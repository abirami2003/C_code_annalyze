/* vim:ts=4:et:ai:ci:sw=4
*/
/*******************************************************************************
 *File Name :oam_populate_func.c
 *
 *Description : This file contains functions to read values from xml file
 *              
 *
 *Revision Histroy:
 *
 *Date            Author      	References        	  Comments
 *------          --------    	------------     	  -------------
 *May,2012        KAPIL TAWAR	OAM Design Document	  Initial Version
 *
 * September,2013 Neeraj Kumar    OAM Design Doc         Changes related to HM
 * September,2013 Vinod Vyas      OAM Design Doc         Changes related to IPV6
 * Nov, 2013      Vinod Vyas                             CSR 00051709 Fix 
 * Jan, 2014      Ravi Gupta                             CSR 00058940 Fix
 * March, 2014    Vinod Vyas                             CSR 00058157 Fix 
 * JAN, 2014      Ankita Jain                            SRVCC, FAPI error handling
 * April, 2014    Dinesh Dua, Pawan Kumar                CSR 00070293 Fix 
 * April, 2014    Ankita Jain                            CSR 00058157 Fix 
 * April, 2014    Ravi Gupta                             SPR 10551 Fix
 * April, 2014    RAVI GUPTA                             SPR 10713 FIX
 * May 2014       Shalu Sagar                            SPR 11311 FIX
 * MAY 2014       Ekta Jain                              BUG 11374 FIX
 * MAY 2014       Ankita Jain                            SPR 11423 FIX
 * May, 2014	    Avinash 		    SPR 11090 Fix
 * May, 2014      Ankita Jain      coverity fixes
 * May, 2014      Ankita Jain      SPR-11454 FIX
 * JUNE 2014      Aditi Singh                            SPR 11599 FIX   
 * JUN 2014       Shalu Sagar                            SPR 11500 FIX
 * June, 2014        Vivek K Gupta  Release 3.0         Changes for xml 
 *                                                      add/delete frwk code
 *June 2014        Shalu Sagar                          Coverity Fix
 * June, 2014     Ankita Jain      SPR-11622 FIX
 * June,2014     Aditi Singh                             SPR 11121 Changes
 * June, 2014     Ankita Jain      SPR-11757 FIX
 * June, 2014     Ekta Jain        SPR-11444 FIX
 * June, 2014     Vinod Vyas       SPR-12096 FIX
 * July, 2014     Avinash Kumar    SPR-11953 FIX
 * June 2014        Shalu Sagar    Coverity FIx
 * June 2014        Ekta Jain      SPR 11444 Fix
 * June, 2014     Avinash          SPR 11892 Fix
 * June, 2014     Avinash          SPR 12228 Fix
 * June, 2014     Mayank Kumar     SPR 11780 Fix
 * June,2014      Avinash Kumar    SPR 11315 FIx
 * June 2014      Shalu Sagar      SPR 11564 Fix
 * June,2014      Avinash Kumar    SPR 12175 FIx
 * June 2014      Shalu Sagar      SPR 12185 FIX
 * July 2014      Avinash Kumar    SPR 12487 FIX
 * July 2014      Shalu Sagar      SPR 12367 FIX
 * July 2014      Aditi, Mayank    SPR 9464 FIX 
 * July,2014      Swetank Srivastava             SPR 12410 FIx
 * July,2014      Avinash Kumar                  SPR 12900 FIx
 * July,2014      Swetank Srivastava           SPR 12926 FIx
 * Aug 2014       Shalu Sagar           SPR 12987 Fix
 * Aug,2014       Aditi Singh       SPR 13065  
 * Aug 2014       Shalu Sagar       SPR4 12673
 * Aug,2014       Ankita Jain       SPR 13074  
 * Aug,2014       Ankita Jain       SPR 13407  
 * Aug,2014       Deepak Kumar      SPR 13417, LTE Interfreq DAHO Cell Addition FIX 
 * Oct 2014       Ankita Jain       SPR 13586
 * Oct 2014       Ankita Jain       SPR 13171
 * Oct 2014       Ankita Jain       SPR 13846
 * Oct 2014       Ankita Jain       SPR 13847
 * Sep 2014       Vinod Vyas        Changes Related to eICIC 
 * Sep 2014       Karuna            eICIC Enhancement
 *Copyright (c) 2014, Aricent Inc. All Rights Reserved
 ******************************************************************************/


/*******************************************************************************
 * Project Includes
 ******************************************************************************/
#include "oam_xml_header.h"
#include "oam_types.h"
#include "oam_defines.h"
#include "oam_proto.h"
#include "oam_sim.h"
#include "oam_sim_utils.h"
#include "lteMacOAMInterface.h"
#include <oam_fm_alarm_defs.h>
#include <oam_fault_mgmt.h>
#include "oam_xml_enum.h"
#ifdef LTE_EMBMS_SUPPORTED
#include "oam_embms_proto.h"
#endif

/*SPR 21889 +- */

extern oam_sim_table_t g_oam_sim_t;
/* SPR 21958 PUSCH RAT1 Support Start */
UInt8 tti_bundling_flag[OAM_MAX_CELL_SUPPORTED];
UInt8 icic_flag[OAM_MAX_CELL_SUPPORTED];
UInt8 fss_flag[OAM_MAX_CELL_SUPPORTED];
UInt8 sps_flag[OAM_MAX_CELL_SUPPORTED];
UInt8 ca_eligible_flag[OAM_MAX_CELL_SUPPORTED];
UInt8 duplex_mode_flag;
/* SPR 22548 Fix Start */
UInt8 dl_num_rbs[OAM_MAX_CELL_SUPPORTED];
UInt8 ul_num_rbs[OAM_MAX_CELL_SUPPORTED];
/* SPR 22548 Fix End */
/* SPR 21958 PUSCH RAT1 Support End */


/* changes for param mapping**/
/* structure for String to Integer mapping */
/*BUG 1248 FIX START*/
rrm_bool_et cell_to_be_started_by_operator = RRM_FALSE;
/*BUG 1248 FIX END*/
extern char ipTable[OAM_FOUR][OAM_SIXTEEN];
extern char ipTablev6[OAM_FOUR][OAM_THIRTY_NINE];
UInt8 sig_count=OAM_ZERO;
UInt8 sig_server=OAM_ZERO;

struct XML_struct_tr196 xml_struct_tr196_g_tr[OAM_MAX_CELL_SUPPORTED]; 
struct XML_struct xml_struct_g_prop[OAM_MAX_CELL_SUPPORTED]; 

UInt8 nnsf_flag = OAM_FALSE;
/* SPR 12932 FIX START */
SInt8 daho_umts_cell_cnt = -1;
oam_bool_et umts_daho_found_flag = OAM_FALSE;
/* SPR-10462 End*/
SInt8 daho_lte_cell_cnt = -1;
oam_bool_et lte_daho_found_flag = OAM_FALSE;
/* SPR 12932 FIX END */

extern xml_struct_nw_scan_t xml_struct_nw_scan;
/* SPR 21040 FIXED START*/
UInt64 oam_max_num_rbs_value;
/* SPR 21040 FIXED END*/

/*SPR 21096 Start*/
typedef struct{
    UInt8 instance_id_flag;
    UInt8 init_cell_cnt;
}oam_l2_instance_flag_t;
/*SPR 21096 End*/
/* START SPR_7554_FIX */
/* SPR 12175 FIX START */
UInt64 lclTemp_value3;
/* SPR 12175 FIX END */
/* SPR19679:TDD HARQ Multiplexing Changes Start */
#define HARQ_MULTIPLEXING 1
#define UL_DL_CONFIG_5 5
/* SPR19679:TDD HARQ Multiplexing Changes End */
/* SPR 23209 Fix Start */
void
oam_update_l2_mac_init_mocn_param(
oam_rrm_cell_config_req_t  *p_rrm_cellconfig,
/* SPR 23504/SES-341 Fix Start */
oam_l2_req_t               *p_mac_req,
UInt8                      l2_cell_index,
UInt8                      oam_cell_index   
/* SPR 23504/SES-341 Fix End */
);
/* SPR 23209 Fix End */

/*SPR 21889 Start*/
/****************************************************************************
 * Gloabal structure  : g_oam_bin_name_mapping_table
 * Description        : Process table defining mapping between nick name given
 *                      by user in the xml file and the actual name of the
 *                      binary generated through compilation
 *******************************************************************************/
oam_bin_map_name_tbl_t g_oam_bin_name_mapping_table [] = 
{
    {OAM_AGENT_NICK_NAME, OAM_AGENT_BIN_NAME},
    {OAM_MAC_RLC_NICK_NAME, OAM_L2_BIN_NAME},
    {OAM_L2_NICK_NAME, OAM_L2_BIN_NAME},
    {OAM_PDCP_SPLIT_NICK_NAME, OAM_PDCP_BIN_NAME},
    {OAM_EGTPU_NICK_NAME, OAM_EGTPU_BIN_NAME},
    {OAM_TR069_NICK_NAME, OAM_TR069_BIN_NAME},
    {OAM_QCLI_NICK_NAME, OAM_QCLI_BIN_NAME},
    {OAM_RRM_NICK_NAME, OAM_RRM_BIN_NAME},
    {OAM_SON_NICK_NAME, OAM_SON_BIN_NAME},
    {OAM_L3_NICK_NAME, OAM_L3_BIN_NAME}
};
/*SPR 21889 End */

int NUM_ANTENNA_PORT[OAM_TWO][OAM_THREE] = 
{
    {1, 2, 4},
    {AN1,
        AN2,
        AN4,
    }};
/* END SPR_7554_FIX */

enumerated_string_fields_mapping_tbl_t Action_load[OAM_ELEVEN]={{"ACTN_NONE",RRMCM_ACTN_NONE},
    {"ACTN_HANDOVER",RRMCM_ACTN_HANDOVER},
    {"ACTN_ACC_CLS_BARRING",RRMCM_ACTN_AC_BARRING},
    {"ACTN_STOP_ADM",RRMCM_ACTN_STOP_ADM},
    {"ACTN_REL_UE_CARR_REDIRECT",RRMCM_ACTN_REL_UE_CARR_REDIRECT},
    {"ACTN_REL_UE",RRMCM_ACTN_REL_UE},
    {"ACTN_AQM",RRMCM_ACTN_AQM},
    {"ACTN_RRM_ECN_UL_DIR",RRMCM_ACTN_RRM_ECN_UL_DIR},
    {"ACTN_RRM_ECN_DL_DIR",RRMCM_ACTN_RRM_ECN_DL_DIR},
    {"ACTN_RRM_ECN_BI_DIR",RRMCM_ACTN_RRM_ECN_BI_DIR},
    {"ACTN_MAX",RRMCM_ACTN_MAX}};

enumerated_string_fields_mapping_tbl_t hoppingMode[OAM_TWO] = {{"InterSubFrame",RRM_OAM_HM_INTER_SF},
    {"IntraAndInterSubFrame",RRM_OAM_HM_INTRA_AND_INTER_SF}};

enumerated_string_fields_mapping_tbl_t QoS_LogicalChannelType[OAM_TWO] = {{"GBR",QOS_GBR},
    {"Non-GBR",NON_GBR}};


enumerated_string_fields_mapping_tbl_t DLBandwidth[OAM_SIX] = {{"n6",RRM_OAM_BW_N_6},
    {"n15",RRM_OAM_BW_N_15},
    {"n25",RRM_OAM_BW_N_25},
    {"n50",RRM_OAM_BW_N_50},
    {"n75",RRM_OAM_BW_N_75},
    {"n100",RRM_OAM_BW_N_100}};

enumerated_string_fields_mapping_tbl_t UlBandwidth[OAM_SIX] = {{"n6",RRM_OAM_BW_N_6},
    {"n15",RRM_OAM_BW_N_15},
    {"n25",RRM_OAM_BW_N_25},
    {"n50",RRM_OAM_BW_N_50},
    {"n75",RRM_OAM_BW_N_75},
    {"n100",RRM_OAM_BW_N_100}};
enumerated_string_fields_mapping_tbl_t srsBandwidthConfig[OAM_EIGHT] = {{"bw0", RRM_OAM_SRS_BW_CONFIG_BW0},
    {"bw1",RRM_OAM_SRS_BW_CONFIG_BW1},
    {"bw2",RRM_OAM_SRS_BW_CONFIG_BW2},
    {"bw3",RRM_OAM_SRS_BW_CONFIG_BW3},
    {"bw4",RRM_OAM_SRS_BW_CONFIG_BW4},
    {"bw5",RRM_OAM_SRS_BW_CONFIG_BW5},
    {"bw6",RRM_OAM_SRS_BW_CONFIG_BW6},
    {"bw7",RRM_OAM_SRS_BW_CONFIG_BW7}};
enumerated_string_fields_mapping_tbl_t DeltaPUCCHShift[OAM_THREE]={{"ds1",OAM_ZERO},
    {"ds2",OAM_ONE},
    {"ds3",OAM_TWO}};


enumerated_string_fields_mapping_tbl_t
access_mode_str_enum_tbl[3] = {
    {"ClosedAccess", RRM_OAM_ACCESS_MODE_CLOSE},
    {"HybridAccess", RRM_OAM_ACCESS_MODE_HYBRID},
    {"OpenAccess",   RRM_OAM_ACCESS_MODE_OPEN}
};


/* CSR 00070293 FIX START */

#ifdef OAM_SON_ENABLE
enumerated_string_fields_mapping_tbl_t
SON_GSM_BANDINDICATOR[OAM_SON_GSM_BANDINDICATOR_TBL_NUM_ROWS] = {
    { "DCS1800", SON_GERAN_DCS_1800 },
    { "PCS1900", SON_GERAN_PCS_1900 }
};
#endif

/* CSR_00088568_FIX Start */
/* CSR_00088568_FIX End */
enumerated_string_fields_mapping_tbl_t
RRM_GSM_BANDINDICATOR[OAM_RRM_GSM_BAND_IND_TBL_NUM_ROWS] = {
    /* SPR_CHANGES */
    /* Code Removed Here */
    /* SPR_CHANGES */
    { "DCS1800", DCS_1800 },
    { "PCS1900", PCS_1900 }
};
/* CSR_00088568_FIX Start */
/* CSR_00088568_FIX End */

/* CSR 00070293 FIX END */

enumerated_string_fields_mapping_tbl_t RRM_GERANFREQ_BANDINDICATOR[OAM_TWO]=
{{"DCS1800",RRM_OAM_DCS1800},
    {"PCS1900",RRM_OAM_PCS1900}};


enumerated_string_fields_mapping_tbl_t
scell_deact_timer_map[OAM_SCELL_DEACT_TIMER_MAP_MAX_LEN] = {
    {"RF2", RRM_OAM_SCELL_RF2},
    {"RF4", RRM_OAM_SCELL_RF4},
    {"RF8", RRM_OAM_SCELL_RF8},
    {"RF16", RRM_OAM_SCELL_RF16},
    {"RF32", RRM_OAM_SCELL_RF32},
    {"RF64", RRM_OAM_SCELL_RF64},
    {"RF128", RRM_OAM_SCELL_RF128},
    {"RFinf", RRM_OAM_SCELL_RFINFINITY}
};
enumerated_string_fields_mapping_tbl_t
meas_cycle_scell_enum_tbl[OAM_MEAS_CYCLE_SCELL_LEN] = {
    {"SF160", RRM_OAM_MEAS_CYCL_SCELL_SF160},
    {"SF256", RRM_OAM_MEAS_CYCL_SCELL_SF256},
    {"SF320", RRM_OAM_MEAS_CYCL_SCELL_SF320},
    {"SF512", RRM_OAM_MEAS_CYCL_SCELL_SF512},
    {"SF640", RRM_OAM_MEAS_CYCL_SCELL_SF640},
    {"SF1024", RRM_OAM_MEAS_CYCL_SCELL_SF1024},
    {"SF1280", RRM_OAM_MEAS_CYCL_SCELL_SF1280}
};

/* CSR 00070293 FIX START */
int RRM_CELL_TRESELECTIONSF[OAM_TWO][OAM_FOUR] = 
/* CSR 00070293 FIX END*/
{
    {25, 50, 75, 100},
    { RRM_OAM_O_DOT_25,
        RRM_OAM_O_DOT_5,
        RRM_OAM_O_DOT_75,
        RRM_OAM_l_DOT_0 }
};

int RAN_PHY_ULPowerControl_Alpha[OAM_TWO][OAM_EIGHT] = 
{{0, 40, 50, 60, 70, 80, 90, 100},{
    RRM_OAM_AL_0,
    RRM_OAM_AL_0_4,
    RRM_OAM_AL_0_5,
    RRM_OAM_AL_0_6,
    RRM_OAM_AL_0_7,
    RRM_OAM_AL_0_8,
    RRM_OAM_AL_0_9,
    RRM_OAM_AL_1}};

int RAN_PHY_PRS_NumConsecutivePRSSubfames[OAM_TWO][OAM_FOUR] = 
{{1, 2, 4, 6},{
    RRM_OAM_NUM_CONS_PRS_SF_N1,
    RRM_OAM_NUM_CONS_PRS_SF_N2,
    RRM_OAM_NUM_CONS_PRS_SF_N4,
    RRM_OAM_NUM_CONS_PRS_SF_N6}};

int RAN_MAC_RACH_NumberOfRaPreambles[OAM_TWO][OAM_SIXTEEN] = 
{{
    4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64},{
        RRM_OAM_RA_PREAMBLE_COUNT_N4,
        RRM_OAM_RA_PREAMBLE_COUNT_N8,
        RRM_OAM_RA_PREAMBLE_COUNT_N12,
        RRM_OAM_RA_PREAMBLE_COUNT_N16,
        RRM_OAM_RA_PREAMBLE_COUNT_N20,
        RRM_OAM_RA_PREAMBLE_COUNT_N24,
        RRM_OAM_RA_PREAMBLE_COUNT_N28,
        RRM_OAM_RA_PREAMBLE_COUNT_N32,
        RRM_OAM_RA_PREAMBLE_COUNT_N36,
        RRM_OAM_RA_PREAMBLE_COUNT_N40,
        RRM_OAM_RA_PREAMBLE_COUNT_N44,
        RRM_OAM_RA_PREAMBLE_COUNT_N48,
        RRM_OAM_RA_PREAMBLE_COUNT_N52,
        RRM_OAM_RA_PREAMBLE_COUNT_N56,
        RRM_OAM_RA_PREAMBLE_COUNT_N60,
        RRM_OAM_RA_PREAMBLE_COUNT_N64
    }};

int RAN_MAC_RACH_sizeOfRaGroupA[OAM_TWO][OAM_FIFTEEN] = 
{{
    4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60},{
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N4,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N8,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N16,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N20,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N24,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N28,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N32,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N36,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N40,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N44,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N48,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N52,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N56,
        RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N60
    }};

int RAN_MAC_RACH_messageSizeGroupA[OAM_TWO][OAM_FOUR] = 
{{
    56, 144, 208, 256},{
        RRM_OAM_GROUP_A_MSG_SIZE_B56,
        RRM_OAM_GROUP_A_MSG_SIZE_B144,
        RRM_OAM_GROUP_A_MSG_SIZE_B208,
        RRM_OAM_GROUP_A_MSG_SIZE_B256
    }};

int RAN_MAC_RACH_messagePowerOffsetGroupB[OAM_TWO][OAM_EIGHT] = 
{{-1, 0, 5, 8, 10, 12, 15, 18},{
    RRM_OAM_GROUP_B_MSG_POWER_OFFSET_MINUSINFINITY,
    RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB0,
    RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB5,
    RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB8,
    RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB10,
    RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB12,
    RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB15,
    RRM_OAM_GROUP_B_MSG_POWER_OFFSET_DB18
                               }};
int RAN_MAC_RACH_powerRampingStep[OAM_TWO][OAM_FOUR] = 
{
    {0, 2, 4, 6},
    {RRM_OAM_POWER_RAMP_STEP_DB0,
        RRM_OAM_POWER_RAMP_STEP_DB2,
        RRM_OAM_POWER_RAMP_STEP_DB4,
        RRM_OAM_POWER_RAMP_STEP_DB6
    }};

int RAN_MAC_RACH_preambleInitialReceivedTargetPower[OAM_TWO][OAM_SIXTEEN] = 
{  
    {-120, -118, -116, -114, -112, -110, -108, -106, -104, -102, -100, -98, -96, -94, -92, -90},
    {RRM_OAM_PREAMBLE_POWER_DBM_120,
        RRM_OAM_PREAMBLE_POWER_DBM_118,
        RRM_OAM_PREAMBLE_POWER_DBM_116,
        RRM_OAM_PREAMBLE_POWER_DBM_114,
        RRM_OAM_PREAMBLE_POWER_DBM_112,
        RRM_OAM_PREAMBLE_POWER_DBM_110,
        RRM_OAM_PREAMBLE_POWER_DBM_108,
        RRM_OAM_PREAMBLE_POWER_DBM_106,
        RRM_OAM_PREAMBLE_POWER_DBM_104,
        RRM_OAM_PREAMBLE_POWER_DBM_102,
        RRM_OAM_PREAMBLE_POWER_DBM_100,
        RRM_OAM_PREAMBLE_POWER_DBM_98,
        RRM_OAM_PREAMBLE_POWER_DBM_96,
        RRM_OAM_PREAMBLE_POWER_DBM_94,
        RRM_OAM_PREAMBLE_POWER_DBM_92,
        RRM_OAM_PREAMBLE_POWER_DBM_90}
};

int RAN_MAC_RACH_preambleTransMax[OAM_TWO][OAM_ELEVEN] = 
{
    {3, 4, 5, 6, 7, 8, 10, 20, 50, 100, 200},
    {RRM_OAM_PREAMBLE_TRANS_MAX_N3,
        RRM_OAM_PREAMBLE_TRANS_MAX_N4,
        RRM_OAM_PREAMBLE_TRANS_MAX_N5,
        RRM_OAM_PREAMBLE_TRANS_MAX_N6,
        RRM_OAM_PREAMBLE_TRANS_MAX_N7,
        RRM_OAM_PREAMBLE_TRANS_MAX_N8,
        RRM_OAM_PREAMBLE_TRANS_MAX_N10,
        RRM_OAM_PREAMBLE_TRANS_MAX_N20,
        RRM_OAM_PREAMBLE_TRANS_MAX_N50,
        RRM_OAM_PREAMBLE_TRANS_MAX_N100,
        RRM_OAM_PREAMBLE_TRANS_MAX_N200
    }};

int RAN_MAC_RACH_ResponseWindowSize[OAM_TWO][OAM_EIGHT] = 
{
    {2, 3, 4, 5, 6, 7, 8, 10},
    {RRM_OAM_RA_RESP_WIN_SIZE_SF2,
        RRM_OAM_RA_RESP_WIN_SIZE_SF3,
        RRM_OAM_RA_RESP_WIN_SIZE_SF4,
        RRM_OAM_RA_RESP_WIN_SIZE_SF5,
        RRM_OAM_RA_RESP_WIN_SIZE_SF6,
        RRM_OAM_RA_RESP_WIN_SIZE_SF7,
        RRM_OAM_RA_RESP_WIN_SIZE_SF8,
        RRM_OAM_RA_RESP_WIN_SIZE_SF10}
};

int RAN_MAC_RACH_ContentionResolutionTimer[OAM_TWO][OAM_EIGHT] = 
{
    {8, 16, 24, 32, 40, 48, 56, 64},
    {RRM_OAM_MAC_CONT_RES_TIMER_SF8,
        RRM_OAM_MAC_CONT_RES_TIMER_SF16,
        RRM_OAM_MAC_CONT_RES_TIMER_SF24,
        RRM_OAM_MAC_CONT_RES_TIMER_SF32,
        RRM_OAM_MAC_CONT_RES_TIMER_SF40,
        RRM_OAM_MAC_CONT_RES_TIMER_SF48,
        RRM_OAM_MAC_CONT_RES_TIMER_SF56,
        RRM_OAM_MAC_CONT_RES_TIMER_SF64}
};

/* SPR 21411 changes start */
/* Added INVALID_VALUE 65535 in below mentioned enums */
/* SPR 21737 Start */
int RAN_MAC_DRX_OnDurationTimer[OAM_TWO][ONDURATIONTIMER_COUNT] = 
/* SPR 21737 End */
{
    {1, 2, 3, 4, 5, 6, 8, 10, 20, 30, 40, 50, 60, 80, 100, 200, 65535},
    {RRM_OAM_ON_DURATION_TIMER_PSF_1,
        RRM_OAM_ON_DURATION_TIMER_PSF_2,
        RRM_OAM_ON_DURATION_TIMER_PSF_3,
        RRM_OAM_ON_DURATION_TIMER_PSF_4,
        RRM_OAM_ON_DURATION_TIMER_PSF_5,
        RRM_OAM_ON_DURATION_TIMER_PSF_6,
        RRM_OAM_ON_DURATION_TIMER_PSF_8,
        RRM_OAM_ON_DURATION_TIMER_PSF_10,
        RRM_OAM_ON_DURATION_TIMER_PSF_20,
        RRM_OAM_ON_DURATION_TIMER_PSF_30,
        RRM_OAM_ON_DURATION_TIMER_PSF_40,
        RRM_OAM_ON_DURATION_TIMER_PSF_50,
        RRM_OAM_ON_DURATION_TIMER_PSF_60,
        RRM_OAM_ON_DURATION_TIMER_PSF_80,
        RRM_OAM_ON_DURATION_TIMER_PSF_100,
        RRM_OAM_ON_DURATION_TIMER_PSF_200,
        RRM_OAM_ON_DURATION_TIMER_INVALID}
};

/* SPR 21737 Start */
int RAN_MAC_DRX_drxInactivityTimer[OAM_TWO][DRXINACTIVITYTIMER_COUNT] = 
/* SPR 21737 End */
{
    {1, 2, 3, 4, 5, 6, 8, 10, 20, 30, 40, 50, 60, 80, 100, 200, 300, 500, 750, 1280, 1920, 2560, 0, 65535},
    { RRM_OAM_DRX_INACTIVITY_TIMER_PSF_1,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_2,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_3,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_4,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_5,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_6,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_8,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_10,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_20,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_30,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_40,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_50,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_60,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_80,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_100,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_200,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_300,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_500,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_750,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_1280,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_1920,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_2560,
        RRM_OAM_DRX_INACTIVITY_TIMER_PSF_0_V1020,
        RRM_OAM_DRX_INACTIVITY_TIMER_INVALID}
};

/* SPR 21737 Start */
int RAN_MAC_DRX_drxRetransmissionTimer[OAM_TWO][DRXRETRANSMISSIONTIMER_COUNT] = 
/* SPR 21737 End */
{
    {1, 2, 4, 6, 8, 16, 24, 33, 65535},
    {RRM_OAM_DRX_RETRANS_TIMER_PSF_1,
        RRM_OAM_DRX_RETRANS_TIMER_PSF_2,
        RRM_OAM_DRX_RETRANS_TIMER_PSF_4,
        RRM_OAM_DRX_RETRANS_TIMER_PSF_6,
        RRM_OAM_DRX_RETRANS_TIMER_PSF_8,
        RRM_OAM_DRX_RETRANS_TIMER_PSF_16,
        RRM_OAM_DRX_RETRANS_TIMER_PSF_24,
        RRM_OAM_DRX_RETRANS_TIMER_PSF_33,
        RRM_OAM_DRX_RETRANS_TIMER_INVALID}
};

/* SPR 21737 Start */
int RAN_MAC_DRX_longDRXCycle[OAM_TWO][LONGDRXCYCLE_COUNT] = 
/* SPR 21737 End */
{
    {10, 20, 32, 40, 64, 80, 128, 160, 256, 320, 512, 640, 1024, 1280, 2048, 2560, 65535},
    { RRM_OAM_SF10,
        RRM_OAM_SF20,
        RRM_OAM_SF32,
        RRM_OAM_SF40,
        RRM_OAM_SF64,
        RRM_OAM_SF80,
        RRM_OAM_SF128,
        RRM_OAM_SF160,
        RRM_OAM_SF256,
        RRM_OAM_SF320,
        RRM_OAM_SF512,
        RRM_OAM_SF640,
        RRM_OAM_SF1024,
        RRM_OAM_SF1280,
        RRM_OAM_SF2048,
        RRM_OAM_SF2560,
        RRM_OAM_INVALID}
};

#ifdef ENDC_ENABLED
int RAN_MAC_DRX_longDRXCycleR15[OAM_TWO][LONGDRXCYCLE_COUNT_R15] = 
{
    {10, 20, 32, 40, 64, 80, 128, 160, 256, 320, 512, 640, 1024, 1280, 2048, 2560, 5120, 10240, 65535},
    { RRM_OAM_R15_SF10,
        RRM_OAM_R15_SF20,
        RRM_OAM_R15_SF32,
        RRM_OAM_R15_SF40,
        RRM_OAM_R15_SF64,
        RRM_OAM_R15_SF80,
        RRM_OAM_R15_SF128,
        RRM_OAM_R15_SF160,
        RRM_OAM_R15_SF256,
        RRM_OAM_R15_SF320,
        RRM_OAM_R15_SF512,
        RRM_OAM_R15_SF640,
        RRM_OAM_R15_SF1024,
        RRM_OAM_R15_SF1280,
        RRM_OAM_R15_SF2048,
        RRM_OAM_R15_SF2560,
        RRM_OAM_R15_SF5120,
        RRM_OAM_R15_SF10240,
        RRM_OAM_R15_INVALID}
};
#endif

/* SPR 21737 Start */
int RAN_MAC_DRX_shortDRXCycle[OAM_TWO][DRXSHORTCYCLE_COUNT] = 
/* SPR 21737 End */
{
    {2, 5, 8, 10, 16, 20, 32, 40, 64, 80, 128, 160, 256, 320, 512, 640, 65535},
    {  RRM_OAM_SHORT_DRX_CYCLE_SF_2,
        RRM_OAM_SHORT_DRX_CYCLE_SF_5,
        RRM_OAM_SHORT_DRX_CYCLE_SF_8,
        RRM_OAM_SHORT_DRX_CYCLE_SF_10,
        RRM_OAM_SHORT_DRX_CYCLE_SF_16,
        RRM_OAM_SHORT_DRX_CYCLE_SF_20,
        RRM_OAM_SHORT_DRX_CYCLE_SF_32,
        RRM_OAM_SHORT_DRX_CYCLE_SF_40,
        RRM_OAM_SHORT_DRX_CYCLE_SF_64,
        RRM_OAM_SHORT_DRX_CYCLE_SF_80,
        RRM_OAM_SHORT_DRX_CYCLE_SF_128,
        RRM_OAM_SHORT_DRX_CYCLE_SF_160,
        RRM_OAM_SHORT_DRX_CYCLE_SF_256,
        RRM_OAM_SHORT_DRX_CYCLE_SF_320,
        RRM_OAM_SHORT_DRX_CYCLE_SF_512,
        RRM_OAM_SHORT_DRX_CYCLE_SF_640,
        RRM_OAM_SHORT_DRX_CYCLE_INVALID}
};
/* SPR 21411 changes end */

int RAN_RLC_SRB1_TPollRetransmit[OAM_TWO][OAM_FIFTY_FIVE] = {
    {5, 10, 15, 20, 25, 30, 35, 40, 45,
        50, 55, 60, 65, 70, 75, 80, 85, 90,
        95, 100, 105, 110, 115, 120, 125, 130,
        135, 140, 145, 150, 155, 160, 165, 170,
        175, 180, 185, 190, 195, 200, 205, 210,
        215, 220, 225, 230, 235, 240, 245, 250,
        300, 350, 400, 450, 500},
    {RRM_OAM_POLL_RETRAS_MS_5,
        RRM_OAM_POLL_RETRAS_MS_10,
        RRM_OAM_POLL_RETRAS_MS_15,
        RRM_OAM_POLL_RETRAS_MS_20,
        RRM_OAM_POLL_RETRAS_MS_25,
        RRM_OAM_POLL_RETRAS_MS_30,
        RRM_OAM_POLL_RETRAS_MS_35,
        RRM_OAM_POLL_RETRAS_MS_40,
        RRM_OAM_POLL_RETRAS_MS_45,
        RRM_OAM_POLL_RETRAS_MS_50,
        RRM_OAM_POLL_RETRAS_MS_55,
        RRM_OAM_POLL_RETRAS_MS_60,
        RRM_OAM_POLL_RETRAS_MS_65,
        RRM_OAM_POLL_RETRAS_MS_70,
        RRM_OAM_POLL_RETRAS_MS_75,
        RRM_OAM_POLL_RETRAS_MS_80,
        RRM_OAM_POLL_RETRAS_MS_85,
        RRM_OAM_POLL_RETRAS_MS_90,
        RRM_OAM_POLL_RETRAS_MS_95,
        RRM_OAM_POLL_RETRAS_MS_100,
        RRM_OAM_POLL_RETRAS_MS_105,
        RRM_OAM_POLL_RETRAS_MS_110,
        RRM_OAM_POLL_RETRAS_MS_115,
        RRM_OAM_POLL_RETRAS_MS_120,
        RRM_OAM_POLL_RETRAS_MS_125,
        RRM_OAM_POLL_RETRAS_MS_130,
        RRM_OAM_POLL_RETRAS_MS_135,
        RRM_OAM_POLL_RETRAS_MS_140,
        RRM_OAM_POLL_RETRAS_MS_145,
        RRM_OAM_POLL_RETRAS_MS_150,
        RRM_OAM_POLL_RETRAS_MS_155,
        RRM_OAM_POLL_RETRAS_MS_160,
        RRM_OAM_POLL_RETRAS_MS_165,
        RRM_OAM_POLL_RETRAS_MS_170,
        RRM_OAM_POLL_RETRAS_MS_175,
        RRM_OAM_POLL_RETRAS_MS_180,
        RRM_OAM_POLL_RETRAS_MS_185,
        RRM_OAM_POLL_RETRAS_MS_190,
        RRM_OAM_POLL_RETRAS_MS_195,
        RRM_OAM_POLL_RETRAS_MS_200,
        RRM_OAM_POLL_RETRAS_MS_205,
        RRM_OAM_POLL_RETRAS_MS_210,
        RRM_OAM_POLL_RETRAS_MS_215,
        RRM_OAM_POLL_RETRAS_MS_220,
        RRM_OAM_POLL_RETRAS_MS_225,
        RRM_OAM_POLL_RETRAS_MS_230,
        RRM_OAM_POLL_RETRAS_MS_235,
        RRM_OAM_POLL_RETRAS_MS_240,
        RRM_OAM_POLL_RETRAS_MS_245,
        RRM_OAM_POLL_RETRAS_MS_250,
        RRM_OAM_POLL_RETRAS_MS_300,
        RRM_OAM_POLL_RETRAS_MS_350,
        RRM_OAM_POLL_RETRAS_MS_400,
        RRM_OAM_POLL_RETRAS_MS_450,
        RRM_OAM_POLL_RETRAS_MS_500
    } };

int RAN_RLC_SRB1_pollPDU[OAM_TWO][OAM_EIGHT] =
{ 
    {4, 8, 16, 32, 64, 128, 256, 0},
    {  RRM_OAM_POLL_PDU_4,
        RRM_OAM_POLL_PDU_8,
        RRM_OAM_POLL_PDU_16,
        RRM_OAM_POLL_PDU_32,
        RRM_OAM_POLL_PDU_64,
        RRM_OAM_POLL_PDU_128,
        RRM_OAM_POLL_PDU_256,
        RRM_OAM_POLL_PDU_INFINITY
    }};

int RAN_RLC_SRB1_pollByte[OAM_TWO][OAM_FIFTEEN] = 
{
    { 25, 50, 75, 100, 125, 250, 375, 
        500, 750, 1000, 1250, 1500, 2000, 3000, OAM_ZERO},
    { RRM_OAM_POLL_BYTE_KB_25,
        RRM_OAM_POLL_BYTE_KB_50,
        RRM_OAM_POLL_BYTE_KB_75,
        RRM_OAM_POLL_BYTE_KB_100,
        RRM_OAM_POLL_BYTE_KB_125,
        RRM_OAM_POLL_BYTE_KB_250,
        RRM_OAM_POLL_BYTE_KB_375,
        RRM_OAM_POLL_BYTE_KB_500,
        RRM_OAM_POLL_BYTE_KB_750,
        RRM_OAM_POLL_BYTE_KB_1000,
        RRM_OAM_POLL_BYTE_KB_1250,
        RRM_OAM_POLL_BYTE_KB_1500,
        RRM_OAM_POLL_BYTE_KB_2000,
        RRM_OAM_POLL_BYTE_KB_3000,
        RRM_OAM_POLL_BYTE_KB_INFINITY
    } };

int RAN_RLC_SRB1_MaxRetxThreshold[OAM_TWO][OAM_EIGHT] = 
{  
    {  1, 2, 3, 4, 6, 8, 16, 32},
    {  RRM_OAM_MAX_RETRANS_THRESH_1,
        RRM_OAM_MAX_RETRANS_THRESH_2,
        RRM_OAM_MAX_RETRANS_THRESH_3,
        RRM_OAM_MAX_RETRANS_THRESH_4,
        RRM_OAM_MAX_RETRANS_THRESH_6,
        RRM_OAM_MAX_RETRANS_THRESH_8,
        RRM_OAM_MAX_RETRANS_THRESH_16,
        RRM_OAM_MAX_RETRANS_THRESH_32}
};

int RAN_RLC_SRB1_TReordering[OAM_TWO][OAM_THIRTY_ONE] = 
{{0, 5, 10, 15, 20, 25, 30,
    35, 40, 45, 50, 55, 60, 65, 
    70, 75, 80, 85, 90, 95, 100, 
    110, 120, 130, 140, 150, 160,
    170, 180, 190, 200},
{ RRM_OAM_T_REORDER_MS_0,
    RRM_OAM_T_REORDER_MS_5,
    RRM_OAM_T_REORDER_MS_10,
    RRM_OAM_T_REORDER_MS_15,
    RRM_OAM_T_REORDER_MS_20,
    RRM_OAM_T_REORDER_MS_25,
    RRM_OAM_T_REORDER_MS_30,
    RRM_OAM_T_REORDER_MS_35,
    RRM_OAM_T_REORDER_MS_40,
    RRM_OAM_T_REORDER_MS_45,
    RRM_OAM_T_REORDER_MS_50,
    RRM_OAM_T_REORDER_MS_55,
    RRM_OAM_T_REORDER_MS_60,
    RRM_OAM_T_REORDER_MS_65,
    RRM_OAM_T_REORDER_MS_70,
    RRM_OAM_T_REORDER_MS_75,
    RRM_OAM_T_REORDER_MS_80,
    RRM_OAM_T_REORDER_MS_85,
    RRM_OAM_T_REORDER_MS_90,
    RRM_OAM_T_REORDER_MS_95,
    RRM_OAM_T_REORDER_MS_100,
    RRM_OAM_T_REORDER_MS_110,
    RRM_OAM_T_REORDER_MS_120,
    RRM_OAM_T_REORDER_MS_130,
    RRM_OAM_T_REORDER_MS_140,
    RRM_OAM_T_REORDER_MS_150,
    RRM_OAM_T_REORDER_MS_160,
    RRM_OAM_T_REORDER_MS_170,
    RRM_OAM_T_REORDER_MS_180,
    RRM_OAM_T_REORDER_MS_190,
    RRM_OAM_T_REORDER_MS_200
} };

int RAN_RLC_SRB1_TStatusProhibit[OAM_TWO][OAM_FIFTY_SIX] =
{  
    { 0, 5, 10, 15, 20, 25, 30, 35, 40,
        45, 50, 55, 60, 65, 70, 75, 80, 
        85, 90, 95, 100, 105, 110, 115, 120, 
        125, 130, 135, 140, 145, 150, 155,
        160, 165, 170, 175, 180, 185, 190,
        195, 200, 205, 210, 215, 220, 225,
        230, 235, 240, 245, 250, 300, 350,
        400, 450, 500},
    {  RRM_OAM_T_STATUS_PROHB_MS_0,
        RRM_OAM_T_STATUS_PROHB_MS_5,
        RRM_OAM_T_STATUS_PROHB_MS_10,
        RRM_OAM_T_STATUS_PROHB_MS_15,
        RRM_OAM_T_STATUS_PROHB_MS_20,
        RRM_OAM_T_STATUS_PROHB_MS_25,
        RRM_OAM_T_STATUS_PROHB_MS_30,
        RRM_OAM_T_STATUS_PROHB_MS_35,
        RRM_OAM_T_STATUS_PROHB_MS_40,
        RRM_OAM_T_STATUS_PROHB_MS_45,
        RRM_OAM_T_STATUS_PROHB_MS_50,
        RRM_OAM_T_STATUS_PROHB_MS_55,
        RRM_OAM_T_STATUS_PROHB_MS_60,
        RRM_OAM_T_STATUS_PROHB_MS_65,
        RRM_OAM_T_STATUS_PROHB_MS_70,
        RRM_OAM_T_STATUS_PROHB_MS_75,
        RRM_OAM_T_STATUS_PROHB_MS_80,
        RRM_OAM_T_STATUS_PROHB_MS_85,
        RRM_OAM_T_STATUS_PROHB_MS_90,
        RRM_OAM_T_STATUS_PROHB_MS_95,
        RRM_OAM_T_STATUS_PROHB_MS_100,
        RRM_OAM_T_STATUS_PROHB_MS_105,
        RRM_OAM_T_STATUS_PROHB_MS_110,
        RRM_OAM_T_STATUS_PROHB_MS_115,
        RRM_OAM_T_STATUS_PROHB_MS_120,
        RRM_OAM_T_STATUS_PROHB_MS_125,
        RRM_OAM_T_STATUS_PROHB_MS_130,
        RRM_OAM_T_STATUS_PROHB_MS_135,
        RRM_OAM_T_STATUS_PROHB_MS_140,
        RRM_OAM_T_STATUS_PROHB_MS_145,
        RRM_OAM_T_STATUS_PROHB_MS_150,
        RRM_OAM_T_STATUS_PROHB_MS_155,
        RRM_OAM_T_STATUS_PROHB_MS_160,
        RRM_OAM_T_STATUS_PROHB_MS_165,
        RRM_OAM_T_STATUS_PROHB_MS_170,
        RRM_OAM_T_STATUS_PROHB_MS_175,
        RRM_OAM_T_STATUS_PROHB_MS_180,
        RRM_OAM_T_STATUS_PROHB_MS_185,
        RRM_OAM_T_STATUS_PROHB_MS_190,
        RRM_OAM_T_STATUS_PROHB_MS_195,
        RRM_OAM_T_STATUS_PROHB_MS_200,
        RRM_OAM_T_STATUS_PROHB_MS_205,
        RRM_OAM_T_STATUS_PROHB_MS_210,
        RRM_OAM_T_STATUS_PROHB_MS_215,
        RRM_OAM_T_STATUS_PROHB_MS_220,
        RRM_OAM_T_STATUS_PROHB_MS_225,
        RRM_OAM_T_STATUS_PROHB_MS_230,
        RRM_OAM_T_STATUS_PROHB_MS_235,
        RRM_OAM_T_STATUS_PROHB_MS_240,
        RRM_OAM_T_STATUS_PROHB_MS_245,
        RRM_OAM_T_STATUS_PROHB_MS_250,
        RRM_OAM_T_STATUS_PROHB_MS_300,
        RRM_OAM_T_STATUS_PROHB_MS_350,
        RRM_OAM_T_STATUS_PROHB_MS_400,
        RRM_OAM_T_STATUS_PROHB_MS_450,
        RRM_OAM_T_STATUS_PROHB_MS_500
    }};

SInt32
carrier_qoffset_freq_tbl[OAM_PARAM_VAL_ENUM_MAP_TBL_MAX_COL]
[INTERFREQ_CARRIER_QOFFSETFREQ_COUNT] = {
    {-24, -22, -20, -18, -16, -14, -12, -10, -8, -6, -5, -4, -3, -2, -1, 0,
        1, 2, 3, 4, 5, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24},
    { RRM_OAM_Q_OFFESET_RANGE_DB_24,
        RRM_OAM_Q_OFFESET_RANGE_DB_22,
        RRM_OAM_Q_OFFESET_RANGE_DB_20,
        RRM_OAM_Q_OFFESET_RANGE_DB_18,
        RRM_OAM_Q_OFFESET_RANGE_DB_16,
        RRM_OAM_Q_OFFESET_RANGE_DB_14,
        RRM_OAM_Q_OFFESET_RANGE_DB_12,
        RRM_OAM_Q_OFFESET_RANGE_DB_10,
        RRM_OAM_Q_OFFESET_RANGE_DB_8,
        RRM_OAM_Q_OFFESET_RANGE_DB_6,
        RRM_OAM_Q_OFFESET_RANGE_DB_5,
        RRM_OAM_Q_OFFESET_RANGE_DB_4,
        RRM_OAM_Q_OFFESET_RANGE_DB_3,
        RRM_OAM_Q_OFFESET_RANGE_DB_2,
        RRM_OAM_Q_OFFESET_RANGE_DB_1,
        RRM_OAM_Q_OFFESET_RANGE_DB0,
        RRM_OAM_Q_OFFESET_RANGE_DB1,
        RRM_OAM_Q_OFFESET_RANGE_DB2,
        RRM_OAM_Q_OFFESET_RANGE_DB3,
        RRM_OAM_Q_OFFESET_RANGE_DB4,
        RRM_OAM_Q_OFFESET_RANGE_DB5,
        RRM_OAM_Q_OFFESET_RANGE_DB6,
        RRM_OAM_Q_OFFESET_RANGE_DB8,
        RRM_OAM_Q_OFFESET_RANGE_DB10,
        RRM_OAM_Q_OFFESET_RANGE_DB12,
        RRM_OAM_Q_OFFESET_RANGE_DB14,
        RRM_OAM_Q_OFFESET_RANGE_DB16,
        RRM_OAM_Q_OFFESET_RANGE_DB18,
        RRM_OAM_Q_OFFESET_RANGE_DB20,
        RRM_OAM_Q_OFFESET_RANGE_DB22,
        RRM_OAM_Q_OFFESET_RANGE_DB24
    }
};

int RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_TWO][OAM_FOUR] = 
{
    {25,50,75,100},
    {  RRM_OAM_O_DOT_25,
        RRM_OAM_O_DOT_5,
        RRM_OAM_O_DOT_75,
        RRM_OAM_l_DOT_0
    }};

int RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_TWO][OAM_FOUR] = 
{
    {  25,50,75,100},
    {  RRM_OAM_O_DOT_25,
        RRM_OAM_O_DOT_5,
        RRM_OAM_O_DOT_75,
        RRM_OAM_l_DOT_0
    }};

int RAN_RRCTimers_T300[OAM_TWO][OAM_EIGHT] = 
{
    {100, 200, 300, 400, 600, 1000, 1500, 2000},
    {RRM_OAM_TIMER_300_301_MS100,
        RRM_OAM_TIMER_300_301_MS200,
        RRM_OAM_TIMER_300_301_MS300,
        RRM_OAM_TIMER_300_301_MS400,
        RRM_OAM_TIMER_300_301_MS600,
        RRM_OAM_TIMER_300_301_MS1000,
        RRM_OAM_TIMER_300_301_MS1500,
        RRM_OAM_TIMER_300_301_MS2000
    }};

int RAN_RRCTimers_T301[OAM_TWO][OAM_EIGHT] = 
{{100, 200, 300, 400, 600, 1000, 1500, 2000},{
    RRM_OAM_TIMER_300_301_MS100,
    RRM_OAM_TIMER_300_301_MS200,
    RRM_OAM_TIMER_300_301_MS300,
    RRM_OAM_TIMER_300_301_MS400,
    RRM_OAM_TIMER_300_301_MS600,
    RRM_OAM_TIMER_300_301_MS1000,
    RRM_OAM_TIMER_300_301_MS1500,
    RRM_OAM_TIMER_300_301_MS2000
                                             }};

int RAN_RRCTimers_T302[OAM_TWO][OAM_EIGHT] = 
{{100, 200, 300, 400, 600, 1000, 1500, 2000},
    {  RRM_OAM_TIMER_T302_MS100,
        RRM_OAM_TIMER_T302_MS200,
        RRM_OAM_TIMER_T302_MS300,
        RRM_OAM_TIMER_T302_MS400,
        RRM_OAM_TIMER_T302_MS600,
        RRM_OAM_TIMER_T302_MS1000,
        RRM_OAM_TIMER_T302_MS1500,
        RRM_OAM_TIMER_T302_MS2000
    }};

int RAN_RRCTimers_T304EUTRA[OAM_TWO][OAM_SEVEN] =
{
    {50, 100, 150, 200, 500, 1000, 2000},
    {RRM_OAM_TIMER_T304_EUTRA_MS50,
        RRM_OAM_TIMER_T304_EUTRA_MS100,
        RRM_OAM_TIMER_T304_EUTRA_MS150,
        RRM_OAM_TIMER_T304_EUTRA_MS200,
        RRM_OAM_TIMER_T304_EUTRA_MS500,
        RRM_OAM_TIMER_T304_EUTRA_MS1000,
        RRM_OAM_TIMER_T304_EUTRA_MS2000  
    } };

int RAN_RRCTimers_T304IRAT [OAM_TWO][OAM_SEVEN] = 
{
    { 100, 200, 500, 1000, 2000, 4000, 8000},
    {  RRM_OAM_TIMER_T304_IRAT_MS100,
        RRM_OAM_TIMER_T304_IRAT_MS200,
        RRM_OAM_TIMER_T304_IRAT_MS500,
        RRM_OAM_TIMER_T304_IRAT_MS1000,
        RRM_OAM_TIMER_T304_IRAT_MS2000,
        RRM_OAM_TIMER_T304_IRAT_MS4000,
        RRM_OAM_TIMER_T304_IRAT_MS8000
    }};

int RAN_RRCTimers_T310[OAM_TWO][OAM_SEVEN] =
{ 
    {  0, 50, 100, 200, 500, 1000, 2000},
    {  RRM_OAM_TIMER_310_MS0,
        RRM_OAM_TIMER_310_MS50,
        RRM_OAM_TIMER_310_MS100,
        RRM_OAM_TIMER_310_MS200,
        RRM_OAM_TIMER_310_MS500,
        RRM_OAM_TIMER_310_MS1000,
        RRM_OAM_TIMER_310_MS2000
    }};

int RAN_RRCTimers_T311[OAM_TWO][OAM_SEVEN] =
{
    {  1000, 3000, 5000, 10000, 15000, 20000, 30000},
    {  RRM_OAM_TIMER_311_MS1000,
        RRM_OAM_TIMER_311_MS3000,
        RRM_OAM_TIMER_311_MS5000,
        RRM_OAM_TIMER_311_MS10000,
        RRM_OAM_TIMER_311_MS15000,
        RRM_OAM_TIMER_311_MS20000,
        RRM_OAM_TIMER_311_MS30000
    }};

int RAN_RRCTimers_T320[OAM_TWO][OAM_SEVEN] =
{
    {  5, 10, 20, 30, 60, 120, 180},
    {  RRM_OAM_TIMER_T320_MIN5,
        RRM_OAM_TIMER_T320_MIN10,
        RRM_OAM_TIMER_T320_MIN20,
        RRM_OAM_TIMER_T320_MIN30,
        RRM_OAM_TIMER_T320_MIN60,
        RRM_OAM_TIMER_T320_MIN120,
        RRM_OAM_TIMER_T320_MIN180
    }};


int RAN_RRCTimers_N310[OAM_TWO][OAM_EIGHT] =
{
    {  1, 2, 3, 4, 6, 8, 10, 20},
    {  RRM_OAM_TIMER_N310_N1,
        RRM_OAM_TIMER_N310_N2,
        RRM_OAM_TIMER_N310_N3,
        RRM_OAM_TIMER_N310_N4,
        RRM_OAM_TIMER_N310_N6,
        RRM_OAM_TIMER_N310_N8,
        RRM_OAM_TIMER_N310_N10,
        RRM_OAM_TIMER_N310_N20
    }};

int RAN_RRCTimers_N311[OAM_TWO][OAM_EIGHT] =
{
    {  1, 2, 3, 4, 5, 6, 8, 10},
    {  RRM_OAM_TIMER_N311_N1,
        RRM_OAM_TIMER_N311_N2,
        RRM_OAM_TIMER_N311_N3,
        RRM_OAM_TIMER_N311_N4,
        RRM_OAM_TIMER_N311_N5,
        RRM_OAM_TIMER_N311_N6,
        RRM_OAM_TIMER_N311_N8,
        RRM_OAM_TIMER_N311_N10}
};

int EPC_QoS_PacketDelayBudget[OAM_TWO][OAM_FOURTEEN] = 
{
    {  50, 100, 150, 200, 300, 400, 500, 
        600, 700, 800, 900, 1000, 1500, 2000},
    {  RRM_OAM_PACKET_DELAY_BUDGET_MS50,
        RRM_OAM_PACKET_DELAY_BUDGET_MS100,
        RRM_OAM_PACKET_DELAY_BUDGET_MS150,
        RRM_OAM_PACKET_DELAY_BUDGET_MS200,
        RRM_OAM_PACKET_DELAY_BUDGET_MS300,
        RRM_OAM_PACKET_DELAY_BUDGET_MS400,
        RRM_OAM_PACKET_DELAY_BUDGET_MS500,
        RRM_OAM_PACKET_DELAY_BUDGET_MS600,
        RRM_OAM_PACKET_DELAY_BUDGET_MS700,
        RRM_OAM_PACKET_DELAY_BUDGET_MS800,
        RRM_OAM_PACKET_DELAY_BUDGET_MS900,
        RRM_OAM_PACKET_DELAY_BUDGET_MS1000,
        RRM_OAM_PACKET_DELAY_BUDGET_MS1500,
        RRM_OAM_PACKET_DELAY_BUDGET_MS2000
    }};

int QoS_MAC_BSR_RETX[OAM_TWO][OAM_SIX] = 
{
    { 320, 640, 1280, 2560, 5120, 10240},
    {
        RRM_OAM_RETX_TMR_BSR_SF320,
        RRM_OAM_RETX_TMR_BSR_SF640,
        RRM_OAM_RETX_TMR_BSR_SF1280,
        RRM_OAM_RETX_TMR_BSR_SF2560,
        RRM_OAM_RETX_TMR_BSR_SF10240
    }
};

int QoS_MAC_BSR_PERIODIC[OAM_TWO][OAM_FIFTEEN] =
{
    { 0, 5, 10, 16, 20, 32, 40, 64, 80, 128, 160, 320, 640, 1280, 2560},
    {
        RRM_OAM_PERIODIC_TMR_BSR_INFINITY,
        RRM_OAM_PERIODIC_TMR_BSR_SF5,
        RRM_OAM_PERIODIC_TMR_BSR_SF10,
        RRM_OAM_PERIODIC_TMR_BSR_SF16,
        RRM_OAM_PERIODIC_TMR_BSR_SF20,
        RRM_OAM_PERIODIC_TMR_BSR_SF32,
        RRM_OAM_PERIODIC_TMR_BSR_SF40,
        RRM_OAM_PERIODIC_TMR_BSR_SF64,
        RRM_OAM_PERIODIC_TMR_BSR_SF80,
        RRM_OAM_PERIODIC_TMR_BSR_SF128,
        RRM_OAM_PERIODIC_TMR_BSR_SF160,
        RRM_OAM_PERIODIC_TMR_BSR_SF320,
        RRM_OAM_PERIODIC_TMR_BSR_SF640,
        RRM_OAM_PERIODIC_TMR_BSR_SF1280,
        RRM_OAM_PERIODIC_TMR_BSR_SF2560
    }
};

/*spr_22058_changes_start*/
int QoS_MAC_PERIODIC_PHR[OAM_TWO][PERIODIC_PHR_COUNT] =
{
    { 10, 20, 50, 100, 200, 500, 1000, OAM_ZERO},
    {
        RRM_OAM_PERIODIC_PHR_SF10,
        RRM_OAM_PERIODIC_PHR_SF20,
        RRM_OAM_PERIODIC_PHR_SF50,
        RRM_OAM_PERIODIC_PHR_SF100,
        RRM_OAM_PERIODIC_PHR_SF200,
        RRM_OAM_PERIODIC_PHR_SF500,
        RRM_OAM_PERIODIC_PHR_SF1000,
        RRM_OAM_PERIODIC_INFINITY
    }
};

int QoS_MAC_PROHIBIT_PHR[OAM_TWO][PROHIBIT_PHR_COUNT] =
{
    { 0, 10, 20, 50, 100, 200, 500, 1000},
    {
        RRM_OAM_PROHIBIT_PHR_SF0,
        RRM_OAM_PROHIBIT_PHR_SF10,
        RRM_OAM_PROHIBIT_PHR_SF20,
        RRM_OAM_PROHIBIT_PHR_SF50,
        RRM_OAM_PROHIBIT_PHR_SF100,
        RRM_OAM_PROHIBIT_PHR_SF200,
        RRM_OAM_PROHIBIT_PHR_SF500,
        RRM_OAM_PROHIBIT_PHR_SF1000
    }
};

int QoS_MAC_DL_PATHLOSS[OAM_TWO][DL_PATHLOSS_COUNT] =
{
    { 1, 3, 6, OAM_ZERO},
    {
        RRM_OAM_DL_PATHLOSS_TMR_DB1,
        RRM_OAM_DL_PATHLOSS_TMR_DB3,
        RRM_OAM_DL_PATHLOSS_TMR_DB6,
        RRM_OAM_DL_PATHLOSS_TMR_INFINITY
    }
};
/*spr_22058_changes_end*/

int RAN_PHY_PDSCH_PA[OAM_TWO][OAM_EIGHT]=
{
    {-600,-477, -300, -177, 0, 100, 200, 300},
    { RRM_OAM_PDSCH_CONFIGURATION_DEDICATED_P_A_DB_M_6, 
        RRM_OAM_PDSCH_CONFIGURATION_DEDICATED_P_A_DB_M_4DOT77,
        RRM_OAM_PDSCH_CONFIGURATION_DEDICATED_P_A_DB_M_3,
        RRM_OAM_PDSCH_CONFIGURATION_DEDICATED_P_A_DB_M_1DOT77,
        RRM_OAM_PDSCH_CONFIGURATION_DEDICATED_P_A_DB0,
        RRM_OAM_PDSCH_CONFIGURATION_DEDICATED_P_A_DB1,
        RRM_OAM_PDSCH_CONFIGURATION_DEDICATED_P_A_DB2,
        RRM_OAM_PDSCH_CONFIGURATION_DEDICATED_P_A_DB3
    }};

#ifdef OAM_SON_ENABLE
/* SPR 13179 FIX START */
SInt32
NR_Blacklisted[OAM_NR_BLACKLISTED_VAL_COUNT][OAM_NR_BLACKLISTED_VAL_COUNT] =
{
    { 0, 1 },
    { SON_HO_ALLOWED, SON_HO_PROHIBITED }
};
/* SPR 13179 FIX END */

int NR_PS_HO_SUPPORTED[OAM_TWO][OAM_TWO] = 
{
    {OAM_ZERO, OAM_ONE},
    {SON_FALSE, SON_TRUE} 
};

int NR_VOIP_CAPABLE[OAM_TWO][OAM_TWO] = 
{
    {OAM_ZERO,OAM_ONE},
    {SON_FALSE, SON_TRUE}
};

/* SPR-16334 COMPILATION START */
#endif
/* SPR-16334 COMPILATION END */

/* SPR 16407 START */
int CELL_BARRED[OAM_TWO][OAM_TWO] =
{
    {OAM_ZERO,OAM_ONE},
    {RRM_OAM_CELL_NOT_BARRED, RRM_OAM_CELL_BARRED}
};
/* SPR 16407 END */


enumerated_string_fields_mapping_tbl_t DLBandwidth_MAP[OAM_SIX] = {{"n6",6},
    {"n15",15},
    {"n25",25},
    {"n50",50},
    {"n75",75},
    {"n100",100}};

/* SPR-11454 Start */
enumerated_string_fields_mapping_tbl_t ULBandwidth_MAP[OAM_SIX] = {{"n6",6},
    {"n15",15},
    {"n25",25},
    {"n50",50},
    {"n75",75},
    {"n100",100}};
/* SPR-11454 End */

/*------------------------------------------------String To Integer-----------------------------------------------*/

/*---------------Type-------------------*/
enumerated_string_fields_mapping_tbl_t Type[OAM_TWO] = {{"GBR",RRM_OAM_GBR},
    {"Non-GBR",RRM_OAM_NON_GBR}};

/*---------------S1ConnectionMode-----------------------*/
enumerated_string_fields_mapping_tbl_t S1ConnectionMode[OAM_TWO] = {{"One",OAM_ONE},
    {"All",OAM_THREE}};

/*---------------------------------AllowedCipheringAlgorithmList-----------------------------------------*/

enumerated_string_fields_mapping_tbl_t
AllowedCipheringAlgorithmList[RRC_MAX_CIPHERING_ALGORITHMS] = {
    {"EEA0",      RRC_PDCP_CIPH_ALG_EEA0},
    {"128-EEA1",  RRC_PDCP_CIPH_ALG_EEA1},
    {"128-EEA2",  RRC_PDCP_CIPH_ALG_EEA2}
};
/* SPR 12987 FIX START */
/*-------------------------------- SUPPORTED_RAT ---------------------------------------------------*/
enumerated_string_fields_mapping_tbl_t SupportedRat_MAP[MAX_SUPPORTED_RAT] = { 
    {"EUTRAN",1},
    {"UTRAN", 2},
    {"GERAN",3},
    {"CDMA1xRTT",4},
    {"CDMAHRPD",5}};
/* SPR 12987 FIX END */
/*---------------------------------AllowedIntegrityProtectionAlgorithmList---------------------------------*/

enumerated_string_fields_mapping_tbl_t
AllowedIntegrityProtectionAlgorithmList[RRC_MAX_INTEGRITY_ALGORITHMS] = {
    {"EIA0",      RRC_PDCP_INT_ALG_EIA0},
    {"128-EIA1",  RRC_PDCP_INT_ALG_EIA1},
    {"128-EIA2",  RRC_PDCP_INT_ALG_EIA2}
};


/* SPR 20653 Fix Start */
int RBSize[OAM_TWO][OAM_TWO] = {{0,1},{RRM_OAM_RB_SIZE_12,RRM_OAM_RB_SIZE_24}};

int Qos_BucketSizeDuration[OAM_TWO][OAM_SIX] = {{0,1,2,3,4,5},
    {RRM_OAM_BUCKET_SIZE_MS_50,
        RRM_OAM_BUCKET_SIZE_MS_100,
        RRM_OAM_BUCKET_SIZE_MS_150,
        RRM_OAM_BUCKET_SIZE_MS_300,
        RRM_OAM_BUCKET_SIZE_MS_500,
        RRM_OAM_BUCKET_SIZE_MS_1000}};

int Qos_PrioritizedBitRate[OAM_TWO][OAM_EIGHT] = {{0,1,2,3,4,5,6,7},
    {RRM_OAM_BIT_RATE_KBPS_0,
        RRM_OAM_BIT_RATE_KBPS_8,
        RRM_OAM_BIT_RATE_KBPS_16,
        RRM_OAM_BIT_RATE_KBPS_32,
        RRM_OAM_BIT_RATE_KBPS_64,
        RRM_OAM_BIT_RATE_KBPS_128,
        RRM_OAM_BIT_RATE_KBPS_256,
        RRM_OAM_BIT_RATE_INFINITY}};
/* SPR 20653 Fix End */

/*---------------------------QHyst----------------------------*/
int RAN_Mobility_IdleMode_Common_QHyst[OAM_TWO][OAM_SIXTEEN] = {{0,1,2,3,4,5,6,8,10,12,14,16,18,20,22,24},
    {RRM_OAM_Q_HYST_DB0,
        RRM_OAM_Q_HYST_DB1,
        RRM_OAM_Q_HYST_DB2,
        RRM_OAM_Q_HYST_DB3,
        RRM_OAM_Q_HYST_DB4,
        RRM_OAM_Q_HYST_DB5,
        RRM_OAM_Q_HYST_DB6,
        RRM_OAM_Q_HYST_DB8,
        RRM_OAM_Q_HYST_DB10,
        RRM_OAM_Q_HYST_DB12,
        RRM_OAM_Q_HYST_DB14,
        RRM_OAM_Q_HYST_DB16,
        RRM_OAM_Q_HYST_DB18,
        RRM_OAM_Q_HYST_DB20,
        RRM_OAM_Q_HYST_DB22,
        RRM_OAM_Q_HYST_DB24}};

/*-------------------QHystSFMedium-----------------------*/
int RAN_Mobility_IdleMode_Common_QHystSFMedium[OAM_TWO][OAM_FOUR] = {{-6,-4,-2,OAM_ZERO},
    {RRM_OAM_Q_HYST_NEG_SIX,
        RRM_OAM_Q_HYST_NEG_FOUR,
        RRM_OAM_Q_HYST_NEG_TWO,
        RRM_OAM_Q_HYST_ZERO}};

/*-------------------QHystSFHigh-----------------------*/
int RAN_Mobility_IdleMode_Common_QHystSFHigh[OAM_TWO][OAM_FOUR] = {{-6,-4,-2,OAM_ZERO},
    {RRM_OAM_Q_HYST_NEG_SIX,
        RRM_OAM_Q_HYST_NEG_FOUR,
        RRM_OAM_Q_HYST_NEG_TWO,
        RRM_OAM_Q_HYST_ZERO}};

/*-------------------------TEvaluation-------------------*/
int RAN_Mobility_IdleMode_Common_TEvaluation[OAM_TWO][OAM_FIVE] = {{30,60,120,180,240},
    {RRM_OAM_T_EVAL_S_30,
        RRM_OAM_T_EVAL_S_60,
        RRM_OAM_T_EVAL_S_120,
        RRM_OAM_T_EVAL_S_180,
        RRM_OAM_T_EVAL_S_240}};

/*-------------------------THystNormal---------------------*/
int RAN_Mobility_IdleMode_Common_THystNormal[OAM_TWO][OAM_FIVE] = {{30,60,120,180,240},
    {RRM_OAM_T_HYST_NORMAL_S_30,
        RRM_OAM_T_HYST_NORMAL_S_60,
        RRM_OAM_T_HYST_NORMAL_S_120,
        RRM_OAM_T_HYST_NORMAL_S_180,
        RRM_OAM_T_HYST_NORMAL_S_240}};				



int RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_TWO][OAM_FIFTEEN]={{0,1,2,3,4,5,6,7,8,9,11,13,15,17,19},
    {RRM_FILTER_COEFF_FC0,
        RRM_FILTER_COEFF_FC1,
        RRM_FILTER_COEFF_FC2,
        RRM_FILTER_COEFF_FC3,
        RRM_FILTER_COEFF_FC4,
        RRM_FILTER_COEFF_FC5,
        RRM_FILTER_COEFF_FC6,
        RRM_FILTER_COEFF_FC7,
        RRM_FILTER_COEFF_FC8,
        RRM_FILTER_COEFF_FC9,
        RRM_FILTER_COEFF_FC11,
        RRM_FILTER_COEFF_FC13,
        RRM_FILTER_COEFF_FC15,
        RRM_FILTER_COEFF_FC17,
        RRM_FILTER_COEFF_FC19
    }};
int RAN_Mobility_ConnMode_EUTRA_TimeToTrigger[OAM_TWO][OAM_SIXTEEN]={{0,40,64,80,100,128,160,256,320,480,512,640,1024,1280,2560,														5120},
    {
        RRMC_TIME_TO_TRIGGER_MS_0,
        RRMC_TIME_TO_TRIGGER_MS_40,
        RRMC_TIME_TO_TRIGGER_MS_64,
        RRMC_TIME_TO_TRIGGER_MS_80,
        RRMC_TIME_TO_TRIGGER_MS_100,
        RRMC_TIME_TO_TRIGGER_MS_128,
        RRMC_TIME_TO_TRIGGER_MS_160,
        RRMC_TIME_TO_TRIGGER_MS_256,
        RRMC_TIME_TO_TRIGGER_MS_320,
        RRMC_TIME_TO_TRIGGER_MS_480,
        RRMC_TIME_TO_TRIGGER_MS_512,
        RRMC_TIME_TO_TRIGGER_MS_640,
        RRMC_TIME_TO_TRIGGER_MS_1024,
        RRMC_TIME_TO_TRIGGER_MS_1280,
        RRMC_TIME_TO_TRIGGER_MS_2560,
        RRMC_TIME_TO_TRIGGER_MS_5120
    }};

enumerated_string_fields_mapping_tbl_t TriggerQuantity[OAM_TWO]={{"RSRP",RRMC_RSRP},
    {"RSRQ",RRMC_RSRQ}};

enumerated_string_fields_mapping_tbl_t ReportQuantity[OAM_TWO]={{"SameAsTriggerQuantity",RRMC_SAME_AS_TRIGGER_QUANTITY},
    {"Both",RRMC_BOTH}};

int RAN_Mobility_ConnMode_EUTRA_ReportInterval[OAM_TWO][OAM_THIRTEEN]={{120,240,480,640,1024,2048,5120,10240,60000,360000,720000,														1800000,3600000},
    {
        RRMC_REPORT_INTERVAL_MS_120,
        RRMC_REPORT_INTERVAL_MS_240,
        RRMC_REPORT_INTERVAL_MS_480,
        RRMC_REPORT_INTERVAL_MS_640,
        RRMC_REPORT_INTERVAL_MS_1024,
        RRMC_REPORT_INTERVAL_MS_2048,
        RRMC_REPORT_INTERVAL_MS_5120,
        RRMC_REPORT_INTERVAL_MS_10240,
        RRMC_REPORT_INTERVAL_MIN_1,
        RRMC_REPORT_INTERVAL_MIN_6,
        RRMC_REPORT_INTERVAL_MIN_12,
        RRMC_REPORT_INTERVAL_MIN_30,
        RRMC_REPORT_INTERVAL_MIN_60
    }};															
/*-- CSR 58268 FIX START */
int EPC_MAX_RETX_THRESHOLD[OAM_TWO][OAM_EIGHT]={{1, 2, 3, 4, 6, 8, 16, 32},
    {
        RRM_OAM_MAX_RETRANS_THRESH_1,
        RRM_OAM_MAX_RETRANS_THRESH_2,
        RRM_OAM_MAX_RETRANS_THRESH_3,
        RRM_OAM_MAX_RETRANS_THRESH_4,
        RRM_OAM_MAX_RETRANS_THRESH_6,
        RRM_OAM_MAX_RETRANS_THRESH_8,
        RRM_OAM_MAX_RETRANS_THRESH_16,
        RRM_OAM_MAX_RETRANS_THRESH_32

    }};															
/*-- CSR 58268 FIX END */

/* SPR 13380 REVIEW COMMENTS FIX START */
/* SPR 13380 FIX START */
SInt32
RAN_Mobility_ConnMode_EUTRA_ReportAmount
[OAM_2X2_TBL_NUM_COULMNS][OAM_NUM_SUPP_EUTRA_REPORT_AMT] = {
    { 1, 2, 4, 8, 16, 32, 64, 0 },
    /* SPR 13380 FIX END */
    { RRMC_REPORT_AMOUNT_1,
        RRMC_REPORT_AMOUNT_2,
        RRMC_REPORT_AMOUNT_4,
        RRMC_REPORT_AMOUNT_8,
        RRMC_REPORT_AMOUNT_16,
        RRMC_REPORT_AMOUNT_32,
        RRMC_REPORT_AMOUNT_64,
        RRMC_REPORT_AMOUNT_INFINITY
    }
};
/* SPR 13380 REVIEW COMMENTS FIX END */

int RAN_Mobility_ConnMode_IRAT_FilterCoefficientUTRA[OAM_TWO][OAM_FIFTEEN]={{0,1,2,3,4,5,6,7,8,9,11,13,15,17,19},
    {
        RRM_FILTER_COEFF_FC0,
        RRM_FILTER_COEFF_FC1,
        RRM_FILTER_COEFF_FC2,
        RRM_FILTER_COEFF_FC3,
        RRM_FILTER_COEFF_FC4,
        RRM_FILTER_COEFF_FC5,
        RRM_FILTER_COEFF_FC6,
        RRM_FILTER_COEFF_FC7,
        RRM_FILTER_COEFF_FC8,
        RRM_FILTER_COEFF_FC9,
        RRM_FILTER_COEFF_FC11,
        RRM_FILTER_COEFF_FC13,
        RRM_FILTER_COEFF_FC15,
        RRM_FILTER_COEFF_FC17,
        RRM_FILTER_COEFF_FC19
    }};

/* LWA changes start*/
/* LWA changes end*/

enumerated_string_fields_mapping_tbl_t MeasQuantityUTRAFDD[OAM_TWO]={{"CPICH-RSCP",RRM_CPICH_RSCP},
    {"CPICH-EcN0",RRM_CPICH_ECN0}};

enumerated_string_fields_mapping_tbl_t MeasQuantityUTRATDD[OAM_TWO]={{"CPICH-RSCP",RRM_TDD_CPICH_RSCP},
    {"CPICH-EcN0",RRM_TDD_CPICH_ECN0}};

enumerated_string_fields_mapping_tbl_t RAN_Mobility_ConnMode_IRAT_MeasQuantityCDMA2000[OAM_TWO]={{"PilotStrength", OAM_ZERO},
    {"PilotPnPhaseAndPilotStrength",OAM_ONE}};																



int RAN_Mobility_ConnMode_IRAT_FilterCoefficientGERAN[OAM_TWO][OAM_FIFTEEN]={{0,1,2,3,4,5,6,7,8,9,11,13,15,17,19},
    {
        RRM_FILTER_COEFF_FC0,
        RRM_FILTER_COEFF_FC1,
        RRM_FILTER_COEFF_FC2,
        RRM_FILTER_COEFF_FC3,
        RRM_FILTER_COEFF_FC4,
        RRM_FILTER_COEFF_FC5,
        RRM_FILTER_COEFF_FC6,
        RRM_FILTER_COEFF_FC7,
        RRM_FILTER_COEFF_FC8,
        RRM_FILTER_COEFF_FC9,
        RRM_FILTER_COEFF_FC11,
        RRM_FILTER_COEFF_FC13,
        RRM_FILTER_COEFF_FC15,
        RRM_FILTER_COEFF_FC17,
        RRM_FILTER_COEFF_FC19
    }};

int RAN_Mobility_ConnMode_IRAT_TimeToTrigger[OAM_TWO][OAM_SIXTEEN]={{0,40,64,80,100,128,160,256,320,480,512,640,1024,1280,2560,														5120},
    {
        RRMC_TIME_TO_TRIGGER_MS_0,
        RRMC_TIME_TO_TRIGGER_MS_40,
        RRMC_TIME_TO_TRIGGER_MS_64,
        RRMC_TIME_TO_TRIGGER_MS_80,
        RRMC_TIME_TO_TRIGGER_MS_100,
        RRMC_TIME_TO_TRIGGER_MS_128,
        RRMC_TIME_TO_TRIGGER_MS_160,
        RRMC_TIME_TO_TRIGGER_MS_256,
        RRMC_TIME_TO_TRIGGER_MS_320,
        RRMC_TIME_TO_TRIGGER_MS_480,
        RRMC_TIME_TO_TRIGGER_MS_512,
        RRMC_TIME_TO_TRIGGER_MS_640,
        RRMC_TIME_TO_TRIGGER_MS_1024,
        RRMC_TIME_TO_TRIGGER_MS_1280,
        RRMC_TIME_TO_TRIGGER_MS_2560,
        RRMC_TIME_TO_TRIGGER_MS_5120
    }};

int RAN_Mobility_ConnMode_IRAT_ReportInterval[OAM_TWO][OAM_THIRTEEN]={{120,240,480,640,1024,2048,5120,10240,60000,360000,720000,														1800000,3600000},
    {
        RRMC_REPORT_INTERVAL_MS_120,
        RRMC_REPORT_INTERVAL_MS_240,
        RRMC_REPORT_INTERVAL_MS_480,
        RRMC_REPORT_INTERVAL_MS_640,
        RRMC_REPORT_INTERVAL_MS_1024,
        RRMC_REPORT_INTERVAL_MS_2048,
        RRMC_REPORT_INTERVAL_MS_5120,
        RRMC_REPORT_INTERVAL_MS_10240,
        RRMC_REPORT_INTERVAL_MIN_1,
        RRMC_REPORT_INTERVAL_MIN_6,
        RRMC_REPORT_INTERVAL_MIN_12,
        RRMC_REPORT_INTERVAL_MIN_30,
        RRMC_REPORT_INTERVAL_MIN_60
    }};														
    //TB_FI
int RAN_Mobility_ConnMode_IRAT_ReportAmount[OAM_TWO][OAM_EIGHT]={{1,2,4,8,16,32,64,0},
    {
        RRMC_REPORT_AMOUNT_1,
        RRMC_REPORT_AMOUNT_2,
        RRMC_REPORT_AMOUNT_4,
        RRMC_REPORT_AMOUNT_8,
        RRMC_REPORT_AMOUNT_16,
        RRMC_REPORT_AMOUNT_32,
        RRMC_REPORT_AMOUNT_64,
        RRMC_REPORT_AMOUNT_INFINITY
    }};				

int RAN_NeighborList_LTECell_QOffset[OAM_TWO][OAM_THIRTY_ONE]={{-24,-22,-20,-18,-16,-14,-12,-10,-8,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,8,10,12,14,16,18,20,22,24},
    {
        RRM_OAM_Q_OFFESET_RANGE_DB_24,
        RRM_OAM_Q_OFFESET_RANGE_DB_22,
        RRM_OAM_Q_OFFESET_RANGE_DB_20,
        RRM_OAM_Q_OFFESET_RANGE_DB_18,
        RRM_OAM_Q_OFFESET_RANGE_DB_16,
        RRM_OAM_Q_OFFESET_RANGE_DB_14,
        RRM_OAM_Q_OFFESET_RANGE_DB_12,
        RRM_OAM_Q_OFFESET_RANGE_DB_10,
        RRM_OAM_Q_OFFESET_RANGE_DB_8,
        RRM_OAM_Q_OFFESET_RANGE_DB_6,
        RRM_OAM_Q_OFFESET_RANGE_DB_5,
        RRM_OAM_Q_OFFESET_RANGE_DB_4,
        RRM_OAM_Q_OFFESET_RANGE_DB_3,
        RRM_OAM_Q_OFFESET_RANGE_DB_2,
        RRM_OAM_Q_OFFESET_RANGE_DB_1,
        RRM_OAM_Q_OFFESET_RANGE_DB0,
        RRM_OAM_Q_OFFESET_RANGE_DB1,
        RRM_OAM_Q_OFFESET_RANGE_DB2,
        RRM_OAM_Q_OFFESET_RANGE_DB3,
        RRM_OAM_Q_OFFESET_RANGE_DB4,
        RRM_OAM_Q_OFFESET_RANGE_DB5,
        RRM_OAM_Q_OFFESET_RANGE_DB6,
        RRM_OAM_Q_OFFESET_RANGE_DB8,
        RRM_OAM_Q_OFFESET_RANGE_DB10,
        RRM_OAM_Q_OFFESET_RANGE_DB12,
        RRM_OAM_Q_OFFESET_RANGE_DB14,
        RRM_OAM_Q_OFFESET_RANGE_DB16,
        RRM_OAM_Q_OFFESET_RANGE_DB18,
        RRM_OAM_Q_OFFESET_RANGE_DB20,
        RRM_OAM_Q_OFFESET_RANGE_DB22,
        RRM_OAM_Q_OFFESET_RANGE_DB24

    }};

int RAN_NeighborList_LTECell_CIO[OAM_TWO][OAM_THIRTY_ONE]={{-24,-22,-20,-18,-16,-14,-12,-10,-8,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,8,10,12,14,16,18,20,22,24},
    {
        RRM_OAM_Q_OFFESET_RANGE_DB_24,
        RRM_OAM_Q_OFFESET_RANGE_DB_22,
        RRM_OAM_Q_OFFESET_RANGE_DB_20,
        RRM_OAM_Q_OFFESET_RANGE_DB_18,
        RRM_OAM_Q_OFFESET_RANGE_DB_16,
        RRM_OAM_Q_OFFESET_RANGE_DB_14,
        RRM_OAM_Q_OFFESET_RANGE_DB_12,
        RRM_OAM_Q_OFFESET_RANGE_DB_10,
        RRM_OAM_Q_OFFESET_RANGE_DB_8,
        RRM_OAM_Q_OFFESET_RANGE_DB_6,
        RRM_OAM_Q_OFFESET_RANGE_DB_5,
        RRM_OAM_Q_OFFESET_RANGE_DB_4,
        RRM_OAM_Q_OFFESET_RANGE_DB_3,
        RRM_OAM_Q_OFFESET_RANGE_DB_2,
        RRM_OAM_Q_OFFESET_RANGE_DB_1,
        RRM_OAM_Q_OFFESET_RANGE_DB0,
        RRM_OAM_Q_OFFESET_RANGE_DB1,
        RRM_OAM_Q_OFFESET_RANGE_DB2,
        RRM_OAM_Q_OFFESET_RANGE_DB3,
        RRM_OAM_Q_OFFESET_RANGE_DB4,
        RRM_OAM_Q_OFFESET_RANGE_DB5,
        RRM_OAM_Q_OFFESET_RANGE_DB6,
        RRM_OAM_Q_OFFESET_RANGE_DB8,
        RRM_OAM_Q_OFFESET_RANGE_DB10,
        RRM_OAM_Q_OFFESET_RANGE_DB12,
        RRM_OAM_Q_OFFESET_RANGE_DB14,
        RRM_OAM_Q_OFFESET_RANGE_DB16,                
        RRM_OAM_Q_OFFESET_RANGE_DB18,
        RRM_OAM_Q_OFFESET_RANGE_DB20,                
        RRM_OAM_Q_OFFESET_RANGE_DB22,
        RRM_OAM_Q_OFFESET_RANGE_DB24											
    }};



int  delta_f_pucch_format_1[OAM_TWO][OAM_THREE] =
{
    {-2, 0, 2},
    {0,
        1,
        2   
    }
};

int delta_f_pucch_format_1b[OAM_TWO][OAM_THREE] ={{1,3,5},
    {0,                                    
        1,
        2
    }};

int delta_f_pucch_format_2[OAM_TWO][4] ={{-2,0,1,2},
    {
        0,
        1,
        2,
        3      
    }};


int delta_f_pucch_format_2a[OAM_TWO][OAM_THREE] ={{-2,0,2},
    {0,
        1,
        2   
    }}; 
int delta_f_pucch_format_2b[2][OAM_THREE] ={{-2,0,2},
    {0,
        1,
        2
    }};
/*SPR FIX 11374 START*/
int delta_f_pucch_format_1b_cs_r10[2][OAM_TWO] ={{1,2},
    {0,
        1
    }};

int delta_f_pucch_format_3_r10[2][OAM_EIGHT] ={{-1,0,1,2,3,4,5,6},
    {0,
        1,
        2,
        3,
        4,
        5,
        6,
        7
    }};
/*SPR FIX 11374 END*/
int t_poll_retransmit[OAM_TWO][OAM_FIFTY_FIVE] = {
    {5, 10, 15, 20, 25, 30, 35, 40, 45,
        50, 55, 60, 65, 70, 75, 80, 85, 90,
        95, 100, 105, 110, 115, 120, 125, 130,
        135, 140, 145, 150, 155, 160, 165, 170,
        175, 180, 185, 190, 195, 200, 205, 210,
        215, 220, 225, 230, 235, 240, 245, 250,
        300, 350, 400, 450, 500},
    { RRM_OAM_POLL_RETRAS_MS_5,
        RRM_OAM_POLL_RETRAS_MS_10,
        RRM_OAM_POLL_RETRAS_MS_15,
        RRM_OAM_POLL_RETRAS_MS_20,
        RRM_OAM_POLL_RETRAS_MS_25,
        RRM_OAM_POLL_RETRAS_MS_30,
        RRM_OAM_POLL_RETRAS_MS_35,
        RRM_OAM_POLL_RETRAS_MS_40,
        RRM_OAM_POLL_RETRAS_MS_45,
        RRM_OAM_POLL_RETRAS_MS_50,
        RRM_OAM_POLL_RETRAS_MS_55,
        RRM_OAM_POLL_RETRAS_MS_60,
        RRM_OAM_POLL_RETRAS_MS_65,
        RRM_OAM_POLL_RETRAS_MS_70,
        RRM_OAM_POLL_RETRAS_MS_75,
        RRM_OAM_POLL_RETRAS_MS_80,
        RRM_OAM_POLL_RETRAS_MS_85,
        RRM_OAM_POLL_RETRAS_MS_90,
        RRM_OAM_POLL_RETRAS_MS_95,
        RRM_OAM_POLL_RETRAS_MS_100,
        RRM_OAM_POLL_RETRAS_MS_105,
        RRM_OAM_POLL_RETRAS_MS_110,
        RRM_OAM_POLL_RETRAS_MS_115,
        RRM_OAM_POLL_RETRAS_MS_120,
        RRM_OAM_POLL_RETRAS_MS_125,
        RRM_OAM_POLL_RETRAS_MS_130,
        RRM_OAM_POLL_RETRAS_MS_135,
        RRM_OAM_POLL_RETRAS_MS_140,
        RRM_OAM_POLL_RETRAS_MS_145,
        RRM_OAM_POLL_RETRAS_MS_150,
        RRM_OAM_POLL_RETRAS_MS_155,
        RRM_OAM_POLL_RETRAS_MS_160,
        RRM_OAM_POLL_RETRAS_MS_165,
        RRM_OAM_POLL_RETRAS_MS_170,
        RRM_OAM_POLL_RETRAS_MS_175,
        RRM_OAM_POLL_RETRAS_MS_180,
        RRM_OAM_POLL_RETRAS_MS_185,
        RRM_OAM_POLL_RETRAS_MS_190,
        RRM_OAM_POLL_RETRAS_MS_195,
        RRM_OAM_POLL_RETRAS_MS_200,
        RRM_OAM_POLL_RETRAS_MS_205,
        RRM_OAM_POLL_RETRAS_MS_210,
        RRM_OAM_POLL_RETRAS_MS_215,
        RRM_OAM_POLL_RETRAS_MS_220,
        RRM_OAM_POLL_RETRAS_MS_225,
        RRM_OAM_POLL_RETRAS_MS_230,
        RRM_OAM_POLL_RETRAS_MS_235,
        RRM_OAM_POLL_RETRAS_MS_240,
        RRM_OAM_POLL_RETRAS_MS_245,
        RRM_OAM_POLL_RETRAS_MS_250,
        RRM_OAM_POLL_RETRAS_MS_300,
        RRM_OAM_POLL_RETRAS_MS_350,
        RRM_OAM_POLL_RETRAS_MS_400,
        RRM_OAM_POLL_RETRAS_MS_450,
        RRM_OAM_POLL_RETRAS_MS_500
    } };

int t_status_prohibit[OAM_TWO][OAM_FIFTY_SIX] =
{
    { 0, 5, 10, 15, 20, 25, 30, 35, 40,
        45, 50, 55, 60, 65, 70, 75, 80,
        85, 90, 95, 100, 105, 110, 115, 120,
        125, 130, 135, 140, 145, 150, 155,
        160, 165, 170, 175, 180, 185, 190,
        195, 200, 205, 210, 215, 220, 225,
        230, 235, 240, 245, 250, 300, 350,
        400, 450, 500},
    {  RRM_OAM_T_STATUS_PROHB_MS_0,
        RRM_OAM_T_STATUS_PROHB_MS_5,
        RRM_OAM_T_STATUS_PROHB_MS_10,
        RRM_OAM_T_STATUS_PROHB_MS_15,
        RRM_OAM_T_STATUS_PROHB_MS_20,
        RRM_OAM_T_STATUS_PROHB_MS_25,
        RRM_OAM_T_STATUS_PROHB_MS_30,
        RRM_OAM_T_STATUS_PROHB_MS_35,
        RRM_OAM_T_STATUS_PROHB_MS_40,
        RRM_OAM_T_STATUS_PROHB_MS_45,
        RRM_OAM_T_STATUS_PROHB_MS_50,
        RRM_OAM_T_STATUS_PROHB_MS_55,
        RRM_OAM_T_STATUS_PROHB_MS_60,
        RRM_OAM_T_STATUS_PROHB_MS_65,
        RRM_OAM_T_STATUS_PROHB_MS_70,
        RRM_OAM_T_STATUS_PROHB_MS_75,
        RRM_OAM_T_STATUS_PROHB_MS_80,
        RRM_OAM_T_STATUS_PROHB_MS_85,
        RRM_OAM_T_STATUS_PROHB_MS_90,
        RRM_OAM_T_STATUS_PROHB_MS_95,
        RRM_OAM_T_STATUS_PROHB_MS_100,
        RRM_OAM_T_STATUS_PROHB_MS_105,
        RRM_OAM_T_STATUS_PROHB_MS_110,
        RRM_OAM_T_STATUS_PROHB_MS_115,
        RRM_OAM_T_STATUS_PROHB_MS_120,
        RRM_OAM_T_STATUS_PROHB_MS_125,
        RRM_OAM_T_STATUS_PROHB_MS_130,
        RRM_OAM_T_STATUS_PROHB_MS_135,
        RRM_OAM_T_STATUS_PROHB_MS_140,
        RRM_OAM_T_STATUS_PROHB_MS_145,
        RRM_OAM_T_STATUS_PROHB_MS_150,
        RRM_OAM_T_STATUS_PROHB_MS_155,
        RRM_OAM_T_STATUS_PROHB_MS_160,
        RRM_OAM_T_STATUS_PROHB_MS_165,
        RRM_OAM_T_STATUS_PROHB_MS_170,
        RRM_OAM_T_STATUS_PROHB_MS_175,
        RRM_OAM_T_STATUS_PROHB_MS_180,
        RRM_OAM_T_STATUS_PROHB_MS_185,
        RRM_OAM_T_STATUS_PROHB_MS_190,
        RRM_OAM_T_STATUS_PROHB_MS_195,
        RRM_OAM_T_STATUS_PROHB_MS_200,
        RRM_OAM_T_STATUS_PROHB_MS_205,
        RRM_OAM_T_STATUS_PROHB_MS_210,
        RRM_OAM_T_STATUS_PROHB_MS_215,
        RRM_OAM_T_STATUS_PROHB_MS_220,
        RRM_OAM_T_STATUS_PROHB_MS_225,
        RRM_OAM_T_STATUS_PROHB_MS_230,
        RRM_OAM_T_STATUS_PROHB_MS_235,
        RRM_OAM_T_STATUS_PROHB_MS_240,
        RRM_OAM_T_STATUS_PROHB_MS_245,
        RRM_OAM_T_STATUS_PROHB_MS_250,
        RRM_OAM_T_STATUS_PROHB_MS_300,
        RRM_OAM_T_STATUS_PROHB_MS_350,
        RRM_OAM_T_STATUS_PROHB_MS_400,
        RRM_OAM_T_STATUS_PROHB_MS_450,
        RRM_OAM_T_STATUS_PROHB_MS_500
    }};

int t_reordering[OAM_TWO][OAM_THIRTY_ONE] =
{{0, 5, 10, 15, 20, 25, 30,
    35, 40, 45, 50, 55, 60, 65,
    70, 75, 80, 85, 90, 95, 100,
    110, 120, 130, 140, 150, 160,
    170, 180, 190, 200},
{ RRM_OAM_T_REORDER_MS_0,
    RRM_OAM_T_REORDER_MS_5,
    RRM_OAM_T_REORDER_MS_10,
    RRM_OAM_T_REORDER_MS_15,
    RRM_OAM_T_REORDER_MS_20,
    RRM_OAM_T_REORDER_MS_25,
    RRM_OAM_T_REORDER_MS_30,
    RRM_OAM_T_REORDER_MS_35,
    RRM_OAM_T_REORDER_MS_40,
    RRM_OAM_T_REORDER_MS_45,
    RRM_OAM_T_REORDER_MS_50,
    RRM_OAM_T_REORDER_MS_55,
    RRM_OAM_T_REORDER_MS_60,
    RRM_OAM_T_REORDER_MS_65,
    RRM_OAM_T_REORDER_MS_70,
    RRM_OAM_T_REORDER_MS_75,
    RRM_OAM_T_REORDER_MS_80,
    RRM_OAM_T_REORDER_MS_85,
    RRM_OAM_T_REORDER_MS_90,
    RRM_OAM_T_REORDER_MS_95,
    RRM_OAM_T_REORDER_MS_100,
    RRM_OAM_T_REORDER_MS_110,
    RRM_OAM_T_REORDER_MS_120,
    RRM_OAM_T_REORDER_MS_130,
    RRM_OAM_T_REORDER_MS_140,
    RRM_OAM_T_REORDER_MS_150,
    RRM_OAM_T_REORDER_MS_160,
    RRM_OAM_T_REORDER_MS_170,
    RRM_OAM_T_REORDER_MS_180,
    RRM_OAM_T_REORDER_MS_190,
    RRM_OAM_T_REORDER_MS_200
} };
/* CSR 00070293 FIX: CODE REMOVED  */

enumerated_string_fields_mapping_tbl_t SUPPORTED_SYS[OAM_FOUR] = {{"UMTS",OAM_UMTS},
    {"LTE",OAM_LTE},
    {"CDMA1x",OAM_CDMA1x},
    {"CDMAHRPD",OAM_CDMAHRPD}};


/** changes for param mapping **/

/* Spr 15596 Fix Start */
oam_return_et oam_isValidIp4SecGWServer (UInt8 *p_str);
/* Spr 15596 Fix End */

oam_return_et oam_isValidIp4 (UInt8 *p_str);
/* SPR-10651 FIX Start */
/* SPR 13781 Changes Start */
UInt32 earfcndl_to_freq_band_ind[OAM_THREE][MAX_FREQBANDINDICATOR] =
{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43
 },
{0,600,1200,1950,2400,2650,2750,3450,3800,4150,4750,5010,5180,5280,0,0,5730,5850,6000,6150,6450,6600,7500,7700,8040,8690,9040,9210,9660,0,0,0,36000,36200,36350,36950,37550,37750,38250,38650,39650,41590,43590
},
{599,1199,1949,2399,2649,2749,3449,3799,4149,4749,4949,5179,5279,5379,0,0,5849,5999,6149,6449,6599,7399,7699,8039,8689,9039,9209,9659,9769,0,0,0,36199,36349,36949,37549,37749,38249,38649,39649,41589,43589,45589
}
};


UInt32 earfcnul_to_freq_band_ind[OAM_THREE][MAX_FREQBANDINDICATOR] =
{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43
 },
{18000,18600,19200,19950,20400,20650,20750,21450,21800,22150,22750,23010,23180,23280,0,0,23730,23850,24000,24150,24450,24600,25500,25700,26040,26690,27040,27210,0,0,0,0,36000,36200,36350,36950,37550,37750,38250,38650,39650,41590,43590
},
{18599,19199,19949,20399,20649,20749,21449,21799,22149,22749,22949,23179,23279,23379,0,0,23849,23999,24149,24449,24599,25399,25699,26039,26689,27039,27209,27659,0,0,0,0,36199,36349,36949,37549,37749,38249,38649,39649,41589,43589,45589
}
};
/* SPR 13781 Changes End */
/* SPR-10651 FIX End */
#define MAX_SUB_FRAME_ASSIGNMENTS_COUNT 7
#define MAX_SPECIAL_SUBFRAME_PATTERNS_COUNT 9
/* SubFrameAssignment */  /*SpecialSubframePatterns */ 
oam_prb_usage_factor_t  numDlUlScdeulable[MAX_SUB_FRAME_ASSIGNMENTS_COUNT][MAX_SPECIAL_SUBFRAME_PATTERNS_COUNT] = 
{
    /* TDD Config  0 */
    {{2, 6},{4, 6},{4, 6},{4, 6},{4, 6},{2, 6},{4, 6},{4, 6},{4, 6}},
    /* TDD Config  1 */
    {{4, 4},{6, 4},{6, 4},{6, 4},{6, 4},{4, 4},{6, 4},{6, 4},{6, 4}},
    /* TDD Config  2 */
    {{6, 2},{8, 2},{8, 2},{8, 2},{8, 2},{6, 2},{8, 2},{8, 2},{8, 2}},
    /* TDD Config 3 */
    {{6, 3},{7, 3},{7, 3},{7, 3},{7, 3},{6, 3},{7, 3},{7, 3},{7, 3}},
    /* TDD Config 4 */
    {{7, 2},{8, 2},{8, 2},{8, 2},{8, 2},{7, 2},{8, 2},{8, 2},{8, 2}},
    /* TDD Config 5 */
    {{8, 1},{9, 1},{9, 1},{9, 1},{9, 1},{8, 1},{9, 1},{9, 1},{9, 1}},
    /* TDD Config 6 */
    {{3, 5},{5, 5},{5, 5},{5, 5},{5, 5},{3, 5},{5, 5},{5, 5},{5, 5}} 
};

/* SPR 12920 Fix Start */
enumerated_string_fields_mapping_tbl_t qosDiscardTimer[RRM_OAM_PDCP_DISCARD_TIMER_COUNT] = 
{
    {"50ms",RRM_OAM_PDCP_DISCARD_TIMER_MS_50},
    {"100ms",RRM_OAM_PDCP_DISCARD_TIMER_MS_100},
    {"150ms",RRM_OAM_PDCP_DISCARD_TIMER_MS_150},
    {"300ms",RRM_OAM_PDCP_DISCARD_TIMER_MS_300},
    {"500ms",RRM_OAM_PDCP_DISCARD_TIMER_MS_500},
    {"750ms",RRM_OAM_PDCP_DISCARD_TIMER_MS_750},
    {"1500ms",RRM_OAM_PDCP_DISCARD_TIMER_MS_1500},
    {"infinity",RRM_OAM_PDCP_DISCARD_TIMER_INFINITY}
};
enumerated_string_fields_mapping_tbl_t qosSrPeriodicityVal[RRM_OAM_SR_PERIODICITY_COUNT] = 
{
    /* SPR 18871 Fix Start */
    {"5ms",RRM_OAM_SR_PERIODICITY_5_MS},
    {"10ms",RRM_OAM_SR_PERIODICITY_10_MS},
    {"20ms",RRM_OAM_SR_PERIODICITY_20_MS},
    {"40ms",RRM_OAM_SR_PERIODICITY_40_MS},
    {"80ms",RRM_OAM_SR_PERIODICITY_80_MS},
    {"1ms",RRM_OAM_SR_PERIODICITY_2_MS},
    {"2ms",RRM_OAM_SR_PERIODICITY_1_MS}
    /* SPR 18871 Fix End */
};
enumerated_string_fields_mapping_tbl_t qosSrMaxTransmission[RRM_OAM_SR_MAX_TRANSMISSION_COUNT] = 
{
    {"n4",RRM_OAM_SR_MAX_TRANSMISSION_N4},
    {"n8",RRM_OAM_SR_MAX_TRANSMISSION_N8},
    {"n16",RRM_OAM_SR_MAX_TRANSMISSION_N16},
    {"n32",RRM_OAM_SR_MAX_TRANSMISSION_N32},
    {"n64",RRM_OAM_SR_MAX_TRANSMISSION_N64},
    {"spare3",RRM_OAM_SR_MAX_TRANSMISSION_SPARE3},
    {"spare2",RRM_OAM_SR_MAX_TRANSMISSION_SPARE2},
    {"spare1",RRM_OAM_SR_MAX_TRANSMISSION_SPARE1}
};
enumerated_string_fields_mapping_tbl_t CellRestrictionIntraFreqReselection[RRM_OAM_INTRA_FREQ_RESELECTION_COUNT] = 
{
    {"Allowed",RRM_OAM_INTRA_FREQ_RESELECTION_ALLOWED},
    {"Not Allowed",RRM_OAM_INTRA_FREQ_RESELECTION_NOT_ALLOWED}
};
enumerated_string_fields_mapping_tbl_t PhyCellidRange[SON_OAM_PHY_CELLID_RANGE_COUNT] = 
{
    {"n4",RRM_OAM_N4},
    {"n8",RRM_OAM_N8},
    {"n12",RRM_OAM_N12},
    {"n16",RRM_OAM_N16},
    {"n24",RRM_OAM_N24},
    {"n32",RRM_OAM_N32},
    {"n48",RRM_OAM_N48},
    {"n64",RRM_OAM_N64},
    {"n84",RRM_OAM_N84},
    {"n96",RRM_OAM_N96},
    {"n128",RRM_OAM_N128},
    {"n168",RRM_OAM_N168},
    {"n252",RRM_OAM_N252},
    {"n504",RRM_OAM_N504},
    {"spare2",RRM_OAM_SPARE2},
    {"spare1",RRM_OAM_SPARE1},
};
enumerated_string_fields_mapping_tbl_t MeasBandwidth[RRM_OAM_BW_MEAS_COUNT] = 
{
    {"BW6",RRM_OAM_BW_MEAS_N_6},
    {"BW15",RRM_OAM_BW_MEAS_N_15},
    {"BW25",RRM_OAM_BW_MEAS_N_25},
    {"BW50",RRM_OAM_BW_MEAS_N_50},
    {"BW75",RRM_OAM_BW_MEAS_N_75},
    {"BW100",RRM_OAM_BW_MEAS_N_100}
};
enumerated_string_fields_mapping_tbl_t systemTimeInfo[RRM_OAM_SYN_SYS_TIME_COUNT] = 
{
    {"SYN",RRM_OAM_SYN_SYS_TIME},
    {"ASYN",RRM_OAM_ASYN_SYS_TIME}
};
int packetErrorLossRate[OAM_TWO][PCKT_ERR_LOSS_RATE_COUNT] = 
{
    {0, 1, 2, 3, 4, 5, 6},
    { RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_0,
        RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_1,
        RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_2,
        RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_3,
        RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_4,
        RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_5,
        RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_6}
};
#ifdef OAM_SON_ENABLE
int altBandClass[OAM_TWO][ALT_BAND_CLASS_COUNT] =
{{0, 1, 2, 3, 4, 5, 6,
    7, 8, 9, 10, 11, 12, 13,
    14, 15, 16, 17, 18, 19, 20,21},
{ BC1,
    BC2,
    BC3,
    BC4,
    BC5,
    BC6,
    BC7,
    BC8,
    BC9,
    BC10,
    BC11,
    BC12,
    BC13,
    BC14,
    BC15,
    BC16,
    BC17,
    BC18_V9A0,
    BC19_V9A0,
    BC20_V9A0,
    BC21_V9A0
}};
/* SPR 12920 Fix End */
#endif
/*SPR 23209 FIXED START */
/*
 ** This global array is used by OAM to keep a track of 
 ** the PLMN ids configuerd for each operator.
 ** While filling MAC INIT req , OAM will 
 ** - add the 1st operator info at 0th index of operator array in  MAC INIT req 
 ** - add the PLMN id of 1st operator at 0th index of mocn_plmn_list array
 ** and so on.
*/
/* SPR 23504/SES-341 Fix Start */
rrm_oam_cell_plmn_info_t  mocn_plmn_list[OAM_MAX_CELL_SUPPORTED][RRM_OAM_MAX_NUM_PLMNS];
/*
 ** This indicates the total count of valid PLMN ids in mocn_plmn_list.
 ** This count should be same as the number of operators configured in MAC INIT req
*/
UInt8 mocn_plmn_count[OAM_MAX_CELL_SUPPORTED];
rrm_oam_cell_plmn_info_t  rrm_oam_plmn_list[OAM_MAX_CELL_SUPPORTED][RRM_OAM_MAX_NUM_PLMNS];
UInt8 rrm_oam_plmn_count[OAM_MAX_CELL_SUPPORTED];
/* SPR 23504/SES-341 Fix End */

/*SPR 23209 FIXED END*/

/*******************************************************************************
  Private Types
 ******************************************************************************/
SInt32 lclTemp_value;
/* SPR-10651 FIX Start */
SInt32 freq_band_ind_val;
/* SPR-10651 FIX End */
char* parmeter_value;
UInt32 lclTemp_value2;

UInt8* p_temp;
extern oam_prov_req_t oam_prov_req;
extern prov_request_t prov_req;
/* CSR 00051709 Change Start*/
extern oam_s1SigLinkServerList_t oam_siglink_server_info;
/* CSR 00051709 Change End*/
unsigned int oam_atoh(char *str);

/*******************************************************************************
 *  FUNCTION NAME    : oam_xml_search_string_to_integer
 *  DESCRIPTION      : Used for parameter mapping
 *  PARAMETERS
 *      IN           : parmeter_value,enumerated_string_fields_mapping_tbl_t
 *
 *      OUT          : int
 *
 *  RETURNS          :  return int value of parameter on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

    int oam_xml_search_string_to_integer
(
 char  *parmeter_value,
 enumerated_string_fields_mapping_tbl_t  *par_table_address,
 int array_size
 )

{
    int counter;
    /* coverity 41169 */
    OAM_NULL_CHECK(parmeter_value != OAM_NULL);	
    for (counter = OAM_ZERO ; counter < array_size; counter++)
    {
        if(oam_strcmp(par_table_address[counter].display_string,parmeter_value) == OAM_ZERO)
        {
            return par_table_address[counter].internal_value;
            break;
        }
    }

    return OAM_MINUS_ONE;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_xml_search_integer_to_integer
 *  DESCRIPTION      : Used for parameter mapping
 *  PARAMETERS
 *      IN           : parmeter_value,int
 *
 *      OUT          : int
 *
 *  RETURNS          :  return int value of parameter on Success
 *                      OAM_INVALID_VALUE(failure value) on Failure
 *******************************************************************************/

    int oam_xml_search_integer_to_integer
(
 char  *parameter_value,
 int   *int_arr_param,
 int array_size
 )

{
    if(OAM_INVALID_VALUE == (oam_atoi(parameter_value)))
    {
		OAM_LOG(OAM, OAM_WARNING,"parameter value not found in xml");
        oam_handle_invalid_startup_config();
    }

    UInt16 status=oam_search_integer_to_interger(parameter_value,int_arr_param,(oam_counter_t)array_size);
    if(status==OAM_ONE)
        return oam_atoi(parameter_value);
    else
    {
		OAM_LOG(OAM, OAM_WARNING,"parameter value not found in enum");
        oam_handle_invalid_startup_config();
    }
    return OAM_ZERO;    
}

#ifdef OAM_SHARED_MEM_LOGGER
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_shared_memory_conf
 *  DESCRIPTION      : This function is used to populate OAM shared memory
 *                      configuration
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
oam_populate_shared_memory_conf(void)
{
	Char8 *tag_value = OAM_NULL;

	OAM_FUN_ENTRY_TRACE();


	tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.oam_shared_mem_config,
			"wait_interval");

	if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read node \"wait_interval\", "
				"using default ERROR level.");
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.wait_interval = OAM_ERROR;
	}
	else {
		/* setting OAM log level */
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.wait_interval = oam_atoi(tag_value);
		OAM_LOG(OAM, OAM_INFO, "\"wait_interval\" set to [%u] ",
            oam_prov_req.oam_igd_params.oam_shared_mem_conf.wait_interval);
	}

	tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.oam_shared_mem_config,
			"log_path");

	if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read node \"log_path\", "
				"using default ERROR level.");
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_path[0] = '\0';
	}
	else {
		oam_strcpy(oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_path, tag_value);
        oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_path[oam_strlen(tag_value)] = '\0';
		OAM_LOG(OAM, OAM_INFO, "\"log_path\" set to [%s] ",
            oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_path);
	}
	tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.oam_shared_mem_config,
			"shm_size");

	if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read node \"shm_size\", "
				"using default ERROR level.");
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.shm_size = OAM_ERROR;
	}
	else {
		/* setting OAM log level */
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.shm_size = oam_atoi(tag_value);
		OAM_LOG(OAM, OAM_INFO, "\"shm_size\" set to [%u] ",
            oam_prov_req.oam_igd_params.oam_shared_mem_conf.shm_size);
	}

	tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.oam_shared_mem_config,
			"log_file_size");

	if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read node \"log_file_size\", "
				"using default ERROR level.");
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_file_size = OAM_ERROR;
	}
	else {
		/* setting OAM log level */
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_file_size = oam_atoi(tag_value);
		OAM_LOG(OAM, OAM_INFO, "\"log_file_size\" set to [%u] ",
            oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_file_size);
	}

	tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.oam_shared_mem_config,
			"log_chunk_count");

	if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read node \"log_chunk_count\", "
				"using default ERROR level.");
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_chunk_count = OAM_ERROR;
	}
	else {
		/* setting OAM log level */
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_chunk_count = oam_atoi(tag_value);
		OAM_LOG(OAM, OAM_INFO, "\"log_chunk_count\" set to [%u] ",
            oam_prov_req.oam_igd_params.oam_shared_mem_conf.log_chunk_count);
	}

	tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.oam_shared_mem_config,
			"cpu_bitmap");

	if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read node \"cpu_bitmap\", "
				"using default ERROR level.");
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.cpu_bitmap = OAM_ERROR;
	}
	else {
		/* setting OAM log level */
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.cpu_bitmap = oam_atoi(tag_value);
		OAM_LOG(OAM, OAM_INFO, "\"cpu_bitmap\" set to [%u] ",
            oam_prov_req.oam_igd_params.oam_shared_mem_conf.cpu_bitmap);
	}

	tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.oam_shared_mem_config,
			"file_count");

	if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read node \"file_count\", "
				"using default ERROR level.");
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.file_count = OAM_ERROR;
	}
	else {
		/* setting OAM log level */
		oam_prov_req.oam_igd_params.oam_shared_mem_conf.file_count = oam_atoi(tag_value);
		OAM_LOG(OAM, OAM_INFO, "\"file_count\" set to [%u] ",
            oam_prov_req.oam_igd_params.oam_shared_mem_conf.file_count);
	}

	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}
#endif
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_configrable_core_num
 *  DESCRIPTION      : This function is used to populate the mac init parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_configrable_core_num(void)
    /* - SPR 17439 */
{
    OAM_FUN_ENTRY_TRACE();

    Char8 *tag_value = OAM_NULL;
    AdvL_LogLevel adv_log_level;
    AdvL_ContextIndex log_index = OAM_ZERO;

/*SPR 21889 +- */

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.eNodeBParams,
            "OAMLogLevel");

    if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
        OAM_LOG(OAM, OAM_WARNING, "Failed to read node \"OAMLogLevel\", "
                "using default ERROR level.");
        prov_req.log_level = OAM_ERROR;
    }
    else {
        /* setting OAM log level */
        prov_req.log_level = oam_atoi(tag_value);
        OAM_LOG(OAM, OAM_INFO, "\"OAMLogLevel\" set to [%d] ",prov_req.log_level);
    }

    adv_log_level = oam_convert_log_level(prov_req.log_level);
    set_loglevel_limit(log_index, adv_log_level);


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/* SPR-10651 FIX Start */
/*******************************************************************************
 *  FUNCTION NAME    : validate_earfcndl_with_freq_band_ind_value
 *  DESCRIPTION      : This function used to validate the earfcn from
 *  freqBandIndicator values
 *  PARAMETERS
 *      IN           : NONE
 * 
 *      OUT          : NONE
 * 
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 ********************************************************************************/
    oam_return_et
validate_earfcndl_with_freq_band_ind_value(UInt32 earfcn)
{
    UInt32    earfcn_low = OAM_ZERO, 
              earfcn_high = OAM_ZERO;

    UInt8 counter = OAM_ZERO, count = MAX_FREQBANDINDICATOR;
    oam_return_et retStatus = OAM_FAILURE;
    UInt32 *par_table_address = earfcndl_to_freq_band_ind[OAM_ZERO];

    for (counter = OAM_ZERO; counter < MAX_FREQBANDINDICATOR; counter++)
    {
        if(*(par_table_address+ counter) == (UInt16)freq_band_ind_val)
        {
            earfcn_low =  *(par_table_address + count + counter);
            earfcn_high = *(par_table_address + (count*2) + counter);
            break;
        }
    }

    if((earfcn_low <= earfcn) && (earfcn <= earfcn_high))
    {
        retStatus = OAM_SUCCESS;
    }
    else
    {
        retStatus = OAM_FAILURE;
		OAM_LOG(OAM, OAM_WARNING,
				"Value of dl_earfcn is out of allowed range for current FreqBandIndicator %d and range is from %d to %d",
                freq_band_ind_val,earfcn_low,
                earfcn_high);
    } 

    return retStatus;
}

/*******************************************************************************
 *  FUNCTION NAME    : validate_earfcnul_with_freq_band_ind_value
 *  DESCRIPTION      : This function used to validate the earfcn from
 *  freqBandIndicator values
 *  PARAMETERS
 *      IN           : NONE
 * 
 *      OUT          : NONE
 * 
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 ********************************************************************************/
    oam_return_et
validate_earfcnul_with_freq_band_ind_value(UInt32 earfcn)
{
    UInt32    earfcn_low = OAM_ZERO, 
              earfcn_high = OAM_ZERO;

    UInt8 counter = OAM_ZERO, count = MAX_FREQBANDINDICATOR;
    oam_return_et retStatus = OAM_FAILURE;
    UInt32 *par_table_address = earfcnul_to_freq_band_ind[OAM_ZERO];

    for (counter = OAM_ZERO; counter < MAX_FREQBANDINDICATOR; counter++)
    {
        if(*(par_table_address+ counter) == (UInt16)freq_band_ind_val)
        {
            earfcn_low =  *(par_table_address + count + counter);
            earfcn_high = *(par_table_address + (count*2) + counter);
            break;
        }
    }

    if((earfcn_low <= earfcn) && (earfcn <= earfcn_high))
    {
        retStatus = OAM_SUCCESS;
    }
    else
    {
        retStatus = OAM_FAILURE;
		OAM_LOG(OAM, OAM_WARNING,
				"Value of ul_earfcn is out of allowed range for current FreqBandIndicator %d and range is from %d to %d",
                freq_band_ind_val,earfcn_low,
                earfcn_high);
    } 

    return retStatus;
}

/* SPR-10651 FIX End */


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_support_for_log_archival
 *  DESCRIPTION      : This function is used to populate the log archival parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_support_for_log_archival(void)
    /* - SPR 17439 */
{
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=
        oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_g.eNodeBParams,"OAM_Support_Log_Archival"));
    oam_prov_req.oam_params.oam_log_archival_supported = lclTemp_value;

    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_lan_device
 *  DESCRIPTION      : This function is used to populate the LAN Device parameters
 *  PARAMETERS
 *      IN           : Pointer of oam_l2_req_t
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
    oam_return_et
oam_populate_lan_device(oam_l2_req_t *p_l2_req)
{
    OAM_FUN_ENTRY_TRACE();
    UInt8  count = OAM_ZERO;
    UInt8 len = OAM_ZERO;
    oam_bool_et Enable = OAM_FALSE;
    UInt32 IpInterfaceNumEntries = OAM_ZERO;
    oam_ip_interface_type_et IpInterface = OAM_INVALID_INTERFACE;
    oam_return_et ret_val = OAM_SUCCESS;
    /* CSR 57651 FIx Start*/
    Char8 * p_temp1[OAM_FIVE] = {OAM_ZERO};
    Char8 * temp = OAM_NULL;
    UInt8 counter =  OAM_ZERO, val = OAM_ZERO;
    UInt8 Interface_Type[OAM_MAX_NUM_IP_INTRFACES] = {OAM_ZERO};
    UInt16 Port_Num[OAM_MAX_NUM_IP_INTRFACES] = {OAM_ZERO};
    UInt8  *IpInterface_str = OAM_NULL;
    Char8 *port_str = OAM_NULL;
#ifdef LTE_EMBMS_SUPPORTED
    UInt8 num_ip_addr = OAM_ZERO;
#endif

    oam_egtpu_initdb_req_t *p_egtpu_initdb = 
        &p_l2_req->oam_egtpu_req.egtpu_initdb_req;


    OAM_FUN_ENTRY_TRACE();

    UInt16 IpInterfaceCount = OAM_ZERO, IpInterfaceCount_populated = OAM_ZERO;    

    IpInterfaceNumEntries = 
        oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.LAN_HostConfigManagement,"IPInterfaceNumberOfEntries"));

    while((xml_struct_tr196_g.IPInterface[count]!=OAM_NULL)&&(IpInterfaceCount_populated < IpInterfaceNumEntries))
    {
        Enable = (oam_bool_et)oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.IPInterface[count],"Enable"));
        if (OAM_TRUE == Enable) { 
            IpInterface_str = oam_xmlNodeGetContent(xml_struct_tr196_g.IPInterface[count],"X_VENDOR_INTERFACE_TYPE");
            temp = strtok((char *)IpInterface_str,","); /* for Comma Seperated Value of Interface Type */
            while(temp) {
                Interface_Type[counter]= oam_atoi(temp);
                ++counter;
                temp = strtok(OAM_NULL, ",");
            }
            IpInterfaceCount = counter;
            port_str = (Char8*)oam_xmlNodeGetContent(
                    xml_struct_tr196_g.IPInterface[count],
                    "X_VENDOR_SOURCE_PORT_NUMBER");

            temp = strtok(port_str, ",");
            counter = OAM_ZERO;
            while(temp) {
                Port_Num[counter]= oam_atoi(temp);
                ++counter;
                temp = strtok(OAM_NULL, ",");
            }
            if(counter != IpInterfaceCount) {
				OAM_LOG(OAM,OAM_WARNING,
                        "No of Interface and port is not matching");
                return OAM_FAILURE;
            }
            p_temp = oam_xmlNodeGetContent(
                    xml_struct_tr196_g.IPInterface[count],
                    "IPInterfaceIPAddress");
            while(val < IpInterfaceCount) { 
                switch(Interface_Type[val]) {
                    case OAM_GTPU_INTERFACE:
                    if(oam_isValidIp4(p_temp)) {
                        /* Currently Supported Only One IP ADDRESS at egtpu */
                        if(p_egtpu_initdb->numMyAddr4 < OAM_ONE) {  
                            ++p_egtpu_initdb->numMyAddr4;
                            p_egtpu_initdb->myAddr4.length = OAM_FOUR;
                            p_temp1[OAM_ZERO] =
                                oam_strtok((Char8*)p_temp, ".");
                            lclTemp_value = OAM_ZERO;
                            while(p_temp1[lclTemp_value]) {
                                eGtpu_Ipv4Addr[count][lclTemp_value] =
                                    oam_atoi(p_temp1[lclTemp_value]);
                                ++lclTemp_value;
                                p_temp1[lclTemp_value] =
                                    oam_strtok(OAM_NULL, ".");
                            }

                            p_egtpu_initdb->myAddr4.value =
                                eGtpu_Ipv4Addr[count];
                        }
                    }
                    else if(oam_isValidIp6(p_temp)) {
                        if(p_egtpu_initdb->numMyAddr6 <= OAM_ONE) {
                            p_egtpu_initdb->myAddr6.length = OAM_SIXTEEN;
                            oam_inet_pton(AF_INET6,
                                    (Char8*)p_temp,
                                    eGtpu_Ipv6Addr[p_egtpu_initdb->numMyAddr6]);
                            p_egtpu_initdb->myAddr6.value =
                                eGtpu_Ipv6Addr[p_egtpu_initdb->numMyAddr6];
                            ++p_egtpu_initdb->numMyAddr6;
                            break;
                        }
                    }
                    else {
							OAM_LOG(OAM, OAM_WARNING, "The number of EGTPU ip "
                                "adderesses exceeds max limit");
                    }
                    break;

                    /* LWA changes start*/
                    case OAM_XWAP_INTERFACE:
                    OAM_LOG(OAM, OAM_INFO, "LWA in system is disabled, So not reading IP address for XWAP");
                    break;
                    /* LWA changes end*/
                    case OAM_S1AP_INTERFACE:
                    if(oam_isValidIp4(p_temp)) {
                        if(OAM_S1AP_INFO.enb_comm_info.num_ip_addr
                                < MAX_NUM_IP_ADDR) {
                            OAM_S1AP_INFO.enb_comm_info.port =
                                Port_Num[val];

                            /*SPR 20633 Fix START*/
                            OAM_S1AP_INFO.enb_comm_info.
                                bitmask |= ENB_COMM_INFO_IPV4_NUM_ADDR_PRESENT;
                            /*SPR 20633 Fix End*/
                            oam_strncpy((Char8*)OAM_S1AP_INFO.enb_comm_info.
                                    ip_addr[OAM_S1AP_INFO.enb_comm_info.num_ip_addr].
                                    ip_addr, (Char8*)p_temp,
                                    MAX_IP_ADDRESS_LENGTH);

                            oam_strncpy(ipTable[OAM_ONE], (Char8*)p_temp,
                                    sizeof(ipTable[OAM_ONE]));
                            /*SPR 20633 Fix START*/
                            OAM_S1AP_INFO.enb_comm_info.
                                bitmask |= ENB_COMM_INFO_IPV4_ADDR_PRESENT;
                            /*SPR 20633 Fix End*/
                            ++OAM_S1AP_INFO.enb_comm_info.num_ip_addr;
                        }
                    }
                    else if(oam_isValidIp6((UInt8 *)p_temp)) {
                        OAM_S1AP_INFO.enb_comm_info.port = Port_Num[val];

                        OAM_S1AP_INFO.enb_comm_info.
                            bitmask |= ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT;
                        oam_strncpy((Char8*)OAM_S1AP_INFO.enb_comm_info.
                                ipv6_addr[OAM_S1AP_INFO.enb_comm_info.num_ipv6_addr].
                                ipv6_addr, (Char8*)p_temp,
                                oam_strlen((Char8*)p_temp)+ OAM_ONE);
                        OAM_S1AP_INFO.enb_comm_info.
                            bitmask |= ENB_COMM_INFO_IPV6_ADDR_PRESENT;
                        ++OAM_S1AP_INFO.enb_comm_info.num_ipv6_addr;
                    } 
                    else {
							OAM_LOG(OAM, OAM_WARNING, "The number of S1AP IP "
                                "adderesses exceeds max limit");
                    }
                    break;

                    case OAM_X2AP_INTERFACE:
                    if(oam_isValidIp4(p_temp)==OAM_ONE)
                    {
                        /* coverity 57687 62098 */  
                        if ( oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                x2ap_info.local_enb_comm_info.num_ip_addr <= MAX_X2AP_NUMIPADDR )
                        { 
                            (oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                             x2ap_info.local_enb_comm_info.num_ip_addr)++ ;
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                x2ap_info.local_enb_comm_info.port=Port_Num[val];
                            /* SPR 20633 changes Start */
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.local_enb_comm_info.
                                bitmask|= X2_ENB_COMM_INFO_IPV4_NUM_ADDR_PRESENT;
                            /* SPR 20633 changes End */
                            /* coverity 57687 */
                            /* SPR-10890 Start*/
                            if (oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                    x2ap_info.local_enb_comm_info.num_ip_addr < MAX_NUM_IP_ADDR)
                            {
                                oam_strncpy((char *)oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                        x2ap_info.local_enb_comm_info.ip_addr[oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                        x2ap_info.local_enb_comm_info.num_ip_addr - OAM_ONE].ip_addr,(const char *)p_temp
                                        ,sizeof(oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.
                                            local_enb_comm_info. ip_addr[oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                            x2ap_info.local_enb_comm_info.num_ip_addr- OAM_ONE].ip_addr) - OAM_ONE);
                            }
                            /*COVERITY FIX 62097*/

                            oam_strncpy(ipTable[OAM_TWO],(const char *)p_temp,oam_strlen((char *)p_temp) + OAM_ONE);

                            /* SPR 20633 changes Start */
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.local_enb_comm_info.
                                bitmask|= X2_ENB_COMM_INFO_IPV4_IP_ADDR_PRESENT;
                            /* SPR 20633 changes End */
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.bitmask |= RRC_X2AP_PROVISION_INFO_PRESENT;
                        }
                    }
                    else if(oam_isValidIp6((UInt8 *)p_temp) == OAM_ONE)
                    {
                        if( oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                x2ap_info.local_enb_comm_info.num_ipv6_addr <= MAX_X2AP_NUMIPADDR )
                        {
                            (oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                             x2ap_info.local_enb_comm_info.num_ipv6_addr)++ ;
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                x2ap_info.local_enb_comm_info.port=Port_Num[val];

                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.local_enb_comm_info.
                                bitmask|= X2_ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT;

                            if (oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
                                    x2ap_info.local_enb_comm_info.num_ipv6_addr < MAX_NUM_IP_ADDR)
                            {
                                oam_strncpy((char *)oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.
                                        local_enb_comm_info.ipv6_addr[oam_prov_req.oam_l3_req.oam_x2ap_req.
                                        x2ap_oam_prov.x2ap_info.local_enb_comm_info.num_ipv6_addr - OAM_ONE].ipv6_addr,(const char *)p_temp
                                        ,oam_strlen((char *)p_temp)+ OAM_ONE );
                            }


                            /* SPR-10890 End*/
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.local_enb_comm_info.
                                bitmask|= X2_ENB_COMM_INFO_IPV6_IP_ADDR_PRESENT;
                            /* SPR 9821 Changes */
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.bitmask |= RRC_X2AP_PROVISION_INFO_PRESENT;
                            /* SPR 9821 Changes End*/
                        }
                    }
                    else {
							OAM_LOG(OAM,OAM_WARNING,"The number of X2AP ip adderesses exceeds max limit");
                    }
                    break;
                    case OAM_TR069_INTERFACE:
                    len = oam_strlen((char *)p_temp); 
                    oam_memcpy(oam_prov_req.oam_tr069_req.tr069_init_params.henb_self_address,p_temp,len);
                    oam_memcpy(oam_prov_req.oam_tr069_req.tr069_init_params.henb_address,p_temp,len);
                    break;
#ifdef LTE_EMBMS_SUPPORTED
                    case OAM_M2AP_INTERFACE:
                        if (oam_isValidIp4(p_temp)) 
                        {
                            num_ip_addr = M2AP_PROV_REQ.enb_comm_info.
                                num_ip_addr;
                            if (num_ip_addr < MAX_NUM_IP_ADDR) 
                            {
                                M2AP_PROV_REQ.enb_comm_info.port = 
                                    Port_Num[val];
                                 OAM_LOG(OAM, OAM_DETAILED, "\n VALUE OF eNB Port is : %d", M2AP_PROV_REQ.enb_comm_info.port);  
                                oam_strncpy((Char8*)M2AP_PROV_REQ.enb_comm_info.
                                        ip_addr[num_ip_addr].ipv4_addr,
                                        (Char8*)p_temp,
                                        MAX_IP_ADDRESS_LENGTH);
                                
                                OAM_LOG(OAM, OAM_DETAILED, "\n VALUE OF eNB  is ipaddr: %s", (Char8*)M2AP_PROV_REQ.enb_comm_info.ip_addr[num_ip_addr].ipv4_addr);
                                ++(M2AP_PROV_REQ.enb_comm_info.num_ip_addr);
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_ERROR,
                                        "The number of M2AP IPv4 "
                                        "adderesses exceeds max limit");

                                ret_val = OAM_FAILURE;
                                break;
                            }
                             //   OAM_LOG(OAM, OAM_DETAILED, "\n VALUE OF eNB numIPAddr is : %d", M2AP_PROV_REQ.enb_comm_info.num_ip_addr);
                        }
                        else if (oam_isValidIp6((UInt8 *)p_temp)) 
                        {
                            num_ip_addr =M2AP_PROV_REQ.enb_comm_info.
                                num_ipv6_addr;
                            if (num_ip_addr < MAX_NUM_IP_ADDR) 
                            {
                                M2AP_PROV_REQ.enb_comm_info.port = 
                                    Port_Num[val];
                                M2AP_PROV_REQ.enb_comm_info.bitmask |= 
                                    ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT;

                                oam_strncpy((Char8*)M2AP_PROV_REQ.
                                        enb_comm_info.
                                        ipv6_addr[num_ip_addr].ipv6_addr,
                                        (Char8*)p_temp,
                                        M2AP_MAX_IPV6_ADDR_LENGTH);

                                M2AP_PROV_REQ.enb_comm_info.bitmask |=
                                    ENB_COMM_INFO_IPV6_ADDR_PRESENT;

                                ++M2AP_PROV_REQ.enb_comm_info.num_ipv6_addr;
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_ERROR,
                                        "The number of M2AP IPv6 "
                                        "adderesses exceeds max limit");

                                ret_val = OAM_FAILURE;
                                break;
                            }
                        }
                        else 
                        {
                            OAM_LOG(OAM, OAM_ERROR, "Invalid address type: %d",
                                    Interface_Type[val]);
                        }
                        break;
                        /* 7.0 OAM_SSI Fix Start */
#else
                    case OAM_M2AP_INTERFACE:
                        OAM_LOG(OAM, OAM_INFO, "EMBMS in system is disabled, So not "
                                "reading IP address for M2AP");
                        break;
                        /* 7.0 OAM_SSI Fix End */ 
#endif

                    default:                
						OAM_LOG(OAM,OAM_WARNING,"Wrong value for ip interface %d", IpInterface);
                    ret_val = OAM_FAILURE;
                }
                val++;
            }
            IpInterfaceCount_populated += IpInterfaceCount;
            counter = val= OAM_ZERO;
        }
        count++;
    }/*End of While loop */
    /* CSR 57651 FIx End*/
    OAM_FUN_EXIT_TRACE();
    return ret_val;
}
/*SPR 21096 Start*/
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_lan_device
 *  DESCRIPTION      : This function is used to populate the LAN Device parameters
 *  PARAMETERS
 *      IN           : Pointer of oam_l2_req_t
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
    oam_return_et
oam_populate_lan_device_1(oam_l2_req_t *p_l2_req)
{
    OAM_FUN_ENTRY_TRACE();
    UInt8  count = OAM_ZERO;
    //UInt8 len = OAM_ZERO;
    oam_bool_et Enable = OAM_FALSE;
    UInt32 IpInterfaceNumEntries = OAM_ZERO;
    //oam_ip_interface_type_et IpInterface = OAM_INVALID_INTERFACE;
    oam_return_et ret_val = OAM_SUCCESS;
    /* CSR 57651 FIx Start*/
    Char8 * p_temp1[OAM_FIVE] = {OAM_ZERO};
    Char8 * temp = OAM_NULL;
    UInt8 counter =  OAM_ZERO, val = OAM_ZERO;
    UInt8 Interface_Type[OAM_MAX_NUM_IP_INTRFACES] = {OAM_ZERO};

    //UInt16 Port_Num[OAM_MAX_NUM_IP_INTRFACES] = {OAM_ZERO};
    UInt8  *IpInterface_str = OAM_NULL;
    Char8 *port_str = OAM_NULL;

    oam_egtpu_initdb_req_t *p_egtpu_initdb = 
        &p_l2_req->oam_egtpu_req.egtpu_initdb_req;


    OAM_FUN_ENTRY_TRACE();

    UInt16 IpInterfaceCount = OAM_ZERO, IpInterfaceCount_populated = OAM_ZERO;    

    IpInterfaceNumEntries = 
        oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.LAN_HostConfigManagement,"IPInterfaceNumberOfEntries"));

    while((xml_struct_tr196_g.IPInterface[count]!=OAM_NULL)&&(IpInterfaceCount_populated < IpInterfaceNumEntries))
    {
        Enable = (oam_bool_et)oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.IPInterface[count],"Enable"));
        if (OAM_TRUE == Enable) { 
            IpInterface_str = oam_xmlNodeGetContent(xml_struct_tr196_g.IPInterface[count],"X_VENDOR_INTERFACE_TYPE");
            temp = strtok((char *)IpInterface_str,","); /* for Comma Seperated Value of Interface Type */
            while(temp) {
                Interface_Type[counter]= oam_atoi(temp);
                ++counter;
                temp = strtok(OAM_NULL, ",");
            }
            IpInterfaceCount = counter;
            port_str = (Char8*)oam_xmlNodeGetContent(
                    xml_struct_tr196_g.IPInterface[count],
                    "X_VENDOR_SOURCE_PORT_NUMBER");

            temp = strtok(port_str, ",");
            counter = OAM_ZERO;
            while(temp) {
                //Port_Num[counter]= oam_atoi(temp);
                ++counter;
                temp = strtok(OAM_NULL, ",");
            }
            if(counter != IpInterfaceCount) {
				OAM_LOG(OAM,OAM_WARNING,
                        "No of Interface and port is not matching");
                return OAM_FAILURE;
            }
            p_temp = oam_xmlNodeGetContent(
                    xml_struct_tr196_g.IPInterface[count],
                    "IPInterfaceIPAddress");
            while(val < IpInterfaceCount) { 
                switch(Interface_Type[val]) {
                    case OAM_GTPU_INTERFACE:
                    if(oam_isValidIp4(p_temp)) {
                        /* Currently Supported Only One IP ADDRESS at egtpu */
                        if(p_egtpu_initdb->numMyAddr4 < OAM_ONE) {  
                            ++p_egtpu_initdb->numMyAddr4;
                            p_egtpu_initdb->myAddr4.length = OAM_FOUR;
                            p_temp1[OAM_ZERO] =
                                oam_strtok((Char8*)p_temp, ".");
                            lclTemp_value = OAM_ZERO;
                            while(p_temp1[lclTemp_value]) {
                                eGtpu_Ipv4Addr[count][lclTemp_value] =
                                    oam_atoi(p_temp1[lclTemp_value]);
                                ++lclTemp_value;
                                p_temp1[lclTemp_value] =
                                    oam_strtok(OAM_NULL, ".");
                            }

                            p_egtpu_initdb->myAddr4.value =
                                eGtpu_Ipv4Addr[count];
                        }
                    }
                    else if(oam_isValidIp6(p_temp)) {
                        if(p_egtpu_initdb->numMyAddr6 <= OAM_ONE) {
                            p_egtpu_initdb->myAddr6.length = OAM_SIXTEEN;
                            oam_inet_pton(AF_INET6,
                                    (Char8*)p_temp,
                                    eGtpu_Ipv6Addr[p_egtpu_initdb->numMyAddr6]);
                            p_egtpu_initdb->myAddr6.value =
                                eGtpu_Ipv6Addr[p_egtpu_initdb->numMyAddr6];
                            ++p_egtpu_initdb->numMyAddr6;
                            break;
                        }
                    }
                    else {
							OAM_LOG(OAM, OAM_WARNING, "The number of EGTPU ip "
                                "adderesses exceeds max limit");
                    }
                    break;

                }
                val++;
            }
            IpInterfaceCount_populated += IpInterfaceCount;
            counter = val= OAM_ZERO;
        }
        count++;
    }/*End of While loop */
    /* CSR 57651 FIx End*/
    OAM_FUN_EXIT_TRACE();
    return ret_val;
}
/*SPR 21096 End*/
/*SPR 20697 Fix Start*/
/*******************************************************************************
 *  FUNCTION NAME    : oam_mapped_packet_delay_budget_param
 *  DESCRIPTION      : This function is used to map the pktDlyBdgt parameter 
 *                      value from enum to actual value.
 *  PARAMETERS
 *      IN           : rrm_oam_packet_delay_budget_et
 *
 *      OUT          : None 
 *
 *  RETURNS          : Integer
 *
 *******************************************************************************/

UInt16 oam_mapped_packet_delay_budget_param(rrm_oam_packet_delay_budget_et pkt_dly)
{
    OAM_FUN_ENTRY_TRACE();
    UInt16 budget = 0;
    switch (pkt_dly)
    {
        case RRM_OAM_PACKET_DELAY_BUDGET_MS50:
        budget = 50;
        break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS100:
        budget = 100;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS150:
        budget = 150;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS200:
        budget = 200;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS300:
        budget = 300;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS400:
        budget = 400;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS500:
        budget = 500;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS600:
        budget = 600;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS700:
        budget = 700;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS800:
        budget = 800;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS900:
        budget = 900;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS1000:
        budget = 1000;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS1500:
        budget = 1500;
        break;

        case RRM_OAM_PACKET_DELAY_BUDGET_MS2000:
        budget = 2000;
        break;
        default:
            OAM_LOG(OAM, OAM_WARNING, "Value received is out of range [%d], returned value is [%d]",
                pkt_dly,budget);
    }
    OAM_FUN_EXIT_TRACE();
    return budget;
}

/*SPR 20697 Fix Stop*/


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_qos_params
 *  DESCRIPTION      : This function is used to populate the l2 qos parameters
 *  PARAMETERS
 *      IN           : pointers of oam_l2_req_t,oam_rrm_cell_config_req_t
 *
 *      OUT          : NONE
 *
 *  RETURNS          : void 
 *                      
 *******************************************************************************/
void  oam_populate_l2_qos_params(oam_l2_req_t *p_l2_init,
        oam_rrm_cell_config_req_t *p_rrm_cellconfig)
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 num_qos_profiles = p_rrm_cellconfig->epc_info.epc_params.
        num_valid_qos_profiles;
	oam_mac_init_req_params_t *p_mac_init =
        &p_l2_init->oam_mac_req.mac_init_req;
    oam_rlc_init_layer_req_t *p_rlc_init =
        &p_l2_init->oam_rlc_req.rlc_init_req;
    UInt8 cnt = 0;

    for(cnt = 0; cnt < num_qos_profiles; ++cnt) {
        p_mac_init->qosQciInfo[cnt].QCI = p_rrm_cellconfig->epc_info.
            epc_params.qos_config_params[cnt].qci;
        p_rlc_init->rlcQosQciInfo[cnt].qci = p_mac_init->qosQciInfo[cnt].QCI;  

        p_mac_init->qosQciInfo[cnt].eResType =(LogicalChannelType)
            p_rrm_cellconfig->epc_info.epc_params.
            qos_config_params[cnt].type;
        p_rlc_init->rlcQosQciInfo[cnt].eResType =(rlcLogicalChannelType)
            p_mac_init->qosQciInfo[cnt].eResType;   

        p_mac_init->qosQciInfo[cnt].priority = p_rrm_cellconfig->epc_info.
            epc_params.qos_config_params[cnt].priority;
        p_rlc_init->rlcQosQciInfo[cnt].priority =
            p_mac_init->qosQciInfo[cnt].priority;   
        /*SPR 20697 Fix Start*/
        p_mac_init->qosQciInfo[cnt].pktDlyBdgt = 
            oam_mapped_packet_delay_budget_param(p_rrm_cellconfig->epc_info.epc_params.qos_config_params[cnt].packet_delay_budget);
        /*SPR 20697 Fix Stop*/
        p_rlc_init->rlcQosQciInfo[cnt].pktDlyBdgt =
            p_mac_init->qosQciInfo[cnt].pktDlyBdgt;

        p_mac_init->qosQciInfo[cnt].pktErrLossRate =
            p_rrm_cellconfig->epc_info.
            epc_params.qos_config_params[cnt].
            packet_error_loss_rate;
        p_rlc_init->rlcQosQciInfo[cnt].pktErrLossRate =
            p_mac_init->qosQciInfo[cnt].pktErrLossRate;
    }
    OAM_FUN_EXIT_TRACE();
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_mac_log_level_param
 *  DESCRIPTION      : This function is used to populate the 
 *                     mac log level parameters
 *  PARAMETERS       
 *      IN           : Pointer of oam_l2_req_t
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

    oam_return_et  
oam_populate_l2_mac_log_level_param(oam_l2_req_t  *p_l2_req)
{
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.L2params,"logLevelMAC"));
    p_l2_req->oam_mac_req.mac_set_log_level_req.logLevel = lclTemp_value;

    OAM_FUN_EXIT_TRACE();  
    return OAM_SUCCESS;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_sps_syswide_params
 *  DESCRIPTION      : This function is used to populate the l2 qos parameters
 *  PARAMETERS
 *      IN           : pointers of XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_rrm_cell_config_req_t, oam_l2_req_t and cell_index
 *      OUT          : NONE
 *
 *  RETURNS          : OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 *******************************************************************************/

oam_return_et
    oam_populate_l2_sps_syswide_params
(
 XML_struct_cell_config    *p_cell_spec_params,
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_rrm_cell_config_req_t *p_rrm_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    UInt8 cnt = 0;
    Char8* tag_value = OAM_NULL;
    UInt8 enable_flag = 0;
    xmlNode *p_xml_tag = OAM_NULL;
    UInt8 num_qos_profiles = p_rrm_cellconfig->epc_info.epc_params.
        num_valid_qos_profiles;
    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;
    oam_rlc_init_layer_req_t *p_rlc_init =
        &p_l2_req->oam_rlc_req.rlc_init_req;
    oam_pdcp_init_layer_req_t *p_pdcp_init =
        &p_l2_req->oam_pdcp_req.pdcp_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;
    oam_rlc_s_cell_info_t *p_rlc_s_cell_info = OAM_NULL;
    oam_pdcp_s_cell_info_t *p_pdcp_s_cell_info = OAM_NULL;

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];

        p_rlc_s_cell_info = &p_l2_req->oam_rlc_req.rlc_init_req.
            sCellInfo[cell_cnt_index - 1];

        p_pdcp_s_cell_info = &p_l2_req->oam_pdcp_req.pdcp_init_req.
            sCellInfo[cell_cnt_index - 1];
    }


    for(cnt = 0; cnt < num_qos_profiles; ++cnt) {
        /* SPR 11060 + */
        xmlNode * QoS_node;
        QoS_node = p_cell_spec_params->QoS[cnt];
        tag_value = (Char8*)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SPS_CONFIG_ENABLED");
        lclTemp_value = oam_atoi(tag_value);

        if(!cell_cnt_index) {
            p_mac_init->spsSysWideParams.qciSpslist[cnt] = lclTemp_value;
            p_rlc_init->qciSpslist[cnt] = lclTemp_value;
            p_pdcp_init->qciSpslist[cnt] = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitSPSParams.spsSysWideParams.qciSpslist[cnt] =
                lclTemp_value;
            p_rlc_s_cell_info->qciSpslist[cnt] = lclTemp_value;
            p_pdcp_s_cell_info->qciSpslist[cnt] = lclTemp_value;
        }
        /* SPR 11060 - */
        enable_flag = p_rrm_cellconfig->epc_info.epc_params.
            qos_config_params[cnt].sps_config_enabled;
        /* SPR 9322 FIX */
        if(enable_flag) {
            if(!cell_cnt_index) {
                p_mac_init->spsSysWideParams.enableSps = enable_flag;
                p_rlc_init->enableSps = enable_flag;
                p_pdcp_init->enableSps = enable_flag;
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsSysWideParams.enableSps = enable_flag;
                p_rlc_s_cell_info->enableSps = enable_flag;
                p_pdcp_s_cell_info->enableSps = enable_flag;
                /* Spr 12453 Fix Start*/
                p_mac_cell_init->fieldBitMask |= SPS_PARAMS;
                /* Spr 12453 Fix End*/
            }
        }
        /*SPR 9256 End*/
    }

    p_xml_tag = oam_xml_find_tag(
            p_prop_cellconfig->supportedUlIntervalList->children,
            (xmlChar*)"Value");


    for(cnt = 0; cnt < SPS_INTERVAL_LIST && p_xml_tag; ++cnt) {
        tag_value = (Char8*)xmlNodeGetContent(p_xml_tag);
        lclTemp_value = oam_atoi(tag_value);
        xmlFree(tag_value);

        if(lclTemp_value >= MIN_SUPPORTED_UL_VALUE &&
                lclTemp_value <= MAX_SUPPORTED_UL_VALUE) {

            if(!cell_cnt_index) {
                p_mac_init->spsSysWideParams.supportedSpsUlIntervalList[cnt] =
                    lclTemp_value;

                p_rlc_init->supportedUlIntervalList[cnt] = lclTemp_value;

                p_pdcp_init->supportedSpsUlIntervalList[cnt] = lclTemp_value; 
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsSysWideParams.
                    supportedSpsUlIntervalList[cnt] = lclTemp_value;

                p_rlc_s_cell_info->supportedUlIntervalList[cnt] = lclTemp_value;

                p_pdcp_s_cell_info->supportedSpsUlIntervalList[cnt] =
                    lclTemp_value; 
            }

        }else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of supportedUlIntervalList value is %d and "
                    "range is from %d to %d",
                    lclTemp_value,MIN_SUPPORTED_UL_VALUE ,
                    MAX_SUPPORTED_UL_VALUE);
            return OAM_FAILURE;
        }

        p_xml_tag = p_xml_tag->next;
    }

    p_xml_tag = oam_xml_find_tag(
            p_prop_cellconfig->supportedDlIntervalList->children,
            (xmlChar*)"Value");

    for(cnt = 0; cnt < SPS_INTERVAL_LIST && p_xml_tag; ++cnt) {
        tag_value = (Char8*)xmlNodeGetContent(p_xml_tag);
        lclTemp_value = oam_atoi(tag_value);
        xmlFree(tag_value);

        if(lclTemp_value >= MIN_SUPPORTED_DL_VALUE &&
                lclTemp_value <= MAX_SUPPORTED_DL_VALUE) {

            if(!cell_cnt_index) {
                p_mac_init->spsSysWideParams.supportedSpsDlIntervalList[cnt] =
                    lclTemp_value;

                p_rlc_init->supportedDlIntervalList[cnt] = lclTemp_value;

                p_pdcp_init->supportedSpsDlIntervalList[cnt] = lclTemp_value; 
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsSysWideParams.
                    supportedSpsDlIntervalList[cnt] = lclTemp_value;

                p_rlc_s_cell_info->supportedDlIntervalList[cnt] = lclTemp_value;

                p_pdcp_s_cell_info->supportedSpsDlIntervalList[cnt] =
                    lclTemp_value; 
            }
        }else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of supportedDlIntervalList value is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_SUPPORTED_DL_VALUE,
                    MAX_SUPPORTED_DL_VALUE);
            return OAM_FAILURE;
        }

        p_xml_tag = p_xml_tag->next;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->sps_params,
            "maxSpsDciAttempt");
    lclTemp_value = oam_atoi(tag_value);
    if(lclTemp_value >= MIN_SPS_DCI_ATTEMPT &&
            lclTemp_value <= MAX_SPS_DCI_ATTEMPT)
    {
        if(!cell_cnt_index) {
            p_mac_init->spsSysWideParams.maxSpsDciAttempt = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitSPSParams.spsSysWideParams.
                maxSpsDciAttempt = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of maxSpsDciAttempt value is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_SPS_DCI_ATTEMPT,
                MAX_SPS_DCI_ATTEMPT);
        return OAM_FAILURE;
    }

    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_IGD_param
 *  DESCRIPTION      : This function is used to populate the igd parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

/* + SPR 17439 */
oam_return_et oam_populate_igd_param(void)
    /* - SPR 17439 */
{
    OAM_FUN_ENTRY_TRACE();

    oam_populate_string_params (xml_struct_tr196_g.InternetGatewayDevice,"DeviceSummary",oam_prov_req.oam_igd_params.DeviceSummary,sizeof(oam_prov_req.oam_igd_params.DeviceSummary));

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_device_info_param
 *  DESCRIPTION      : This function is used to populate the igd device info parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

/* + SPR 17439 */
oam_return_et oam_populate_device_info_param(void)
    /* - SPR 17439 */
{
    OAM_FUN_ENTRY_TRACE();
    oam_return_et ret_val = OAM_SUCCESS; 

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"Manufacturer",oam_prov_req.oam_igd_params.device_info_params.Manufacturer,sizeof(oam_prov_req.oam_igd_params.device_info_params.Manufacturer));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"ManufacturerOUI",oam_prov_req.oam_igd_params.device_info_params.ManufacturerOUI,sizeof(oam_prov_req.oam_igd_params.device_info_params.ManufacturerOUI));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"ModelName",oam_prov_req.oam_igd_params.device_info_params.ModelName,sizeof(oam_prov_req.oam_igd_params.device_info_params.ModelName));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"Description",oam_prov_req.oam_igd_params.device_info_params.Description,sizeof(oam_prov_req.oam_igd_params.device_info_params.Description));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"ProductClass",oam_prov_req.oam_igd_params.device_info_params.ProductClass,sizeof(oam_prov_req.oam_igd_params.device_info_params.ProductClass));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"SerialNumber",oam_prov_req.oam_igd_params.device_info_params.SerialNumber,sizeof(oam_prov_req.oam_igd_params.device_info_params.SerialNumber));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"HardwareVersion",oam_prov_req.oam_igd_params.device_info_params.HardwareVersion,sizeof(oam_prov_req.oam_igd_params.device_info_params.HardwareVersion));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"SoftwareVersion",oam_prov_req.oam_igd_params.device_info_params.SoftwareVersion,sizeof(oam_prov_req.oam_igd_params.device_info_params.SoftwareVersion));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"ModemFirmwareVersion",oam_prov_req.oam_igd_params.device_info_params.ModemFirmwareVersion,sizeof(oam_prov_req.oam_igd_params.device_info_params.ModemFirmwareVersion));

    oam_populate_string_params (xml_struct_tr196_g.DeviceInfo,"AdditionalSoftwareVersion",oam_prov_req.oam_igd_params.device_info_params.AdditionalSoftwareVersion,sizeof(oam_prov_req.oam_igd_params.device_info_params.AdditionalSoftwareVersion));

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.DeviceInfo,"UpTime"));

    oam_prov_req.oam_igd_params.device_info_params.UpTime = lclTemp_value ;

    ret_val = oam_populate_string_param_with_validation(xml_struct_tr196_g.DeviceInfo,"FirstUseDate",oam_prov_req.oam_igd_params.device_info_params.FirstUseDate,sizeof(oam_prov_req.oam_igd_params.device_info_params.FirstUseDate),OAM_NULL);
    if(ret_val == OAM_FAILURE)
    {
		OAM_LOG(OAM, OAM_WARNING,"Value of FirstUseDate is incorrect");
        ret_val = OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_rem_lte_param
 *  DESCRIPTION      : This function is used to populate the igd parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_rem_lte_param(void)
    /* - SPR 17439 */
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 *p_temp = OAM_NULL;
    UInt16 len = OAM_ZERO;
    oam_return_et ret_val = OAM_SUCCESS;
    Char8 temp_plmnid[OAM_SEVEN] = {0};

    /* spr_21013_fix_start */
    /* As a part of SPR 21013, parameter population of FAPService has been modified
     * to add support for storing multiple FAPService instances. CellConfig strcuture
     * of N cells is changed to single CellConfig element and will now be accessed 
     * through FAPService[index]. Support for multiple instances of FAPService has been 
     * added. Value of FAPServiceNumberOfEntries parameter needs to be changed  for N 
     * cells and accordingly FAPService hierarchy needs to be added N times. CellConfig 
     * array has been removed and now for each cell one FAPService will be added which 
     * will contain single instance of AccessMgmt and CellConfig. From second instance 
     * of FAPService onwards, only two children are included, i.e.AccessMgmt and CellConfig,
     * rest will be taken from first FAPService always. Hence, 0th index is used for the
     * childrens which are only part of FAPService 1st hierarchy */
    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"InServiceHandling",oam_prov_req.oam_igd_params.rem_lte_params.in_service_handling,sizeof(oam_prov_req.oam_igd_params.rem_lte_params.in_service_handling));

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"ScanOnBoot"));
    oam_prov_req.oam_igd_params.rem_lte_params.scan_on_boot=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"ScanPeriodically"));
    oam_prov_req.oam_igd_params.rem_lte_params.scan_periodically=lclTemp_value;
    /*SPR_16636 Fix Start*/
    if((OAM_FALSE == oam_prov_req.oam_igd_params.rem_lte_params.scan_on_boot) &&
            (OAM_TRUE == oam_prov_req.oam_igd_params.rem_lte_params.scan_periodically))
    {
      OAM_LOG(OAM, OAM_INFO,"Periodic Network Scan is disabled as ScanOnBoot is diabled"); 
        oam_prov_req.oam_igd_params.rem_lte_params.scan_periodically = OAM_FALSE;
    }
    /*SPR_16636 Fix End*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"PeriodicInterval"));
    oam_prov_req.oam_igd_params.rem_lte_params.periodic_interval=lclTemp_value;

    ret_val = oam_populate_string_param_with_validation(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"PeriodicTime",oam_prov_req.oam_igd_params.rem_lte_params.periodic_time,sizeof(oam_prov_req.oam_igd_params.rem_lte_params.periodic_time),OAM_NULL);
    if(ret_val == OAM_FAILURE)
    {
		OAM_LOG(OAM, OAM_WARNING,"Value of PeriodicTime is incorrect");
        ret_val = OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"ScanTimeout"));
    oam_prov_req.oam_igd_params.rem_lte_params.scan_timeout=lclTemp_value;

    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"ScanStatus",oam_prov_req.oam_igd_params.rem_lte_params.scan_status,sizeof(oam_prov_req.oam_igd_params.rem_lte_params.scan_status));

    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"ErrorDetails",oam_prov_req.oam_igd_params.rem_lte_params.error_details,sizeof(oam_prov_req.oam_igd_params.rem_lte_params.error_details));

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"MaxCellEntries"));
    oam_prov_req.oam_igd_params.rem_lte_params.max_cell_entries=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"CellNumberOfEntries"));
    oam_prov_req.oam_igd_params.rem_lte_params.cell_number_of_entries=lclTemp_value;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"MaxCarrierMeasEntries"));
    oam_prov_req.oam_igd_params.rem_lte_params.max_carrier_meas_entries=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"CarrierMeasNumberOfEntries"));
    oam_prov_req.oam_igd_params.rem_lte_params.carrier_meas_number_of_entries=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,"EUTRACarrierARFCN"));
    oam_prov_req.oam_igd_params.rem_lte_params.eutra_carrier_arfcn=lclTemp_value;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,"RSRP"));
    oam_prov_req.oam_igd_params.rem_lte_params.rsrp=lclTemp_value;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,"RSRQ"));
    oam_prov_req.oam_igd_params.rem_lte_params.rsrq=lclTemp_value;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,"RSSI"));
    oam_prov_req.oam_igd_params.rem_lte_params.rssi=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,"RSTxPower"));
    oam_prov_req.oam_igd_params.rem_lte_params.rstxpower=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,"TAC"));
    oam_prov_req.oam_igd_params.rem_lte_params.tac=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,"CellID"));
    oam_prov_req.oam_igd_params.rem_lte_params.cell_id=lclTemp_value;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,"CellBarred"));
    oam_prov_req.oam_igd_params.rem_lte_params.cell_barred=lclTemp_value;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,"MaxPLMNListEntries"));
    oam_prov_req.oam_igd_params.rem_lte_params.max_plmn_list_entries=lclTemp_value;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,"PLMNListNumberOfEntries"));
    oam_prov_req.oam_igd_params.rem_lte_params.plmn_list_number_of_entries=lclTemp_value;

    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].PLMNList_2,"PLMNID");
    OAM_NULL_CHECK(p_temp != OAM_NULL);
    oam_convert_plmnid(temp_plmnid,p_temp);
    len = oam_strlen((char *)temp_plmnid);
    oam_memcpy(oam_prov_req.oam_igd_params.rem_lte_params.plmn_id,temp_plmnid,len);

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].PLMNList_2,"CellReservedForOperatorUse"));
    oam_prov_req.oam_igd_params.rem_lte_params.cell_reserved_for_operator_use=lclTemp_value;

#ifdef OAM_SON_ENABLE
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas,"CarrierARFCNDL"));
    oam_prov_req.oam_igd_params.rem_lte_params.carrier_arfcndl=lclTemp_value;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas,"CarrierChWidth"));
    oam_prov_req.oam_igd_params.rem_lte_params.carrier_chwidth=lclTemp_value;
#endif
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,"DLBandwidth"));
    oam_prov_req.oam_igd_params.rem_lte_params.dl_bdwth=lclTemp_value;

    /*SPR_15770 Fix start*/
#ifdef OAM_SON_ENABLE
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"X_VENDOR_NR_SCAN"));
    /* spr_21013_fix_end */
    oam_prov_req.oam_igd_params.rem_lte_params.is_nr_scan_required=lclTemp_value;
#endif
    /*SPR_15770 Fix end*/

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_management_server_param
 *  DESCRIPTION      : This function is used to populate the igd parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

/* + SPR 17439 */
oam_return_et oam_populate_management_server_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    oam_populate_string_params (xml_struct_tr196_g.ManagementServer,"URL",oam_prov_req.oam_tr069_req.tr069_init_params.serving_hems_address,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.serving_hems_address));
    /* SPR 21176 Fixed Start */
    oam_populate_string_params (xml_struct_tr196_g.ManagementServer,"ConnectionRequestURL",oam_prov_req.oam_tr069_req.tr069_init_params.ConReqURL,sizeof(oam_prov_req.oam_igd_params.management_server_params.ConReqURL));

    /* SPR 21176 Fixed End */
    oam_populate_string_params (xml_struct_tr196_g.ManagementServer,"X_VENDOR_IHEMS_URL",oam_prov_req.oam_tr069_req.tr069_init_params.initial_hems_address,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.initial_hems_address));

    /* SPR 17880 START*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.ManagementServer,"EnableCWMP"));
    /* Coverity 99533 + */
    oam_prov_req.oam_tr069_req.tr069_init_params.EnableCWMP = (oam_bool_et)lclTemp_value;
    /* Coverity 99533 - */

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.ManagementServer,"PeriodicInformEnable"));
    /* Coverity 99532 + */
    oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformEnable= (oam_bool_et)lclTemp_value;
    /* Coverity 99532 - */

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.ManagementServer,"PeriodicInformInterval"));
    oam_prov_req.oam_tr069_req.PeriodicInformInterval=lclTemp_value;
    oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformInterval = lclTemp_value;

    oam_populate_string_params (xml_struct_tr196_g.ManagementServer,"PeriodicInformTime",
            oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime));

    oam_populate_string_params (xml_struct_tr196_g.ManagementServer,"ParameterKey",
            oam_prov_req.oam_tr069_req.tr069_init_params.ParameterKey,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.ParameterKey));

    oam_populate_string_params (xml_struct_tr196_g.ManagementServer,"ConnectionRequestUsername",
            oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername));

    oam_populate_string_params (xml_struct_tr196_g.ManagementServer,"ConnectionRequestPassword",
            oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword));

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.ManagementServer,"CWMPRetryMinimumWaitInterval"));
    oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryMinimumWaitInterval = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.ManagementServer,"CWMPRetryIntervalMultiplier"));
    oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryIntervalMultiplier = lclTemp_value;

    /*coverity 109019 fix start*/
    if(OAM_NULL !=(Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.ManagementServer,"Username"))
    {
        oam_strncpy((Char8 *)&oam_prov_req.oam_tr069_req.tr069_init_params.Username[OAM_ZERO],
                (Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.ManagementServer,"Username"),
                oam_strlen((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.ManagementServer,"Username")));

    }
    if(OAM_NULL !=(Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.ManagementServer,"Password"))
    {
        oam_strncpy((Char8 *)&oam_prov_req.oam_tr069_req.tr069_init_params.Password[OAM_ZERO],
                (Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.ManagementServer,"Password"),
                oam_strlen((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.ManagementServer,"Password")));
    }
    /*coverity 109019 fix end*/
    /* SPR 17880 END */

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}


/*******************************************************************************
 * FUNCTION NAME    : oam_populate_tunnel_param
 * DESCRIPTION      : This function  is used to populate the igd parameters
 * PARAMETERS
 *     IN           : NONE
 *    
 *     OUT          : NONE
 *      
 * RETURNS          :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ********************************************************************************/


/* + SPR 17439 */
oam_return_et oam_populate_tunnel_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.CryptoProfile,"Enable"));
    oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].Enable= lclTemp_value;

    /* SPR_12373_CHANGES */
    /* Redundant Code Removed */
    /* SPR_12373_CHANGES */

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.CryptoProfile,"IPsecRekeyLifetimeTime"));
    oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IPsecRekeyLifetimeTime = lclTemp_value;

    oam_populate_string_params (xml_struct_tr196_g.CryptoProfile,"AuthMethod",oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].AuthMethod,sizeof(oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].AuthMethod));

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Tunnel,"CryptoProfileNumberOfEntries"));
    oam_prov_req.oam_igd_params.tunnel_params.CryptoProfileNumberOfEntries = lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Tunnel,"VirtualInterfaceNumberOfEntries"));
    oam_prov_req.oam_igd_params.tunnel_params.VirtualInterfaceNumberOfEntries= lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Tunnel,"IKESANumberOfEntries"));
    oam_prov_req.oam_igd_params.tunnel_params.IKESANumberOfEntries = lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.CryptoProfile,"DPDTimer"));
    oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].DPDTimer= lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.CryptoProfile,"NATTKeepaliveTimer"));
    oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].NATTKeepaliveTimer= lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Tunnel,"MaxVirtualInterfaces"));
    oam_prov_req.oam_igd_params.tunnel_params.MaxVirtualInterfaces = lclTemp_value;

    oam_populate_string_params(xml_struct_tr196_g.IKESA,"PeerAddress",
            (UInt8*)oam_prov_req.oam_igd_params.tunnel_params.
            oam_ikesa[OAM_ZERO].PeerAddress,
            OAM_IP_ADDR_MAX_LEN);

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.VirtualInterface,"Enable"));
    oam_prov_req.oam_igd_params.tunnel_params.virtual_interface_params[OAM_ZERO].Enable= lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.VirtualInterface,"DSCPMarkPolicy"));
    oam_prov_req.oam_igd_params.tunnel_params.virtual_interface_params[OAM_ZERO].DSCPMarkPolicy= lclTemp_value;

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 * FUNCTION NAME    : oam_populate_capabilities_param
 * DESCRIPTION      : This function  is used to populate the igd parameters
 * PARAMETERS
 *     IN           : NONE
 *
 *     OUT          : NONE
 *
 * RETURNS          :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ********************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_capabilities_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    /* spr_21013_fix_start */
    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"UMTSRxBandsSupported",oam_prov_req.oam_igd_params.capabilities_params.UMTSRxBandsSupported,sizeof(oam_prov_req.oam_igd_params.capabilities_params.UMTSRxBandsSupported));

    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"GSMRxBandsSupported",oam_prov_req.oam_igd_params.capabilities_params.GSMRxBandsSupported,sizeof(oam_prov_req.oam_igd_params.capabilities_params.GSMRxBandsSupported));

    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"CDMA2000RxBandsSupported",oam_prov_req.oam_igd_params.capabilities_params.CDMA2000RxBandsSupported,sizeof(oam_prov_req.oam_igd_params.capabilities_params.CDMA2000RxBandsSupported));
    /* spr_21013_fix_end */

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/*******************************************************************************
 * FUNCTION NAME    : oam_populate_nms_ftp_server_params
 * DESCRIPTION      : This function  is used to populate the igd parameters
 * PARAMETERS
 *     IN           : NONE
 *
 *     OUT          : NONE
 *
 * RETURNS          :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ********************************************************************************/

/* + SPR 17439 */
oam_return_et oam_populate_nms_ftp_server_params(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.nms_ftp_server_params,"X_VENDOR_Enable"));
    oam_prov_req.oam_nms_ftp_server_params.Enable= lclTemp_value;

    oam_populate_string_params (xml_struct_tr196_g.nms_ftp_server_params,"X_VENDOR_FTPServerURL",oam_prov_req.oam_nms_ftp_server_params.ftp_server_url,sizeof(oam_prov_req.oam_nms_ftp_server_params.ftp_server_url));

    oam_populate_string_params (xml_struct_tr196_g.nms_ftp_server_params,"X_VENDOR_FTPServerUsername",oam_prov_req.oam_nms_ftp_server_params.ftp_server_username,sizeof(oam_prov_req.oam_nms_ftp_server_params.ftp_server_username));

    oam_populate_string_params (xml_struct_tr196_g.nms_ftp_server_params,"X_VENDOR_FTPServerUserPassword",oam_prov_req.oam_nms_ftp_server_params.ftp_server_password,sizeof(oam_prov_req.oam_nms_ftp_server_params.ftp_server_password));

    oam_populate_string_params (xml_struct_tr196_g.nms_ftp_server_params,"X_VENDOR_LocalDirectoryPath",oam_prov_req.oam_nms_ftp_server_params.local_download_upload_path,sizeof(oam_prov_req.oam_nms_ftp_server_params.local_download_upload_path));

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}


/****************************************************************************
 * FUNCTION NAME    : oam_populate_rrm_enb_config_params
 * DESCRIPTION      : This function  is used to populate parameters for API
 *                    RRM_OAM_ENB_CONFIG_REQ
 * PARAMETERS
 *     IN           : NONE
 *
 *     OUT          : NONE
 *
 * RETURNS          :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ***************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_rrm_enb_config_params(void)
{
    /* - SPR 17439 */
    UInt8 index = 0;
    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3,
            /* spr_21013_fix_end */
            "X_VENDOR_CELL_TYPE");
    lclTemp_value = oam_atoi((Char8*)p_temp);
    if(OAM_MACRO_ENB_TYPE == lclTemp_value) {
        RRM_PROV_REQ.oam_rrm_enb_config_req.enb_id.
            enb_type = RRM_ENB_TYPE_MACRO;
        oam_memcpy(RRM_PROV_REQ.oam_rrm_enb_config_req.enb_id.eNb_id,
                OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
                macro_enb_id.eNB_id, MACRO_ENB_ID_OCTET_SIZE);
    }
    else {
        RRM_PROV_REQ.oam_rrm_enb_config_req.enb_id.
            enb_type = RRM_ENB_TYPE_HOME;
        oam_memcpy(RRM_PROV_REQ.oam_rrm_enb_config_req.enb_id.eNb_id,
                OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
                home_enb_id.eNB_id, HOME_ENB_ID_OCTET_SIZE);
    }

    for(index = 0; index < RRM_PROV_REQ.plmnlist_data[0].curr_plmn_entries; ++index) {
        /*SPR_18921_START*/
        if((RRM_PROV_REQ.plmnlist_data[0].plmn_entries[index].enable) && 
                (RRM_PROV_REQ.plmnlist_data[0].plmn_entries[index].is_primary)) {
            /*SPR_18921_END*/
            oam_memcpy(&RRM_PROV_REQ.oam_rrm_enb_config_req.enb_id.plmn_id,
                    &RRM_PROV_REQ.plmnlist_data[0].plmn_entries[index].plmn_id,
                    sizeof(rrm_oam_cell_plmn_info_t));
        }
    }

    RRM_PROV_REQ.oam_rrm_enb_config_req.
        bitmask |= RRM_OAM_GLOBAL_ENB_ID_PRESENT;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3,"X_VENDOR_CELL_STOP_NEEDED_FOR_NMM"));
    /* spr_21013_fix_end */
    /* coverity 63605 */
    RRM_PROV_REQ.oam_rrm_enb_config_req.cell_stop_needed_for_nmm = (rrm_bool_et)lclTemp_value;
    RRM_PROV_REQ.oam_rrm_enb_config_req.
        bitmask |= RRM_OAM_CELL_STOP_NEEDED_FOR_NMM_PRESENT;


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 * FUNCTION NAME    : oam_populate_perf_mgmt_param
 * DESCRIPTION      : This function  is used to populate the igd parameters
 * PARAMETERS
 *     IN           : NONE
 *
 *     OUT          : NONE
 *
 * RETURNS          :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ********************************************************************************/

/* + SPR 17439 */
oam_return_et oam_populate_perf_mgmt_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();
    oam_return_et ret_val = OAM_SUCCESS;


    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.PerfMgmt,"ConfigNumberOfEntries"));
    oam_prov_req.oam_igd_params.perf_mgmt_params.ConfigNumberOfEntries = lclTemp_value;


    oam_populate_string_params (xml_struct_tr196_g.Config,"URL",oam_prov_req.oam_igd_params.perf_mgmt_params.URL,sizeof(oam_prov_req.oam_igd_params.perf_mgmt_params.URL));

    oam_populate_string_params (xml_struct_tr196_g.Config,"Username",oam_prov_req.oam_igd_params.perf_mgmt_params.Username,sizeof(oam_prov_req.oam_igd_params.perf_mgmt_params.Username));

    oam_populate_string_params (xml_struct_tr196_g.Config,"Password",oam_prov_req.oam_igd_params.perf_mgmt_params.Password,sizeof(oam_prov_req.oam_igd_params.perf_mgmt_params.Password));

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Config,"Enable"));
    oam_prov_req.oam_igd_params.perf_mgmt_params.Enable = lclTemp_value;

    lclTemp_value  = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Config,"PeriodicUploadInterval"));
    oam_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadInterval= lclTemp_value;

    ret_val = oam_populate_string_param_with_validation(xml_struct_tr196_g.Config,"PeriodicUploadTime",oam_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadTime,sizeof(oam_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadTime),OAM_NULL);
    if(ret_val == OAM_FAILURE)
    {
		OAM_LOG(OAM, OAM_WARNING,"Value of PeriodicTime is incorrect");
        ret_val = OAM_FAILURE;
    }

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Config,"X_VENDOR_SamplingInterval"));
    oam_prov_req.oam_igd_params.perf_mgmt_params.sampling_interval_timer = lclTemp_value;


    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Config,"X_VENDOR_FileWriteTimer"));
    oam_prov_req.oam_igd_params.perf_mgmt_params.file_write_timer = lclTemp_value;

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}
/*******************************************************************************
 * FUNCTION NAME    : oam_populate_health_mgmt_param 
 * DESCRIPTION      : This function  is used to populate the igd parameters
 * PARAMETERS
 *     IN           : NONE
 *     OUT          : NONE
 * RETURNS          :  OAM_SUCCESS on Success
 ********************************************************************************/
/* + SPR 17439 */
    oam_return_et 
oam_populate_health_mgmt_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.health_monitoring,"monitoring_interval"));
	OAM_LOG( OAM, OAM_INFO,"monitoring_interval = %d",lclTemp_value);
    oam_prov_req.hm_config_param.monitoring_interval = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.health_monitoring,"nonresponsive_monitoring_interval"));
	OAM_LOG( OAM, OAM_INFO,"nonresponsive_monitoring_interval = %d",lclTemp_value);
    oam_prov_req.hm_config_param.nonresponsive_monitoring_interval = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.health_monitoring,"max_retries"));
	OAM_LOG( OAM, OAM_INFO,"max_retries = %d",lclTemp_value);
    oam_prov_req.hm_config_param.max_retries = lclTemp_value;
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 * FUNCTION NAME    : oam_populate_services_param
 * DESCRIPTION      : This function  is used to populate the igd parameters
 * PARAMETERS
 *     IN           : NONE
 *
 *     OUT          : NONE
 *
 * RETURNS          :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ********************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_services_param(void)
{
    /* - SPR 17439 */
    UInt8 len = OAM_ZERO;
    OAM_FUN_ENTRY_TRACE();

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].FapService,"DNPrefix");
    /* spr_21013_fix_end */
    OAM_NULL_CHECK(p_temp != OAM_NULL);
    len = oam_strlen((char *)p_temp);
    oam_memcpy(oam_prov_req.oam_igd_params.services_params.DNPrefix,p_temp,len);

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].FapService,"DeviceType");
    /* spr_21013_fix_end */
    OAM_NULL_CHECK(p_temp != OAM_NULL);
    len = oam_strlen((char *)p_temp);
    oam_memcpy(oam_prov_req.oam_igd_params.services_params.DeviceType,p_temp,len);

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.Services,"FAPServiceNumberOfEntries"));

    oam_prov_req.oam_igd_params.services_params.FAPServiceNumberOfEntries=lclTemp_value;

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 * FUNCTION NAME    : oam_populate_fap_control_param
 * DESCRIPTION      : This function  is used to populate the igd parameters
 * PARAMETERS
 *     IN           : NONE
 *
 *     OUT          : NONE
 *
 * RETURNS          :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ********************************************************************************/

/* + SPR 17439 */
oam_return_et oam_populate_fap_control_param(void)
{
    /* - SPR 17439 */
    UInt8 len = OAM_ZERO;
    char *temp = OAM_NULL;
    OAM_FUN_ENTRY_TRACE();

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].FAPControl,"SelfConfigEvents");
    /* spr_21013_fix_end */
    OAM_NULL_CHECK(p_temp != OAM_NULL);
    len = oam_strlen((char *)p_temp);
    oam_memcpy(oam_prov_req.oam_igd_params.fap_control_params.SelfConfigEvents,p_temp,len);

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].FAPControl,"EnclosureTamperingDetected"));
    /* spr_21013_fix_end */

    oam_prov_req.oam_igd_params.fap_control_params.EnclosureTamperingDetected=lclTemp_value;

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,"S1SigLinkServerList");
    /* spr_21013_fix_end */
    OAM_NULL_CHECK(p_temp != OAM_NULL);
    len = oam_strlen((char *)p_temp);
    if(sig_count==OAM_ONE)
    {
        temp = strtok((char *)p_temp,",");
        p_temp = (UInt8*)temp;

    }
    oam_memcpy(oam_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,p_temp,len);

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,"S1ConnectionMode");
    /* spr_21013_fix_end */
    OAM_NULL_CHECK(p_temp != OAM_NULL);
    /* SPR-13171 START */
    if(sig_count == OAM_ONE)
    {
        oam_memcpy(oam_prov_req.oam_igd_params.fap_control_params.S1ConnectionMode,"One",oam_strlen("One")+OAM_ONE);       
    }
    else
    {
        oam_memcpy(oam_prov_req.oam_igd_params.fap_control_params.S1ConnectionMode,"All",oam_strlen("All")+OAM_ONE);       
    }
    /* SPR-13171 END */
    /*SPR 11090 FIX START*/	
    lclTemp_value =
        /* spr_21013_fix_start */
        oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,
                    /* spr_21013_fix_end */
                    "S1SigLinkPort"));

    oam_prov_req.oam_igd_params.fap_control_params.S1SigLinkPort=lclTemp_value;
    /*SPR 11090 FIX END*/	



    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 * FUNCTION NAME    : oam_populate_lte_tunnel_params
 * DESCRIPTION      : This function  is used to populate the igd parameters
 * PARAMETERS
 *     IN           : Pointer of XML_struct_cell_config
 *
 *     OUT          : NONE
 *
 * RETURNS          :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ********************************************************************************/

    oam_return_et
oam_populate_lte_tunnel_params(XML_struct_cell_config *p_cell_spec_params)
{
    UInt8 len = OAM_ZERO;
    OAM_FUN_ENTRY_TRACE();
    Char8 *tag_value = OAM_NULL;
    Char8 temp_plmnid[OAM_SEVEN] = {0};     

    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->LTE_4,
            "TunnelNumberOfEntries");
    lclTemp_value = oam_atoi(tag_value);

    oam_prov_req.oam_igd_params.cell_config_params.
        TunnelNumberOfEntries = lclTemp_value;


    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Tunnel_2,
            "Enable");
    lclTemp_value = oam_atoi(tag_value);

    oam_prov_req.oam_igd_params.cell_config_params.Enable = lclTemp_value;

    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Tunnel_2,
            "TunnelRef");
    len = oam_strlen(tag_value);
    oam_memcpy(oam_prov_req.oam_igd_params.cell_config_params.TunnelRef,
            tag_value, len);


    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Tunnel_2,
            "PLMNID");
    OAM_NULL_CHECK(tag_value != OAM_NULL);
    oam_convert_plmnid(temp_plmnid,tag_value);
    len = oam_strlen(temp_plmnid);
    oam_memcpy(oam_prov_req.oam_igd_params.cell_config_params.PLMNID,
            temp_plmnid, len);

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}


/* SPR_12373_CHANGES */
/* Redundant Code Removed */
/* SPR_12373_CHANGES */
/****************************************************************************
 *  FUNCTION NAME    : oam_populate_egtpu_init_req
 *  DESCRIPTION     : This function is used to populate the egtpu init params
 *  PARAMETERS       
 *      IN          : Pointers to prop_cellconfig_xml_st  and oam_l2_req_t
 *                  
 *      OUT         : NONE
 *                  
 *  RETURNS         :  OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 ****************************************************************************/
    oam_return_et
oam_populate_egtpu_init_req(prop_cellconfig_xml_st  *p_prop_cellconfig,
        oam_l2_req_t *p_l2_req)
{
    OAM_FUN_ENTRY_TRACE();
    /*SPR21717 Changes start*/
    Char8* tag_value = OAM_NULL;
#ifdef LTE_EMBMS_SUPPORTED
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    xmlChar* tag_value1 = OAM_NULL;
#endif
    XML_struct_cell_config *p_cell_spec_params =
        /* spr_21013_fix_start */
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig;
    /* spr_21013_fix_end */
    oam_egtpu_initdb_req_t *p_egtpu_initdb = 
        &p_l2_req->oam_egtpu_req.egtpu_initdb_req;

    tag_value = (Char8* )oam_xmlNodeGetContent(xml_struct_g.L2params, "logLevelGTPU");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        p_egtpu_initdb->logLevel = oam_atoi((Char8*)tag_value);
        }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            p_cell_spec_params->GTPUEchoInterval,
            "GTPUEchoInterval");
    lclTemp_value = oam_atoi(tag_value);

    /* SPR 10597 Changes Start */
    /* echoReqTimer is disabled when set to 0 */
    if ((0 == lclTemp_value) ||                   
            (lclTemp_value >= MIN_EGTPU_ECHO_REQ_TIMER))  
    {
        p_egtpu_initdb->echoReqTimer = (UInt32) lclTemp_value;
    }
    else
    {
        /* SPR 13851 Changes Start */
		OAM_LOG(OAM, OAM_WARNING,
                "Value of GTPUEchoInterval is %u and "
                "range is from %u to %u",
                lclTemp_value, MIN_EGTPU_ECHO_REQ_TIMER,
                MAX_EGTPU_ECHO_REQ_TIMER);
        /* SPR 13851 Changes End */
        return OAM_FAILURE;
    }
    /* SPR 10597 Changes End */

    tag_value = (Char8*)oam_xmlNodeGetContent(
            p_cell_spec_params->GTPUEchoInterval,
            "X_VENDOR_MAX_RETRY");
    lclTemp_value = oam_atoi(tag_value);


    p_egtpu_initdb->maxRetry = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->dimension_params,"NumPeerRec"));

    p_egtpu_initdb->noPeerRec=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->dimension_params,"numRabRecinitSize"));
    /*SPR 21212 Start*/
    p_egtpu_initdb->noRabRec.initSize+=lclTemp_value;
    /*SPR 21212 End*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->dimension_params,"numRabRecstepSize"));

    /*SPR 21212 Start*/
    p_egtpu_initdb->noRabRec.stepSize+=lclTemp_value;
    /*SPR 21212 End*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->dimension_params,"numRabRecmaxSize"));

    /*SPR 21212 Start*/
    p_egtpu_initdb->noRabRec.maxSize+=lclTemp_value;
    /*SPR 21212 End*/

    /*+ Fix for HM params +*/
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.health_monitoring,"healthMonitoringTimeInterval"));
    p_egtpu_initdb->healthMonitoringTimeInterval = lclTemp_value; 
    /*- Fix for HM params -*/

#ifdef LTE_EMBMS_SUPPORTED
    tag_value1 = oam_get_xml_text_node_content(xml_struct_g.EGTPUParams,
            "maxMspToBeBuffered", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);

    if (tag_value1)
    {
        lclTemp_value = oam_atoi(buf);

        if (lclTemp_value >= MAX_MSP_TO_BE_BUFFERED_MIN_VAL &&
                lclTemp_value <= MAX_MSP_TO_BE_BUFFERED_MAX_VAL)
        {
            p_egtpu_initdb->maxMspToBeBuffered = lclTemp_value; 
        }
        else
        {
            OAM_LOG(OAM, OAM_CRITICAL,
                    "Value[%d] of maxMspToBeBuffered is out of range[%d to %d]",
                    lclTemp_value, MAX_MSP_TO_BE_BUFFERED_MIN_VAL,
                    MAX_MSP_TO_BE_BUFFERED_MAX_VAL);

            OAM_FUN_EXIT_TRACE();

            return OAM_FAILURE;
        }
    }
    else
    {
        OAM_LOG(OAM, OAM_CRITICAL,
                "Failed to read the mandatory param maxMspToBeBuffered");

        OAM_FUN_EXIT_TRACE();

        return OAM_FAILURE;
    }
#endif
/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
    Char8 *en_dc_enabled_tag = OAM_NULL;
    xmlChar* dataForwardingGuradTimer  = OAM_NULL;
    xmlChar* x2uDeliveryTriggerTimer   = OAM_NULL;
    xmlChar* x2uDeliveryTriggerPktCnt  = OAM_NULL;
    xmlChar* x2uDeliveryTriggerPktSize = OAM_NULL;
    xmlChar* isGtpuNRHeaderEnabled = OAM_NULL;

    en_dc_enabled_tag = (Char8*)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"ENDCEnabled");

    if ( (OAM_ZERO != oam_strcmp(en_dc_enabled_tag, OAM_INVALID_STR)) && 
            (OAM_TRUE == oam_atoi(en_dc_enabled_tag))
       )
    {
        /*populating dataForwardingGuradTimer */
        dataForwardingGuradTimer = oam_xmlNodeGetContent
            (xml_struct_g.EN_DC_Params,
             "GtpuSplitDataForwardingGuardTimer");

        if(oam_strcmp((Char8*)dataForwardingGuradTimer, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi((Char8*)dataForwardingGuradTimer);
            if(lclTemp_value >= MIN_GTPU_DATA_FORWARDING_GUARD_TIMER &&
                    lclTemp_value <= MAX_GTPU_DATA_FORWARDING_GUARD_TIMER )
            {
                p_egtpu_initdb->dataForwardingGuardTimerInterval =
                    (UInt16)lclTemp_value;

            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of GtpuSplitDataForwardingGuardTimer is %u and range"
                        "is from [%u to %u ] ",
                        lclTemp_value, MIN_GTPU_DATA_FORWARDING_GUARD_TIMER,
                        MAX_GTPU_DATA_FORWARDING_GUARD_TIMER);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Failed to read the mandatory tag GtpuSplitDataForwardingGuardTimer");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        /*populating x2uDeliveryStatusTriggerTimer */
        x2uDeliveryTriggerTimer = oam_xmlNodeGetContent(
                xml_struct_g.EN_DC_Params,
                "x2uDeliveryStatusTriggerTimer");
        if(oam_strcmp((Char8*)x2uDeliveryTriggerTimer, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi((Char8*)x2uDeliveryTriggerTimer);
            if(lclTemp_value >= MIN_X2U_DELIVERY_STATUS_TRIGGER_TIMER &&
                    lclTemp_value <= MAX_X2U_DELIVERY_STATUS_TRIGGER_TIMER)
            {
                p_egtpu_initdb->x2uDelStatusThreshold.
                    x2uDeliveryStatusTriggerTimer = (UInt16)lclTemp_value;
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of x2uDeliveryStatusTriggerTimer is %u and range"
                        "is from [%u to %u ] ",
                        lclTemp_value, MIN_X2U_DELIVERY_STATUS_TRIGGER_TIMER,
                        MAX_X2U_DELIVERY_STATUS_TRIGGER_TIMER);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Failed to read the mandatory tag x2uDeliveryStatusTriggerTimer");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        /*populating x2uDeliveryStatusTriggerPktCnt */
        x2uDeliveryTriggerPktCnt = oam_xmlNodeGetContent(
                xml_struct_g.EN_DC_Params,
                "x2uDeliveryStatusTriggerPktCnt");
        if(oam_strcmp((Char8*)x2uDeliveryTriggerPktCnt, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi((Char8*)x2uDeliveryTriggerPktCnt);
            if(lclTemp_value >= MIN_X2U_DELIVERY_STATUS_PKT_COUNT &&
                    lclTemp_value <= MAX_X2U_DELIVERY_STATUS_PKT_COUNT )
            {
                p_egtpu_initdb->x2uDelStatusThreshold.
                    x2uDeliveryStatusTriggerPktCnt = (UInt16)lclTemp_value;
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of x2uDeliveryStatusTriggerPktCnt is %u and range"
                        "is from [%u to %u ] ",
                        lclTemp_value, MIN_X2U_DELIVERY_STATUS_PKT_COUNT,
                        MAX_X2U_DELIVERY_STATUS_PKT_COUNT);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Failed to read the mandatory tag x2uDeliveryStatusTriggerPktCnt");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        /*populating x2uDeliveryStatusTriggerPktSize*/
        x2uDeliveryTriggerPktSize = oam_xmlNodeGetContent(
                xml_struct_g.EN_DC_Params,
                "x2uDeliveryStatusTriggerPktSize");
        if(oam_strcmp((Char8*)x2uDeliveryTriggerPktSize, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi((Char8*)x2uDeliveryTriggerPktSize);
            if(lclTemp_value >= MIN_X2U_DELIVERY_STATUS_PKT_SIZE &&
                    lclTemp_value <= MAX_X2U_DELIVERY_STATUS_PKT_SIZE )
            {
                p_egtpu_initdb->x2uDelStatusThreshold.
                    x2uDeliveryStatusTriggerPktSize = (UInt16)lclTemp_value;
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of x2uDeliveryStatusTriggerPktSize is %u and range"
                        "is from [%u to %u ] ",
                        lclTemp_value, MIN_X2U_DELIVERY_STATUS_PKT_SIZE,
                        MAX_X2U_DELIVERY_STATUS_PKT_SIZE);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Failed to read the mandatory tag x2uDeliveryStatusTriggerPktSize");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
		/*populating isGtpuNRHeaderEnabled */
        isGtpuNRHeaderEnabled = oam_xmlNodeGetContent
            (xml_struct_g.EN_DC_Params,
             "isGtpuNRHeaderEnabled");

        if(oam_strcmp((Char8*)isGtpuNRHeaderEnabled, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi((Char8*)isGtpuNRHeaderEnabled);
            if(lclTemp_value == OAM_TRUE ||
                    lclTemp_value == OAM_FALSE )
            {
                p_egtpu_initdb->isGtpuNRHeaderEnabled =
                    (UInt16)lclTemp_value;

            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of isGtpuNRHeaderEnabled is %u and range"
                        "is from [%u to %u ] ",
                        lclTemp_value, OAM_FALSE,
                        OAM_TRUE);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Failed to read the mandatory tag isGtpuNRHeaderEnabled");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

    }
    else
    {
        p_egtpu_initdb->dataForwardingGuardTimerInterval
            = DEFAULT_GTPU_DATA_FORWARDING_GUARD_TIMER;
        p_egtpu_initdb->x2uDelStatusThreshold.x2uDeliveryStatusTriggerTimer
            = DEFAULT_X2U_DELIVERY_STATUS_TRIGGER_TIMER;
        p_egtpu_initdb->x2uDelStatusThreshold.x2uDeliveryStatusTriggerPktCnt
            = DEFAULT_X2U_DELIVERY_STATUS_PKT_COUNT;
        p_egtpu_initdb->x2uDelStatusThreshold.x2uDeliveryStatusTriggerPktSize
            = DEFAULT_X2U_DELIVERY_STATUS_PKT_SIZE;
    }
#endif
/* OPTION3X Changes End */


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}


/*******************************************************************************
 ** FUNCTION NAME    : oam_populate_fault_mgmt_param
 * DESCRIPTION      : This function  is used to populate the igd parameters
 ** PARAMETERS
 **     IN           : NONE
 **     
 **     OUT          : NONE
 **       
 ** RETURNS          :  OAM_SUCCESS on Success
 **                     OAM_FAILURE on Failure
 *********************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_fault_mgmt_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();
    UInt8 *p_temp = OAM_NULL;
    UInt16 counter;
    SInt32 AlarmEntTemp_value;
    xmlNode * supported_alarm;
    /* Coverity FIX 34789 */
    alarm_report_mechanism_et logged_alarm = LOGGED_ALARM;
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FaultMgmt,"SupportedAlarmNumberOfEntries"));
    oam_prov_req.fm_cntxt.SupportedAlarmNumberOfEntries=lclTemp_value;
    AlarmEntTemp_value = lclTemp_value;
    /* SPR-8133,34,35 FIX START*/ 
    oam_prov_req.fm_cntxt.Current_HistoryEventNumberOfEntries=lclTemp_value;

    oam_prov_req.fm_cntxt.Current_ExpeditedEventNumberOfEntries=lclTemp_value;

    oam_prov_req.fm_cntxt.Current_QueuedEventNumberOfEntries=lclTemp_value;

    /* SPR-8133,34,35 FIX END*/ 
    oam_prov_req.fm_cntxt.Current_List_Index = OAM_ZERO;
    oam_prov_req.fm_cntxt.History_List_Index = OAM_ZERO;
    oam_prov_req.fm_cntxt.Queued_List_Index = OAM_ZERO;
    oam_prov_req.fm_cntxt.Expedited_List_Index = OAM_ZERO;

    for(counter=LOW_COUNT;counter<AlarmEntTemp_value;counter++)
    {
        supported_alarm = xml_struct_tr196_g.SupportedAlarm[counter];
        p_temp = oam_xmlNodeGetContent(supported_alarm,"EventType");
        OAM_NULL_CHECK(p_temp != OAM_NULL);
        lclTemp_value=oam_get_alarm_event_id_by_event((char *)p_temp);
        /* coverity 35742 */
        oam_prov_req.fm_cntxt.supported_alarm_list[counter].event_type=(alarm_event_type_et)lclTemp_value;
        oam_strcpy((char*)oam_prov_req.fm_cntxt.supported_alarm_list[counter].event_type_str,
                (char *)p_temp);

        p_temp = oam_xmlNodeGetContent(supported_alarm,"ProbableCause");
        OAM_NULL_CHECK(p_temp != OAM_NULL);
        lclTemp_value=oam_get_alarm_probable_cause_id_by_cause((char *)p_temp); 
        /* coverity 35744 */
        oam_prov_req.fm_cntxt.supported_alarm_list[counter].probable_cause=(alarm_probable_cause_et)lclTemp_value;
        oam_strcpy((char*)oam_prov_req.fm_cntxt.supported_alarm_list[counter].probable_cause_str,
                (char *)p_temp);

        oam_populate_string_params(supported_alarm,
                "SpecificProblem",
                (UInt8*)SUPP_ALARM_LIST(counter).specific_problem,
                sizeof(SUPP_ALARM_LIST(counter).specific_problem));

        p_temp = oam_xmlNodeGetContent(supported_alarm,"PerceivedSeverity");
        OAM_NULL_CHECK(p_temp != OAM_NULL);
        lclTemp_value=oam_get_alarm_severity_id_by_severity((char *)p_temp);
        /* coverity 35743 */
        oam_prov_req.fm_cntxt.supported_alarm_list[counter].perceived_severity=(FM_alarm_severity_et)lclTemp_value;
        oam_strcpy((char*)oam_prov_req.fm_cntxt.supported_alarm_list[counter].perceived_severity_str,
                (char *)p_temp);

        p_temp = oam_xmlNodeGetContent(supported_alarm,"ReportingMechanism");
        OAM_NULL_CHECK(p_temp != OAM_NULL);
        if( (oam_strcmp((const char *)p_temp, OAM_INVALID_STR) == OAM_ZERO) || (oam_strcmp((const char *)p_temp, "") == OAM_ZERO) )
        {
            /* Coverity FIX 34789 */
            logged_alarm = LOGGED_ALARM; 
            lclTemp_value= (SInt32)logged_alarm;
            oam_prov_req.fm_cntxt.supported_alarm_list[counter].reporting_mechanism=(alarm_report_mechanism_et)lclTemp_value;
            oam_strcpy((char*)oam_prov_req.fm_cntxt.supported_alarm_list[counter].reporting_mechanism_str, (char *)"2 Logged");
        }
        else /* Success */
        {
            lclTemp_value=oam_get_alarm_report_id_by_report((char *)p_temp);
            oam_prov_req.fm_cntxt.supported_alarm_list[counter].reporting_mechanism=(alarm_report_mechanism_et)lclTemp_value;
            oam_strcpy((char*)oam_prov_req.fm_cntxt.supported_alarm_list[counter].reporting_mechanism_str, (char *)p_temp);
        }
        oam_populate_string_params(supported_alarm,
                "ManagedObjectInstance",
                (UInt8*)SUPP_ALARM_LIST(counter).managed_object_instance,
                sizeof(SUPP_ALARM_LIST(counter).managed_object_instance));

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    supported_alarm,"X_VENDOR_ALARM_ID"));
        oam_prov_req.fm_cntxt.supported_alarm_list[counter].alarm_identifier=lclTemp_value;
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_rrm_init_config_param
 *  DESCRIPTION      : This function is used to populate the rrm 
 *					   init config parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

/* + SPR 17439 */
    oam_return_et
oam_populate_rrm_init_config_param(void)
{
    /* - SPR 17439 */
    /* SPR 22055 FIXED START */
    char *tag_value = OAM_NULL;
    /* SPR 22055 FIXED END */

    UInt8 log_on_off=OAM_ZERO;
    UInt8 log_level=OAM_ZERO;
    UInt8 loop_counter=OAM_ZERO; 
    UInt8 len = OAM_ZERO;   
    /* SPR 19703 changes start */
    U8 rrm_log_level = 0;
    /* SPR 19703 changes end */

    /* Coverity_63661 Fix Start */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.RRMparams,"log_on_off"));
    if(lclTemp_value >= MIN_RRM_INIT_LOG_ON_OFF
            &&
            lclTemp_value <= MAX_RRM_INIT_LOG_ON_OFF)
    {
        log_on_off=lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of log_on_off is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_INIT_LOG_ON_OFF,MAX_RRM_INIT_LOG_ON_OFF);

        return OAM_FAILURE;
    }
    /* Coverity_63661 Fix End */


    /* SPR 19703 changes start */
    rrm_log_level=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.RRMparams,"log_level"));
    /* SPR 20007 : CID 110652 fix start */
    if(rrm_log_level <= MAX_RRM_INIT_LOG_LEVEL)
        /* SPR 20007 : CID 110652 fix end */
    {
        log_level=rrm_log_level;
        OAM_LOG(OAM, OAM_INFO,
                "Populated value of RRM log_level is %d",
                rrm_log_level);
    }else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of log_level is %d and range is from %d to %d",
                rrm_log_level,MIN_RRM_INIT_LOG_LEVEL,MAX_RRM_INIT_LOG_LEVEL);
        /* SPR 19703 changes end */

        return OAM_FAILURE;
    }


    oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.bitmask |= RRM_OAM_MODULE_INIT_CONFIG_PRESENT;

    for(loop_counter=OAM_ZERO;loop_counter<RRM_MAX_NUM_INT_MODULES; loop_counter++)
    {
        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.init_module_config[loop_counter].module_id=(rrm_internal_module_id_et)(RRM_MIN_INT_MODULE_ID + loop_counter);
        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.
            init_module_config[loop_counter].log_config.log_on_off=(rrm_oam_log_on_off_et)log_on_off;
        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.
            init_module_config[loop_counter].log_config.log_level=(rrm_oam_log_level_et)log_level;  
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(xml_struct_g.shm_logger_cfg,
                    "wait_interval"),OAM_INVALID_STR)!= OAM_ZERO) && (oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.shm_logger_cfg,
                        "log_path"),OAM_INVALID_STR)!= OAM_ZERO) && (oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.shm_logger_cfg,
                            "shm_size"),OAM_INVALID_STR)!= OAM_ZERO) && (oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.shm_logger_cfg,
                                "log_file_size"),OAM_INVALID_STR)!= OAM_ZERO) && (oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.shm_logger_cfg,
                                    "log_chunk_count"),OAM_INVALID_STR)!= OAM_ZERO) && (oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.shm_logger_cfg,
                                        "cpu_bitmap"),OAM_INVALID_STR)!= OAM_ZERO) && (oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.shm_logger_cfg,
                                            "file_count"),OAM_INVALID_STR)!= OAM_ZERO) 
      )
    {

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.
            bitmask |= RRM_OAM_SHM_LOGGING_INFO_PRESENT ;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.shm_logger_cfg,"wait_interval"));

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.rrm_shm_log_config.
            wait_interval = lclTemp_value;

        p_temp = oam_xmlNodeGetContent(
                xml_struct_g.shm_logger_cfg,"log_path");
        OAM_NULL_CHECK(p_temp != OAM_NULL);
        len = oam_strlen((char *)p_temp);
        oam_memcpy(oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.rrm_shm_log_config.
                log_path,p_temp,len);

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.shm_logger_cfg,"shm_size"));

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.rrm_shm_log_config.
            shm_size = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.shm_logger_cfg,"log_file_size"));

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.rrm_shm_log_config.
            log_file_sz = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.shm_logger_cfg,"log_chunk_count"));

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.rrm_shm_log_config.
            log_chunk_cnt = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.shm_logger_cfg,"cpu_bitmap"));

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.rrm_shm_log_config.
            cpu_bitmap = lclTemp_value;

        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.shm_logger_cfg,"file_count"));

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.rrm_shm_log_config.
            file_cnt = lclTemp_value;
    }
    else {
        OAM_LOG(OAM, OAM_WARNING, "ALL the parameters of shm_logger_cfg are not present");
    } 

    /* Spr 16211 Changes Start*/
    if((oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.RRMparams,
                        "rim_enable_disable"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.RRMparams,"rim_enable_disable"));

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.
            rrm_rim_config.rim_enable_disable =
            (rrm_bool_et)lclTemp_value;/*cov 97159 +-*/

        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.
            bitmask |= RRM_OAM_RIM_CONFIG_INFO_PRESENT;
    }
    /* Spr 16211 Changes End*/
    /* SPR 22055 FIXED START*/
    tag_value =(Char8*)oam_xmlNodeGetContent(xml_struct_g.health_monitoring,"healthMonitoringTimeInterval");
    if(oam_strcmp(tag_value, OAM_INVALID_STR))
    {
        lclTemp_value = oam_atoi((Char8*)tag_value);
        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.health_update_timer = lclTemp_value;
        oam_prov_req.oam_rrm_req.oam_rrm_init_config_req.bitmask |= RRM_OAM_MODULE_HEALTH_TIMER_PRESENT;
    }    
    /* SPR 22055 FIXED END*/
    OAM_FUN_EXIT_TRACE();    
    return OAM_SUCCESS;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_fill_global_cell_id
 *  DESCRIPTION      : This function is used to populate global cell id
 *  PARAMETERS
 *      IN           : Pointers of xmlNode & oam_rrm_eutran_global_cell_id_t
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
void
oam_fill_global_cell_id( xmlNode             *ptr_node_global_cell_id,
        xmlNode             *ptr_plmn_id,
        oam_rrm_eutran_global_cell_id_t
        *ptr_global_cell_id)
{
    UInt32        value;
    UInt8         index = OAM_ZERO;
    UInt8         num_mnc_digit_new = OAM_ZERO; 
    xmlNode       *ptr_child = OAM_NULL;
    const char    *p_data = OAM_NULL;

    OAM_FUN_ENTRY_TRACE();


    ptr_child = ptr_plmn_id->children; 

    for( index = OAM_ZERO ; ( (index < OAM_THREE )&& (OAM_NULL != (xmlNode *)ptr_child )); index++)
    {

        ptr_child = oam_xml_find_tag(ptr_child,(xmlChar *)"mcc");

        if( OAM_NULL != ptr_child )
        {
            p_data = ((const char *)xmlNodeGetContent( ptr_child ));

            if( OAM_NULL != p_data )
            {
                value =  oam_atoi((const char *)p_data);

                ptr_global_cell_id->primary_plmn_id.mcc[index] = (UInt8)value;

                ptr_child = (((xmlNode *)ptr_child)->next);
            }
        }

    }

    num_mnc_digit_new = oam_atoi((const char *)oam_xmlNodeGetContent(
                ptr_plmn_id,
                "num_mnc_digit"));

    ptr_global_cell_id->primary_plmn_id.num_mnc_digit = num_mnc_digit_new;

    ptr_child = ptr_plmn_id->children;

    for( index = OAM_ZERO ; ((index < num_mnc_digit_new )&& (OAM_NULL != (xmlNode *)ptr_child ));
            index++ )
    {
        ptr_child = oam_xml_find_tag(ptr_child,(xmlChar *)"mnc");

        if( OAM_NULL != ptr_child )
        {
            p_data =  ((const char *)xmlNodeGetContent( ptr_child ));

            if( p_data != OAM_NULL )
            {
                value =  oam_atoi((const char *)p_data);

                ptr_global_cell_id->primary_plmn_id.mnc[index] = (UInt8)value;

                ptr_child = (((xmlNode *)ptr_child)->next);

            }
        }
    }

    ptr_child = ptr_node_global_cell_id->children;

    for( index = OAM_ZERO ; ((index < MAX_CELL_IDENTITY_OCTETS)  &&
                ( OAM_NULL != (xmlNode *)ptr_child )) ; index++ )
    {
        ptr_child = oam_xml_find_tag(ptr_child,(xmlChar *)"cell_identity");

        if( OAM_NULL != ptr_child )
        {
            p_data =  ((const char *)xmlNodeGetContent( ptr_child ));

            if( p_data != OAM_NULL )
            {
                value =  oam_atoi((const char *)p_data );

                ptr_global_cell_id->cell_identity[index] = (UInt8)value;

                ptr_child = (((xmlNode *)ptr_child )->next);
            }
        }
    }
    OAM_FUN_EXIT_TRACE();
}

/*SPR 12228 FIX START*/
/*Redundant code removed */
/*SPR 12228 FIX END*/

/*******************************************************************************
 *  FUNCTION NAME    : oam_fill_version_id_req
 *  DESCRIPTION      : This function is used to populate version id request
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_fill_version_id_req(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    oam_populate_string_params (xml_struct_g.RRMparams,"ver_id",oam_prov_req.oam_rrm_req.oam_send_oam_rrm_ver_id_resp.ver_id,sizeof(oam_prov_req.oam_rrm_req.oam_send_oam_rrm_ver_id_resp.ver_id));

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/* SPR 11001 FIX START */
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_system_spec_load_config_params
 *  DESCRIPTION      : This function is used to populate rrm load config 
 *                      request parameters
 *  PARAMETERS
 *      IN           : Pointer of oam_rrm_cell_config_req_t
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
oam_populate_system_spec_load_config_params
(
 /* + SPR 17439 */
 void 
 /* - SPR 17439 */
 )
{
    Char8 *tag_value = OAM_NULL;
    OAM_FUN_ENTRY_TRACE();

    tag_value =
        (Char8*)oam_xmlNodeGetContent(xml_struct_g.load_configuration,
                "ncl_load_ind_intrvl");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        RRM_PROV_REQ.oam_load_config_req.
            ncl_load_ind_intrvl = oam_atoi(tag_value);

        RRM_PROV_REQ.oam_load_config_req.
            bitmask |= RRM_OAM_NCL_LOAD_IND_INTRVL_PRESENT;
    }

    tag_value =
        (Char8*)oam_xmlNodeGetContent(xml_struct_g.load_configuration,
                "load_rpt_intrvl");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        RRM_PROV_REQ.oam_load_config_req.
            load_rpt_intrvl = oam_atoi(tag_value);

        RRM_PROV_REQ.oam_load_config_req.
            bitmask |= RRM_OAM_LOAD_RPT_INTRVL_PRESENT;
    }

    tag_value =
        (Char8*)oam_xmlNodeGetContent(xml_struct_g.load_configuration,
                "load_chk_periodicity");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        RRM_PROV_REQ.oam_load_config_req.
            load_chk_periodicity = oam_atoi(tag_value);

        RRM_PROV_REQ.oam_load_config_req.
            bitmask |= RRM_OAM_LOAD_CHK_PRDCTY_PRESENT;
    }

    tag_value =
        (Char8*)oam_xmlNodeGetContent(xml_struct_g.load_configuration,
                "high_actn_repeat_lmt");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        RRM_PROV_REQ.oam_load_config_req.
            high_actn_repeat_lmt = oam_atoi(tag_value);

        RRM_PROV_REQ.oam_load_config_req.
            bitmask |= RRM_OAM_HIGH_ACT_RPT_LMT_PRESENT;
    }
    /* SPR 20653 Fix Start */
    tag_value =
        (Char8*)oam_xmlNodeGetContent(xml_struct_g.load_configuration,
                "tnl_load_support_flag");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        RRM_PROV_REQ.oam_load_config_req.
            tnl_load_support_flag = oam_atoi(tag_value);

        RRM_PROV_REQ.oam_load_config_req.
            bitmask |= RRM_OAM_TNL_LOAD_SUPPORT_FLAG_PRESENT;
    }

    tag_value =
        (Char8*)oam_xmlNodeGetContent(xml_struct_g.load_configuration,
                "hw_load_support_flag");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        RRM_PROV_REQ.oam_load_config_req.
            hw_load_support_flag = oam_atoi(tag_value);

        RRM_PROV_REQ.oam_load_config_req.
            bitmask |= RRM_OAM_HW_LOAD_SUPPORT_FLAG_PRESENT;
    }
    /* SPR 20653 fix End */

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_cell_spec_load_config_params
 *  DESCRIPTION      : This function is used to populate rrm load config 
 *                      request parameters
 *  PARAMETERS
 *      IN           : Pointer of oam_rrm_cell_config_req_t
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_cell_spec_load_config_params
(
 rrm_oam_serving_enb_cell_info_t *p_srv_enb_cell_info,
 prop_cellconfig_xml_st *p_prop_cellconfig,
 oam_rrm_cell_config_req_t *p_rrm_cell_config
 )
    /* SPR 11001 FIX END */
{
    SInt32   value = 0;
    UInt8    index = 0;
    UInt8        load_num = 0;
    /* SPR 11001 FIX START */
    Char8 *tag_value = OAM_NULL;
    SInt32 tag_found1 = OAM_ZERO;
    SInt32 tag_found2 = OAM_ZERO;

    oam_rrm_load_def_t   *p_load = OAM_NULL;

    /* SPR 16200 FIX START */
    rrm_oam_sub_frame_asgmnt_et tdd_config = RRM_OAM_SA0;
    oam_return_et retVal = OAM_FAILURE;
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    /* SPR 16200 FIX END */
    OAM_FUN_ENTRY_TRACE();


    oam_memcpy(&p_srv_enb_cell_info->global_cell_id,
            &(p_rrm_cell_config->global_cell_info.eutran_global_cell_id),
            sizeof(rrm_oam_eutran_global_cell_id_t));

    tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->load_config,
            "load_level_num_entries");
    load_num = oam_atoi(tag_value);


    for (index = OAM_ZERO; index < load_num; ++index) {
        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "load_level");

        if (oam_strcmp(tag_value, OAM_INVALID_STR)) {
            if(!oam_strcmp(tag_value, "OverLoad")) {
                p_srv_enb_cell_info->bitmask |= 
                    RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT;
                p_load = &p_srv_enb_cell_info->over_load_lvl_act;
            }
            else if(!oam_strcmp(tag_value, "HighLoad")) {
                p_srv_enb_cell_info->bitmask |= 
                    RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT;
                p_load = &p_srv_enb_cell_info->high_load_lvl_act;
            }
            else if(!oam_strcmp(tag_value, "MidLoad")) {
                p_srv_enb_cell_info->bitmask |= 
                    RRM_OAM_MID_LOAD_LVL_ACT_PRESENT;
                p_load = &p_srv_enb_cell_info->mid_load_lvl_act;
            } 
            else {
				OAM_LOG(OAM, OAM_WARNING, "Load level: %s is not supported",
                        tag_value);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Failed to read load level[%d]", index);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "load_percentage");

        if (oam_strcmp(tag_value, OAM_INVALID_STR)) {
            value = oam_atoi(tag_value);

            if (value >= OAM_RRM_MIN_LOAD_PRCNT &&
                    value <= OAM_RRM_MAX_LOAD_PRCNT) {
                p_load->load_perctg = value;
                p_load->bitmask |= RRM_OAM_PERCNTG_PRESENT;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                        "parameter load_percentage (allowed %d to %d)",
                        value,
                        OAM_RRM_MIN_LOAD_PRCNT, OAM_RRM_MAX_LOAD_PRCNT);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "action");

        if (oam_strcmp(tag_value, OAM_INVALID_STR)) {
            value = oam_atoi(tag_value);

            if (value >= 0) {
                p_load->action = value;
                p_load->bitmask |= RRM_OAM_ACTION_PRESENT;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                        "parameter action (allowed > 0)", value);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "num_users");

        if (oam_strcmp(tag_value, OAM_INVALID_STR)) {
            value = oam_atoi(tag_value);

            if (value >= OAM_RRM_MIN_LOAD_NUM_USRS &&
                    value <= OAM_RRM_MAX_LOAD_NUM_USRS) {
                p_load->num_usr = value;
                p_load->bitmask |= RRM_OAM_NUM_USR_PRESENT;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                        "parameter num_users (allowed %d to %d)",
                        value,
                        OAM_RRM_MIN_LOAD_NUM_USRS,
                        OAM_RRM_MAX_LOAD_NUM_USRS);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "q_watermark_high");

        tag_found1 = !oam_strcmp(tag_value, OAM_INVALID_STR);

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "q_watermark_low");

        tag_found2 = !oam_strcmp(tag_value, OAM_INVALID_STR);

        if (tag_found1 && tag_found2) {
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_prop_cellconfig->load_level_info[index],
                    "q_watermark_high");
            value = oam_atoi(tag_value);

            if (value >= OAM_RRM_MIN_LOAD_Q_WATERMARK &&
                    value <= OAM_RRM_MAX_LOAD_Q_WATERMARK) {
                p_load->q_watermark.high_watermark = value;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                        "parameter q_watermark_high (allowed %d to %d)",
                        value,
                        OAM_RRM_MIN_LOAD_Q_WATERMARK,
                        OAM_RRM_MAX_LOAD_Q_WATERMARK);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_prop_cellconfig->load_level_info[index],
                    "q_watermark_low");
            value = oam_atoi(tag_value);

            if (value >= OAM_RRM_MIN_LOAD_Q_WATERMARK &&
                    value <= OAM_RRM_MAX_LOAD_Q_WATERMARK) {
                p_load->q_watermark.low_watermark = value;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                        "parameter q_watermark_low (allowed %d to %d)",
                        value,
                        OAM_RRM_MIN_LOAD_Q_WATERMARK,
                        OAM_RRM_MAX_LOAD_Q_WATERMARK);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            p_load->bitmask |= RRM_OAM_Q_WATERMARK_PRESENT;
        }




        if(p_prop_cellconfig->load_access_class_barring_config[index]) {
            if(p_prop_cellconfig->acBarringForMoSignalling[index]) {
                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_prop_cellconfig->acBarringForMoSignalling[index],
                        "acBarringFactor");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);
                    /**  Coverity 64282 , 63835  Fix Start **/
                    if( value >= RRM_AC_BARRING_FACTOR_P00 && value <= RRM_AC_BARRING_FACTOR_P95) {
                        /**  Coverity 64282 , 63835  Fix Start **/
                        p_load->ld_ac_bar.ac_barring_for_mo_signalling.
                            ac_barring_factor = (rrm_oam_ac_barring_factor_et)value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringFactor (allowed %d to %d)",
                                value,
                                RRM_AC_BARRING_FACTOR_P00,
                                RRM_AC_BARRING_FACTOR_P95);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringFactor[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_prop_cellconfig->acBarringForMoSignalling[index],
                        "acBarringTime");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    if (value >= RRM_AC_BARRING_TIME_S4 && /* Coverity ID : 64282 , 63835 Fix Start */
                            value <= RRM_AC_BARRING_TIME_S512) {
                        p_load->ld_ac_bar.ac_barring_for_mo_signalling.
                            ac_barring_time = (rrm_oam_ac_barring_time_et)value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringTime (allowed %d to %d)",
                                value,
                                RRM_AC_BARRING_TIME_S4,
                                RRM_AC_BARRING_TIME_S512);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringTime[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_prop_cellconfig->acBarringForMoSignalling[index],
                        "acBarringForSpecialAc");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    if (value >= OAM_RRM_MIN_LOAD_AC_BARRING_FOR_SPECIAL_AC &&
                            value <= OAM_RRM_MAX_LOAD_AC_BARRING_FOR_SPECIAL_AC) {
                        p_load->ld_ac_bar.ac_barring_for_mo_signalling.
                            ac_barring_for_special_ac = value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringForSpecialAc (allowed %d to %d)",
                                value,
                                OAM_RRM_MIN_LOAD_AC_BARRING_FOR_SPECIAL_AC,
                                OAM_RRM_MAX_LOAD_AC_BARRING_FOR_SPECIAL_AC);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringForSpecialAc[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                p_load->ld_ac_bar.
                    bitmask |= RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT;
            }

            if(p_prop_cellconfig->acBarringForMoData[index]) {
                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_prop_cellconfig->acBarringForMoData[index],
                        "acBarringFactor");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    /**  Coverity 64282  , 63835  Fix Start **/
                    if( value >= RRM_AC_BARRING_FACTOR_P00 && value <= RRM_AC_BARRING_FACTOR_P95) {
                        /**  Coverity 64282  , 63835  Fix Start **/
                        p_load->ld_ac_bar.ac_barring_for_mo_data.
                            ac_barring_factor = (rrm_oam_ac_barring_factor_et)value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringFactor (allowed %d to %d)",
                                value,
                                RRM_AC_BARRING_FACTOR_P00,
                                RRM_AC_BARRING_FACTOR_P95);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringFactor[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_prop_cellconfig->acBarringForMoData[index],
                        "acBarringTime");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);
                    /* coverity 64282  , 63835 Fix Start*/
                    if (value >= RRM_AC_BARRING_TIME_S4 && /* Coverity  64282  , 63835 Fix End */
                            value <= RRM_AC_BARRING_TIME_S512) {
                        p_load->ld_ac_bar.ac_barring_for_mo_data.
                            ac_barring_time = (rrm_oam_ac_barring_time_et)value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringTime (allowed %d to %d)",
                                value,
                                RRM_AC_BARRING_TIME_S4,
                                RRM_AC_BARRING_TIME_S512);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringTime[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_prop_cellconfig->acBarringForMoData[index],
                        "acBarringForSpecialAc");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    if (value >= OAM_RRM_MIN_LOAD_AC_BARRING_FOR_SPECIAL_AC &&
                            value <= OAM_RRM_MAX_LOAD_AC_BARRING_FOR_SPECIAL_AC) {
                        p_load->ld_ac_bar.ac_barring_for_mo_data.
                            ac_barring_for_special_ac = value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringForSpecialAc (allowed %d to %d)",
                                value,
                                OAM_RRM_MIN_LOAD_AC_BARRING_FOR_SPECIAL_AC,
                                OAM_RRM_MAX_LOAD_AC_BARRING_FOR_SPECIAL_AC);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringForSpecialAc[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                p_load->ld_ac_bar.
                    bitmask |= RRM_OAM_AC_BARRING_MO_DATA_PRESENT;
            }

            if(p_prop_cellconfig->ssac_barring_for_mmtel_voice_r9[index]) {
                tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->
                        ssac_barring_for_mmtel_voice_r9[index],
                        "acBarringFactor");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    /* bug_15030_start CID 64282  , 63835 */
                    if( value >= RRM_AC_BARRING_FACTOR_P00 && value <= RRM_AC_BARRING_FACTOR_P95) {
                        /* bug_15030_end CID 64282  , 63835*/
                        p_load->ld_ac_bar.ssac_barring_r9.
                            ssac_barring_for_mmtel_voice_r9.
                            ac_barring_factor = (rrm_oam_ac_barring_factor_et)value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringFactor (allowed %d to %d)",
                                value,
                                RRM_AC_BARRING_FACTOR_P00,
                                RRM_AC_BARRING_FACTOR_P95);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringFactor[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->
                        ssac_barring_for_mmtel_voice_r9[index],
                        "acBarringTime");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    if (
                            (rrm_oam_ac_barring_time_et)value <= RRM_AC_BARRING_TIME_S512) {
                        p_load->ld_ac_bar.ssac_barring_r9.
                            ssac_barring_for_mmtel_voice_r9.
                            ac_barring_time = (rrm_oam_ac_barring_time_et)value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringTime (allowed %d to %d)",
                                value,
                                RRM_AC_BARRING_TIME_S4,
                                RRM_AC_BARRING_TIME_S512);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringTime[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->
                        ssac_barring_for_mmtel_voice_r9[index],
                        "acBarringForSpecialAc");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    if (value >= OAM_RRM_MIN_LOAD_AC_BARRING_FOR_SPECIAL_AC &&
                            value <= OAM_RRM_MAX_LOAD_AC_BARRING_FOR_SPECIAL_AC) {
                        p_load->ld_ac_bar.ssac_barring_r9.
                            ssac_barring_for_mmtel_voice_r9.
                            ac_barring_for_special_ac = value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringForSpecialAc "
                                "(allowed %d to %d)", value,
                                OAM_RRM_MIN_LOAD_AC_BARRING_FOR_SPECIAL_AC,
                                OAM_RRM_MAX_LOAD_AC_BARRING_FOR_SPECIAL_AC);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringForSpecialAc[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                p_load->ld_ac_bar.
                    bitmask |= RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT;

                p_load->ld_ac_bar.ssac_barring_r9.
                    bitmask |= RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT;
            }

            if(p_prop_cellconfig->ssac_barring_for_mmtel_video_r9[index]) {
                tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->
                        ssac_barring_for_mmtel_video_r9[index],
                        "acBarringFactor");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);
                    /* bug_15030_start CID 64282  , 63835 */
                    if ( value >= RRM_AC_BARRING_FACTOR_P00 && value <= RRM_AC_BARRING_FACTOR_P95) {
                        /* bug_15030_end CID 64282  , 63835*/
                        p_load->ld_ac_bar.ssac_barring_r9.
                            ssac_barring_for_mmtel_video_r9.
                            ac_barring_factor = (rrm_oam_ac_barring_factor_et)value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringFactor (allowed %d to %d)",
                                value,
                                RRM_AC_BARRING_FACTOR_P00,
                                RRM_AC_BARRING_FACTOR_P95);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringFactor[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->
                        ssac_barring_for_mmtel_video_r9[index],
                        "acBarringTime");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    if (
                            (rrm_oam_ac_barring_time_et)value <= RRM_AC_BARRING_TIME_S512) {
                        p_load->ld_ac_bar.ssac_barring_r9.
                            ssac_barring_for_mmtel_video_r9.
                            ac_barring_time = (rrm_oam_ac_barring_time_et)value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringTime (allowed %d to %d)",
                                value,
                                RRM_AC_BARRING_TIME_S4,
                                RRM_AC_BARRING_TIME_S512);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringTime[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->
                        ssac_barring_for_mmtel_video_r9[index],
                        "acBarringForSpecialAc");

                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    value = oam_atoi(tag_value);

                    if (value >= OAM_RRM_MIN_LOAD_AC_BARRING_FOR_SPECIAL_AC &&
                            value <= OAM_RRM_MAX_LOAD_AC_BARRING_FOR_SPECIAL_AC) {
                        p_load->ld_ac_bar.ssac_barring_r9.
                            ssac_barring_for_mmtel_video_r9.
                            ac_barring_for_special_ac = value;
                    }
                    else {
						OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                                "parameter acBarringForSpecialAc "
                                "(allowed %d to %d)", value,
                                OAM_RRM_MIN_LOAD_AC_BARRING_FOR_SPECIAL_AC,
                                OAM_RRM_MAX_LOAD_AC_BARRING_FOR_SPECIAL_AC);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Expected node acBarringForSpecialAc[%d] not found",
                            index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                p_load->ld_ac_bar.
                    bitmask |= RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT;

                p_load->ld_ac_bar.ssac_barring_r9.
                    bitmask |= RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT;
            }

            p_load->bitmask |= RRM_OAM_LD_AC_BARRING_PRESENT;
        }

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "redirect_meas_based_rwr");

        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            value = oam_atoi(tag_value);

            if (value >= OAM_RRM_MIN_LOAD_REDIRECT_MEAS_BASED_RWR &&
                    value <= OAM_RRM_MAX_LOAD_REDIRECT_MEAS_BASED_RWR) {
                p_load->redirect_info.is_meas_based_rwr = (rrm_bool_t)value;
                p_load->bitmask |= RRM_OAM_REDIRECT_INFO_PRESENT;
                p_load->redirect_info.
                    bitmask |= RRM_OAM_MEAS_BASED_RWR_PRESENT;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                        "parameter redirect_meas_based_rwr "
                        "(allowed %d to %d)", value,
                        OAM_RRM_MIN_LOAD_REDIRECT_MEAS_BASED_RWR,
                        OAM_RRM_MAX_LOAD_REDIRECT_MEAS_BASED_RWR);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "redirect_meas_based_rwr_timer");

        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            value = oam_atoi(tag_value);

            if (value >= OAM_RRM_MIN_LOAD_REDIRECT_RWR_TIMER &&
                    value <= OAM_RRM_MAX_LOAD_REDIRECT_RWR_TIMER) {
                p_load->redirect_info.rwr_timer = value;
                p_load->bitmask |= RRM_OAM_REDIRECT_INFO_PRESENT;
                p_load->redirect_info.
                    bitmask |= RRM_OAM_RWR_TIMER_PRESENT;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                        "parameter redirect_meas_based_rwr_timer "
                        "(allowed %d to %d)", value,
                        OAM_RRM_MIN_LOAD_REDIRECT_RWR_TIMER,
                        OAM_RRM_MAX_LOAD_REDIRECT_RWR_TIMER);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_prop_cellconfig->load_level_info[index],
                "soft_limit");

        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            value = oam_atoi(tag_value);

            if (value >= OAM_RRM_MIN_LOAD_STOP_ADM_INFO_SOFT_LIMIT &&
                    value <= OAM_RRM_MAX_LOAD_STOP_ADM_INFO_SOFT_LIMIT) {
                p_load->stop_adm_info.soft_limit = value;
                p_load->bitmask |= RRM_OAM_STOP_ADM_INFO_PRESENT;
                p_load->stop_adm_info.
                    bitmask |= RRM_OAM_SOFT_LIMIT_PRESENT;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                        "parameter soft_limit "
                        "(allowed %d to %d)", value,
                        OAM_RRM_MIN_LOAD_STOP_ADM_INFO_SOFT_LIMIT,
                        OAM_RRM_MAX_LOAD_STOP_ADM_INFO_SOFT_LIMIT);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        /* SPR 11001 FIX END */
        /*eICIC_PHASE_1_2_CHANGES_START*/ 
        if(p_prop_cellconfig->eicic_load_config[index]) 
        { 
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_prop_cellconfig->eicic_load_config[index],
                    "eligible_ue");

            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                value = oam_atoi(tag_value);
                if (value >= OAM_RRM_eICIC_MIN_ELEGIBLE_UE &&
                        value <= OAM_RRM_eICIC_MAX_ELEGIBLE_UE) {

                    p_load->eicic_load_config.eligible_ue = value;
                    p_load->bitmask |= RRM_OAM_EICIC_LOAD_CONFIG_PRESENT;
                    p_load->eicic_load_config.bitmask |= RRM_OAM_ELIGIBLE_UE_PRESENT;


                }     
                else {
					OAM_LOG(OAM, OAM_WARNING, "Out-of-range value %d of "
                            "parameter eligible_ue"
                            "(allowed %d to %d)", value,
                            OAM_RRM_eICIC_MIN_ELEGIBLE_UE,
                            OAM_RRM_eICIC_MAX_ELEGIBLE_UE);

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
            } 
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_prop_cellconfig->eicic_load_config[index],
                    "abs_pattern");

            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                /* SPR 16200 FIX START */
                /* spr_21013_fix_start */
                oam_get_xml_text_node_content(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,
                        /* spr_21013_fix_end */
                        "DuplexMode", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);
                tdd_config = p_rrm_cell_config->ran_info.physical_layer_params.
                    physical_layer_param_tdd_frame_structure.
                    sub_frame_assignment;

                retVal = oam_validate_abs_pattern(tag_value, buf,
                        tdd_config);
                if (OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_WARNING,
                            "ABS pattern length is too long");

                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }
                /* SPR 16200 FIX END */

                if(OAM_SUCCESS == 
                        oam_conversion_abs_pattern_byte_string_to_bitstring(
                            tag_value ,p_load->eicic_load_config.abs_pattern))
                {
                    p_load->bitmask |= RRM_OAM_EICIC_LOAD_CONFIG_PRESENT;
                    p_load->eicic_load_config.bitmask |= RRM_OAM_ABS_PATTERN_PRESENT;

                }     
                else {
					OAM_LOG(OAM, OAM_WARNING, "Out-of-range length %d of "
                            "parameter abs_patarn"
                            "(allowed %d to %d)", value,
                            OAM_RRM_eICIC_MIN_ABS_PATTERN_LENGTH,
                            OAM_RRM_eICIC_MAX_ABS_PATTERN_LENGTH);

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
            }
        }
        /*eICIC_PHASE_1_2_CHANGES_END*/  
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_tdd_frame
 *  DESCRIPTION      : This function is used to populate the rrm
 *                                         init config parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
void
    oam_populate_tdd_frame
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_rrm_cell_config_req_t *p_rrm_cellconfig
 )
{
    UInt32    value = OAM_ZERO;
    OAM_FUN_ENTRY_TRACE();
    Char8* tag_value = OAM_NULL;

    UInt8 sub_frame_assignment , special_sub_frame_patterns;

    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->TDDFrame,
            "SubFrameAssignment");
    value =  oam_atoi(tag_value);
    p_rrm_cellconfig->ran_info.physical_layer_params.
        bitmask |= RRM_OAM_PHYSICAL_LAYER_PARAM_TDD_FRAME_PRESENT;

    /* coverity 35823 */
    p_rrm_cellconfig->ran_info.physical_layer_params.
        physical_layer_param_tdd_frame_structure.sub_frame_assignment =
        (rrm_oam_sub_frame_asgmnt_et)value;

    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->TDDFrame,
            "SpecialSubframePatterns");
    value =  oam_atoi(tag_value);

    p_rrm_cellconfig->ran_info.physical_layer_params.
        physical_layer_param_tdd_frame_structure.special_sub_frame_patterns =
        (rrm_oam_special_sub_frame_patterns_et)value;

    sub_frame_assignment = p_rrm_cellconfig->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure.sub_frame_assignment;
    special_sub_frame_patterns = p_rrm_cellconfig->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure.special_sub_frame_patterns;

    oam_prov_req.prb_usage_factor.num_ul_schedulable = numDlUlScdeulable[sub_frame_assignment][special_sub_frame_patterns].num_ul_schedulable;

    oam_prov_req.prb_usage_factor.num_dl_schedulable = numDlUlScdeulable[sub_frame_assignment][special_sub_frame_patterns].num_dl_schedulable;
    OAM_FUN_EXIT_TRACE();

}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_irat_eutrans_to_utra_tdd_list
 *  DESCRIPTION      : This function is used to populate the UTRAN TDD frequency
 *                      parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* RT SPR 9019 FIX START */

oam_return_et
oam_populate_irat_eutrans_to_utra_tdd_list
(
 XML_struct_cell_config *p_cell_spec_params,
 /* BCOM Compiltaion Fix */
#ifdef OAM_SON_ENABLE
 /*SPR_17730 Fix Start */
 oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params,
 /*SPR_17730 Fix End */
#endif
 /* BCOM Compiltaion Fix */
 oam_rrm_cell_config_req_t *p_rrm_cellconfig
 )
{
    UInt32   count = 0;
    UInt32   value = 0;
    UInt8    index = 0;
    Char8 *tag_value = OAM_NULL;
    oam_return_et retVal = OAM_FAILURE;
    /*SPR_17730 Fix Start */    
    SInt32 num_entries = 0;
    /*SPR_17730 Fix End */    

    OAM_FUN_ENTRY_TRACE();

    /* No need to read the tag NUM_IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS
     * again as it's already done */

    /*SPR_17730 Fix Start */

    /* BCOM Compiltaion Fix */
#ifdef OAM_SON_ENABLE
    oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
        &p_son_inter_freq_carr_params->oam_son_anr_meas_config_req;
#endif
    /* BCOM Compiltaion Fix */


    tag_value = (Char8*)oam_xmlNodeGetContent(
            p_cell_spec_params->UTRA,				
            "NUM_IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS");

    num_entries = oam_atoi(tag_value);

	OAM_LOG(OAM, OAM_INFO,
            "value of num_entries :[%d],",num_entries);


    if(num_entries > OAM_MAX_NUM_UTRA_TDD_CARRIERS) {
		OAM_LOG(OAM, OAM_WARNING, "Maximum allowed value of the tag "
                "NUM_IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS is %d",
                OAM_MAX_NUM_UTRA_TDD_CARRIERS);
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
#ifdef OAM_SON_ENABLE


    p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
        utran_fdd_list_size = count;
#endif

    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
        irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers = num_entries;


    /*SPR22856_FIX_START*/
    /*Lines Deleted*/
    /*SPR22856_FIX_STOP*/
    /*SPR_17730 Fix End */


    count = p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
        irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers;
    /* SPR_17730 Fix Start */
    for(index = 0; index < count; ++index) {
        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_cell_spec_params->UTRANTDDFreq[index],
                "UTRA_CARRIER_ARFCN");
		OAM_LOG(OAM, OAM_INFO,
                "Value of count :%d,Value of tag:%p",
                count,tag_value);
        /* SPR_17730 Fix End */
        if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
			OAM_LOG(OAM, OAM_WARNING,
					"Mandatory tag \"UTRA_CARRIER_ARFCN[%d]\" missing",
                    index);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        value =  oam_atoi(tag_value);

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[index].
            utra_carrier_arfcn = value;


        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_cell_spec_params->UTRANTDDFreq[index],
                "Q_RX_LEV_MIN");
        if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
			OAM_LOG(OAM, OAM_WARNING,
					"Mandatory tag \"Q_RX_LEV_MIN[%d]\" missing",
                    index);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        value =  oam_atoi(tag_value);

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[index].
            q_rx_lev_min = (SInt8)value;


        /*BUG_FIX_6943 */
        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_cell_spec_params->UTRANTDDFreq[index],
                "CELL_RESELECTION_PRIORITY");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            value =  oam_atoi(tag_value);
            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_utra_params.
                irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].
                cell_reselection_priority = value;
            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_utra_params.
                irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].
                bitmask |= RRM_OAM_IRAT_CELL_RESELECTION_PRIORITY_PRESENT;

        }

        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_cell_spec_params->UTRANTDDFreq[index],
                "THRESH_X_HIGH");
        if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
			OAM_LOG(OAM, OAM_WARNING,
					"Mandatory tag \"THRESH_X_HIGH[%d]\" missing",
                    index);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        value =  oam_atoi(tag_value);

        p_rrm_cellconfig->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            threshold_x_high = (UInt8)value;


        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_cell_spec_params->UTRANTDDFreq[index],
                "THRESH_X_LOW");
        if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
			OAM_LOG(OAM, OAM_WARNING,
					"Mandatory tag \"THRESH_X_LOW[%d]\" missing",
                    index);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        value =  oam_atoi(tag_value);

        p_rrm_cellconfig->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            threshold_x_low = (UInt8)value;



        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_cell_spec_params->UTRANTDDFreq[index],
                "P_MAX_UTRA");
        if(!oam_strcmp(tag_value, OAM_INVALID_STR)) {
			OAM_LOG(OAM, OAM_WARNING,
					"Mandatory tag \"P_MAX_UTRA[%d]\" missing", index);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        value =  oam_atoi(tag_value);

        p_rrm_cellconfig->ran_info.mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].p_max_utra = (SInt8)value;


    }
    /*SPR22856_FIX_START*/
    if(OAM_ZERO < num_entries ) {
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
            bitmask |= RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT;

        p_rrm_cellconfig->ran_info. mobility_params.
            bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT;

        p_rrm_cellconfig->ran_info.
            bitmask |= RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT;       
    }
    /*SPR22856_FIX_STOP*/
    OAM_FUN_EXIT_TRACE();
    retVal = OAM_SUCCESS;
    return retVal;
}
/* RT SPR 9019 FIX END */

/****************************************************************************
 *  FUNCTION NAME    : oam_fill_mcc_mnc_from_plmnid
 *  DESCRIPTION      : This function is used to the PLMNID from a given numeric
 *                     character string
 *  PARAMETERS       
 *      IN           : temp: numeric character string
 *                   
 *      OUT          : plmnid strucutre
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 ****************************************************************************/
/*****SPR FIX FOR 00044046*******************************/
    oam_return_et
oam_fill_mcc_mnc_from_plmnid(char *temp ,rrm_oam_cell_plmn_info_t *plmnid )
{
    OAM_FUN_ENTRY_TRACE();

    UInt16 length = OAM_ZERO;
    char new_plmn[OAM_SEVEN],final_plmn[OAM_TWO];
    oam_memset(new_plmn, OAM_ZERO , OAM_SEVEN);
    oam_memset(final_plmn, OAM_ZERO , OAM_TWO);

	OAM_LOG(OAM, OAM_INFO,
			" {global}Content of node is PLMN ID and parameter name is %s",temp);

    length = oam_strlen(temp);

    if (OAM_SIX == length)
    {
        oam_memcpy(new_plmn,temp,OAM_SIX);
    }
    else
    {
        OAM_LOG(OAM, OAM_DETAILED,
				" Enter Valid PLMN ID");

        return OAM_FAILURE;
    }

    snprintf(final_plmn,OAM_ONE + sizeof(new_plmn[OAM_ZERO]),"%c",new_plmn[OAM_ZERO]);
    plmnid->mcc[OAM_ONE] = oam_atoi(final_plmn);


    snprintf(final_plmn,OAM_ONE + sizeof(new_plmn[OAM_ONE]),"%c",new_plmn[OAM_ONE]);
    plmnid->mcc[OAM_ZERO] = oam_atoi(final_plmn);

    snprintf(final_plmn,OAM_ONE + sizeof(new_plmn[OAM_THREE]),"%c",new_plmn[OAM_THREE]);
    plmnid->mcc[OAM_TWO] = oam_atoi(final_plmn);


    snprintf(final_plmn,OAM_ONE + sizeof(new_plmn[OAM_TWO]),"%c",new_plmn[OAM_TWO]);
    if ((new_plmn[OAM_TWO] == 'f') || new_plmn[OAM_TWO] == 'F')
    {

        snprintf(final_plmn,OAM_ONE + sizeof(new_plmn[OAM_FOUR]),"%c",new_plmn[OAM_FOUR]);
        plmnid->mnc[OAM_ONE] = oam_atoi(final_plmn);

        snprintf(final_plmn,OAM_ONE + sizeof(new_plmn[OAM_FIVE]),"%c",new_plmn[OAM_FIVE]);
        plmnid->mnc[OAM_ZERO] = oam_atoi(final_plmn);
    }
    else
    {
        plmnid->mnc[OAM_ZERO] = oam_atoi(final_plmn);

        snprintf(final_plmn,OAM_ONE + sizeof(new_plmn[OAM_FOUR]),"%c",new_plmn[OAM_FOUR]);

        plmnid->mnc[OAM_TWO] = oam_atoi(final_plmn);

        snprintf(final_plmn,OAM_ONE + sizeof(new_plmn[OAM_FIVE]),"%c",new_plmn[OAM_FIVE]);

        plmnid->mnc[OAM_ONE] = oam_atoi(final_plmn);
    }

    if (new_plmn[OAM_TWO] == 'f' || new_plmn[OAM_TWO] == 'F')
    {
        plmnid->num_mnc_digit = MIN_NUM_MNC_DIGIT;
    }
    else
    {
        plmnid->num_mnc_digit = MAX_NUM_MNC_DIGIT;
    }





    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_rrm_cell_config_param
 *  DESCRIPTION      : This function is used to populate the rrm cell 
 *                     config parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

oam_return_et
oam_populate_rrm_cell_config_param
(
 oam_rrm_cell_config_req_t *p_rrm_cellconfig,
 oam_rrm_cell_plmnlist_data_t *p_plmnlist_data,
 XML_struct_cell_config *p_cell_spec_params,
/* SPR 22248 MBMS Changes Start */
 XML_struct_fap_service *p_cell_specFAPService,
/* SPR 22248 MBMS Changes Stop */
 /* SPR 17730 Fix Start */
 /* BCOM Compiltaion Fix */
#ifdef OAM_SON_ENABLE
 oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params,
#endif
 /* BCOM Compiltaion Fix */
 /* SPR 17730 Fix End */
 /* spr_21013_fix_start */
 prop_cellconfig_xml_st *p_prop_cellconfig,
 /* SPR 15527 START */
 UInt8 cell_index,
 /* spr_21013_fix_end */
 oam_rrm_qos_data_t *p_qos_data
 /* SPR 15527 END */
 )
{
    /* SPR 14651 START */
    UInt32 count= OAM_ZERO;
    /* SPR 14651 END */
    /* SPR 20653 Fix Start */
    UInt8  index= OAM_ZERO;
    char *p_temp_token = OAM_NULL;
    /* SPR 20653 Fix End */
    /* SPR_9464_FIX Start */
    UInt32 drx_count = OAM_ZERO;
    /* SPR_9464_FIX End */
    /* SPR 15527 START */
    UInt32 count_qci = OAM_ZERO;
    oam_bool_et qos_enable = OAM_FALSE;
    /* SPR 15527 END */
    /* SPR 12096 Fix Start */
    UInt8 i = OAM_ZERO;
    /* SPR 12096 Fix End */
    /*SPR 21096 Start*/
    U8 l2_instance = OAM_ZERO;
    /*SPR 21096 End*/

    Char8 *temp =OAM_NULL;
    /* + SPR 17665 + */
    /*
     * To store the list of RBs for SI msgs
     * corresponding to different TBSizes
     */
    Char8  si_rb_list[RBS_FOR_DCI_1C_SIZE* OAM_FOUR] = {0};
    /* - SPR 17665 - */
    /* RT SPR 8154 FIX START */
    UInt32 count1 = OAM_ZERO;
    SInt32 diff1 = OAM_FALSE;
    SInt32 diff2 = OAM_FALSE;
    U8 lclTemp_value_1 = OAM_ZERO;
    UInt8 cell_identity[MAX_CELL_IDENTITY_OCTETS] = {OAM_ZERO};
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};

    xmlNode       *ptr_child = OAM_NULL;
    /* RT SPR 8154 FIX END */

    /* RT SPR 9019 FIX START */
    oam_return_et retVal = OAM_SUCCESS;
    /* RT SPR 9019 FIX END */
    /* SPR 15238 START */
    oam_access_mode_et calculated_access_mode = OAM_OPEN_FEMTO;
    /* SPR 15238 END */
    xmlChar *tag_value = OAM_NULL;
    /* SPR21978 Start */
    Char8* tagvalue = {0};
    /* SPR21978 End */
    xmlNode       *p_access_mgmt_lte_xml_node = OAM_NULL;
    /* SPR 12987 REVIEW COMMENTS FIX START */
    Char8 temp_plmnid[OAM_SEVEN] = {0};
    UInt8 bit_set = OAM_ZERO;
    /* SPR 12987 REVIEW COMMENTS FIX END */
    /* SPR-13976 START */
    Char8 *tag_name_1;
    Char8 *tag_name_2;
    Char8 *tag_name_3;
    Char8 *tag_name_4;
    Char8 *tag_name_5;
    /* SPR-13976 END*/
    /* Spr 15438 Fix Start */ 
    UInt8 lte_cell_enable = OAM_ZERO;  
    UInt8 lte_cell_mi = OAM_ZERO;
    /* Spr 15438 Fix End */  
    /*SPR 15604 START */
    UInt8 indx = OAM_ZERO;
    oam_bool_et duplicate_nbr_found = OAM_FALSE;
    UInt16 nliu_counter = OAM_ZERO;
    UInt16 intra_freq_ncl_idx = OAM_ZERO;
    UInt16 inter_freq_ncl_idx = OAM_ZERO;
    UInt16 lte_cell_num_entries_nliu = OAM_ZERO;
    UInt16 max_lte_cell_entries_nliu=OAM_ZERO;
    /* SPR 22420 Fix Start */
    UInt16 abs_value = OAM_ZERO;
    /* SPR 22420 Fix End */
    /*SPR 15604 END */
    /* SPR 14651 START */
    UInt8 eutran_meas_enable = OAM_ZERO;
    UInt8 utran_meas_enable = OAM_ZERO;
    UInt8 geran_meas_enable = OAM_ZERO;
    UInt8 meas_count = OAM_ZERO;
    UInt8 num_entries = OAM_ZERO;
    UInt8 max_entries = OAM_ZERO;
    /* SPR 14651 END*/

    /* SPR 17525 changes start */
    /* SPR 20430 Changes Start*/
    //UInt32 temp_node = OAM_ZERO;

    xmlNode *temp_node = OAM_ZERO;
    /* SPR 20430 Changes Start*/
    /* SPR 17525 changes end */

    /*SPR 16372 fix start*/	
    /* SPR 17408 Fix +- */	
    /*SPR 16372 fix stop*/	
    /* SPR 19349 Fix Start */ 
    oam_rrm_plmn_data_t        *p_plmn_entries = OAM_NULL;
    /* SPR 19349 Fix End */ 

    /* SPR-18198 START */
    UInt8 ul_prb_budget_ngbr = OAM_ZERO;
    UInt8 dl_prb_budget_ngbr = OAM_ZERO;
    UInt8 ul_prb_budget_gbr = OAM_ZERO;
    UInt8 dl_prb_budget_gbr = OAM_ZERO;
    /* SPR-18198 END */

    /* COV 31347 changes start */
    U8 tdd_ack_nack_feedback_mode = OAM_ZERO;  
    /* COV 31347 changes end */

#ifdef LTE_EMBMS_SUPPORTED
    disable_embms_neighcellconfig_g = OAM_FALSE;
#endif
    /* SPR 17730 Fix Start*/
    /* BCOM Compiltaion Fix */
#ifdef OAM_SON_ENABLE
    /* BCOM Compiltaion Fix */
    oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
        &p_son_inter_freq_carr_params->oam_son_anr_meas_config_req;

    /* BCOM Compiltaion Fix */

    p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
        utran_fdd_list_size = count;
#endif

    /* SPR 17730 Fix End */
    /* SPR 23504/SES-341 Fix Start */
    rrm_oam_cell_plmn_info_t p_rrm_oam_plmn;
    /* SPR 23504/SES-341 Fix End */



    OAM_FUN_ENTRY_TRACE();

    /*SPR_18663 Fix Start*/
    /* Code removed */
    /*SPR_18663 Fix End*/

    /*Only Primary Plmn should be copied here*/
    /* SPR 15917 START */
    /* Find Primary PLMNID to fill global ECGI */
    oam_find_primary_plmnid(&temp,p_cell_spec_params);

    if(OAM_NULL == temp)
    {
        OAM_LOG(OAM,OAM_WARNING,"Failure in populating Primary PLMNID");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    /* SPR 15917 END */
    oam_convert_plmnid(temp_plmnid,temp);
    oam_fill_mcc_mnc_from_plmnid(temp_plmnid , &p_rrm_cellconfig->global_cell_info.
            eutran_global_cell_id.primary_plmn_id);


    /*for bug 316*/
    tag_value = oam_xmlNodeGetContent(p_cell_spec_params->Common_1,
            "CellIdentity");
    lclTemp_value = oam_atoi((Char8*)tag_value); 

    retVal = oam_encode_eutran_cellidentity_into_bit_stream(
            cell_identity,
            lclTemp_value);

    if(OAM_FAILURE == retVal) {
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    if(oam_is_duplicate_cell_identity(cell_identity)) {
        OAM_LOG(OAM, OAM_WARNING,
                "Two cells configured with same cell identity: %s",
                tag_value);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    else {
        OAM_LOG(OAM, OAM_INFO, "Reading CellIdentity: %s", tag_value);
        oam_memcpy(p_rrm_cellconfig->global_cell_info.
                eutran_global_cell_id.cell_identity,
                cell_identity, MAX_CELL_IDENTITY_OCTETS);
    }
    /* SPR 16407 START */
    temp = (Char8 *)oam_xmlNodeGetContent(
            p_cell_spec_params->CellRestriction,"CellBarred");
    lclTemp_value = oam_atoi(temp);
    /* SPR 16407 END */

    if (
            lclTemp_value >= MIN_CELL_BARRED 
            && 
            lclTemp_value <= MAX_CELL_BARRED
       )
    { 
        /* SPR 16407 START */
        oam_search_integer_to_interger((Char8*)temp, CELL_BARRED[OAM_ZERO], OAM_TWO);
        lclTemp_value = oam_atoi(temp);                 	
        /* coverity 35804 */
        /* SPR 16407 END */
        p_rrm_cellconfig->global_cell_info.
            cell_access_restriction_params.cell_barred=(rrm_oam_cell_barred_et)lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of CellBarred is %d and range is from %d to %d",
                lclTemp_value,MIN_CELL_BARRED,MAX_CELL_BARRED);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->CellRestriction,"BarringForEmergency"));
    if 
        (
         lclTemp_value >= MIN_BARRING_FOR_EMERGENCY 
         && 
         lclTemp_value <= MAX_BARRING_FOR_EMERGENCY
        )
        { 	
            /* coverity 35803 */
            p_rrm_cellconfig->global_cell_info.
                cell_access_restriction_params.barring_for_emergency=(rrm_bool_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of BarringForEmergency is %d and range is from %d to %d",
                lclTemp_value,MIN_BARRING_FOR_EMERGENCY,MAX_BARRING_FOR_EMERGENCY);

        return OAM_FAILURE;
    }

    /* SPR 12920 Fix Start */
    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->CellRestriction,"X_VENDOR_INTRA_FREQ_CELL_RESELECTION_INDICATOR"),
            CellRestrictionIntraFreqReselection,RRM_OAM_INTRA_FREQ_RESELECTION_COUNT);
    /* SPR 12920 Fix End */
    /* coverity 35806 */
    p_rrm_cellconfig->global_cell_info.
        cell_access_restriction_params.intra_freq_reselection=(rrm_oam_intra_freq_reselection_et)lclTemp_value; 

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PDSCH,"Pb"));
    if 
        (
         lclTemp_value >= MIN_PDSCH_PB 
         && 
         lclTemp_value <= MAX_PDSCH_PB
        )
        {  
            /* coverity 35821 */
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_pdsch.p_b=(rrm_oam_pdsch_config_common_pb_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of Pb is %d and range is from %d to %d",
                lclTemp_value,MIN_PDSCH_PB,MAX_PDSCH_PB);

        return OAM_FAILURE;
    }
    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PDSCH,"Pa"),RAN_PHY_PDSCH_PA[OAM_ZERO],PDSCH_PA_COUNT);
    if 
        (
         lclTemp_value >= MIN_PDSCH_PA 
         && 
         lclTemp_value <= MAX_PDSCH_PA
        )
        {  
            /* coverity 35820 */
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_pdsch.p_a=(rrm_oam_pdsch_config_dedicated_p_a_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of Pa is %d and range is from %d to %d",
                lclTemp_value,MIN_PDSCH_PA,MAX_PDSCH_PA);

        return OAM_FAILURE;
    } 



    /*Bug Fix */
    p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.bitmask |= RRM_OAM_ADDITIONAL_PHYSICAL_LAYER_PARAM_PRESENT;

    SInt8 Enable64QAM = OAM_ZERO;
    Enable64QAM = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PUSCH,"Enable64QAM"),OAM_INVALID_STR);
    if(Enable64QAM != OAM_ZERO)
    {
        p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.bitmask |=RRM_OAM_ADDITIONAL_PUSCH_PARAMS_PRESENT;
        p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.additional_pusch_parameters.bitmask |=RRM_OAM_PUSCH_ENABLE_64_QAM_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PUSCH,"Enable64QAM"));
        p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.additional_pusch_parameters.pusch_enable_64_qam =lclTemp_value;

    }


    p_rrm_cellconfig->ran_info.physical_layer_params.bitmask |=RRM_OAM_ADDITIONAL_PHYSICAL_LAYER_PARAM_PRESENT;
    p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.bitmask |=RRM_OAM_ADDITIONAL_PUCCH_PARAMS_PRESENT;

    if (OAM_INVALID_VALUE != (lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PUCCH,"NCSAN"))))
    {
        p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.addl_pucch_parameters.n1_cs =lclTemp_value;
        p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.addl_pucch_parameters.bitmask |=RRM_OAM_N1_CS_PRESENT;
    }

    SInt8 SRSEnabled = OAM_ZERO,
          SRSBandwidthConfig = OAM_ZERO,
          srs_subframe_config = OAM_ZERO,
          /* SPR 20653 Fix Start */
          AckNackSRSSimultaneousTransmission = OAM_ZERO,
          SRSHoppingEnabled = OAM_ZERO,
          SRSDuration = OAM_ZERO,
          SRSPeriodicity = OAM_ZERO;
    /* SPR 20653 Fix End */

    SRSEnabled = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRS,"SRSEnabled"),OAM_INVALID_STR);
    SRSBandwidthConfig = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRS,"SRSBandwidthConfig"),OAM_INVALID_STR);
    srs_subframe_config = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRS,"X_VENDOR_SRS_SUBFRAME_CONFIG"),OAM_INVALID_STR);
    AckNackSRSSimultaneousTransmission = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRS,"AckNackSRSSimultaneousTransmission"),OAM_INVALID_STR);
    /* SPR 20653 Fix Start */
    SRSHoppingEnabled = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRS,"X_VENDOR_SRS_HOPPING_ENABLED"),OAM_INVALID_STR);
    SRSDuration = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRS,"X_VENDOR_SRS_DURATION"),OAM_INVALID_STR);
    SRSPeriodicity = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRS,"X_VENDOR_SRS_PERIODICITY"),OAM_INVALID_STR);
    /* SPR 20653 Fix End */

    if((SRSEnabled != OAM_ZERO)
            && (SRSBandwidthConfig != OAM_ZERO)
            && (srs_subframe_config != OAM_ZERO) 
            && (AckNackSRSSimultaneousTransmission != OAM_ZERO)
            /* SPR 20653 Fix Start */
            && (SRSHoppingEnabled != OAM_ZERO)
            && (SRSDuration != OAM_ZERO)
            && (SRSPeriodicity != OAM_ZERO)
            /* SPR 20653 Fix End */
      )
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRS,"SRSEnabled"));
        if 
            (
             lclTemp_value >= MIN_SRSENABLED 
             && 
             lclTemp_value <= MAX_SRSENABLED
            )
            {	

                if(lclTemp_value == 1)
                    p_rrm_cellconfig->ran_info.
                        physical_layer_params.bitmask |= RRM_OAM_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT;

                /* coverity 35822 */
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_srs.srsEnabled=(rrm_oam_srs_enabled_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of SRSEnabled is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRSENABLED,MAX_SRSENABLED);

            return OAM_FAILURE;
        } 

        lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRS,"SRSBandwidthConfig"),srsBandwidthConfig,SRS_BANDWIDTH_CONFIG_COUNT);

        if 
            (
             lclTemp_value >= MIN_SRSBANDWIDTHCONFIG 
             && 
             lclTemp_value <= MAX_SRSBANDWIDTHCONFIG
            )
            {
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_srs.srs_bandwidth_config
                    =(rrm_oam_srs_bw_config_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of SRSBandwidthConfig is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRSBANDWIDTHCONFIG,MAX_SRSBANDWIDTHCONFIG);

            return OAM_FAILURE;
        } 

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRS, "X_VENDOR_SRS_SUBFRAME_CONFIG"));
        if 
            (
             lclTemp_value >= MIN_SRS_SUBFRAME_CONFIG 
             && 
             lclTemp_value <= MAX_SRS_SUBFRAME_CONFIG
            )
            {
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_srs.srs_subframe_config
                    =(rrm_oam_srs_subframe_config_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of srs_subframe_config is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRS_SUBFRAME_CONFIG,MAX_SRS_SUBFRAME_CONFIG);

            return OAM_FAILURE;
        }

        /* CSR00053377_CHANGES_START */
        if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
                        /* spr_21013_fix_start */
                        xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"TDDMode",oam_strlen("TDDMode")+1))
            /* spr_21013_fix_end */
        {   
            /*SPR 14600 START*/
            if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRS,
                                "SRSMaxUpPTS"),OAM_INVALID_STR) != OAM_ZERO))
            {
                /*SPR 14600 END*/

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->SRS,"SRSMaxUpPTS"));

                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_srs.srs_max_up_pts
                    =(rrm_oam_srs_max_up_pts_et)lclTemp_value;
                p_rrm_cellconfig->ran_info.physical_layer_params.physical_layer_param_srs.bitmask |= RRM_OAM_SRS_MAX_UP_PTS_PRESENT;    
                /*SPR 14600 START*/
            }    
            else
            {
                OAM_LOG(OAM, OAM_INFO, "SRSMaxUpPTS is not provided"
                        " in eNodeB_Data_Model_TR_196_based.xml");
            }
            /*SPR 14600 END*/

        }    
        /* CSR00053377_CHANGES_END */

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRS,"AckNackSRSSimultaneousTransmission"));
        if 
            (
             lclTemp_value >= MIN_ACKNACKSRSSIMULTANEOUSTRANSMISSION 
             && 
             lclTemp_value <= MAX_ACKNACKSRSSIMULTANEOUSTRANSMISSION
            )
            {	
                /* coverity 35798 */
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_srs.
                    ack_nack_srs_simultaneous_transmission=(rrm_bool_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of AckNackSRSSimultaneousTransmission is %d and range is from %d to %d",
                    lclTemp_value,MIN_ACKNACKSRSSIMULTANEOUSTRANSMISSION,
                    MAX_ACKNACKSRSSIMULTANEOUSTRANSMISSION);

            return OAM_FAILURE;
        } 
        /* SPR 20653 Fix Start */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRS,"X_VENDOR_SRS_HOPPING_ENABLED"));
        if 
            (
             lclTemp_value >= MIN_SRSHOPPINGENABLED 
             && 
             lclTemp_value <= MAX_SRSHOPPINGENABLED
            )
            {	
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_srs.srs_hopping_enable
                    =(rrm_bool_t)lclTemp_value;
                p_rrm_cellconfig->ran_info.physical_layer_params.physical_layer_param_srs.bitmask |= RRM_OAM_SRS_HOPPING_ENABLE_PRESENT;    
            }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,
					"Value of SRSHoppingEnabled is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRSHOPPINGENABLED,
                    MAX_SRSHOPPINGENABLED);

            return OAM_FAILURE;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRS,"X_VENDOR_SRS_DURATION"));
        if 
            (
             lclTemp_value >= MIN_SRSDURATION 
             && 
             lclTemp_value <= MAX_SRSDURATION
            )
            {	
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_srs.srs_duration
                    =lclTemp_value;
                p_rrm_cellconfig->ran_info.physical_layer_params.physical_layer_param_srs.bitmask |= RRM_OAM_SRS_DURATION_PRESENT;    
            }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,
					"Value of SRSDuration is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRSDURATION,
                    MAX_SRSDURATION);

            return OAM_FAILURE;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRS,"X_VENDOR_SRS_PERIODICITY"));
        if 
            (
             lclTemp_value >= MIN_SRSPERIODICITY
             && 
             lclTemp_value <= MAX_SRSPERIODICITY
            )
            {	
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_srs.srs_periodicity
                    =lclTemp_value;
                p_rrm_cellconfig->ran_info.physical_layer_params.physical_layer_param_srs.bitmask |= RRM_OAM_SRS_PERIODICITY_PRESENT;    
            }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,
					"Value of SRSPeriodicity is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRSPERIODICITY,
                    MAX_SRSPERIODICITY);

            return OAM_FAILURE;
        }
        /* SPR 20653 Fix End */ 
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"RootSequenceIndex"));
    if 
        (
         lclTemp_value >= MIN_ROOTSEQUENCEINDEX 
         && 
         lclTemp_value <= MAX_ROOTSEQUENCEINDEX
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prach.
                root_sequence_index=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of RootSequenceIndex is %d and range is from %d to %d",
                lclTemp_value,MIN_ROOTSEQUENCEINDEX,MAX_ROOTSEQUENCEINDEX);

        return OAM_FAILURE;
    } 

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"ConfigurationIndex"));
    if 
        (
         lclTemp_value >= MIN_CONFIGURATIONINDEX
         && 
         lclTemp_value <= MAX_CONFIGURATIONINDEX
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prach.
                configuration_index=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ConfigurationIndex is %d and range is from %d to %d",
                lclTemp_value,MIN_CONFIGURATIONINDEX,MAX_CONFIGURATIONINDEX);

        return OAM_FAILURE;
    } 

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"HighSpeedFlag"));
    if 
        (
         lclTemp_value >= MIN_HIGHSPEEDFLAG 
         && 
         lclTemp_value <= MAX_HIGHSPEEDFLAG
        )
        {	
            p_rrm_cellconfig->
                ran_info.physical_layer_params.physical_layer_param_prach.
                high_speed_flag=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of HighSpeedFlag is %d and range is from %d to %d",
                lclTemp_value,MIN_HIGHSPEEDFLAG,MAX_HIGHSPEEDFLAG);

        return OAM_FAILURE;
    } 

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"ZeroCorrelationZoneConfig"));
    if 
        (
         lclTemp_value >= MIN_ZEROCORRELATIONZONECONFIG 
         && 
         lclTemp_value <= MAX_ZEROCORRELATIONZONECONFIG
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prach.
                zero_correlation_zone_config=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ZeroCorrelationZoneConfig is %d and range is from %d to %d",
                lclTemp_value,MIN_ZEROCORRELATIONZONECONFIG
                ,MAX_ZEROCORRELATIONZONECONFIG);

        return OAM_FAILURE;
    } 

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"FreqOffset"));
    if 
        (
         lclTemp_value >= MIN_FREQOFFSET 
         && 
         lclTemp_value <= MAX_FREQOFFSET
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prach.
                frequency_offset=lclTemp_value;  
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of FreqOffset is %d and range is from %d to %d",
                lclTemp_value,MIN_FREQOFFSET,MAX_FREQOFFSET);

        return OAM_FAILURE;
    }  


    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUCCH,"DeltaPUCCHShift"),DeltaPUCCHShift,DELTA_PUCCH_SHIFT_COUNT);


    if 
        (
         lclTemp_value >= MIN_DELTAPUCCHSHIFT 
         && 
         lclTemp_value <= MAX_DELTAPUCCHSHIFT
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_pucch.
                delta_pucch_shift=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of DeltaPUCCHShift is %d and range is from %d to %d",
                lclTemp_value,MIN_DELTAPUCCHSHIFT,MAX_DELTAPUCCHSHIFT);

        return OAM_FAILURE;
    }  

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUCCH,"NRBCQI"));
    if 
        (
         lclTemp_value >= MIN_NRBCQI
         && 
         lclTemp_value <= MAX_NRBCQI
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.
                physical_layer_param_pucch.n_rb_cqi=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of NRBCQI is %d and range is from %d to %d",
                lclTemp_value,MIN_NRBCQI,MAX_NRBCQI);

        return OAM_FAILURE;
    }  

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUCCH,"N1PUCCHAN"));
    if 
        (
         lclTemp_value >= MIN_N1PUCCHAN 
         && 
         lclTemp_value <= MAX_N1PUCCHAN
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_pucch.
                n1_pucch_an=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of N1PUCCHAN is %d and range is from %d to %d",
                lclTemp_value,MIN_N1PUCCHAN,MAX_N1PUCCHAN);

        return OAM_FAILURE;
    }  

    /* SPR 22311 Changes - Starts */
    /* Code Deleted */
    /* SPR 22311 Changes - Ends */

    /* SPR 9188 Fix Start*/ 
    if(OAM_INVALID_VALUE != (lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        xml_struct_g.L1_Power_Control_param,"PUCCH_CQI_SINR_VAL"))))
    {
        p_rrm_cellconfig->ran_info.
            physical_layer_params.physical_layer_param_pucch.
            pucch_cqi_sinr_value=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            physical_layer_params.physical_layer_param_pucch.
            bitmask |= RRM_OAM_PUCCH_CQI_SINR_VAL_PRESENT; 
    }
    /* SPR 9188 Fix End*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUSCH,"NSB"));
    if 
        (
         lclTemp_value >= MIN_NSB 
         && 
         lclTemp_value <= MAX_NSB
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_pusch.n_sb
                =lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of NSB is %d and range is from %d to %d",
                lclTemp_value,MIN_NSB,MAX_NSB);

        return OAM_FAILURE;
    }  


    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(p_cell_spec_params->PUSCH,
                "HoppingMode"),hoppingMode,HOPPING_MODE_COUNT);


    if 
        (
         lclTemp_value >= MIN_HOPPINGMODE 
         && 
         lclTemp_value <= MAX_HOPPINGMODE
        )
        {	
            /* coverity 35826 */
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_pusch.
                pusch_hopping_mode=(rrm_oam_hopping_mode_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of HoppingMode is %d and range is from %d to %d",
                lclTemp_value,MIN_HOPPINGMODE,MAX_HOPPINGMODE);

        return OAM_FAILURE;
    }  

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUSCH,"HoppingOffset"));
    if(lclTemp_value >= MIN_HOPPINGOFFSET && 
            lclTemp_value <= MAX_HOPPINGOFFSET) {
        p_rrm_cellconfig->ran_info.
            physical_layer_params.physical_layer_param_pusch.
            hopping_offset=lclTemp_value;
    }
    else {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of HoppingOffset is %d and range is from %d to %d",
                lclTemp_value,MIN_HOPPINGOFFSET,MAX_HOPPINGOFFSET);

        return OAM_FAILURE;
    }  	
    /* SPR 20653 Fix Start */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUSCH,"X_VENDOR_BETA_OFFSET_ACK_INDEX"));

    if(lclTemp_value >= MIN_BETAOFFSETACKINDEX && 
            lclTemp_value <= MAX_BETAOFFSETACKINDEX) {

        p_rrm_cellconfig->ran_info.
            physical_layer_params.physical_layer_param_pusch.
            beta_offset_ack_index=lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of BetaOffsetAckIndex is %d and range is from %d to %d",
                lclTemp_value,MIN_BETAOFFSETACKINDEX,MAX_BETAOFFSETACKINDEX);

        return OAM_FAILURE;
    }  	
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUSCH,"X_VENDOR_BETA_OFFSET_RI_INDEX"));

    if(lclTemp_value >= MIN_BETAOFFSETRIINDEX && 
            lclTemp_value <= MAX_BETAOFFSETRIINDEX) {

        p_rrm_cellconfig->ran_info.
            physical_layer_params.physical_layer_param_pusch.
            beta_offset_ri_index=lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of BetaOffsetRIIndex is %d and range is from %d to %d",
                lclTemp_value,MIN_BETAOFFSETRIINDEX,MAX_BETAOFFSETRIINDEX);

        return OAM_FAILURE;
    }  	
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUSCH,"X_VENDOR_BETA_OFFSET_CQI_INDEX"));

    if(lclTemp_value >= MIN_BETAOFFSETCQIINDEX && 
            lclTemp_value <= MAX_BETAOFFSETCQIINDEX) {

        p_rrm_cellconfig->ran_info.
            physical_layer_params.physical_layer_param_pusch.
            beta_offset_cqi_index=lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of BetaOffsetCQIIndex is %d and range is from %d to %d",
                lclTemp_value,MIN_BETAOFFSETCQIINDEX,MAX_BETAOFFSETCQIINDEX);

        return OAM_FAILURE;
    }  	
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUSCH,"X_VENDOR_PUSCH_BLER_THRESHOLD"));

    if(lclTemp_value >= MIN_PUSCHBLERTHRESHOLD && 
            lclTemp_value <= MAX_PUSCHBLERTHRESHOLD) {

        p_rrm_cellconfig->ran_info.
            physical_layer_params.physical_layer_param_pusch.
            pusch_bler_threshold=lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of PUSCHBlerThreshold is %d and range is from %d to %d",
                lclTemp_value,MIN_PUSCHBLERTHRESHOLD,MAX_PUSCHBLERTHRESHOLD);

        return OAM_FAILURE;
    }  	
    /* SPR 20653 Fix End */

    /*SPR 14600 START*/
    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->ULRS,
                        "GroupHoppingEnabled"),OAM_INVALID_STR) != OAM_ZERO))
    {
        /*SPR 14600 END*/

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->ULRS,"GroupHoppingEnabled"));
        if 
            (
             lclTemp_value >= MIN_GROUPHOPPINGENABLED 
             && 
             lclTemp_value <= MAX_GROUPHOPPINGENABLED
            )
            {	
                /* coverity 35809 */
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_ul_reference_signal.
                    group_hopping_enabled=(rrm_bool_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of GroupHoppingEnabled is %d and range is from %d to %d",
                    lclTemp_value,MIN_GROUPHOPPINGENABLED,MAX_GROUPHOPPINGENABLED);

            return OAM_FAILURE;
        }  	
        /*SPR 14600 START*/
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO, "GroupHoppingEnabled is not provided in eNodeB_Data_Model_TR_196_based.xml");
    }
    /*SPR 14600 END*/


    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULRS,"GroupAssignmentPUSCH"));
    if
        (

         lclTemp_value >= MIN_GROUPASSIGNMENTPUSCH
         &&
         lclTemp_value <= MAX_GROUPASSIGNMENTPUSCH
        )
        {
            /* SPR 20653 Fix Start */
            p_rrm_cellconfig->ran_info.physical_layer_params.bitmask |= RRM_OAM_ADDITIONAL_PHYSICAL_LAYER_PARAM_PRESENT;
            p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.bitmask |= RRM_OAM_ADDITIONAL_UL_REF_SIGNAL_PARAMS_PRESENT;
            /* SPR 20653 Fix End */
            p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.addtl_ul_reference_signal_params.group_assignment_pusch=lclTemp_value;

            p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.addtl_ul_reference_signal_params.bitmask |= RRM_OAM_GROUP_ASSIGMENT_PUSCH_PRESENT;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of GroupAssignmentPUSCH is %d and range is from %d to %d",
                lclTemp_value,MIN_GROUPASSIGNMENTPUSCH,MAX_GROUPASSIGNMENTPUSCH);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULRS,"CyclicShift"));
    if
        (
         lclTemp_value >= MIN_CYCLICSHIFT
         &&
         lclTemp_value <= MAX_CYCLICSHIFT
        )
        {
            p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.addtl_ul_reference_signal_params.ul_reference_signal_pusch_cyclicshift=lclTemp_value;

            p_rrm_cellconfig->ran_info.physical_layer_params.addl_physical_layer_params.addtl_ul_reference_signal_params.bitmask |= RRM_OAM_UL_REFER_SIGNAL_PUSCH_CYCLIC_SHIFT_PRESENT ;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of CyclicShift is %d and range is from %d to %d",
                lclTemp_value,MIN_CYCLICSHIFT,MAX_CYCLICSHIFT);

        return OAM_FAILURE;
    }

    /*SPR 14600 START*/
    if((oam_strcmp((const char *)oam_xmlNodeGetContent( p_cell_spec_params->ULRS,
                        "SequenceHoppingEnabled"),OAM_INVALID_STR) != OAM_ZERO))
    {
        /*SPR 14600 END*/

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->ULRS,"SequenceHoppingEnabled"));
        if 
            (
             lclTemp_value >= MIN_SEQUENCEHOPPINGENABLED 
             && 
             lclTemp_value <= MAX_SEQUENCEHOPPINGENABLED
            )
            {	
                /* coverity 35830 */
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_ul_reference_signal.
                    sequence_hopping_enabled=(rrm_bool_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of SequenceHoppingEnabled is %d and range is from %d to %d",
                    lclTemp_value,MIN_SEQUENCEHOPPINGENABLED,MAX_SEQUENCEHOPPINGENABLED);

            return OAM_FAILURE;
        }  	  
        /*SPR 14600 START*/
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO, "SequenceHoppingEnabled is not provided in eNodeB_Data_Model_TR_196_based.xml");
    }
    /*SPR 14600 END*/


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"P0NominalPUSCH"));
    if 
        (
         lclTemp_value >= MIN_P0NOMINALPUSCH 
         && 
         lclTemp_value <= MAX_P0NOMINALPUSCH
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_ul_power_control.
                p_0_nominal_pusch=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of P0NominalPUSCH is %d and range is from %d to %d",
                lclTemp_value,MIN_P0NOMINALPUSCH,MAX_P0NOMINALPUSCH);

        return OAM_FAILURE;
    } 	




    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"Alpha"),RAN_PHY_ULPowerControl_Alpha[OAM_ZERO],ALPHA_COUNT);
    if 
        (
         lclTemp_value >= MIN_ALPHA 
         && 
         lclTemp_value <= MAX_ALPHA
        )
        {	
            /* coverity 35802 */
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_ul_power_control.
                alpha=(rrm_oam_alpha_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of Alpha is %d and range is from %d to %d",
                lclTemp_value,MIN_ALPHA,MAX_ALPHA);

        return OAM_FAILURE;
    } 	
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"P0NominalPUCCH"));

    if 
        (
         lclTemp_value >= MIN_P0NOMINALPUCCH 
         && 
         lclTemp_value <= MAX_P0NOMINALPUCCH
        )
        {	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_ul_power_control.
                p_0_nominal_pucch=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of P0NominalPUCCH is %d and range is from %d to %d",
                lclTemp_value,MIN_P0NOMINALPUCCH,MAX_P0NOMINALPUCCH);

        return OAM_FAILURE;
    } 

    /* XML tdd change START */
    /* spr_21013_fix_start */
    tag_value = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,
            /* spr_21013_fix_end */
            "DuplexMode");
    if(!oam_strcmp((Char8*)tag_value, "TDDMode")) {
        oam_populate_tdd_frame(p_cell_spec_params, p_rrm_cellconfig);
    }
    else
    {
        oam_prov_req.prb_usage_factor.num_dl_schedulable = OAM_TEN;
        oam_prov_req.prb_usage_factor.num_ul_schedulable = OAM_TEN;
    }
    /* XML tdd change END*/


    p_rrm_cellconfig->operator_info.rrm_power_control_params.bitmask |= RRM_OAM_POWER_CONTROL_ENABLE_PRESENT ;  
    p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_POWER_CONTROL_INFO_PRESENT ;


    lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"DeltaFPUCCHFormat1"),delta_f_pucch_format_1[0],OAM_THREE);



    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.
        delta_f_pucch_format_1=lclTemp_value;

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_1_PRESENT ;

    lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"DeltaFPUCCHFormat1b"),delta_f_pucch_format_1b[0],OAM_THREE);

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.
        delta_f_pucch_format_1b=lclTemp_value;

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_1B_PRESENT ;

    lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"DeltaFPUCCHFormat2"),delta_f_pucch_format_2[0],4);


    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.
        delta_f_pucch_format_2=lclTemp_value;

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_2_PRESENT ;

    lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"DeltaFPUCCHFormat2a"),delta_f_pucch_format_2a[0],OAM_THREE);


    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.
        delta_f_pucch_format_2a=lclTemp_value;

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_2A_PRESENT ;

    lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"DeltaFPUCCHFormat2b"),delta_f_pucch_format_2b[0],OAM_THREE);

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.
        delta_f_pucch_format_2b=lclTemp_value;

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_2B_PRESENT ;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->ULPowerControl,"DeltaPreambleMsg3"));

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.
        delta_preamble_msg_3=lclTemp_value;

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_power_control_enable.bitmask |= RRM_OAM_DELTA_PREAMBLE_MSG_PRESENT ;

    /*SPR FIX 11374 START*/ // Fix shall be taken after Stage 3 code merge
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->ULPowerControl,"X_VENDOR_DELTAF_PUCCH_FORMAT1BCS_R10"),OAM_INVALID_STR)!=0)) 
    {
        lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->ULPowerControl,"X_VENDOR_DELTAF_PUCCH_FORMAT1BCS_R10"),delta_f_pucch_format_1b_cs_r10[0],OAM_TWO);

        p_rrm_cellconfig->operator_info.
            rrm_power_control_params.rrm_power_control_enable.
            delta_f_pucch_format_1b_cs_r10=lclTemp_value;

        p_rrm_cellconfig->operator_info.
            rrm_power_control_params.rrm_power_control_enable.bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_1B_CS_R10_PRESENT ;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->ULPowerControl,"X_VENDOR_DELTAF_PUCCH_FORMAT3_R10"),OAM_INVALID_STR)!=0))
    {
        lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->ULPowerControl,"X_VENDOR_DELTAF_PUCCH_FORMAT3_R10"),delta_f_pucch_format_3_r10[0],OAM_EIGHT);

        p_rrm_cellconfig->operator_info.
            rrm_power_control_params.rrm_power_control_enable.
            delta_f_pucch_format_3_r10=lclTemp_value;

        p_rrm_cellconfig->operator_info.
            rrm_power_control_params.rrm_power_control_enable.bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_3_R10_PRESENT ;
    }
    /*SPR FIX 11374 END*/

    SInt8 NumPRSResourceBlocks = OAM_ZERO,
          PRSConfigurationIndex = OAM_ZERO,
          NumConsecutivePRSSubframes = OAM_ZERO;

    NumPRSResourceBlocks = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"NumPRSResourceBlocks"),OAM_INVALID_STR);
    PRSConfigurationIndex =  oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"PRSConfigurationIndex"),OAM_INVALID_STR);
    NumConsecutivePRSSubframes =  oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"NumConsecutivePRSSubframes"),OAM_INVALID_STR);

    if((NumPRSResourceBlocks != OAM_ZERO)
            && (PRSConfigurationIndex != OAM_ZERO)
            && (NumConsecutivePRSSubframes != OAM_ZERO)
      )
    {
        p_rrm_cellconfig->ran_info.physical_layer_params.bitmask |= RRM_OAM_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT;


        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"NumPRSResourceBlocks"));
        if 
            (
             lclTemp_value >= MIN_NUMPRSRESOURCEBLOCKS 
             && 
             lclTemp_value <= MAX_NUMPRSRESOURCEBLOCKS
            )
            {	
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_prs.
                    num_prs_resource_blocks=lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of NumPRSResourceBlocks is %d and range is from %d to %d",
                    lclTemp_value,MIN_NUMPRSRESOURCEBLOCKS,MAX_NUMPRSRESOURCEBLOCKS);

            return OAM_FAILURE;
        }


        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"PRSConfigurationIndex"));
        if
            (
             lclTemp_value >= MIN_PRS_CONF_INDEX 
             &&
             lclTemp_value <= MAX_PRS_CONF_INDEX 
            )
            {
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_prs.
                    prs_configuration_index=lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of PRSConfigurationIndex is %d and range is from %d to %d",
                    lclTemp_value,MIN_PRS_CONF_INDEX,MAX_PRS_CONF_INDEX);

            return OAM_FAILURE;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->MAC,"X_VENDOR_UL_SYNC_LOSS_TIMER"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->MAC,"X_VENDOR_UL_SYNC_LOSS_TIMER"));
            p_rrm_cellconfig->ran_info.
                mac_layer_params.ul_sync_loss_timer=lclTemp_value;
            p_rrm_cellconfig->ran_info.
                mac_layer_params.bitmask |= RRM_OAM_UL_SYNC_LOSS_TIMER_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->MAC,"X_VENDOR_N_GAP"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->MAC,"X_VENDOR_N_GAP"));
            p_rrm_cellconfig->ran_info.
                mac_layer_params.n_gap=lclTemp_value;
            p_rrm_cellconfig->ran_info.
                mac_layer_params.bitmask |= RRM_OAM_N_GAP_PRESENT;
        }

        /* SPR 11500 START */
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->MAC,"X_VENDOR_IS_DYNAMIC_PDCCH_ENABLED"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->MAC,"X_VENDOR_IS_DYNAMIC_PDCCH_ENABLED"));
            p_rrm_cellconfig->ran_info.
                mac_layer_params.dynamic_pdcch = (rrm_bool_et)lclTemp_value;
        }
        /* SPR 11500 END */
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(xml_struct_g.MACParams,"dci_format_for_si_msg"),OAM_INVALID_STR)!=0))
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        xml_struct_g.MACParams,"dci_format_for_si_msg"));

            /* coverity 56675 */
            p_rrm_cellconfig->ran_info.
                mac_layer_params.dci_format_for_si_msg = (rrm_oam_dci_format_for_si_msgs_et)lclTemp_value;

            p_rrm_cellconfig->ran_info.
                mac_layer_params.bitmask |= RRM_OAM_DCI_FORMAT_FOR_SI_MSG_PRESENT ;
        }

        /* + SPR 17665 +*/
        if(p_rrm_cellconfig->ran_info.mac_layer_params.bitmask & RRM_OAM_DCI_FORMAT_FOR_SI_MSG_PRESENT)
        {

            switch(p_rrm_cellconfig->ran_info.mac_layer_params.dci_format_for_si_msg)
            {

                case RRM_OAM_RBS_PER_TBS_DCI_1A:
                {

                    if((oam_strcmp
                                ((const char *)oam_xmlNodeGetContent(xml_struct_g.MACParams,"num_rbs_per_tbs_dci_1a"),OAM_INVALID_STR)!=0))
                    {

                        oam_memset(si_rb_list, 0, sizeof(si_rb_list));
                        strncpy((Char8*)si_rb_list, (const Char8*)oam_xmlNodeGetContent(xml_struct_g.MACParams, "num_rbs_per_tbs_dci_1a"),
                                sizeof(si_rb_list)-1);

                        if (RBS_FOR_DCI_1A_SIZE != oam_tokenize_string_to_u8(si_rb_list, ",", RBS_FOR_DCI_1A_SIZE,
                                    p_rrm_cellconfig->ran_info.
                                    mac_layer_params.num_rbs_per_tbs_dci_1a) )
                        {
                            OAM_LOG(OAM, OAM_ERROR, "num_rbs_per_tbs_dci_1a: expected %d comma seperated values ", 
                                    p_rrm_cellconfig->ran_info.mac_layer_params.num_rbs_per_tbs_dci_1a);
                            return OAM_FAILURE;
                        }

                        p_rrm_cellconfig->ran_info.
                            mac_layer_params.bitmask |= RRM_OAM_NUM_OF_RB_DCI_FORMAT_1A_PRESENT ;
                    }
                    else                    
                    {

                        OAM_LOG(OAM, OAM_ERROR, "num_rbs_per_tbs_dci_1a Tag not found in xml file");
                        return OAM_FAILURE;


                    }    

                    break;
                }

                case RRM_OAM_RBS_PER_TBS_DCI_1C:
                {
                    if((oam_strcmp
                                ((const char *)oam_xmlNodeGetContent(xml_struct_g.MACParams,"num_rbs_per_tbs_dci_1c"),OAM_INVALID_STR)!=0))
                    {

                        oam_memset(si_rb_list, 0, sizeof(si_rb_list));
                        strncpy((Char8*)si_rb_list, (const Char8*)oam_xmlNodeGetContent(xml_struct_g.MACParams, "num_rbs_per_tbs_dci_1c"),
                                sizeof(si_rb_list)-1);

                        if (RBS_FOR_DCI_1C_SIZE != oam_tokenize_string_to_u8(si_rb_list, ",", RBS_FOR_DCI_1C_SIZE,
                                    p_rrm_cellconfig->ran_info.
                                    mac_layer_params.num_rbs_per_tbs_dci_1c) )
                        {
                            OAM_LOG(OAM, OAM_ERROR, "num_rbs_per_tbs_dci_1c: expected %d comma seperated values ",
                                    p_rrm_cellconfig->ran_info.mac_layer_params.num_rbs_per_tbs_dci_1c);
                            return OAM_FAILURE;
                        }


                        p_rrm_cellconfig->ran_info.
                            mac_layer_params.bitmask |= RRM_OAM_NUM_OF_RB_DCI_FORMAT_1C_PRESENT ;
                    }
                    else
                    {

                        OAM_LOG(OAM, OAM_ERROR, "num_rbs_per_tbs_dci_1c Tag not found in xml file");
                        return OAM_FAILURE;

                    }    
                    break;       
                }

            }

        }        

        /* - SPR 17665 - */
        
        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"NumConsecutivePRSSubframes"),RAN_PHY_PRS_NumConsecutivePRSSubfames[OAM_ZERO],NUMCONSECUTIVEPRSSUBFAMES_COUNT);
        if 
            (
             lclTemp_value >= MIN_NUMCONSECUTIVEPRSSUBFAMES
             && 
             lclTemp_value <= MAX_NUMCONSECUTIVEPRSSUBFAMES
            )
            {	
                /* coverity 35818 */
                p_rrm_cellconfig->ran_info.
                    physical_layer_params.physical_layer_param_prs.
                    num_consecutive_prs_subfames=(rrm_oam_num_consecutive_prs_sf_et)lclTemp_value; 
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of NumConsecutivePRSSubframes is %d and range is from %d to %d",
                    lclTemp_value,
                    MIN_NUMCONSECUTIVEPRSSUBFAMES,MAX_NUMCONSECUTIVEPRSSUBFAMES);

            return OAM_FAILURE;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"X_VENDOR_MUTING_CONFIG_TWO"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PRS,"X_VENDOR_MUTING_CONFIG_TWO"));

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_two = lclTemp_value;

            /* BITSTRING FIX START */
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_two <<= OAM_SIX;
            /* BITSTRING FIX END */

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_TWO_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"X_VENDOR_MUTING_CONFIG_FOUR"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PRS,"X_VENDOR_MUTING_CONFIG_FOUR"));

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_four = lclTemp_value;

            /* BITSTRING FIX START */
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_four <<= OAM_FOUR;
            /* BITSTRING FIX END */

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_FOUR_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"X_VENDOR_MUTING_CONFIG_EIGHT"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PRS,"X_VENDOR_MUTING_CONFIG_EIGHT"));

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_eight = lclTemp_value;

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_EIGHT_PRESENT;
        }


        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"X_VENDOR_MUTING_CONFIG_SIXTEEN"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PRS,"X_VENDOR_MUTING_CONFIG_SIXTEEN"));

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_sixteen = lclTemp_value;

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"X_VENDOR_PRS_ENABLE"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PRS,"X_VENDOR_PRS_ENABLE"));
            /* coverity 52792 */	
            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_enable = (rrm_bool_et)lclTemp_value;

        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"X_VENDOR_PRS_TRANSMISSION_POWER"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PRS,"X_VENDOR_PRS_TRANSMISSION_POWER"));

            p_rrm_cellconfig->ran_info.
                physical_layer_params.physical_layer_param_prs.prs_transmission_power = lclTemp_value;

        }

    }

    /* EUTRAN ACCESS POINT POS PARA */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->PRS,"X_VENDOR_LATITUDE_SIGN"),OAM_INVALID_STR)!=0))
    {
        p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_EUTRAN_ACCESS_POINT_POS_PRESENT; 

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_LATITUDE_SIGN"));
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.latitude_sign = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_DEG_OF_LATITUDE"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.deg_of_latitude = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_DEG_OF_LONGITUDE"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.deg_of_longitude = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_DIR_OF_ALTITUDE"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.dir_of_altitude = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_ALTITUDE"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.altitude= lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_UNCERTAINTY_SEMI_MAJOR"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.uncertainty_semi_major= lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_UNCERTAINTY_SEMI_MINOR"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.uncertainty_semi_minor= lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_ORIENTATION_OF_MAJOR_AXIS"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.orientation_of_major_axis= lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_UNCERTAINTY_ALTITUDE"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.uncertainty_altitude= lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PRS,"X_VENDOR_CONFIDENCE"));  
        p_rrm_cellconfig->operator_info.rrm_eutran_access_point_pos.confidence= lclTemp_value;
    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RACH,"NumberOfRaPreambles"),RAN_MAC_RACH_NumberOfRaPreambles[OAM_ZERO],NUMBEROFRAPREAMBLES_COUNT);
    if 
        (
         lclTemp_value >= MIN_NUMBEROFRAPREAMBLES
         && 
         lclTemp_value <= MAX_NUMBEROFRAPREAMBLES
        )
        {	
            /* coverity 35819 */
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_rach.preamble_info.
                number_of_ra_preambles=(rrm_oam_ra_preamble_count_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of NumberOfRaPreambles is %d and range is from %d to %d",
                lclTemp_value,MIN_NUMBEROFRAPREAMBLES,MAX_NUMBEROFRAPREAMBLES);

        return OAM_FAILURE;
    } 	

    SInt8 SizeOfRaGroupA = OAM_ZERO,
          MessageSizeGroupA = OAM_ZERO,
          MessagePowerOffsetGroupB = OAM_ZERO;

    SizeOfRaGroupA = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RACH,"SizeOfRaGroupA"),OAM_INVALID_STR);
    MessageSizeGroupA = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RACH,"MessageSizeGroupA"),OAM_INVALID_STR);
    MessagePowerOffsetGroupB = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RACH,"MessagePowerOffsetGroupB"),OAM_INVALID_STR);

    if((SizeOfRaGroupA != OAM_ZERO)
            && (MessageSizeGroupA != OAM_ZERO)
            && (MessagePowerOffsetGroupB != OAM_ZERO)
      )	

    {     
        p_rrm_cellconfig->ran_info.
            mac_layer_params.bitmask |= 
            RRM_OAM_MAC_LAYER_PARAM_RACH_PRESENT;

        p_rrm_cellconfig->ran_info.
            mac_layer_params.mac_layer_param_rach.preamble_info.
            bitmask |= RRM_OAM_RA_PREABLE_GROUPA_INFO_PRESENT;

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RACH,"SizeOfRaGroupA"),RAN_MAC_RACH_sizeOfRaGroupA[OAM_ZERO],SIZEOFRAGROUPA_COUNT );
        if 
            (
             lclTemp_value >= MIN_SIZEOFRAGROUPA
             && 
             lclTemp_value <= MAX_SIZEOFRAGROUPA
            )
            {	
                /* coverity 35829 */
                p_rrm_cellconfig->ran_info.
                    mac_layer_params.mac_layer_param_rach.preamble_info.
                    ra_preamble_groupA_info.size_of_ra_group_a=(rrm_oam_ra_preambles_group_a_size_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of SizeOfRaGroupA is %d and range is from %d to %d",
                    lclTemp_value,MIN_SIZEOFRAGROUPA,MAX_SIZEOFRAGROUPA);

            return OAM_FAILURE;
        } 	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RACH,"MessageSizeGroupA"),RAN_MAC_RACH_messageSizeGroupA[OAM_ZERO],MESSAGESIZEGROUPA_COUNT);
        if 
            (
             lclTemp_value >= MIN_MESSAGESIZEGROUPA
             && 
             lclTemp_value <= MAX_MESSAGESIZEGROUPA
            )
            {	
                /* coverity 35828 */
                p_rrm_cellconfig->ran_info.
                    mac_layer_params.mac_layer_param_rach.preamble_info.
                    ra_preamble_groupA_info.message_size_group_a=(rrm_oam_group_a_msg_size_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of MessageSizeGroupA is %d and range is from %d to %d",
                    lclTemp_value,MIN_MESSAGESIZEGROUPA,MAX_MESSAGESIZEGROUPA);

            return OAM_FAILURE;
        } 

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RACH,"MessagePowerOffsetGroupB"),RAN_MAC_RACH_messagePowerOffsetGroupB[OAM_ZERO],MESSAGEPOWEROFFSETGROUPB_COUNT);
        if 
            (
             lclTemp_value >= MIN_MESSAGEPOWEROFFSETGROUPB
             && 
             lclTemp_value <= MAX_MESSAGEPOWEROFFSETGROUPB
            )
            {	
                /* coverity 35827 */
                p_rrm_cellconfig->ran_info.
                    mac_layer_params.mac_layer_param_rach.preamble_info.
                    ra_preamble_groupA_info.message_power_offset_group_b=(rrm_oam_group_b_msg_power_offset_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of MessagePowerOffsetGroupB is %d and range is from %d to %d",
                    lclTemp_value,MIN_MESSAGEPOWEROFFSETGROUPB,MAX_MESSAGEPOWEROFFSETGROUPB);

            return OAM_FAILURE;
        } 			

    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(p_cell_spec_params->RACH,"PowerRampingStep"),RAN_MAC_RACH_powerRampingStep[OAM_ZERO],POWERRAMPINGSTEP_COUNT);
    if 
        (
         lclTemp_value >= MIN_POWERRAMPINGSTEP
         && 
         lclTemp_value <= MAX_POWERRAMPINGSTEP
        )
        {	
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_rach.power_ramping_step
                =(rrm_oam_power_ramping_step_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of PowerRampingStep is %d and range is from %d to %d",
                lclTemp_value,MIN_POWERRAMPINGSTEP,MAX_POWERRAMPINGSTEP);

        return OAM_FAILURE;
    } 

    lclTemp_value=oam_xml_search_integer_to_integer(((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RACH,"PreambleInitialReceivedTargetPower")),
            RAN_MAC_RACH_preambleInitialReceivedTargetPower[OAM_ZERO],PREAMBLEINITIALRECEIVEDTARGETPOWER_COUNT);
    if 
        (
         lclTemp_value >= MIN_PREAMBLEINITIALRECEIVEDTARGETPOWER
         && 
         lclTemp_value <= MAX_PREAMBLEINITIALRECEIVEDTARGETPOWER
        )
        {	
            /* coverity 35824 */
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_rach.
                preamble_initial_received_target_power=(rrm_oam_preamble_init_rec_target_pow_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of PreambleInitialReceivedTargetPower is %d and range is from %d to %d",
                lclTemp_value,MIN_PREAMBLEINITIALRECEIVEDTARGETPOWER,
                MAX_PREAMBLEINITIALRECEIVEDTARGETPOWER);

        return OAM_FAILURE;
    }

    /* SPR 15748 Fixed Start */
    tag_value = oam_xmlNodeGetContent(p_cell_spec_params->RACH,
            "SizeOfRaGroupA");
    /* spr17535 - start */
#ifdef OAM_SON_ENABLE
    if (oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_xml_search_integer_to_integer((Char8*)tag_value,
                RAN_MAC_RACH_sizeOfRaGroupA[OAM_ZERO],
                SIZEOFRAGROUPA_COUNT);

        /* coverity 52773 53543*/
        /* SPR 21702 Start */
        oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_index].serving_cell[OAM_ZERO].
            size_of_ra_group_a = (son_oam_ra_preambles_group_a_size_et)lclTemp_value;
        oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_index].serving_cell[OAM_ZERO].
            bitmask |= SON_CELL_SIZE_OF_RA_GROUP_A_PRESENT;
        /* SPR 21702 End */
    }
    /* SPR 15748 Fixed End */
#endif
    /* spr17535 - end */
    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RACH,"PreambleTransMax"),RAN_MAC_RACH_preambleTransMax[OAM_ZERO],PREAMBLETRANSMAX_COUNT);
    if 
        (
         lclTemp_value >= MIN_PREAMBLETRANSMAX
         && 
         lclTemp_value <= MAX_PREAMBLETRANSMAX
        )
        {	
            /* coverity 35825 */
            p_rrm_cellconfig->
                ran_info.mac_layer_params.mac_layer_param_rach.
                preamble_trans_max=(rrm_oam_preamble_trans_max_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of PreambleTransMax is %d and range is from %d to %d",
                lclTemp_value,MIN_PREAMBLETRANSMAX,MAX_PREAMBLETRANSMAX);

        return OAM_FAILURE;
    } 


    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RACH,"ResponseWindowSize"),RAN_MAC_RACH_ResponseWindowSize[OAM_ZERO],RESPONSEWINDOWSIZE_COUNT);
    if 
        (
         lclTemp_value >= MIN_RESPONSEWINDOWSIZE
         && 
         lclTemp_value <= MAX_RESPONSEWINDOWSIZE
        )
        {	
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_rach.response_window_size
                =(rrm_oam_ra_resp_win_size_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ResponseWindowSize is %d and range is from %d to %d",
                lclTemp_value,MIN_RESPONSEWINDOWSIZE,MAX_RESPONSEWINDOWSIZE);

        return OAM_FAILURE;
    } 

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RACH,"ContentionResolutionTimer"),RAN_MAC_RACH_ContentionResolutionTimer[OAM_ZERO],CONTENTIONRESOLUTIONTIMER_COUNT);

    if 
        (
         lclTemp_value >= MIN_CONTENTIONRESOLUTIONTIMER
         && 
         lclTemp_value <= MAX_CONTENTIONRESOLUTIONTIMER
        )
        {	
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_rach.contention_resolution_timer
                =(rrm_oam_mac_cont_resol_timer_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ContentionResolutionTimer is %d and range is from %d to %d",
                lclTemp_value,MIN_CONTENTIONRESOLUTIONTIMER,MAX_CONTENTIONRESOLUTIONTIMER);

        return OAM_FAILURE;
    } 

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RACH,"MaxHARQMsg3Tx"));
    if 
        (
         lclTemp_value >= MIN_MAXHARQMSG3TX
         && 
         lclTemp_value <= MAX_MAXHARQMSG3TX
        )
        {
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_rach.max_harq_msg_3tx
                =lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of MaxHARQMsg3Tx is %d and range is from %d to %d",
                lclTemp_value,MIN_MAXHARQMSG3TX,MAX_MAXHARQMSG3TX);

        return OAM_FAILURE;
    } 
    /* SPR 20653 Fix Start */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RACH,"ContentionFreeRachTimer"));
    if 
        (
         lclTemp_value >= MIN_CONTENTIONFREERACHTIMER
         && 
         lclTemp_value <= MAX_CONTENTIONFREERACHTIMER
        )
        {
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_rach.contention_free_rach_timer
                =lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ContentionFreeRachTimer is %d and range is from %d to %d",
                lclTemp_value,MIN_CONTENTIONFREERACHTIMER,MAX_CONTENTIONFREERACHTIMER);

        return OAM_FAILURE;
    } 
    /* SPR 20653 Fix End */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->DRX,"DRXEnabled"));
    if(lclTemp_value==OAM_ONE)
    {		
        /* coverity 35817 */
        p_rrm_cellconfig->ran_info.
            mac_layer_params.mac_layer_param_drx.drx_enabled=(rrm_bool_et)lclTemp_value;

        p_rrm_cellconfig->ran_info.
            mac_layer_params.bitmask |= RRM_OAM_MAC_LAYER_PARAM_DRX_PRESENT ;

    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,
                "Value of DRXEnabled is Disabled");
    } 

    /* SPR 21411 changes start */
    for(drx_count = OAM_ZERO;drx_count < MAX_NUM_VALID_DRX_PROFILES; drx_count++)
    {    
        #ifdef ENDC_ENABLED
        p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].long_drx_cycle_r15 = RRM_OAM_R15_INVALID;
        #endif
        p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].long_drx_cycle = RRM_OAM_INVALID;
        p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].short_drx_cycle.
            short_drx_cycle = RRM_OAM_SHORT_DRX_CYCLE_INVALID;
        p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
            drx_inactivity_timer = RRM_OAM_DRX_INACTIVITY_TIMER_INVALID;
        p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
            drx_retransmission_timer = RRM_OAM_DRX_RETRANS_TIMER_INVALID;
        p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
            on_duration_timer = RRM_OAM_ON_DURATION_TIMER_INVALID;
    }
    /* SPR 21411 changes end */

    if(OAM_ZERO == (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"X_VENDOR_DRX_COMMAND"), "TRUE")))
    {
        p_rrm_cellconfig->ran_info.
            mac_layer_params.mac_layer_param_drx.drx_mac_ce_command_enable= (rrm_bool_et)OAM_TRUE;
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"X_VENDOR_DRX_TIMER_PERCENTAGE"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->DRX,"X_VENDOR_DRX_TIMER_PERCENTAGE"));
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_drx.drx_mac_ce_timer_percentage=(UInt16)lclTemp_value;
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_drx.bitmask|=RRM_OAM_DRX_MAC_CE_TIMER_PERCENT_INFO_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"X_VENDOR_DRX_CMD_THRESHOLD"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->DRX,"X_VENDOR_DRX_CMD_THRESHOLD"));
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_drx.drx_mac_ce_cmd_threshold=(U16)lclTemp_value;
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_drx.bitmask|=RRM_OAM_DRX_MAC_CE_CMD_THRESHOLD_PRESENT;
        }
    }
    else
    {
        if(OAM_ZERO == (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"X_VENDOR_DRX_COMMAND"), "FALSE")))
        {
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_layer_param_drx.drx_mac_ce_command_enable=(rrm_bool_et)OAM_FALSE;
        }
    }
    /* SPR_9464_FIX End */

    /*CSR 00059124 FIX Start*/
    if(p_rrm_cellconfig->ran_info.mac_layer_params.
            bitmask & RRM_OAM_MAC_LAYER_PARAM_CDRX_PRESENT) {
        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->CDRX,
                "X_VENDOR_ONDURATION_TIMER");
        lclTemp_value = oam_xml_search_integer_to_integer((Char8*)tag_value,
                RAN_MAC_DRX_OnDurationTimer[OAM_ZERO],
                ONDURATIONTIMER_COUNT);
        if(lclTemp_value >= MIN_ON_DURATION_TIMER && 
                lclTemp_value <= MAX_ON_DURATION_TIMER) {   
            p_rrm_cellconfig->ran_info.mac_layer_params.rrm_oam_cdrx_config.
                on_duration_timer = (rrm_oam_on_duration_timer_et)lclTemp_value;
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of OnDurationTimer is %d and range is from %d to %d",
                    lclTemp_value, MIN_ON_DURATION_TIMER, MAX_ON_DURATION_TIMER);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->CDRX,
                "X_VENDOR_CDRX_INACTIVITY_TIMER");
        lclTemp_value = oam_xml_search_integer_to_integer((Char8*)tag_value,
                RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO],
                DRXINACTIVITYTIMER_COUNT);
        if(lclTemp_value >= MIN_DRX_INACTIVITY_TIMER && 
                lclTemp_value <= MAX_DRX_INACTIVITY_TIMER) {   
            /* coverity 35807 */
            p_rrm_cellconfig->ran_info.mac_layer_params.rrm_oam_cdrx_config.
                drx_inactivity_timer =
                (rrm_oam_drx_inactivity_timer_et)lclTemp_value;
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of DRXInactivityTimer is %d and range is "
                    "from %d to %d",
                    lclTemp_value,
                    MIN_DRX_INACTIVITY_TIMER,
                    MAX_DRX_INACTIVITY_TIMER);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }   

        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->CDRX,
                "X_VENDOR_CDRX_RETRANSMISSION_TIMER");
        lclTemp_value = oam_xml_search_integer_to_integer((Char8*)tag_value,
                RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO],
                DRXRETRANSMISSIONTIMER_COUNT);
        if(lclTemp_value >= MIN_DRX_RETRANSMISSION_TIMER && 
                lclTemp_value <= MAX_DRX_RETRANSMISSION_TIMER) {   
            /* coverity 35808 */
            p_rrm_cellconfig->ran_info.mac_layer_params.rrm_oam_cdrx_config.
                drx_retransmission_timer =
                (rrm_oam_drx_retransmission_timer_et)lclTemp_value;
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of DRXRetransmissionTimer is %d and "
                    "range is from %d to %d",
                    lclTemp_value,
                    MIN_DRX_RETRANSMISSION_TIMER,
                    MAX_DRX_RETRANSMISSION_TIMER);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }   


        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->CDRX,
                "X_VENDOR_LONG_CDRX_CYCLE");
        lclTemp_value = oam_xml_search_integer_to_integer((Char8*)tag_value,
                RAN_MAC_DRX_longDRXCycle[OAM_ZERO],
                LONGDRXCYCLE_COUNT);
        if(lclTemp_value >= MIN_LONG_DRX_CYCLE && 
                lclTemp_value <= MAX_LONG_DRX_CYCLE) {   
            /* coverity 35816 */
            p_rrm_cellconfig->ran_info.mac_layer_params.rrm_oam_cdrx_config.
                long_drx_cycle =
                (rrm_oam_long_drx_cycle_start_offset_et)lclTemp_value;
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of LongDRXCycle is %d and range is from %d to %d",
                    lclTemp_value, MIN_LONG_DRX_CYCLE, MAX_LONG_DRX_CYCLE);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }       

        #ifdef ENDC_ENABLED
        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->CDRX,
                "X_VENDOR_LONG_CDRX_CYCLE_R15");
        lclTemp_value = oam_xml_search_integer_to_integer((Char8*)tag_value,
                RAN_MAC_DRX_longDRXCycleR15[OAM_ZERO],
                LONGDRXCYCLE_COUNT_R15);
        if(lclTemp_value >= MIN_LONG_DRX_CYCLE_R15 && 
                lclTemp_value <= MAX_LONG_DRX_CYCLE_R15) {   
            p_rrm_cellconfig->ran_info.mac_layer_params.rrm_oam_cdrx_config.
                long_drx_cycle_r15 =
                (rrm_oam_long_drx_cycle_start_offset_r15_et)lclTemp_value;
            p_rrm_cellconfig->ran_info.mac_layer_params.rrm_oam_cdrx_config.
                bitmask |= RRM_OAM_CDRX_COFNIG_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT;
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of LongDRXCycleR15 is %d and range is from %d to %d",
                    lclTemp_value, MIN_LONG_DRX_CYCLE_R15, MAX_LONG_DRX_CYCLE_R15);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        #endif
        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->CDRX,
                "X_VENDOR_CDRX_STARTOFFSET");
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(lclTemp_value >= MIN_DRX_START_OFFSETT && 
                lclTemp_value <= MAX_DRX_START_OFFSETT) {   
            p_rrm_cellconfig->ran_info.mac_layer_params.rrm_oam_cdrx_config.
                drx_start_offset = lclTemp_value;  
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of DRXStartOffset is %d and range is from %d to %d",
                    lclTemp_value, MIN_DRX_START_OFFSETT,
                    MAX_DRX_START_OFFSETT);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }   

        /*SPR 20533 Fix Start*/
        /*Code Removed*/
        /*SPR 20533 Fix Stop*/
    }
    /*CSR 00059124 FIX End*/
    p_rrm_cellconfig->ran_info.
        rlc_layer_params.num_valid_srb_info = RRM_OAM_MAX_NUM_SRBS;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->SRB1,"DefaultConfiguration"));
    if 
        (
         lclTemp_value >= MIN_SRB1_DEFAULT_CONFIGURATION
         && 
         lclTemp_value <= MAX_SRB1_DEFAULT_CONFIGURATION
        )
        {		
            /* coverity 35681 */
            p_rrm_cellconfig->ran_info.
                rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].
                default_configuration=(rrm_bool_et)lclTemp_value;	
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of DefaultConfiguration is %d and range is from %d to %d",
                lclTemp_value,MIN_SRB1_DEFAULT_CONFIGURATION,MAX_SRB1_DEFAULT_CONFIGURATION);

        return OAM_FAILURE;
    }	

    SInt8 TPollRetransmit = OAM_ZERO,
          PollPDU = OAM_ZERO,
          PollByte = OAM_ZERO,
          MaxRetxThreshold = OAM_ZERO,
          TReordering = OAM_ZERO,
          TStatusProhibit = OAM_ZERO;

    TPollRetransmit = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB1,"TPollRetransmit"),OAM_INVALID_STR);
    PollPDU = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB1,"PollPDU"),OAM_INVALID_STR);
    PollByte = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB1,"PollByte"),OAM_INVALID_STR);
    MaxRetxThreshold = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB1,"MaxRetxThreshold"),OAM_INVALID_STR);
    TReordering = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB1,"TReordering"),OAM_INVALID_STR);
    TStatusProhibit = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB1,"TStatusProhibit"),OAM_INVALID_STR);


    if((TPollRetransmit != OAM_ZERO)
            && (PollPDU != OAM_ZERO)
            && (PollByte != OAM_ZERO)
            && (MaxRetxThreshold != OAM_ZERO)
            && (TReordering != OAM_ZERO)
            && (TStatusProhibit != OAM_ZERO)
      )
    {
        p_rrm_cellconfig->ran_info.rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].bitmask |= RRM_OAM_SRB_INFO_PRESENT; 

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB1,"TPollRetransmit"),RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO],TPOLLRETRANSMIT_COUNT);
        if 
            (
             lclTemp_value >= MIN_SRB1_T_POLL_RETRANSMIT
             && 
             lclTemp_value <= MAX_SRB1_T_POLL_RETRANSMIT
            )
            {	
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.
                    t_poll_retransmit=(rrm_oam_t_poll_retransmit_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of TPollRetransmit is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB1_T_POLL_RETRANSMIT,MAX_SRB1_T_POLL_RETRANSMIT);

            return OAM_FAILURE;
        }	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB1,"PollPDU"),RAN_RLC_SRB1_pollPDU[OAM_ZERO],POLLPDU_COUNT);
        if 
            (
             lclTemp_value >= MIN_SRB1_POLL_PDU
             && 
             lclTemp_value <= MAX_SRB1_POLL_PDU
            )
            {	
                /* coverity 35709 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].
                    srb_params.poll_pdu=(rrm_oam_poll_pdu_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of PollPDU is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB1_POLL_PDU,MAX_SRB1_POLL_PDU);

            return OAM_FAILURE;
        }	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB1,"PollByte"), RAN_RLC_SRB1_pollByte[OAM_ZERO],POLLBYTE_COUNT);
        if 
            (
             lclTemp_value >= MIN_SRB1_POLL_BYTE
             && 
             lclTemp_value <= MAX_SRB1_POLL_BYTE
            )
            {	
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.
                    poll_byte=(rrm_oam_poll_byte_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of PollByte is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB1_POLL_BYTE,MAX_SRB1_POLL_BYTE);

            return OAM_FAILURE;
        }	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB1,"MaxRetxThreshold"),RAN_RLC_SRB1_MaxRetxThreshold[OAM_ZERO],MAXRETXTHRESHOLD_COUNT);
        if
            (
             lclTemp_value >= MIN_SRB2_MAX_RETX_THRESHOLD
             &&
             lclTemp_value <= MAX_SRB2_MAX_RETX_THRESHOLD
            )
            {
                /* coverity 35685 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.
                    max_retx_threshold=(rrm_oam_max_retx_threshold_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of MaxRetxThreshold is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_MAX_RETX_THRESHOLD,MAX_SRB2_MAX_RETX_THRESHOLD);

            return OAM_FAILURE;
        }



        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB1,"TReordering"),RAN_RLC_SRB1_TReordering[OAM_ZERO],TREORDERING_COUNT);
        if 
            (
             lclTemp_value >= MIN_SRB1_T_REORDERING
             && 
             lclTemp_value <= MAX_SRB1_T_REORDERING
            )
            {	
                /* coverity 35710 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].
                    srb_params.t_reordering=(rrm_oam_t_reordering_et)lclTemp_value;	
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of TReordering is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB1_T_REORDERING,MAX_SRB1_T_REORDERING);

            return OAM_FAILURE;
        }	


        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB1,"TStatusProhibit"),RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO],TSTATUSPROHIBIT_COUNT);
        if 
            (
             lclTemp_value >= MIN_SRB1_T_STATUS_PROHIBIT
             && 
             lclTemp_value <= MAX_SRB1_T_STATUS_PROHIBIT
            )
            {	
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.
                    t_status_prohibit=(rrm_oam_t_status_prohibit_et)lclTemp_value;	
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of TStatusProhibit is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB1_T_STATUS_PROHIBIT,MAX_SRB1_T_STATUS_PROHIBIT);

            return OAM_FAILURE;
        }	
        /* SPR 20653 Fix Start */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB1,"X_VENDOR_TX_BUFFER_SIZE_FACTOR_GBR"));
        if 
            (
             lclTemp_value >= MIN_SRB1_TX_BUFFERFACTOR_GBR
             && 
             lclTemp_value <= MAX_SRB1_TX_BUFFERFACTOR_GBR
            )
            {	
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_tx_buffer_size_factor_gbr=lclTemp_value;	
            }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_TX_BUFFER_SIZE_FACTOR_GBR is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB1_TX_BUFFERFACTOR_GBR,MAX_SRB1_TX_BUFFERFACTOR_GBR);

            return OAM_FAILURE;
        }	
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB1,"X_VENDOR_TX_BUFFER_SIZE_FACTOR_NGBR"));
        if 
            (
             lclTemp_value >= MIN_SRB1_TX_BUFFERFACTOR_NGBR
             && 
             lclTemp_value <= MAX_SRB1_TX_BUFFERFACTOR_NGBR
            )
            {	
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_tx_buffer_size_factor_ngbr=lclTemp_value;	
            }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_TX_BUFFER_SIZE_FACTOR_NGBR is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB1_TX_BUFFERFACTOR_NGBR,MAX_SRB1_TX_BUFFERFACTOR_NGBR);

            return OAM_FAILURE;
        }	
        /* SPR 20653 Fix End */	
    }	
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->SRB2,"DefaultConfiguration"));
    if 
        (
         lclTemp_value >= MIN_SRB2_DEFAULT_CONFIGURATION
         && 
         lclTemp_value <= MAX_SRB2_DEFAULT_CONFIGURATION
        )
        {		
            /* coverity 35681 */
            p_rrm_cellconfig->ran_info.
                rlc_layer_params.rlc_layer_param_srb[OAM_ONE].
                default_configuration=(rrm_bool_et)lclTemp_value;	
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of DefaultConfiguration is %d and range is from %d to %d",
                lclTemp_value,MIN_SRB2_DEFAULT_CONFIGURATION,MAX_SRB2_DEFAULT_CONFIGURATION);

        return OAM_FAILURE;
    }	

    TPollRetransmit = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB2,"TPollRetransmit"),OAM_INVALID_STR);
    PollPDU = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB2,"PollPDU"),OAM_INVALID_STR);
    PollByte = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB2,"PollByte"),OAM_INVALID_STR);
    MaxRetxThreshold = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB2,"MaxRetxThreshold"),OAM_INVALID_STR);
    TReordering = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB2,"TReordering"),OAM_INVALID_STR);
    TStatusProhibit = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SRB2,"TStatusProhibit"),OAM_INVALID_STR);


    if((TPollRetransmit != OAM_ZERO)
            && (PollPDU != OAM_ZERO)
            && (PollByte != OAM_ZERO)
            && (MaxRetxThreshold != OAM_ZERO)
            && (TReordering != OAM_ZERO)
            && (TStatusProhibit != OAM_ZERO)
      )
    {
        p_rrm_cellconfig->ran_info.rlc_layer_params.rlc_layer_param_srb[OAM_ONE].bitmask |= RRM_OAM_SRB_INFO_PRESENT;   

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB2,"TPollRetransmit"),RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO],TPOLLRETRANSMIT_COUNT);
        if 
            (
             lclTemp_value >= MIN_SRB2_T_POLL_RETRANSMIT
             && 
             lclTemp_value <= MAX_SRB2_T_POLL_RETRANSMIT
            )
            {	
                /* coverity 35713 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.
                    t_poll_retransmit=(rrm_oam_t_poll_retransmit_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of TPollRetransmit is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_T_POLL_RETRANSMIT,MAX_SRB2_T_POLL_RETRANSMIT);

            return OAM_FAILURE;
        }	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB2,"PollPDU"),RAN_RLC_SRB1_pollPDU[OAM_ZERO],POLLPDU_COUNT);
        if 
            (
             lclTemp_value >= MIN_SRB2_POLL_PDU
             && 
             lclTemp_value <= MAX_SRB2_POLL_PDU
            )
            {	
                /* coverity 35689 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.
                    poll_pdu=(rrm_oam_poll_pdu_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of PollPDU is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_POLL_PDU,MAX_SRB2_POLL_PDU);

            return OAM_FAILURE;
        }	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB2,"PollByte"), RAN_RLC_SRB1_pollByte[OAM_ZERO],POLLBYTE_COUNT);
        if 
            (
             lclTemp_value >= MIN_SRB2_POLL_BYTE
             && 
             lclTemp_value <= MAX_SRB2_POLL_BYTE
            )
            {	
                /* coverity 35688 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.
                    poll_byte=(rrm_oam_poll_byte_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of PollByte is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_POLL_BYTE,MAX_SRB2_POLL_BYTE);

            return OAM_FAILURE;
        }	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB2,"MaxRetxThreshold"),RAN_RLC_SRB1_MaxRetxThreshold[OAM_ZERO],MAXRETXTHRESHOLD_COUNT);   
        if 
            (
             lclTemp_value >= MIN_SRB2_MAX_RETX_THRESHOLD
             && 
             lclTemp_value <= MAX_SRB2_MAX_RETX_THRESHOLD
            )
            {	
                /* coverity 35685 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.
                    max_retx_threshold=(rrm_oam_max_retx_threshold_et)lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of MaxRetxThreshold is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_MAX_RETX_THRESHOLD,MAX_SRB2_MAX_RETX_THRESHOLD);

            return OAM_FAILURE;
        }	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB2,"TReordering"),RAN_RLC_SRB1_TReordering[OAM_ZERO],TREORDERING_COUNT);  
        if 
            (
             lclTemp_value >= MIN_SRB2_T_REORDERING
             && 
             lclTemp_value <= MAX_SRB2_T_REORDERING
            )
            {	
                /* coverity 35714 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.
                    t_reordering=(rrm_oam_t_reordering_et)lclTemp_value;	
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of TReordering is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_T_REORDERING,MAX_SRB2_T_REORDERING);

            return OAM_FAILURE;
        }	

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB2,"TStatusProhibit"),RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO],TSTATUSPROHIBIT_COUNT);  
        if 
            (
             lclTemp_value >= MIN_SRB2_T_STATUS_PROHIBIT
             && 
             lclTemp_value <= MAX_SRB2_T_STATUS_PROHIBIT
            )
            {	
                /* coverty 35717 */
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.
                    t_status_prohibit=(rrm_oam_t_status_prohibit_et)lclTemp_value;	
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of TStatusProhibit is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_T_STATUS_PROHIBIT,MAX_SRB2_T_STATUS_PROHIBIT);

            return OAM_FAILURE;
        }	
        /* SPR 20653 Fix Start */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB2,"X_VENDOR_TX_BUFFER_SIZE_FACTOR_GBR"));
        if 
            (
             lclTemp_value >= MIN_SRB2_TX_BUFFERFACTOR_GBR
             && 
             lclTemp_value <= MAX_SRB2_TX_BUFFERFACTOR_GBR
            )
            {	
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_tx_buffer_size_factor_gbr=lclTemp_value;	
            }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_TX_BUFFER_SIZE_FACTOR_GBR is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_TX_BUFFERFACTOR_GBR,MAX_SRB2_TX_BUFFERFACTOR_GBR);

            return OAM_FAILURE;
        }	
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SRB2,"X_VENDOR_TX_BUFFER_SIZE_FACTOR_NGBR"));
        if 
            (
             lclTemp_value >= MIN_SRB2_TX_BUFFERFACTOR_NGBR
             && 
             lclTemp_value <= MAX_SRB2_TX_BUFFERFACTOR_NGBR
            )
            {	
                p_rrm_cellconfig->ran_info.
                    rlc_layer_params.rlc_tx_buffer_size_factor_ngbr=lclTemp_value;	
            }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_TX_BUFFER_SIZE_FACTOR_NGBR is %d and range is from %d to %d",
                    lclTemp_value,MIN_SRB2_TX_BUFFERFACTOR_NGBR,MAX_SRB2_TX_BUFFERFACTOR_NGBR);

            return OAM_FAILURE;
        }	
        /* SPR 20653 Fix End */	
    }	
    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->Common_2,"Qhyst"),RAN_Mobility_IdleMode_Common_QHyst[OAM_ZERO],16);
    /* coverity 35682 */   
    p_rrm_cellconfig->ran_info.
        mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_common_params.q_hyst =(rrm_oam_q_hyst_et)lclTemp_value;

    SInt8 QHystSFMedium = OAM_ZERO,
          QHystSFHigh =  OAM_ZERO,
          TEvaluation = OAM_ZERO,
          THystNormal = OAM_ZERO,
          NCellChangeMedium = OAM_ZERO,
          NCellChangeHigh = OAM_ZERO;

    QHystSFMedium = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2,"QHystSFMedium"),OAM_INVALID_STR);
    QHystSFHigh = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2,"QHystSFHigh"),OAM_INVALID_STR);
    TEvaluation = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2,"TEvaluation"),OAM_INVALID_STR);
    THystNormal = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2,"THystNormal"),OAM_INVALID_STR);
    NCellChangeMedium = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2,"NCellChangeMedium"),OAM_INVALID_STR);
    NCellChangeHigh = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2,"NCellChangeHigh"),OAM_INVALID_STR);


    if((QHystSFMedium != OAM_ZERO)
            && (QHystSFHigh != OAM_ZERO)
            && (TEvaluation != OAM_ZERO)
            && (THystNormal != OAM_ZERO)
            && (NCellChangeMedium != OAM_ZERO)
            && (NCellChangeHigh != OAM_ZERO)
      )
    {

        p_rrm_cellconfig->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.bitmask |= RRM_OAM_SPEED_STATE_PARAMS_PRESENT; /* mobility bitmask change activity 21 march*/

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Common_2,"QHystSFMedium"),RAN_Mobility_IdleMode_Common_QHystSFMedium[OAM_ZERO],OAM_FOUR);
        /* coverity 35691 */
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            q_hyst_sf_medium=(rrm_oam_q_hyst_sf_et)lclTemp_value;

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Common_2,"QHystSFHigh"),RAN_Mobility_IdleMode_Common_QHystSFHigh[OAM_ZERO],OAM_FOUR);
        /* coverity 35690 */
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            q_hyst_sf_high	=(rrm_oam_q_hyst_sf_et)lclTemp_value;

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Common_2,"TEvaluation"),RAN_Mobility_IdleMode_Common_TEvaluation[OAM_ZERO],OAM_FIVE);

        /* coverity 35711 */
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            t_evaluation=(rrm_oam_t_evaluation_et)lclTemp_value;


        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Common_2,"THystNormal"),RAN_Mobility_IdleMode_Common_THystNormal[OAM_ZERO],OAM_FIVE);
        /* coverity 35712 */
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            t_hyst_normal=(rrm_oam_t_hyst_normal_et)lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Common_2,"NCellChangeMedium"));
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            n_cell_change_medium=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Common_2,"NCellChangeHigh"));
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_common_params.speed_state_params.
            n_cell_change_high=lclTemp_value;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"QRxLevMinSIB1"));

    p_rrm_cellconfig->ran_info.
        mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_1=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"QRxLevMinOffset"));
    p_rrm_cellconfig->ran_info.
        mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.q_rx_lev_min_offset=lclTemp_value;

    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
        bitmask |= RRM_OAM_Q_RX_LEV_MIN_OFFSET_PRESENT;


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"PMax"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_P_MAX_SIB_1
         && 
         lclTemp_value <= MAX_RRM_CELL_P_MAX_SIB_1
        )
        {	
            p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.p_max_sib_1=lclTemp_value;

            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
                bitmask |= RRM_OAM_P_MAX_SIB1_PRESENT;
        }
    else
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IntraFreq,"PMax"),
                    OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of p_max_sib_1 is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_P_MAX_SIB_1,
                    MAX_RRM_CELL_P_MAX_SIB_1);

            return OAM_FAILURE;
        }
    }	


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"QRxLevMinSIB3"));
    p_rrm_cellconfig->ran_info.
        mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_3=lclTemp_value;
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"PMax"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_P_MAX_SIB_3
         && 
         lclTemp_value <= MAX_RRM_CELL_P_MAX_SIB_3
        )
        {	
            p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.p_max_sib_3=lclTemp_value;

            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
                bitmask |= RRM_OAM_P_MAX_SIB3_PRESENT;
        }
    else
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IntraFreq,"p_max_sib_3"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of p_max_sib_3 is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_P_MAX_SIB_3,
                    MAX_RRM_CELL_P_MAX_SIB_3);

            return OAM_FAILURE;
        }
    }	

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"SIntraSearch"));

    /* SPR 11157 FIX START */
    if (OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.s_intra_search=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_S_INTRA_SEARCH_PRESENT;

    }
    /* SPR 11157 FIX START */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"TReselectionEUTRA"));
    if (OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.t_reselection_eutra=lclTemp_value;
    }

    SInt8 TReselectionEUTRASFMedium = OAM_ZERO,
          TReselectionEUTRASFHigh = OAM_ZERO;

    TReselectionEUTRASFMedium = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,"TReselectionEUTRASFMedium"),OAM_INVALID_STR);
    TReselectionEUTRASFHigh = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,"TReselectionEUTRASFHigh"),OAM_INVALID_STR);

    if((TReselectionEUTRASFMedium != OAM_ZERO)
            && (TReselectionEUTRASFHigh != OAM_ZERO)
      )
    {
        p_rrm_cellconfig->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT;


        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"TReselectionEUTRASFMedium"),RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO],INTRAFREQ_TRESELECTIONEUTRASFMEDIUM_COUNT);
        if (OAM_INVALID_VALUE != lclTemp_value )
        {
            p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.speed_scale_factors.
                t_reselection_eutra_sf_medium=(rrm_oam_speed_state_scale_factors_et)lclTemp_value;
        }

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"TReselectionEUTRASFHigh"),RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO],INTRAFREQ_TRESELECTIONEUTRASFHIGH_COUNT);
        if (OAM_INVALID_VALUE != lclTemp_value )
        {
            p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.speed_scale_factors.
                t_reselection_eutra_sf_high=(rrm_oam_speed_state_scale_factors_et)lclTemp_value;
        }
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"SNonIntraSearch"));
    if (OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.s_non_intra_search=lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.
            bitmask |= RRM_OAM_S_NON_INTRA_SEARCH_PRESENT;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"CellReselectionPriority"));
    if (OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.cell_reselection_priority
            =lclTemp_value;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"ThreshServingLow"));
    if (OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_intra_freq_params.thresh_serving_low	=lclTemp_value;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->MBSFN,"NeighCellConfig"));      
    if 
        (
         lclTemp_value >= MIN_NEIGH_CELL_CONFIG 
         && 
         lclTemp_value <= MAX_NEIGH_CELL_CONFIG
        )
        {		
            p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.neigh_cell_config =lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of NeighCellConfig is %d and range is from %d to %d",
                lclTemp_value,MIN_NEIGH_CELL_CONFIG,
                MIN_NEIGH_CELL_CONFIG);

        return OAM_FAILURE;
    }


    UInt32 eutran_meas_cnt = OAM_ZERO;
    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->InterFreq,
            "CarrierNumberOfEntries");
    if(oam_strcmp(temp, OAM_INVALID_STR)) {
        eutran_meas_cnt = oam_atoi(temp);
        /* SPR 14651 START/END Code Removed  */
    }


    /* SPR 12096 Fix Start */
    for(count = OAM_ZERO; count < eutran_meas_cnt; ++count) {
        /* SPR 12096 Fix Start */
        /* SPR 14651 START */
        eutran_meas_enable = oam_atoi((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "Enable"));

        if(eutran_meas_enable)
        {
            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "EUTRACarrierARFCN");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[count].
                    eutra_carrier_arfcn = (U32)lclTemp_value;
                /*SPR_15770 Fix start*/
#ifdef OAM_SON_ENABLE
                /*Populate known neighbor earfcn list for Network scan*/
                oam_prov_req.oam_igd_params.rem_lte_params.known_earfcn_list.
                    meas_bandwidth_per_earfcn[oam_prov_req.oam_igd_params.rem_lte_params.
                    known_earfcn_list.num_earfcn].earfcn = (U16)lclTemp_value;
                oam_prov_req.oam_igd_params.rem_lte_params.known_earfcn_list.num_earfcn++;
#endif			
                /*SPR_15770 Fix end*/

            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "QRxLevMinSIB5");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);
                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    q_rx_lev_min_sib_5 = (S8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "QOffsetFreq");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_xml_search_integer_to_integer(temp,
                        carrier_qoffset_freq_tbl[0],
                        INTERFREQ_CARRIER_QOFFSETFREQ_COUNT);
                /* coverity 35692 */
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    q_offset_freq = (rrm_oam_q_offset_range_et)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "TReselectionEUTRA");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    t_reselection_eutra = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "CellReselectionPriority");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    cell_reselection_priority = (U8)lclTemp_value;

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    bitmask |= RRM_OAM_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "ThreshXHigh");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    thresh_x_high = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "ThreshXLow");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    thresh_x_low = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "PMax");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    p_max = (S8)lclTemp_value;

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    bitmask |= RRM_OAM_P_MAX_PRESENT; 
            }

            /* SPR 12920 Fix Start */
            lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->Carrier[count],"X_VENDOR_MEAS_BANDWIDTH_FOR_EARFCN"),MeasBandwidth,RRM_OAM_BW_MEAS_COUNT);
            /* SPR 12920 Fix End */

            /* coverity 35672 */
            p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[meas_count].measurement_bandwidth
                = (rrm_oam_measurement_bandwidth_et)lclTemp_value;


            tag_value = oam_get_xml_text_node_content(
                    p_cell_spec_params->Carrier[count],
                    "X_VENDOR_PRESENCE_ANTENNA_PORT1", buf,
                    OAM_TAG_VALUE_STR_MAX_LEN);

            if(tag_value) {
                lclTemp_value = oam_atoi(buf);

                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    presence_antenna_port1 = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "X_VENDOR_NEIGHBOR_CELL_CONFIG");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);
#ifdef LTE_EMBMS_SUPPORTED

            if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
/* SPR 22248 MBMS Changes Start */
                            p_cell_specFAPService->LTE_1,"DuplexMode"),
/* SPR 22248 MBMS Changes Stop */
                        "FDDMode",oam_strlen("FDDMode")+1) &&
                    (lclTemp_value == OAM_THREE))
            {
                disable_embms_neighcellconfig_g = OAM_TRUE;
                OAM_LOG(OAM, OAM_ERROR, "\n Operator can't configure "
                        "neighcellconfig for inter cell as 3 for fddmode ,"
                        " so disabling embms");
            }

#endif
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    neigh_cell_config = (U8)lclTemp_value;

                /* BITSTRING CHANGES START */
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[count].
                    neigh_cell_config <<= OAM_SIX;
                /* BITSTRING CHANGES END */
            }

            diff1 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                        "TReselectionEUTRASFMedium"), OAM_INVALID_STR);

            diff2 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                        "TReselectionEUTRASFHigh"), OAM_INVALID_STR);

            if(diff1 && diff2) {
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    bitmask |= RRM_OAM_T_EUTR_SPEED_SCALE_FACTOR_PRESENT; 


                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                        "TReselectionEUTRASFMedium");
                lclTemp_value = oam_xml_search_integer_to_integer(temp,
                        RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[0],
                        INTRAFREQ_TRESELECTIONEUTRASFMEDIUM_COUNT);
                /* coverity 35708 */
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].speed_scale_factors.
                    t_reselection_eutra_sf_medium = (rrm_oam_speed_state_scale_factors_et)lclTemp_value;


                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                        "TReselectionEUTRASFHigh");

                lclTemp_value = oam_xml_search_integer_to_integer(temp,
                        RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[0],
                        INTRAFREQ_TRESELECTIONEUTRASFHIGH_COUNT);
                /* coverity 35707 */
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].speed_scale_factors.
                    t_reselection_eutra_sf_high = (rrm_oam_speed_state_scale_factors_et)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                    "X_VENDOR_Q_QUAL_MIN_R9");

            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    q_qual_min_r9 = (S8)lclTemp_value;

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    bitmask |= RRM_OAM_Q_QUAL_MIN_R9_PRESENT;
            }

            diff1 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                        "X_VENDOR_THRESHX_HIGHQ_R9"), OAM_INVALID_STR);

            diff2 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                        "X_VENDOR_THRESHX_LOWQ_R9"), OAM_INVALID_STR);

            if(diff1 && diff2) {
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[count].
                    bitmask |= RRM_OAM_THRESHX_Q_R9_PRESENT;

                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                        "X_VENDOR_THRESHX_HIGHQ_R9");
                lclTemp_value = oam_atoi(temp);
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    threshx_q_r9.thresh_serving_highq_r9 = (U8)lclTemp_value;


                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[count],
                        "X_VENDOR_THRESHX_LOWQ_R9");
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[meas_count].
                    threshx_q_r9.thresh_serving_lowq_r9 = (U8)lclTemp_value;	
            }

            tag_value = oam_get_xml_text_node_content(
                    p_cell_spec_params->Carrier[count],
                    "X_VENDOR_CM_OFFSET_FREQ", buf,
                    OAM_TAG_VALUE_STR_MAX_LEN);

            if(tag_value) {
                lclTemp_value = oam_xml_search_integer_to_integer(buf,
                        carrier_qoffset_freq_tbl[0],
                        INTERFREQ_CARRIER_QOFFSETFREQ_COUNT);
                /* coverity 35692 */
                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[count].
                    cm_offset_freq = (rrm_oam_q_offset_range_et)lclTemp_value;

                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[count].
                    bitmask |= RRM_OAM_CM_OFFSET_FREQ_PRESENT;
            }
            meas_count++;
        }
    }

    if(meas_count)
    {    
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_inter_freq_params_list.
            num_valid_inter_freq_list = meas_count;

        p_rrm_cellconfig->ran_info.
            bitmask |= RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT;       

        p_rrm_cellconfig->ran_info. mobility_params.
            bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT; 

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_INTER_FREQ_PRESENT;

    }        
    /* SPR 14651 END */

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRA,
            "TReselectionUTRA");
    if(oam_strcmp(temp, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(temp);

        p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutra_to_utra_reselection_params.
            t_reselection_utra = (U8)lclTemp_value;	

        /* SPR 14651 START/END Code Removed  */
    }

    diff1 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRA,
                "TReselectionUTRASFMedium"), OAM_INVALID_STR);

    diff2 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRA,
                "TReselectionUTRASFHigh"), OAM_INVALID_STR);
    if(diff1 && diff2) {
        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRA,
                "TReselectionUTRASFMedium");
        lclTemp_value = oam_xml_search_integer_to_integer(temp,
                RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO],
                INTRAFREQ_TRESELECTIONEUTRASFMEDIUM_COUNT);

        /* coverity 35790 */
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
            irat_eutra_to_utra_reselection_params.speed_scale_factors.
            t_reselection_eutra_sf_medium = (rrm_oam_speed_state_scale_factors_et)lclTemp_value;

        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRA,
                "TReselectionUTRASFHigh");
        lclTemp_value = oam_xml_search_integer_to_integer(temp,
                RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO],
                INTRAFREQ_TRESELECTIONEUTRASFHIGH_COUNT);

        /* coverity 35791 */
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
            irat_eutra_to_utra_reselection_params.speed_scale_factors.
            t_reselection_eutra_sf_high = (rrm_oam_speed_state_scale_factors_et)lclTemp_value;	

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
            irat_eutra_to_utra_reselection_params.
            bitmask |= RRM_OAM_EUTRA_UTRA_RESELECTION_SPEED_SCALE_FACTOR_PRESENT;
    }

    /* RT SPR 9019 FIX START */

    /* SPR 14651 START */
    /*UTARN ADD UPDATE DELETE FIXED START */
    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRA,
            "UTRANFDDFreqNumberOfEntries");
    num_entries = oam_atoi(temp);

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRA,
            "MaxUTRANFDDFreqEntries");
    max_entries = oam_atoi(temp);

    if(max_entries > OAM_MAX_NUM_UTRA_FDD_CARRIERS) {
        OAM_LOG(OAM, OAM_WARNING, "Maximum allowed value of the tag "
                "MaxUTRANFDDFreqEntries is %d", OAM_MAX_NUM_UTRA_FDD_CARRIERS);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    if(num_entries > max_entries) {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of the tag UTRANFDDFreqNumberOfEntries "
                "can't be greater than that of MaxUTRANFDDFreqEntries");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    meas_count= OAM_ZERO;

    for (count = OAM_ZERO ; count < num_entries ; ++count) {

        utran_meas_enable = oam_atoi((Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->UTRANFDDFreq[count],"Enable"));
        if(utran_meas_enable) 
        {  
            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                    "UTRACarrierARFCN");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[meas_count].
                    utra_carrier_arfcn	= (U16)lclTemp_value;	
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "The mandatory tag \"UTRACarrierARFCN\" not found");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                    "QRxLevMin");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value=oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[meas_count].
                    q_rx_lev_min = (S8)lclTemp_value;	     
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                    "QQualMin");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value=oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[meas_count].
                    q_qual_min = (S8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                    "CellReselectionPriority");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value=oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[meas_count].
                    cell_reselection_priority = (U8)lclTemp_value;

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[meas_count].
                    bitmask |= RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                    "ThreshXHigh");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[meas_count].
                    thresh_x_high   = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                    "ThreshXLow");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value=oam_atoi(temp);
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[meas_count].
                    thresh_x_low = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                    "PMaxUTRA");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value=oam_atoi(temp);
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[meas_count].
                    p_max_utra	= (S8)lclTemp_value;
            }

            diff1 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                        "X_VENDOR_THRESHX_HIGHQ_R9"), OAM_INVALID_STR);

            diff2 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                        "X_VENDOR_THRESHX_LOWQ_R9"), OAM_INVALID_STR);


            if(diff1 && diff2) {
                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                        "X_VENDOR_THRESHX_HIGHQ_R9");
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[meas_count].threshx_q_r9.
                    thresh_serving_highq_r9 = (U8)lclTemp_value;	


                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[count],
                        "X_VENDOR_THRESHX_LOWQ_R9");
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[meas_count].threshx_q_r9.
                    thresh_serving_lowq_r9 = (U8)lclTemp_value;	

                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
                    irat_eutran_to_utran_fdd_list.
                    irat_eutran_to_utran_fdd_carriers[meas_count].
                    bitmask |= RRM_OAM_THRESHOLD_Q_R9_T_PRESENT;
            }
            meas_count++;    
        }
    }

    if(meas_count) {
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
            bitmask |= RRM_OAM_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.num_irat_eutran_to_utran_fdd_carriers = meas_count;

        p_rrm_cellconfig->ran_info.
            bitmask |= RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT;       

        p_rrm_cellconfig->ran_info. mobility_params.
            bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT;
    }
    /* SPR 14651 END */

    /* TDD xml change START*/
    /* RT SPR 9019 FIX START */

    /* SPR 17730 Fix Start */ 
    retVal = oam_populate_irat_eutrans_to_utra_tdd_list(p_cell_spec_params,
            /* BCOM Compiltaion Fix */
#ifdef OAM_SON_ENABLE

            p_son_inter_freq_carr_params,
#endif
            /* BCOM Compiltaion Fix */
            p_rrm_cellconfig);
    /* SPR 17730 Fix End */

    if(OAM_FAILURE == retVal) {
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }

    /* RT SPR 9019 FIX END */
    /* TDD xml change END */

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"T300"),RAN_RRCTimers_T300[OAM_ZERO],RRCTIMERS_T300);
    if 
        (
         lclTemp_value >= MIN_T300
         && 
         lclTemp_value <= MAX_T300
        )
        {
            /* coverity 35697 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_timers.t300=(rrm_oam_timer_300_301_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of T300 is %d and range is from %d to %d",
                lclTemp_value,MIN_T300,
                MAX_T300);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"T301"),RAN_RRCTimers_T301[OAM_ZERO],RRCTIMERS_T301);
    if 
        (
         lclTemp_value >= MIN_T301
         && 
         lclTemp_value <= MAX_T301
        )
        {
            /* coverity 35698 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_timers.t301=(rrm_oam_timer_300_301_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of T301 is %d and range is from %d to %d",
                lclTemp_value,MIN_T301,
                MAX_T301);
        return OAM_FAILURE;
    }
    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"T302"),RAN_RRCTimers_T302[OAM_ZERO],RRCTIMERS_T302);
    if 
        (
         lclTemp_value >= MIN_T302
         && 
         lclTemp_value <= MAX_T302
        )
        {
            /* coverity 35699 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_timers.t302=(rrm_oam_timer_t302_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of T302 is %d and range is from %d to %d",
                lclTemp_value,MIN_T302,
                MAX_T302);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"T304EUTRA"),RAN_RRCTimers_T304EUTRA[OAM_ZERO],RRCTIMERS_T304EUTRA);
    if 
        (
         lclTemp_value >= MIN_T304EUTRA
         && 
         lclTemp_value <= MAX_T304EUTRA
        )
        {
            /*  coverity 35700 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_timers.t304_eutra=(rrm_oam_timer_t304_eutra_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of T304EUTRA is %d and range is from %d to %d",
                lclTemp_value,MIN_T304EUTRA,
                MAX_T304EUTRA);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"T304IRAT"),RAN_RRCTimers_T304IRAT[OAM_ZERO],RRCTimers_T304IRAT);
    if 
        (
         lclTemp_value >= MIN_T304IRAT
         && 
         lclTemp_value <= MAX_T304IRAT
        )
        {
            /* coverity 35701 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_timers.t304_irat=(rrm_oam_timer_t304_irat_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of T304IRAT is %d and range is from %d to %d",
                lclTemp_value,MIN_T304IRAT,
                MAX_T304IRAT);
        return OAM_FAILURE;
    }
    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"T310"),RAN_RRCTimers_T310[OAM_ZERO],RRCTimers_T310);
    if 
        (
         lclTemp_value >= MIN_T310
         && 
         lclTemp_value <= MAX_T310
        )
        {
            /* coverity 35702 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_timers.t310=(rrm_oam_timer_310_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of T310 is %d and range is from %d to %d",
                lclTemp_value,MIN_T310,
                MAX_T310);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"T311"),RAN_RRCTimers_T311[OAM_ZERO],RRCTimers_T311);
    if 
        (
         lclTemp_value >= MIN_T311
         && 
         lclTemp_value <= MAX_T311
        )
        {
            /* coverity 35703 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_timers.t311=(rrm_oam_timer_311_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of T311 is %d and range is from %d to %d",
                lclTemp_value,MIN_T311,
                MAX_T311);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"T320"),RAN_RRCTimers_T320[OAM_ZERO],RRCTimers_T320);
    if 
        (
         lclTemp_value >= MIN_T320
         && 
         lclTemp_value <= MAX_T320
        )
        {
            /* coverity 35704 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_timers.t320=(rrm_oam_timer_t320_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of T320 is %d and range is from %d to %d",
                lclTemp_value,MIN_T320,
                MAX_T320);
        return OAM_FAILURE;
    }


    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"N310"),RAN_RRCTimers_N310[OAM_ZERO],RRCTimers_N310);
    if 
        (
         lclTemp_value >= MIN_N310
         && 
         lclTemp_value <= MAX_N310
        )
        {
            /* coverity 35695 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_constants.n310=(rrm_oam_out_of_sync_n310_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of N310 is %d and range is from %d to %d",
                lclTemp_value,MIN_N310,
                MAX_N310);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RRCTimers,"N311"),RAN_RRCTimers_N311[OAM_ZERO],RRCTimers_N311);
    if 
        (
         lclTemp_value >= MIN_N311
         && 
         lclTemp_value <= MAX_N311
        )
        {
            /* coverity 35696 */
            p_rrm_cellconfig->ran_info.
                rrc_timers_and_constants.rrc_constants.n311=(rrm_oam_in_sync_n311_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of N311 is %d and range is from %d to %d",
                lclTemp_value,MIN_N311,
                MAX_N311);
        return OAM_FAILURE;
    }

    /* SPR-10651 FIX Start */
    freq_band_ind_val=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"FreqBandIndicator"));
    if 
        (
         freq_band_ind_val >= MIN_FREQBANDINDICATOR && 
         freq_band_ind_val <= MAX_FREQBANDINDICATOR 
        )
        {


            p_rrm_cellconfig->ran_info.
                rf_params.rf_configurations.frequency_band_indicator=freq_band_ind_val;	
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of FreqBandIndicator is %d and range is from %d to %d",
                freq_band_ind_val,MIN_FREQBANDINDICATOR,
                MAX_FREQBANDINDICATOR);
        return OAM_FAILURE;
    }

    /*SPR_18663 Fix Start*/
#ifdef OAM_SON_ENABLE
    Char8 *earfcn_str = OAM_NULL;
    tag_value = oam_get_xml_text_node_content(p_cell_spec_params->RF_1,
            "EARFCNDL", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);
    if(tag_value) {
        earfcn_str = oam_strtok(buf, ",");
        while (earfcn_str) {
            /*Populate self earcfn in known earfcn list for Network scan*/
            oam_prov_req.oam_igd_params.rem_lte_params.known_earfcn_list.
                meas_bandwidth_per_earfcn[oam_prov_req.oam_igd_params.rem_lte_params.known_earfcn_list.num_earfcn]
                .earfcn = oam_atoi(earfcn_str);
            oam_prov_req.oam_igd_params.rem_lte_params.known_earfcn_list.num_earfcn++;
            earfcn_str = oam_strtok(OAM_NULL, ",");

        }
    }
#endif
    /*SPR_18663 Fix End*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"EARFCNDL"));
    /* SPR 14091 FIX START */
    if(lclTemp_value >= MIN_DLEARFCN && lclTemp_value <= MAX_DLEARFCN)
    {

        /*SPR_18663 Fix Start*/
        /*Code Removed */
        /*SPR_18663 Fix End*/
        if(!validate_earfcndl_with_freq_band_ind_value(lclTemp_value)) 
        {
            return OAM_FAILURE;
        } 

        if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
                        /* spr_21013_fix_start */
                        xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"FDDMode",oam_strlen("FDDMode")+1))
            /* spr_21013_fix_end */
        {
            if(freq_band_ind_val > MAX_FDD_BAND)
            {
                OAM_LOG(OAM, OAM_WARNING, "Value of FreqBandIndicator is %d which is not a FDD Band"
                        "but DuplexMode is set to FDD", freq_band_ind_val);
                return OAM_FAILURE;
            }
        }
        else if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
                        /* spr_21013_fix_start */
                        xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"TDDMode",oam_strlen("TDDMode")+1))
            /* spr_21013_fix_end */
        {
            /* SPR 21958 PUSCH RAT1 Support Start */
            duplex_mode_flag = OAM_ONE;
            /* SPR 21958 PUSCH RAT1 Support End */
            if(freq_band_ind_val < MIN_TDD_BAND)
            {
                OAM_LOG(OAM, OAM_WARNING, "Value of FreqBandIndicator is %d which is not a TDD Band"
                        "but DuplexMode is set to TDD", freq_band_ind_val);
                return OAM_FAILURE;
            }
        }
        else
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of DuplexMode is not set to either FDDMode or TDDMode");
            return OAM_FAILURE;
        }
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.dl_earfcn = 
            (UInt32)lclTemp_value; /* Coverity 70320 Fix */ 
    }
    /* SPR 14091 FIX END */
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of dl_earfcn is %d and range is from %d to %d",
                lclTemp_value,MIN_DLEARFCN,
                MAX_DLEARFCN);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"DLBandwidth"),DLBandwidth,DL_BANDWIDTH_COUNT);

    if 
        (
         lclTemp_value >= MIN_DLBANDWIDTH
         && 
         lclTemp_value <= MAX_DLBANDWIDTH
        )
        {
            /* coverity 35693 */
            p_rrm_cellconfig->ran_info.
                rf_params.rf_configurations.dl_bandwidth=(rrm_oam_band_width_et)lclTemp_value;
            /* SPR 21040 FIXED START*/

            if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.dl_bandwidth == 0 )
            {
                oam_max_num_rbs_value = 6;
                /* SPR 22548 Fix Start */
                dl_num_rbs[cell_index] = 6;
                /* SPR 22548 Fix End */
            }    

            if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.dl_bandwidth == 1 )
            {
                oam_max_num_rbs_value = 15;
                /* SPR 22548 Fix Start */
                dl_num_rbs[cell_index] = 15;
                /* SPR 22548 Fix End */
            }    
            if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.dl_bandwidth == 2 )
            {
                oam_max_num_rbs_value = 25;
                /* SPR 22548 Fix Start */
                dl_num_rbs[cell_index] = 25;
                /* SPR 22548 Fix End */
            }    
            if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.dl_bandwidth == 3 )
            {
                oam_max_num_rbs_value = 50;
                /* SPR 22548 Fix Start */
                dl_num_rbs[cell_index] = 50;
                /* SPR 22548 Fix End */
            }    

            if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.dl_bandwidth == 4 )
            {
                oam_max_num_rbs_value = 75;
                /* SPR 22548 Fix Start */
                dl_num_rbs[cell_index] = 75;
                /* SPR 22548 Fix End */
            }    
            if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.dl_bandwidth == 5 )
            {
                oam_max_num_rbs_value = 100;
                /* SPR 22548 Fix Start */
                dl_num_rbs[cell_index] = 100;
                /* SPR 22548 Fix End */
            }   

            /* SPR 21040 FIXED END*/
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of DLBandWidth is %d and range is from %d to %d",
                lclTemp_value,MIN_DLBANDWIDTH,
                MAX_DLBANDWIDTH);
        return OAM_FAILURE;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RF_1,"EARFCNUL"),OAM_INVALID_STR)!= OAM_ZERO))
    {	
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"EARFCNUL"));
        /* SPR-10651 FIX Start */
        if(!validate_earfcnul_with_freq_band_ind_value(lclTemp_value)) 
        {
            return OAM_FAILURE;
        } 
        /* SPR-10651 FIX End */
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.ul_earfcn=lclTemp_value;
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.bitmask |= RRM_OAM_RF_CONFIGURATION_UL_EARFCN_PRESENT;
    }	


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RF_1,"ULBandwidth"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"ULBandwidth"),UlBandwidth,UL_BANDWIDTH_COUNT);
        /* coverity 35694 */
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.ul_bandwidth=(rrm_oam_band_width_et)lclTemp_value;
        /* SPR 21040 FIXED START*/

        if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.ul_bandwidth == 0 )
        {
            oam_max_num_rbs_value = 6;
            /* SPR 22548 Fix Start */
            ul_num_rbs[cell_index] = 6;
            /* SPR 22548 Fix End */
        }    

        if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.ul_bandwidth == 1 )
        {
            oam_max_num_rbs_value = 15;
            /* SPR 22548 Fix Start */
            ul_num_rbs[cell_index] = 15;
            /* SPR 22548 Fix End */
        }    
        if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.ul_bandwidth == 2 )
        {
            oam_max_num_rbs_value = 25;
            /* SPR 22548 Fix Start */
            ul_num_rbs[cell_index] = 25;
            /* SPR 22548 Fix End */
        }    
        if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.ul_bandwidth == 3 )
        {
            oam_max_num_rbs_value = 50;
            /* SPR 22548 Fix Start */
            ul_num_rbs[cell_index] = 50;
            /* SPR 22548 Fix End */
        }    

        if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.ul_bandwidth == 4 )
        {
            oam_max_num_rbs_value = 75;
            /* SPR 22548 Fix Start */
            ul_num_rbs[cell_index] = 75;
            /* SPR 22548 Fix End */
        }    
        if(p_rrm_cellconfig->ran_info.rf_params.rf_configurations.ul_bandwidth == 5 )
        {
            oam_max_num_rbs_value = 100;
            /* SPR 22548 Fix Start */
            ul_num_rbs[cell_index] = 100;
            /* SPR 22548 Fix End */
        }

        /* SPR 21040 FIXED END*/
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.bitmask |= RRM_OAM_RF_CONFIGURATION_UL_BW_PRESENT;
    }	

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"ReferenceSignalPower"));
    if 
        (
         lclTemp_value >= MIN_REFERENCESIGNALPOWER
         && 
         lclTemp_value <= MAX_REFERENCESIGNALPOWER
        )
        {
            p_rrm_cellconfig->ran_info.
                rf_params.rf_configurations.reference_signal_power=lclTemp_value;	
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ReferenceSignalPower is %d and range is from %d to %d",
                lclTemp_value,MIN_REFERENCESIGNALPOWER,
                MAX_REFERENCESIGNALPOWER);
        return OAM_FAILURE;
    }

    /* Spr 17753 Changes Start*/
    /* Code Removed */
    /* Spr 17753 Changes End*/

    /* CSR 58157 FIX Changes*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"PSCHPowerOffset"));
    if 
        (
         lclTemp_value >= MIN_PSCHPOWEROFFSET
         && 
         lclTemp_value <= MAX_PSCHPOWEROFFSET
        )
        {
            p_rrm_cellconfig->ran_info.
                rf_params.rf_configurations.psch_power_offset=lclTemp_value;	
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of PSCHPowerOffset is %d and range is from %d to %d",
                lclTemp_value,MIN_PSCHPOWEROFFSET,
                MAX_PSCHPOWEROFFSET);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"SSCHPowerOffset"));
    if 
        (
         lclTemp_value >= MIN_SSCHPOWEROFFSET
         && 
         lclTemp_value <= MAX_SSCHPOWEROFFSET
        )
        {
            p_rrm_cellconfig->ran_info.
                rf_params.rf_configurations.ssch_power_offset=lclTemp_value;	
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of SSCHPOWEROFFSET is %d and range is from %d to %d",
                lclTemp_value,MIN_SSCHPOWEROFFSET,
                MAX_SSCHPOWEROFFSET);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"PBCHPowerOffset"));
    if 
        (
         lclTemp_value >= MIN_PBCHPOWEROFFSET
         && 
         lclTemp_value <= MAX_PBCHPOWEROFFSET
        )
        {
            p_rrm_cellconfig->ran_info.
                rf_params.rf_configurations.pbch_power_offset=lclTemp_value;
            /* SPR 13918 fix start */
            p_rrm_cellconfig->ran_info.
                rf_params.rf_configurations.
                pbchTransmissionPower = (MIN_PBCHPOWEROFFSET -(lclTemp_value))*(-100);
            /* SPR 13918 fix end */


        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of PBBCHPowerOffset is %d and range is from %d to %d",
                lclTemp_value,MIN_PBCHPOWEROFFSET,
                MAX_PBCHPOWEROFFSET);
        return OAM_FAILURE;
    }

    /*Bug Fix */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RF_1,"X_VENDOR_MAX_RS_EPRE"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"X_VENDOR_MAX_RS_EPRE"));
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.max_rs_epre=lclTemp_value;	

        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.bitmask |=RRM_OAM_MAX_RS_EPRE_PRESENT;		
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"X_VENDOR_PCFICH_POWER_OFFSET"));

    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.pcfichPowerOffset = lclTemp_value;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"X_VENDOR_PHICH_POWER_OFFSET"));
    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.phichPowerOffset = lclTemp_value;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"X_VENDOR_PDCCH_POWER_OFFSET"));
    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.pdcchPowerOffset = lclTemp_value;    
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"X_VENDOR_PCH_TRANSMISSION_POWER"));

    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.pchTransmissionpower = lclTemp_value;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->S1AP,"TRelocPrep"));
    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        /* SPR 11952 FIX START */
        p_rrm_cellconfig->ran_info.
            s1ap_params.t_reloc_prep=lclTemp_value/OAM_FIVE;
        /* SPR 11952 FIX END */
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->S1AP,"TRelocOverall"));
    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        /* SPR 11952 FIX START */
        p_rrm_cellconfig->ran_info.
            s1ap_params.t_reloc_overall=lclTemp_value/OAM_FIVE;
        /* SPR 11952 FIX END */
    }

    UInt32 earfcn_val = OAM_ZERO;
    /* SPR 21351 Start */
    earfcn_val=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"EARFCNDL"));
    /* SPR-10651 FIX Start */
    if(!validate_earfcndl_with_freq_band_ind_value(earfcn_val))
    {
        return OAM_FAILURE;
    }
    /* SPR 21351 End */
    /* SPR-10651 FIX End */
    UInt16 counter = OAM_ZERO;
    UInt16 counter_1 = OAM_ZERO;
    UInt16 counter_2 = OAM_ZERO;

    extern  UInt16 lte_cell_num_entries;
    UInt16 max_lte_cell_entries=OAM_ZERO;

    max_lte_cell_entries = oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->NeighborList,"MaxLTECellEntries"));

    lte_cell_num_entries = oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->NeighborList,"LTECellNumberOfEntries"));

    if(lte_cell_num_entries > max_lte_cell_entries)
    {
        OAM_LOG(OAM, OAM_WARNING," Fail Because MaxLTECellEntries < LTECellNumberOfEntries");
        return OAM_FAILURE;
    }


    for(counter = OAM_ZERO;counter < lte_cell_num_entries;counter++)
    {
        /* Spr 15438 Fix Start */ 
        lte_cell_enable = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[counter],"Enable"));
        lte_cell_mi = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[counter],"MustInclude"));

        if ((OAM_TRUE == lte_cell_enable)&& (OAM_TRUE == lte_cell_mi))
        {
            /* Spr 15438 Fix End*/ 

            /* SPR 12348 FIX - Redundant code removed */
            UInt32 eutra_carrier_arfcn=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->LTECell[counter],"EUTRACarrierARFCN"));  
            if(eutra_carrier_arfcn == earfcn_val)
            {

                p_rrm_cellconfig->ran_info.
                    ncl_params.bitmask |= RRM_OAM_LTE_NCL_PRESENT;	
                p_rrm_cellconfig->ran_info.
                    bitmask |= RRM_OAM_NCL_PARAMS_PRESENT;

                if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->LTECell[counter],"PLMNID"),OAM_INVALID_STR)!= OAM_ZERO)
                {
                    temp = (char *)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],"PLMNID"); 
                    oam_convert_plmnid(temp_plmnid,temp);

                    oam_fill_mcc_mnc_from_plmnid(temp_plmnid ,&p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.intra_freq_cells[counter_1].cell_id.primary_plmn_id);



                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->LTECell[counter],"CID"));

                    /* Spr 10710 Fix Start*/
                    oam_encode_eutran_cellidentity_into_bit_stream(p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.intra_freq_cells[counter_1].cell_id.cell_identity,
                            lclTemp_value);
                    /* Spr 10710 Fix End*/

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].bitmask
                        |= RRM_OAM_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT;


                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "PhyCellID", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    /*Cov 93922 fix start*/
                    lclTemp_value2 = oam_atoi(buf);

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        phy_cell_id = (U16)lclTemp_value2;	
                    /*Cov 93922 fix end*/
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING, "Failed to read PhyCellID");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "QOffset", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    oam_search_integer_to_interger(buf,
                            RAN_NeighborList_LTECell_QOffset[OAM_ZERO],
                            OAM_THIRTY_ONE);

                    lclTemp_value = oam_atoi(buf);

                    /* coverity 35727*/
                    p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.
                        intra_freq_cells[counter_1].
                        q_offset = (rrm_oam_q_offset_range_et)lclTemp_value;
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "CIO", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    oam_search_integer_to_interger(buf,
                            RAN_NeighborList_LTECell_CIO[OAM_ZERO],
                            OAM_THIRTY_ONE);

                    lclTemp_value = oam_atoi(buf);

                    /* coverity 35726 */
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        cell_individual_offset =
                        (rrm_oam_q_offset_range_et)lclTemp_value;
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        bitmask |= RRM_OAM_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "RSTxPower", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        r_stx_power = lclTemp_value;
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        bitmask |= RRM_OAM_INTRA_FREQ_R_STX_POWER_PRESENT;
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "Blacklisted", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        blacklisted = lclTemp_value;	
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING, "Failed to read Blacklisted");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_TAC", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    oam_conversion_bitstring_short_to_byte_string(p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.intra_freq_cells[counter_1].tac,
                            lclTemp_value);
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_BROADCAST_STATUS", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);

                    /* SPR 18930  FIX START */
                    /* Code Removed */
                    /* SPR 18930  FIX END */
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        /* Cov CID 107809 Fix Start */
                        broadcast_status = (rrm_bool_et)lclTemp_value;
                    /* Cov CID 107809 Fix End */

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        bitmask |= RRM_OAM_INTRA_FREQ_BROADCAST_STATUS_PRESENT;
                }


                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_ACCESS_MODE", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    /* SPR 15238 START */
                    /* SPR 18930  FIX START */
                    calculated_access_mode = oam_init_nbr_cell_access_mode_pci_validation(
                            p_cell_spec_params,
                            OAM_INTRA_FREQ_NBR_CELL, 
                            eutra_carrier_arfcn,
                            p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.
                            intra_freq_cells[counter_1].phy_cell_id,
                            lclTemp_value);

                    if (lclTemp_value != (SInt32)calculated_access_mode)
                    {
                        lclTemp_value =  calculated_access_mode;
                    }
                    /* SPR 15238 END */
                    /* SPR 18930  FIX END */
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        cell_access_mode = lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        bitmask |= RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Failed to read X_VENDOR_ACCESS_MODE");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }


                if(
                        (p_rrm_cellconfig->ran_info.
                         ncl_params.lte_ncl.intra_freq_cells[counter_1].
                         bitmask & RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT)
                        &&
                        /* SPR 17408 Fix Start */
                        ((p_rrm_cellconfig->ran_info.
                         ncl_params.lte_ncl.intra_freq_cells[counter_1].
                         cell_access_mode == RRM_OAM_ACCESS_MODE_OPEN)
                        ||
                        (p_rrm_cellconfig->ran_info.
                         ncl_params.lte_ncl.intra_freq_cells[counter_1].
                         cell_access_mode == RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
                  )
                {
                    OAM_LOG(OAM, OAM_INFO, "CSGID will not be read into "
                            "lte_ncl.intra_freq_cells as ACCESS_MODE is present"
                            " and its value is Open/Open Femto");
                    /* SPR 17408 Fix End */
                }
                else {
                    temp = (Char8*)oam_xmlNodeGetContent(
                            p_cell_spec_params->LTECell[counter],
                            "X_VENDOR_CSGID");

                    if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                        OAM_LOG(OAM, OAM_INFO, "X_VENDOR_CSGID is present "
                                "and it value is: %s", temp);
                        /*SPR 16372 fix start*/
                        lclTemp_value = oam_atoi((Char8*)temp);
                        /*SPR 16372 fix stop*/
                        /* BITSTRING FIX START */
                        oam_conversion_from_int_to_byte_string(
                                p_rrm_cellconfig->
                                ran_info.ncl_params.lte_ncl.intra_freq_cells[counter_1].
                                csg_identity, lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                        /* BITSTRING FIX END */

                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.intra_freq_cells[counter_1].
                            bitmask |= RRM_OAM_INTRA_FREQ_CSG_ID_PRESENT;
                    }
                }
                /* SPR 17408 Fix +- */


                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_DAHO_INDICATION", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        daho_indication = (UInt8)lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        bitmask |= RRM_OAM_INTRA_FREQ_CELL_DAHO_IND_PRESENT;
                    /* SPR 12932 FIX START */
#ifdef OAM_SON_ENABLE
                    UInt32 instance_id = OAM_ZERO;

                    if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],
                                        "X_VENDOR_INSTANCE_ID"),OAM_INVALID_STR))!= OAM_ZERO)
                    {
                        instance_id = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],"X_VENDOR_INSTANCE_ID"));

                    }


                    /* SPR-10462 Start*/
                    if((lclTemp_value == OAM_ONE) && (lte_daho_found_flag == OAM_FALSE))
                    {
                        lte_daho_found_flag = OAM_TRUE;
                        SON_PROV_REQ.intra_rat_daho_bitmask |= OAM_ONE<<(instance_id - OAM_ONE);
                    }  
                    /* SPR 12932 FIX END */
#endif

                }                
                /*SPR 14600 START*/
#ifdef OAM_SON_ENABLE
                else
                {
                    OAM_LOG(OAM, OAM_INFO, "X_VENDOR_DAHO_INDICATION is not provided in eNodeB_Data_Model_TR_196_based.xml");
                }
#endif
                /*SPR 14600 END*/


                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_HO_STATUS", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    /* CID 118462 Fix Start */
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        ho_status = (S32)lclTemp_value;
                    /* CID 118462 Fix End */

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_1].
                        bitmask |= RRM_OAM_INTRA_FREQ_HO_STATUS_PRESENT;
                }
                /*SPR 14600 START*/
                else
                {
                    OAM_LOG(OAM, OAM_INFO,"X_VENDOR_HO_STATUS is not provided in eNodeB_Data_Model_TR_196_based.xml");
                }
                /*SPR 14600 END*/

                /* SPR 18930  FIX START */
                /* Code Removed */ 
                /* SPR 18930  FIX END */

                /* SPR_11780_FIX Start */
                // lines removed
                /* SPR_11780_FIX End */
                /*eICIC_PHASE_1_2_CHANGES_START*/

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_INTERFERENCE_SCHEME", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    /*CID:69590 start*/
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[counter_2].
                        interference_scheme = (rrm_oam_intf_scheme_type_et)lclTemp_value;
                    /*CID:69590 end*/
                    p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.intra_freq_cells[counter_2].
                        bitmask |= RRM_OAM_INTRA_FREQ_INTERFERENCE_SCHEME_PRESENT;
                }

                /*eICIC_PHASE_1_2_CHANGES_END*/

                counter_1++;
            }
            else
            {
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],"PLMNID"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    p_rrm_cellconfig->ran_info.
                        ncl_params.bitmask |= RRM_OAM_LTE_NCL_PRESENT;	
                    p_rrm_cellconfig->ran_info.
                        bitmask |= RRM_OAM_NCL_PARAMS_PRESENT;


                    temp = (char *)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],"PLMNID");  
                    oam_convert_plmnid(temp_plmnid,temp);
                    oam_fill_mcc_mnc_from_plmnid(temp_plmnid , &p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.inter_freq_cells[counter_2].cell_id.primary_plmn_id);


                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->LTECell[counter],"CID"));
                    /*SPR 10784 FIx Start */
                    oam_encode_eutran_cellidentity_into_bit_stream(p_rrm_cellconfig->ran_info. 
                            ncl_params.lte_ncl.inter_freq_cells[counter_2].cell_id.cell_identity,
                            lclTemp_value);
                    /*SPR 10784 FIx Start */
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].bitmask
                        |= RRM_OAM_INTER_FREQ_GLOBAL_CELL_ID_PRESENT;
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "PhyCellID", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    /*Cov 94761 fix start*/
                    lclTemp_value2 = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        phy_cell_id = (U16)lclTemp_value2;
                    /*Cov 94761 fix end*/
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING, "Failed to read PhyCellID");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "QOffset", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    oam_search_integer_to_interger(buf,
                            RAN_NeighborList_LTECell_QOffset[OAM_ZERO],
                            OAM_THIRTY_ONE);

                    lclTemp_value = oam_atoi(buf);

                    /* coverity 35736 */
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        q_offset = (rrm_oam_q_offset_range_et)lclTemp_value;	
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "CIO", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    oam_search_integer_to_interger(buf,
                            RAN_NeighborList_LTECell_CIO[OAM_ZERO],
                            OAM_THIRTY_ONE);

                    lclTemp_value = oam_atoi(buf);

                    /* coverity 35725 */
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        cell_individual_offset =
                        (rrm_oam_q_offset_range_et)lclTemp_value;	

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        bitmask |= RRM_OAM_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;	
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "RSTxPower", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        r_stx_power=lclTemp_value;		

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        bitmask |= RRM_OAM_INTER_FREQ_RSTX_POWER_PRESENT;		
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "Blacklisted", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        blacklisted = lclTemp_value;
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "EUTRACarrierARFCN", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        eutra_carrier_arfcn = (U32)lclTemp_value;	
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Failed to read EUTRACarrierARFCN");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }


                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_TAC", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    oam_conversion_bitstring_short_to_byte_string(p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.inter_freq_cells[counter_2].tac,
                            lclTemp_value);
                }

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_BROADCAST_STATUS", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        broadcast_status = lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        bitmask |= RRM_OAM_INTER_FREQ_BROADCAST_STATUS_PRESENT;
                }
                /* SPR 13120 FIX START */
                /* Code removed */
                /* SPR 13120 FIX END */


                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_ACCESS_MODE", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    /* SPR 15238 START */
                    calculated_access_mode = oam_init_nbr_cell_access_mode_pci_validation(
                            p_cell_spec_params,
                            OAM_INTER_FREQ_NBR_CELL, 
                            eutra_carrier_arfcn,
                            p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.
                            inter_freq_cells[counter_2].phy_cell_id,
                            lclTemp_value);
                    if (lclTemp_value != (SInt32)calculated_access_mode)
                    {
                        lclTemp_value =  calculated_access_mode;
                    }
                    /* SPR 15238 END */

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        cell_access_mode = lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        bitmask |= RRM_OAM_CELL_ACCESS_MODE_PRESENT ;		
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Failed to read X_VENDOR_ACCESS_MODE");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                /* SPR 17408 Fix Start */
                if(
                        (p_rrm_cellconfig->ran_info.
                         ncl_params.lte_ncl.inter_freq_cells[counter_2].
                         bitmask & RRM_OAM_CELL_ACCESS_MODE_PRESENT)
                        &&
                        ((p_rrm_cellconfig->ran_info.
                         ncl_params.lte_ncl.inter_freq_cells[counter_2].
                         cell_access_mode == RRM_OAM_ACCESS_MODE_OPEN)
                         ||
                        (p_rrm_cellconfig->ran_info.
                         ncl_params.lte_ncl.inter_freq_cells[counter_2].
                         cell_access_mode == RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
                          
                  )
                {
                    OAM_LOG(OAM, OAM_WARNING, "CSGID will not be read into "
                            "lte_ncl.inter_freq_cells as ACCESS_MODE is present"
                            " and its value is Open/Open Femto");
                }
                /* SPR 17408 Fix End */
                else {
                    temp = (Char8*)oam_xmlNodeGetContent(
                            p_cell_spec_params->LTECell[counter],
                            "X_VENDOR_CSGID");

                    if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                        OAM_LOG(OAM, OAM_INFO, "X_VENDOR_CSGID is present "
                                "and it value is: %s", temp);

                        /*SPR 16372 fix start*/
                        lclTemp_value = oam_atoi((Char8*)temp);
                        /*SPR 16372 fix stop*/
                        /* BITSTRING FIX START */
                        oam_conversion_from_int_to_byte_string(
                                p_rrm_cellconfig->
                                ran_info.ncl_params.lte_ncl.inter_freq_cells[counter_2].
                                csg_identity, lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                        /* BITSTRING FIX START */

                        p_rrm_cellconfig->
                            ran_info.ncl_params.lte_ncl.inter_freq_cells[counter_2].
                            bitmask |= RRM_OAM_INTER_FREQ_CSG_ID_PRESENT;
                    }
                }
                /* SPR 17408 Fix +- */

                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_X2_STATUS", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);

                    if(lclTemp_value != OAM_ZERO && lclTemp_value != OAM_ONE) {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Invalid value[%d] of X_VENDOR_X2_STATUS, should be a boolean value.",
                                lclTemp_value);
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        x2_status = lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        bitmask |= RRM_OAM_INTER_FREQ_X2_STATUS_PRESENT;	
                }

                /*SPR FIX 13417 START*/
                tag_value = oam_get_xml_text_node_content(
                        p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_DAHO_INDICATION", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        daho_indication = (UInt8)lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[counter_2].
                        bitmask |= RRM_OAM_INTRA_FREQ_CELL_DAHO_IND_PRESENT;
#ifdef OAM_SON_ENABLE
                    UInt32 instance_id = OAM_ZERO;
                    if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],
                                        "X_VENDOR_INSTANCE_ID"),OAM_INVALID_STR))!= OAM_ZERO)
                    {     
                        instance_id = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],"X_VENDOR_INSTANCE_ID"));

                    }     


                    if((lclTemp_value == OAM_ONE) && (lte_daho_found_flag == OAM_FALSE))
                    {
                        lte_daho_found_flag = OAM_TRUE;
                        SON_PROV_REQ.intra_rat_daho_bitmask |= OAM_ONE<<(instance_id - OAM_ONE);
                    }

#endif
                }

                /*SPR FIX 13417 END*/


                counter_2++; 
            }
            /* Spr 15438 Fix Start */ 
        }
        /* Spr 15438 Fix End */ 
    }  
    p_rrm_cellconfig->ran_info.
        ncl_params.lte_ncl.num_valid_intra_freq_cell=counter_1;
    p_rrm_cellconfig->ran_info.
        ncl_params.lte_ncl.num_valid_inter_freq_cell=counter_2;
    /*SPR 15604 START */
    intra_freq_ncl_idx = p_rrm_cellconfig->ran_info.
        ncl_params.lte_ncl.num_valid_intra_freq_cell;
    inter_freq_ncl_idx= p_rrm_cellconfig->ran_info.
        ncl_params.lte_ncl.num_valid_inter_freq_cell;

    max_lte_cell_entries_nliu = oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->NeighborListInUse,"MaxLTECellEntries"));
    lte_cell_num_entries_nliu = oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->NeighborListInUse,"LTECellNumberOfEntries"));
    if(lte_cell_num_entries_nliu > max_lte_cell_entries_nliu)
    {
        OAM_LOG(OAM, OAM_WARNING,"Fail Because MaxLTECellEntries < LTECellNumberOfEntries");
        return OAM_FAILURE;
    }
    for(nliu_counter = OAM_ZERO;nliu_counter < lte_cell_num_entries_nliu;nliu_counter++)
    {
        rrm_oam_eutran_global_cell_id_t temp_ecgi;
        oam_memset(&temp_ecgi,OAM_ZERO,sizeof(rrm_oam_eutran_global_cell_id_t));

        if((intra_freq_ncl_idx + inter_freq_ncl_idx) == OAM_MAX_LTE_NBR_CELL_NUM_ENTRIES)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Max number of LTECell Entries populated.");
            break;
        }
        UInt32 eutra_carrier_arfcn=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->NeighborListInUse,"EUTRACarrierARFCN"));
        if(eutra_carrier_arfcn == earfcn_val)
        {
            /* Population of IntraFreq cells present in NLIU */
            p_rrm_cellconfig->ran_info.
                ncl_params.bitmask |= RRM_OAM_LTE_NCL_PRESENT;
            p_rrm_cellconfig->ran_info.
                bitmask |= RRM_OAM_NCL_PARAMS_PRESENT;

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->NeighborListInUse,"PLMNID"),OAM_INVALID_STR)!= OAM_ZERO)
            {
                temp = (char *)oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,"PLMNID");
                oam_convert_plmnid(temp_plmnid,temp);

                oam_fill_mcc_mnc_from_plmnid(temp_plmnid , &(temp_ecgi.primary_plmn_id));


                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->NeighborListInUse,"CID"));



                oam_conversion_from_int_to_byte_string(temp_ecgi.cell_identity,
                        lclTemp_value,OAM_CELL_ID_BITSTRING_SIZE);

                /* Check if the Neighbour CEll
                 * is already populated in RRM's ncl list. */

                for(indx = OAM_ZERO;
                        indx < p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.num_valid_intra_freq_cell;
                        indx++)
                {
                    if(OAM_ZERO == oam_memcmp((void *)&temp_ecgi,
                                (void *)&p_rrm_cellconfig->ran_info.
                                ncl_params.lte_ncl.intra_freq_cells[indx].cell_id,
                                sizeof(temp_ecgi)))
                    {
                        duplicate_nbr_found = OAM_TRUE;
                        break;
                    }

                }
                if(duplicate_nbr_found)
                    continue;

                oam_memcpy((void *)&p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].cell_id,
                        (void *)&temp_ecgi,
                        sizeof(temp_ecgi));

                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].bitmask
                    |= RRM_OAM_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT;


            }
            /*  coverity 93922 fix start */
            lclTemp_value2=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->NeighborListInUse,"PhyCellID"));

            if  (          /* Coverity 54899 fix start */
                    ((lclTemp_value2 > MIN_PHY_CELL_ID) || (lclTemp_value2 == MIN_PHY_CELL_ID))
                    /* Coverity 54899 fix end */
                    &&
                    lclTemp_value2 <= MAX_PHY_CELL_ID
                )
            {
                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].phy_cell_id=
                    (U16)lclTemp_value2;
            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of PhyCellID is %d and range is from %d to %d",
                        lclTemp_value2,MIN_PHY_CELL_ID,MIN_PHY_CELL_ID);
                /*  coverity 93922 fix end */
                return OAM_FAILURE;
            }

            parmeter_value = (char *)oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,"QOffset");

            oam_search_integer_to_interger(parmeter_value,RAN_NeighborList_LTECell_QOffset[OAM_ZERO],OAM_THIRTY_ONE);

            lclTemp_value = oam_atoi(parmeter_value);

            if
                (
                 lclTemp_value >= MIN_Q_OFFSET_CELL
                 &&
                 lclTemp_value <= MAX_Q_OFFSET_CELL
                )
                {
                    /* coverity 35727*/
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].q_offset=(rrm_oam_q_offset_range_et)lclTemp_value;
                }
            else
            {

                OAM_LOG(OAM, OAM_WARNING,
                        "Value of QOffset is %d and range is from %d to %d",
                        lclTemp_value,MIN_Q_OFFSET_CELL,MAX_Q_OFFSET_CELL);
                return OAM_FAILURE;
            }

            parmeter_value = (char *)oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,"QOffset");

            oam_search_integer_to_interger(parmeter_value,RAN_NeighborList_LTECell_QOffset[OAM_ZERO],OAM_THIRTY_ONE);

            lclTemp_value = oam_atoi(parmeter_value);

            if
                (
                 lclTemp_value >= MIN_Q_OFFSET_CELL
                 &&
                 lclTemp_value <= MAX_Q_OFFSET_CELL
                )
                {
                    /* coverity 35727*/
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].q_offset=(rrm_oam_q_offset_range_et)lclTemp_value;
                }
            else
            {

                OAM_LOG(OAM, OAM_WARNING,
                        "Value of QOffset is %d and range is from %d to %d",
                        lclTemp_value,MIN_Q_OFFSET_CELL,MAX_Q_OFFSET_CELL);
                return OAM_FAILURE;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->NeighborListInUse,"CIO"),OAM_INVALID_STR)!= OAM_ZERO)
            {
                parmeter_value = (char *)oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,"CIO");

                oam_search_integer_to_interger(parmeter_value,RAN_NeighborList_LTECell_CIO[OAM_ZERO],OAM_THIRTY_ONE );

                lclTemp_value = oam_atoi(parmeter_value);


                if
                    (
                     lclTemp_value >= MIN_RRM_CELL_INDIV_OFFSET
                     &&
                     lclTemp_value <= MAX_RRM_CELL_INDIV_OFFSET
                    )
                    {
                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].cell_individual_offset=(rrm_oam_q_offset_range_et)lclTemp_value;
                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                            bitmask |= RRM_OAM_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;
                    }
                else
                {
                    if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->NeighborListInUse,"CIO"),OAM_INVALID_STR)!= OAM_ZERO)
                    {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Value of CIO is %d and range is from %d to %d",
                                lclTemp_value,MIN_RRM_CELL_INDIV_OFFSET,MAX_RRM_CELL_INDIV_OFFSET);

                        return OAM_FAILURE;
                    }
                }
            }
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->NeighborListInUse,"RSTxPower"));

            if (
                    lclTemp_value >= MIN_RRM_CELL_SIG_TX
                    &&
                    lclTemp_value <= MAX_RRM_CELL_SIG_TX
               )
            {
                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].r_stx_power=lclTemp_value;
                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                    bitmask |= RRM_OAM_INTRA_FREQ_R_STX_POWER_PRESENT;
            }

            else
            {
                if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->NeighborListInUse,"RSTxPower"),OAM_INVALID_STR)!= OAM_ZERO)
                {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Value of RSTxPower is %d and range is from %d to %d",
                            lclTemp_value,MIN_RRM_CELL_SIG_TX,MAX_RRM_CELL_SIG_TX);

                    return OAM_FAILURE;
                }
            }

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->NeighborListInUse,"Blacklisted"));
            if
                (
                 lclTemp_value >= MIN_BLACKLISTED
                 &&
                 lclTemp_value <= MAX_BLACKLISTED
                )
                {
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].blacklisted=lclTemp_value;
                }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of Blacklisted is %d and range is from %d to %d",
                        lclTemp_value,MIN_BLACKLISTED,MIN_BLACKLISTED);
                return OAM_FAILURE;
            }

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->NeighborListInUse,"X_VENDOR_TAC"));

            if( lclTemp_value != OAM_MINUS_FIVE_HUNDRED )
            {
                oam_conversion_bitstring_short_to_byte_string( p_rrm_cellconfig->ran_info. //BITSTRING FIX
                        ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].tac ,
                        lclTemp_value );

            }

            else
            {
                OAM_LOG(OAM, OAM_INFO,"Value of TAC is %d ",
                        lclTemp_value);
                return OAM_FAILURE;
            }

            /* SPR 15602 START */
            /* Broadcast will be done if Nr status is Locked */
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->NeighborListInUse,"X_VENDOR_NR_STATUS"));
            OAM_LOG(OAM, OAM_INFO," lclTemp_value %d",lclTemp_value);

            /*SPR 15602 END*/
            if( lclTemp_value != OAM_MINUS_FIVE_HUNDRED )
            {
                /* SPR 15602 START */
                if(lclTemp_value == OAM_TWO) /* NR_STATUS is Unlocked */
                {
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].broadcast_status
                        /*Cov 93927 fix start*/
                        = (S32)OAM_FALSE;
                    /*Cov 93927 fix end*/
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                        bitmask |= RRM_OAM_INTRA_FREQ_BROADCAST_STATUS_PRESENT ;
                }
                else
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->NeighborListInUse,"X_VENDOR_BROADCAST_STATUS"));
                    if( lclTemp_value != OAM_MINUS_FIVE_HUNDRED )
                    {

                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].broadcast_status = lclTemp_value;
                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                            bitmask |= RRM_OAM_INTRA_FREQ_BROADCAST_STATUS_PRESENT ;
                    }
                }
            }
            /* SPR 15602 END */

            else
            {
                OAM_LOG(OAM, OAM_INFO,"Value of broascast status is %d ",
                        lclTemp_value);
            }


            /*SPR 16372 fix start*/		
            /* SPR 17408 Fix +- */
            /*SPR 16372 fix stop*/		

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->NeighborListInUse,"X_VENDOR_ACCESS_MODE"));

            /*SPR 16372 fix start*/		
            /* SPR 17408 Fix +- */
            /*SPR 16372 fix stop*/		

            if( lclTemp_value != OAM_MINUS_FIVE_HUNDRED )
            {

                /*SPR 16372 fix start*/		
		/* SPR 17408 Fix +- */
                /*SPR 16372 fix stop*/		
                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].cell_access_mode = (S32)lclTemp_value; /*Coverity CID 85399 Fix */

                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                    bitmask |= RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT ;
            }
            else
            {
                OAM_LOG(OAM, OAM_INFO,"Value of cell access mode is %d ",
                        lclTemp_value);
            }

            /* SPR 17408 Fix Start */
            if(
                    (p_rrm_cellconfig->ran_info.
                     ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                     bitmask & RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT)
                    &&
                    ((p_rrm_cellconfig->ran_info.
                     ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                     /*Cov 93929 fix start*/
                     cell_access_mode == (S32)RRM_OAM_ACCESS_MODE_OPEN)
                    /*Cov 93929 fix end*/
                    ||
                    (p_rrm_cellconfig->ran_info.
                     ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                     cell_access_mode == (S32)RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
              )
            {
                OAM_LOG(OAM, OAM_WARNING, "CSGID will not be read into "
                        "lte_ncl.intra_freq_cells as ACCESS_MODE is present"
                        " and its value is Open/Open Femto");
            }
            else {
                temp = (Char8*)oam_xmlNodeGetContent(
                        p_cell_spec_params->NeighborListInUse,
                        "X_VENDOR_CSGID");

                if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                    OAM_LOG(OAM, OAM_INFO, "X_VENDOR_CSGID is present "
                            "and it value is: %s", temp);

                    /*SPR 16372 fix start*/
                    lclTemp_value = oam_atoi((Char8*)temp);
                    /*SPR 16372 fix stop*/
                    oam_conversion_from_int_to_byte_string(p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.
                            intra_freq_cells[intra_freq_ncl_idx].csg_identity,lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                        bitmask |= RRM_OAM_INTRA_FREQ_CSG_ID_PRESENT;
                }
            }
            /* SPR 17408 Fix End */
            /* SPR 17408 Fix +- */

            if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,
                                "X_VENDOR_HO_STATUS"),OAM_INVALID_STR) != OAM_ZERO))
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->NeighborListInUse,"X_VENDOR_HO_STATUS"));

                /* CID 118462 Fix Start */
                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].ho_status = (S32)lclTemp_value;
                /* CID 118462 Fix End */

                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.intra_freq_cells[intra_freq_ncl_idx].
                    bitmask |= RRM_OAM_INTRA_FREQ_HO_STATUS_PRESENT ;
            }
            else
            {
                OAM_LOG(OAM, OAM_INFO,"X_VENDOR_HO_STATUS is not provided in eNodeB_Data_Model_TR_196_based.xml");
            }
            intra_freq_ncl_idx++;
        }

        else
        {
            if((oam_strcmp
                        ((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->NeighborListInUse,"PLMNID"),OAM_INVALID_STR)!= OAM_ZERO))
            {
                p_rrm_cellconfig->ran_info.
                    ncl_params.bitmask |= RRM_OAM_LTE_NCL_PRESENT;
                p_rrm_cellconfig->ran_info.
                    bitmask |= RRM_OAM_NCL_PARAMS_PRESENT;


                temp = (char *)oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,"PLMNID");
                oam_convert_plmnid(temp_plmnid,(void *)temp);

                oam_fill_mcc_mnc_from_plmnid(temp_plmnid ,
                        &temp_ecgi.primary_plmn_id);


                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->NeighborListInUse,"CID"));


                oam_conversion_from_int_to_byte_string(temp_ecgi.cell_identity,
                        lclTemp_value,OAM_CELL_ID_BITSTRING_SIZE);

                /* Check if the Neighbour CEll
                 * is already populated in RRM's ncl list. */

                for(indx = OAM_ZERO;
                        indx < p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.num_valid_inter_freq_cell;
                        indx++)
                {
                    if(OAM_ZERO == oam_memcmp((void *)&temp_ecgi,
                                (void *)&p_rrm_cellconfig->ran_info.
                                ncl_params.lte_ncl.inter_freq_cells[indx].cell_id,
                                sizeof(temp_ecgi)))
                    {
                        duplicate_nbr_found = OAM_TRUE;
                        break;
                    }

                }
                if(duplicate_nbr_found)
                {
                    duplicate_nbr_found = OAM_FALSE;
                    continue;

                }

                oam_memcpy((void *)&p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].cell_id,
                        (void *)&temp_ecgi,
                        sizeof(temp_ecgi));


                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].bitmask
                    |= RRM_OAM_INTER_FREQ_GLOBAL_CELL_ID_PRESENT;
            }

            /* SPR 17525 changes start */
            oam_xml_find_ptr(p_cell_spec_params->NeighborListInUse->children,&temp_node,"LTECell");
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        (xmlNode *)temp_node, "PhyCellID"));
            /* SPR 17525 changes ends */
            if
                (
                 lclTemp_value >= MIN_PHY_CELL_ID
                 &&
                 lclTemp_value <= MAX_PHY_CELL_ID
                )
                {
                    p_rrm_cellconfig->ran_info.
                        /*  coverity 94761 fix start */
                        ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].phy_cell_id=(U16)lclTemp_value;
                    /*  coverity 94761 fix end */
                }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of PhyCellID is %d and range is from %d to %d",
                        lclTemp_value,MIN_PHY_CELL_ID,MAX_PHY_CELL_ID);
                return OAM_FAILURE;
            }

            /* SPR 17525 changes start */
            parmeter_value = (char *)oam_xmlNodeGetContent((xmlNode *)temp_node,"QOffset");
            /* SPR 17525 changes ends */

            oam_search_integer_to_interger(parmeter_value,RAN_NeighborList_LTECell_QOffset[OAM_ZERO],31);

            lclTemp_value = oam_atoi(parmeter_value);

            if
                (
                 lclTemp_value >= MIN_Q_OFFSET_CELL
                 &&
                 lclTemp_value <= MAX_Q_OFFSET_CELL
                )
                    p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].q_offset=(rrm_oam_q_offset_range_et)lclTemp_value;
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of QOffset is %d and range is from %d to %d",
                        lclTemp_value,MIN_Q_OFFSET_CELL,MAX_Q_OFFSET_CELL);
                return OAM_FAILURE;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->NeighborListInUse,"CIO"),OAM_INVALID_STR)!= OAM_ZERO)
            {
                parmeter_value = (char *)oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,"CIO");
                oam_search_integer_to_interger(parmeter_value,RAN_NeighborList_LTECell_CIO[OAM_ZERO],31);

                lclTemp_value = oam_atoi(parmeter_value);
                if
                    (
                     lclTemp_value >= MIN_RRM_CELL_INDIV_OFFSET
                     &&
                     lclTemp_value <= MAX_RRM_CELL_INDIV_OFFSET
                    ){
                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].cell_individual_offset=(rrm_oam_q_offset_range_et)lclTemp_value;

                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                            bitmask |= RRM_OAM_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;
                    }else
                    {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Value of CIO is %d and range is from %d to %d",
                                lclTemp_value,MIN_RRM_CELL_INDIV_OFFSET,MAX_RRM_CELL_INDIV_OFFSET);

                        return OAM_FAILURE;
                    }

            }

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->NeighborListInUse,"RSTxPower"));
            if
                (
                 lclTemp_value >= MIN_RRM_CELL_SIG_TX
                 &&
                 lclTemp_value <= MAX_RRM_CELL_SIG_TX
                )
                {
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].r_stx_power=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                        bitmask |= RRM_OAM_INTER_FREQ_RSTX_POWER_PRESENT;

                }
            else
            {
                if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->NeighborListInUse,"RSTxPower"),OAM_INVALID_STR)!= OAM_ZERO)
                {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Value of RSTxPower is %d and range is from %d to %d",
                            lclTemp_value,MIN_RRM_CELL_SIG_TX,MAX_RRM_CELL_SIG_TX);

                    return OAM_FAILURE;
                }

            }

            /* SPR 17525 changes start */
            /* code removed */
            /* SPR 17525 changes ends */
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        /* SPR 17525 changes start */
                        (xmlNode *)temp_node, "EUTRACarrierARFCN"));
            /* SPR 17525 changes ends */            
            if
                (
                 lclTemp_value >= MIN_EUTRA_CARRIER_ARFCN
                 &&
                 lclTemp_value <= MAX_EUTRA_CARRIER_ARFCN
                )
                {
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].eutra_carrier_arfcn=(U32)lclTemp_value;
                }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of EUTRACarrierARFCN is %d and range is from %d to %d",
                        lclTemp_value,MIN_EUTRA_CARRIER_ARFCN,MAX_EUTRA_CARRIER_ARFCN);

                return OAM_FAILURE;
            }


            /* lte cell tag add*/
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        /* SPR 17525 changes start */
                        (xmlNode *)temp_node,"X_VENDOR_TAC"));
            /* SPR 17525 changes ends */

            if( lclTemp_value != OAM_MINUS_FIVE_HUNDRED )
            {
                oam_conversion_bitstring_short_to_byte_string( p_rrm_cellconfig->ran_info. //BITSTRING FIX
                        ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].tac ,
                        lclTemp_value );
            }
            else
            {
                OAM_LOG(OAM, OAM_INFO,"Value of TAC is %d ",
                        lclTemp_value);
                return OAM_FAILURE;
            }

            /* Broadcast will be done if Nr status is Locked */
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        /* SPR 17525 changes start */
                        (xmlNode *)temp_node, "X_VENDOR_NR_STATUS"));
            /* SPR 17525 changes ends */

            if( lclTemp_value != OAM_MINUS_FIVE_HUNDRED )
            {
                /* SPR 15602 START */
                if(lclTemp_value == OAM_TWO) /* NR_STATUS is Unlocked */
                {
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].broadcast_status
                        /*Cov 93928_93925 fix start*/
                        = (S32)OAM_FALSE;
                    /*Cov 93928_93925 fix end*/
                    p_rrm_cellconfig->ran_info.
                        ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                        bitmask |= RRM_OAM_INTER_FREQ_BROADCAST_STATUS_PRESENT ;
                }
                else
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->NeighborListInUse,"X_VENDOR_BROADCAST_STATUS"));
                    if( lclTemp_value != OAM_MINUS_FIVE_HUNDRED )
                    {

                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].broadcast_status
                            = (S32)lclTemp_value;   /* coverity_fix 86788 +-*/
                        p_rrm_cellconfig->ran_info.
                            ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                            bitmask |= RRM_OAM_INTER_FREQ_BROADCAST_STATUS_PRESENT ;
                    }
                }
            }
            /* SPR 15602 END */

            else
            {
                OAM_LOG(OAM, OAM_INFO,"Value of broascast status is %d ",
                        lclTemp_value);
            }

            /*SPR 16372 fix start*/	
            /* SPR 17408 Fix +- */	
            /*SPR 16372 fix stop*/		

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        /* SPR 17525 changes start */
                        (xmlNode *)temp_node, "X_VENDOR_ACCESS_MODE"));
            /* SPR 17525 changes ends */

            /*SPR 16372 fix start*/		
            /* SPR 17408 Fix +- */	
            /*SPR 16372 fix stop*/		
            if( lclTemp_value != OAM_MINUS_FIVE_HUNDRED )
            {

                /*SPR 16372 fix start*/		
		/* SPR 17408 Fix +- */	
                /*SPR 16372 fix stop*/		
                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].cell_access_mode
                    /*Cov 93930 fix start*/
                    = (UInt32)lclTemp_value;
                /*Cov 93930 fix end*/

                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                    bitmask |= RRM_OAM_CELL_ACCESS_MODE_PRESENT ;
            }
            else
            {
                OAM_LOG(OAM, OAM_INFO,"Value of cell access mode is %d ",
                        lclTemp_value);
            }

            /* SPR 17408 Fix Start */
            if(
                    (p_rrm_cellconfig->ran_info.
                     ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                     bitmask & RRM_OAM_CELL_ACCESS_MODE_PRESENT)
                    &&
                    ((p_rrm_cellconfig->ran_info.
                     ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                     cell_access_mode == (S32)RRM_OAM_ACCESS_MODE_OPEN) // coverity_fix 86789 +-
                    ||
                    (p_rrm_cellconfig->ran_info.
                     ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                     cell_access_mode == (S32)RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
              )
            {
                OAM_LOG(OAM, OAM_WARNING, "CSGID will not be read into "
                        "lte_ncl.inter_freq_cells as ACCESS_MODE is present"
                        " and its value is Open/Open Femto");
            }
            else {
                temp = (Char8*)oam_xmlNodeGetContent(
                        /* SPR 17525 changes start */
                        (xmlNode *)temp_node,
                        /* SPR 17525 changes ends */
                        "X_VENDOR_CSGID");

                if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {

                    /*SPR 16372 fix start*/
                    lclTemp_value = oam_atoi((Char8*)temp);
                    /*SPR 16372 fix stop*/
                    OAM_LOG(OAM, OAM_INFO, "X_VENDOR_CSGID is present "
                            "and it value is: %s", temp);

                    oam_conversion_from_int_to_byte_string(
                            p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.
                            intra_freq_cells[inter_freq_ncl_idx].csg_identity,
                            lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);

                    p_rrm_cellconfig->
                        ran_info.ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                        bitmask |= RRM_OAM_INTER_FREQ_CSG_ID_PRESENT;
                }
            }
            /* SPR 17408 Fix End */
            /* SPR 17408 Fix +- */

            if((oam_strcmp((const char *)oam_xmlNodeGetContent(
                                /* SPR 17525 changes start */
                                (xmlNode *)temp_node,"X_VENDOR_HO_STATUS"),
                            /* SPR 17525 changes ends */
                            OAM_INVALID_STR) != OAM_ZERO))
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            /* SPR 17525 changes start */
                            (xmlNode *)temp_node, "X_VENDOR_HO_STATUS"));
                /* SPR 17525 changes ends */

                /* CID 118462 Fix Start */
                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].ho_status = (S32)lclTemp_value;
                /* CID 118462 Fix End */

                p_rrm_cellconfig->ran_info.
                    ncl_params.lte_ncl.inter_freq_cells[inter_freq_ncl_idx].
                    bitmask |= RRM_OAM_INTER_FREQ_HO_STATUS_PRESENT ;
            }
            else
            {
                OAM_LOG(OAM, OAM_INFO,"X_VENDOR_HO_STATUS is not provided in eNodeB_Data_Model_TR_196_based.xml");
            }

            inter_freq_ncl_idx++;
        }

    }
    p_rrm_cellconfig->ran_info.
        ncl_params.lte_ncl.num_valid_intra_freq_cell=intra_freq_ncl_idx;
    p_rrm_cellconfig->ran_info.
        ncl_params.lte_ncl.num_valid_inter_freq_cell=inter_freq_ncl_idx;

    /*SPR 15604 END */
    /* Spr 17753 Changes Start*/
    /* Populate the serving cell PCI based on list and neighbors PCI */
    oam_populate_serving_cell_phy_cell_id(p_rrm_cellconfig,p_cell_spec_params);
    /* Spr 17753 Changes End*/


    /*1.0 Fix Params Add Start*/
    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"FilterCoefficientRSRP"),RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_ZERO],OAM_FIFTEEN);

    if 
        (
         lclTemp_value >= MIN_FILTER_COEFFICIENT_RSRP
         && 
         lclTemp_value <= MAX_FILTER_COEFFICIENT_RSRP
        )
        {
            /* coverity 35767 */
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                filter_coefficient_rsrp=(rrm_filter_coefficient_et)lclTemp_value; 


            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.bitmask|=
                RRM_OAM_COMMON_PARAMS_FOR_EUTRA_PRESENT;

        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of FilterCoefficientRSRP is %d and range is from 0 to 15",
                lclTemp_value);
        return OAM_FAILURE;
    }


    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"FilterCoefficientRSRQ"),RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_ZERO],OAM_FIFTEEN);

    if 
        (
         lclTemp_value >= MIN_FILTER_COEFFICIENT_RSRQ
         && 
         lclTemp_value <= MAX_FILTER_COEFFICIENT_RSRQ
        )
        {

            /* coverity 35768 */
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                filter_coefficient_rsrq=(rrm_filter_coefficient_et)lclTemp_value;

        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of FilterCoefficientRSRQ is %d and range is from 0 to 15",
                lclTemp_value);

        return OAM_FAILURE;
    }



    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A1ThresholdRSRP"));
    if 
        (
         lclTemp_value >= MIN_A1_THRESHOLD_RSRP
         && 
         lclTemp_value <= MAX_A1_THRESHOLD_RSRP
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a1_threshold_rsrp=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A1ThresholdRSRP is %d and range is from 0 to 97",
                lclTemp_value);

        return OAM_FAILURE;
    }




    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A1ThresholdRSRQ"));
    if 
        (
         lclTemp_value >= MIN_A1_THRESHOLD_RSRQ
         && 
         lclTemp_value <= MAX_A1_THRESHOLD_RSRQ
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a1_threshold_rsrq=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A1ThresholdRSRQ is %d and range is from 0 to 34",
                lclTemp_value);

        return OAM_FAILURE;
    }



    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A2ThresholdRSRP"));
    if 
        (
         lclTemp_value >= MIN_A2_THRESHOLD_RSRP 
         && 
         lclTemp_value <= MAX_A2_THRESHOLD_RSRP
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a2_threshold_rsrp=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A2ThresholdRSRP is %d and range is from 0 to 97",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A2ThresholdRSRQ"));
    if 
        (
         lclTemp_value >= MIN_A2_THRESHOLD_RSRQ
         && 
         lclTemp_value <= MAX_A2_THRESHOLD_RSRQ
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a2_threshold_rsrq=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A2ThresholdRSRQ is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A3Offset"));

    if 
        (
         lclTemp_value >= MIN_A3_OFFSET 
         && 
         lclTemp_value <= MAX_A3_OFFSET
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a3_offset=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A3Offset is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }



    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"ReportOnLeave"));
    if 
        (
         lclTemp_value >= MIN_REPORT_ON_LEAVE
         && 
         lclTemp_value <= MAX_REPORT_ON_LEAVE
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                report_on_leave=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ReportOnLeave is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A4ThresholdRSRP"));
    if 
        (
         lclTemp_value >= MIN_A4_THRESHOLD_RSRP
         && 
         lclTemp_value <= MAX_A4_THRESHOLD_RSRP
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a4_threshold_rsrp=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A4ThresholdRSRP is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }



    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A4ThresholdRSRQ"));
    if 
        (
         lclTemp_value >= MIN_A4_THRESHOLD_RSRQ
         && 
         lclTemp_value <= MAX_A4_THRESHOLD_RSRQ
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a4_threshold_rsrq=lclTemp_value;	

        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A4ThresholdRSRQ is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A5Threshold1RSRP"));
    if 
        (
         lclTemp_value >= MIN_A5_THRESHOLD_1RSRP
         && 
         lclTemp_value <= MAX_A5_THRESHOLD_1RSRP
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a5_threshold_1rsrp=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A5Threshold1RSRP is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A5Threshold1RSRQ"));
    if 
        (
         lclTemp_value >= MIN_A5_THRESHOLD_1RSRQ
         && 
         lclTemp_value <= MAX_A5_THRESHOLD_1RSRQ
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a5_threshold_1rsrq=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A5Threshold1RSRQ is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }



    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A5Threshold2RSRP"));
    if 
        (
         lclTemp_value >= MIN_A5_THRESHOLD_2RSRP
         && 
         lclTemp_value <= MAX_A5_THRESHOLD_2RSRP
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a5_threshold_2rsrp=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A5Threshold2RSRP is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }



    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"A5Threshold2RSRQ"));
    if 
        (
         lclTemp_value >= MIN_A5_THRESHOLD_2RSRQ
         && 
         lclTemp_value <= MAX_A5_THRESHOLD_2RSRQ
        )
        {

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a5_threshold_2rsrq=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of A5Threshold2RSRQ is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"Hysteresis"));
    if 
        (
         lclTemp_value >= MIN_HYSTERESIS
         && 
         lclTemp_value <= MAX_HYSTERESIS
        )
        {
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                hysteresis=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of Hysteresis is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }



    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"TimeToTrigger"),RAN_Mobility_ConnMode_EUTRA_TimeToTrigger[OAM_ZERO],OAM_SIXTEEN);

    if 
        (
         lclTemp_value >= MIN_TIME_TO_TRIGGER
         && 
         lclTemp_value <= MAX_TIME_TO_TRIGGER
        )
        {
            /* coverity 35782 */
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                time_to_trigger=(rrmc_time_to_trigger_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of TimeToTrigger is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"TriggerQuantity"),TriggerQuantity, OAM_TWO);

    if 
        (
         lclTemp_value >= MIN_TRIGGER_QUANTITY
         && 
         lclTemp_value <= MAX_TRIGGER_QUANTITY
        )
        {
            /* coverity 35783 */ 
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                trigger_quantity=(rrmc_trigger_quantity_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of TriggerQuantity is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"ReportQuantity"),ReportQuantity, OAM_TWO);
    if 
        (
         lclTemp_value >= MIN_REPORT_QUANTITY
         && 
         lclTemp_value <= MAX_REPORT_QUANTITY
        )
        {
            /* coverity 35777 */
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                report_quantity=(rrmc_report_quantity_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ReportQuantity is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"ReportInterval"),RAN_Mobility_ConnMode_EUTRA_ReportInterval[OAM_ZERO],OAM_THIRTEEN);

    if 
        (
         lclTemp_value >= MIN_REPORT_INTERVAL
         && 
         lclTemp_value <= MAX_REPORT_INTERVAL
        )
        {
            /* coverity 35776 */
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                report_interval=(rrmc_report_interval_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ReportInterval is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }


    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"ReportAmount"),RAN_Mobility_ConnMode_EUTRA_ReportAmount[OAM_ZERO],OAM_EIGHT);
    if 
        (
         lclTemp_value >= MIN_REPORT_AMOUNT
         && 
         lclTemp_value <= MAX_REPORT_AMOUNT
        )
        {

            /* coverity 35775 */
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                report_amount=(rrmc_report_amount_et)lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ReportAmount is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;

    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"X_VENDOR_PS_HO_ENABLED"));
    if 
        (
         lclTemp_value >= MIN_PS_HO_ENABLED
         && 
         lclTemp_value <= MAX_PS_HO_ENABLED
        )
        {
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                ps_ho_enabled=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of X_VENDOR_PS_HO_ENABLED is %d and range is from 1 to 6",
                lclTemp_value);

        return OAM_FAILURE;
    }
    /* SPR 20653 Fix Start */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"X_VENDOR_DELAYED_A3_ENABLED"));
    if 
        (
         lclTemp_value >= MIN_DELAYED_A3_ENABLED
         && 
         lclTemp_value <= MAX_DELAYED_A3_ENABLED
        )
        {
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                delayed_a3_enabled=(rrm_bool_t)lclTemp_value;
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.bitmask |= RRM_OAM_DELAYED_A3_ENABLED_PRESENT;
        }
    else
    {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of X_VENDOR_DELAYED_A3_ENABLED is %d and range is from 0 to 1",
                lclTemp_value);

        return OAM_FAILURE;
    }
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"X_VENDOR_A4_MEAS_CFG_ENABLED"));
    if 
        (
         lclTemp_value >= MIN_A4_MEAS_CFG_ENABLED
         && 
         lclTemp_value <= MAX_A4_MEAS_CFG_ENABLED
        )
        {
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                a4_meas_cfg_enabled=(rrm_bool_t)lclTemp_value;
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.bitmask |= RRM_OAM_A4_MEAS_CONFIG_ENABLED_PRESENT;
        }
    else
    {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of X_VENDOR_A4_MEAS_CFG_ENABLED is %d and range is from 0 to 1",
                lclTemp_value);

        return OAM_FAILURE;
    }
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EUTRA,"X_VENDOR_S_MEASURE"));
    if 
        (
         lclTemp_value >= MIN_SMEASURE
         && 
         lclTemp_value <= MAX_SMEASURE
        )
        {
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.common_params_for_eutra.
                s_measure=lclTemp_value;
        }
    else
    {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of X_VENDOR_S_MEASURE is %d and range is from 0 to 97",
                lclTemp_value);

        return OAM_FAILURE;
    }
    /* SPR 20653 Fix End */
    /*bug fix 985 start*/ 
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->EUTRA,"MaxReportCells"));
    p_rrm_cellconfig->ran_info.connected_mode_mobility_params.common_params_for_eutra.max_report_cells=lclTemp_value;
    /*bug fix 985 end*/ 

    /*1.0 Fix Params Add End*/
    /*2.0 Params Add Start*/


    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERAN,
            "TReselectionGERAN");
    if(oam_strcmp(temp, OAM_INVALID_STR)) {
        p_rrm_cellconfig->ran_info.
            bitmask |= RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT;

        lclTemp_value = oam_atoi(temp);


        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.
            geran_reselection_params.t_reselection_geran = (U8)lclTemp_value;	
    }


    /* START SPR_6719_FIX */

    diff1 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERAN,
                "TReselectionGERANSFMedium"), OAM_INVALID_STR);

    diff2 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERAN,
                "TReselectionGERANSFHigh"), OAM_INVALID_STR);
    if(diff1 && diff2) {
        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERAN,
                "TReselectionGERANSFMedium");
        lclTemp_value =
            /* CSR 00070293 FIX START */
            oam_xml_search_integer_to_integer(temp, RRM_CELL_TRESELECTIONSF[OAM_ZERO],
                    TRESELECTIONSF_COUNT);
        /* CSR 00070293 FIX END */

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.
            geran_reselection_params.
            bitmask |= RRM_OAM_T_RESELECTION_GERAN_SPEED_SCALE_FACTOR_PRESENT;

        /* coverity 35676 */
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.
            geran_reselection_params.speed_scale_factors.
            t_reselection_eutra_sf_medium = (rrm_oam_speed_state_scale_factors_et)lclTemp_value;


        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERAN,
                "TReselectionGERANSFHigh");
        /* CSR 00070293 FIX START */
        lclTemp_value = oam_xml_search_integer_to_integer(temp,
                RRM_CELL_TRESELECTIONSF[OAM_ZERO],
                TRESELECTIONSF_COUNT);
        /* CSR 00070293 FIX END */
        /* coverity 35675 */
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.
            geran_reselection_params.speed_scale_factors.
            t_reselection_eutra_sf_high = (rrm_oam_speed_state_scale_factors_et)lclTemp_value;
    }	


    /* END SPR_6719_FIX */

    /* mobility bitmask change activity 21 march*/

    /* Population of measurement configuration of GERAN starts */

    /* RT SPR 9019 FIX START */
    /* LINES MOVED to oam_xml_function.c */
    /* coverity 56659 */ 

    /* SPR 14651 START/END Code Removed */
    /* RT SPR 9019 FIX END */

    /* SPR 14651 START*/
    num_entries = oam_atoi((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERAN,
                "GERANFreqGroupNumberOfEntries"));
    meas_count = OAM_ZERO;

    for(count = OAM_ZERO; count < num_entries; ++count) {

        geran_meas_enable = oam_atoi((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "Enable"));

        if(geran_meas_enable)
        {
            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "BCCHARFCN");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);  
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].carrier_freq.starting_arfcn = (U16)lclTemp_value;
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Mandatory parameter BCCHARFCN[%d] is missing", count);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            /****** SPR_6719_FIX ****/
            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "BandIndicator");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value =
                    oam_xml_search_string_to_integer(temp, RRM_GERANFREQ_BANDINDICATOR,
                            GERANFREQ_BANDINDICATOR_COUNT);  
                /* coverity 35680 */ 
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].carrier_freq.band_indicator = (rrm_oam_carrier_freq_geran_band_indicator_et)lclTemp_value;
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Mandatory parameter BandIndicator[%d] is missing", count);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }


            /*********************/
            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "CellReselectionPriority");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].common_info.present_bitmask |= RRM_OAM_CARRIER_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG ;

                lclTemp_value = oam_atoi(temp);  

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].common_info.
                    cell_reselection_priority = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "X_VENDOR_NCC_PERMITTED");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp); 
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].common_info.
                    ncc_peritted[OAM_ZERO] = (U8)lclTemp_value;	
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "QRxLevMin");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].common_info.q_rx_lev_min = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "X_VENDOR_P_MAX_GERAN");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].common_info.present_bitmask |= RRM_OAM_CARRIER_GERAN_P_MAX_GERAN_PRESENCE_FLAG;

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].common_info.p_max_geran = (U8)lclTemp_value;
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "ThreshXHigh");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].common_info.thres_x_high = (U8)lclTemp_value;	
            }

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "ThreshXLow");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(temp);
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].common_info.thres_x_low = (U8)lclTemp_value;	
            }


            UInt32 num_exp_arfcn = OAM_ZERO;
            UInt16 out_exp_arfcn_arr[MAX_EXPL_ARFCNS] = {0};
            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "X_VENDOR_EXPLICIT_ARFCN_LIST");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                num_exp_arfcn =  oam_tokenize_string_to_u16(temp, ",",  
                        MAX_EXPL_ARFCNS,
                        out_exp_arfcn_arr);

                if(num_exp_arfcn > 0) {
                    p_rrm_cellconfig->ran_info.
                        mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_geran_params.
                        carrier_freq_info_list.carrier_list[meas_count].carrier_freq.
                        following_arfcn.
                        presence_bitmask |= RRM_OAM_GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG;
                }

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].carrier_freq.following_arfcn.
                    explicit_list_of_arfcns.count_explicit_arfcn = (U8)num_exp_arfcn;

                for(count1 = OAM_ZERO; count1 < num_exp_arfcn; ++count1) {
                    p_rrm_cellconfig->
                        ran_info.mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_geran_params.
                        carrier_freq_info_list.carrier_list[meas_count].
                        carrier_freq.following_arfcn.explicit_list_of_arfcns.
                        data_explicit_arfcn[count1] = out_exp_arfcn_arr[count1];
                }
            }

            diff1 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                        "X_VENDOR_ARFCN_SPACING"), OAM_INVALID_STR);

            diff2 = oam_strcmp((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                        "X_VENDOR_NUM_OF_FOLLOWING_ARFCNS"), OAM_INVALID_STR);
            if(diff1 && diff2) {
                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].carrier_freq.following_arfcn.
                    presence_bitmask |= RRM_OAM_GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG;

                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                        "X_VENDOR_ARFCN_SPACING");
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].carrier_freq.following_arfcn.equally_spaced_arfcns.
                    arfcn_spacing = (U8)lclTemp_value;

                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                        "X_VENDOR_NUM_OF_FOLLOWING_ARFCNS");
                lclTemp_value = oam_atoi(temp);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].carrier_freq.following_arfcn.equally_spaced_arfcns.
                    num_of_following_arfcns = (U8)lclTemp_value;
            }

            SInt32 num_var_bimap = OAM_ZERO;
            UInt8 bitmap_arr[MAX_VAR_BITMAP_OF_ARFCNS] = {0};
            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[count],
                    "X_VENDOR_ARFCN_BITMAP");
            if(oam_strcmp(temp, OAM_INVALID_STR)) {
                num_var_bimap = oam_tokenize_string_to_bitmap_array(temp, ",",
                        MAX_VAR_BITMAP_OF_ARFCNS, bitmap_arr);

                p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.
                    carrier_list[meas_count].carrier_freq.following_arfcn.
                    var_bitmap_of_arfcns.count_var_bit_map = (U8)num_var_bimap;

                if(num_var_bimap > 0) {
                    p_rrm_cellconfig->ran_info.
                        mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_geran_params.
                        carrier_freq_info_list.carrier_list[meas_count].carrier_freq.
                        following_arfcn.
                        presence_bitmask |= RRM_OAM_GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG;
                }



                if(num_var_bimap > 0) {
                    oam_memcpy(p_rrm_cellconfig->ran_info.
                            mobility_params.idle_mode_mobility_params.
                            idle_mode_mobility_inter_rat_geran_params.
                            carrier_freq_info_list.carrier_list[meas_count].
                            carrier_freq.following_arfcn.var_bitmap_of_arfcns.
                            data_var_bitmap,
                            bitmap_arr,
                            num_var_bimap);

                }
            }
            meas_count++; 
        }
    }
    if(meas_count) {
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.count_geran_carrier = meas_count;

        p_rrm_cellconfig->ran_info.
            bitmask |= RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.
            bitmask |= RRM_OAM_GERAN_CARRIER_FREQ_PARAMETER;

    }
    /* SPR 14651 END */
    /* RT SPR 8154 FIX END */

    /*Mobility Params Starts here*/

    /* Mobility bitmask change 21 march */
    SInt8 SearchWindowSize = OAM_ZERO;
    SInt8 pre_reg_allowed = OAM_ZERO;
    SInt8 csfb_support_for_dual_rx_ues_r9 = OAM_ZERO;
    SInt8 ac_barring_0_to_9_r9 = OAM_ZERO;

    SearchWindowSize = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"SearchWindowSize"),OAM_INVALID_STR);
    pre_reg_allowed = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_PRE_REG_INFO_HRPD,"PRE_REG_ALLOWED"),OAM_INVALID_STR);
    csfb_support_for_dual_rx_ues_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9"),OAM_INVALID_STR);
    ac_barring_0_to_9_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"X_VENDOR_AC_BARRING_0_TO_9_R9"),OAM_INVALID_STR);

    if(
            (SearchWindowSize != OAM_ZERO)
            ||	
            (pre_reg_allowed != OAM_ZERO)
            || 
            (csfb_support_for_dual_rx_ues_r9 != OAM_ZERO)
            || 
            (ac_barring_0_to_9_r9 != OAM_ZERO)
      )
    { 
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT;
    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"SearchWindowSize"),OAM_INVALID_STR)!= OAM_ZERO))
    { 
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000,"SearchWindowSize"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask |= RRM_OAM_SEARCH_WIN_SIZE_PRESENCE_FLAG;


        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            search_window_size = lclTemp_value;
    }

    SInt8 QoffsettUTRA = OAM_ZERO,
          FilterCoefficientUTRA = OAM_ZERO,
          QoffsetGERAN = OAM_ZERO,
          FilterCoefficientGERAN = OAM_ZERO,
          Hysteresis = OAM_ZERO,
          TimeToTrigger = OAM_ZERO,
          MaxReportCells = OAM_ZERO,
          ReportInterval = OAM_ZERO,
          ReportAmount = OAM_ZERO;

    QoffsettUTRA = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"QoffsettUTRA"),OAM_INVALID_STR);
    FilterCoefficientUTRA = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"FilterCoefficientUTRA"),OAM_INVALID_STR);
    QoffsetGERAN = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"QoffsetGERAN"),OAM_INVALID_STR);
    FilterCoefficientGERAN = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"FilterCoefficientGERAN"),OAM_INVALID_STR);
    Hysteresis = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"Hysteresis"),OAM_INVALID_STR);
    TimeToTrigger = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"TimeToTrigger"),OAM_INVALID_STR);
    MaxReportCells = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"MaxReportCells"),OAM_INVALID_STR);
    ReportInterval = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"ReportInterval"),OAM_INVALID_STR);
    ReportAmount = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"ReportAmount"),OAM_INVALID_STR);


    if((QoffsettUTRA != OAM_ZERO)
            &&(FilterCoefficientUTRA != OAM_ZERO)
            &&(QoffsetGERAN != OAM_ZERO)
            &&(FilterCoefficientGERAN != OAM_ZERO)
            &&(Hysteresis != OAM_ZERO)
            &&(TimeToTrigger != OAM_ZERO)
            &&(MaxReportCells != OAM_ZERO)
            &&(ReportInterval != OAM_ZERO)
            &&(ReportAmount != OAM_ZERO))
    {

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"QoffsettUTRA"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.qoffset_tutra=lclTemp_value;

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"FilterCoefficientUTRA"),RAN_Mobility_ConnMode_IRAT_FilterCoefficientUTRA[OAM_ZERO],OAM_FIFTEEN);

        /* coverity 35759 */
        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.filter_coefficient_utra=(rrm_filter_coefficient_et)lclTemp_value;
        /* CSR00053377_CHANGES_START */
        if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
                        /* spr_21013_fix_start */
                        xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"FDDMode",oam_strlen("FDDMode")+1))
            /* spr_21013_fix_end */
        {
            if((oam_strcmp
                        ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"MeasQuantityUTRAFDD"),OAM_INVALID_STR)!= OAM_ZERO))
            {
                lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->IRAT_2,"MeasQuantityUTRAFDD"),MeasQuantityUTRAFDD, OAM_TWO);
                /* coverity 35760 */
                p_rrm_cellconfig->ran_info.
                    connected_mode_mobility_params.irat.meas_quantity_utra_fdd=(rrm_irat_measquanutrafdd_et)lclTemp_value;

                p_rrm_cellconfig->ran_info.connected_mode_mobility_params.irat.bitmask |= RRM_OAM_MEAS_QUANUTRA_FDD_PRESENT;
            }
        }
        else if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
                        /* spr_21013_fix_start */
                        xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"TDDMode",oam_strlen("TDDMode")+1))
            /* spr_21013_fix_end */
        {
            lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"X_VENDOR_MeasQuantityUTRATDD"),MeasQuantityUTRATDD, OAM_TWO);

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.meas_quantity_utra_tdd= (rrm_irat_measquanutratdd_et)lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask |= RRM_OAM_MEAS_QUANUTRA_TDD_PRESENT;
        }
        else
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of DuplexMode is not set to "
                    "either FDDMode or TDDMode");
            return OAM_FAILURE;
        }

        /* CSR00053377_CHANGES_END */

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B1ThresholdUTRARSCP"),OAM_INVALID_STR)!= OAM_ZERO))
        {

            lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B1ThresholdUTRARSCP"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b1_threshold_utra_rscp=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRMCM_RMIF_B1_THRESHOLD_UTRA_RSCP_PRESENT;

        }


        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B1ThresholdUTRAEcN0"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B1ThresholdUTRAEcN0"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b1_threshold_utra_ecn0=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRMCM_RMIF_B1_THRESHOLD_UTRA_ECN0_PRESENT;
        }

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"QoffsetGERAN"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.q_offset_geran=lclTemp_value;

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"FilterCoefficientGERAN"),RAN_Mobility_ConnMode_IRAT_FilterCoefficientGERAN[OAM_ZERO],OAM_FIFTEEN);

        /* coverity 35758 */
        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.filter_coefficient_geran=(rrm_filter_coefficient_et)lclTemp_value;


        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B1ThresholdGERAN"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B1ThresholdGERAN"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b1_threshold_geran=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRMCM_RMIF_B1_THRESHOLD_GERAN_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"QoffsetCDMA2000"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"QoffsetCDMA2000"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.q_offset_cdma2000=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRM_OAM_Q_OFFSET_CDMA_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"MeasQuantityCDMA2000"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"MeasQuantityCDMA2000"),RAN_Mobility_ConnMode_IRAT_MeasQuantityCDMA2000,OAM_TWO);

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.meas_quantity_cdma2000=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRM_OAM_MEAS_QUANTITY_CDMA2000_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B1ThresholdCDMA2000"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B1ThresholdCDMA2000"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b1_threshold_cdma2000=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B1_THRESHOLD_CDMA2000_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B2Threshold2UTRARSCP"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B2Threshold2UTRARSCP"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b2_threshold_2utra_rscp=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|= RRMCM_RMIF_B1_THRESHOLD_2UTRA_RSCP_PRESENT;
        }


        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B2Threshold2UTRAEcN0"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B2Threshold2UTRAEcN0"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b2_threshold_2utra_ecn0=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRMCM_RMIF_B1_THRESHOLD_2UTRA_ECN0_PRESENT;
        }



        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B2Threshold2GERAN"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B2Threshold2GERAN"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b2_threshold_2geran=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRMCM_RMIF_B1_THRESHOLD_2GERAN_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B2Threshold2CDMA2000"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B2Threshold2CDMA2000"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b2_threshold_2cdma=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B2_THRESHOLD_2CDMA_PRESENT;
        }

        /* SPR 13020 START */
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B2Threshold1RSRP"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B2Threshold1RSRP"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b2_threshold_1rsrp=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B2_THRESHOLD_1RSRP_PRESENT;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"B2Threshold1RSRQ"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->IRAT_2,"B2Threshold1RSRQ"));

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.b2_threshold_1rsrq=lclTemp_value;

            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B2_THRESHOLD_1RSRQ_PRESENT;
        }
        /* SPR 13020 END */

        /*LWA changes END*/
/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
        tagvalue=(Char8*)oam_xmlNodeGetContent(
                              xml_struct_g.EN_DC_Params,"ENDCEnabled");
        if(oam_strcmp(tagvalue, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi(tagvalue);
            if(lclTemp_value)
            {
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_B1NRThresholdRSRP"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_B1NRThresholdRSRP"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.b1_nr_threshold_rsrp=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B1_NR_THRESHOLD_RSRP_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_B1NRThresholdRSRQ"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_B1NRThresholdRSRQ"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.b1_nr_threshold_rsrq=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B1_NR_THRESHOLD_RSRQ_PRESENT;
                }

                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_B1NRThresholdSINR"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_B1NRThresholdSINR"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.b1_nr_threshold_sinr=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B1_NR_THRESHOLD_SINR_PRESENT;
                }

                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_B2NRThreshold2RSRP"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_B2NRThreshold2RSRP"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.b2_nr_threshold2_rsrp = lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask |= RRM_OAM_B2_NR_THRESHOLD2_RSRP_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_B2NRThreshold2RSRQ"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_B2NRThreshold2RSRQ"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.b2_nr_threshold2_rsrq=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B2_NR_THRESHOLD2_RSRQ_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_B2NRThreshold2SINR"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_B2NRThreshold2SINR"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.b2_nr_threshold2_sinr=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B2_NR_THRESHOLD2_SINR_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_B2NR_THRESH1_RSRP_EUTRA"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_B2NR_THRESH1_RSRP_EUTRA"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.b2_nr_threshold1_rsrp_eutra=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B2_NR_THRESHOLD1_RSRP_EUTRA_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_B2NR_THRESH1_RSRQ_EUTRA"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_B2NR_THRESH1_RSRQ_EUTRA"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.b2_nr_threshold1_rsrq_eutra=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_B2_NR_THRESHOLD1_RSRQ_EUTRA_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_OFFSET_FREQ_R15"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_OFFSET_FREQ_R15"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.offset_freq_r15=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_NR_OFFSET_FREQ_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_QUANTITY_CONFIG_SET_R15"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_QUANTITY_CONFIG_SET_R15"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.quantity_config_set_r15=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_NR_QUANTITY_CONFIG_SET_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_REPORT_QUANTITY_NR"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_REPORT_QUANTITY_NR"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.report_quantity_nr=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_REPORT_QUANTITY_NR_PRESENT;
                }
/* NR_REP_CONFIG_FIX_START */
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_TRIGGER_QUANTITY_NR"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_TRIGGER_QUANTITY_NR"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.trigger_quantity_nr = lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask |= RRM_OAM_TRIGGER_QUANTITY_NR_PRESENT;
                }
/* NR_REP_CONFIG_FIX_END */

                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_FILTER_COEFF_RSRP_R15"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_FILTER_COEFF_RSRP_R15"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.filter_coeff_rsrp_r15=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_NR_FILTER_COEFF_RSRP_PRESENT;
                }

                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_FILTER_COEFF_RSRQ_R15"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_FILTER_COEFF_RSRQ_R15"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.filter_coeff_rsrq_r15=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_NR_FILTER_COEFF_RSRQ_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_FILTER_COEFF_SINR_R15"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_FILTER_COEFF_SINR_R15"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.filter_coeff_sinr_r15=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_NR_FILTER_COEFF_SINR_PRESENT;
                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IRAT_2,"X_VENDOR_REPORT_ON_LEAVE_R15"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->IRAT_2,"X_VENDOR_REPORT_ON_LEAVE_R15"));

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.report_on_leave_r15=lclTemp_value;

                    p_rrm_cellconfig->ran_info.
                        connected_mode_mobility_params.irat.bitmask|=RRM_OAM_NR_REPORT_ON_LEAVE_PRESENT;
                }
            }
        }
/* ENDC_MEAS_CHANGES_END */
#endif
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"Hysteresis"));

        if( OAM_INVALID_VALUE != lclTemp_value )
        {
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.hysteresis=lclTemp_value;
        }

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"TimeToTrigger"),RAN_Mobility_ConnMode_IRAT_TimeToTrigger[OAM_ZERO],OAM_SIXTEEN);
        /* coverity 35763 */
        if( OAM_INVALID_VALUE != lclTemp_value )
        {
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.time_to_trigger=(rrmc_time_to_trigger_et)lclTemp_value;
        }

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"MaxReportCells"));

        if( OAM_INVALID_VALUE != lclTemp_value )
        {
            p_rrm_cellconfig->ran_info.
                connected_mode_mobility_params.irat.max_report_cells=lclTemp_value;
        }

        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"ReportInterval"),RAN_Mobility_ConnMode_EUTRA_ReportInterval[OAM_ZERO],OAM_THIRTEEN);

        /* coverity 35762 */
        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.report_interval=(rrmc_report_interval_et)lclTemp_value;


        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IRAT_2,"ReportAmount"),RAN_Mobility_ConnMode_IRAT_ReportAmount[OAM_ZERO],OAM_EIGHT);

        /* coverity 35761 */
        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.report_amount=(rrmc_report_amount_et)lclTemp_value;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        p_rrm_cellconfig->ran_info.
            bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"max_num_alt_so"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"max_num_alt_so"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            max_num_alt_so=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            bitmask |=RRM_OAM_MAX_NUM_ALT_SO_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.
            bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"pref_msid_type"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"pref_msid_type"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            pref_msid_type=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            bitmask|=RRM_OAM_PREF_MSID_TYPE_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.
            bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"mcc"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"mcc"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            mcc=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            bitmask|=RRM_OAM_MCC_INCLUDED_PRESENT;
        p_rrm_cellconfig->ran_info.
            bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"imsi_11_12"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"imsi_11_12"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            imsi_11_12=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            bitmask|=RRM_OAM_IMSI_11_12_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.
            bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"imsi_t_supported"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"imsi_t_supported"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            imsi_t_supported=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            bitmask |=RRM_OAM_IMSI_T_SUPPORTED_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.
            bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"PilotReport"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"PilotReport"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            pilot_report=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            bitmask |=RRM_OAM_PILOT_REPORT_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.
            bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"sdb_supported"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"sdb_supported"));

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            sdb_supported=lclTemp_value;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.ue_generic_cdma2000_params.
            bitmask |=RRM_OAM_SDB_SUPPORTED_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.
            bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.bitmask|=RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

        p_rrm_cellconfig->ran_info.
            connected_mode_mobility_params.irat.bitmask|=RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }
    /* CSR00053377_CHANGES_START */
    if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
                    /* spr_21013_fix_start */
                    xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"TDDMode",oam_strlen("TDDMode")+1))
        /* spr_21013_fix_end */
    {
        /* COV 31347 changes start */
        tdd_ack_nack_feedback_mode=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->TDDFrame,"X_VENDOR_TDD_ACK_NACK_FEEDBACK_MODE"));

        /* SPR 19679: TDD HARQ Multiplexing Changes Start */
        if((tdd_ack_nack_feedback_mode == HARQ_MULTIPLEXING)&& 
                /* COV 31347 changes end */
                (p_rrm_cellconfig->ran_info.physical_layer_params.
                 physical_layer_param_tdd_frame_structure.sub_frame_assignment
                 == UL_DL_CONFIG_5))
        {

            OAM_LOG(OAM, OAM_WARNING, "Harq Multiplexing is not supported"
                    "with TDD config 5");
            OAM_ALARM(CRITICAL_CONFIGURATION_FAILURE_ALARM_ID,CRITICAL,NOTIFY_NEW_ALARM,
                    PROCESSING_ERROR_ALARM,UNAVAILABLE,EXPEDITED_ALARM,
                    "Startup Configuration Failure: ",
                    OAM_NULL,OAM_ZERO);
            oam_abort();
            return OAM_FAILURE;
        }
        /* SPR 19679: TDD HARQ Multiplexing Changes End */
        /* COV 31347 changes start */
        p_rrm_cellconfig->ran_info.physical_layer_params.
            physical_layer_param_pucch.tdd_ack_nack_feedback_mode=tdd_ack_nack_feedback_mode;
        /* COV 31347 changes end */
        p_rrm_cellconfig->ran_info.physical_layer_params.
            physical_layer_param_pucch.bitmask|=RRM_OAM_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;

    }

    /* CSR00053377_CHANGES_END */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"X_VENDOR_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            csfb_support_for_dual_rx_ues_r9=lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask|=RRM_OAM_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask|=RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT; 
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"X_VENDOR_CSFB_REGISTRATION_PARAM_1XRTT_V920"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000,"X_VENDOR_CSFB_REGISTRATION_PARAM_1XRTT_V920"));

        /* SPR 11892 FIX START */
        /* coverity 35766 */
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            csfb_registration_param_1xrtt_v920=(rrm_oam_csfb_registration_param_1xrtt_v920_et)lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask|=RRM_OAM_CSFB_REG_PARAM_1XRTT_V920_PRESENCE_FLAG;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask|=RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT; 

        /* SPR 11892 FIX END */
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"X_VENDOR_SYSTEM_TIME_INFO"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        /* SPR 12920 Fix Start */
        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000,"X_VENDOR_SYSTEM_TIME_INFO"),systemTimeInfo,RRM_OAM_SYN_SYS_TIME_COUNT);
        /* SPR 12920 Fix End */
        /*coverity 35779 */ 
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            system_time_info=(rrm_oam_system_time_info_et)lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask|=RRM_OAM_SYSTEM_TIME_INFO_PRESENCE_FLAG;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask|=RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT; 
    }


    SInt8 ac_barring_0_to_9_r9_d = OAM_ZERO,
          ac_barring_10_r9 = OAM_ZERO,
          ac_barring_11_r9 = OAM_ZERO,
          ac_barring_12_r9 = OAM_ZERO,
          ac_barring_13_r9 = OAM_ZERO,
          ac_barring_14_r9 = OAM_ZERO,
          ac_barring_15_r9 = OAM_ZERO,
          ac_barring_msg_r9 = OAM_ZERO,
          ac_barring_reg_r9 = OAM_ZERO,
          ac_barring_emg_r9 = OAM_ZERO;


    ac_barring_0_to_9_r9_d = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_0_TO_9_R9"),OAM_INVALID_STR);
    ac_barring_10_r9  = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_10_R9"),OAM_INVALID_STR);
    ac_barring_11_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_11_R9"),OAM_INVALID_STR);
    ac_barring_12_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_12_R9"),OAM_INVALID_STR);
    ac_barring_13_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_13_R9"),OAM_INVALID_STR);
    ac_barring_14_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_14_R9"),OAM_INVALID_STR);
    ac_barring_15_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_15_R9"),OAM_INVALID_STR);
    ac_barring_msg_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_MSG_R9"),OAM_INVALID_STR);
    ac_barring_reg_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_REG_R9"),OAM_INVALID_STR);
    ac_barring_emg_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_EMG_R9"),OAM_INVALID_STR);

    if((ac_barring_0_to_9_r9_d != OAM_ZERO)
            && (ac_barring_10_r9 != OAM_ZERO)
            && (ac_barring_11_r9 != OAM_ZERO)
            && (ac_barring_12_r9 != OAM_ZERO)
            && (ac_barring_13_r9 != OAM_ZERO)
            && (ac_barring_14_r9 != OAM_ZERO)
            && (ac_barring_15_r9 != OAM_ZERO)
            && (ac_barring_msg_r9 != OAM_ZERO)
            && (ac_barring_reg_r9 != OAM_ZERO)
            && (ac_barring_emg_r9 != OAM_ZERO)
      )
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_0_TO_9_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_0_to_9_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_10_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_10_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_11_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_11_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_12_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_12_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_13_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_13_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_14_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_14_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_15_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_15_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_MSG_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_msg_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_REG_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_reg_r9=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000, "X_VENDOR_AC_BARRING_EMG_R9"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            ac_barring_config_1_xrtt_r9.ac_barring_emg_r9=lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask|=RRM_OAM_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_PRE_REG_INFO_HRPD,"PRE_REG_ALLOWED"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_PRE_REG_INFO_HRPD,"PRE_REG_ALLOWED"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            pre_reg_info_hrpd.pre_reg_allowed = lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask |= RRM_OAM_PRE_REG_INFO_HRPD_PRESENCE_FLAG;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_PRE_REG_INFO_HRPD,"PRE_REG_ZONE_ID"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_PRE_REG_INFO_HRPD,"PRE_REG_ZONE_ID"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            pre_reg_info_hrpd.pre_reg_zone_id = lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            pre_reg_info_hrpd.presence_bitmask |= RRM_OAM_PRE_REG_INFO_HRPD_ZONE_ID_PRESENCE_FLAG;
    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_SECONDARY_LIST,"COUNT"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_SECONDARY_LIST,"COUNT"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            pre_reg_info_hrpd.secondary_list.count = lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            pre_reg_info_hrpd.presence_bitmask |= RRM_OAM_PRE_REG_INFO_HRPD_SECONDARY_LST_PRESENCE_FLAG;


        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_SECONDARY_LIST, "PRE_REG_ZONE_ID"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            pre_reg_info_hrpd.secondary_list.pre_reg_zone_id[OAM_ZERO] = lclTemp_value;
    }

    SInt8 sid  = OAM_ZERO,
          nid = OAM_ZERO,
          multiple_sid = OAM_ZERO,
          multiple_nid = OAM_ZERO,
          reg_zone = OAM_ZERO,
          total_zone = OAM_ZERO,
          zone_timer = OAM_ZERO,
          home_reg = OAM_ZERO,
          foreign_sid_reg = OAM_ZERO,
          foreign_nid_reg = OAM_ZERO,
          parame_reg = OAM_ZERO,
          power_up_reg = OAM_ZERO,
          reg_prd = OAM_ZERO;

    sid = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"SID"),OAM_INVALID_STR); 
    nid = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"NID"),OAM_INVALID_STR);
    multiple_sid = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"MULTIPLE_SID"),OAM_INVALID_STR);
    multiple_nid = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"MULTIPLE_NID"),OAM_INVALID_STR);
    reg_zone = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"REG_ZONE"),OAM_INVALID_STR);
    total_zone = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"TOTAL_ZONE"),OAM_INVALID_STR);
    zone_timer = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"ZONE_TIMER"),OAM_INVALID_STR);
    home_reg = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"HOME_REG"),OAM_INVALID_STR);
    foreign_sid_reg = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"FOREIGN_SID_REG"),OAM_INVALID_STR);
    foreign_nid_reg = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"FOREIGN_NID_REG"),OAM_INVALID_STR);
    parame_reg = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"PARAME_REG"),OAM_INVALID_STR); 
    power_up_reg = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"POWER_UP_REG"),OAM_INVALID_STR);
    reg_prd = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"REG_PRD"),OAM_INVALID_STR);



    if((sid != OAM_ZERO)
            && (nid != OAM_ZERO)
            && (multiple_sid != OAM_ZERO)
            && (multiple_nid != OAM_ZERO)
            && (reg_zone != OAM_ZERO)
            && (total_zone != OAM_ZERO)
            && (zone_timer != OAM_ZERO)
            && (home_reg != OAM_ZERO)
            && (foreign_sid_reg != OAM_ZERO)
            && (foreign_nid_reg != OAM_ZERO)
            && (parame_reg != OAM_ZERO)
            && (power_up_reg != OAM_ZERO)
            && (reg_prd != OAM_ZERO)
      )
    {
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask |= RRM_OAM_MOBILITY_SIB_8_PARAMS_PRESENCE_FLAG;
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(

                    /* BITSTRING FIX START */ 
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"SID"));
        oam_conversion_from_short_to_byte_string(
                p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                mobility_sib_8_params.sid, lclTemp_value, OAM_SID_BITSTRING_SIZE);

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"NID"));
        oam_conversion_from_short_to_byte_string(
                p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                mobility_sib_8_params.nid, lclTemp_value, OAM_NID_BITSTRING_SIZE);

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"MULTIPLE_SID"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.multiple_sid = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"MULTIPLE_NID"));

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.multiple_nid = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"REG_ZONE"));
        oam_conversion_from_short_to_byte_string(
                p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                mobility_sib_8_params.reg_zone, lclTemp_value, OAM_REG_ZONE_BITSTRING_SIZE);
        /* BITSTRING FIX END */

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"TOTAL_ZONE"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.total_zone[OAM_ZERO] = (UInt8) (lclTemp_value & 0x000000FF);

        /* Comented for SPR-8400
           p_rrm_cellconfig->ran_info.mobility_params.
           idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
           mobility_sib_8_params.total_zone[OAM_ZERO] <<= OAM_FIVE; */

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"ZONE_TIMER"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.zone_timer[OAM_ZERO] = (UInt8) (lclTemp_value & 0x000000FF); 

        /* Commented for SPR-8400
           p_rrm_cellconfig->ran_info.mobility_params.
           idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
           mobility_sib_8_params.zone_timer[OAM_ZERO] <<= OAM_FIVE;*/


        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"PACKET_ZONE_ID"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"PACKET_ZONE_ID"));
            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                mobility_sib_8_params.packet_zone_id = lclTemp_value;
            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                mobility_sib_8_params.bitmask |= RRM_OAM_PACKET_ZONE_ID_INCLUDED_PRESENT;
        }

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"HOME_REG"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.home_reg = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"FOREIGN_SID_REG"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.foreign_sid_reg = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"FOREIGN_NID_REG"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.foreign_nid_reg = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"PARAME_REG"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.parame_reg = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"POWER_UP_REG"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.power_up_reg = lclTemp_value;

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"POWER_DOWN_REG"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"POWER_DOWN_REG"));

            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                mobility_sib_8_params.power_down_reg = lclTemp_value;

            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                mobility_sib_8_params.bitmask |= RRM_OAM_POWER_DOWN_REG_INCLUDED_PRESENT;
        }

        /* BITSTRING FIX START */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_MOBILITY_SIB_8_PARAMS,"REG_PRD"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.reg_prd = lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            mobility_sib_8_params.reg_prd <<= OAM_ONE;
        /* BITSTRING FIX END */

    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->CDMA2000_RAND,"RAND_SEED"));
    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
        cdma2000_cell_param.cdma2000_rand.rand_seed = lclTemp_value; 

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->CDMA2000_RAND,"RAND_MIN"));
    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
        cdma2000_cell_param.cdma2000_rand.rand_min = lclTemp_value;

    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
        presence_bitmask |= RRM_OAM_CDMA2000_CELL_PARAMS_PRESENCE_FLAG;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->CDMA2000_RAND,"RAND_MAX"));
    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
        cdma2000_cell_param.cdma2000_rand.rand_max = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->CDMA2000_RAND,"RAND_REGENERATE_TIMER"));
    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
        cdma2000_cell_param.cdma2000_rand.rand_regenerate_timer = lclTemp_value;

    /*lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
      p_cell_spec_params->CELL_ID_1XRTT,"CDMA2000_1XRTT_CELL_ID"));
      p_rrm_cellconfig->ran_info.mobility_params.
      idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
      cdma2000_cell_param.cell_id_1xrtt.cdma2000_1xrtt_cell_id[OAM_ONE] = lclTemp_value;*/
    /* SPR 13283 START */
    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
        cdma2000_cell_param.bitmask |= RRM_OAM_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG;

    lclTemp_value3=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->CELL_ID_1XRTT,"CDMA2000_1XRTT_CELL_ID"));
    oam_conversion_from_int64_to_byte_string(p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.cdma2000_cell_param.cell_id_1xrtt.cdma2000_1xrtt_cell_id,
            lclTemp_value3,OAM_CDMA_1XRTT_CELL_ID_BITSTRING_SIZE);

    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
        cdma2000_cell_param.cell_id_hrpd.cdma2000_hrpd_cell_id_length = RRM_CDMA2000_HRPD_CELL_ID_LENGTH;

    /*lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
      p_cell_spec_params->CELL_ID_HRPD,"CDMA2000_HRPD_CELL_ID"));
      p_rrm_cellconfig->ran_info.mobility_params.
      idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
      cdma2000_cell_param.cell_id_hrpd.cdma2000_hrpd_cell_id[OAM_ONE] = lclTemp_value; */
    UInt8 cdma2000_hrpd_cell_id_half_length = RRM_CDMA2000_HRPD_CELL_ID_LENGTH/OAM_TWO;
    UInt64 HRPD_CellId_Temp_value[OAM_TWO];

    p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
        cdma2000_cell_param.bitmask |= RRM_OAM_CDMA2000_PARAM_HRPD_SECTOR_ID_PRESENCE_FLAG;

    ptr_child = (p_cell_spec_params->CELL_ID_HRPD)->children;


    for ( count = OAM_ZERO; ((count < OAM_TWO) &&
                (OAM_NULL != (xmlNode *)ptr_child )); count++ )
    {
        ptr_child = oam_xml_find_tag(ptr_child,(xmlChar *)"CDMA2000_HRPD_CELL_ID");

        if ( ptr_child != OAM_NULL )
        {
            temp = ((char *)xmlNodeGetContent( ptr_child ));
            if ( OAM_NULL != temp )
            {
                HRPD_CellId_Temp_value[count] =  oam_atoi((const char *)temp);
                OAM_LOG(OAM, OAM_INFO,"Value of HRPD_CellId_Temp_value[%d] is %llu",count,HRPD_CellId_Temp_value[count]);
                xmlFree(temp);

                ptr_child = (((xmlNode *)ptr_child)->next);
            }
        }
    }
    for ( count = OAM_ZERO; count < cdma2000_hrpd_cell_id_half_length; count++)
    {
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cdma2000_cell_param.cell_id_hrpd.cdma2000_hrpd_cell_id[RRM_CDMA2000_HRPD_CELL_ID_LENGTH-count-OAM_ONE] =
            ((HRPD_CellId_Temp_value[OAM_ONE] >> (count * OAM_EIGHT))& 0x000000FF);
    }
    for ( count = cdma2000_hrpd_cell_id_half_length; count < RRM_CDMA2000_HRPD_CELL_ID_LENGTH; count++)
    {
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cdma2000_cell_param.cell_id_hrpd.cdma2000_hrpd_cell_id[RRM_CDMA2000_HRPD_CELL_ID_LENGTH-count-OAM_ONE] =
            ((HRPD_CellId_Temp_value[OAM_ZERO] >> ((count-OAM_EIGHT) * OAM_EIGHT))& 0x000000FF);
    }
    /* SPR 13283 END */



    /* Start: SPR 10551 */
    if(OAM_NULL != p_cell_spec_params->REFERENCE_CELL_ID_1XRTT) {
        ptr_child = (p_cell_spec_params->REFERENCE_CELL_ID_1XRTT)->children;
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_cdma2000_params.cdma2000_cell_param.
            bitmask |= RRM_OAM_CDMA2000_PARAM_1XRTT_REFERENCE_CELL_ID_PRESENCE_FLAG;

        for (count = OAM_ZERO;
                (count < RRM_CDMA2000_1XRTT_REFERENCE_CELL_ID_LENGTH) && ptr_child;
                ++count)
        {    
            ptr_child = oam_xml_find_tag(ptr_child,
                    (xmlChar *)"CDMA2000_1XRTT_REFERENCE_CELL_ID");

            if (ptr_child != OAM_NULL) {
                temp = (Char8*)xmlNodeGetContent(ptr_child);
                if (OAM_NULL != temp) {
                    lclTemp_value =  oam_atoi((Char8*)temp);
                    xmlFree(temp);
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_cdma2000_params.
                        cdma2000_cell_param.
                        cdma2000_1xrtt_reference_cell_id[count] = lclTemp_value;

                    ptr_child = (((xmlNode *)ptr_child)->next);
                }
            }
        }
    }

    if(OAM_NULL != p_cell_spec_params->REFERENCE_CELL_ID_HRPD) {
        ptr_child = (p_cell_spec_params->REFERENCE_CELL_ID_HRPD)->children;
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_cdma2000_params.cdma2000_cell_param.
            bitmask |= RRM_OAM_CDMA2000_PARAM_HRPD_REFERENCE_CELL_ID_PRESENCE_FLAG;

        for (count = OAM_ZERO;
                (count < RRM_CDMA2000_HRPD_REFERENCE_CELL_ID_LENGTH) && ptr_child;
                ++count)
        {
            ptr_child = oam_xml_find_tag(ptr_child,
                    (xmlChar *)"CDMA2000_HRPD_REFERENCE_CELL_ID");

            if (ptr_child != OAM_NULL) {   
                temp = ((char *)xmlNodeGetContent( ptr_child));
                if (OAM_NULL != temp) {
                    lclTemp_value =  oam_atoi((const char *)temp);

                    xmlFree(temp);
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_cdma2000_params.
                        cdma2000_cell_param.
                        cdma2000_hrpd_reference_cell_id[count] = lclTemp_value;

                    ptr_child = (((xmlNode *)ptr_child)->next);
                }
            }    
        }       
    }    
    /*End: SPR 10551 */
    /* SPR 10911 FIX START */
    if ((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"X_VENDOR_ECSFB_1XRTT_R9"),
                 OAM_INVALID_STR)!= OAM_ZERO))
    {
        /* SPR 10911 FIX END */            
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000,"X_VENDOR_ECSFB_1XRTT_R9"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            inter_rat_parameters_cdma2000_v920.eCSFB_1xrtt_r9 = lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask |= RRM_OAM_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG;

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"X_VENDOR_ECSFB_CONC_PS_MOBILITY_1XRTT_R9"),
                     OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->CDMA2000,"X_VENDOR_ECSFB_CONC_PS_MOBILITY_1XRTT_R9"));
            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                inter_rat_parameters_cdma2000_v920.eCSFB_conc_ps_mobility_1xrtt_r9 = lclTemp_value;

            p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                inter_rat_parameters_cdma2000_v920.bitmask |= RRM_OAM_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG;
        }
        /* SPR 10911 FIX START */
    }    
    /* SPR  10911 FIX END */

    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"TReselectionCDMA2000"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000,"TReselectionCDMA2000"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cell_reselection_params_hrpd.t_reselection_cdma2000=lclTemp_value;
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask |= RRM_OAM_CELL_RESEL_PARAMS_HRPD_CDMA2000_PRESENCE_FLAG;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"TReselectionCDMA2000"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->CDMA2000,"TReselectionCDMA2000"));
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cell_reselection_params_1xrtt.t_reselection_cdma2000=lclTemp_value;
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            presence_bitmask |= RRM_OAM_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG;
    }


    UInt8 TReselectionCDMA2000SFHigh = OAM_ZERO,
          TReselectionCDMA2000SFMedium = OAM_ZERO;

    TReselectionCDMA2000SFHigh =  oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"TReselectionCDMA2000SFHigh"),OAM_INVALID_STR);
    TReselectionCDMA2000SFMedium = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,"TReselectionCDMA2000SFMedium"),OAM_INVALID_STR);

    if((TReselectionCDMA2000SFHigh != OAM_ZERO)
            &&(TReselectionCDMA2000SFMedium != OAM_ZERO))
    { 
        /* CSR 00070293 FIX START */
        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,
                "TReselectionCDMA2000SFHigh");

        lclTemp_value =
            oam_xml_search_integer_to_integer(temp, 
                    RRM_CELL_TRESELECTIONSF[OAM_ZERO],
                    TRESELECTIONSF_COUNT);

        /* CSR 00070293 FIX END*/

        /* coverity */ 
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cell_reselection_params_hrpd.t_reselection_cdma2000_sf.
            t_reselection_eutra_sf_high=(rrm_oam_speed_state_scale_factors_et)lclTemp_value;


        /* CSR 00070293 FIX START */
        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,
                "TReselectionCDMA2000SFMedium");

        lclTemp_value =
            oam_xml_search_integer_to_integer(temp, 
                    RRM_CELL_TRESELECTIONSF[OAM_ZERO],
                    TRESELECTIONSF_COUNT);
        /* CSR 00070293 FIX END*/
        /* coverity */ 
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cell_reselection_params_hrpd.t_reselection_cdma2000_sf.
            t_reselection_eutra_sf_medium=(rrm_oam_speed_state_scale_factors_et)lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cell_reselection_params_hrpd.presence_bitmask|=RRM_OAM_CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG;
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask|=RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT;
    }

    if((TReselectionCDMA2000SFHigh != OAM_ZERO)
            &&(TReselectionCDMA2000SFMedium != OAM_ZERO))
    { 
        /* CSR 00070293 FIX START */
        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,
                "TReselectionCDMA2000SFHigh");

        lclTemp_value =
            oam_xml_search_integer_to_integer(temp, RRM_CELL_TRESELECTIONSF[OAM_ZERO],
                    TRESELECTIONSF_COUNT);
        /* CSR 00070293 FIX END */

        /* coverity */ 
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cell_reselection_params_1xrtt.t_reselection_cdma2000_sf.
            t_reselection_eutra_sf_high=(rrm_oam_speed_state_scale_factors_et)lclTemp_value;

        /* CSR 00070293 FIX START */
        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000,
                "TReselectionCDMA2000SFMedium");

        lclTemp_value =
            oam_xml_search_integer_to_integer(temp, RRM_CELL_TRESELECTIONSF[OAM_ZERO],
                    TRESELECTIONSF_COUNT);
        /* CSR 00070293 FIX END */

        /* coverity 35785 */ 
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cell_reselection_params_1xrtt.t_reselection_cdma2000_sf.
            t_reselection_eutra_sf_medium=(rrm_oam_speed_state_scale_factors_et)lclTemp_value;

        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
            cell_reselection_params_1xrtt.presence_bitmask|=RRM_OAM_CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG;
        p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.bitmask|=RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT;
    }



    UInt32 num_cdma2000band_entries = OAM_ZERO;
    UInt8 count_1 = OAM_ZERO;
    UInt8 count_2 = OAM_ZERO;

    num_cdma2000band_entries=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->InterRATCell_1,"CDMA2000NumberOfEntries"));
    UInt32 BandClass_1=OAM_ZERO;
    UInt32 BandClass_2=OAM_ZERO;
    SInt8 BandClass = OAM_ZERO,
          ThreshXHigh = OAM_ZERO,
          ThreshXLow = OAM_ZERO;

    UInt32 num_cdma_band = OAM_ZERO;
    num_cdma_band = oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->CDMA2000,"X_VENDOR_NUMCDMA2000BAND"));

    for(counter = OAM_ZERO ; counter < num_cdma_band ; counter ++)
    {
        for(count = OAM_ZERO ; count < num_cdma2000band_entries ; count ++)
        {

            BandClass_1=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->CDMA2000Band[counter],"BandClass"));

            BandClass_2=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->CDMA2000_2[count],"BandClass"));

            /* SPR-13846 START */  
            BandClass = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000Band[counter],"BandClass"),OAM_INVALID_STR);
            ThreshXHigh = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000Band[counter],"ThreshXHigh"),OAM_INVALID_STR);
            ThreshXLow = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000Band[counter],"ThreshXLow"),OAM_INVALID_STR);
            /* SPR-13846 END */  
            if((BandClass_1 == BandClass_2)
                    &&(oam_strcmp
                        ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[count],"Type"),"HRPD")== OAM_ZERO))
            {
                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                    cell_reselection_params_hrpd.band_class_list.
                    band_class_info_cdma2000[count].presence_bitmask
                    |=RRM_OAM_BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG;



                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                    cell_reselection_params_hrpd.band_class_list.count+=1;

                /* SPR-13846 START */  
                /* code removed */
                /* SPR-13846 END */  



                if((BandClass != OAM_ZERO)
                        &&(ThreshXHigh != OAM_ZERO)
                        &&(ThreshXLow != OAM_ZERO))
                {

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->CDMA2000Band[counter],"BandClass"));
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_hrpd.band_class_list.
                        band_class_info_cdma2000[count_1].band_class=lclTemp_value;

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->CDMA2000Band[counter],"CellReselectionPriority"));
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_hrpd.band_class_list.
                        band_class_info_cdma2000[count_1].cell_reselection_priority=lclTemp_value;
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_hrpd.presence_bitmask |= RRM_OAM_CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG;

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->CDMA2000Band[counter],"ThreshXHigh"));
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_hrpd.band_class_list.
                        band_class_info_cdma2000[count_1].thresh_x_high=lclTemp_value;

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->CDMA2000Band[counter],"ThreshXLow"));
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_hrpd.band_class_list.
                        band_class_info_cdma2000[count_1].thresh_x_low=lclTemp_value;

                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT;
                }
                count_1++;
            }

            if((BandClass_1 == BandClass_2)
                    &&(oam_strcmp
                        ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[count],"Type"),"1xRTT")== OAM_ZERO))
            {
                p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                    cell_reselection_params_1xrtt.band_class_list.count+=1;


                if((BandClass != OAM_ZERO)
                        &&(ThreshXHigh != OAM_ZERO)
                        &&(ThreshXLow != OAM_ZERO))   
                {

                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_1xrtt.band_class_list.
                        band_class_info_cdma2000[count].presence_bitmask
                        |=RRM_OAM_BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG;

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->CDMA2000Band[counter],"BandClass"));
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_1xrtt.band_class_list.
                        band_class_info_cdma2000[count_2].band_class=lclTemp_value;

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->CDMA2000Band[counter],"CellReselectionPriority"));
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_1xrtt.band_class_list.
                        band_class_info_cdma2000[count_2].cell_reselection_priority=lclTemp_value;
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_1xrtt.band_class_list.
                        band_class_info_cdma2000[count_2].presence_bitmask
                        |=RRM_OAM_BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG;

                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_1xrtt.presence_bitmask |=RRM_OAM_CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG;

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->CDMA2000Band[counter],"ThreshXHigh"));
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_1xrtt.band_class_list.
                        band_class_info_cdma2000[count_2].thresh_x_high=lclTemp_value;

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->CDMA2000Band[counter],"ThreshXLow"));
                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.
                        cell_reselection_params_1xrtt.band_class_list.
                        band_class_info_cdma2000[count_2].thresh_x_low=lclTemp_value;

                    p_rrm_cellconfig->ran_info.mobility_params.
                        idle_mode_mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT;
                }
                count_2++;
            }
        }
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"auth"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"auth"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.auth = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_AUTH_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.bitmask |= RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"use_sync_id"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"use_sync_id"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.use_sync_id = lclTemp_value;        

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_USE_SYNC_ID_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.bitmask |= RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"mob_qos"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"mob_qos"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.mob_qos = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_MOB_QOS_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.bitmask |= RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"bypass_reg_ind"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"bypass_reg_ind"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bypass_reg_ind = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_BYPASS_REG_IND_INCLUDED_PRESENT;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.bitmask |= RRM_OAM_UE_GENERIC_PARAMS_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"max_add_serv_instance"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"max_add_serv_instance"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.max_add_serv_instance = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_MAX_ADD_SERV_INSTANCE_INCLUDED_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"parameter_reg"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"parameter_reg"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.parameter_reg = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_PARAMETER_REG_INCLUDED_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"reg_dist"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"reg_dist"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.reg_dist = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_REG_DIST_INCLUDED_PRESENT;

    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"ext_pref_msid_type"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"ext_pref_msid_type"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.ext_pref_msid_type = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_EXT_PREF_MSID_TYPE_INCLUDED_PRESENT;

    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"meid_reqd"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"meid_reqd"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.meid_reqd = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_MEID_REQD_INCLUDED_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"reconnect_msg_ind"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"reconnect_msg_ind"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.reconnect_msg_ind = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_RECONNECT_MSG_IND_INCLUDED_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"rer_mode_supported"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"rer_mode_supported"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.rer_mode_supported = lclTemp_value;
        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_RER_MODE_SUPPORTED_INCLUDED_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"auto_fcso_allowed"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"auto_fcso_allowed"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.auto_fcso_allowed = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_AUTO_FCSO_ALLOWED_INCLUDED_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"sdb_in_rcnm_ind"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"sdb_in_rcnm_ind"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.sdb_in_rcnm_ind = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_SDB_IN_RCNM_IND_INCLUDED_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"daylt"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"daylt"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.daylt = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_DAYLT_INCLUDED_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"gcsna_l2_ack_timer"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"gcsna_l2_ack_timer"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.gcsna_l2_ack_timer = lclTemp_value;
        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_GCSNA_L2_ACK_TIMER_INCLUDED_PRESENT;

    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"gcsna_sequence_context_timer"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"gcsna_sequence_context_timer"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.gcsna_sequence_context_timer = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_GCSNA_SEQUENCE_CONTEXT_TIMER_INCLUDED_PRESENT;

    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"lp_sec"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"lp_sec"));

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.lp_sec = lclTemp_value;

        p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
            irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_LP_SEC_INCLUDED_PRESENT;

    }

    /* SPR 12673 START */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"rand_included"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"rand_included"));


        if(OAM_ONE == lclTemp_value)
        {
            p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
                irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_RAND_INCLUDED_PRESENT;
        }

    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ue_generic_cdma2000_params,"ltm_off_included"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ue_generic_cdma2000_params,"ltm_off_included"));


        if(OAM_ONE == lclTemp_value)
        {
            p_rrm_cellconfig->ran_info.connected_mode_mobility_params.
                irat.ue_generic_cdma2000_params.bitmask |= RRM_OAM_LTM_OFF_INCLUDED_PRESENT;
        }

    }
    /* SPR 12673 END */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(xml_struct_g.operator_info,"simultaneous_ack_nack_and_cqi"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.operator_info,"simultaneous_ack_nack_and_cqi"));

        p_rrm_cellconfig->operator_info.
            simultaneous_ack_nack_and_cqi = lclTemp_value;

        p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ACK_NACK_CQI_PRESENT;
    }

    /** MISSING_MEAS_CONFIG_FIX_START **/

    p_rrm_cellconfig->operator_info.
        measurement_configuration.csfb_tgt_selection.bitmask = OAM_ZERO;

    /** MISSING_MEAS_CONFIG_FIX_END **/

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->measurement_configuration,"si_gap_enable"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->measurement_configuration,"si_gap_enable"));

        p_rrm_cellconfig->operator_info.
            measurement_configuration.si_gap_enable = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            measurement_configuration.bitmask |= RRM_OAM_SI_GAP_ENABLE_PRESENT;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_MEASUREMENT_CONFIG_PRESENT;
    }

    /*SPR-503 START*/
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->measurement_configuration,"eutran_gap_offset_type"),OAM_INVALID_STR)!=0)
      )
    {
        p_rrm_cellconfig->operator_info.
            measurement_configuration.bitmask |= RRM_OAM_MEAS_GAP_CONFIG_PRESENT;

        if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->measurement_configuration,"eutran_gap_offset_type"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->measurement_configuration,"eutran_gap_offset_type"));
            p_rrm_cellconfig->operator_info.
                measurement_configuration.meas_gap_config.eutran_gap_offset_type = lclTemp_value;
            p_rrm_cellconfig->operator_info.
                measurement_configuration.meas_gap_config.bitmask |= RRM_OAM_E_UTRAN_GAP_OFFSET_TYPE_PRESENT;
        }

        if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->measurement_configuration,"utran_gap_offset_type"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->measurement_configuration,"utran_gap_offset_type"));
            p_rrm_cellconfig->operator_info.
                measurement_configuration.meas_gap_config.utran_gap_offset_type= lclTemp_value;
            p_rrm_cellconfig->operator_info.
                measurement_configuration.meas_gap_config.bitmask |= RRM_OAM_UTRAN_GAP_OFFSET_TYPE_PRESENT;
        }

        if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->measurement_configuration,"geran_gap_offset_type"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->measurement_configuration,"geran_gap_offset_type"));
            p_rrm_cellconfig->operator_info.
                measurement_configuration.meas_gap_config.geran_gap_offset_type= lclTemp_value;
            p_rrm_cellconfig->operator_info.
                measurement_configuration.meas_gap_config.bitmask |= RRM_OAM_GERAN_GAP_OFFSET_TYPE_PRESENT;
        }

        if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->measurement_configuration,"cdma2000_gap_offset_type"),OAM_INVALID_STR)!=0))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->measurement_configuration,"cdma2000_gap_offset_type"));
            p_rrm_cellconfig->operator_info.
                measurement_configuration.meas_gap_config.cdma2000_gap_offset_type= lclTemp_value;
            p_rrm_cellconfig->operator_info.
                measurement_configuration.meas_gap_config.bitmask |=  RRM_OAM_CDMA2000_GAP_OFFSET_TYPE_PRESENT;
        }
/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
        tagvalue=(Char8*)oam_xmlNodeGetContent(
                              xml_struct_g.EN_DC_Params,"ENDCEnabled");
        if(oam_strcmp(tagvalue, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi(tagvalue);
            if(lclTemp_value)
            {
                if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->measurement_configuration,"endc_gap_offset_type"),OAM_INVALID_STR)!=0))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_prop_cellconfig->measurement_configuration,"endc_gap_offset_type"));
                    p_rrm_cellconfig->operator_info.
                        measurement_configuration.meas_gap_config.endc_gap_offset_type= lclTemp_value;
                    p_rrm_cellconfig->operator_info.
                        measurement_configuration.meas_gap_config.bitmask |=  RRM_OAM_ENDC_GAP_OFFSET_TYPE_PRESENT;
                }
            }
        }
#endif
/* ENDC_MEAS_CHANGES_END */

    }

    /*SPR-503 END*/

    /* SPR 14059 FIX : code removed */

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->csfb_tgt_selection,"utran_csfb_tgt_selection"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->csfb_tgt_selection,"utran_csfb_tgt_selection"));

        /* coverity 35772 */
        p_rrm_cellconfig->operator_info.
            measurement_configuration.csfb_tgt_selection.utran_csfb_tgt_selection = (rrm_csfb_target_selection_et)lclTemp_value;

        p_rrm_cellconfig->operator_info.
            measurement_configuration.csfb_tgt_selection.bitmask |= RRM_OAM_UTRAN_CSFB_TGT_SELECTION_PRESENT;

        p_rrm_cellconfig->operator_info.
            measurement_configuration.bitmask |= RRM_OAM_CSFB_TGT_SELECTION_PRESENT;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_MEASUREMENT_CONFIG_PRESENT;
    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->csfb_tgt_selection,"geran_csfb_tgt_selection"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->csfb_tgt_selection,"geran_csfb_tgt_selection"));

        /* coverity 35771 */
        p_rrm_cellconfig->operator_info.
            measurement_configuration.csfb_tgt_selection.geran_csfb_tgt_selection = (rrm_csfb_target_selection_et)lclTemp_value;

        p_rrm_cellconfig->operator_info.
            measurement_configuration.csfb_tgt_selection.bitmask |= RRM_OAM_GERAN_CSFB_TGT_SELECTION_PRESENT;

        p_rrm_cellconfig->operator_info.
            measurement_configuration.bitmask |= RRM_OAM_CSFB_TGT_SELECTION_PRESENT;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_MEASUREMENT_CONFIG_PRESENT;
    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->csfb_tgt_selection,"cdma2000_csfb_tgt_selection"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->csfb_tgt_selection,"cdma2000_csfb_tgt_selection"));

        /* coverity 35770 */
        p_rrm_cellconfig->operator_info.
            measurement_configuration.csfb_tgt_selection.cdma2000_csfb_tgt_selection = (rrm_csfb_target_selection_et)lclTemp_value;

        p_rrm_cellconfig->operator_info.
            measurement_configuration.csfb_tgt_selection.bitmask |= RRM_OAM_CDMA2000_CSFB_TGT_SELECTION_PRESENT;

        p_rrm_cellconfig->operator_info.
            measurement_configuration.bitmask |= RRM_OAM_CSFB_TGT_SELECTION_PRESENT;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_MEASUREMENT_CONFIG_PRESENT;
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,"CELL_CAPACITY_CLASS"));
    p_rrm_cellconfig->operator_info.
        cell_capacity_class = lclTemp_value;        

    p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_CELL_CAPACITY_CLASS_PRESENT;

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_configuration,"blind_ho_timer"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_configuration,"blind_ho_timer"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.blind_ho_timer = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_BLIND_HO_TIMER_PRESENT;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_HO_CONFIGURATION_PRESENT;
    }
    /* SPR 20653 Fix Start */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_configuration,"s1_direct_fwd_path_available"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_configuration,"s1_direct_fwd_path_available"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.s1_direct_fwd_path_available = (rrm_bool_t)lclTemp_value;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_S1_DIRECT_FWD_PATH_AVAILABLE_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of s1_direct_fwd_path_available not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_configuration,"utra_rnc_direct_fwd_path_available"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_configuration,"utra_rnc_direct_fwd_path_available"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.utra_rnc_direct_fwd_path_available = (rrm_bool_t)lclTemp_value;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_UTRA_RNC_DIRECT_FWD_PATH_AVAILABLE_PRESENT;

    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_configuration,"b1_event_utran_trigger_quantity"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_configuration,"b1_event_utran_trigger_quantity"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.b1_event_utran_trigger_quantity = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_B1_EVENT_UTRAN_TRIGGER_QUANTITY_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of b1_event_utran_trigger_quantity not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_configuration,"b2_event_utran_trigger_quantity"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_configuration,"b2_event_utran_trigger_quantity"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.b2_event_utran_trigger_quantity = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_B2_EVENT_UTRAN_TRIGGER_QUANTITY_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of b2_event_utran_trigger_quantity not found");
        return OAM_FAILURE;
    }
/*SPR 21365 fix start*/
/* Lines Deleted */
/*SPR 21365 fix stop*/
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_configuration,"csfb_blind_timer_duration"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_configuration,"csfb_blind_timer_duration"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.csfb_blind_timer_duration = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_CSFB_BLIND_TIMER_DURATION_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of csfb_blind_timer_duration not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_configuration,"irat_offset"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_configuration,"irat_offset"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.irat_offset = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_IRAT_OFFSET_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of irat_offset not found");
        return OAM_FAILURE;
    }
    /* SPR 20653 Fix End */

    /* SPR 22311 Changes - Starts */
    /* SPR 20635 Fix - SRVCC to GERAN - Starts */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_algo_params,"ue_meas_duration_for_ho"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_configuration,"ue_meas_duration_for_ho"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.ue_meas_duration_for_ho = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_HO_CONFIGURATION_PRESENT;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_UE_MEAS_DURATION_FOR_HO_PRESENT;
    }
    /* SPR 20635 Fix - SRVCC to GERAN - Ends */
    /* SPR 22311 Changes - Ends */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_retry_params,"ho_retry_count"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_retry_params,"ho_retry_count"));

        p_rrm_cellconfig->operator_info.
            ho_configuration.ho_retry_params.ho_retry_count = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            ho_configuration.ho_retry_params.bitmask |= RRM_OAM_HO_RETRY_COUNT_PRESENT;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_HO_CONFIGURATION_PRESENT;

        p_rrm_cellconfig->operator_info.
            ho_configuration.bitmask |= RRM_OAM_HO_RETRY_PARAMS_PRESENT;
    }

    /* SPR 22311 Changes - Starts */
    /* Code Deleted */
    /* SPR 22311 Changes - Ends */

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->target_cell_selection_params,"daho_cell_based_ho_enable"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->target_cell_selection_params,"daho_cell_based_ho_enable"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.daho_cell_based_ho_enable = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.bitmask |= RRM_OAM_DAHO_CELL_BASED_HO_ENABLE_PRESENT;

        p_rrm_cellconfig->operator_info.ho_configuration.
            bitmask |= RRM_OAM_TARGET_CELL_SELECTION_PARAMS_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->target_cell_selection_params,"ue_measurement_based_ho_enable"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->target_cell_selection_params,"ue_measurement_based_ho_enable"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.ue_measurement_based_ho_enable = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.bitmask |= RRM_OAM_UE_MEAS_BASED_HO_ENABLE_PRESENT;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->target_cell_selection_params,"spid_based_ho_enable"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->target_cell_selection_params,"spid_based_ho_enable"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.spid_based_ho_enable = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.bitmask |= RRM_OAM_SPID_BASED_HO_ENABLE_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->target_cell_selection_params,"ue_history_based_ho_enable"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->target_cell_selection_params,"ue_history_based_ho_enable"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.ue_history_based_ho_enable = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.bitmask |= RRM_OAM_UE_HISTORY_BASED_HO_ENABLE_PRESENT;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->target_cell_selection_params,"neighboring_cell_load_based_ho_enable"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->target_cell_selection_params,"neighboring_cell_load_based_ho_enable"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.neighboring_cell_load_based_ho_enable = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            target_cell_selection_params.bitmask |= RRM_OAM_UE_HISTORY_BASED_HO_ENABLE_PRESENT;
    }
    /* SPR 20653 Fix Start */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_oscillation_params,"time_of_stay_threshold"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_oscillation_params,"time_of_stay_threshold"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            ho_oscillation_cfg.time_of_stay_threshold = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            ho_oscillation_cfg.bitmask |= RRM_OAM_TIME_OF_STAY_THRESHOLD_PRESENT;

        p_rrm_cellconfig->operator_info.ho_configuration.
            bitmask |= RRM_OAM_HO_OSCILLATION_CFG_PRESENT;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of time_of_stay_threshold not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_oscillation_params,"min_num_of_oscillation_loop"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_oscillation_params,"min_num_of_oscillation_loop"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            ho_oscillation_cfg.min_num_of_oscillation_loop = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            ho_oscillation_cfg.bitmask |= RRM_OAM_MIN_NUM_OF_OSCILLATION_LOOP_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of min_num_of_oscillation_loop not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_oscillation_params,"max_last_visited_cells_searched"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_oscillation_params,"max_last_visited_cells_searched"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            ho_oscillation_cfg.max_last_visited_cells_searched = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            ho_oscillation_cfg.bitmask |= RRM_OAM_MAX_LAST_VISITED_CELLS_SEARCHED_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of max_last_visited_cells_searched not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_oscillation_params,"ho_oscillation_cio_offset"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_oscillation_params,"ho_oscillation_cio_offset"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            ho_oscillation_cfg.ho_oscillation_cio_offset = lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            ho_oscillation_cfg.bitmask |= RRM_OAM_HO_OSCILLATION_CIO_OFFSET_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of ho_oscillation_cio_offset not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_block_cell_params,"trigger_quantity_for_block"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_block_cell_params,"trigger_quantity_for_block"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            block_cell_params_ho.trigger_quantity_for_block = (rrmc_trigger_quantity_et)lclTemp_value;

        p_rrm_cellconfig->operator_info.ho_configuration.
            bitmask |= RRM_OAM_BLOCK_CELL_PARAMS_HO_PRESENT;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of trigger_quantity_for_block not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_block_cell_params,"a4_threshold_rsrp_for_block"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_block_cell_params,"a4_threshold_rsrp_for_block"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            block_cell_params_ho.a4_threshold_rsrp_for_block = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of a4_threshold_rsrp_for_block not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ho_block_cell_params,"a4_threshold_rsrq_for_block"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->ho_block_cell_params,"a4_threshold_rsrq_for_block"));

        p_rrm_cellconfig->operator_info.ho_configuration.
            block_cell_params_ho.a4_threshold_rsrq_for_block = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of a4_threshold_rsrq_for_block not found");
        return OAM_FAILURE;
    }
    /* Code removed */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->mimo_mode_params,"mimo_num_of_cbsr"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_MIMO_MODE_PARAMS_PRESENT;
        /* SPR 20653 Fix End */

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->mimo_mode_params,"mimo_num_of_cbsr"));

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.num_of_cbsr = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.bitmask |= RRM_OAM_NUM_OF_CSR_PRESENT ;
    }

    UInt8         loop_index = OAM_ZERO;
    UInt8         loop_child_index = OAM_ZERO;
    char    *p_data = OAM_NULL;
    UInt8          num_of_cbsr = p_rrm_cellconfig->operator_info.
        mimo_mode_params.num_of_cbsr;

    for( loop_index = OAM_ZERO; ((loop_index < RRM_OAM_MAX_CODEBOOK_SUBSET) &&( loop_index < num_of_cbsr ) ) ;
            loop_index++ )
    {
        if( OAM_NULL != p_prop_cellconfig->mimo_codebook_subset_restriction[loop_index] )
        {

            lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->mimo_codebook_subset_restriction[loop_index],
                        "mimo_codebook_subset_restriction_type"));

            if( OAM_INVALID_VALUE != lclTemp_value )
            {
                p_rrm_cellconfig->operator_info.
                    mimo_mode_params.mimo_cbsr[loop_index].type = (UInt8)lclTemp_value; 

                p_rrm_cellconfig->operator_info.
                    mimo_mode_params.bitmask |= RRM_OAM_CODEBOOK_SUBSET_RESTRICTION_PRESENT; 
            }

            ptr_child = p_prop_cellconfig->mimo_codebook_subset_restriction[loop_index]->children;

            for( loop_child_index = OAM_ZERO ; ( (loop_child_index < RRM_OAM_MAX_STRING_OF_CODEBOOK_SUBSET )&&
                        ( OAM_NULL != (xmlNode *)ptr_child )); 
                    loop_child_index++ )
            {

                ptr_child = oam_xml_find_tag(ptr_child,(xmlChar *)"mimo_codebook_subset_restriction_value");

                if( OAM_NULL != ptr_child )
                {
                    p_data = ((char *)xmlNodeGetContent( ptr_child ));

                    if( OAM_NULL != p_data )
                    {
                        lclTemp_value =  oam_atoi((const char *)p_data);

                        p_rrm_cellconfig->operator_info.
                            mimo_mode_params.mimo_cbsr[loop_index].value[loop_child_index] = (UInt8)lclTemp_value;

                        ptr_child = (((xmlNode *)ptr_child)->next);
                        xmlFree(p_data);
                    }
                }

            } /* end of inner for loop */

        }

    } /*  end of outer for loop */

    if( p_prop_cellconfig->mimo_transmission_mode_table != OAM_NULL )
    {

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.bitmask |= RRM_OAM_TRANSMISSION_MODE_TABLE_PRESENT ;

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->mimo_transmission_mode_table,"tm_mode_for_strngnt_qci"),OAM_INVALID_STR)!= OAM_ZERO)
          )
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->mimo_transmission_mode_table,"tm_mode_for_strngnt_qci"));


                    p_rrm_cellconfig->operator_info.
                        mimo_mode_params.tm_mode_table.tm_mode_for_strngnt_qci = lclTemp_value;

                    p_rrm_cellconfig->operator_info.
                        mimo_mode_params.tm_mode_table.bitmask |= RRM_OAM_TM_MODE_FOR_STRNGNT_QCI_PRESENT;

        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->mimo_transmission_mode_table,"count"),OAM_INVALID_STR)!= OAM_ZERO)
          )
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->mimo_transmission_mode_table,"count"));

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.tm_mode_table.count = lclTemp_value;

        }
        for( loop_index = OAM_ZERO; ((loop_index < RRM_OAM_MAX_TM_MODE_TABLE_ROW ) && 
                    (loop_index < p_rrm_cellconfig->
                     operator_info.mimo_mode_params.tm_mode_table.count ));
                loop_index++ )
        {
            if( p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index] != OAM_NULL )
            {
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent( p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index],
                                "sinr_level"),OAM_INVALID_STR)!= OAM_ZERO)
                  )
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index],"sinr_level"));

                    p_rrm_cellconfig->operator_info.
                        mimo_mode_params.tm_mode_table.rrm_tm_mode_table_row[loop_index].sinr_level = lclTemp_value;

                }

                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent( p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index],
                                "pathloss_level"),OAM_INVALID_STR)!= OAM_ZERO)
                  )
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index],"pathloss_level"));

                    p_rrm_cellconfig->operator_info.
                        mimo_mode_params.tm_mode_table.rrm_tm_mode_table_row[loop_index].pathloss_level = lclTemp_value;

                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent( p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index],
                                "mobility_level"),OAM_INVALID_STR)!= OAM_ZERO)
                  )
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index],"mobility_level"));

                    p_rrm_cellconfig->operator_info.
                        mimo_mode_params.tm_mode_table.rrm_tm_mode_table_row[loop_index].mobility_level = lclTemp_value;

                }
                if((oam_strcmp
                            ((const char *)oam_xmlNodeGetContent( p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index],
                                "tm_mode"),OAM_INVALID_STR)!= OAM_ZERO)
                  )
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_prop_cellconfig->rrm_oam_tm_mode_table_row[loop_index],"tm_mode"));

                    p_rrm_cellconfig->operator_info.
                        mimo_mode_params.tm_mode_table.rrm_tm_mode_table_row[loop_index].tm_mode = lclTemp_value;

                }
            }
        }   
    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->mimo_mode_params,"sinr_threshold"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->mimo_mode_params,"sinr_threshold"));

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.sinr_threshold = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.bitmask |= RRM_OAM_SINR_THRESHOLD_PRESENT ;
    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->mimo_mode_params,"pathloss_threshold"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->mimo_mode_params,"pathloss_threshold"));

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.pathloss_threshold = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.bitmask |= RRM_OAM_PATHLOSS_THRESHOLD_PRESENT ;
    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->mimo_mode_params,"mobility_threshold"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->mimo_mode_params,"mobility_threshold"));

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.mobility_sinr_threshold = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.bitmask |= RRM_OAM_MOBILITY_SINR_THRESHOLD_PRESENT ;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->mimo_mode_params,"ue_transmit_antenna_selection"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->mimo_mode_params,"ue_transmit_antenna_selection"));

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.ue_transmit_antenna_selection = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.bitmask |= RRM_OAM_UE_TRANSMIT_ANTENNA_SELECTION ;
    }

    /* SPR 20653 Fix Start */
    if( p_prop_cellconfig->ul_mimo_mode_params != OAM_NULL )
    {
        p_rrm_cellconfig->operator_info.
            mimo_mode_params.bitmask |= RRM_OAM_UL_MIMO_MODE_PARAMS_PRESENT ;

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ul_mimo_mode_params,"uplink_sinr_threshold"),OAM_INVALID_STR)!= OAM_ZERO)
          )
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->ul_mimo_mode_params,"uplink_sinr_threshold"));

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.ul_mimo_mode_params.uplink_sinr_threshold = lclTemp_value;

        }
        else
        {
		OAM_LOG(OAM, OAM_WARNING, "Value of uplink_sinr_threshold not found");
            return OAM_FAILURE;
        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ul_mimo_mode_params,"uplink_prb_budget_threshold"),OAM_INVALID_STR)!= OAM_ZERO)
          )
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->ul_mimo_mode_params,"uplink_prb_budget_threshold"));

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.ul_mimo_mode_params.uplink_prb_budget_threshold = lclTemp_value;

        }
        else
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of uplink_prb_budget_threshold not found");
            return OAM_FAILURE;
        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ul_mimo_mode_params,"uplink_prb_budget_down_threshold"),OAM_INVALID_STR)!= OAM_ZERO)
          )
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->ul_mimo_mode_params,"uplink_prb_budget_down_threshold"));

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.ul_mimo_mode_params.uplink_prb_budget_down_threshold = lclTemp_value;

        }
        else
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of uplink_prb_budget_down_threshold not found");
            return OAM_FAILURE;
        }
    }
    if( p_prop_cellconfig->tm_mode_additional_info != OAM_NULL )
    {

        p_rrm_cellconfig->operator_info.
            mimo_mode_params.bitmask |= RRM_OAM_TM_MODE_ADDITIONAL_INFO_PRESENT;

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->tm_mode_additional_info,"pdsch_epre_to_ue_rs_ratio"),OAM_INVALID_STR)!= OAM_ZERO)
          )
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->tm_mode_additional_info,"pdsch_epre_to_ue_rs_ratio"));

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.rrm_tm_mode_additional_info.pdsch_epre_to_ue_rs_ratio = lclTemp_value;

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.rrm_tm_mode_additional_info.bitmask |= RRM_OAM_PDSCH_EPRE_TO_UE_RS_RATIO_PRESENT;

        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->tm_mode_additional_info,"enable_pmi_ri_report_r9"),OAM_INVALID_STR)!= OAM_ZERO)
          )
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->tm_mode_additional_info,"enable_pmi_ri_report_r9"));

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.rrm_tm_mode_additional_info.enable_pmi_ri_report_r9 = (rrm_bool_t)lclTemp_value;

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.rrm_tm_mode_additional_info.bitmask |= RRM_OAM_ENABLE_PMI_RI_REPORT_R9_PRESENT;

        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->tm_mode_additional_info,"beam_forming_algo"),OAM_INVALID_STR)!= OAM_ZERO)
          )
        {
            p_rrm_cellconfig->operator_info.mimo_mode_params.rrm_tm_mode_additional_info.bitmask |= 
                RRM_OAM_BEAM_FORMING_ALGO_INFO_PRESENT;
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->tm_mode_additional_info,"beam_forming_algo"));

            p_rrm_cellconfig->operator_info.
                mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.beam_forming_algo = (rrm_beam_forming_algo_et)lclTemp_value;

            if(lclTemp_value == OAM_ZERO)
            {
                tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->beam_forming_vector, "SINR_beamforming_vector");

                if(oam_strcmp((const char *)tag_value, OAM_INVALID_STR)) {
                    p_temp_token = oam_strtok((char *)tag_value,",");        
                    counter = OAM_ZERO;
                    while (OAM_NULL != p_temp_token && counter < (RRM_MAX_BF_VECTORS_TO_SINR_VAL + OAM_ONE))
                    {
                        lclTemp_value2 = oam_atoi(p_temp_token);
                        p_rrm_cellconfig->operator_info.mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.
                            sinr_beamforming_vector[counter] = lclTemp_value2;
                        counter++;
                        p_temp_token = oam_strtok(OAM_NULL,",");
                    }
                    while(counter < RRM_MAX_BF_VECTORS_TO_SINR_VAL)
                    {
                        p_rrm_cellconfig->operator_info.mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.
                            sinr_beamforming_vector[counter - 1] = lclTemp_value2;  
                        counter++;
                    }
                    p_rrm_cellconfig->operator_info.mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.bitmask |= 
                        RRM_OAM_SINR_BEAM_FORMING_ALGO_PRESENT;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING, "param sinr_beamforming_vector missing");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
            }
            else
            {
                tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->beam_forming_vector, "AOA_beamforming_vector");

                if(oam_strcmp((const char *)tag_value, OAM_INVALID_STR)) {
                    p_temp_token = oam_strtok((char *)tag_value,",");        
                    counter = OAM_ZERO;
                    while (OAM_NULL != p_temp_token && counter < (RRM_MAX_BF_VECTORS_TO_AOA_VAL + OAM_ONE))
                    {
                        lclTemp_value2 = oam_atoi(p_temp_token);
                        p_rrm_cellconfig->operator_info.mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.
                            aoa_beamforming_vector[counter] = lclTemp_value2;
                        counter++;
                        p_temp_token = oam_strtok(OAM_NULL,",");
                    }
                    while(counter < RRM_MAX_BF_VECTORS_TO_AOA_VAL)
                    {
                        /* SPR 23054 Fix - Starts */
                        p_rrm_cellconfig->operator_info.mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.
                            aoa_beamforming_vector[counter] = lclTemp_value2;  
                        /* SPR 23054 Fix - Ends */
                        counter++;
                    }
                    p_rrm_cellconfig->operator_info.mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.bitmask |= 
                        RRM_OAM_AOA_BEAM_FORMING_ALGO_PRESENT;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING, "param aoa_beamforming_vector missing");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
            }

        }
        /* SPR 21536 start */
        /* Code removed */
        /* SPR 21536 end */
    }
    /* SPR 20653 Fix End */

    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RRCTimers,"X_VENDOR_WAIT_TIME"),OAM_INVALID_STR)!= OAM_ZERO))       
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RRCTimers, "X_VENDOR_WAIT_TIME"));

        p_rrm_cellconfig->operator_info.
            load_params.wait_time = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            load_params.bitmask |= RRM_OAM_WAIT_TIME_PRESENT;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_LOAD_PARAMS_PRESENT;
    }
    /* SPR 20653 Fix Start */
    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RRCTimers,"X_VENDOR_EXTENDED_WAIT_TIME"),OAM_INVALID_STR)!= OAM_ZERO))       
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RRCTimers, "X_VENDOR_EXTENDED_WAIT_TIME"));

        p_rrm_cellconfig->operator_info.
            load_params.extended_wait_time = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            load_params.bitmask |= RRM_OAM_EXTENDED_WAIT_TIME_PRESENT;

        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_LOAD_PARAMS_PRESENT;
    }
    /* SPR 20653 Fix End */ 

    /* As currently we support only 15KHz Sub Carrier Spacing, assigning 1 for 15KHz */
    p_rrm_cellconfig->operator_info.
        additional_cell_params.sub_carrier_spacing = OAM_ZERO;

    /*Bug fix */
    p_rrm_cellconfig->operator_info.bitmask |=  RRM_OAM_ADD_CELL_PARAMS_PRESENT;  

    /* As currently we support only normal cyclic prefix, assigning 1 for normal cyclic prefix */
    p_rrm_cellconfig->operator_info.
        additional_cell_params.dl_cyclic_prefix = OAM_ZERO;

    UInt32 dl_mcs = OAM_ZERO,
           ul_mcs = OAM_ZERO;

    dl_mcs = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->additional_packet_scheduling_params,"dl_mcs"),OAM_INVALID_STR);
    ul_mcs = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->additional_packet_scheduling_params,"ul_mcs"),OAM_INVALID_STR);

    if((dl_mcs != OAM_ZERO)
            &&(ul_mcs != OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->additional_packet_scheduling_params,"dl_mcs"));
        p_rrm_cellconfig->operator_info.
            additional_packet_scheduling_params.dl_mcs = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            additional_packet_scheduling_params.bitmask |= RRM_OAM_DL_MCS_PRESENT;


        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->additional_packet_scheduling_params,"ul_mcs"));

        p_rrm_cellconfig->operator_info.
            additional_packet_scheduling_params.ul_mcs = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            additional_packet_scheduling_params.bitmask |= RRM_OAM_UL_MCS_PRESENT;
        p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ADD_PACKET_SCH_PARAMS_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->additional_packet_scheduling_params,"frequency_selective_scheduling"));

        p_rrm_cellconfig->operator_info.
            additional_packet_scheduling_params.frequency_selective_scheduling = lclTemp_value;
        /* SPR 21958 PUSCH RAT1 Support Start */
        if((p_rrm_cellconfig->operator_info.additional_packet_scheduling_params.frequency_selective_scheduling > OAM_ZERO)&&
            (p_rrm_cellconfig->operator_info.additional_packet_scheduling_params.frequency_selective_scheduling <= OAM_THREE))
        {
            /* SPR 22549 Fix Start */
            fss_flag[cell_index] = OAM_ONE;
            /* SPR 22549 Fix End */
        }		
        /* SPR 21958 PUSCH RAT1 Support End */

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->additional_packet_scheduling_params,"cqi_reporting_mode"));

        p_rrm_cellconfig->operator_info.
            additional_packet_scheduling_params.cqi_reporting_mode = lclTemp_value;

        /* SPR 20653 Fix Start */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->additional_packet_scheduling_params,"min_ri_periodicity"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_INFO,
                    "Value of min_ri_periodicity not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                additional_packet_scheduling_params.min_ri_periodicity = lclTemp_value;

            p_rrm_cellconfig->operator_info.
                additional_packet_scheduling_params.bitmask |= RRM_OAM_MIN_RI_PERIODICITY_PRESENT;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->additional_packet_scheduling_params,"min_cqi_periodicity"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_INFO,
                    "Value of min_cqi_periodicity not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                additional_packet_scheduling_params.min_cqi_periodicity = lclTemp_value;
            p_rrm_cellconfig->operator_info.
                additional_packet_scheduling_params.bitmask |= RRM_OAM_MIN_CQI_PERIODICITY_PRESENT;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->additional_packet_scheduling_params,"min_sr_periodicity"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_INFO,
                    "Value of min_sr_periodicity not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                additional_packet_scheduling_params.min_sr_periodicity = lclTemp_value;
            p_rrm_cellconfig->operator_info.
                additional_packet_scheduling_params.bitmask |= RRM_OAM_MIN_SR_PERIODICITY_PRESENT;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->additional_packet_scheduling_params,"nom_pdsch_rs_epre_offset"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_INFO,
                    "Value of nom_pdsch_rs_epre_offset not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                additional_packet_scheduling_params.nom_pdsch_rs_epre_offset = lclTemp_value;
            p_rrm_cellconfig->operator_info.
                additional_packet_scheduling_params.bitmask |= NOM_PDSCH_RS_EPRE_OFFSET_PRESENT;
        }
        /* SPR 20653 Fix End */
    }

    SInt8 start_sps_crnti_range = OAM_ZERO,
          end_sps_crnti_range = OAM_ZERO;

    start_sps_crnti_range = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_crnti,"start_sps_crnti_range"),OAM_INVALID_STR);
    end_sps_crnti_range = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_crnti,"end_sps_crnti_range"),OAM_INVALID_STR);
    if((start_sps_crnti_range != OAM_ZERO)
            &&(end_sps_crnti_range != OAM_ZERO))
    {

        p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_SPS_CRNTI_RANGE_PRESENT; 

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->sps_crnti,"start_sps_crnti_range"));

        p_rrm_cellconfig->operator_info.
            rrm_sps_crnti_range.start_sps_crnti_range = lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->sps_crnti,"end_sps_crnti_range"));

        p_rrm_cellconfig->operator_info.
            rrm_sps_crnti_range.end_sps_crnti_range = lclTemp_value;

    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->tpc_rnti,"startTpcRntiPucch"));

    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->operator_info.
            rrm_power_control_params.rrm_tpc_rnti_range.startTpcRntiPucch = lclTemp_value;

        /*Bug fix */
        p_rrm_cellconfig->operator_info.
            rrm_power_control_params.bitmask |= RRM_OAM_TPC_RNTI_RANGE_PRESENT;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->tpc_rnti,"endTpcRntiPucch"));

    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->operator_info.
            rrm_power_control_params.rrm_tpc_rnti_range.endTpcRntiPucch = lclTemp_value;

    }
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->tpc_rnti,"startTpcRntiPusch"));

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_tpc_rnti_range.startTpcRntiPusch = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->tpc_rnti,"endTpcRntiPusch"));

    p_rrm_cellconfig->operator_info.
        rrm_power_control_params.rrm_tpc_rnti_range.endTpcRntiPusch = lclTemp_value;

    /* SPR 20653 Fix Start */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->mac_periodic,"periodic_report_required"));

    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->operator_info.
            rrm_mac_config.periodic_report_required = (rrm_bool_t)lclTemp_value;

        p_rrm_cellconfig->operator_info.
            rrm_mac_config.bitmask |= RRM_OAM_PERIODIC_REPORT_REQUIRED_PRESENT;
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,
                "Value of periodic_report_required not found");

        return OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->mac_periodic,"periodic_report_periodicity"));

    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->operator_info.
            rrm_mac_config.periodic_report_periodicity = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            rrm_mac_config.bitmask |= RRM_OAM_PERIODIC_REPORT_PERIODICITY_PRESENT;
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,
                "Value of periodic_report_periodicity not found");

        return OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->mac_periodic,"periodic_report_ue_batch_size"));

    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        p_rrm_cellconfig->operator_info.
            rrm_mac_config.periodic_report_ue_batch_size = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            rrm_mac_config.bitmask |= RRM_OAM_PERIODIC_REPORT_UE_BATCH_SIZE_PRESENT;
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,
                "Value of periodic_report_ue_batch_size not found");

        return OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->mac_periodic,"sampling_normal_time"));

    if( OAM_INVALID_VALUE != lclTemp_value )
    {
        /* SPR 22420 Fix Start */
        if((lclTemp_value > OAM_ZERO) && (lclTemp_value <= MAX_SAMPLING_NORMAL_TIME))
        {
            p_rrm_cellconfig->operator_info.
                rrm_mac_config.sampling_normal_time = lclTemp_value;
            p_rrm_cellconfig->operator_info.
                rrm_mac_config.bitmask |= RRM_OAM_SAMPLING_NORMAL_TIME;
        }
        else
        {
            if(OAM_ZERO == (lclTemp_value%OAM_HUNDRED))
            {
                abs_value = (lclTemp_value/OAM_HUNDRED) - OAM_HUNDRED;
                if((abs_value >= OAM_ONE) && (abs_value <= OAM_NINE)) 
                {
                    p_rrm_cellconfig->operator_info.
                        rrm_mac_config.sampling_normal_time = lclTemp_value;
                    p_rrm_cellconfig->operator_info.
                        rrm_mac_config.bitmask |= RRM_OAM_SAMPLING_NORMAL_TIME;
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Invalid Value of sampling_normal_time %d", lclTemp_value);
                    return OAM_FAILURE;
                }
            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Invalid Value of sampling_normal_time %d", lclTemp_value);
                return OAM_FAILURE;
            }
        }
        /* SPR 22420 Fix End */
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,
                "Value of sampling_normal_time not found");

        return OAM_FAILURE;
    }
    /* SPR 20653 Fix End */

    tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
            "pdcchPoworAggregationEnable");
    lclTemp_value = oam_atoi((Char8*)tag_value);
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "harqBlerClpcPucchEnable");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.harqBlerClpcPucchEnable = lclTemp_value;

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.
            bitmask |= RRM_OAM_HARQ_BLER_CLPC_PUCCH_ENABLE_PRESENT;

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "cqiSinrClpcPucchEnable");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.cqiSinrClpcPucchEnable = lclTemp_value;

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.
            bitmask |= RRM_OAM_CQI_SINR_CLPC_PUCCH_ENABLE_PRESENT; 

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "clpcPuschEnable");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.clpcPuschEnable = lclTemp_value;

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.bitmask |= RRM_OAM_CLPC_PUSCH_PRESENT;

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "dci_3_3a_based_power_control_for_pucch_enable");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.
            dci_3_3a_based_power_control_for_pucch_enable = lclTemp_value;

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.bitmask |= RRM_OAM_DCI_3_3A_PUCCH_PRESENT;

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "dci_3_3a_based_power_control_for_pusch_enable");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.
            dci_3_3a_based_power_control_for_pusch_enable = lclTemp_value;

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.bitmask |= RRM_OAM_DCI_3_3A_PUSCH_PRESENT;

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "clpcPuschfreqSelectiveEnable");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.
            clpcPuschfreqSelectiveEnable = lclTemp_value;

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.
            bitmask |= RRM_OAM_CLPC_PUSCH_FREQ_SELECTIVE_PRESENT;

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "pdcchPoworAggregationEnable");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.pdcchPowOrAggregationEnable = lclTemp_value;

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "delta_mcs_enabled");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.delta_mcs_enabled = lclTemp_value;

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.
            bitmask |= RRM_OAM_DELTA_MCS_ENABLED_PRESENT;

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->power_control_enable,
                    "accumulation_enabled");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.accumulation_enabled = lclTemp_value;

        p_rrm_cellconfig->operator_info.rrm_power_control_params.
            rrm_power_control_enable.
            bitmask |= RRM_OAM_ACCUMULATION_ENABLED_PRESENT;

        /* SPR 20653 Fix Start */
        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->uplink_power_control_dedicated,
                    "p0_ue_pusch");
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(OAM_INVALID_VALUE != lclTemp_value)
        {
            p_rrm_cellconfig->operator_info.rrm_power_control_params.
                uplink_power_control_dedicated.p0_ue_pusch = lclTemp_value;

            p_rrm_cellconfig->operator_info.rrm_power_control_params.
                bitmask |= RRM_OAM_UL_POWER_CONTROL_DEDICATED_PRESENT;
        }
        else
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of p0_ue_pusch not found");

            return OAM_FAILURE;
        }
        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->uplink_power_control_dedicated,
                    "p0_ue_pucch");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(OAM_INVALID_VALUE != lclTemp_value)
        {
            p_rrm_cellconfig->operator_info.rrm_power_control_params.
                uplink_power_control_dedicated.p0_ue_pucch = lclTemp_value;
        }
        else
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of p0_ue_pucch not found");

            return OAM_FAILURE;
        }
        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->uplink_power_control_dedicated,
                    "p_srs_offset");
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(OAM_INVALID_VALUE != lclTemp_value)
        {
            p_rrm_cellconfig->operator_info.rrm_power_control_params.
                uplink_power_control_dedicated.p_srs_offset = lclTemp_value;
        }
        else
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of p_srs_offset not found");

            return OAM_FAILURE;
        }

        tag_value =
            oam_xmlNodeGetContent(p_prop_cellconfig->uplink_power_control_dedicated,
                    "filter_coefficient");
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(OAM_INVALID_VALUE != lclTemp_value)
        {
            p_rrm_cellconfig->operator_info.rrm_power_control_params.
                uplink_power_control_dedicated.filter_coefficient = lclTemp_value;
        }
        else
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of filter_coefficient not found");

            return OAM_FAILURE;
        }
        /* SPR 20653 Fix End */
    }
    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_params,"max_sps_ues"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->admission_control_info,"resource_reserved_for_existing_users"));

        p_rrm_cellconfig->operator_info.
            admission_control_info.resource_reserved_for_existing_users = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            admission_control_info.bitmask |= RRM_OAM_RESOURCE_RESERVED_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->sps_params, "max_sps_ues"));
        if(lclTemp_value >= MIN_SPS_UES &&
                lclTemp_value <= MAX_SPS_UES) {
            p_rrm_cellconfig->operator_info.
                admission_control_info.max_sps_ues = lclTemp_value;
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of max_sps_ues is %d and "
                    "range is from %d to %d",
                    lclTemp_value, OAM_ONE,
                    MAX_SPS_UES);
            return OAM_FAILURE;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->admission_control_info,"preemption_allowed"));

        p_rrm_cellconfig->operator_info.
            admission_control_info.preemption_allowed = lclTemp_value;

        p_rrm_cellconfig->operator_info.
            admission_control_info.bitmask |= RRM_OAM_PREEMPTION_ALLOWED_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->admission_control_info,"preemption_status"));

        /* coverity 35764 */
        p_rrm_cellconfig->operator_info.
            admission_control_info.preemption_status = (rrm_bool_et)lclTemp_value;

        p_rrm_cellconfig->operator_info.
            admission_control_info.bitmask |= RRM_OAM_PREEMPTION_STATUS_PRESENT;

        /* SPR 20653 Fix Start */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->admission_control_info,"srb_bit_rate"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of srb_bit_rate not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.srb_bit_rate = lclTemp_value;

            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_SRB_BIT_RATE_PRESENT;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->admission_control_info,"minimum_bitrate"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of minimum_bitrate not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.minimum_bitrate = lclTemp_value;

            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_MIN_BITRATE_PRESENT;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->admission_control_info,"ngbr_threshold"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of ngbr_threshold not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.ngbr_threshold = lclTemp_value;

            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_NGBR_THRESHOLD_PRESENT;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->admission_control_info,"non_default_bearer_multiplier"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of non_default_bearer_multiplier not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.non_default_bearer_multiplier = lclTemp_value;

            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_NON_DEFAULT_BEARER_MULTIPLIER_PRESENT;
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->prb_estimation_factor,"dl_prb_per_bps"));
        if(lclTemp_value >= MIN_PRB_PER_BPS  && 
                lclTemp_value <= MAX_PRB_PER_BPS) 
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |=
                RRM_OAM_PRB_ESTIMATION_FACTOR_PRESENT;
            p_rrm_cellconfig->operator_info.
                admission_control_info.prb_estimation_factor.dl_prb_per_bps = lclTemp_value;
            p_rrm_cellconfig->operator_info.
                admission_control_info.prb_estimation_factor.bitmask |=
                RRM_OAM_DL_PRB_PER_BPS_PRESENT;
        }
        else {
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                            p_prop_cellconfig->prb_estimation_factor,"dl_prb_per_bps"),
                        OAM_INVALID_STR)!= OAM_ZERO)
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of dl_prb_per_bps is %d and range is from %d to %d",
                        lclTemp_value,MIN_PRB_PER_BPS, MAX_PRB_PER_BPS);
            }
        }

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->prb_estimation_factor,"ul_prb_per_bps"));
        if(lclTemp_value >= MIN_PRB_PER_BPS  && 
                lclTemp_value <= MAX_PRB_PER_BPS) 
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |=
                RRM_OAM_PRB_ESTIMATION_FACTOR_PRESENT;
            p_rrm_cellconfig->operator_info.
                admission_control_info.prb_estimation_factor.ul_prb_per_bps = lclTemp_value;
            p_rrm_cellconfig->operator_info.
                admission_control_info.prb_estimation_factor.bitmask |=
                RRM_OAM_UL_PRB_PER_BPS_PRESENT;
        }
        else {
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                            p_prop_cellconfig->prb_estimation_factor,"ul_prb_per_bps"),
                        OAM_INVALID_STR)!= OAM_ZERO)
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of ul_prb_per_bps is %d and range is from %d to %d",
                        lclTemp_value,MIN_PRB_PER_BPS, MAX_PRB_PER_BPS);
            }
        }
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->admission_control_info,"max_eicic_ues"));

        if(OAM_INVALID_VALUE == lclTemp_value)
        {
            OAM_LOG(OAM, OAM_WARNING,"Value of max_eicic_ues not found");

            return OAM_FAILURE;
        }
        else
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.max_eicic_ues = lclTemp_value;
        }
        /* SPR 20653 Fix End */

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.operator_info,"proximity_indication_status"));

        /* coverity 35765 */
        p_rrm_cellconfig->operator_info.
            admission_control_info.proximity_indication_status = (rrm_bool_et)lclTemp_value;

        p_rrm_cellconfig->operator_info.
            admission_control_info.bitmask |= RRM_OAM_PROXIMITY_IND_STATUS_PRESENT;

    }

    /* CSR 00051178 CHANGES START */ 

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,"SI_WINDOW_LENGTH"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,"SI_WINDOW_LENGTH"));

        p_rrm_cellconfig->operator_info.
            sib_1_info.si_window_length = lclTemp_value;
        p_rrm_cellconfig->operator_info.
            sib_1_info.bitmask |= RRM_OAM_SI_WINDOW_SIZE_PRESENT;
        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_ADDL_SIB1_INFO_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,"SI_COUNT"));

        /* SPR 7497 CHANGES START */
        if 
            (
             lclTemp_value >= MIN_SI_COUNT 
             && 
             lclTemp_value <= MAX_SI_COUNT
            )
            {   
                /* SPR 7497 CHANGES END */
                p_rrm_cellconfig->operator_info.
                    sib_1_info.si_count= lclTemp_value;
                /* SPR 7497 CHANGES START */
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of si_count is %d and range is from %d to %d",
                    lclTemp_value,MIN_SI_COUNT,MAX_SI_COUNT);

            return OAM_FAILURE;
        }
        /* SPR 7497 CHANGES END */
        /* CID: 99566 Fix Start */
        for(count=0; (count <p_rrm_cellconfig->operator_info.sib_1_info.si_count) && (p_rrm_cellconfig->operator_info.sib_1_info.si_count < RRM_OAM_MAX_NUM_SI) ; count++)
            /* CID: 99566 Fix Stop */
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->SCHEDULING_INFO[count],"SI_PERIODICITY"));
            /* SPR 7497 CHANGES START */
            if 
                (
                 lclTemp_value >= MIN_SI_OAM_PERIODICITY 
                 && 
                 lclTemp_value <= MAX_SI_OAM_PERIODICITY
                )
                {   
                    /* SPR 7497 CHANGES END */
                    p_rrm_cellconfig->operator_info.
                        sib_1_info.scheduling_info[count].si_periodicity = lclTemp_value;
                    /* SPR 7497 CHANGES START */
                }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of si_periodicity at scheduling_info[%d] is %d and range is from %d to %d",
                        count,lclTemp_value,MIN_SI_OAM_PERIODICITY,MAX_SI_OAM_PERIODICITY);

                return OAM_FAILURE;
            }
            /* SPR 7497 CHANGES END */

            UInt8 count2=OAM_ZERO;
            /* SPR 11599 CHANGES START */
            for(count2=OAM_ZERO;count2<RRM_OAM_MAX_SIB;count2++)
                /* SPR 11599 CHANGES END */
            {
                p_rrm_cellconfig->operator_info.
                    sib_1_info.scheduling_info[count].sib_mapping_info[count2].sib_type=-1;
            }

            SInt8 num_sib_type= OAM_ZERO;
            num_sib_type = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SCHEDULING_INFO[count],"NUM_SIB_TYPE"));
            /* SPR 7497 CHANGES START */
            /* SPR 14072 START */
            if (num_sib_type == OAM_ZERO && count != OAM_ZERO)
            {
                /* SPR 14072 END*/
                if 
                    (!(
                       num_sib_type >= MIN_NUM_SIB_TYPE 
                       && 
                       num_sib_type <= MAX_NUM_SIB_TYPE
                      ))
                    {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Value of num_sib_type is %d and range is from %d to %d",
                                num_sib_type,MIN_NUM_SIB_TYPE,MAX_NUM_SIB_TYPE);

                        return OAM_FAILURE;
                    }
                /* SPR 14072 START */
            }
            /* SPR 14072 END*/
            /* SPR 7497 CHANGES END */		
            UInt8 sib_type_count=OAM_ZERO;
            xmlNode* sib_type = oam_xml_find_tag(p_cell_spec_params->SCHEDULING_INFO[count]->children,(xmlChar *)"SIB_TYPE");
            while(num_sib_type > OAM_ZERO )
            {
                char *temp=(char *)xmlNodeGetContent(sib_type);
                if(temp)
                {

                    lclTemp_value = oam_atoi(temp);
                    /* SPR 7497 CHANGES START */
                    if 
                        (
                         lclTemp_value >= MIN_SIB_TYPE 
                         && 
                         lclTemp_value <= MAX_SIB_TYPE
                        )
                        { 	
                            /* SPR 7497 CHANGES END */
                            p_rrm_cellconfig->operator_info.
                                sib_1_info.scheduling_info[count].sib_mapping_info[sib_type_count].sib_type = lclTemp_value;
                            /* SPR 7497 CHANGES START */
                        }
                    else
                    {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Value of sib_type at scheduling_info[%d].sib_type[%d] is %d and range is from %d to %d",
                                count,sib_type_count,lclTemp_value,MIN_SIB_TYPE,MAX_SIB_TYPE);
                        return OAM_FAILURE;
                    }
                    xmlFree(temp);
                }
                else
                {
                    OAM_LOG(OAM, OAM_INFO,
                            "Value of sib_type tag not found");
                    return OAM_FAILURE;
                }
                /* SPR 7497 CHANGES END */
                sib_type= sib_type->next;
                sib_type_count++;	
                num_sib_type--;
            }
        }

        /* CSR 00051178 CHANGES END */


    } 
    /*SPR 21206 Start*/
    tag_value =
        oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,
                "AssocLayer2Inst");
    if(oam_strcmp((const char *)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((const char *)tag_value);
        p_rrm_cellconfig->operator_info.
            associated_layer2_inst = lclTemp_value;
	     p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ASSOCIATED_LAYER2_INST_FIELD_PRESENT;
        l2_instance = p_rrm_cellconfig->operator_info.associated_layer2_inst;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "AssocLayer2Inst info not present ");
        retVal = OAM_FAILURE;
        return retVal;

    }
    /*SPR 21206 End*/
    /*Mobility Params Ends here */
    /* SPR 20653 Fix Start */
    /* SPR 21088 Fix Start */
    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->spid_table,"default_rat_priority_info"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->default_rat_priority_info,"IRAT_PRIORITY_EUTRAN")); 
        p_rrm_cellconfig->operator_info.
            admission_control_info.spid_table.default_rat_priority_info.irat_priority_list_cfg[0]= (rrm_irat_priority_et)lclTemp_value;		   
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->default_rat_priority_info,"IRAT_PRIORITY_UTRAN")); 
        p_rrm_cellconfig->operator_info.
            admission_control_info.spid_table.default_rat_priority_info.irat_priority_list_cfg[1]= (rrm_irat_priority_et)lclTemp_value;		   
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->default_rat_priority_info,"IRAT_PRIORITY_GERAN")); 
        p_rrm_cellconfig->operator_info.
            admission_control_info.spid_table.default_rat_priority_info.irat_priority_list_cfg[2]= (rrm_irat_priority_et)lclTemp_value;		   
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->default_rat_priority_info,"IRAT_PRIORITY_CDMA2000")); 
        p_rrm_cellconfig->operator_info.
            admission_control_info.spid_table.default_rat_priority_info.irat_priority_list_cfg[3]= (rrm_irat_priority_et)lclTemp_value;		   
        p_rrm_cellconfig->operator_info.
            admission_control_info.spid_table.bitmask |= RRM_OAM_RAT_PRIORITY_INFO_PRESENT;
    }    
    /* SPR 21088 Fix End */

    /* SPR 20653 Fix End */
    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->spid_table,"spid_count"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->spid_table,"spid_count")); 
        p_rrm_cellconfig->operator_info.
            admission_control_info.spid_table.spid_count= lclTemp_value;		   
        p_rrm_cellconfig->operator_info.
            admission_control_info.bitmask |= RRM_OAM_SPID_TABLE_PRESENT;

        for
            (
             count = OAM_ZERO;
             count < p_rrm_cellconfig->operator_info.admission_control_info.spid_table.spid_count;
             count++
            )
            {
                if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->spid_config[count].p_spid_config,"spid"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_prop_cellconfig->spid_config[count].p_spid_config,"spid"));   
                    p_rrm_cellconfig->operator_info.
                        admission_control_info.spid_table.spid_config[count].spid= lclTemp_value;		   
                }
                /* SPR 20653 Fix Start */
                else
                {
                        OAM_LOG(OAM, OAM_WARNING, "Value of spid not found");
                    return OAM_FAILURE;
                }

                if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->spid_config[count].p_spid_config,"rat_count"),OAM_INVALID_STR)!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_prop_cellconfig->spid_config[count].p_spid_config,"rat_count")); 
                    p_rrm_cellconfig->operator_info.
                        admission_control_info.spid_table.spid_config[count].rrm_rat_priority_list.rat_count= lclTemp_value;		   
                }
                else
                {
                        OAM_LOG(OAM, OAM_WARNING, "Value of rat_count not found");
                    return OAM_FAILURE;
                }

                for(count1 = OAM_ZERO; count1 < p_rrm_cellconfig->operator_info.
                        admission_control_info.spid_table.spid_config[count].rrm_rat_priority_list.rat_count; count1++)
                {
                    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->spid_config[count].rat_priority[count1].rat_priority,"rat_type"),OAM_INVALID_STR)!= OAM_ZERO))
                    {
                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->spid_config[count].rat_priority[count1].rat_priority,"rat_type")); 
                        p_rrm_cellconfig->operator_info.
                            admission_control_info.spid_table.spid_config[count].rrm_rat_priority_list.rrm_rat_priority_info[count1].rat_type= (rrm_oam_rat_type_et)lclTemp_value;		   
                    }
                    else
                    {
                            OAM_LOG(OAM, OAM_WARNING, "Value of rat_type not found");
                        return OAM_FAILURE;
                    }

                    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->spid_config[count].rat_priority[count1].rat_priority,"freq_count"),OAM_INVALID_STR)!= OAM_ZERO))
                    {
                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->spid_config[count].rat_priority[count1].rat_priority,"freq_count"));  
                        p_rrm_cellconfig->operator_info.
                            admission_control_info.spid_table.spid_config[count].rrm_rat_priority_list.rrm_rat_priority_info[count1].freq_count= lclTemp_value;		   
                    }
                    else
                    {
                            OAM_LOG(OAM, OAM_WARNING, "Value of freq_count not found");
                        return OAM_FAILURE;
                    }

                    for(index = OAM_ZERO; index < p_rrm_cellconfig->operator_info.admission_control_info.spid_table.spid_config[count].
                            rrm_rat_priority_list.rrm_rat_priority_info[count1].freq_count; index++)
                    {
                        /* SPR 22516 Fix Start */
                        if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->spid_config[count].rat_priority[count1].freq_priority[index].freq_priority,"freq"),OAM_INVALID_STR)!= OAM_ZERO))
                        {
                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        p_prop_cellconfig->spid_config[count].rat_priority[count1].freq_priority[index].freq_priority,"freq"));  
                            p_rrm_cellconfig->operator_info.
                                admission_control_info.spid_table.spid_config[count].rrm_rat_priority_list.rrm_rat_priority_info[count1].freq_priority[index].freq = lclTemp_value;		   
                        }
                        else
                        {
                                OAM_LOG(OAM, OAM_WARNING, "Value of freq not found");
                            return OAM_FAILURE;
                        }
                        /* SPR 22516 Fix End */
                        if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->spid_config[count].rat_priority[count1].freq_priority[index].freq_priority,"new_priority"),OAM_INVALID_STR)!= OAM_ZERO))
                        {
                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        p_prop_cellconfig->spid_config[count].rat_priority[count1].freq_priority[index].freq_priority,"new_priority"));  
                            p_rrm_cellconfig->operator_info.
                                admission_control_info.spid_table.spid_config[count].rrm_rat_priority_list.rrm_rat_priority_info[count1].freq_priority[index].new_priority = lclTemp_value;		   
                        }
                        else
                        {
                                OAM_LOG(OAM, OAM_WARNING, "Value of new_priority not found");
                            return OAM_FAILURE;
                        }
                    }
                }
            }
    }
    else
    {
            OAM_LOG(OAM, OAM_WARNING, "Value of spid_count not found");
        return OAM_FAILURE;
    }
    /* SPR 20653 Fix End */

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->Common_2, "X_VENDOR_TIME_ALIGNMENT_TIMER_COMMON")); 
    p_rrm_cellconfig->operator_info.
        sib_2_info.time_alignment_timer_common=lclTemp_value;		   

    /* coverity 52770 */
    U8 lclTemp_value_spec; 
    lclTemp_value_spec=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->Common_2,"X_VENDOR_ADDITIONAL_SPECTRUM_EMISSION"));	
    p_rrm_cellconfig->operator_info.
        sib_2_info.additional_spectrum_emission=lclTemp_value_spec;	



    /* coverity 52769 */
    /* BITSTRING CHANGES START */
    /* SPR 16419 Fix Start */
    if(OAM_NULL != p_cell_spec_params->AC_BARRING_FOR_CSFB_R10)
    {
        /* SPR 16419 Fix Stop */

        lclTemp_value2=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->AC_BARRING_FOR_CSFB_R10,"AC_BARRING_FOR_SPECIAL_AC"));
        p_rrm_cellconfig->operator_info.
            sib_2_info.ac_barring_for_csfb_r10.
            ac_barring_for_special_ac=lclTemp_value2;          

        p_rrm_cellconfig->operator_info.
            sib_2_info.ac_barring_for_csfb_r10.
            ac_barring_for_special_ac <<= OAM_THREE;          
        /* BITSTRING CHANGES END */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->AC_BARRING_FOR_CSFB_R10, "AC_BARRING_FACTOR"));
        /* coverity 35792 */	
        p_rrm_cellconfig->operator_info.
            sib_2_info.ac_barring_for_csfb_r10.
            ac_barring_factor=(rrm_oam_ac_barring_factor_et)lclTemp_value;		   

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->AC_BARRING_FOR_CSFB_R10, "AC_BARRING_TIME"));   
        /* coverity 35797 */
        p_rrm_cellconfig->operator_info.
            sib_2_info.ac_barring_for_csfb_r10.
            ac_barring_time=(rrm_oam_ac_barring_time_et)lclTemp_value;		   

        /* SPR 15289 FIX START */
        p_rrm_cellconfig->operator_info.sib_2_info.presence_bitmask |=
            RRM_OAM_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG;
        /* SPR 15289 FIX End */
        /* SPR 16419 Fix Start */
    }
    /* SPR 16419 Fix Stop */

    /*2.0 Params Add End*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EPC,"MaxPLMNListEntries"));

    p_plmnlist_data->max_plmn_entries = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EPC,"PLMNListNumberOfEntries"));
    if (lclTemp_value <= p_plmnlist_data->max_plmn_entries) {
        p_plmnlist_data->curr_plmn_entries = lclTemp_value;
    }
    else {
        OAM_LOG(OAM, OAM_WARNING, "Value of PLMNListNumberOfEntries is %d"
                " and range is from 1 to %d",
                lclTemp_value, p_plmnlist_data->max_plmn_entries);

        return OAM_FAILURE;
    }

    /* Validate PLMN entries present in PLMNList */
    if(OAM_FAILURE == oam_validate_plmnList(p_plmnlist_data->curr_plmn_entries,p_cell_spec_params))
    {
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    /* SPR 15917 END */

    UInt8  instance_id = OAM_ZERO;
    UInt8  plmn_idx = OAM_ZERO;
    for(i = OAM_ZERO; i < p_plmnlist_data->curr_plmn_entries; i++)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PLMNList[i],"X_VENDOR_INSTANCE_ID"));

        instance_id = lclTemp_value;

        OAM_LOG(OAM, OAM_INFO,"Instance number %d ",instance_id);
        /* SPR 15917 START */

        /* Read Enable parameter first */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PLMNList[instance_id - OAM_ONE],"Enable"));

        p_plmnlist_data->plmn_entries[instance_id - OAM_ONE].enable = lclTemp_value;

        p_plmnlist_data->is_valid_bitmap |= 1 << (instance_id - OAM_ONE);


        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PLMNList[instance_id - OAM_ONE],"IsPrimary"));
        p_plmnlist_data->plmn_entries[instance_id - OAM_ONE].is_primary = lclTemp_value;

        /* SPR 19349 Fix Start */
        /*SPR 23815 Fix Start*/
        UInt8 primary_idx = OAM_ZERO;
        if(((instance_id - OAM_ONE) > OAM_ZERO) && (p_plmnlist_data->plmn_entries[instance_id - OAM_ONE].is_primary))
        {
            primary_idx = instance_id - OAM_ONE;
            p_plmn_entries = p_plmnlist_data->plmn_entries;
        }
        /*SPR 23815 Fix End*/
        /* SPR 19349 Fix End */
        if((UInt8)OAM_TRUE == 
                p_plmnlist_data->plmn_entries[instance_id - OAM_ONE].enable)
        {
            /* Fill RRM Cell Config Structure and
             * OAM structure for PLMNList */

            temp = (char *)oam_xmlNodeGetContent(p_cell_spec_params->PLMNList[instance_id - OAM_ONE],"PLMNID");  
            oam_convert_plmnid(temp_plmnid,temp);
            /* SPR 23504/SES-341 Fix Start */
            oam_memset(&p_rrm_oam_plmn, OAM_ZERO , sizeof(rrm_oam_cell_plmn_info_t));
            oam_fill_mcc_mnc_from_plmnid(temp_plmnid , &p_rrm_oam_plmn); 
            if(OAM_SUCCESS == oam_validate_and_update_plmnid_in_rrm_oam_plmn_list(&p_rrm_oam_plmn, cell_index))
            {
                oam_memcpy(&(p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[plmn_idx].plmn_info), 
                        &p_rrm_oam_plmn, sizeof(rrm_oam_cell_plmn_info_t));
                /* SPR 23504/SES-341 Fix End */

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->PLMNList[instance_id - OAM_ONE],"CellReservedForOperatorUse"));
                /* coverity 35677 */
                p_rrm_cellconfig->epc_info.
                    epc_params.general_epc_params.plmn_list[plmn_idx].
                    reserve_operator_use=(rrm_oam_cell_reserved_for_operatoruse_et)lclTemp_value;	


                oam_memcpy(&(p_plmnlist_data->plmn_entries[instance_id - OAM_ONE].plmn_id),
                        &(p_rrm_cellconfig->epc_info.
                            epc_params.general_epc_params.plmn_list[plmn_idx].plmn_info),
                        sizeof(rrm_oam_cell_plmn_info_t));

                p_plmnlist_data->plmn_entries[instance_id - OAM_ONE].reserve_operator_use = 
                    p_rrm_cellconfig->epc_info.
                    epc_params.general_epc_params.plmn_list[plmn_idx].reserve_operator_use;

                plmn_idx++;
                /* SPR 23504/SES-341 Fix Start */
            }
            else
            {
                OAM_LOG(OAM, OAM_DETAILED,"Duplicate PLMN id [%d] present for Cell Config",oam_atoi(temp));
            }
            /* SPR 23504/SES-341 Fix End */

        }
        else
        {
            /* Fill OAM structure for PLMNList */
            temp = (char *)oam_xmlNodeGetContent(p_cell_spec_params->PLMNList[i],"PLMNID");  
            oam_convert_plmnid(temp_plmnid,temp);		

            /* SPR 23504/SES-341 Fix Start */
            oam_memset(&p_rrm_oam_plmn, OAM_ZERO , sizeof(rrm_oam_cell_plmn_info_t));

            oam_fill_mcc_mnc_from_plmnid(temp_plmnid , &p_rrm_oam_plmn); 

            if(OAM_SUCCESS == oam_validate_and_update_plmnid_in_rrm_oam_plmn_list(&p_rrm_oam_plmn, cell_index))
            {
                oam_memcpy(&p_plmnlist_data->plmn_entries[instance_id - OAM_ONE].plmn_id, 
                        &p_rrm_oam_plmn, sizeof(rrm_oam_cell_plmn_info_t));
                /* SPR 23504/SES-341 Fix End */

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->PLMNList[i],"CellReservedForOperatorUse"));

                p_plmnlist_data->plmn_entries[instance_id - OAM_ONE].reserve_operator_use = 
                    (rrm_oam_cell_reserved_for_operatoruse_et)lclTemp_value;	
                /* SPR 23504/SES-341 Fix Start */
            }
            else
            {
                OAM_LOG(OAM, OAM_DETAILED,"Duplicate PLMN id [%d] present for PLMN List Data",oam_atoi(temp));
            }
            /* SPR 23504/SES-341 Fix End */

        }
        /* SPR 19349 Fix Start */
        if(primary_idx > OAM_ZERO) {
            rrm_oam_plmn_access_info_t tmp_plmnlist;
            oam_memcpy(&tmp_plmnlist,
                    &p_rrm_cellconfig->epc_info.epc_params.
                    general_epc_params.plmn_list[0],
                    sizeof(rrm_oam_plmn_access_info_t));

            oam_memcpy(&p_rrm_cellconfig->epc_info.epc_params.
                    general_epc_params.plmn_list[0].plmn_info,
                    &p_plmn_entries[primary_idx].plmn_id,
                    sizeof(rrm_oam_cell_plmn_info_t));

            p_rrm_cellconfig->epc_info.epc_params.general_epc_params.
                plmn_list[0].reserve_operator_use =
                p_plmn_entries[primary_idx].reserve_operator_use;


            oam_memcpy(&p_rrm_cellconfig->epc_info.epc_params.
                    general_epc_params.plmn_list[primary_idx],
                    &tmp_plmnlist,
                    sizeof(rrm_oam_plmn_access_info_t));
        }

        /* SPR 19349 Fix End */
        p_rrm_cellconfig->epc_info.epc_params.general_epc_params.
            num_valid_plmn = plmn_idx;
        /* SPR 15917 END */

    }/* End of for loop to support multi-instance objects */
    /*SPR 21096 Start*/
    /* SPR21978 Start */
    tagvalue = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->ca_params,
            "isCAEligible");
    /* SPR21978 End */
    if(oam_strcmp(tagvalue, OAM_INVALID_STR)){
        lclTemp_value = oam_atoi(tagvalue);
        if(lclTemp_value == OAM_ONE)
        {
            p_rrm_cellconfig->operator_info.ca_config.is_ca_eligible = lclTemp_value;
            p_rrm_cellconfig->operator_info.ca_config.
                bitmask |= RRM_OAM_IS_CA_ELIGIBLE_INFO_PRESENT;
            p_rrm_cellconfig->operator_info.
                bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
            /* SPR 21958 PUSCH RAT1 Support Start */
            /* SPR 22549 Fix Start */
            ca_eligible_flag[cell_index] = OAM_ONE;
            /* SPR 22549 Fix End */
            /* SPR 21958 PUSCH RAT1 Support End */
            oam_populate_ca_params(p_rrm_cellconfig, p_cell_spec_params);
        }
    }
    /*SPR 21096 End*/

    if(
            (oam_strcmp
             ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->EPC,"TAC"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {      
        p_rrm_cellconfig->epc_info.epc_params.bitmask |= RRM_OAM_GENERAL_EPC_PARAMS_PRESENT;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EPC,"TAC"));
    oam_conversion_bitstring_short_to_byte_string(
            p_rrm_cellconfig->
            epc_info.epc_params.general_epc_params.tac, lclTemp_value);

    if(
            (oam_strcmp
             ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->EPC,"EAID"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {	
        p_rrm_cellconfig->epc_info.epc_params.general_epc_params.bitmask |= RRM_OAM_EMERGENCY_AREA_ID_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->EPC,"EAID"));
        oam_convert_3byte_int_to_byte_string(p_rrm_cellconfig->epc_info.epc_params.general_epc_params.eaid,lclTemp_value);
    }

    /*SPR 15527 START*/
    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EPC,"MaxQoSEntries"));
    p_qos_data->max_qos_entries = lclTemp_value;
    /*SPR 15527 END*/

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EPC,"QoSNumberOfEntries"));

    /*SPR 15527 START*/
    if(lclTemp_value > p_qos_data->max_qos_entries)
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Population Failure as QoSNumberOfEntries > MaxQoSEntries");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    p_qos_data->num_qos_entries = lclTemp_value;
    p_qos_data->last_added_qos_instance_id = p_qos_data->num_qos_entries;
    count = OAM_ZERO;
    /*SPR 15527 END*/

    p_rrm_cellconfig->epc_info.epc_params.num_valid_qos_profiles=lclTemp_value;     

    /* SPR_9464_FIX Start */
    /* SPR 15527 START */
    for(count_qci = (MIN_RRM_CELL_QCI-1),drx_count = (MIN_NUM_VALID_DRX_PROFILES -1);
            (count_qci < p_qos_data->num_qos_entries) && (drx_count < p_qos_data->num_qos_entries); count_qci++)
        /* SPR 15527 END */
        /* SPR_9464_FIX End */
    {
        xmlNode * QoS_node;
        /* SPR 15527 START */
        QoS_node = p_cell_spec_params->QoS[count_qci];
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_INSTANCE_ID"));
        if((lclTemp_value < OAM_ONE) || (lclTemp_value >OAM_NINE))
        {
            OAM_LOG(OAM,OAM_WARNING,
                    "QoS Instance Id should lie in between 1 to 9");
            return OAM_FAILURE;
        }

        UInt8 qos_inst_idx = lclTemp_value - OAM_ONE;

        qos_enable = (oam_bool_et)oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"Enable"));
        if(qos_enable)
        {
            /* SPR 15527 END */ 

            U8 qci_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"QCI"));
            if (qci_value >= MIN_RRM_CELL_QCI && qci_value <= MAX_RRM_CELL_QCI)
            {   
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].qci=qci_value;
                /* SPR 15527 START */
                /*SPR 21096 Start*/
                oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_mac_req.mac_init_req.qosQciInfo[count].QCI=lclTemp_value;
                oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_rlc_req.rlc_init_req.rlcQosQciInfo[count].qci=lclTemp_value;
                /*SPR 21096 Start*/
                /* SPR 15527 END */
                oam_prov_req.oam_rrm_req.oam_ecn_req.ecn_cells[OAM_ZERO].bitrate.bitrate_for_qci[count].qci = qci_value;
            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from %d to %d", "QCI", lclTemp_value, MIN_RRM_CELL_QCI,MAX_RRM_CELL_QCI);
                return OAM_FAILURE;
            }   

            lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(QoS_node,"Type"),QoS_LogicalChannelType,QOS_LOGICALCHANNELTYPE_COUNT);
            if (lclTemp_value >= MIN_RRM_CELL_TYPE && lclTemp_value <= MAX_RRM_CELL_TYPE)
            {   
                /* coverity 35670*/
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].type=(rrm_oam_qos_type_et)lclTemp_value; 
                /* coverity 35668*/
                /* SPR 15527 START */
                /*SPR 21096 Start*/
                oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_mac_req.mac_init_req.qosQciInfo[count].eResType=(LogicalChannelType)lclTemp_value;
                oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_rlc_req.rlc_init_req.rlcQosQciInfo[count].eResType=(rlcLogicalChannelType)lclTemp_value;
                /*SPR 21096 End*/
                /* SPR 15527 END */
            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from %d to %d", "Type", lclTemp_value, MIN_RRM_CELL_TYPE, MAX_RRM_CELL_TYPE);
                return OAM_FAILURE;
            }   

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent( QoS_node,"Priority"));
            if (    lclTemp_value >= MIN_RRM_CELL_PRIORITY  &&  lclTemp_value <= MAX_RRM_CELL_PRIORITY  )
            {       
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].priority=lclTemp_value;  
                /* SPR 15527 START */
                /*SPR 21096 Start*/
                oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_mac_req.mac_init_req.qosQciInfo[count].priority=lclTemp_value;
                oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_rlc_req.rlc_init_req.rlcQosQciInfo[count].priority=lclTemp_value;
                /*SPR 21096 End*/
                /* SPR 15527 END */
            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from %d to %d", "Priority", lclTemp_value,MIN_RRM_CELL_PRIORITY,MAX_RRM_CELL_PRIORITY);
                return OAM_FAILURE;
            }   

            lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                        QoS_node,"PacketDelayBudget"),EPC_QoS_PacketDelayBudget[OAM_ZERO],EPC_QOS_PACKETDELAYBUDGET_COUNT);
            if (lclTemp_value >= MIN_RRM_CELL_PACKETDELAYBUDGET && lclTemp_value <= MAX_RRM_CELL_PACKETDELAYBUDGET)
            {       
                /* coverity 35669*/
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].packet_delay_budget=(rrm_oam_packet_delay_budget_et)lclTemp_value;   
                /* SPR 15527 START */
                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(    QoS_node,"PacketDelayBudget"));
                /*SPR 21096 Start*/
                oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_mac_req.mac_init_req.qosQciInfo[count].pktDlyBdgt=lclTemp_value;
                oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_rlc_req.rlc_init_req.rlcQosQciInfo[count].pktDlyBdgt=lclTemp_value;
                /*SPR 21096 End*/
                /* SPR 15527 END */
            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from %d to %d", "PacketDelayBudget", lclTemp_value,MIN_RRM_CELL_PACKETDELAYBUDGET, MAX_RRM_CELL_PACKETDELAYBUDGET);
                return OAM_FAILURE;
            }    


            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_TTI_BUNDLING"), OAM_INVALID_STR) != OAM_ZERO)    
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_TTI_BUNDLING"));
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].tti_bundling=lclTemp_value;
                /* SPR 21958 PUSCH RAT1 Support Start */
                if(p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].tti_bundling == OAM_ONE)
                {
                    /* SPR 22549 Fix Start */
                    tti_bundling_flag[cell_index] = OAM_ONE;
                    /* SPR 22549 Fix Start */
                }		
                /* SPR 21958 PUSCH RAT1 Support End */
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_TTI_BUNDLING_PRESENT;
                OAM_LOG(OAM, OAM_INFO,"Value of X_VENDOR_TTI_BUNDLING[%d] is %d",count,lclTemp_value);
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_LOGICAL_CHANNEL_GROUP"), OAM_INVALID_STR) != OAM_ZERO)    
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_LOGICAL_CHANNEL_GROUP"));
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].logical_channel_group=lclTemp_value;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_LOGICAL_CHANNEL_GROUP_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_RLC_AM_STATUS_REPORT_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)    
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_RLC_AM_STATUS_REPORT_REQUIRED"));
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].rlc_am_status_report_required = (rrm_bool_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_RLC_AM_STATUS_REPORT_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_RLC_AM_ENB_STATUS_REPORT_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)    
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_RLC_AM_ENB_STATUS_REPORT_REQUIRED"));
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].rlc_am_enb_status_report_required = (rrm_bool_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_RLC_AM_ENB_STATUS_REPORT_PRESENT;
            }
#ifdef ENDC_ENABLED

            /* ENDC changes start */
        tagvalue=(Char8*)oam_xmlNodeGetContent(
                              xml_struct_g.EN_DC_Params,"ENDCEnabled");
        if(oam_strcmp(tagvalue, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi(tagvalue);
            if(lclTemp_value)
            {
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SGNB_BEARER_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)    
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SGNB_BEARER_REQUIRED"));
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].sgnb_bearer_required = (rrm_bool_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_SGNB_BEARER_REQUIRED;
            }
                /* ENDC_MEAS_CHANGES_START */
                if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SGNB_BEARER_TYPE"), OAM_INVALID_STR) != OAM_ZERO)    
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SGNB_BEARER_TYPE"));
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].sgnb_bearer_type= (rrm_bool_et)lclTemp_value;
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_SGNB_BEARER_TYPE;
                }
            }
        }
/* ENDC_MEAS_CHANGES_END */
            /* ENDC changes end */
#endif


            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_PACKETERRORLOSSRATE"), OAM_INVALID_STR) != OAM_ZERO)    
            {     
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_PACKETERRORLOSSRATE"));
                if(lclTemp_value >= MIN_PACKET_ERROR_LOSS_RATE && lclTemp_value <= MAX_PACKET_ERROR_LOSS_RATE)
                {
                    /* cverity 35666 */
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].packet_error_loss_rate=(rrm_oam_packet_error_loss_rate_et)lclTemp_value;
                    /* SPR 15527 START */ 
                    /*SPR 21096 Start*/
                    oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_mac_req.mac_init_req.qosQciInfo[count].pktErrLossRate=lclTemp_value;
                    oam_prov_req.l2_setup_info.instance_info[l2_instance].oam_l2_req.oam_rlc_req.rlc_init_req.rlcQosQciInfo[count].pktErrLossRate=lclTemp_value;
                    /*SPR 21096 End*/
                    /* SPR 15527 END */
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT;                
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING, "Value of %s is %d and range is from %d to %d", "X_VENDOR_PACKETERRORLOSSRATE", lclTemp_value,MIN_PACKET_ERROR_LOSS_RATE, MAX_PACKET_ERROR_LOSS_RATE);
                    return OAM_FAILURE;
                }
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DSCP"), OAM_INVALID_STR) != OAM_ZERO)    
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DSCP"));
                if(lclTemp_value >= MIN_DSCP && lclTemp_value <= MAX_DSCP)
                {
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].dscp=lclTemp_value;
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_DSCP_PRESENT;
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from %d to %d", "X_VENDOR_DSCP", lclTemp_value,MIN_DSCP,MAX_DSCP);
                    return OAM_FAILURE;
                }
            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SPS_CONFIG_ENABLED"), OAM_INVALID_STR) != OAM_ZERO)    
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SPS_CONFIG_ENABLED"));

                /* coverity 35724 */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_config_enabled=(rrm_bool_et)lclTemp_value;
                /*SPR 9256 Start*/

                /* SPR 21958 PUSCH RAT1 Support Start */
                if(p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].sps_config_enabled == OAM_ONE)
                {
                    /* SPR 22549 Fix Start */
                    sps_flag[cell_index] = OAM_ONE;	
                    /* SPR 22549 Fix End */
                }
                /* SPR 21958 PUSCH RAT1 Support End */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_SPS_CONFIG_ENABLED_PRESENT;
            }

            SInt8 x_vendor_semi_persist_sched_interval_dl = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_DL"), OAM_INVALID_STR);
            SInt8 x_vendor_number_of_conf_sps_processes = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_NUMBER_OF_CONF_SPS_PROCESSES"), OAM_INVALID_STR);
            SInt8 x_vendor_max_sps_harq_retx = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_MAX_SPS_HARQ_RETX"), OAM_INVALID_STR);
            SInt8 x_vendor_explicit_release_after = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_EXPLICIT_RELEASE_AFTER"), OAM_INVALID_STR);
            if(x_vendor_number_of_conf_sps_processes &&
                    x_vendor_max_sps_harq_retx &&
                    x_vendor_explicit_release_after &&
                    x_vendor_semi_persist_sched_interval_dl) 
            {

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_SPS_CONFIG_DATA_PRESENT;

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_data.bitmask |= RRM_OAM_SPS_CONFIG_DL_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_DL"));

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_data.sps_config_dl.semi_persist_sched_interval_dl=lclTemp_value;


                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_NUMBER_OF_CONF_SPS_PROCESSES"));

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_data.sps_config_dl.number_of_conf_sps_processes=lclTemp_value;                        

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_MAX_SPS_HARQ_RETX"));

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_data.sps_config_dl.max_sps_harq_retx=lclTemp_value;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_EXPLICIT_RELEASE_AFTER"));

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_data.sps_config_dl.explicit_release_after=lclTemp_value;

            }
            SInt8 X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL = OAM_ZERO,
                  X_VENDOR_IMPLICIT_RELEASE_AFTER = OAM_ZERO;

            X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL"), OAM_INVALID_STR);
            X_VENDOR_IMPLICIT_RELEASE_AFTER = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_IMPLICIT_RELEASE_AFTER"), OAM_INVALID_STR);

            if((X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL != OAM_ZERO) &&
                    (X_VENDOR_IMPLICIT_RELEASE_AFTER != OAM_ZERO))    
            {

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_SPS_CONFIG_DATA_PRESENT;

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_data.bitmask |= RRM_OAM_SPS_CONFIG_UL_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL"));

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_data.sps_config_ul.semi_persist_sched_interval_ul=lclTemp_value;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_IMPLICIT_RELEASE_AFTER"));

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sps_data.sps_config_ul.implicit_release_after=lclTemp_value;

                if((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_P_ZERO_NOMINAL_PUSCH_PERSISTENT"), OAM_INVALID_STR) != OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                QoS_node,"X_VENDOR_P_ZERO_NOMINAL_PUSCH_PERSISTENT"));

                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].sps_data.sps_config_ul.bitmask |= RRM_OAM_P_ZERO_NOMINAL_PUSCH_PERSISTENT_PRESENT;

                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].sps_data.sps_config_ul.p_zero_nominal_pusch_persistent=lclTemp_value;
                }
            }
            /* + SPS_TDD_Changes */
            if(OAM_ZERO == strncmp((const char *)oam_xmlNodeGetContent(
                            /* spr_21013_fix_start */
                            xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"TDDMode",strlen("TDDMode")+1))
                /* spr_21013_fix_end */
            {
                if(oam_strcmp((const char *)oam_xmlNodeGetContent
                            (QoS_node, "X_VENDOR_TWO_INTERVAL_CONFIG"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                QoS_node,"X_VENDOR_TWO_INTERVAL_CONFIG"));	
                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].sps_data.sps_config_ul.bitmask |= RRM_OAM_SPS_TWO_INTERVAL_CONFIG_SUPPORTED;

                    /* + Coverity 88599 */
                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].sps_data.sps_config_ul.two_interval_supported = (rrm_oam_two_interval_config_et)lclTemp_value;
                    /* - Coverity 88599 */
                }
            }
            /* - SPS_TDD_Changes */
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_LOSSLESS_HO_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)    
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_LOSSLESS_HO_REQUIRED"));	
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].lossless_ho_required=lclTemp_value;		 
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_LOSSLESS_HO_REQ_PRESENT;
            }

            /*BUG_11564_CHANGES_START*/
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DL_FORWARDING_APPLICABILTIY"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DL_FORWARDING_APPLICABILTIY"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].dl_forwarding_applicability=(rrm_bool_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_DL_FWDING_APPLICABLE;
            }
            /*BUG_11564_CHANGES_END*/


            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_UE_INACTIVITY_TIMER_CONFIG"), OAM_INVALID_STR) != OAM_ZERO)   
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node, "X_VENDOR_UE_INACTIVITY_TIMER_CONFIG"));	
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].ue_inactivity_timer_config=lclTemp_value;		 
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_UE_INACTIVE_TIMER_PRESENT;
            }

            /* SPR 12185 FIX START */
            /* SPR 12987 FIX START */
            /* SPR 12987 REVIEW COMMENTS FIX START */
            tag_value = oam_get_xml_text_node_content(QoS_node,
                    "X_VENDOR_SUPPORTED_RAT", buf,
                    OAM_TAG_VALUE_STR_MAX_LEN);
            if(tag_value) {
                OAM_LOG(OAM, OAM_INFO,
                        "Value of X_VENDOR_SUPPORTED_RAT is %s", buf);

                temp = oam_strtok(buf, ",");

                while(temp) {
                    lclTemp_value = oam_xml_search_string_to_integer(temp,
                            SupportedRat_MAP,
                            MAX_SUPPORTED_RAT);

                    if(OAM_INVALID_RETURN == lclTemp_value) {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Skipping Unsupported RAT Type: %s",temp);
                        temp = strtok(OAM_NULL , ",");
                        continue;
                    }

                    if(OAM_ZERO != lclTemp_value) {
                        bit_set |= OAM_ONE << ((UInt8)lclTemp_value - OAM_ONE);
                    }

                    temp = strtok(OAM_NULL, ",");
                }

                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].
                    bitmask |= RRM_OAM_SUPPORTED_RAT_PRESENT;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].
                    supported_rat = bit_set;
            }
            /* SPR 12987 REVIEW COMMENTS FIX END */
            /* SPR 12987 FIX END */
            /* SPR 12185 FIX END */

            /* 
               Currently, there is support of only one cell in OAM, the following code will be updated for Multiple cells
               in future release.
               */
            oam_prov_req.oam_rrm_req.oam_ecn_req.ecn_cells[OAM_ZERO].bitrate.
                bitrate_for_qci[count].bitmask  = OAM_ZERO;

            xmlNode* QoS_node_child = oam_xml_find_tag(QoS_node->children,(xmlChar *)"X_VENDOR_BITRATE");

            /* CSR 00070293 FIX START */
            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node_child, "MIN_UL_BITRATE"), OAM_INVALID_STR) != OAM_ZERO)) 
            {

                /*SPR 15335 Fix Start*/
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_NGBR_UL_MIN_BITRATE_PRESENT;
                /*SPR 15335 Fix End*/    
                p_rrm_cellconfig->epc_info.epc_params.
                    qos_config_params[count].ul_min_bitrate =
                    oam_atoi((const char *)oam_xmlNodeGetContent(
                                QoS_node_child,
                                "MIN_UL_BITRATE"));

            }
            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node_child, "MIN_DL_BITRATE"), OAM_INVALID_STR) != OAM_ZERO)) 
            {

                /*SPR 15335 Fix Start*/
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |=  RRM_OAM_NGBR_DL_MIN_BITRATE_PRESENT;
                /*SPR 15335 Fix End*/

                p_rrm_cellconfig->epc_info.epc_params.
                    qos_config_params[count].dl_min_bitrate =
                    oam_atoi((const char *)oam_xmlNodeGetContent(
                                QoS_node_child,
                                "MIN_DL_BITRATE"));
            }
            /* CSR 00070293 FIX END */

            /*Bug fix */
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_RLC_MODE"), OAM_INVALID_STR) != OAM_ZERO)    
            { 
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_RLC_MODE"));
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].rlc_mode=lclTemp_value;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_RLC_MODE_PRESENT;
            }
            p_rrm_cellconfig->epc_info.
                epc_params.qos_config_params[count].bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;

            p_rrm_cellconfig->epc_info.
                epc_params.qos_config_params[count].sn_field_len.bitmask |= RRM_OAM_SN_FIELD_LEN_DL_RLC_PRESENT | RRM_OAM_SN_FIELD_LEN_UL_RLC_PRESENT | RRM_OAM_RLC_UM_PDCP_SN_SIZE_PRESENT;


            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SN_LEN_UL_RLC"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SN_LEN_UL_RLC"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sn_field_len.ul_rlc =lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sn_field_len.bitmask |= RRM_OAM_SN_FIELD_LEN_UL_RLC_PRESENT;


            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SN_LEN_DL_RLC"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SN_LEN_DL_RLC"));

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sn_field_len.dl_rlc =lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sn_field_len.bitmask |= RRM_OAM_SN_FIELD_LEN_DL_RLC_PRESENT;

            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_RLC_UM_PDCP_SN_SIZE"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_RLC_UM_PDCP_SN_SIZE"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sn_field_len.rlc_um_pdcp_sn_size = lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sn_field_len.bitmask |= RRM_OAM_RLC_UM_PDCP_SN_SIZE_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DISCARD_TIMER"), OAM_INVALID_STR) != OAM_ZERO)
            {
                /* SPR 12920 Fix Start */
                lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DISCARD_TIMER"),qosDiscardTimer,RRM_OAM_PDCP_DISCARD_TIMER_COUNT);
                /* SPR 12920 Fix End */
                /* coverity 56672 */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].pdcp_discard_timer =(rrm_oam_pdcp_discard_timer_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_PDCP_DISCARD_TIMER_PRESENT;

            }


            xmlNode* rohc_parameter = oam_xml_find_tag(QoS_node->children,(xmlChar *)"X_VENDOR_ROHC_PARAMS");
            if (OAM_NULL != rohc_parameter )
            {


                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].rohc_params.bitmask |=RRM_OAM_ROHC_ENABLE_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_parameter,"ENABLE_ROHC"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].rohc_params.enable_rohc=lclTemp_value;

                xmlNode* rohc_profile = oam_xml_find_tag(rohc_parameter->children,(xmlChar *)"MAX_CID");
                if (OAM_NULL != rohc_profile) 
                {
                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].rohc_params.bitmask |=RRM_OAM_ROHC_MAX_CID_PRESENT;

                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_parameter,"MAX_CID"));
                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].rohc_params.max_cid=lclTemp_value;
                }


                rohc_profile = oam_xml_find_tag(rohc_parameter->children,(xmlChar *)"ROHC_PROFILES");
                if (OAM_NULL != rohc_profile)
                {
                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].rohc_params.bitmask |=RRM_OAM_ROHC_PROFILE_PRESENT;

                    xmlNode* rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0001");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_1_PRESENT;

                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0001"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0001", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0001=(U8)lclTemp_value_1;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0002");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |= RRM_OAM_ROHC_PROFILE_2_PRESENT;
                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0002"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0002", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0002=(U8)lclTemp_value_1;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0003");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_3_PRESENT;
                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0003"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0003", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0003=(U8)lclTemp_value_1;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0004");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_4_PRESENT;
                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0004"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0004", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0004=(U8)lclTemp_value_1;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0006");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_6_PRESENT;
                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0006"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0006", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0006=(U8)lclTemp_value_1;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0101");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_101_PRESENT;
                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0101"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0101", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0101=(U8)lclTemp_value_1;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0102");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_102_PRESENT;
                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0102"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0102", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0102=(U8)lclTemp_value_1;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0103");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_103_PRESENT;
                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0103"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0103", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0103=(U8)lclTemp_value_1;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0104");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_104_PRESENT;
                        lclTemp_value_1=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0104"));
                        if (!((lclTemp_value_1 == 0) || (lclTemp_value_1 == 1)))
                        {
                            OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0104", lclTemp_value_1);
                            return OAM_FAILURE;
                        }
                        p_rrm_cellconfig->epc_info.
                            epc_params.qos_config_params[count].rohc_params.rohc_profiles.rohc_profile0x0104=(U8)lclTemp_value_1;
                    }
                }
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_HARQ_TX"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_HARQ_TX"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].max_harq_tx = lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_MAX_HARQ_TX_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_HARQ_RETRANS"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_HARQ_RETRANS"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].max_harq_retrans = lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ARQ_TX_RETRANS_PRESENT;
            }
            /* SPR 12487 FIX START */
            /* Population of redundant param LOGICAL_CHANNEL_GROUPING_ON_OFF removed */
            /* SPR 12487 FIX END */

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_RLC_TRANSMISSIONS"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_RLC_TRANSMISSIONS"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].max_rlc_transmissions = lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_MAX_RLC_TRANS_PRESENT;
            }
            /* SPR 20653 Fix Start */
            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SR_MASK_FLAG"), OAM_INVALID_STR) != OAM_ZERO) &&
                    (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SR_PROHIBIT_TIMER_R9"), OAM_INVALID_STR) != OAM_ZERO) &&
                    (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DSR_MAX_TRANSMISSIONS"), OAM_INVALID_STR) != OAM_ZERO))

            {
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_SR_CONFIGURATION_PRESENT;
                /* SPR 20653 Fix End */

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SR_MASK_FLAG"));
                /* coverity 57699 */  
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sr_configuration.sr_mask_flag = (rrm_bool_et) lclTemp_value;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SR_PROHIBIT_TIMER_R9"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sr_configuration.sr_prohibit_timer_r9 = lclTemp_value;

                /* SPR 12920 Fix Start */
                lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DSR_MAX_TRANSMISSIONS"),qosSrMaxTransmission,RRM_OAM_SR_MAX_TRANSMISSION_COUNT);
                /* SPR 12920 Fix End */
                /* coverity 57698 */  
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].sr_configuration.dsr_trans_max = (rrm_oam_sr_max_transmission_et)lclTemp_value;
            }
            /* coverity 56673 */ 

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DDL_PARAM_T_STATUES_PROHIBIT"), OAM_INVALID_STR) != OAM_ZERO)
            {
                /* SPR 12920 Fix Start */
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DDL_PARAM_T_STATUES_PROHIBIT"),RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO],TSTATUSPROHIBIT_COUNT);
                /* SPR 12920 Fix End */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.t_status_prohibit = (rrm_oam_t_status_prohibit_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.bitmask |=RRM_OAM_TMR_STATUS_PROHIBIT_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
            }       
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DDL_PARAM_T_POLL_PDU"), OAM_INVALID_STR) != OAM_ZERO)
            {
                /* SPR 12920 Fix Start */
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DDL_PARAM_T_POLL_PDU"),RAN_RLC_SRB1_pollPDU[OAM_ZERO],POLLPDU_COUNT);
                /* SPR 12920 Fix End */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.t_poll_pdu = (rrm_oam_poll_pdu_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.bitmask |=RRM_OAM_TMR_POLL_PDU_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
            }



            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DDL_PARAM_T_POLL_RETRANSMIT"), OAM_INVALID_STR) != OAM_ZERO)
            {
                /* SPR 12920 Fix Start */
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DDL_PARAM_T_POLL_RETRANSMIT"),RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO],TPOLLRETRANSMIT_COUNT);
                /* SPR 12920 Fix End */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.t_poll_retransmit = (rrm_oam_t_poll_retransmit_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.bitmask |=RRM_OAM_TMR_RETRSMIT_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
            }         

            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_DL_PARAM_T_REORDERING_AM"), OAM_INVALID_STR) != OAM_ZERO)
            {
                /* SPR 12920 Fix Start */
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DL_PARAM_T_REORDERING_AM"),RAN_RLC_SRB1_TReordering[OAM_ZERO],TREORDERING_COUNT);
                /* SPR 12920 Fix End */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.t_reordering_am = (rrm_oam_t_reordering_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.bitmask |= RRM_OAM_TMR_REORDER_FOR_AM_MODE_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;

            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_DL_PARAM_T_REORDERING_UM"), OAM_INVALID_STR) != OAM_ZERO)
            {
                /* SPR 12920 Fix Start */
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DL_PARAM_T_REORDERING_UM"),RAN_RLC_SRB1_TReordering[OAM_ZERO],TREORDERING_COUNT);
                /* SPR 12920 Fix End */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.t_reordering_um = (rrm_oam_t_reordering_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.bitmask |= RRM_OAM_TMR_REORDER_FOR_UM_MODE_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;

            }




            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_UL_AM_POLL_BYTE"), OAM_INVALID_STR) != OAM_ZERO)
            {
                /* SPR 12920 Fix Start */
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_UL_AM_POLL_BYTE"),RAN_RLC_SRB1_pollByte[OAM_ZERO],POLLBYTE_COUNT);
                /* SPR 12920 Fix End */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.ul_am_poll_byte = (rrm_oam_poll_byte_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.bitmask |= RRM_OAM_UL_AM_POLL_BYTE_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;

            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_MAX_RETX_THRESHOLD"), OAM_INVALID_STR) != OAM_ZERO)
            {
                /*-- CSR 58268 FIX START */ 
                lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_MAX_RETX_THRESHOLD"),EPC_MAX_RETX_THRESHOLD[OAM_ZERO],OAM_EIGHT);

                /*-- CSR 58268 FIX END */

                /* coverity 34790 */
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.ul_am_rrc_max_retx_threshold = (rrm_oam_max_retx_threshold_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_rlc_param.bitmask |= RRM_OAM_MAX_RTX_THRESHOLD_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;

            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_SRVCC_OP_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SRVCC_OP_REQUIRED"));
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].srvcc_op_required = (rrm_bool_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_SRVCC_OP_REQUIRED_PRESENT;

            }
            /*spr_22058_changes_start*/
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_PERIODIC_PHR_TIMER"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_PERIODIC_PHR_TIMER"),QoS_MAC_PERIODIC_PHR[OAM_ZERO], PERIODIC_PHR_COUNT);

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.phr_config.t_periodic_phr = (rrm_oam_periodic_phr_tmr_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_MAC_PARAM_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.bitmask |= RRM_OAM_PHR_CONFIG_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.phr_config.bitmask |= RRM_OAM_PERIODIC_PHR_TMR_PRESENT;
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,"Mandatory parameter X_VENDOR_PERIODIC_PHR_TIMER not found in configuration file");
                return OAM_FAILURE;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_PROHIBIT_PHR_TIMER"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_PROHIBIT_PHR_TIMER"),QoS_MAC_PROHIBIT_PHR[OAM_ZERO], PROHIBIT_PHR_COUNT);

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.phr_config.t_prohibit_phr = (rrm_oam_prohibit_phr_tmr_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_MAC_PARAM_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.bitmask |= RRM_OAM_PHR_CONFIG_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.phr_config.bitmask |= RRM_OAM_PROHIBIT_PHR_TMR_PRESENT;
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,"Mandatory parameter X_VENDOR_PROHIBIT_PHR_TIMER not found in configuration file");
                return OAM_FAILURE;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DL_PATHLOSS_TIMER"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DL_PATHLOSS_TIMER"),QoS_MAC_DL_PATHLOSS[OAM_ZERO], DL_PATHLOSS_COUNT);

                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.phr_config.t_pathloss_chng = (rrm_oam_dl_pathloss_tmr_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_MAC_PARAM_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.bitmask |= RRM_OAM_PHR_CONFIG_PRESENT;
                p_rrm_cellconfig->epc_info.
                    epc_params.qos_config_params[count].addl_mac_param.phr_config.bitmask |= RRM_OAM_DL_PATHLOSS_TMR_PRESENT;
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,"Mandatory parameter X_VENDOR_DL_PATHLOSS_TIMER not found in configuration file");
                return OAM_FAILURE;
            }
            /*spr_22058_changes_end*/

            /* SPR_9464_FIX Start */
            /* SPR 16195 START */
            /* spr_21013_fix_start */
            /*SPR 21295 FIXED START*/
            lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"DRXEnabled"));
            /*SPR 21295 FIXED END*/
            /* spr_21013_fix_end */
            if (lclTemp_value != OAM_ZERO)
            {
                if((oam_strcmp(((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_ENABLED")), OAM_INVALID_STR) != OAM_ZERO))
                {
                    /* SPR 16195 END */
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DRX_ENABLED"));
                    if(OAM_ZERO != lclTemp_value )
                    {
                        if((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_ON_DURATION_TIMER"), OAM_INVALID_STR) != OAM_ZERO) &&
                                (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_INACTIVITY_TIMER"), OAM_INVALID_STR) != OAM_ZERO) &&
                                (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_RETRANSMISSION_TIMER"), OAM_INVALID_STR) != OAM_ZERO) &&
                                (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_LONG_DRX_CYCLE"), OAM_INVALID_STR) != OAM_ZERO) &&
#ifdef ENDC_ENABLED
                                (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_LONG_DRX_CYCLE_R15"), OAM_INVALID_STR) != OAM_ZERO) &&
#endif
                                (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_START_OFFSET"), OAM_INVALID_STR) != OAM_ZERO))
                        {
                            lclTemp_value= oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        QoS_node,"X_VENDOR_DRX_ON_DURATION_TIMER"),RAN_MAC_DRX_OnDurationTimer[OAM_ZERO],ONDURATIONTIMER_COUNT);
                            if(lclTemp_value >= MIN_ON_DURATION_TIMER &&
                                    lclTemp_value <= MAX_ON_DURATION_TIMER)
                            {
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    on_duration_timer=(rrm_oam_on_duration_timer_et)lclTemp_value;
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of OnDurationTimer is %d and range is from %d to %d",
                                        lclTemp_value,MIN_ON_DURATION_TIMER,MAX_ON_DURATION_TIMER);

                                return OAM_FAILURE;
                            }
                            lclTemp_value=  oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        QoS_node,"X_VENDOR_DRX_INACTIVITY_TIMER"),RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO],DRXINACTIVITYTIMER_COUNT);
                            if(lclTemp_value >= MIN_DRX_INACTIVITY_TIMER &&
                                    lclTemp_value <= MAX_DRX_INACTIVITY_TIMER)
                            {
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    drx_inactivity_timer=(rrm_oam_drx_inactivity_timer_et)lclTemp_value; /* coverity fix 66639 */
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of DRXInactivityTimer is %d and range is from %d to %d",
                                        lclTemp_value,MIN_DRX_INACTIVITY_TIMER,MAX_DRX_INACTIVITY_TIMER);

                                return OAM_FAILURE;
                            }
                            lclTemp_value= oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        QoS_node,"X_VENDOR_DRX_RETRANSMISSION_TIMER"),RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO],DRXRETRANSMISSIONTIMER_COUNT);
                            if(lclTemp_value >= MIN_DRX_RETRANSMISSION_TIMER &&
                                    lclTemp_value <= MAX_DRX_RETRANSMISSION_TIMER)
                            {
                                /*CID:34790 start*/
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    drx_retransmission_timer=(rrm_oam_drx_retransmission_timer_et)lclTemp_value;
                                /*CID:34790 end*/
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of DRXRetransmissionTimer is %d and range is from %d to %d",
                                        lclTemp_value,MIN_DRX_RETRANSMISSION_TIMER,MAX_DRX_RETRANSMISSION_TIMER);

                                return OAM_FAILURE;
                            }
                            lclTemp_value= oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        QoS_node,"X_VENDOR_LONG_DRX_CYCLE"),RAN_MAC_DRX_longDRXCycle[OAM_ZERO],LONGDRXCYCLE_COUNT);
                            if(lclTemp_value >= MIN_LONG_DRX_CYCLE &&
                                    lclTemp_value <= MAX_LONG_DRX_CYCLE)
                            {
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    long_drx_cycle=(rrm_oam_long_drx_cycle_start_offset_et)lclTemp_value;   /* Coverity 66641 Fix */
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of LongDRXCycle is %d and range is from %d to %d",
                                        lclTemp_value,MIN_LONG_DRX_CYCLE,MAX_LONG_DRX_CYCLE);

                                return OAM_FAILURE;
                            }
                            #ifdef ENDC_ENABLED
                            lclTemp_value= oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        QoS_node,"X_VENDOR_LONG_DRX_CYCLE_R15"),RAN_MAC_DRX_longDRXCycleR15[OAM_ZERO],LONGDRXCYCLE_COUNT_R15);
                            if(lclTemp_value >= MIN_LONG_DRX_CYCLE_R15 &&
                                    lclTemp_value <= MAX_LONG_DRX_CYCLE_R15)
                            {
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    long_drx_cycle_r15 =(rrm_oam_long_drx_cycle_start_offset_r15_et)lclTemp_value;
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    bitmask |= RRM_OAM_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT;
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of LongDRXCycleR15 is %d and range is from %d to %d",
                                        lclTemp_value,MIN_LONG_DRX_CYCLE_R15,MAX_LONG_DRX_CYCLE_R15);

                                return OAM_FAILURE;
                            }
                            #endif
                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        QoS_node,"X_VENDOR_DRX_START_OFFSET"));
                            if(lclTemp_value >= MIN_DRX_START_OFFSETT &&
                                    lclTemp_value <= MAX_DRX_START_OFFSETT)
                            {
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    drx_start_offset=lclTemp_value;
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of DRXStartOffset is %d and range is from %d to %d",
                                        lclTemp_value,MIN_DRX_START_OFFSETT,MAX_DRX_START_OFFSETT);

                                return OAM_FAILURE;
                            }

                            if((oam_strcmp(((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SHORT_DRX_CYCLE")),OAM_INVALID_STR)!= OAM_ZERO) &&
                                    (oam_strcmp(((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DRX_SHORT_CYCLE_TIMER")),OAM_INVALID_STR)!= OAM_ZERO))
                            {
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].bitmask |=RRM_OAM_SHORT_DRX_CYCLE_PRESENT;
                                lclTemp_value= oam_xml_search_integer_to_integer ((char *)oam_xmlNodeGetContent(
                                            QoS_node,"X_VENDOR_SHORT_DRX_CYCLE"), RAN_MAC_DRX_shortDRXCycle[OAM_ZERO], DRXSHORTCYCLE_COUNT);
                                if(lclTemp_value >= MIN_SHORT_DRX_CYCLE &&
                                        lclTemp_value <= MAX_SHORT_DRX_CYCLE)
                                {
                                    /*CID:66642 start*/
                                    p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                        short_drx_cycle.short_drx_cycle=(rrm_oam_short_drx_cycle_et)lclTemp_value;
                                    /*CID:66642 end*/

                                }
                                else
                                {
                                    OAM_LOG(OAM, OAM_WARNING,
                                            "Value of ShortDRXCycle is %d and range is from %d to %d",
                                            lclTemp_value,MIN_SHORT_DRX_CYCLE,MAX_SHORT_DRX_CYCLE);

                                    return OAM_FAILURE;
                                }	
                                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                            QoS_node,"X_VENDOR_DRX_SHORT_CYCLE_TIMER"));
                                if(lclTemp_value >= MIN_DRX_SHORT_CYCLE_TIMER &&
                                        lclTemp_value <= MAX_DRX_SHORT_CYCLE_TIMER)
                                {
                                    p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                        short_drx_cycle.drx_short_cycle_timer=lclTemp_value;
                                }
                                else
                                {
                                    OAM_LOG(OAM, OAM_WARNING,
                                            "Value of DRXShortCycleTimer is %d and range is from %d to %d",
                                            lclTemp_value,MIN_DRX_SHORT_CYCLE_TIMER,MAX_DRX_SHORT_CYCLE_TIMER);

                                    return OAM_FAILURE;
                                }
                            }

                        }
                        else
                        {

                            lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->DRX,"OnDurationTimer"),RAN_MAC_DRX_OnDurationTimer[OAM_ZERO],ONDURATIONTIMER_COUNT);
                            if(lclTemp_value >= MIN_ON_DURATION_TIMER && 
                                    lclTemp_value <= MAX_ON_DURATION_TIMER)
                            {	
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    on_duration_timer=(rrm_oam_on_duration_timer_et)lclTemp_value;
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of OnDurationTimer is %d and range is from %d to %d",
                                        lclTemp_value,MIN_ON_DURATION_TIMER,MAX_ON_DURATION_TIMER);

                                return OAM_FAILURE;
                            }	

                            lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->DRX,"DRXInactivityTimer"),RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO],DRXINACTIVITYTIMER_COUNT);
                            if(lclTemp_value >= MIN_DRX_INACTIVITY_TIMER && 
                                    lclTemp_value <= MAX_DRX_INACTIVITY_TIMER)
                            {	
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    drx_inactivity_timer=(rrm_oam_drx_inactivity_timer_et)lclTemp_value;  /* coverity fix 66639 */
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of DRXInactivityTimer is %d and range is from %d to %d",
                                        lclTemp_value,MIN_DRX_INACTIVITY_TIMER,MAX_DRX_INACTIVITY_TIMER);

                                return OAM_FAILURE;
                            }	

                            lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->DRX,"DRXRetransmissionTimer"),RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO],DRXRETRANSMISSIONTIMER_COUNT);
                            if(lclTemp_value >= MIN_DRX_RETRANSMISSION_TIMER && 
                                    lclTemp_value <= MAX_DRX_RETRANSMISSION_TIMER)
                            {	
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    drx_retransmission_timer=(rrm_oam_drx_retransmission_timer_et)lclTemp_value;   /* coverity fix 66640 */                    
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of DRXRetransmissionTimer is %d and range is from %d to %d",
                                        lclTemp_value,MIN_DRX_RETRANSMISSION_TIMER,MAX_DRX_RETRANSMISSION_TIMER);

                                return OAM_FAILURE;
                            }	
                            lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->DRX,"LongDRXCycle"),RAN_MAC_DRX_longDRXCycle[OAM_ZERO],LONGDRXCYCLE_COUNT);
                            if(lclTemp_value >= MIN_LONG_DRX_CYCLE && 
                                    lclTemp_value <= MAX_LONG_DRX_CYCLE)
                            {	
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    long_drx_cycle=(rrm_oam_long_drx_cycle_start_offset_et)lclTemp_value;    /* coverity 66641 Fix  */
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of LongDRXCycle is %d and range is from %d to %d",
                                        lclTemp_value,MIN_LONG_DRX_CYCLE,MAX_LONG_DRX_CYCLE);

                                return OAM_FAILURE;
                            }		
                            #ifdef ENDC_ENABLED		
                            lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->DRX,"LongDRXCycleR15"),RAN_MAC_DRX_longDRXCycleR15[OAM_ZERO],LONGDRXCYCLE_COUNT_R15);
                            if(lclTemp_value >= MIN_LONG_DRX_CYCLE_R15 && 
                                    lclTemp_value <= MAX_LONG_DRX_CYCLE_R15)
                            {	
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    long_drx_cycle_r15 =(rrm_oam_long_drx_cycle_start_offset_r15_et)lclTemp_value;
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    bitmask |= RRM_OAM_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT;
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of LongDRXCycleR15 is %d and range is from %d to %d",
                                        lclTemp_value,MIN_LONG_DRX_CYCLE_R15,MAX_LONG_DRX_CYCLE_R15);

                                return OAM_FAILURE;
                            }
                            #endif
                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->DRX,"DRXStartOffset"));
                            if(lclTemp_value >= MIN_DRX_START_OFFSETT && 
                                    lclTemp_value <= MAX_DRX_START_OFFSETT)
                            {	
                                p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                    drx_start_offset=lclTemp_value;  
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of DRXStartOffset is %d and range is from %d to %d",
                                        lclTemp_value,MIN_DRX_START_OFFSETT,MAX_DRX_START_OFFSETT);

                                return OAM_FAILURE;
                            }	
                            if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"ShortDRXCycle"),OAM_INVALID_STR)!= OAM_ZERO) &&
                                    (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"DRXShortCycleTimer"),OAM_INVALID_STR)!= OAM_ZERO))
                            {

                                lclTemp_value=oam_xml_search_integer_to_integer ((char *)oam_xmlNodeGetContent(
                                            p_cell_spec_params->DRX,"ShortDRXCycle"), RAN_MAC_DRX_shortDRXCycle[OAM_ZERO], DRXSHORTCYCLE_COUNT);	
                                if(lclTemp_value >= MIN_SHORT_DRX_CYCLE && 
                                        lclTemp_value <= MAX_SHORT_DRX_CYCLE)
                                {	
                                    p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                        short_drx_cycle.short_drx_cycle=(rrm_oam_short_drx_cycle_et)lclTemp_value; /* coverity 66642 fix */

                                    p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].bitmask |=RRM_OAM_SHORT_DRX_CYCLE_PRESENT;

                                }
                                else
                                {
                                    OAM_LOG(OAM, OAM_WARNING,
                                            "Value of ShortDRXCycle is %d and range is from %d to %d",
                                            lclTemp_value,MIN_SHORT_DRX_CYCLE,MAX_SHORT_DRX_CYCLE);

                                    return OAM_FAILURE;
                                }

                                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                            p_cell_spec_params->DRX,"DRXShortCycleTimer"));
                                if(lclTemp_value >= MIN_DRX_SHORT_CYCLE_TIMER && 
                                        lclTemp_value <= MAX_DRX_SHORT_CYCLE_TIMER)
                                {	
                                    p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].
                                        short_drx_cycle.drx_short_cycle_timer=lclTemp_value;  
                                }
                                else
                                {
                                    OAM_LOG(OAM, OAM_WARNING,
                                            "Value of DRXShortCycleTimer is %d and range is from %d to %d",
                                            lclTemp_value,MIN_DRX_SHORT_CYCLE_TIMER,MAX_DRX_SHORT_CYCLE_TIMER);
                                    return OAM_FAILURE;
                                }	
                            }

                            /*CSR 00053551 FIX START*/
                            if(OAM_ZERO == (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"X_VENDOR_DRX_COMMAND"), "TRUE")))
                            {
                                p_rrm_cellconfig->ran_info.
                                    mac_layer_params.mac_layer_param_drx.drx_mac_ce_command_enable= (rrm_bool_et)OAM_TRUE;
                                /*CSR 00053551 bitmask fix start*/
                                if((oam_strcmp
                                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"X_VENDOR_DRX_TIMER_PERCENTAGE"),OAM_INVALID_STR)!=0))
                                {
                                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                                p_cell_spec_params->DRX,"X_VENDOR_DRX_TIMER_PERCENTAGE"));
                                    /*CID:66595 start*/
                                    p_rrm_cellconfig->ran_info.
                                        mac_layer_params.mac_layer_param_drx.drx_mac_ce_timer_percentage=(UInt16)lclTemp_value;
                                    /*CID:66595 end*/
                                    p_rrm_cellconfig->ran_info.
                                        mac_layer_params.mac_layer_param_drx.bitmask|=RRM_OAM_DRX_MAC_CE_TIMER_PERCENT_INFO_PRESENT;
                                }

                                if((oam_strcmp
                                            ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"X_VENDOR_DRX_CMD_THRESHOLD"),OAM_INVALID_STR)!=0))
                                {
                                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                                p_cell_spec_params->DRX,"X_VENDOR_DRX_CMD_THRESHOLD"));
                                    /*CID:66594 start*/
                                    p_rrm_cellconfig->ran_info.
                                        mac_layer_params.mac_layer_param_drx.drx_mac_ce_cmd_threshold=(U16)lclTemp_value;
                                    /*CID:66594 end*/
                                    p_rrm_cellconfig->ran_info.
                                        mac_layer_params.mac_layer_param_drx.bitmask|=RRM_OAM_DRX_MAC_CE_CMD_THRESHOLD_PRESENT;
                                }
                                /*CSR 00053551 bitmask fix end*/
                            }
                            else
                            {
                                if(OAM_ZERO == (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"X_VENDOR_DRX_COMMAND"), "FALSE")))
                                {
                                    p_rrm_cellconfig->ran_info.
                                        mac_layer_params.mac_layer_param_drx.drx_mac_ce_command_enable=(rrm_bool_et)OAM_FALSE;
                                }
                            }
                            /*CSR 00053551 FIX END*/
                        }
                        p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].num_applicable_qci = OAM_ONE;
                        /* SPR 15527 START */
                        p_rrm_cellconfig->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].applicable_qci_list[OAM_ZERO] = 
                            p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].qci;

                        oam_memcpy((void *)&p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info,
                                (void *)&p_rrm_cellconfig->
                                ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count],
                                sizeof(p_rrm_cellconfig->
                                    ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count]));

                        p_qos_data->qos_obj_list[qos_inst_idx].drx_enabled = OAM_TRUE;
                        /* SPR 15527 END */

                        drx_count++;
                    }
                    /* SPR_9464_FIX End */
                    /* SPR 16195 START */  
                }    
            }	/* SPR 16195 END */  
            /* SPR 15527 START */
            p_qos_data->qos_obj_list[qos_inst_idx].qos_enable = OAM_TRUE;
            oam_memcpy((void *)&p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info,
                    (void *)&p_rrm_cellconfig->
                    epc_info.epc_params.qos_config_params[count],
                    sizeof(p_rrm_cellconfig->
                        epc_info.epc_params.qos_config_params[count]));
            p_qos_data->qos_obj_list[qos_inst_idx].is_valid_entry = OAM_TRUE;  
            /* SPR 16081 fix start */
            count++;
            p_rrm_cellconfig->epc_info.epc_params.num_valid_qos_profiles = count;
            /* SPR 16081 fix end */
            /* SPR 20653 Fix Start */
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_BUCKET_SIZE_DURATION"), OAM_INVALID_STR) != OAM_ZERO)    
            {     
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_BUCKET_SIZE_DURATION"));
                if(lclTemp_value >= MIN_BUCKET_SIZE_DURATION && lclTemp_value <= MAX_BUCKET_SIZE_DURATION)
                {
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bucket_size_duration=(rrm_oam_bucket_size_duration_et)lclTemp_value;
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_BUCKET_SIZE_DURATION_PRESENT;                
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING, "Value of %s is %d and range is from %d to %d", "X_VENDOR_BUCKET_SIZE_DURATION", lclTemp_value,MIN_BUCKET_SIZE_DURATION, MAX_BUCKET_SIZE_DURATION);
                    return OAM_FAILURE;
                }
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_PRIORITIZED_BIT_RATE"), OAM_INVALID_STR) != OAM_ZERO)    
            {     
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_PRIORITIZED_BIT_RATE"));
                if(lclTemp_value >= MIN_PRIORITIZED_BIT_RATE && lclTemp_value <= MAX_PRIORITIZED_BIT_RATE)
                {
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].prioritized_bit_rate=(rrm_oam_prioritized_bit_rate_et)lclTemp_value;
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_PRIORITIZED_BIT_RATE_PRESENT;                
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING, "Value of %s is %d and range is from %d to %d", "X_VENDOR_PRIORITIZED_BIT_RATE", lclTemp_value,MIN_PRIORITIZED_BIT_RATE, MAX_PRIORITIZED_BIT_RATE);
                    return OAM_FAILURE;
                }
            }
            /* SPR 20653 Fix End */
        }/* Endof IF for QOS Enable */
        else
        {
            p_qos_data->qos_obj_list[qos_inst_idx].qos_enable = OAM_FALSE;
            p_qos_data->qos_obj_list[qos_inst_idx].is_valid_entry = OAM_TRUE;  
            lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"QCI"));
            p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.qci= (U8)lclTemp_value;        /* Coverity_fix 85397 +-*/

            lclTemp_value =
                oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(QoS_node,"Type"),
                        QoS_LogicalChannelType,QOS_LOGICALCHANNELTYPE_COUNT);
            p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.type=(rrm_oam_qos_type_et)lclTemp_value;

            lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(    QoS_node,"Priority"));
            p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.priority=lclTemp_value;

            lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                        QoS_node,"PacketDelayBudget"),EPC_QoS_PacketDelayBudget[OAM_ZERO],EPC_QOS_PACKETDELAYBUDGET_COUNT);
            p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.packet_delay_budget=(rrm_oam_packet_delay_budget_et)lclTemp_value;



            lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(    QoS_node,"PacketDelayBudget"));

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_TTI_BUNDLING"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
            {

                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_TTI_BUNDLING"));
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.tti_bundling=lclTemp_value;
                /* SPR 21958 PUSCH RAT1 Support Start */
                if(p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.tti_bundling == OAM_ONE)
                {
                    /* SPR 22549 Fix Start */
                    tti_bundling_flag[cell_index] = OAM_ONE;
                    /* SPR 22549 Fix Start */
                }		
                /* SPR 21958 PUSCH RAT1 Support End */
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_TTI_BUNDLING_PRESENT;
                OAM_LOG(OAM, OAM_DETAILED,"Value of X_VENDOR_TTI_BUNDLING[%d] is %d",qos_inst_idx,lclTemp_value);
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_LOGICAL_CHANNEL_GROUP"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_LOGICAL_CHANNEL_GROUP"));
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.logical_channel_group=lclTemp_value;
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_LOGICAL_CHANNEL_GROUP_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_RLC_AM_STATUS_REPORT_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_RLC_AM_STATUS_REPORT_REQUIRED"));
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.rlc_am_status_report_required = (rrm_bool_et)lclTemp_value;
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_RLC_AM_STATUS_REPORT_PRESENT;
            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_RLC_AM_ENB_STATUS_REPORT_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_RLC_AM_ENB_STATUS_REPORT_REQUIRED"));
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.rlc_am_enb_status_report_required = (rrm_bool_et)lclTemp_value;
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_RLC_AM_ENB_STATUS_REPORT_PRESENT;
            }

#ifdef ENDC_ENABLED
            /* ENDC changes start */
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SGNB_BEARER_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)    
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SGNB_BEARER_REQUIRED"));
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.sgnb_bearer_required = (rrm_bool_et)lclTemp_value;
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SGNB_BEARER_REQUIRED;
            }
            /* ENDC changes end */
#endif



            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_PACKETERRORLOSSRATE"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_PACKETERRORLOSSRATE"),packetErrorLossRate[OAM_ZERO],PCKT_ERR_LOSS_RATE_COUNT);
                if(lclTemp_value >= MIN_PACKET_ERROR_LOSS_RATE && lclTemp_value <= MAX_PACKET_ERROR_LOSS_RATE)
                {
                    /* cverity 35666 */
                    p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.packet_error_loss_rate=(rrm_oam_packet_error_loss_rate_et)lclTemp_value;
                    p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT;
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING, "Value of %s is %d and range is from %d to %d", "X_VENDOR_PACKETERRORLOSSRATE", lclTemp_value,MIN_PACKET_ERROR_LOSS_RATE, MAX_PACKET_ERROR_LOSS_RATE);
                    return OAM_FAILURE;
                }
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DSCP"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DSCP"));
                if(lclTemp_value >= MIN_DSCP && lclTemp_value <= MAX_DSCP)
                {
                    p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.dscp=lclTemp_value;
                    p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_DSCP_PRESENT;
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING,"Value of %s is %d and range is from %d to %d", "X_VENDOR_DSCP", lclTemp_value,MIN_DSCP,MAX_DSCP);
                    return OAM_FAILURE;
                }
            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SPS_CONFIG_ENABLED"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SPS_CONFIG_ENABLED"));

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_config_enabled=(rrm_bool_et)lclTemp_value;

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SPS_CONFIG_ENABLED_PRESENT;

                if(OAM_ONE==lclTemp_value)
                {
                }

            }

            SInt8 x_vendor_semi_persist_sched_interval_dl = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_DL"), OAM_INVALID_STR);
            SInt8 x_vendor_number_of_conf_sps_processes = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_NUMBER_OF_CONF_SPS_PROCESSES"), OAM_INVALID_STR);
            SInt8 x_vendor_max_sps_harq_retx = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_MAX_SPS_HARQ_RETX"), OAM_INVALID_STR);
            SInt8 x_vendor_explicit_release_after = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_EXPLICIT_RELEASE_AFTER"), OAM_INVALID_STR);
            if(x_vendor_number_of_conf_sps_processes &&
                    x_vendor_max_sps_harq_retx &&
                    x_vendor_explicit_release_after &&
                    x_vendor_semi_persist_sched_interval_dl)
            {

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SPS_CONFIG_DATA_PRESENT;

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.bitmask |= RRM_OAM_SPS_CONFIG_DL_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_DL"));

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.sps_config_dl.semi_persist_sched_interval_dl=lclTemp_value;


                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_NUMBER_OF_CONF_SPS_PROCESSES"));

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.sps_config_dl.number_of_conf_sps_processes=lclTemp_value;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_MAX_SPS_HARQ_RETX"));

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.sps_config_dl.max_sps_harq_retx=lclTemp_value;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_EXPLICIT_RELEASE_AFTER"));

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.sps_config_dl.explicit_release_after=lclTemp_value;

            }
            SInt8 X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL = OAM_ZERO,
                  X_VENDOR_IMPLICIT_RELEASE_AFTER = OAM_ZERO;

            X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL"), OAM_INVALID_STR);
            X_VENDOR_IMPLICIT_RELEASE_AFTER = oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_IMPLICIT_RELEASE_AFTER"), OAM_INVALID_STR);

            if((X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL != OAM_ZERO) &&
                    (X_VENDOR_IMPLICIT_RELEASE_AFTER != OAM_ZERO))    //Added RRM1.2
            {

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SPS_CONFIG_DATA_PRESENT;

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.bitmask |= RRM_OAM_SPS_CONFIG_UL_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL"));

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.sps_config_ul.semi_persist_sched_interval_ul=lclTemp_value;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_IMPLICIT_RELEASE_AFTER"));

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.sps_config_ul.implicit_release_after=lclTemp_value;

                if((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_P_ZERO_NOMINAL_PUSCH_PERSISTENT"), OAM_INVALID_STR) != OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                QoS_node,"X_VENDOR_P_ZERO_NOMINAL_PUSCH_PERSISTENT"));

                    p_qos_data->
                        qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.sps_config_ul.bitmask |= RRM_OAM_P_ZERO_NOMINAL_PUSCH_PERSISTENT_PRESENT;

                    p_qos_data->
                        qos_obj_list[qos_inst_idx].qos_qci_info.sps_data.sps_config_ul.p_zero_nominal_pusch_persistent=lclTemp_value;
                }
            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_LOSSLESS_HO_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_LOSSLESS_HO_REQUIRED"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.lossless_ho_required=lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_LOSSLESS_HO_REQ_PRESENT;
            }

            /*BUG_11564_CHANGES_START*/
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DL_FORWARDING_APPLICABILTIY"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DL_FORWARDING_APPLICABILTIY"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.dl_forwarding_applicability=(rrm_bool_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_DL_FWDING_APPLICABLE;
            }
            /*BUG_11564_CHANGES_END*/


            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_UE_INACTIVITY_TIMER_CONFIG"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node, "X_VENDOR_UE_INACTIVITY_TIMER_CONFIG"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.ue_inactivity_timer_config=lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_UE_INACTIVE_TIMER_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SUPPORTED_RAT"), OAM_INVALID_STR) != OAM_ZERO)
            {
                UInt8 bit_set = OAM_ZERO;
                Char8 *temp_str = OAM_NULL;
                Char8 *rat_str = OAM_NULL;
                rat_str = (Char8*)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SUPPORTED_RAT");
                OAM_LOG(OAM, OAM_INFO, "Value of X_VENDOR_SUPPORTED_RAT is %s",
                        rat_str);

                temp_str = strtok(rat_str, ",");
                while(temp_str) {
                    lclTemp_value = oam_xml_search_string_to_integer(temp_str,
                            SupportedRat_MAP,
                            MAX_SUPPORTED_RAT);

                    if(lclTemp_value == OAM_INVALID_RETURN) {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Skipping Unsupported RAT Type: %s",temp_str);
                        temp_str = strtok(OAM_NULL , ",");
                        continue;
                    }

                    if(OAM_ZERO != lclTemp_value)
                    {
                        bit_set |= OAM_ONE << ((UInt8)lclTemp_value - OAM_ONE);
                    }

                    temp_str = strtok(OAM_NULL , ",");
                }

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SUPPORTED_RAT_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.supported_rat = bit_set;
            }

            xmlNode* QoS_node_child = oam_xml_find_tag(QoS_node->children,(xmlChar *)"X_VENDOR_BITRATE");

            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node_child, "MIN_UL_BITRATE"), OAM_INVALID_STR) != OAM_ZERO))
            {
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_NGBR_UL_MIN_BITRATE_PRESENT;

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.ul_min_bitrate =
                    oam_atoi((const char *)oam_xmlNodeGetContent(
                                QoS_node_child,
                                "MIN_UL_BITRATE"));

            }
            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node_child, "MIN_DL_BITRATE"), OAM_INVALID_STR) != OAM_ZERO))
            {
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_NGBR_DL_MIN_BITRATE_PRESENT;

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.dl_min_bitrate =
                    oam_atoi((const char *)oam_xmlNodeGetContent(
                                QoS_node_child,
                                "MIN_DL_BITRATE"));
            }


            /*Bug fix */
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_RLC_MODE"), OAM_INVALID_STR) != OAM_ZERO)    //Added RRM1.2
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_RLC_MODE"));
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.rlc_mode=lclTemp_value;
                p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_RLC_MODE_PRESENT;
            }
            p_qos_data->
                qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;

            p_qos_data->
                qos_obj_list[qos_inst_idx].qos_qci_info.sn_field_len.bitmask |= RRM_OAM_SN_FIELD_LEN_DL_RLC_PRESENT | RRM_OAM_SN_FIELD_LEN_UL_RLC_PRESENT | RRM_OAM_RLC_UM_PDCP_SN_SIZE_PRESENT;


            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SN_LEN_UL_RLC"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SN_LEN_UL_RLC"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sn_field_len.ul_rlc =lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sn_field_len.bitmask |= RRM_OAM_SN_FIELD_LEN_UL_RLC_PRESENT;


            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_SN_LEN_DL_RLC"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_SN_LEN_DL_RLC"));

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sn_field_len.dl_rlc =lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sn_field_len.bitmask |= RRM_OAM_SN_FIELD_LEN_DL_RLC_PRESENT;

            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_RLC_UM_PDCP_SN_SIZE"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_RLC_UM_PDCP_SN_SIZE"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sn_field_len.rlc_um_pdcp_sn_size = lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sn_field_len.bitmask |= RRM_OAM_RLC_UM_PDCP_SN_SIZE_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DISCARD_TIMER"), OAM_INVALID_STR) != OAM_ZERO)
            {

                lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DISCARD_TIMER"),qosDiscardTimer,RRM_OAM_PDCP_DISCARD_TIMER_COUNT);
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.pdcp_discard_timer =(rrm_oam_pdcp_discard_timer_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_DISCARD_TIMER_PRESENT;

            }
            xmlNode* rohc_parameter = oam_xml_find_tag(QoS_node->children,(xmlChar *)"X_VENDOR_ROHC_PARAMS");
            if (OAM_NULL != rohc_parameter )
            {
                U8 lclTemp_value_rohc = OAM_ZERO;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.bitmask |=RRM_OAM_ROHC_ENABLE_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_parameter,"ENABLE_ROHC"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.enable_rohc=lclTemp_value;

                xmlNode* rohc_profile = oam_xml_find_tag(rohc_parameter->children,(xmlChar *)"MAX_CID");
                if (OAM_NULL != rohc_profile)
                {
                    p_qos_data->
                        qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.bitmask |=RRM_OAM_ROHC_MAX_CID_PRESENT;

                    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(rohc_parameter,"MAX_CID"));
                    p_qos_data->
                        qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.max_cid=lclTemp_value;
                }


                rohc_profile = oam_xml_find_tag(rohc_parameter->children,(xmlChar *)"ROHC_PROFILES");
                if (OAM_NULL != rohc_profile)
                {
                    p_qos_data->
                        qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.bitmask |=RRM_OAM_ROHC_PROFILE_PRESENT;

                    xmlNode* rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0001");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_1_PRESENT;

                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0001"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0001", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0001=lclTemp_value_rohc;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0002");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= RRM_OAM_ROHC_PROFILE_2_PRESENT;
                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0002"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0002", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0002=lclTemp_value_rohc;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0003");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_3_PRESENT;
                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0003"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0003", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0003=lclTemp_value_rohc;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0004");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_4_PRESENT;
                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0004"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0004", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0004=lclTemp_value_rohc;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0006");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_6_PRESENT;
                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0006"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0006", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0006=lclTemp_value_rohc;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0101");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_101_PRESENT;
                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0101"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0101", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0101=lclTemp_value_rohc;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0102");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_102_PRESENT;
                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0102"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0102", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0102=lclTemp_value_rohc;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0103");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_103_PRESENT;
                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0103"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0103", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0103=lclTemp_value_rohc;
                    }
                    rohc_profile_val = oam_xml_find_tag(rohc_profile->children,(xmlChar *)"ROHC_PROFILE0X0104");
                    if (OAM_NULL!= rohc_profile_val)
                    {
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |=RRM_OAM_ROHC_PROFILE_104_PRESENT;
                        lclTemp_value_rohc=oam_atoi((const char *)oam_xmlNodeGetContent(rohc_profile,"ROHC_PROFILE0X0104"));
                        if (!((lclTemp_value_rohc == 0) || (lclTemp_value_rohc == 1)))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Value of %s is %d and range is from 0 to 1", "rohc_profile0x0104", lclTemp_value_rohc);
                            return OAM_FAILURE;
                        }
                        p_qos_data->
                            qos_obj_list[qos_inst_idx].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0104=lclTemp_value_rohc;
                    }
                }
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_HARQ_TX"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_HARQ_TX"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.max_harq_tx = lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_MAX_HARQ_TX_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_HARQ_RETRANS"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_HARQ_RETRANS"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.max_harq_retrans = lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_ARQ_TX_RETRANS_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_RETX_THRESHOLD"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_MAX_RETX_THRESHOLD"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.max_rlc_transmissions = lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_MAX_RLC_TRANS_PRESENT;
            }
            /* SPR 20653 Fix Start */
            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SR_MASK_FLAG"), OAM_INVALID_STR) != OAM_ZERO) &&
                    (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SR_PROHIBIT_TIMER_R9"), OAM_INVALID_STR) != OAM_ZERO) &&
                    (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DSR_MAX_TRANSMISSIONS"), OAM_INVALID_STR) != OAM_ZERO))

            {
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SR_CONFIGURATION_PRESENT;
                /* SPR 20653 Fix End */

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SR_MASK_FLAG"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sr_configuration.sr_mask_flag = (rrm_bool_et) lclTemp_value;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SR_PROHIBIT_TIMER_R9"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sr_configuration.sr_prohibit_timer_r9 = lclTemp_value;

                lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DSR_MAX_TRANSMISSIONS"),qosSrMaxTransmission,RRM_OAM_SR_MAX_TRANSMISSION_COUNT);
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.sr_configuration.dsr_trans_max = (rrm_oam_sr_max_transmission_et)lclTemp_value;
            }
            /* coverity 56673 */

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DDL_PARAM_T_STATUES_PROHIBIT"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DDL_PARAM_T_STATUES_PROHIBIT"),RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO],TSTATUSPROHIBIT_COUNT);
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.t_status_prohibit = (rrm_oam_t_status_prohibit_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.bitmask |=RRM_OAM_TMR_STATUS_PROHIBIT_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DDL_PARAM_T_POLL_PDU"), OAM_INVALID_STR) != OAM_ZERO)
            {

                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DDL_PARAM_T_POLL_PDU"),RAN_RLC_SRB1_pollPDU[OAM_ZERO],POLLPDU_COUNT);
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.t_poll_pdu = (rrm_oam_poll_pdu_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.bitmask |=RRM_OAM_TMR_POLL_PDU_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
            }



            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DDL_PARAM_T_POLL_RETRANSMIT"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DDL_PARAM_T_POLL_RETRANSMIT"),RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO],TPOLLRETRANSMIT_COUNT);

                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.t_poll_retransmit = (rrm_oam_t_poll_retransmit_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.bitmask |=RRM_OAM_TMR_RETRSMIT_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_DL_PARAM_T_REORDERING_AM"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DL_PARAM_T_REORDERING_AM"),RAN_RLC_SRB1_TReordering[OAM_ZERO],TREORDERING_COUNT);
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.t_reordering_am = (rrm_oam_t_reordering_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.bitmask |= RRM_OAM_TMR_REORDER_FOR_AM_MODE_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;

            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_DL_PARAM_T_REORDERING_UM"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_DL_PARAM_T_REORDERING_UM"),RAN_RLC_SRB1_TReordering[OAM_ZERO],TREORDERING_COUNT);
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.t_reordering_um = (rrm_oam_t_reordering_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.bitmask |= RRM_OAM_TMR_REORDER_FOR_UM_MODE_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;

            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_UL_AM_POLL_BYTE"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_UL_AM_POLL_BYTE"),RAN_RLC_SRB1_pollByte[OAM_ZERO],POLLBYTE_COUNT);
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.ul_am_poll_byte = (rrm_oam_poll_byte_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.bitmask |= RRM_OAM_UL_AM_POLL_BYTE_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;

            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_MAX_RETX_THRESHOLD"), OAM_INVALID_STR) != OAM_ZERO)
            {
                lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            QoS_node,"X_VENDOR_MAX_RETX_THRESHOLD"),EPC_MAX_RETX_THRESHOLD[OAM_ZERO],OAM_EIGHT);


                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.ul_am_rrc_max_retx_threshold = (rrm_oam_max_retx_threshold_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.addl_rlc_param.bitmask |= RRM_OAM_MAX_RTX_THRESHOLD_PRESENT;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;

            }
            if(oam_strcmp((const char *)oam_xmlNodeGetContent( QoS_node,"X_VENDOR_SRVCC_OP_REQUIRED"), OAM_INVALID_STR) != OAM_ZERO)
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SRVCC_OP_REQUIRED"));
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.srvcc_op_required = (rrm_bool_et)lclTemp_value;
                p_qos_data->
                    qos_obj_list[qos_inst_idx].qos_qci_info.bitmask |= RRM_OAM_SRVCC_OP_REQUIRED_PRESENT;

            }
            if((oam_strcmp(((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"DRXEnabled")), OAM_INVALID_STR) != OAM_ZERO) &&
                    ((oam_strcmp(((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_ENABLED")), OAM_INVALID_STR) != OAM_ZERO)))
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DRX_ENABLED"));
                if(OAM_ZERO != lclTemp_value )
                {
                    if((oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_ON_DURATION_TIMER"), OAM_INVALID_STR) != OAM_ZERO) &&
                            (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_INACTIVITY_TIMER"), OAM_INVALID_STR) != OAM_ZERO) &&
                            (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_RETRANSMISSION_TIMER"), OAM_INVALID_STR) != OAM_ZERO) &&
                            (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_LONG_DRX_CYCLE"), OAM_INVALID_STR) != OAM_ZERO) &&
#ifdef ENDC_ENABLED
                            (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_LONG_DRX_CYCLE_R15"), OAM_INVALID_STR) != OAM_ZERO) &&
#endif
                            (oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_DRX_START_OFFSET"), OAM_INVALID_STR) != OAM_ZERO))
                    {
                        lclTemp_value= oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    QoS_node,"X_VENDOR_DRX_ON_DURATION_TIMER"),RAN_MAC_DRX_OnDurationTimer[OAM_ZERO],ONDURATIONTIMER_COUNT);
                        if(lclTemp_value >= MIN_ON_DURATION_TIMER &&
                                lclTemp_value <= MAX_ON_DURATION_TIMER)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                on_duration_timer=(rrm_oam_on_duration_timer_et)lclTemp_value;
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of OnDurationTimer is %d and range is from %d to %d",
                                    lclTemp_value,MIN_ON_DURATION_TIMER,MAX_ON_DURATION_TIMER);

                            return OAM_FAILURE;
                        }
                        lclTemp_value=  oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    QoS_node,"X_VENDOR_DRX_INACTIVITY_TIMER"),RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO],DRXINACTIVITYTIMER_COUNT);
                        if(lclTemp_value >= MIN_DRX_INACTIVITY_TIMER &&
                                lclTemp_value <= MAX_DRX_INACTIVITY_TIMER)
                        {
                            /*cov 85424 +*/
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                drx_inactivity_timer=(rrm_oam_drx_inactivity_timer_et )lclTemp_value;
                            /*cov 85424 -*/
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of DRXInactivityTimer is %d and range is from %d to %d",
                                    lclTemp_value,MIN_DRX_INACTIVITY_TIMER,MAX_DRX_INACTIVITY_TIMER);

                            return OAM_FAILURE;
                        }
                        lclTemp_value= oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    QoS_node,"X_VENDOR_DRX_RETRANSMISSION_TIMER"),RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO],DRXRETRANSMISSIONTIMER_COUNT);
                        if(lclTemp_value >= MIN_DRX_RETRANSMISSION_TIMER &&
                                lclTemp_value <= MAX_DRX_RETRANSMISSION_TIMER)
                        {
                            /*cov 85417 +*/
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                drx_retransmission_timer=(rrm_oam_drx_retransmission_timer_et)lclTemp_value;
                            /*cov 85417 -*/
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of DRXRetransmissionTimer is %d and range is from %d to %d",
                                    lclTemp_value,MIN_DRX_RETRANSMISSION_TIMER,MAX_DRX_RETRANSMISSION_TIMER);

                            return OAM_FAILURE;
                        }
                        lclTemp_value= oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    QoS_node,"X_VENDOR_LONG_DRX_CYCLE"),RAN_MAC_DRX_longDRXCycle[OAM_ZERO],LONGDRXCYCLE_COUNT);
                        if(lclTemp_value >= MIN_LONG_DRX_CYCLE &&
                                lclTemp_value <= MAX_LONG_DRX_CYCLE)
                        {
                            /*cov 85407 +*/
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                long_drx_cycle=(rrm_oam_long_drx_cycle_start_offset_et)lclTemp_value;
                            /*cov 85407 -*/
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of LongDRXCycle is %d and range is from %d to %d",
                                    lclTemp_value,MIN_LONG_DRX_CYCLE,MAX_LONG_DRX_CYCLE);

                            return OAM_FAILURE;
                        }
#ifdef ENDC_ENABLED
                        lclTemp_value= oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    QoS_node,"X_VENDOR_LONG_DRX_CYCLE_R15"),RAN_MAC_DRX_longDRXCycleR15[OAM_ZERO],LONGDRXCYCLE_COUNT_R15);
                        if(lclTemp_value >= MIN_LONG_DRX_CYCLE_R15 &&
                                lclTemp_value <= MAX_LONG_DRX_CYCLE_R15)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                long_drx_cycle_r15 =(rrm_oam_long_drx_cycle_start_offset_r15_et)lclTemp_value;
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                bitmask |= RRM_OAM_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT;
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of LongDRXCycleR15 is %d and range is from %d to %d",
                                    lclTemp_value,MIN_LONG_DRX_CYCLE_R15,MAX_LONG_DRX_CYCLE_R15);

                            return OAM_FAILURE;
                        }
#endif
                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    QoS_node,"X_VENDOR_DRX_START_OFFSET"));
                        if(lclTemp_value >= MIN_DRX_START_OFFSETT &&
                                lclTemp_value <= MAX_DRX_START_OFFSETT)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                drx_start_offset=lclTemp_value;
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of DRXStartOffset is %d and range is from %d to %d",
                                    lclTemp_value,MIN_DRX_START_OFFSETT,MAX_DRX_START_OFFSETT);

                            return OAM_FAILURE;
                        }
                        if((oam_strcmp(((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_SHORT_DRX_CYCLE")),OAM_INVALID_STR)!= OAM_ZERO) &&
                                (oam_strcmp(((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_DRX_SHORT_CYCLE_TIMER")),OAM_INVALID_STR)!= OAM_ZERO))
                        {
                            p_qos_data->
                                qos_obj_list[qos_inst_idx].drx_per_qci_info.bitmask |=RRM_OAM_SHORT_DRX_CYCLE_PRESENT;
                            lclTemp_value= oam_xml_search_integer_to_integer ((char *)oam_xmlNodeGetContent(
                                        QoS_node,"X_VENDOR_SHORT_DRX_CYCLE"), RAN_MAC_DRX_shortDRXCycle[OAM_ZERO], DRXSHORTCYCLE_COUNT);
                            if(lclTemp_value >= MIN_SHORT_DRX_CYCLE &&
                                    lclTemp_value <= MAX_SHORT_DRX_CYCLE)
                            {
                                /*cov 85427 +*/
                                p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                    short_drx_cycle.short_drx_cycle=(rrm_oam_short_drx_cycle_et)lclTemp_value;
                                /*cov 85427 -*/

                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of ShortDRXCycle is %d and range is from %d to %d",
                                        lclTemp_value,MIN_SHORT_DRX_CYCLE,MAX_SHORT_DRX_CYCLE);

                                return OAM_FAILURE;
                            }
                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        QoS_node,"X_VENDOR_DRX_SHORT_CYCLE_TIMER"));
                            if(lclTemp_value >= MIN_DRX_SHORT_CYCLE_TIMER &&
                                    lclTemp_value <= MAX_DRX_SHORT_CYCLE_TIMER)
                            {
                                p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                    short_drx_cycle.drx_short_cycle_timer=lclTemp_value;
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of DRXShortCycleTimer is %d and range is from %d to %d",
                                        lclTemp_value,MIN_DRX_SHORT_CYCLE_TIMER,MAX_DRX_SHORT_CYCLE_TIMER);

                                return OAM_FAILURE;
                            }
                        }

                    }
                    else
                    {

                        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->DRX,"OnDurationTimer"),RAN_MAC_DRX_OnDurationTimer[OAM_ZERO],ONDURATIONTIMER_COUNT);
                        if(lclTemp_value >= MIN_ON_DURATION_TIMER &&
                                lclTemp_value <= MAX_ON_DURATION_TIMER)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                on_duration_timer=(rrm_oam_on_duration_timer_et)lclTemp_value;
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of OnDurationTimer is %d and range is from %d to %d",
                                    lclTemp_value,MIN_ON_DURATION_TIMER,MAX_ON_DURATION_TIMER);

                            return OAM_FAILURE;
                        }

                        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->DRX,"DRXInactivityTimer"),RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO],DRXINACTIVITYTIMER_COUNT);
                        if(lclTemp_value >= MIN_DRX_INACTIVITY_TIMER &&
                                lclTemp_value <= MAX_DRX_INACTIVITY_TIMER)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                /*Coveirty 85424 Fix Start*/ 
                                drx_inactivity_timer= (rrm_oam_drx_inactivity_timer_et )lclTemp_value;
                            /*Coveirty 85424 Fix End*/ 
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of DRXInactivityTimer is %d and range is from %d to %d",
                                    lclTemp_value,MIN_DRX_INACTIVITY_TIMER,MAX_DRX_INACTIVITY_TIMER);

                            return OAM_FAILURE;
                        }

                        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->DRX,"DRXRetransmissionTimer"),RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO],DRXRETRANSMISSIONTIMER_COUNT);
                        if(lclTemp_value >= MIN_DRX_RETRANSMISSION_TIMER &&
                                lclTemp_value <= MAX_DRX_RETRANSMISSION_TIMER)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                /*Coveirty 85417 Fix Start*/ 
                                drx_retransmission_timer=(rrm_oam_drx_retransmission_timer_et)lclTemp_value;
                            /*Coveirty 85417 Fix End*/ 
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of DRXRetransmissionTimer is %d and range is from %d to %d",
                                    lclTemp_value,MIN_DRX_RETRANSMISSION_TIMER,MAX_DRX_RETRANSMISSION_TIMER);

                            return OAM_FAILURE;
                        }

                        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->DRX,"LongDRXCycle"),RAN_MAC_DRX_longDRXCycle[OAM_ZERO],LONGDRXCYCLE_COUNT);
                        if(lclTemp_value >= MIN_LONG_DRX_CYCLE &&
                                lclTemp_value <= MAX_LONG_DRX_CYCLE)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                /*Coveirty 85407 Fix Start*/ 
                                long_drx_cycle=(rrm_oam_long_drx_cycle_start_offset_et)lclTemp_value;
                            /*Coveirty 85407 Fix Start*/ 
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of LongDRXCycle is %d and range is from %d to %d",
                                    lclTemp_value,MIN_LONG_DRX_CYCLE,MAX_LONG_DRX_CYCLE);

                            return OAM_FAILURE;
                        }
#ifdef ENDC_ENABLED
                        lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->DRX,"LongDRXCycleR15"),RAN_MAC_DRX_longDRXCycleR15[OAM_ZERO],LONGDRXCYCLE_COUNT_R15);
                        if(lclTemp_value >= MIN_LONG_DRX_CYCLE_R15 &&
                                lclTemp_value <= MAX_LONG_DRX_CYCLE_R15)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                long_drx_cycle_r15=(rrm_oam_long_drx_cycle_start_offset_r15_et)lclTemp_value;
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                bitmask |= RRM_OAM_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT;
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of LongDRXCycleR15 is %d and range is from %d to %d",
                                    lclTemp_value,MIN_LONG_DRX_CYCLE_R15,MAX_LONG_DRX_CYCLE_R15);

                            return OAM_FAILURE;
                        }
#endif

                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->DRX,"DRXStartOffset"));
                        if(lclTemp_value >= MIN_DRX_START_OFFSETT &&
                                lclTemp_value <= MAX_DRX_START_OFFSETT)
                        {
                            p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                drx_start_offset=lclTemp_value;
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of DRXStartOffset is %d and range is from %d to %d",
                                    lclTemp_value,MIN_DRX_START_OFFSETT,MAX_DRX_START_OFFSETT);

                            return OAM_FAILURE;
                        }
                        if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"ShortDRXCycle"),OAM_INVALID_STR)!= OAM_ZERO) &&
                                (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->DRX,"DRXShortCycleTimer"),OAM_INVALID_STR)!= OAM_ZERO))
                        {

                            lclTemp_value=oam_xml_search_integer_to_integer ((char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->DRX,"ShortDRXCycle"), RAN_MAC_DRX_shortDRXCycle[OAM_ZERO], DRXSHORTCYCLE_COUNT);
                            if(lclTemp_value >= MIN_SHORT_DRX_CYCLE &&
                                    lclTemp_value <= MAX_SHORT_DRX_CYCLE)
                            {
                                p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                    /*Coveirty 85427 Fix Start*/ 
                                    short_drx_cycle.short_drx_cycle=(rrm_oam_short_drx_cycle_et)lclTemp_value;
                                /*Coveirty 85427 Fix Start*/ 

                                p_qos_data->
                                    qos_obj_list[qos_inst_idx].drx_per_qci_info.bitmask |=RRM_OAM_SHORT_DRX_CYCLE_PRESENT;

                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_DETAILED,
                                        "Value of ShortDRXCycle is %d and range is from %d to %d\n",
                                        lclTemp_value,MIN_SHORT_DRX_CYCLE,MAX_SHORT_DRX_CYCLE);

                                return OAM_FAILURE;
                            }

                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->DRX,"DRXShortCycleTimer"));
                            if(lclTemp_value >= MIN_DRX_SHORT_CYCLE_TIMER &&
                                    lclTemp_value <= MAX_DRX_SHORT_CYCLE_TIMER)
                            {
                                p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.
                                    short_drx_cycle.drx_short_cycle_timer=lclTemp_value;
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Value of DRXShortCycleTimer is %d and range is from %d to %d",
                                        lclTemp_value,MIN_DRX_SHORT_CYCLE_TIMER,MAX_DRX_SHORT_CYCLE_TIMER);
                                return OAM_FAILURE;
                            }
                        }

                    }
                    p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.num_applicable_qci = OAM_ONE;
                    p_qos_data->qos_obj_list[qos_inst_idx].drx_per_qci_info.applicable_qci_list[OAM_ZERO] =
                        p_qos_data->qos_obj_list[qos_inst_idx].qos_qci_info.qci;

                }
            }
            /* SPR 20653 Fix Start */
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_BUCKET_SIZE_DURATION"), OAM_INVALID_STR) != OAM_ZERO)    
            {     
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_BUCKET_SIZE_DURATION"));
                if(lclTemp_value >= MIN_BUCKET_SIZE_DURATION && lclTemp_value <= MAX_BUCKET_SIZE_DURATION)
                {
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bucket_size_duration=(rrm_oam_bucket_size_duration_et)lclTemp_value;
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_BUCKET_SIZE_DURATION_PRESENT;                
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING, "Value of %s is %d and range is from %d to %d", "X_VENDOR_BUCKET_SIZE_DURATION", lclTemp_value,MIN_BUCKET_SIZE_DURATION, MAX_BUCKET_SIZE_DURATION);
                    return OAM_FAILURE;
                }
            }

            if(oam_strcmp((const char *)oam_xmlNodeGetContent(QoS_node, "X_VENDOR_PRIORITIZED_BIT_RATE"), OAM_INVALID_STR) != OAM_ZERO)    
            {     
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(QoS_node,"X_VENDOR_PRIORITIZED_BIT_RATE"));
                if(lclTemp_value >= MIN_PRIORITIZED_BIT_RATE && lclTemp_value <= MAX_PRIORITIZED_BIT_RATE)
                {
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].prioritized_bit_rate=(rrm_oam_prioritized_bit_rate_et)lclTemp_value;
                    p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_PRIORITIZED_BIT_RATE_PRESENT;                
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING, "Value of %s is %d and range is from %d to %d", "X_VENDOR_PRIORITIZED_BIT_RATE", lclTemp_value,MIN_PRIORITIZED_BIT_RATE, MAX_PRIORITIZED_BIT_RATE);
                    return OAM_FAILURE;
                }
            }
            /* SPR 20653 Fix End */
        }/* SPR 15527 END */    
    }	/* End FOR Loop */

    /* SPR_9464_FIX Start */
    if(drx_count <= MAX_NUM_VALID_DRX_PROFILES)
    {
        p_rrm_cellconfig->ran_info.
            mac_layer_params.mac_layer_param_drx.num_valid_drx_profiles = drx_count;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of num_valid_drx_profiles is %d and range is from %d to %d",
                drx_count,MIN_NUM_VALID_DRX_PROFILES,MAX_NUM_VALID_DRX_PROFILES);

        return OAM_FAILURE;
    }
    /* SPR_9464_FIX End */

    /* below code for ULSCH sholud come after populating qos params */
    if(p_cell_spec_params->ULSCH != OAM_NULL)
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->ULSCH, "RetxBSRTimer"), OAM_INVALID_STR) != OAM_ZERO)  
        {
            lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(p_cell_spec_params->ULSCH,"RetxBSRTimer"),QoS_MAC_BSR_RETX[OAM_ZERO],OAM_SIX);
            for(count = MIN_RRM_CELL_QCI-1; count < MAX_RRM_CELL_QCI; count++){  
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].addl_mac_param.bsr_config.t_retx_bsr= (rrm_oam_retx_tmr_bsr_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_MAC_PARAM_PRESENT;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].addl_mac_param.bitmask |= RRM_OAM_BSR_CONFIG_PRESENT;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].addl_mac_param.bsr_config.bitmask |= RRM_OAM_RETX_TMR_BSR_PRESENT;
                OAM_LOG(OAM, OAM_INFO,"Value of RetxBSRTimer[%d] is %d",count,lclTemp_value);
            }
        }
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->ULSCH, "PeriodicBSRTimer"), OAM_INVALID_STR) != OAM_ZERO)   
        {
            lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(p_cell_spec_params->ULSCH,"PeriodicBSRTimer"),QoS_MAC_BSR_PERIODIC[OAM_ZERO],OAM_FIFTEEN);
            for(count = MIN_RRM_CELL_QCI-1; count < MAX_RRM_CELL_QCI; count++){
                p_rrm_cellconfig->epc_info.epc_params.
                    qos_config_params[count].addl_mac_param.bsr_config.t_periodic_bsr=(rrm_oam_periodic_tmr_bsr_et)lclTemp_value;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask |= RRM_OAM_ADDL_MAC_PARAM_PRESENT;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].addl_mac_param.bitmask |= RRM_OAM_BSR_CONFIG_PRESENT;
                p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].addl_mac_param.bsr_config.bitmask |= RRM_OAM_PERIODIC_TMR_BSR_PRESENT;
                OAM_LOG(OAM, OAM_INFO,"Value of PeriodicBSRTimer[%d] is %d",count,lclTemp_value);
            }
        }

        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->ULSCH,
                "TTIBundling");
        if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
            /* Coverity CID 62469 Fix Start*/
            lclTemp_value_1 = oam_atoi((Char8*)tag_value);
            /* SPR 18641_18843 fix start */
            if(lclTemp_value_1)
            {
                if( (oam_strcmp((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->tti_bundling_info_params,"ul_sinr_threshold_to_actv_tti"), OAM_INVALID_STR) != OAM_ZERO)
                        && (oam_strcmp((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->tti_bundling_info_params,"ul_sinr_threshold_to_deactv_tti"), OAM_INVALID_STR) != OAM_ZERO) 
                        && (oam_strcmp((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->tti_bundling_info_params,"rrm_ue_used_rb_threshold"), OAM_INVALID_STR) != OAM_ZERO) )
                {

                    p_rrm_cellconfig->operator_info.tti_bundling_info.ul_sinr_threshold_to_actv_tti = 
                                                                                                      oam_atoi((const char *)oam_xmlNodeGetContent(
                                                                                                                  p_prop_cellconfig->tti_bundling_info_params,"ul_sinr_threshold_to_actv_tti"));
                    p_rrm_cellconfig->operator_info.tti_bundling_info.ul_sinr_threshold_to_deactv_tti = 
                                                                                                        oam_atoi((const char *)oam_xmlNodeGetContent(
                                                                                                                    p_prop_cellconfig->tti_bundling_info_params,"ul_sinr_threshold_to_deactv_tti"));
                    p_rrm_cellconfig->operator_info.tti_bundling_info.rrm_ue_used_rb_threshold = 
                                                                                                 oam_atoi((const char *)oam_xmlNodeGetContent(
                                                                                                             p_prop_cellconfig->tti_bundling_info_params,"rrm_ue_used_rb_threshold"));

                    if(p_rrm_cellconfig->operator_info.tti_bundling_info.ul_sinr_threshold_to_deactv_tti <= 
                            p_rrm_cellconfig->operator_info.tti_bundling_info.ul_sinr_threshold_to_actv_tti)
                    {
                        OAM_LOG(OAM, OAM_WARNING,"ul_sinr_threshold_to_deactv_tti[%d] should be greater than ul_sinr_threshold_to_actv_tti[%d]",
                                p_rrm_cellconfig->operator_info.tti_bundling_info.ul_sinr_threshold_to_deactv_tti,
                                p_rrm_cellconfig->operator_info.tti_bundling_info.ul_sinr_threshold_to_actv_tti);
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }

                    p_rrm_cellconfig->operator_info.tti_bundling_info.bitmask = OAM_ZERO;
                    p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_TTI_BUNDLING_INFO_PRESENT;

                    OAM_LOG(OAM, OAM_INFO,"TTI_B[%d], ul_sinr_thres_actv_tti[%d], ul_sinr_thres_deactv_tti[%d], rrm_rb_thres[%d]",
                            lclTemp_value_1,
                            p_rrm_cellconfig->operator_info.tti_bundling_info.ul_sinr_threshold_to_actv_tti,
                            p_rrm_cellconfig->operator_info.tti_bundling_info.ul_sinr_threshold_to_deactv_tti,
                            p_rrm_cellconfig->operator_info.tti_bundling_info.rrm_ue_used_rb_threshold);
                }
            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,"TTI Bundling[%d] is disabled. Can't fill tti_bundling_info_params",lclTemp_value_1);
            }
            /* SPR 18641_18843 fix end */

            for(count = MIN_RRM_CELL_QCI-1; count < MAX_RRM_CELL_QCI; count++){
                if(!(p_rrm_cellconfig->epc_info.epc_params.
                            qos_config_params[count].
                            bitmask & RRM_OAM_TTI_BUNDLING_PRESENT)) {
                    p_rrm_cellconfig->epc_info.epc_params.
                        qos_config_params[count].tti_bundling = lclTemp_value_1;
                    p_rrm_cellconfig->epc_info.epc_params.
                        qos_config_params[count].
                        bitmask |= RRM_OAM_TTI_BUNDLING_PRESENT;
                    OAM_LOG(OAM, OAM_INFO,
                            "Value of TTIBundling[%d] is %d", count,
                            lclTemp_value_1);
                    /* Coverity CID 62469 Fix Start*/
                }
            }
        }
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->ULSCH, "MaxHARQTx"), OAM_INVALID_STR) != OAM_ZERO)
        {
            U8 lclTemp_value_harq = OAM_ZERO;
            lclTemp_value_harq = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->ULSCH, "MaxHARQTx"));
            for(count = MIN_RRM_CELL_QCI-1; count < MAX_RRM_CELL_QCI; count++){  
                if(!(p_rrm_cellconfig->epc_info.epc_params.qos_config_params[count].bitmask & RRM_OAM_MAX_HARQ_TX_PRESENT))
                {
                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].max_harq_tx = lclTemp_value_harq;
                    p_rrm_cellconfig->epc_info.
                        epc_params.qos_config_params[count].bitmask |= RRM_OAM_MAX_HARQ_TX_PRESENT;
                } 
            }
        }  
    }

    if(oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_EMERGENCY_SERVICE, "IMS_EMERGENCY_SUPPORT_R9"), OAM_INVALID_STR) != OAM_ZERO) 
    {
        p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ADDL_SIB1_INFO_PRESENT;
        p_rrm_cellconfig->operator_info.sib_1_info.bitmask |= RRM_OAM_IMS_EMERGENCY_SUPPORT_R9_PRESENT;
        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_EMERGENCY_SERVICE, "IMS_EMERGENCY_SUPPORT_R9"));
        /* coverity 35673 */
        p_rrm_cellconfig->operator_info.sib_1_info.ims_emergency_support_r9 = (rrm_oam_ims_emergency_support_r9_et)lclTemp_value;
    }

    /* CSR:0058598 FIX START */
    if(oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_EMERGENCY_SERVICE,"EMERGENCY_ERAB_ARP"), OAM_INVALID_STR) != OAM_ZERO)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_EMERGENCY_SERVICE,"EMERGENCY_ERAB_ARP"));
        p_rrm_cellconfig->epc_info.epc_params.emergency_erab_arp=lclTemp_value;
        p_rrm_cellconfig->epc_info.epc_params.bitmask |= RRM_OAM_EMERGENCY_ERAB_ARP_PRESENT;
    }
    /* CSR:0058598 FIX END */

    if(oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2, "X_VENDOR_Q_QUAL_MIN_R9"), OAM_INVALID_STR) != OAM_ZERO)
    {
        p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ADDL_SIB1_INFO_PRESENT;
        p_rrm_cellconfig->operator_info.sib_1_info.bitmask |= RRM_OAM_CELL_SELECTION_INFO_R9_PRESENT;
        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2, "X_VENDOR_Q_QUAL_MIN_R9"));
        p_rrm_cellconfig->operator_info.sib_1_info.cell_selection_info.q_qual_min_r9 = lclTemp_value;
    }

    if(oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2, "X_VENDOR_Q_QUAL_MIN_OFFSET_R9_PRESENT"), OAM_INVALID_STR)!= OAM_ZERO)
    {
        p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ADDL_SIB1_INFO_PRESENT;
        p_rrm_cellconfig->operator_info.sib_1_info.cell_selection_info.bitmask |= RRM_OAM_Q_QUAL_MIN_OFFSET_R9_PRESENT;
        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2, "X_VENDOR_Q_QUAL_MIN_OFFSET_R9_PRESENT"));
        p_rrm_cellconfig->operator_info.sib_1_info.cell_selection_info.q_qual_min_offset_r9_present = lclTemp_value;
        p_rrm_cellconfig->operator_info.
            sib_1_info.cell_selection_info.bitmask |= RRM_OAM_Q_QUAL_MIN_OFFSET_R9_PRESENT;
    }
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,"MODIFICATION_PERIOD_COEFF"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_MODIFICATION_PERIOD_COEFF 
         && 
         lclTemp_value <= MAX_RRM_CELL_MODIFICATION_PERIOD_COEFF
        )
        {  
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.modification_period_coeff
                =(rrm_oam_modification_period_coeff_et)lclTemp_value;
            p_rrm_cellconfig->operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= RRM_OAM_MODIFICATION_PERIOD_COEFF_PRESENT;
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,"MODIFICATION_PERIOD_COEFF"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            return OAM_FAILURE;
        }
    }


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO, "DEFAULT_PAGING_CYCLE"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_DEFAULT_PAGING_CYCLE 
         && 
         lclTemp_value <= MAX_RRM_CELL_DEFAULT_PAGING_CYCLE
        )
        { 
            /* coverity 35678 */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.default_paging_cycle
                =(rrm_oam_default_paging_cycle_et)lclTemp_value;
            p_rrm_cellconfig->operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= RRM_OAM_DEFAULT_PAGING_CYCLE_PRESENT;
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO, "DEFAULT_PAGING_CYCLE"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            return OAM_FAILURE;
        }
    }




    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->RArnti,"RArntiStartRange"));

    if 
        (
         lclTemp_value>= MIN_RRM_MAC_S_RARNTI 
         && 
         lclTemp_value<= MAX_RRM_MAC_S_RARNTI
        )
        {
            p_rrm_cellconfig->
                operator_info.rrm_mac_config.start_rarnti_range=lclTemp_value;
        }
    else 
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of RArntiStartRange is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_MAC_S_RARNTI,MAX_RRM_MAC_S_RARNTI);	

        return OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->RArnti, "RArntiEndRange"));
    if 
        (
         lclTemp_value>= MIN_RRM_MAC_E_RARNTI 
         && 
         lclTemp_value<= MAX_RRM_MAC_E_RARNTI
        )
        {
            p_rrm_cellconfig->
                operator_info.rrm_mac_config.end_rarnti_range=lclTemp_value;
        }
    else 
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of RArntiEndRange is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_MAC_E_RARNTI,MAX_RRM_MAC_E_RARNTI);

        return OAM_FAILURE;
    }
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"X_VENDOR_PHICH_RESOURCE"));
    if 
        (
         lclTemp_value>= MIN_RRM_CELL_PHICH_RESOURCE 
         && 
         lclTemp_value<= MAX_RRM_CELL_PHICH_RESOURCE
        )
        {
            p_rrm_cellconfig->
                operator_info.phich_config.phich_resource=lclTemp_value;
        }
    else 
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of X_VENDOR_PHICH_RESOURCE is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_CELL_PHICH_RESOURCE,MAX_RRM_CELL_PHICH_RESOURCE);

        return OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"X_VENDOR_PHICH_DURATION"));
    if 
        (
         lclTemp_value>= MIN_RRM_CELL_PHICH_DURATION 
         && 
         lclTemp_value<= MAX_RRM_CELL_PHICH_DURATION
        )
        {
            p_rrm_cellconfig->operator_info.
                phich_config.phich_duration=lclTemp_value;
        }
    else 
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of X_VENDOR_PHICH_DURATION is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_CELL_PHICH_DURATION,MAX_RRM_CELL_PHICH_DURATION);

        return OAM_FAILURE;
    }
    /* SPR 20653 Fix Start */
    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"X_VENDOR_RB_SIZE"),RBSize[OAM_ZERO],RB_SIZE_COUNT);

    if 
        (
         lclTemp_value >= MIN_RRM_RB_SIZE 
         && 
         lclTemp_value <= MAX_RRM_RB_SIZE
        )
        {
            p_rrm_cellconfig->ran_info.rf_params.
                rf_configurations.rb_size=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of X_VENDOR_RB_SIZE is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_RB_SIZE,MAX_RRM_RB_SIZE);

        return OAM_FAILURE;
    } 
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->AntennaInfo,"AntennaPortsCount"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->AntennaInfo,"AntennaPortsCount"));

        p_rrm_cellconfig->ran_info.rf_params.
            rf_configurations.antenna_ports_count_number = lclTemp_value;

        p_rrm_cellconfig->ran_info.rf_params.
            rf_configurations.bitmask |= RRM_OAM_ANTENNA_PORTS_COUNT_NO_PRESENT;

    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of AntennaPortsCount not found");

        return OAM_FAILURE;
    } 
    /* SPR 20653 Fix End */
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_EMERGENCY_SERVICE,
                    "ims_emergency_support_r9"),OAM_INVALID_STR)!= OAM_ZERO)
      )
    {
        /*for bug 318*/
        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_ADDL_SIB1_INFO_PRESENT;
        p_rrm_cellconfig->operator_info.
            sib_1_info.bitmask |= RRM_OAM_IMS_EMERGENCY_SUPPORT_R9_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_EMERGENCY_SERVICE,"IMS_EMERGENCY_SUPPORT_R9"));
        /* coverity 35705 */
        p_rrm_cellconfig->operator_info.
            sib_1_info.ims_emergency_support_r9=(rrm_oam_ims_emergency_support_r9_et)lclTemp_value;
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2,"X_VENDOR_Q_QUAL_MIN_R9"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ADDL_SIB1_INFO_PRESENT;
            p_rrm_cellconfig->operator_info.sib_1_info.bitmask |= RRM_OAM_CELL_SELECTION_INFO_R9_PRESENT;     

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->Common_2,"X_VENDOR_Q_QUAL_MIN_R9")); 
            p_rrm_cellconfig->operator_info.
                sib_1_info.cell_selection_info.q_qual_min_r9=lclTemp_value;
        }


        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2,
                        "X_VENDOR_Q_QUAL_MIN_OFFSET_R9_PRESENT"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.sib_1_info.cell_selection_info.bitmask |= RRM_OAM_Q_QUAL_MIN_OFFSET_R9_PRESENT;
            p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ADDL_SIB1_INFO_PRESENT;


            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->Common_2, "X_VENDOR_Q_QUAL_MIN_OFFSET_R9_PRESENT"));
            p_rrm_cellconfig->operator_info.
                sib_1_info.cell_selection_info.q_qual_min_offset_r9_present=lclTemp_value;
            p_rrm_cellconfig->operator_info.
                sib_1_info.cell_selection_info.
                bitmask |= RRM_OAM_Q_QUAL_MIN_OFFSET_R9_PRESENT;
        }
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,"MODIFICATION_PERIOD_COEFF"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_MODIFICATION_PERIOD_COEFF 
         && 
         lclTemp_value <= MAX_RRM_CELL_MODIFICATION_PERIOD_COEFF
        )
        {  
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.modification_period_coeff
                =(rrm_oam_modification_period_coeff_et)lclTemp_value;
            p_rrm_cellconfig->
                operator_info.sib_2_info.radio_res_config_common_sib.
                bitmask |= RRM_OAM_MODIFICATION_PERIOD_COEFF_PRESENT;
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO, "MODIFICATION_PERIOD_COEFF"),
                    OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of modification_period_coeff is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_MODIFICATION_PERIOD_COEFF,
                    MAX_RRM_CELL_MODIFICATION_PERIOD_COEFF);

            return OAM_FAILURE;
        }
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO, "NB"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_NB 
         && 
         lclTemp_value <= MAX_RRM_CELL_NB
        )
        {  
            /* coverity 35687 */
            p_rrm_cellconfig->
                operator_info.sib_2_info.radio_res_config_common_sib.nB=(rrm_oam_nB_et)lclTemp_value;
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.bitmask |= RRM_OAM_NB_PRESENT;
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO, "NB"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of nB is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_NB,MAX_RRM_CELL_NB);

            return OAM_FAILURE;
        }
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO,"UL_CYCLIC_PREFIX_LENGTH"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_UL_CYCLIC_PREFIX_LENGTH 
         && 
         lclTemp_value <= MAX_RRM_CELL_UL_CYCLIC_PREFIX_LENGTH
        )
        {
            /* coverity 35706 */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length=(rrm_oam_ul_cyclic_prefix_length_et)lclTemp_value;
            p_rrm_cellconfig->operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= RRM_OAM_UL_CYCLIC_PREFIX_LEN_PRESENT;
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->X_VENDOR_ADDITIONAL_OPERATOR_INFO, "UL_CYCLIC_PREFIX_LENGTH"),
                    OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of ul_cyclic_prefix_length is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_UL_CYCLIC_PREFIX_LENGTH,
                    MAX_RRM_CELL_UL_CYCLIC_PREFIX_LENGTH);

            return OAM_FAILURE;
        }
    }  

    lclTemp_value2=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->Common_2,"X_VENDOR_ADDITIONAL_SPECTRUM_EMISSION"));
    if 
        (
         /* Coverity FIX 54899 */
         lclTemp_value2 <= MAX_RRM_CELL_ADDITIONAL_SPECTRUM_EMISSION
        )
        {
            /* coverity 52770 */
            p_rrm_cellconfig->operator_info.
                sib_2_info.additional_spectrum_emission=lclTemp_value2;
        }
    else 
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of X_VENDOR_ADDITIONAL_SPECTRUM_EMISSION is %d and range is from %d to %d",
                lclTemp_value2,MIN_RRM_CELL_ADDITIONAL_SPECTRUM_EMISSION,
                MAX_RRM_CELL_ADDITIONAL_SPECTRUM_EMISSION);

        return OAM_FAILURE;
    } 

    /* coverity 52772 */
    lclTemp_value2=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->Common_2, "X_VENDOR_TIME_ALIGNMENT_TIMER_COMMON"));
    p_rrm_cellconfig->operator_info.
        sib_2_info.time_alignment_timer_common=lclTemp_value2;

    /* SPR 17222 FIX START */
    if(p_cell_spec_params->AC_BARRING_FOR_MO_SIGNALLING != NULL)
    {
        /* SPR 17222 FIX END */
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->AC_BARRING_FOR_MO_SIGNALLING,
                        "AC_BARRING_FACTOR"),OAM_INVALID_STR)!= OAM_ZERO))
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->AC_BARRING_FOR_MO_SIGNALLING, "AC_BARRING_FACTOR"));
            /* coverity 35795 */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.access_barring_info.
                ac_barring_for_mo_signalling.ac_barring_factor=(rrm_oam_ac_barring_factor_et)lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->AC_BARRING_FOR_MO_SIGNALLING,"AC_BARRING_TIME"));
            /* coverity 35796 */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.access_barring_info.
                ac_barring_for_mo_signalling.ac_barring_time=(rrm_oam_ac_barring_time_et)lclTemp_value;

            lclTemp_value2=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->AC_BARRING_FOR_MO_SIGNALLING, "AC_BARRING_FOR_SPECIAL_AC"));
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.access_barring_info.
                ac_barring_for_mo_signalling.ac_barring_for_special_ac=lclTemp_value2;
            /* BITSTRING CHANGES START */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.access_barring_info.
                ac_barring_for_mo_signalling.ac_barring_for_special_ac <<= OAM_THREE;
            /* BITSTRING CHANGES END */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.
                access_barring_info.bitmask |= RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT;

            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.
                bitmask |= RRM_OAM_BARRING_INFO_PRESENT;
        }
        /* SPR 17222 FIX START */
    }
    else
    {
        OAM_LOG(OAM,OAM_INFO,"AC_BARRING_FOR_MO_SIGNALLING Tag is not present");
    }


    if(p_cell_spec_params->AC_BARRING_FOR_MO_DATA != NULL)
    {
        /* SPR 17222 FIX END */

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->AC_BARRING_FOR_MO_DATA,
                        "AC_BARRING_FACTOR"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->AC_BARRING_FOR_MO_DATA, "AC_BARRING_FACTOR"));
            /* coverity 35793 */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.access_barring_info.
                ac_barring_for_mo_data.ac_barring_factor=(rrm_oam_ac_barring_factor_et)lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->AC_BARRING_FOR_MO_DATA,"AC_BARRING_TIME"));
            /* coverity 35794 */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.access_barring_info.
                ac_barring_for_mo_data.ac_barring_time=(rrm_oam_ac_barring_time_et)lclTemp_value;

            lclTemp_value2=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->AC_BARRING_FOR_MO_DATA, "AC_BARRING_FOR_SPECIAL_AC"));
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.access_barring_info.
                ac_barring_for_mo_data.ac_barring_for_special_ac=lclTemp_value2;
            /* BITSTRING CHANGES START */
            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.access_barring_info.
                ac_barring_for_mo_data.ac_barring_for_special_ac <<= OAM_THREE;
            /* BITSTRING CHANGES END */

            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.
                access_barring_info.bitmask |= RRM_OAM_AC_BARRING_MO_DATA_PRESENT;

            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.
                access_barring_info.ssac_barring_r9.bitmask |= RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT;

            p_rrm_cellconfig->operator_info.
                sib_2_info.radio_res_config_common_sib.
                bitmask |= RRM_OAM_BARRING_INFO_PRESENT;

        }
        /* SPR 17222 FIX START */
    }
    else
    {
        OAM_LOG(OAM,OAM_INFO,"AC_BARRING_FOR_MO_DATA Tag is not present");
    }
    /* SPR 17222 FIX END */

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SSAC_BARRING_FOR_MMTEL_VOICE_R9,
                    "AC_BARRING_FACTOR"),OAM_INVALID_STR)!= OAM_ZERO))
    { 
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SSAC_BARRING_FOR_MMTEL_VOICE_R9, "AC_BARRING_FACTOR"));
        /* coverity 35834 */
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_factor=(rrm_oam_ac_barring_factor_et)lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SSAC_BARRING_FOR_MMTEL_VOICE_R9, "AC_BARRING_TIME"));
        /* coverity 35835 */
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_time=(rrm_oam_ac_barring_time_et)lclTemp_value;

        lclTemp_value2=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SSAC_BARRING_FOR_MMTEL_VOICE_R9, "AC_BARRING_FOR_SPECIAL_AC"));
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac=lclTemp_value2;

        /* BITSTRING CHANGES START */
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac <<= OAM_THREE;
        /* BITSTRING CHANGES END */
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            bitmask |= RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT;

        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.
            access_barring_info.ssac_barring_r9.bitmask |= RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT;

        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.
            bitmask |= RRM_OAM_BARRING_INFO_PRESENT;

    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->SSAC_BARRING_FOR_MMTEL_VIDEO_R9,
                    "AC_BARRING_FACTOR"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SSAC_BARRING_FOR_MMTEL_VIDEO_R9, "AC_BARRING_FACTOR"));
        /* coverity 35832*/
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_factor=(rrm_oam_ac_barring_factor_et)lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SSAC_BARRING_FOR_MMTEL_VIDEO_R9, "AC_BARRING_TIME"));
        /* coverity 35833 */
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_time=(rrm_oam_ac_barring_time_et)lclTemp_value;

        lclTemp_value2=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->SSAC_BARRING_FOR_MMTEL_VIDEO_R9, "AC_BARRING_FOR_SPECIAL_AC"));
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac=lclTemp_value2;

        /* BITSTRING CHANGES START */
        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac <<= OAM_THREE;
        /* BITSTRING CHANGES END */

        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.access_barring_info.
            bitmask |= RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT;

        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.
            access_barring_info.ssac_barring_r9.bitmask |= RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT;

        p_rrm_cellconfig->operator_info.
            sib_2_info.radio_res_config_common_sib.
            bitmask |= RRM_OAM_BARRING_INFO_PRESENT;


    }


    /* SPR 12920 Fix Start */
    lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq,"X_VENDOR_ALLOWED_MEASUREMENT_BW"),MeasBandwidth,RRM_OAM_BW_MEAS_COUNT);
    /* SPR 12920 Fix End */
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_ALLOWED_MEASUREMENT_BW 
         && 
         lclTemp_value <= MAX_RRM_CELL_ALLOWED_MEASUREMENT_BW
        )
        {
            /* coverity 35671 */
            p_rrm_cellconfig->operator_info.
                sib_3_info.intra_freq_reselection_info.
                measurement_bandwidth=(rrm_oam_measurement_bandwidth_et)lclTemp_value;
            p_rrm_cellconfig->
                operator_info.sib_3_info.intra_freq_reselection_info.
                bitmask |= RRM_OAM_MEAS_BW_PRESENT;
        }
    else
    {  if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,
                    "X_VENDOR_ALLOWED_MEASUREMENT_BW"),OAM_INVALID_STR)!= OAM_ZERO)
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of X_VENDOR_ALLOWED_MEASUREMENT_BW is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_CELL_ALLOWED_MEASUREMENT_BW,
                MAX_RRM_CELL_ALLOWED_MEASUREMENT_BW);

        return OAM_FAILURE;
    }
    }
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->IntraFreq, "X_VENDOR_PRESENCE_ANTENNA_PORT1"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_PRESENCE_ANTENNA_PORT1 
         && 
         lclTemp_value <= MAX_RRM_CELL_PRESENCE_ANTENNA_PORT1
        )
        {       
            p_rrm_cellconfig->operator_info.
                sib_3_info.intra_freq_reselection_info.
                presence_antenna_port1=lclTemp_value;
        }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of X_VENDOR_PRESENCE_ANTENNA_PORT1 is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_CELL_PRESENCE_ANTENNA_PORT1,
                MAX_RRM_CELL_PRESENCE_ANTENNA_PORT1);   

        return OAM_FAILURE;
    }   

    SInt8 s_intra_search_p_r9 = OAM_ZERO,
          s_intra_search_q_r9 = OAM_ZERO;

    s_intra_search_p_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq, "X_VENDOR_S_INTRA_SEARCH_P_R9"),OAM_INVALID_STR);
    s_intra_search_q_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq, "X_VENDOR_S_INTRA_SEARCH_Q_R9"),OAM_INVALID_STR);

    if((s_intra_search_p_r9 != OAM_ZERO)
            && (s_intra_search_q_r9 != OAM_ZERO)
      )		
    {	
        p_rrm_cellconfig->
            operator_info.sib_3_info.
            bitmask |= RRM_OAM_S_INTRA_SEARCH_V920_PRESENT;
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq, "X_VENDOR_S_INTRA_SEARCH_P_R9"));
        if 
            (
             lclTemp_value >= MIN_RRM_CELL_S_INTRA_SEARCH_P_R9 
             && 
             lclTemp_value <= MAX_RRM_CELL_S_INTRA_SEARCH_P_R9
            )
            {   
                p_rrm_cellconfig->operator_info.
                    sib_3_info.s_intra_search.s_intra_search_p_r9=lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_S_INTRA_SEARCH_P_R9 is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_S_INTRA_SEARCH_P_R9,
                    MAX_RRM_CELL_S_INTRA_SEARCH_P_R9);  

            return OAM_FAILURE;
        }   
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq, "X_VENDOR_S_INTRA_SEARCH_Q_R9"));
        if 
            (
             lclTemp_value >= MIN_RRM_CELL_S_INTRA_SEARCH_Q_R9 
             && 
             lclTemp_value <= MAX_RRM_CELL_S_INTRA_SEARCH_Q_R9
            )
            {   
                p_rrm_cellconfig->operator_info.
                    sib_3_info.s_intra_search.s_intra_search_q_r9=lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_S_INTRA_SEARCH_P_R9 is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_S_INTRA_SEARCH_Q_R9,
                    MAX_RRM_CELL_S_INTRA_SEARCH_Q_R9);  

            return OAM_FAILURE;
        }   
    }

    SInt8 s_non_intra_search_p_r9 = OAM_ZERO,
          s_non_intra_search_q_r9 = OAM_ZERO;

    s_non_intra_search_p_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2, "X_VENDOR_S_NON_INTRA_SEARCH_P_R9"),OAM_INVALID_STR);
    s_non_intra_search_q_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Common_2, "X_VENDOR_S_NON_INTRA_SEARCH_Q_R9"),OAM_INVALID_STR);

    if((s_non_intra_search_p_r9 != OAM_ZERO)
            && (s_non_intra_search_q_r9 != OAM_ZERO)
      )
    {
        p_rrm_cellconfig->
            operator_info.sib_3_info.
            bitmask |= RRM_OAM_S_NON_INTRA_SEARCH_V920_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Common_2, "X_VENDOR_S_NON_INTRA_SEARCH_P_R9"));

        if 
            (
             lclTemp_value >= MIN_RRM_CELL_S_NON_INTRA_SEARCH_P_R9 
             && 
             lclTemp_value <= MAX_RRM_CELL_S_NON_INTRA_SEARCH_P_R9
            )
            {		
                p_rrm_cellconfig->operator_info.
                    sib_3_info.s_non_intra_search.s_non_intra_search_p_r9=lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_S_NON_INTRA_SEARCH_P_R9 is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_S_NON_INTRA_SEARCH_P_R9,
                    MAX_RRM_CELL_S_NON_INTRA_SEARCH_P_R9);	

            return OAM_FAILURE;
        }	
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Common_2, "X_VENDOR_S_NON_INTRA_SEARCH_Q_R9"));

        if 
            (
             lclTemp_value >= MIN_RRM_CELL_S_NON_INTRA_SEARCH_Q_R9 
             &&
             lclTemp_value <= MAX_RRM_CELL_S_NON_INTRA_SEARCH_Q_R9
            )
            {	
                p_rrm_cellconfig->operator_info.
                    sib_3_info.s_non_intra_search.s_non_intra_search_q_r9=lclTemp_value;
            }
        else
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_S_NON_INTRA_SEARCH_Q_R9 is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_S_NON_INTRA_SEARCH_Q_R9,
                    MAX_RRM_CELL_S_NON_INTRA_SEARCH_Q_R9);	

            return OAM_FAILURE;
        }	
    }	
    if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq, "X_VENDOR_Q_QUAL_MIN_R9"),OAM_INVALID_STR)!= OAM_ZERO)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq, "X_VENDOR_Q_QUAL_MIN_R9"));
        if 
            (
             lclTemp_value >= MIN_RRM_CELL_Q_QUAL_MIN_R9 
             && 
             lclTemp_value <= MAX_RRM_CELL_Q_QUAL_MIN_R9
            )
            {   
                p_rrm_cellconfig->operator_info.
                    sib_3_info.q_qual_min_r9=lclTemp_value;
                p_rrm_cellconfig->operator_info.
                    sib_3_info.bitmask |= RRM_OAM_Q_QUAL_MIN_R9_PRESENT1;
            } 
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_Q_QUAL_MIN_R9 is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_Q_QUAL_MIN_R9,MAX_RRM_CELL_Q_QUAL_MIN_R9);   
            return OAM_FAILURE;
        }
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->Common_2, "X_VENDOR_THRESH_SERVING_LOWQ_R9"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_THRESH_SERVING_LOWQ_R9
         && 
         lclTemp_value <= MAX_RRM_CELL_THRESH_SERVING_LOWQ_R9
        )
        {
            p_rrm_cellconfig->operator_info.
                sib_3_info.thresh_serving_lowq_r9=lclTemp_value;
            p_rrm_cellconfig->operator_info.
                sib_3_info.bitmask |= RRM_OAM_THRESHOLD_SERVING_LOW_PRESENT;
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->Common_2, "X_VENDOR_THRESH_SERVING_LOWQ_R9"),
                    OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_THRESH_SERVING_LOWQ_R9 is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_THRESH_SERVING_LOWQ_R9,
                    MAX_RRM_CELL_THRESH_SERVING_LOWQ_R9);	

            return OAM_FAILURE;
        }
    }


    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                    "X_VENDOR_CSG_PHY_CELLID_RANGE"),OAM_INVALID_STR)!= OAM_ZERO) 
      )	
    {
        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_ADDL_SIB4_INFO_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq, "X_VENDOR_CSG_PHY_CELLID_START"));
        if 
            (
             lclTemp_value >= MIN_RRM_CELL_PHY_CELL_ID_START
             && 
             lclTemp_value <= MAX_RRM_CELL_PHY_CELL_ID_START
            )
            { 
                p_rrm_cellconfig->operator_info.
                    sib_4_info.csg_id_range.start=lclTemp_value;
            }
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_CSG_PHY_CELLID_START is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_PHY_CELL_ID_START,
                    MAX_RRM_CELL_PHY_CELL_ID_START);	

            return OAM_FAILURE;
        } 

        p_rrm_cellconfig->operator_info.
            sib_4_info.csg_id_range.bitmask |= RRM_OAM_CELL_ID_RANGE_PRESENT;

        /* SPR 12920 Fix Start */
        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_CSG_PHY_CELLID_RANGE"),PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);
        /* SPR 12920 Fix End */
        if 
            (
             lclTemp_value >= MIN_RRM_CELL_PHY_CELL_ID_RANGE 
             && 
             lclTemp_value <= MAX_RRM_CELL_PHY_CELL_ID_RANGE
            )
            {
                /* coverity 35831 */
                p_rrm_cellconfig->operator_info.
                    sib_4_info.csg_id_range.range=(rrm_oam_cell_id_range_et)lclTemp_value;
            }
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of X_VENDOR_CSG_PHY_CELLID_RANGE is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_PHY_CELL_ID_RANGE,
                    MAX_RRM_CELL_PHY_CELL_ID_RANGE);	

            return OAM_FAILURE;
        }  
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"max_num_gbr_drbs_per_ue"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_MAX_NUM_GBR_DRBS_PER_UE 
         && 
         lclTemp_value <= MAX_RRM_CELL_MAX_NUM_GBR_DRBS_PER_UE
        )
        {  
            p_rrm_cellconfig->operator_info.
                admission_control_info.max_num_gbr_drbs_per_ue=lclTemp_value;
            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_MAX_NUM_GBR_DRBS_PER_UE_PRESENT;
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,
                        "max_num_gbr_drbs_per_ue"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of max_num_gbr_drbs_per_ue is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_MAX_NUM_GBR_DRBS_PER_UE,
                    MAX_RRM_CELL_MAX_NUM_GBR_DRBS_PER_UE);

            return OAM_FAILURE;
        }
    }   




    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"max_num_non_gbr_drbs_per_ue"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_MAX_NUM_NON_GBR_DRBS_PER_UE
         && 
         lclTemp_value <= MAX_RRM_CELL_MAX_NUM_NON_GBR_DRBS_PER_UE
        )
        {  
            p_rrm_cellconfig->operator_info.
                admission_control_info.max_num_non_gbr_drbs_per_ue=lclTemp_value;
            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_MAX_NUM_NGBR_DRBS_PER_UE_PRESENT; 
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,
                        "max_num_non_gbr_drbs_per_ue"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of max_num_non_gbr_drbs_per_ue is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_MAX_NUM_NON_GBR_DRBS_PER_UE,
                    MAX_RRM_CELL_MAX_NUM_NON_GBR_DRBS_PER_UE);		

            return OAM_FAILURE;
        }    
    }	


    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"total_backhaul_capacity"));
    if
        (
         lclTemp_value >= MIN_TOTAL_BACKHAUL_CAPACITY 
         &&
         lclTemp_value <= MAX_TOTAL_BACKHAUL_CAPACITY
        )
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.total_backhaul_capacity=lclTemp_value;
        }
    else
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,
                        "total_backhaul_capacity"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of total_backhaul_capacity is %d and range is from %d to %d",
                    lclTemp_value,MIN_TOTAL_BACKHAUL_CAPACITY,
                    MAX_TOTAL_BACKHAUL_CAPACITY);

            return OAM_FAILURE;
        }
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"capacity_threshold"));
    if
        (
         lclTemp_value >= MIN_CAPACITY_THRESHOLD 
         &&
         lclTemp_value <= MAX_CAPACITY_THRESHOLD
        )
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.capacity_threshold=lclTemp_value;
        }
    else
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,
                        "capacity_threshold"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of capacity_threshold is %d and range is from %d to %d",
                    lclTemp_value,MIN_CAPACITY_THRESHOLD,
                    MAX_CAPACITY_THRESHOLD);

            return OAM_FAILURE;
        }
    }

    /*SPR 12926 Fix start*/
    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"DLBandwidth"),DLBandwidth_MAP,DL_BANDWIDTH_COUNT);

    p_rrm_cellconfig->operator_info.
        admission_control_info.dl_prb_budget=lclTemp_value;
    p_rrm_cellconfig->operator_info.
        admission_control_info.bitmask |= RRM_OAM_MAX_TOTAL_DL_PRB_BUDGET;

    /* SPR 13654 REVIEW COMMENTS FIX START */
    tag_value = oam_get_xml_text_node_content(p_cell_spec_params->RF_1,
            "ULBandwidth", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);
    if(tag_value) {
        lclTemp_value = oam_xml_search_string_to_integer(buf,
                ULBandwidth_MAP,
                /* SPR 13654 FIX START */
                UL_BANDWIDTH_COUNT);
        /* SPR 13654 FIX END */

        p_rrm_cellconfig->operator_info.
            admission_control_info.ul_prb_budget = lclTemp_value;
        p_rrm_cellconfig->operator_info.
            admission_control_info.bitmask |= RRM_OAM_MAX_TOTAL_UL_PRB_BUDGET;
    }
    /* SPR 13654 REVIEW COMMENTS FIX END */

    /*SPR 12926 Fix end*/
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"dl_prb_budget_gbr"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_DL_PRB_BUDGET_GBR 
         && 
         lclTemp_value <= MAX_RRM_CELL_DL_PRB_BUDGET_GBR
        )
        {  
            p_rrm_cellconfig->operator_info.
                admission_control_info.dl_prb_budget_gbr=lclTemp_value;
            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_MAX_TOTAL_DL_GBR_PRB_BUDGET;
            /* SPR-18198 START */
            dl_prb_budget_gbr = (UInt8)lclTemp_value;
            /* SPR-18198 END */

        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,
                        "dl_prb_budget_gbr"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of dl_prb_budget_gbr is %d and range is from %d to %d",
                    lclTemp_value,
                    MIN_RRM_CELL_DL_PRB_BUDGET_GBR,
                    MAX_RRM_CELL_DL_PRB_BUDGET_GBR);		

            return OAM_FAILURE;
        } 
    }  

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"ul_prb_budget_gbr"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_UL_PRB_BUDGET_GBR
         && 
         lclTemp_value <= MAX_RRM_CELL_UL_PRB_BUDGET_GBR
        )
        {   
            p_rrm_cellconfig->operator_info.
                admission_control_info.ul_prb_budget_gbr=lclTemp_value;
            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_MAX_TOTAL_UL_GBR_PRB_BUDGET;
            /* SPR-18198 START */
            ul_prb_budget_gbr = (UInt8)lclTemp_value;
            /* SPR-18198 END */

        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,
                        "ul_prb_budget_gbr"),OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of ul_prb_budget_gbr is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_UL_PRB_BUDGET_GBR,
                    MAX_RRM_CELL_UL_PRB_BUDGET_GBR);

            return OAM_FAILURE;
        } 
    }  

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"dl_prb_budget_ngbr"));
    if 
        (
         lclTemp_value >= MIN_RRM_CELL_DL_PRB_BUDGET_NGBR 
         && 
         lclTemp_value <= MAX_RRM_CELL_DL_PRB_BUDGET_NGBR
        )
        { 
            p_rrm_cellconfig->operator_info.
                admission_control_info.dl_prb_budget_ngbr=lclTemp_value;
            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |= RRM_OAM_MAX_TOTAL_DL_NGBR_PRB_BUDGET;
            /* SPR-18198 START */
            dl_prb_budget_ngbr = (UInt8)lclTemp_value;
            /* SPR-18198 END */
        }
    else 
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,"dl_prb_budget_ngbr"),
                    OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of dl_prb_budget_ngbr is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_DL_PRB_BUDGET_NGBR,
                    MAX_RRM_CELL_DL_PRB_BUDGET_NGBR);

            return OAM_FAILURE;
        } 
    }   

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"ul_prb_budget_ngbr"));
    if
        (
         lclTemp_value >= MIN_RRM_CELL_UL_PRB_BUDGET_NGBR 
         && 
         lclTemp_value <= MAX_RRM_CELL_UL_PRB_BUDGET_NGBR
        ) 
        {  
            p_rrm_cellconfig->operator_info.
                admission_control_info.ul_prb_budget_ngbr=lclTemp_value;

            p_rrm_cellconfig->operator_info.admission_control_info.
                bitmask |= RRM_OAM_MAX_TOTAL_UL_NGBR_PRB_BUDGET;
            /* SPR-18198 START */
            ul_prb_budget_ngbr = (UInt8)lclTemp_value;
            /* SPR-18198 END */
        }
    else {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,"ul_prb_budget_ngbr"),
                    OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of ul_prb_budget_ngbr is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_UL_PRB_BUDGET_NGBR,
                    MAX_RRM_CELL_UL_PRB_BUDGET_NGBR);

            return OAM_FAILURE;
        } 
    } 

    /* SPR-18198 START */
    if((ul_prb_budget_ngbr + ul_prb_budget_gbr) > MAX_RRM_CELL_UL_PRB_BUDGET_NGBR_GBR)
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of ul_prb_budget_ngbr + ul_prb_budget_gbr should not exceed %d",
                MAX_RRM_CELL_UL_PRB_BUDGET_NGBR_GBR);

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    if((dl_prb_budget_ngbr + dl_prb_budget_gbr) > MAX_RRM_CELL_DL_PRB_BUDGET_NGBR_GBR)
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Value of dl_prb_budget_ngbr + dl_prb_budget_gbr should not exceed %d",
                MAX_RRM_CELL_DL_PRB_BUDGET_NGBR_GBR);

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    /* SPR-18198 END */

    /*SPR 18654 START*/
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"dl_bw_for_control_prbs"));
    if
        (
         lclTemp_value >= MIN_RRM_CELL_DL_BW_FOR_CONTROL_PRBS
         &&
         lclTemp_value <= MAX_RRM_CELL_DL_BW_FOR_CONTROL_PRBS
        )
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.dl_bw_for_control_prbs=(UInt8 )lclTemp_value;
        }
    else
    {
        if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->admission_control_info,"dl_bw_for_control_prbs"),
                    OAM_INVALID_STR)!= OAM_ZERO)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of dl_bw_for_control_prbs is %d and it should be between %d and %d ",
                    lclTemp_value,MIN_RRM_CELL_DL_BW_FOR_CONTROL_PRBS,MAX_RRM_CELL_DL_BW_FOR_CONTROL_PRBS);

            return OAM_FAILURE;
        }
    }
    /* Coverity 54885 Fix Start */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_prop_cellconfig->admission_control_info,"rb_factor_for_bitrate"));
    /* Coverity 54885 Fix End */
    if
        (
         lclTemp_value >= MIN_RRM_CELL_RB_FACTOR_FOR_BITRATE
         &&
         lclTemp_value <= MAX_RRM_CELL_RB_FACTOR_FOR_BITRATE
        )
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.rb_factor_for_bitrate=(UInt16 )lclTemp_value;
        }else
        {
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                            p_prop_cellconfig->admission_control_info,"rb_factor_for_bitrate"),
                        OAM_INVALID_STR)!= OAM_ZERO)
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of rb_factor_for_bitrate is %d and it should be greater than or equal to %d",
                        lclTemp_value,MIN_RRM_CELL_RB_FACTOR_FOR_BITRATE);

                return OAM_FAILURE;
            }
        }
        /*SPR 18654 END*/



        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->available_gbr_limit,"dl_gbr_limit"));
        if(lclTemp_value >= MIN_GBR_LIMIT  && 
                lclTemp_value <= MAX_GBR_LIMIT)
        {
            p_rrm_cellconfig->operator_info.
                admission_control_info.available_gbr_limit.dl_gbr_limit=lclTemp_value;
            p_rrm_cellconfig->operator_info.
                admission_control_info.bitmask |=
                RRM_OAM_AVAILABLE_GBR_LIMIT_PRESENT;
        }
        else 
        {
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                            p_prop_cellconfig->available_gbr_limit,"dl_gbr_limit"),
                        OAM_INVALID_STR)!= OAM_ZERO)
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of dl_gbr_limit is %d and range is from %d to %d",
                        lclTemp_value,MIN_GBR_LIMIT,
                        MAX_GBR_LIMIT);

                return OAM_FAILURE;
            }
        }


        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->available_gbr_limit,"ul_gbr_limit"));
        if
            (
             lclTemp_value >= MIN_GBR_LIMIT 
             && 
             lclTemp_value <= MAX_GBR_LIMIT
            ) 
            {
                p_rrm_cellconfig->operator_info.
                    admission_control_info.available_gbr_limit.ul_gbr_limit=lclTemp_value;
                p_rrm_cellconfig->operator_info.
                    admission_control_info.bitmask |=
                    RRM_OAM_AVAILABLE_GBR_LIMIT_PRESENT;
            }
        else
        {
            if(oam_strcmp((const char *)oam_xmlNodeGetContent(
                            p_prop_cellconfig->available_gbr_limit,"ul_gbr_limit"),
                        OAM_INVALID_STR)!= OAM_ZERO)
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of ul_gbr_limit is %d and range is from %d to %d",
                        lclTemp_value,MIN_GBR_LIMIT,
                        MAX_GBR_LIMIT);

                return OAM_FAILURE;
            }
        }

        /* Dynamic UE Scheduling Start  */
        SInt8 max_ue_scheduled_dl = OAM_ZERO,
              max_ue_scheduled_ul = OAM_ZERO;

        max_ue_scheduled_dl = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->rrm_ue_scheduling_info,"max_ue_scheduled_dl"),      OAM_INVALID_STR);
        max_ue_scheduled_ul = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->rrm_ue_scheduling_info,"max_ue_scheduled_ul"),      OAM_INVALID_STR);


        if((max_ue_scheduled_dl != OAM_ZERO)
                && (max_ue_scheduled_ul != OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                bitmask |= RRM_OAM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT;

            p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT;

            SInt8 ue_scheduling_hysteresis = OAM_ZERO;

            ue_scheduling_hysteresis = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->rrm_ue_scheduling_info,"ue_scheduling_hysteresis"),OAM_INVALID_STR);


            if(ue_scheduling_hysteresis != OAM_ZERO)
            {

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_prop_cellconfig->rrm_ue_scheduling_info,"ue_scheduling_hysteresis"));
                if(lclTemp_value >= MIN_UE_SCHEDULING_HYSTERESIS &&
                        lclTemp_value <= MAX_UE_SCHEDULING_HYSTERESIS) {
                    p_rrm_cellconfig->operator_info.
                        rrm_ue_scheduling_info.bitmask |= RRM_OAM_UE_SCHEDULING_HYSTERESIS_PRESENT;

                    p_rrm_cellconfig->operator_info.
                        rrm_ue_scheduling_info.ue_scheduling_hysteresis = lclTemp_value;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Value of ue_scheduling_hysteresis is %d and range is from %d to %d",
                            lclTemp_value,MIN_UE_SCHEDULING_HYSTERESIS,MAX_UE_SCHEDULING_HYSTERESIS);

                    return OAM_FAILURE;
                }
            }
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->rrm_ue_scheduling_info,"max_ue_scheduled_dl"));
            if(lclTemp_value >= MIN_UE_SCHEDULED_DL &&
                    lclTemp_value <= MAX_UE_SCHEDULED_DL) {
                p_rrm_cellconfig->operator_info.
                    rrm_ue_scheduling_info.max_ue_scheduled_dl = lclTemp_value;
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of max_ue_scheduled_dl is %d and range is from %d to %d",
                        lclTemp_value,MIN_UE_SCHEDULED_DL,MAX_UE_SCHEDULED_DL);

                return OAM_FAILURE;
            }

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->rrm_ue_scheduling_info,"max_ue_scheduled_ul"));
            if(lclTemp_value >= MIN_MAX_UE_SCHEDULED_UL &&
                    lclTemp_value <= MAX_MAX_UE_SCHEDULED_UL) {
                p_rrm_cellconfig->operator_info.
                    rrm_ue_scheduling_info.max_ue_scheduled_ul = lclTemp_value;
            } 
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Value of max_ue_scheduled_ul is %d and range is from %d to %d",
                        lclTemp_value,MIN_MAX_UE_SCHEDULED_UL,MAX_MAX_UE_SCHEDULED_UL);

                return OAM_FAILURE;
            }
            /* SPR 20653 Fix Start */
            SInt8 active_ue_reports_timer = OAM_ZERO;

            active_ue_reports_timer = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->rrm_ue_scheduling_info,"active_ue_reports_timer"),OAM_INVALID_STR);

            if(active_ue_reports_timer != OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_prop_cellconfig->rrm_ue_scheduling_info,"active_ue_reports_timer"));
                if(lclTemp_value >= MIN_ACTIVE_UE_REPORTS_TIMER &&
                        lclTemp_value <= MAX_ACTIVE_UE_REPORTS_TIMER) {
                    p_rrm_cellconfig->operator_info.
                        rrm_ue_scheduling_info.bitmask |= RRM_OAM_ACTIVE_UE_REPORTS_TIMER_PRESENT;

                    p_rrm_cellconfig->operator_info.
                        rrm_ue_scheduling_info.active_ue_reports_timer = lclTemp_value;
                }
                else {
				OAM_LOG(OAM, OAM_WARNING,
						"Value of active_ue_reports_timer is %d and range is from %d to %d",
                            lclTemp_value,MIN_ACTIVE_UE_REPORTS_TIMER,MAX_ACTIVE_UE_REPORTS_TIMER);

                    return OAM_FAILURE;
                }
            }
            /* SPR 20653 Fix End */
        }

        SInt8 rrm_enable_cqi_mask_r9 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->scheduler_Params,"rrm_enable_cqi_mask_r9"),OAM_INVALID_STR);
        if((rrm_enable_cqi_mask_r9 != OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->scheduler_Params,"rrm_enable_cqi_mask_r9"));
            p_rrm_cellconfig->operator_info.rrm_enable_cqi_mask_r9 = lclTemp_value;
            p_rrm_cellconfig->operator_info.bitmask |=RRM_OAM_ENABLE_CQI_MASK_R9_PRESENT;
        }
        /* Dynamic UE Scheduling End    */

        /* SPR 13768 Changes Start */
        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->MAC_Params,"dl_num_harq_process"));

        if (lclTemp_value >= MIN_DL_NUM_HARQ_PROCESS &&
                lclTemp_value <= MAX_DL_NUM_HARQ_PROCESS) 
        {
            p_rrm_cellconfig->ran_info.
                mac_layer_params.dl_num_harq_process = lclTemp_value;
        }
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of dl_num_harq_process %d and range is from %d to %d",
                    lclTemp_value,MIN_DL_NUM_HARQ_PROCESS,MAX_DL_NUM_HARQ_PROCESS);

            return OAM_FAILURE;
        }
        /* SPR 13768 Changes End */
        /* SPR 19309 + */
        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->MAC_Params,"cfi_value"));

        if (lclTemp_value >= MIN_POSSIBLE_CFI_VALUE &&
                lclTemp_value <= MAX_POSSIBLE_CFI_VALUE) 
        {
            p_rrm_cellconfig->ran_info.
                mac_layer_params.cfi_value = (UInt8)lclTemp_value;
            OAM_LOG(OAM, OAM_INFO,
                    "Value of cfi_value is %u ",
                    lclTemp_value);
        }
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of cfi_value %u and range is from %u to %u",
                    lclTemp_value,MIN_POSSIBLE_CFI_VALUE,MAX_POSSIBLE_CFI_VALUE);

            return OAM_FAILURE;
        }
        /* SPR 19309 - */
        /* SPR 19310 + */
        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->MAC_Params,"num_of_eul"));
        if (lclTemp_value >= MIN_POSSIBLE_EUL_VALUE &&
                lclTemp_value <= MAX_POSSIBLE_EUL_VALUE) 
        {
            p_rrm_cellconfig->ran_info.
                mac_layer_params.num_of_eul = (UInt16)lclTemp_value;

            OAM_LOG(OAM, OAM_INFO,
                    "Value of num_of_eul is %u ",
                    lclTemp_value);
        }
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of num_of_eul %u and range is from %u to %u",
                    lclTemp_value,MIN_POSSIBLE_EUL_VALUE,MAX_POSSIBLE_EUL_VALUE);

            return OAM_FAILURE;
        }

        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_prop_cellconfig->MAC_Params,"size_of_eul"));

        if (lclTemp_value >= MIN_POSSIBLE_EUL_VALUE &&
                lclTemp_value <= MAX_POSSIBLE_EUL_VALUE) 
        {
            p_rrm_cellconfig->ran_info.
                mac_layer_params.size_of_eul = (UInt16)lclTemp_value;

            OAM_LOG(OAM, OAM_INFO,
                    "Value of size_of_eul is %u ",
                    lclTemp_value);
        }
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of size_of_eul %u and range is from %u to %u",
                    lclTemp_value,MIN_POSSIBLE_EUL_VALUE,MAX_POSSIBLE_EUL_VALUE);

            return OAM_FAILURE;
        }
        /* SPR 20653 Fix Start */
        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.RRMparams,"mac_ecid_meas_start_sfn"));

        if (lclTemp_value >= MIN_MAC_ECID_MEAS_START_SFN &&
                lclTemp_value <= MAX_MAC_ECID_MEAS_START_SFN) 
        {
            p_rrm_cellconfig->ran_info.
                mac_layer_params.bitmask |= RRM_OAM_MAC_ECID_MEAS_START_SFN_PRESENT;
            p_rrm_cellconfig->ran_info.
                mac_layer_params.mac_ecid_meas_start_sfn = (UInt8)lclTemp_value;

            OAM_LOG(OAM, OAM_INFO,
                    "Value of mac_ecid_meas_start_sfn is %u ",
                    lclTemp_value);
        }
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of mac_ecid_meas_start_sfn %u and range is from %u to %u",
                    lclTemp_value,MIN_MAC_ECID_MEAS_START_SFN,MAX_MAC_ECID_MEAS_START_SFN);

            return OAM_FAILURE;
        }
        /* SPR 20653 Fix End */
        /* SPR 19310 - */
        /* SPR-13976 START */

        /* spr_21013_fix_start */
        p_access_mgmt_lte_xml_node = xml_struct_tr196_g.FAPService[cell_index].LTE_3;
        tag_name_1 = "AccessMode";
        tag_name_2 = "CSGID";
        tag_name_3 = "MaxCSGMembers";
        tag_name_4 = "MaxNonCSGMembers";
        tag_name_5 = "MaxUEsServed";
        /* spr_21013_fix_end */


        tag_value = oam_get_xml_text_node_content(p_access_mgmt_lte_xml_node,
                tag_name_1, buf,
                OAM_TAG_VALUE_STR_MAX_LEN);
        if(tag_value) {
            lclTemp_value =
                oam_xml_search_string_to_integer(buf,
                        access_mode_str_enum_tbl,
                        ACCESS_MODE_COUNT);
            p_rrm_cellconfig->access_mgmt_params.access_mode =
                (rrm_oam_access_mode_et)lclTemp_value;

            p_rrm_cellconfig->bitmask |= RRM_OAM_ACCESS_MGMT_PARAMS_PRESENT;

            /* SPR 12447 Fix Start */
            tag_value =
                oam_get_xml_text_node_content(p_access_mgmt_lte_xml_node,
                        tag_name_2, buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);

            if(tag_value) {
                lclTemp_value = oam_atoi(buf);

                /* BITSTRING FIX START */
                oam_conversion_from_int_to_byte_string(
                        p_rrm_cellconfig->access_mgmt_params.csg_id,
                        lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                /* BITSTRING FIX START */

                p_rrm_cellconfig->access_mgmt_params.
                    bitmask |= RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT;
            }
            /* SPR 12447 Fix End*/


            /*SPR 21176 FIXED START*/
            if((S32)RRM_OAM_ACCESS_MODE_OPEN != p_rrm_cellconfig->access_mgmt_params.
                    access_mode) {
                /*SPR 21176 FIXED END*/  
                tag_value =
                    oam_get_xml_text_node_content(p_access_mgmt_lte_xml_node,
                            tag_name_3, buf,
                            OAM_TAG_VALUE_STR_MAX_LEN);

                if(tag_value) {
                    lclTemp_value = oam_atoi(buf);
                    p_rrm_cellconfig->access_mgmt_params.
                        max_csg_members = lclTemp_value;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Failed to read mandatory parameter MaxCSGMembers");

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
                /*SPR 21176 FIXED START*/
                /* SPR 12447 Fix Start */
                if((S32)RRM_OAM_ACCESS_MODE_HYBRID == p_rrm_cellconfig->access_mgmt_params.access_mode)
                {
                    /* SPR 12447 Fix End*/
                    /*SPR 21176 FIXED END*/
                    tag_value =
                        oam_get_xml_text_node_content(p_access_mgmt_lte_xml_node,
                                tag_name_4, buf,
                                OAM_TAG_VALUE_STR_MAX_LEN);

                    if(tag_value) {
                        lclTemp_value = oam_atoi(buf);
                        p_rrm_cellconfig->access_mgmt_params.
                            max_non_csg_members = lclTemp_value;
                    }
                    else {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Failed to read mandatory parameter MaxNonCSGMembers");

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;

                    }
                }
            }
            /* SPR 12447 Fix Start */
            /*SPR 21176 FIXED START*/
            else if((S32)RRM_OAM_ACCESS_MODE_OPEN == p_rrm_cellconfig->access_mgmt_params.
                    access_mode) {
                /*SPR 21176 FIXED START*/    
                if(p_rrm_cellconfig->access_mgmt_params.
                        bitmask & RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT)
                {
                    OAM_LOG(OAM,OAM_WARNING,
                            "Access Mode is Open Access and CSG ID is present invalid Configuration");
                    oam_handle_invalid_startup_config();
                }
            }
            /* SPR 12447 Fix End*/
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Failed to read mandatory parameter AccessMode");

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        tag_value = oam_get_xml_text_node_content(p_access_mgmt_lte_xml_node,
                tag_name_5, buf,
                OAM_TAG_VALUE_STR_MAX_LEN);

        /* SPR-13976 END */
        if(tag_value) {
            lclTemp_value = oam_atoi(buf);
            p_rrm_cellconfig->operator_info.admission_control_info.
                max_num_ue_per_cell = lclTemp_value;

            p_rrm_cellconfig->operator_info.admission_control_info.
                bitmask |= RRM_OAM_MAX_NUM_UE_PER_CELL_PRESENT;
            OAM_LOG(OAM, OAM_INFO, "Value of RRM MaxUEsServed is %d",
                    lclTemp_value);
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Failed to read mandatory parameter MaxUEsServed");

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }




        if (1 == oam_prov_req.num_cells_configured) {
            /* spr_21013_fix_start */
            tag_value = oam_get_xml_text_node_content(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3,
                    /* spr_21013_fix_end */
                    "HNBName", buf,
                    OAM_TAG_VALUE_STR_MAX_LEN);

            if(tag_value) {
                oam_strncpy((Char8*)p_rrm_cellconfig->access_mgmt_params.
                        hnb_name, buf, RRM_OAM_MAX_NUM_HNB_NAME_OCTETS);

                p_rrm_cellconfig->access_mgmt_params.
                    hnb_name_size = oam_strlen(buf);
            }
        }



        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.operator_info,"immediate_start_needed"));
        if(lclTemp_value >= MIN_RRM_CELL_IMMEDIATE_START_NEEDED && 
                lclTemp_value <= MAX_RRM_CELL_IMMEDIATE_START_NEEDED ) { 
            /* coverity 35683 */
            p_rrm_cellconfig->
                immediate_start_needed=(rrm_bool_et)lclTemp_value;
            /*BUG 1248 FIX START*************/
            cell_to_be_started_by_operator = p_rrm_cellconfig->immediate_start_needed;
            if(p_rrm_cellconfig->immediate_start_needed == RRM_TRUE)
                p_rrm_cellconfig->immediate_start_needed = RRM_FALSE;
            /*BUG 1248 FIX END*************/

        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Value of immediate_start_needed is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_CELL_IMMEDIATE_START_NEEDED,
                    MAX_RRM_CELL_IMMEDIATE_START_NEEDED);

            return OAM_FAILURE;
        }

#ifdef ENDC_ENABLED
        tagvalue=(Char8*)oam_xmlNodeGetContent(
                              xml_struct_g.EN_DC_Params,"ENDCEnabled");
        if(oam_strcmp(tagvalue, OAM_INVALID_STR))
        {
            lclTemp_value = oam_atoi(tagvalue);
            if(lclTemp_value)
            {
                p_rrm_cellconfig->operator_info.bitmask |= RRM_OAM_ENDC_INFO_PRESENT;
                p_rrm_cellconfig->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"is_MaSgnbAddition"));
                p_rrm_cellconfig->operator_info.endc_info.is_ma_sgnb_addition = lclTemp_value;
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"SgNBAmbrShare"));
                p_rrm_cellconfig->operator_info.endc_info.sgnb_ambr_share = lclTemp_value;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"minNumUEThruputReport"));
                p_rrm_cellconfig->operator_info.endc_info.min_num_ue_thp_report = lclTemp_value;
                temp = (Char8*)oam_xmlNodeGetContent(
                            p_cell_spec_params->endc_params,"X_VENDOR_MAX_MEAS_FREQ_SCG_NR");
                lclTemp_value = oam_atoi(temp);
                if ( ( lclTemp_value >= MIN_MAX_MEAS_FREQ_SCG_NR ) &&
                    ( lclTemp_value <= MAX_MAX_MEAS_FREQ_SCG_NR ))
                {
                    p_rrm_cellconfig->operator_info.endc_info.max_meas_freq_scg_nr = lclTemp_value;
                }
                else
                {
                    OAM_LOG(OAM,OAM_WARNING,
                            "Value of X_VENDOR_MAX_MEAS_FREQ_SCG_NR is %d and range is from %d to %d",
                            lclTemp_value,MIN_MAX_MEAS_FREQ_SCG_NR,
                            MAX_MAX_MEAS_FREQ_SCG_NR);

                    return OAM_FAILURE;
                }
  
                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->endc_params,"X_VENDOR_MAX_MEAS_ID_SCG_NR"));
                if ( ( lclTemp_value >= MIN_MAX_MEAS_ID_SCG_NR ) &&
                    ( lclTemp_value <= MAX_MAX_MEAS_ID_SCG_NR ))
                {
                    p_rrm_cellconfig->operator_info.endc_info.max_meas_id_scg_nr = lclTemp_value;
                }
                else
                {
                    OAM_LOG(OAM,OAM_WARNING,
                            "Value of X_VENDOR_MAX_MEAS_ID_SCG_NR is %d and range is from %d to %d",
                            lclTemp_value,MIN_MAX_MEAS_ID_SCG_NR,
                            MAX_MAX_MEAS_ID_SCG_NR);
                    return OAM_FAILURE;
                }

#if 1
                U8    gnb_count = OAM_ZERO; 
                tag_value = oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,
                            "peer_gnb_pci_list_size");

                if ( oam_strcmp((Char8*)tag_value, OAM_INVALID_STR) )
                {
                    lclTemp_value = oam_atoi((Char8*)tag_value);
                    OAM_LOG(OAM,OAM_WARNING,
                            "Value of peer_gnb_pci_list_size is %d ",
                            lclTemp_value);
                    U8 lclTemp_value_1 = OAM_ZERO;
                    lclTemp_value_1 = oam_atoi((const char *)oam_xmlNodeGetContent(
                                xml_struct_g.EN_DC_Params,"is_MaSgnbAddition"));

                    if ( OAM_ZERO == lclTemp_value_1 )
                    {
                        if ( ( OAM_ONE <= lclTemp_value ) && ( lclTemp_value <= 8 ) )
                        {
                            p_rrm_cellconfig->operator_info.endc_info.peer_gnb_pci_list.count =
                                lclTemp_value;

                            for ( gnb_count= OAM_ZERO; gnb_count < p_rrm_cellconfig->
                                    operator_info.endc_info.peer_gnb_pci_list.count; gnb_count++ )
                            {
                                tag_value = oam_xmlNodeGetContent(
                                            xml_struct_g.peer_pci_info[gnb_count],"nr_pci");

                                if ( oam_strcmp((Char8*)tag_value, OAM_INVALID_STR) )
                                {
                                    lclTemp_value = oam_atoi((Char8*)tag_value);
                                    if ( ( lclTemp_value >= OAM_ZERO ) &&
                                            ( lclTemp_value <= RRM_MAX_NR_PCI ))
                                    {
                                        p_rrm_cellconfig->operator_info.endc_info.peer_gnb_pci_list.
                                            nr_pci[gnb_count] = lclTemp_value;
                                        OAM_LOG(OAM,OAM_WARNING,
                                                "Value of peer_gnb_pci is %d ",
                                                lclTemp_value);
                                    }
                                    else
                                    {
                                        OAM_LOG(OAM,OAM_WARNING,
                                                "Value of NR PCI is %d and range is from 0 to %d",
                                                lclTemp_value,
                                                RRM_MAX_NR_PCI);
                                        return OAM_FAILURE;
                                    }
                                }
                            }
                        }
                        else
                        {
                            OAM_LOG(OAM,OAM_WARNING,
                                    "Value of NR PCI list count is %d and range is from 1 to 8",
                                    lclTemp_value);
                            return OAM_FAILURE;
                        }
                    }
                    else
                    {
                        if ( ( 0 <= lclTemp_value ) && ( lclTemp_value <= 8 ) )
                        {
                            p_rrm_cellconfig->operator_info.endc_info.peer_gnb_pci_list.count =
                                (U8)lclTemp_value;

                            for ( gnb_count= OAM_ZERO; gnb_count < p_rrm_cellconfig->
                                    operator_info.endc_info.peer_gnb_pci_list.count; gnb_count++ )
                            {
                                temp = (Char8*)oam_xmlNodeGetContent(
                                        xml_struct_g.peer_pci_info[gnb_count],"nr_pci");

                                lclTemp_value = oam_atoi((Char8*)temp);

                                if ( ( lclTemp_value >= OAM_ZERO ) &&
                                        ( lclTemp_value <= RRM_MAX_NR_PCI ))
                                {
                                    p_rrm_cellconfig->operator_info.endc_info.peer_gnb_pci_list.
                                        nr_pci[gnb_count] = lclTemp_value;
                                }
                                else
                                {
                                    OAM_LOG(OAM,OAM_WARNING,
                                            "Value of NR PCI is %d and range is from 0 to %d",
                                            lclTemp_value,
                                            RRM_MAX_NR_PCI);
                                    return OAM_FAILURE;
                                }  
                            }
                        }
                        else
                        {
                            OAM_LOG(OAM,OAM_WARNING,
                                    "Value of NR PCI list count is %d and range is from 0 to 8",
                                    lclTemp_value);
                    return OAM_FAILURE;
                }  
            }
        }
#endif
            }
        }

#endif

        /*SPR 21096 +-*/
        /*eICIC_PHASE_1_2_CHANGES_END */  
        tagvalue = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->eicic_params,
                "eICICProvisionType");
        if(oam_strcmp(tagvalue, OAM_INVALID_STR)){
            lclTemp_value = oam_atoi(tagvalue);
            /* bug_15059_start CID: 34790 */
            if((rrm_oam_eicic_node_type_et)lclTemp_value != RRM_OAM_EICIC_DEACTIVATED)
                /* bug_15059_end CID: 34790 */
            {
                /*CID:69229start*/
                p_rrm_cellconfig->operator_info.eicic_info.eicic_provisioned_type= 
                    (rrm_oam_eicic_node_type_et)lclTemp_value;
                /*CID:69229 end*/
                p_rrm_cellconfig->operator_info.eicic_info.
                    bitmask |= RRM_OAM_EICIC_PROVISIONED_TYPE_PRESENT;
                p_rrm_cellconfig->operator_info.
                    bitmask |= RRM_OAM_EICIC_INFO_PRESENT;
                if(OAM_SUCCESS == oam_populate_eicic_params(p_rrm_cellconfig, p_cell_spec_params))
                {
                    OAM_LOG(OAM,OAM_INFO,"Parameters populated for rrm eICIC Info");
                }
                /* SPR 16200 FIX START */
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Parameter population failed for eICIC params");
                    retVal = OAM_FAILURE;
                }
                /* SPR 16200 FIX END */
            }
        }
        /*eICIC_PHASE_1_2_CHANGES_END */  


        return retVal;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_dynamic_icic_param
 *  DESCRIPTION      : This function is used to populate the rrm dynamic icic 
 *                                         parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* Cov cid 54862 Fix */
oam_return_et
    oam_populate_dynamic_icic_param
(
 oam_rrm_cell_config_req_t  *p_rrm_cellconfig,
 XML_struct_cell_config *p_cell_spec_params,
 prop_cellconfig_xml_st *p_prop_cellconfig,
 /* SPR 21958 PUSCH RAT1 Support Start */
 UInt8 cell_cnt
 /* SPR 21958 PUSCH RAT1 Support End */
 )
{
    UInt8         region = OAM_ZERO;
    UInt8         count = OAM_ZERO;
    /* SPR 11001 FIX START */
    xmlChar* tag_value = OAM_NULL;
    /* SPR 11001 FIX END */

    xmlNode       *ptr_child_power_mask = OAM_NULL;
    UInt8         index_power = OAM_ZERO;
    char    *p_data_power_mask = OAM_NULL;
    OAM_FUN_ENTRY_TRACE();

    /* SPR 13501 FIX START */
    SInt32 total_ul_rbs = OAM_ZERO;
    SInt32 total_dl_rbs = OAM_ZERO;
    SInt32 num_cc_rbs = OAM_ZERO;
    SInt32 num_ce_rbs = OAM_ZERO;
    /* SPR 13501 FIX END */
    /* SPR 9787 Fix : code removed */
    if( OAM_NULL != p_cell_spec_params->dynamic_icic_info )
    {
        /* gur30485 fix start */
        p_rrm_cellconfig->operator_info.
            bitmask |= RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT;
        /* SPR 10713 FIX START */
        lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->dynamic_icic_info,"icic_enable_disable"));
        if (OAM_ONE == lclTemp_value)
        {
		/* SPR 21958 PUSCH RAT1 Support Start */
            /* SPR 22549 Fix Start */
            icic_flag[cell_cnt] = OAM_ONE;
            /* SPR 22549 Fix End */
		/* SPR 21958 PUSCH RAT1 Support End */
            /* SPR 10713 FIX END */ 

            lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"icic_scheme_type"));

            if( OAM_INVALID_POPULATE_VAL != lclTemp_value )
            { 
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.bitmask |= RRM_OAM_ICIC_SCHEME_TYPE_PRESENT;

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.icic_scheme_type = lclTemp_value;
            }
            /* dl resource partition info */
            if( OAM_NULL != p_cell_spec_params->dl_resource_partition_info )
            {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.dl_resource_partition_info.
                    bitmask = OAM_ALL_8_BIT_ZERO;

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.
                    bitmask |= RRM_OAM_DL_RESOURCE_PARTITON_INFO_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->dl_resource_partition_info,"num_of_cell_center_region"));

                if( OAM_INVALID_POPULATE_VAL != lclTemp_value )
                {
                    region = lclTemp_value; /* fill cell region count and hold it in temp val */

                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.dl_resource_partition_info.
                        num_of_cell_center_region = lclTemp_value;

                    for(count = OAM_ZERO ; ((count < region) && (count < RRM_OAM_MAX_CC_REGION)) ; count++)
                    {

                        if( p_cell_spec_params->dl_cell_center_region[count] != OAM_NULL )
                        {
                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->dl_cell_center_region[count],"start_rb"));

                            p_rrm_cellconfig->operator_info.
                                dynamic_icic_info.dl_resource_partition_info.
                                cell_center_region[count].start_rb = lclTemp_value;

                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->dl_cell_center_region[count],"num_of_rb"));

                            p_rrm_cellconfig->operator_info.
                                dynamic_icic_info.dl_resource_partition_info.
                                cell_center_region[count].num_of_rb = lclTemp_value;
                            /* SPR 13501 FIX START */
                            num_cc_rbs += lclTemp_value;
                            /* SPR 13501 FIX END */
                        }
                        /* SPR 13501 FIX START */
                        else {
                                OAM_LOG(OAM, OAM_WARNING, "Failed to read the "
                                    "mandatory tag cell_center_region");

                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        /* SPR 13501 FIX END */
                    }

                }

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->dl_resource_partition_info,"num_of_cell_edge_region"));

                if( OAM_INVALID_POPULATE_VAL != lclTemp_value )
                {
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.dl_resource_partition_info.
                        num_of_cell_edge_region = lclTemp_value;

                    /* SPR 13501 FIX START */
                    region = lclTemp_value;

                    if (p_cell_spec_params->dl_cell_edge_region && region > 0) {
                        /* SPR 13501 FIX END */
                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.dl_resource_partition_info.
                            bitmask |= RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT;

                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->dl_cell_edge_region,"start_rb"));

                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.dl_resource_partition_info.
                            cell_edge_region.start_rb = lclTemp_value;

                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->dl_cell_edge_region,"num_of_rb"));

                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.dl_resource_partition_info.
                            cell_edge_region.num_of_rb = lclTemp_value;
                        /* SPR 13501 FIX START */
                        num_ce_rbs = lclTemp_value;
                        /* SPR 13501 FIX END */
                    }

                    /* SPR 13501 FIX START */
                    total_dl_rbs = num_cc_rbs + num_ce_rbs;
                    /* SPR 21040 FIXED START*/

                    if (total_dl_rbs > oam_max_num_rbs_value) {
                        /* SPR 22304 Fix Start */
                        OAM_LOG(OAM, OAM_WARNING, "Total number of DL RBs[%d] "
                                "excceed the max allowed value[%llu]",
                                total_dl_rbs, oam_max_num_rbs_value);
                        /* SPR 22304 Fix End */
                        /* SPR 21040 FIXED END*/

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                    /* SPR 13501 FIX END */
                }
            }
            /* ul resourec partition info */
            if( OAM_NULL != p_cell_spec_params->ul_resource_partition_info )
            {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.bitmask |= RRM_OAM_UL_RESOURCE_PARTITION_INFO_PRESENT;

                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->ul_resource_partition_info,"num_of_cell_center_region"));
                /* SPR 13501 FIX START */
                num_cc_rbs = 0;
                num_ce_rbs = 0;
                region = lclTemp_value;
                /* SPR 13501 FIX END */

                if( OAM_INVALID_POPULATE_VAL != lclTemp_value )
                {
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.ul_resource_partition_info.
                        num_of_cell_center_region = lclTemp_value;/* cell center region count */

                    for(count = OAM_ZERO; ((count < RRM_OAM_MAX_CC_REGION) &&
                                /* SPR 13501 FIX START */
                                (count < region)) ; count++)
                        /* SPR 13501 FIX END */
                    {

                        if( p_cell_spec_params->ul_cell_center_region[count] != OAM_NULL )
                        {
                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->ul_cell_center_region[count],"start_rb"));

                            p_rrm_cellconfig->operator_info.
                                dynamic_icic_info.ul_resource_partition_info.
                                cell_center_region[count].start_rb = lclTemp_value;

                            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                        p_cell_spec_params->ul_cell_center_region[count],"num_of_rb"));

                            p_rrm_cellconfig->operator_info.
                                dynamic_icic_info.ul_resource_partition_info.
                                cell_center_region[count].num_of_rb = lclTemp_value;
                            /* SPR 13501 FIX START */
                            num_cc_rbs += lclTemp_value;
                            /* SPR 13501 FIX END */
                        }
                        /* SPR 13501 FIX START */
                        else {
                                OAM_LOG(OAM, OAM_WARNING, "Failed to read the "
                                    "mandatory tag cell_center_region");

                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        } 
                        /* SPR 13501 FIX END */
                    }
                }

                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->ul_resource_partition_info,"num_of_cell_edge_region"));
                /* SPR 13501 FIX START */
                region = lclTemp_value;
                /* SPR 13501 FIX END */

                if( OAM_INVALID_POPULATE_VAL != lclTemp_value )
                {
                    /*cell edge region count in ul resource */
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.ul_resource_partition_info.
                        num_of_cell_edge_region = lclTemp_value;

                    /* SPR 13501 FIX START */
                    if (p_cell_spec_params->ul_cell_edge_region && region > 0) {
                        /* SPR 13501 FIX END */
                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.ul_resource_partition_info.
                            bitmask |= RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT;

                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->ul_cell_edge_region,"start_rb"));

                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.ul_resource_partition_info.
                            cell_edge_region.start_rb = lclTemp_value;

                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_cell_spec_params->ul_cell_edge_region,"num_of_rb"));

                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.ul_resource_partition_info.
                            cell_edge_region.num_of_rb = lclTemp_value;

                        /* SPR 13501 FIX START */
                        num_ce_rbs = lclTemp_value;
                        /* SPR 13501 FIX END */
                    }
                }

                /* SPR 13501 FIX START */
                total_ul_rbs = num_cc_rbs + num_ce_rbs;
                /* SPR 21040 FIXED START*/
                if (total_ul_rbs > oam_max_num_rbs_value) {
                    /* SPR 22304 Fix Start */
                    OAM_LOG(OAM, OAM_WARNING,
                            "Total number of UL RBs[%d] "
                            "excceed the max allowed value[%llu]",
                            total_ul_rbs,oam_max_num_rbs_value);
                    /* SPR 22304 Fix End */

                    /* SPR 21040 FIXED END*/   

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
                /* SPR 13501 FIX END */
            }
            /* SPR 9787 Fix : code removed */

            /* UL power mask */
            if( OAM_NULL != p_cell_spec_params->ul_power_mask )
            {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.bitmask |= RRM_OAM_UL_POWER_MASK_PRESENT;

                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->ul_power_mask,"cell_center_user_power_mask"));

                if( OAM_INVALID_POPULATE_VAL != lclTemp_value )
                {
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.ul_power_mask.cell_center_user_power_mask = lclTemp_value;
                }

                lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->ul_power_mask,"cell_edge_user_power_mask"));

                if( OAM_INVALID_POPULATE_VAL != lclTemp_value )
                {
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.ul_power_mask.cell_edge_user_power_mask = lclTemp_value;
                }


                count = OAM_ZERO ;
                ptr_child_power_mask = (p_cell_spec_params->ul_power_mask)->children;

                for( index_power = OAM_ZERO ; ((index_power < RRM_OAM_MAX_QCI_VAL ) &&
                            ((OAM_NULL != (xmlNode *)ptr_child_power_mask ))); index_power++ )
                {
                    ptr_child_power_mask = oam_xml_find_tag(ptr_child_power_mask,(xmlChar *)"qci_delta_power_mask");

                    if( ptr_child_power_mask != OAM_NULL )
                    {
                        p_data_power_mask = ((char *)xmlNodeGetContent( ptr_child_power_mask ));

                        if( OAM_NULL != p_data_power_mask )
                        {
                            lclTemp_value =  oam_atoi((const char *)p_data_power_mask);
                            xmlFree(p_data_power_mask);
                            p_rrm_cellconfig->operator_info.
                                dynamic_icic_info.ul_power_mask.qci_delta_power_mask[count] = lclTemp_value;

                            ptr_child_power_mask = (((xmlNode *)ptr_child_power_mask)->next);
                            count++;
                        }  
                    }
                }
            }

            /* gur30485  fix end */


            if((oam_strcmp
                        ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->rntp_report_config_info,"rntp_report_required"),OAM_INVALID_STR)!= OAM_ZERO))
            {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.bitmask |= RRM_OAM_RNTP_REPORT_CONFIG_INFO_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->rntp_report_config_info,"rntp_report_required"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.rntp_report_config_info.rntp_report_on_X2_required = lclTemp_value;

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.rntp_report_config_info.bitmask = OAM_ALL_8_BIT_ZERO ;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->rntp_report_config_info,"rntp_threshold"));

                if( lclTemp_value != OAM_INVALID_POPULATE_VAL )
                {
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.rntp_report_config_info.bitmask |= RRM_OAM_RNTP_THRESHOLD_PRESENT;

                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.rntp_report_config_info.rntp_threshold = lclTemp_value;
                }


                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->rntp_report_config_info,"max_nominal_epre"));

                if( lclTemp_value != OAM_INVALID_POPULATE_VAL )
                {
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.rntp_report_config_info.bitmask |= RRM_OAM_MAX_NOMINAL_EPRE_PRESENT;

                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.rntp_report_config_info.max_nominal_epre = lclTemp_value;
                }

            }
            /*SPR 18955 +*/    
        }
        else
        {
                OAM_LOG(OAM, OAM_INFO,"ICIC feature is disabled");
        }
        /*SPR 18955 -*/    

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->alpha_pathloss_target_sinr_map,"default_path_loss"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->alpha_pathloss_target_sinr_map,"default_path_loss"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.alpha_pathloss_target_sinr_map.default_path_loss = lclTemp_value;
        }

        UInt8    pathloss_count = OAM_ZERO;
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->path_loss_target_sinr_map,"count"));

        p_rrm_cellconfig->operator_info.
            dynamic_icic_info.alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[OAM_ZERO].count = lclTemp_value;

        pathloss_count = (UInt8)lclTemp_value;

        for(count = OAM_ZERO ; ((count < RRM_OAM_MAX_NUM_PATHLOSS_TO_SINR_COUNT)
                    &&  ( count < pathloss_count )); count++)
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->path_loss_to_target_sinr_map_info[count],"start_PL"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[OAM_ZERO].
                path_loss_to_target_sinr_map_info[count].start_PL = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->path_loss_to_target_sinr_map_info[count],"end_PL"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[OAM_ZERO].
                path_loss_to_target_sinr_map_info[count].end_PL = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->path_loss_to_target_sinr_map_info[count],"target_SINR"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[OAM_ZERO].
                path_loss_to_target_sinr_map_info[count].target_SINR = lclTemp_value;

        }

        UInt32  pow_off_cqi_count = OAM_ZERO;
        UInt32  count1 = OAM_ZERO;
        UInt32  count2 = OAM_ZERO;
        p_rrm_cellconfig->operator_info.
            dynamic_icic_info.bitmask |= RRM_OAM_PDCCH_AGG_AND_POW_OFFSET_PRESENT;

        for(count = OAM_ZERO; count < RRM_OAM_NUM_DCI_SIZE_CATEGORY; count++)
        {

            for(count1 = OAM_ZERO ; count1 < RRM_OAM_MAX_CQI_VALUE ; count1++)
            {


                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_prop_cellconfig->aggregation_power_offset_cc_user_cqi[count][count1],"count"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.pdcch_aggregation_power_offset.aggregation_power_offset_cc_user[count].aggregation_power_offset_user[count1].count = lclTemp_value;
                pow_off_cqi_count = lclTemp_value;

                for(count2 = OAM_ZERO; ((count2 < pow_off_cqi_count) && (count2 < RRM_OAM_MAX_AGGREGATION_LEVEL_POWER_OFFSET_COUNT))
                        ; count2++)
                {

                    if( p_prop_cellconfig->aggr_pwr_offset_tuples_cc_user[count][count1][count2] != OAM_NULL )
                    {
                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->aggr_pwr_offset_tuples_cc_user[count][count1][count2],"aggregation_level"));

                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.pdcch_aggregation_power_offset.aggregation_power_offset_cc_user[count].
                            aggregation_power_offset_user[count1].aggr_pwr_offset_tuples[count2].aggregation_level = lclTemp_value;

                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->aggr_pwr_offset_tuples_cc_user[count][count1][count2],"power_offset"));

                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.pdcch_aggregation_power_offset.aggregation_power_offset_cc_user[count].
                            aggregation_power_offset_user[count1].aggr_pwr_offset_tuples[count2].power_offset = lclTemp_value;
                    }   
                }
            }
        }

        UInt32 ce_cqi_count = OAM_ZERO;

        p_rrm_cellconfig->operator_info.
            dynamic_icic_info.pdcch_aggregation_power_offset.bitmask = OAM_ALL_8_BIT_ZERO;
        for(count = OAM_ZERO ; count < RRM_OAM_NUM_DCI_SIZE_CATEGORY; count++)
        {

            ce_cqi_count = OAM_ZERO;
            for(count1 = OAM_ZERO ; count1 < RRM_OAM_MAX_CQI_VALUE ; count1++)
            {

                if( p_prop_cellconfig->aggregation_power_offset_ce_user_cqi[count][count1] != OAM_NULL )
                {
                    lclTemp_value= oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_prop_cellconfig->aggregation_power_offset_ce_user_cqi[count][count1],"count"));

                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.pdcch_aggregation_power_offset.aggregation_power_offset_ce_user[count].aggregation_power_offset_user[count1].count = lclTemp_value;
                    ce_cqi_count = lclTemp_value;

                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.pdcch_aggregation_power_offset.bitmask |= RRM_OAM_AGGREGATION_POWER_OFFSET_CE_USER_PRESENT ;

                }



                for(count2 = OAM_ZERO ; ((count2 < RRM_OAM_MAX_AGGREGATION_LEVEL_POWER_OFFSET_COUNT) &&
                            (count2 < ce_cqi_count ))
                        ; count2++)
                {

                    if( p_prop_cellconfig->aggr_pwr_offset_tuples_ce_user[count][count1][count2] != OAM_NULL )
                    {
                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->aggr_pwr_offset_tuples_ce_user[count][count1][count2],"aggregation_level"));

                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.pdcch_aggregation_power_offset.aggregation_power_offset_ce_user[count].
                            aggregation_power_offset_user[count1].aggr_pwr_offset_tuples[count2].aggregation_level = lclTemp_value;

                        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                    p_prop_cellconfig->aggr_pwr_offset_tuples_ce_user[count][count1][count2],"power_offset"));

                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.pdcch_aggregation_power_offset.aggregation_power_offset_ce_user[count].
                            aggregation_power_offset_user[count1].aggr_pwr_offset_tuples[count2].power_offset = lclTemp_value;
                    }
                }
            }
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->cqi_to_phich_power ,"cqi_to_phich_power_info"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_CQI_TO_PHICH_POW_PRESENT;

            xmlNode *ptr_child = OAM_NULL;
            ptr_child = oam_xml_find_tag(p_prop_cellconfig->cqi_to_phich_power->children,(xmlChar *)"cqi_to_phich_power_info");
            for(count = OAM_ZERO ; ((count < RRM_OAM_MAX_CQI_VALUE) && (ptr_child != OAM_NULL )); count++)
            {
                char *temp=(char *)xmlNodeGetContent(ptr_child);
                lclTemp_value=oam_atoi(temp);
                xmlFree(temp); 
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.cqi_to_phich_power.cqi_to_phich_power_info[count] = lclTemp_value;

                ptr_child = ptr_child->next;
            } 
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->ADDITIONAL_ICIC_params ,"min_rb_for_pl_phr_calc"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_MIN_RB_FOR_PL_PHR_CALC_BIT_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->ADDITIONAL_ICIC_params,"min_rb_for_pl_phr_calc"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.min_rb_for_pl_phr_calc = lclTemp_value;
        }

        SInt8 max_dl_sps_dci_per_tti = OAM_ZERO,
              max_dl_sps_Occasion_Per_tti = OAM_ZERO,
              max_dl_sps_rbs_per_tti = OAM_ZERO,
              max_dl_sps_rbs_per_tti_per_interval = OAM_ZERO;

        max_dl_sps_dci_per_tti = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_dl_scheduling_Info_per_tti ,"max_dl_sps_dci_per_tti"),OAM_INVALID_STR);
        max_dl_sps_Occasion_Per_tti = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_dl_scheduling_Info_per_tti,"max_dl_sps_Occasion_Per_tti"),OAM_INVALID_STR);
        max_dl_sps_rbs_per_tti = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_dl_scheduling_Info_per_tti,"max_dl_sps_rbs_per_tti"),OAM_INVALID_STR);
        max_dl_sps_rbs_per_tti_per_interval = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_dl_scheduling_Info_per_tti,"max_dl_sps_rbs_per_tti_per_interval"),OAM_INVALID_STR);


        if((max_dl_sps_dci_per_tti != OAM_ZERO)
                && (max_dl_sps_Occasion_Per_tti != OAM_ZERO)
                && (max_dl_sps_rbs_per_tti != OAM_ZERO)
                && (max_dl_sps_rbs_per_tti_per_interval != OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_SPS_DL_SCHEDULING_INFO_PER_TTI_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->sps_dl_scheduling_Info_per_tti,"max_dl_sps_dci_per_tti"));
            if(lclTemp_value >= MIN_SPS_DL_DCI_PER_TTI && lclTemp_value <= MAX_SPS_DL_DCI_PER_TTI) {

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.sps_dl_scheduling_Info_per_tti.max_dl_sps_dci_per_tti = lclTemp_value;
            }
            else {
					OAM_LOG(OAM, OAM_WARNING,"Value of max_dl_sps_dci_per_tti is %d and "
                        "range is from %d to %d",
                        lclTemp_value, MIN_SPS_DL_DCI_PER_TTI,MAX_SPS_DL_DCI_PER_TTI);
                return OAM_FAILURE;
            }

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->sps_dl_scheduling_Info_per_tti,"max_dl_sps_Occasion_Per_tti"));
            if(lclTemp_value >= MIN_DL_SPS_OCCASSION_PER_TTI &&
                    lclTemp_value <= MAX_DL_SPS_OCCASSION_PER_TTI) {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.sps_dl_scheduling_Info_per_tti.max_dl_sps_Occasion_Per_tti = lclTemp_value;
            }
            else {
					OAM_LOG(OAM, OAM_WARNING,
                        "Value of max_dl_sps_occasion_per_tti is %d and "
                        "range is from %d to %d",
                        lclTemp_value, MIN_DL_SPS_OCCASSION_PER_TTI,
                        MIN_DL_SPS_OCCASSION_PER_TTI);
                return OAM_FAILURE;
            }

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->sps_dl_scheduling_Info_per_tti,"max_dl_sps_rbs_per_tti"));
            if(lclTemp_value >= MIN_DL_SPS_RBS_PER_TTI &&
                    lclTemp_value <= MAX_DL_SPS_RBS_PER_TTI) {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.sps_dl_scheduling_Info_per_tti.max_dl_sps_rbs_per_tti = lclTemp_value;
            }
            else {
					OAM_LOG(OAM, OAM_WARNING,
                        "Value of max_dl_sps_rbs_per_tti is %d and "
                        "range is from %d to %d",
                        lclTemp_value, MIN_DL_SPS_RBS_PER_TTI,
                        MAX_DL_SPS_RBS_PER_TTI);
                return OAM_FAILURE;
            }

            int i = RRM_OAM_MAX_SPS_INTERVALS - OAM_ONE;
            xmlNode* abc = oam_xml_find_tag(p_prop_cellconfig->sps_dl_scheduling_Info_per_tti->children,(xmlChar *)"max_dl_sps_rbs_per_tti_per_interval");
            OAM_NULL_CHECK(NULL != abc);/* Coverity FIX 35430 */
            while(i >= OAM_ZERO )
            {
                char *temp=(char *)xmlNodeGetContent(abc);
                if(temp)
                {
                    lclTemp_value = oam_atoi(temp);
                    if(lclTemp_value >= MIN_DL_SPS_RBS_TTI_PER_INTERVAL &&
                            lclTemp_value <= MAX_DL_SPS_RBS_TTI_PER_INTERVAL) {
                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.sps_dl_scheduling_Info_per_tti.
                            max_dl_sps_rbs_per_tti_per_interval[i] = lclTemp_value;
                    }
                    else {
							OAM_LOG(OAM, OAM_WARNING,
                                "Value of max_dl_sps_rbs_tti_per_interval is %d and "
                                "range is from %d to %d",
                                lclTemp_value, MIN_DL_SPS_RBS_TTI_PER_INTERVAL,
                                MAX_DL_SPS_RBS_TTI_PER_INTERVAL);
                        return OAM_FAILURE;
                    }

                    xmlFree(temp);
                }
                abc = abc->next;
                i--;
            }
        }

        SInt8 max_ul_sps_dci_per_tti = OAM_ZERO,
              max_ul_sps_occasion_per_tti = OAM_ZERO,
              max_ul_sps_rbs_per_tti = OAM_ZERO,
              max_ul_sps_rbs_tti_per_interval = OAM_ZERO;

        max_ul_sps_dci_per_tti = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_ul_scheduling_Info_per_tti ,"max_ul_sps_dci_per_tti"),OAM_INVALID_STR);
        max_ul_sps_occasion_per_tti = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_ul_scheduling_Info_per_tti,"max_ul_sps_occasion_per_tti"),OAM_INVALID_STR);
        max_ul_sps_rbs_per_tti = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_ul_scheduling_Info_per_tti,"max_ul_sps_rbs_per_tti"),OAM_INVALID_STR);
        max_ul_sps_rbs_tti_per_interval = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->sps_ul_scheduling_Info_per_tti,"max_ul_sps_rbs_tti_per_interval"),OAM_INVALID_STR);

        if((max_ul_sps_dci_per_tti != OAM_ZERO)
                && (max_ul_sps_occasion_per_tti != OAM_ZERO)
                && (max_ul_sps_rbs_per_tti != OAM_ZERO)
                && (max_ul_sps_rbs_tti_per_interval != OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_SPS_UL_SCHEDULING_INFO_PER_TTI_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->sps_ul_scheduling_Info_per_tti,"max_ul_sps_dci_per_tti"));

            if(lclTemp_value >= MIN_SPS_UL_DCI_PER_TTI && lclTemp_value <= MAX_SPS_UL_DCI_PER_TTI) {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.sps_ul_scheduling_Info_per_tti.max_ul_sps_dci_per_tti = lclTemp_value;
            }
            else {
					OAM_LOG(OAM, OAM_WARNING,"Value of max_ul_sps_dci_per_tti is %d and "
                        "range is from %d to %d",
                        lclTemp_value, MIN_SPS_UL_DCI_PER_TTI,MAX_SPS_UL_DCI_PER_TTI);
                return OAM_FAILURE;
            }

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->sps_ul_scheduling_Info_per_tti,"max_ul_sps_occasion_per_tti"));
            if(lclTemp_value >= MIN_UL_SPS_OCCASSION_PER_TTI &&
                    lclTemp_value <= MAX_UL_SPS_OCCASSION_PER_TTI) {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.sps_ul_scheduling_Info_per_tti.max_ul_sps_occasion_per_tti = lclTemp_value;
            }
            else {
					OAM_LOG(OAM, OAM_WARNING,
                        "Value of max_ul_sps_occasion_per_tti is %d and "
                        "range is from %d to %d",
                        lclTemp_value, MIN_UL_SPS_OCCASSION_PER_TTI,
                        MIN_UL_SPS_OCCASSION_PER_TTI);
                return OAM_FAILURE;
            }

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_prop_cellconfig->sps_ul_scheduling_Info_per_tti,"max_ul_sps_rbs_per_tti"));
            if(lclTemp_value >= MIN_UL_SPS_RBS_PER_TTI &&
                    lclTemp_value <= MAX_UL_SPS_RBS_PER_TTI) {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.sps_ul_scheduling_Info_per_tti.max_ul_sps_rbs_per_tti = lclTemp_value;
            }
            else {
					OAM_LOG(OAM, OAM_WARNING,
                        "Value of max_ul_sps_rbs_per_tti is %d and "
                        "range is from %d to %d",
                        lclTemp_value, MIN_UL_SPS_RBS_PER_TTI,
                        MAX_UL_SPS_RBS_PER_TTI);
                return OAM_FAILURE;
            }

            int i = RRM_OAM_MAX_SPS_INTERVALS - OAM_ONE;
            xmlNode* abc = oam_xml_find_tag(p_prop_cellconfig->sps_ul_scheduling_Info_per_tti->children,(xmlChar *)"max_ul_sps_rbs_tti_per_interval");
            OAM_NULL_CHECK(NULL != abc);/* Coverity FIX 35430 */
            while(i >= OAM_ZERO )
            {
                char *temp=(char *)xmlNodeGetContent(abc);
                if(temp)
                {
                    lclTemp_value = oam_atoi(temp);
                    if(lclTemp_value >= MIN_UL_SPS_RBS_TTI_PER_INTERVAL &&
                            lclTemp_value <= MAX_UL_SPS_RBS_TTI_PER_INTERVAL) {
                        p_rrm_cellconfig->operator_info.
                            dynamic_icic_info.sps_ul_scheduling_Info_per_tti.
                            max_ul_sps_rbs_tti_per_interval[i] = lclTemp_value;
                    }
                    else {
							OAM_LOG(OAM, OAM_WARNING,
                                "Value of max_ul_sps_rbs_tti_per_interval is %d and "
                                "range is from %d to %d",
                                lclTemp_value, MIN_UL_SPS_RBS_TTI_PER_INTERVAL,
                                MAX_UL_SPS_RBS_TTI_PER_INTERVAL);
                        return OAM_FAILURE;
                    }
                    xmlFree(temp);
                }
                abc = abc->next;
                i--;
            }
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->alpha_pathloss_target_sinr_map_sps,"default_path_loss"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_SPS_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->alpha_pathloss_target_sinr_map_sps,"default_path_loss"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.alpha_pathloss_target_sinr_map_sps.default_path_loss = lclTemp_value;
        }

        pathloss_count = OAM_ZERO;
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->path_loss_target_sinr_map_sps[OAM_ZERO],"count"));

        p_rrm_cellconfig->operator_info.
            dynamic_icic_info.alpha_pathloss_target_sinr_map_sps.path_loss_target_sinr_map[OAM_ZERO].count = lclTemp_value;

        pathloss_count = (UInt8)lclTemp_value;

        for(count = OAM_ZERO ; ((count < RRM_OAM_MAX_NUM_PATHLOSS_TO_SINR_COUNT)
                    &&  ( count < pathloss_count )); count++)
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->path_loss_to_target_sinr_map_info_sps[count],"start_PL"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.alpha_pathloss_target_sinr_map_sps.path_loss_target_sinr_map[OAM_ZERO].
                path_loss_to_target_sinr_map_info[count].start_PL = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->path_loss_to_target_sinr_map_info_sps[count],"end_PL"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.alpha_pathloss_target_sinr_map_sps.path_loss_target_sinr_map[OAM_ZERO].
                path_loss_to_target_sinr_map_info[count].end_PL = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->path_loss_to_target_sinr_map_info_sps[count],"target_SINR"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.alpha_pathloss_target_sinr_map_sps.path_loss_target_sinr_map[OAM_ZERO].
                path_loss_to_target_sinr_map_info[count].target_SINR = lclTemp_value;

        }

        SInt8 cce_correction_step_up_factor = OAM_ZERO,
              cce_correction_step_down_factor = OAM_ZERO,
              cce_adjust_factor = OAM_ZERO;

        cce_correction_step_up_factor = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->dynamic_cfi_extension_params ,"cce_correction_step_up_factor"),OAM_INVALID_STR);
        cce_correction_step_down_factor = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->dynamic_cfi_extension_params,"cce_correction_step_down_factor"),OAM_INVALID_STR);
        cce_adjust_factor = oam_strcmp((const char *)oam_xmlNodeGetContent(p_prop_cellconfig->dynamic_cfi_extension_params,"cce_adjust_factor"),OAM_INVALID_STR);

        if((cce_correction_step_up_factor != OAM_ZERO)
                && (cce_correction_step_down_factor != OAM_ZERO)
                && (cce_adjust_factor != OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_DYNAMIC_CFI_EXTENSION_PARAM_PRESENT;

            int i = RRM_OAM_MAX_POSSIBLE_AGGREGAITION_LEVELS - OAM_ONE;
            xmlNode* abc = oam_xml_find_tag(p_prop_cellconfig->dynamic_cfi_extension_params->children,(xmlChar *)"cce_correction_step_up_factor");
            OAM_NULL_CHECK(NULL != abc);/* Coverity FIX 35430 */
            while(i >= OAM_ZERO )
            {
                char *temp = (char *)xmlNodeGetContent(abc);
                if(temp){
                    lclTemp_value = oam_atoi(temp);
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.dynamic_cfi_extension_params.
                        cce_correction_step_up_factor[i] = lclTemp_value;
                    xmlFree(temp);
                }    
                i--;
                abc = abc->next;
            }

            i = RRM_OAM_MAX_POSSIBLE_AGGREGAITION_LEVELS - OAM_ONE;
            abc = oam_xml_find_tag(p_prop_cellconfig->dynamic_cfi_extension_params->children,(xmlChar *)"cce_correction_step_down_factor");
            OAM_NULL_CHECK(NULL != abc);/* Coverity FIX 35430 */
            while(i >= OAM_ZERO )
            {
                char *temp = (char *)xmlNodeGetContent(abc);
                if(temp){
                    lclTemp_value = oam_atoi(temp);
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.dynamic_cfi_extension_params.
                        cce_correction_step_down_factor[i] = lclTemp_value;
                    xmlFree(temp);
                }
                i--;
                abc = abc->next;
            }

            i = RRM_OAM_MAX_POSSIBLE_AGGREGAITION_LEVELS - OAM_ONE;
            abc = oam_xml_find_tag(p_prop_cellconfig->dynamic_cfi_extension_params->children,(xmlChar *)"cce_adjust_factor");
            OAM_NULL_CHECK(NULL != abc);/* Coverity FIX 35430 */
            while(i >= OAM_ZERO )
            {
                char *temp = (char *)xmlNodeGetContent(abc);
                if(temp){
                    lclTemp_value = oam_atoi(temp);
                    p_rrm_cellconfig->operator_info.
                        dynamic_icic_info.dynamic_cfi_extension_params.
                        cce_adjust_factor[i] = lclTemp_value;
                    xmlFree(temp);
                }
                abc = abc->next;
                i--;
            }
        }


        SInt8 min_mcs_index_for_atb = OAM_ZERO,
              min_prb_val_for_atb = OAM_ZERO;

        min_mcs_index_for_atb = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->atb_config ,"min_mcs_index_for_atb"),OAM_INVALID_STR);
        min_prb_val_for_atb = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->atb_config,"min_prb_val_for_atb"),OAM_INVALID_STR);

        if((min_mcs_index_for_atb != OAM_ZERO)
                && (min_prb_val_for_atb != OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_ATB_CONFIG_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->atb_config,"min_mcs_index_for_atb"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.atb_config.min_mcs_index_for_atb = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->atb_config,"min_prb_val_for_atb"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.atb_config.min_prb_val_for_atb = lclTemp_value;

        }

        /* SPR 11001 FIX START */
        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->mimo_mode_params,
                "ul_mu_mimo_type");
        if (oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
            p_rrm_cellconfig->operator_info.dynamic_icic_info.
                bitmask |= RRM_OAM_UL_MU_MIMO_TYPE_PRESENT;

            lclTemp_value = oam_atoi((Char8*)tag_value);
				OAM_LOG(OAM, OAM_INFO, "UL MUMIMO Type: %d", lclTemp_value);
        }
        else {
            lclTemp_value = 0;
            OAM_LOG(OAM, OAM_WARNING,
                    "Unable to read parameter ul_mu_mimo_type "
                    "from configuration file, assuming default: %d",
                    lclTemp_value);
        }

        p_rrm_cellconfig->operator_info.dynamic_icic_info.
            ul_mu_mimo_type = lclTemp_value;
        /* SPR 11001 FIX END */

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dynamic_icic_info ,"msc_threshold_ul_mu_mimo"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_MSC_THRESHOLD_UL_MU_MIMO_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"msc_threshold_ul_mu_mimo"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.msc_threshold_ul_mu_mimo = lclTemp_value;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dynamic_icic_info ,"x2ap_icic_report_perodicity"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_X2AP_ICIC_REPORT_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"x2ap_icic_report_perodicity"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.x2ap_icic_report_periodicity = lclTemp_value;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dynamic_icic_info ,"pa_fo_cell_edge_ue"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_PA_FOR_CELL_EDGE_UE_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"pa_fo_cell_edge_ue"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.pa_for_ce_ue = lclTemp_value;
        }
        /* SPR 20653 Fix Start */
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dynamic_icic_info ,"ref_sig_powr_ramping_step"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_REF_SIG_POWER_RAMPING_STEP_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"ref_sig_powr_ramping_step"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.ref_sig_powr_ramping_step = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of ref_sig_powr_ramping_step not found");
            return OAM_FAILURE;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dynamic_icic_info ,"p_a_ramping_step"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_PA_RAMPING_STEP_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"p_a_ramping_step"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.p_a_ramping_step = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of p_a_ramping_step not found");
            return OAM_FAILURE;
        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dynamic_icic_info ,"initial_ue_location"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_INITIAL_UE_LOCATION_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"initial_ue_location"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.initial_ue_location = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of initial_ue_location not found");
            return OAM_FAILURE;
        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dynamic_icic_info ,"srs_subband_group_size"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.bitmask |= RRM_OAM_SRS_SUBBAND_GROUP_SIZE_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"srs_subband_group_size"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.srs_subband_group_size = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of srs_subband_group_size not found");
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dynamic_icic_info ,"tpc_for_msg3"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bitmask |= RRM_OAM_TPC_FOR_MSG3_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->dynamic_icic_info,"tpc_for_msg3"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.tpc_for_msg3 = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of tpc_for_msg3 not found");
        }
        /* SPR 20653_1 Fix Start */
        if(OAM_NULL != p_cell_spec_params->dci_params)
        {
            p_rrm_cellconfig->operator_info.dynamic_icic_info.tpc_info.bitmask |= RRM_OAM_TPC_DCI_INFO_PRESENT;
            /*SPR 20653_1 Fix End */ 
            SInt8 tpc_trigger_waittime_for_pusch_DCI0 = OAM_ZERO,
                  tpc_trigger_waittime_for_pucch_DCI1x2x = OAM_ZERO,
                  tpc_num_ue_threshold_for_pusch_DCI3A = OAM_ZERO,
                  tpc_num_ue_threshold_for_pucch_DCI3A = OAM_ZERO;

            tpc_trigger_waittime_for_pusch_DCI0 = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dci_params,"tpc_trigger_waittime_for_pusch_DCI0"),OAM_INVALID_STR);
            tpc_trigger_waittime_for_pucch_DCI1x2x = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dci_params,"tpc_trigger_waittime_for_pucch_DCI1x2x"),OAM_INVALID_STR);
            tpc_num_ue_threshold_for_pusch_DCI3A = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dci_params,"tpc_num_ue_threshold_for_pusch_DCI3A"),OAM_INVALID_STR);
            tpc_num_ue_threshold_for_pucch_DCI3A = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->dci_params,"tpc_num_ue_threshold_for_pucch_DCI3A"),OAM_INVALID_STR);

            if((tpc_trigger_waittime_for_pusch_DCI0 != OAM_ZERO)
                    && (tpc_trigger_waittime_for_pucch_DCI1x2x != OAM_ZERO)
                    && (tpc_num_ue_threshold_for_pusch_DCI3A != OAM_ZERO)
                    && (tpc_num_ue_threshold_for_pucch_DCI3A != OAM_ZERO)
              )
            {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.dci_params.bitmask |= RRM_OAM_TPC_TRIGGER_WAITTIME_FOR_PUSCH_DCI0_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->dci_params,"tpc_trigger_waittime_for_pusch_DCI0"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.dci_params.tpc_trigger_waittime_for_pusch_DCI0 = lclTemp_value;

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.dci_params.bitmask |= RRM_OAM_TPC_TRIGGER_WAITTIME_FOR_PUCCH_DCI1_X2X_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->dci_params,"tpc_trigger_waittime_for_pucch_DCI1x2x"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.dci_params.tpc_trigger_waittime_for_pucch_DCI1x2x = lclTemp_value;

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.dci_params.bitmask |= RRM_OAM_TPC_NUM_UE_THRESHOLD_FOR_PUSCH_DCI3A_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->dci_params,"tpc_num_ue_threshold_for_pusch_DCI3A"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.dci_params.tpc_num_ue_threshold_for_pusch_DCI3A = lclTemp_value;

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.dci_params.bitmask |= RRM_OAM_TPC_NUM_UE_THRESHOLD_FOR_PUCCH_DCI3A_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->dci_params,"tpc_num_ue_threshold_for_pucch_DCI3A"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.dci_params.tpc_num_ue_threshold_for_pucch_DCI3A = lclTemp_value;
            }

            /*SPR 20653_1 Fix Start*/
        }
        if(OAM_NULL != p_cell_spec_params->cooloff_period)
        {
            p_rrm_cellconfig->operator_info.dynamic_icic_info.tpc_info.bitmask |= RRM_OAM_COOLOFF_PERIOD_PRESENT;
            /* SPR 20653_1 Fix End */
            SInt8 cooloff_period_for_bler_triggered_pucchTPC = OAM_ZERO,
                  cooloff_period_for_pucchTPC = OAM_ZERO,
                  cooloff_period_for_puschTPC = OAM_ZERO;

            cooloff_period_for_bler_triggered_pucchTPC = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->cooloff_period,"cooloff_period_for_bler_triggered_pucchTPC"),OAM_INVALID_STR);
            cooloff_period_for_pucchTPC = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->cooloff_period,"cooloff_period_for_pucchTPC"),OAM_INVALID_STR);
            cooloff_period_for_puschTPC = oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->cooloff_period,"cooloff_period_for_puschTPC"),OAM_INVALID_STR);

            if((cooloff_period_for_bler_triggered_pucchTPC != OAM_ZERO)
                    && (cooloff_period_for_pucchTPC != OAM_ZERO)
                    && (cooloff_period_for_puschTPC != OAM_ZERO)
              )
            {
                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.cooloff_period.bitmask |= RRM_OAM_COOLOFF_PERIOD_FOR_BLER_TRIGGERED_PUCCH_TPC_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->cooloff_period,"cooloff_period_for_bler_triggered_pucchTPC"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.cooloff_period.cooloff_period_for_bler_triggered_pucchTPC = lclTemp_value;

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.cooloff_period.bitmask |= RRM_OAM_COOLOFF_PERIOD_FOR_PUCCH_TPC_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->cooloff_period,"cooloff_period_for_pucchTPC"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.cooloff_period.cooloff_period_for_pucchTPC = lclTemp_value;

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.cooloff_period.bitmask |= RRM_OAM_COOLOFF_PERIOD_FOR_PUSCH_TPC_PRESENT;

                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->cooloff_period,"cooloff_period_for_puschTPC"));

                p_rrm_cellconfig->operator_info.
                    dynamic_icic_info.tpc_info.cooloff_period.cooloff_period_for_puschTPC = lclTemp_value;
            }
            /* SPR 20653_1 Fix Start */
        }
        /* SPR 20653_1 Fix End */

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->delta_sinr_tpc_map_pusch_info,"delta_sinr_count"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bitmask |= RRM_OAM_DELTA_SINR_TPC_MAP_PUSCH_INFO_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_tpc_map_pusch_info,"delta_sinr_count"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pusch_info.count = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of delta_sinr_count not found");
            return OAM_FAILURE;
        }

        pathloss_count = (UInt8)lclTemp_value;

        for(count = OAM_ZERO ; ((count < RRM_OAM_MAX_DELTA_SINR_TO_TCP_MAP_PUSCH)
                    &&  ( count < pathloss_count )); count++)
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_to_tpc_map_pusch_info[count],"start_delta_sinr"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pusch_info.
                delta_sinr_to_tpc_map_pusch_info[count].start_delta_sinr = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_to_tpc_map_pusch_info[count],"end_delta_sinr"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pusch_info.
                delta_sinr_to_tpc_map_pusch_info[count].end_delta_sinr = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_to_tpc_map_pusch_info[count],"pusch_tpc"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pusch_info.
                delta_sinr_to_tpc_map_pusch_info[count].pusch_tpc = lclTemp_value;

        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->bler_to_tpc_map_for_pucch,"pucch_bler_target"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bitmask |= RRM_OAM_BLER_TO_TPC_MAP_FOR_PUCCH_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->bler_to_tpc_map_for_pucch,"pucch_bler_target"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bler_to_tpc_map_for_pucch.pucch_bler_target = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of pucch_bler_target not found");
            return OAM_FAILURE;
        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->bler_to_tpc_map_for_pucch,"bler_count"),OAM_INVALID_STR)!= OAM_ZERO))
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->bler_to_tpc_map_for_pucch,"bler_count"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bler_to_tpc_map_for_pucch.count = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of bler_count not found");
            return OAM_FAILURE;
        }

        pathloss_count = (UInt8)lclTemp_value;

        for(count = OAM_ZERO ; ((count < RRM_OAM_MAX_NUM_TPC_FOR_PUCCH)
                    &&  ( count < pathloss_count )); count++)
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_bler_tpc_map_pucch_info[count],"start_bler"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bler_to_tpc_map_for_pucch.
                delta_bler_tpc_map_pucch_info[count].start_bler = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_bler_tpc_map_pucch_info[count],"end_bler"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bler_to_tpc_map_for_pucch.
                delta_bler_tpc_map_pucch_info[count].end_bler = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_bler_tpc_map_pucch_info[count],"bler_pucch_tpc"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bler_to_tpc_map_for_pucch.
                delta_bler_tpc_map_pucch_info[count].pucch_tpc = lclTemp_value;

        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->delta_sinr_tpc_map_pucch_info,"pucch_sinr_target"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.bitmask |= RRM_OAM_DELTA_SINR_TPC_MAP_PUCCH_INFO_PRESENT;

            /*spr_22058_changes_start*/
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pucch_info.bitmask |= RRM_OAM_PUCCH_SINR_TARGET_PRESENT;
            /*spr_22058_changes_end*/

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_tpc_map_pucch_info,"pucch_sinr_target"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pucch_info.pucch_sinr_target = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of pucch_sinr_target not found");
            return OAM_FAILURE;
        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->delta_sinr_tpc_map_pucch_info,"delta_sinr_pucch_count"),OAM_INVALID_STR)!= OAM_ZERO))
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_tpc_map_pucch_info,"delta_sinr_pucch_count"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pucch_info.count = lclTemp_value;
        }
        else
        {
		    OAM_LOG(OAM, OAM_WARNING, "Value of delta_sinr_pucch_count not found");
            return OAM_FAILURE;
        }

        pathloss_count = (UInt8)lclTemp_value;

        for(count = OAM_ZERO ; ((count < RRM_OAM_MAX_NUM_TPC_FOR_PUCCH)
                    &&  ( count < pathloss_count )); count++)
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_to_tpc_map_pucch_info[count],"start_sinr"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pucch_info.
                delta_sinr_to_tpc_map_for_pucch_info[count].start_sinr = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_to_tpc_map_pucch_info[count],"end_sinr"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pucch_info.
                delta_sinr_to_tpc_map_for_pucch_info[count].end_sinr = lclTemp_value;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->delta_sinr_to_tpc_map_pucch_info[count],"pucch_tpc"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.tpc_info.delta_sinr_tpc_map_pucch_info.
                delta_sinr_to_tpc_map_for_pucch_info[count].pucch_tpc = lclTemp_value;

        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->l1_meas_report_config_info,"layer1_meas_report_required"),OAM_INVALID_STR)!= OAM_ZERO))
        {

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.bitmask |= RRM_OAM_L1_MEAS_REPORT_CONFIG_INFO_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->l1_meas_report_config_info,"layer1_meas_report_required"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.l1_meas_report_config_info.layer1_meas_report_required = (rrm_bool_t)lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of layer1_meas_report_required not found");
            return OAM_FAILURE;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->l1_meas_report_config_info,"layer1_meas_report_avg_enabled"),OAM_INVALID_STR)!= OAM_ZERO))
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->l1_meas_report_config_info,"layer1_meas_report_avg_enabled"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.l1_meas_report_config_info.layer1_meas_report_avg_enabled = (rrm_bool_t)lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of layer1_meas_report_avg_enabled not found");
            return OAM_FAILURE;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->l1_meas_report_config_info,"layer1_meas_report_periodicity"),OAM_INVALID_STR)!= OAM_ZERO))
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->l1_meas_report_config_info,"layer1_meas_report_periodicity"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.l1_meas_report_config_info.layer1_meas_report_periodicity = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of layer1_meas_report_periodicity not found");
            return OAM_FAILURE;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->l2_meas_report_config_info,"cell_edge_prb_usage_required"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.bitmask |= RRM_OAM_L2_MEAS_REPORT_CONFIG_INFO_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->l2_meas_report_config_info,"cell_edge_prb_usage_required"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.l2_meas_report_config_info.cell_edge_prb_usage_required = (rrm_bool_t)lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of cell_edge_prb_usage_required not found");
            return OAM_FAILURE;
        }

        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->l2_meas_report_config_info,"l2_icic_report_periodicity"),OAM_INVALID_STR)!= OAM_ZERO))
        {

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->l2_meas_report_config_info,"l2_icic_report_periodicity"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.l2_meas_report_config_info.l2_icic_report_periodicity = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of l2_icic_report_periodicity not found");
            return OAM_FAILURE;
        }
        if((oam_strcmp
                    ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->report_config_info,"pdcch_interference_impact"),OAM_INVALID_STR)!= OAM_ZERO))
        {
            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.bitmask |= RRM_OAM_PDCCH_INTERFERENCE_IMPACT_PRESENT;

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->report_config_info,"pdcch_interference_impact"));

            p_rrm_cellconfig->operator_info.
                dynamic_icic_info.report_config_info.pdcch_interference_impact = lclTemp_value;
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING, "Value of pdcch_interference_impact not found");
        }
        /* SPR 20653 Fix End */

        /* SPR 9787 Fix Start */
    }
    /* SPR 9787 Fix End */
    return OAM_SUCCESS;
}

#ifdef COMMENT_CELL_CONFIG
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_rrm_log_enable_disable_param
 *  DESCRIPTION      : This function is used to populate the rrm log enable disable
 * 					   parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

/* + SPR 17439 */
    oam_return_et
oam_populate_rrm_log_enable_disable_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.log_enable_disable_req,"int_module_id"));
    /* coverity 35686 */
    oam_prov_req.oam_rrm_req.oam_rrm_log_enable_disable_req.
        module_id=(rrm_internal_module_id_et)lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.RRMparams,"log_on_off"));
    if(lclTemp_value >= MIN_RRM_LOG_ENABLE_DISABLE_LOG_ON_OFF && 
            lclTemp_value <= MAX_RRM_LOG_ENABLE_DISABLE_LOG_ON_OFF) { 
        /* coverity 35684 */
        oam_prov_req.oam_rrm_req.oam_rrm_log_enable_disable_req.
            log_config.log_on_off=(rrm_oam_log_on_off_et)lclTemp_value;		
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of log_on_off is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_LOG_ENABLE_DISABLE_LOG_ON_OFF,
                MAX_RRM_LOG_ENABLE_DISABLE_LOG_ON_OFF);
        return OAM_FAILURE;
    }

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.RRMparams,"log_level"));
    if(lclTemp_value >= MIN_RRM_LOG_ENABLE_DISABLE_LOG_LEVEL &&
            lclTemp_value <= MAX_RRM_LOG_ENABLE_DISABLE_LOG_LEVEL) { 
        oam_prov_req.oam_rrm_req.oam_rrm_log_enable_disable_req.
            log_config.log_level=(rrm_oam_log_level_et)lclTemp_value;			
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
				"Value of log_level is %d and range is from %d to %d",
                lclTemp_value,MIN_RRM_LOG_ENABLE_DISABLE_LOG_LEVEL,
                MAX_RRM_LOG_ENABLE_DISABLE_LOG_LEVEL);
        return OAM_FAILURE;
    }


    OAM_FUN_EXIT_TRACE();	
    return OAM_SUCCESS;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_rrm_set_log_level_req_param
 *  DESCRIPTION      : This function is used to populate the rrm set log level
 * 					   parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

/* + SPR 17439 */
    oam_return_et
oam_populate_rrm_set_log_level_req_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.,"int_module_id"));
    if 
        (
         lclTemp_value >= MIN_RRM_SET_LOG_LEVEL_REQ_INT_MODULE_ID
         && 
         lclTemp_value <= MAX_RRM_SET_LOG_LEVEL_REQ_INT_MODULE_ID
        )
        { 
            oam_prov_req.oam_rrm_req.oam_send_oam_rrm_set_log_level_req.
                module_id=(rrm_internal_module_id_et)lclTemp_value;		
        }else
        {
			OAM_LOG(OAM, OAM_WARNING,
					"Value of log_level is %d and range is from %d to %d",
                    lclTemp_value,MIN_RRM_SET_LOG_LEVEL_REQ_INT_MODULE_ID,
                    MAX_RRM_SET_LOG_LEVEL_REQ_INT_MODULE_ID);
            return OAM_FAILURE;
        }

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.RRMparams,"log_level"));
        if 
            (
             lclTemp_value >= MIN_RRM_SET_LOG_LEVEL_REQ_LOG_LEVEL 
             && 
             lclTemp_value <= MAX_RRM_SET_LOG_LEVEL_REQ_LOG_LEVEL
            )
            {
                oam_prov_req.oam_rrm_req.oam_send_oam_rrm_set_log_level_req.
                    log_level=(rrm_oam_log_level_et)lclTemp_value;			
            }else
            {
				OAM_LOG(OAM, OAM_WARNING,
						"Value of log_level is %d and range is from %d to %d",
                        lclTemp_value,MIN_RRM_SET_LOG_LEVEL_REQ_LOG_LEVEL,
                        MAX_RRM_SET_LOG_LEVEL_REQ_LOG_LEVEL);
                return OAM_FAILURE;
            }

            return OAM_SUCCESS;
}
#endif
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_epc_cipher_and_integrity_algo_data
 *  DESCRIPTION      : This function is used to populate the rrc cipher algo info 
 *                                         parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS/OAM_FAILURE
 *******************************************************************************/
    oam_return_et oam_populate_epc_cipher_and_integrity_algo_data
(
 XML_struct_cell_config *p_cell_spec_params,
 rrc_oam_sector_info_t *p_cell_info
 )
{
    Char8     *cipher_str = OAM_NULL;
    Char8     *protection_str = OAM_NULL;
    /*SPR 11444 FIX START*/
    Char8     *unauth_user_integ_str = OAM_NULL;
    /*SPR 11444 FIX END*/
    Char8     *temp_str = OAM_NULL;
    UInt8     index = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;

    OAM_FUN_ENTRY_TRACE();

    cipher_str = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->EPC,
            "AllowedCipheringAlgorithmList");
    OAM_LOG(OAM, OAM_INFO, "Value of AllowedCipheringAlgorithmList is %s",
            cipher_str);

    if(oam_strcmp(cipher_str, OAM_INVALID_STR)) {
        temp_str = strtok(cipher_str, ",");

        while(temp_str && index < RRC_MAX_CIPHERING_ALGORITHMS) {
            lclTemp_value = oam_xml_search_string_to_integer(temp_str,
                    AllowedCipheringAlgorithmList,
                    RRC_MAX_CIPHERING_ALGORITHMS);

            if(lclTemp_value != OAM_INVALID_RETURN) {
                p_cell_info->supported_security_algorithms.
                    ciphering_algorithms.algorithms[index++] = lclTemp_value;
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Skipping unsupprted ciphering algorithm: %s",
                        temp_str);
                break;
            }

            temp_str = strtok(OAM_NULL , ",");
        }

        p_cell_info->supported_security_algorithms.ciphering_algorithms.
            num_algorithms = index;
    }

    protection_str = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->EPC,
            "AllowedIntegrityProtectionAlgorithmList");
    OAM_LOG(OAM, OAM_INFO,
            "Value of AllowedIntegrityProtectionAlgorithmList is %s",
            protection_str);

    temp_str = OAM_NULL;
    index = OAM_ZERO;
    if(oam_strcmp(protection_str, OAM_INVALID_STR)) {
        temp_str = strtok(protection_str,",");

        while(temp_str && index < RRC_MAX_INTEGRITY_ALGORITHMS) {
            lclTemp_value = oam_xml_search_string_to_integer(temp_str,
                    AllowedIntegrityProtectionAlgorithmList,
                    RRC_MAX_INTEGRITY_ALGORITHMS);

            if(lclTemp_value != OAM_INVALID_RETURN) {
                p_cell_info->supported_security_algorithms.
                    integrity_algorithms.algorithms[index++] = lclTemp_value;
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Skipping unsupprted integrity algorithm: %s",
                        temp_str);
                break;
            }

            temp_str = strtok(OAM_NULL , ",");
        }

    }
    /*SPR 11444 FIX START*/
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->EPC,"X_VENDOR_UNAUTH_USER_INTEGRITY_ALGO"),OAM_INVALID_STR)!=0))
    {
        unauth_user_integ_str = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->EPC,
                "X_VENDOR_UNAUTH_USER_INTEGRITY_ALGO");
        OAM_LOG(OAM, OAM_INFO,
                "Value of X_VENDOR_UNAUTH_USER_INTEGRITY_ALGO is %s",
                unauth_user_integ_str);
        /* SPR-13847 START */  
        lclTemp_value = oam_xml_search_string_to_integer(unauth_user_integ_str,
                AllowedIntegrityProtectionAlgorithmList,
                RRC_MAX_INTEGRITY_ALGORITHMS);
        /* SPR-13847 END */  
        /* coverity 64926 */
        if((lclTemp_value != OAM_INVALID_RETURN) && (index < RRC_MAX_INTEGRITY_ALGORITHMS)) {
            /* SPR 12663 Fix Start */
            p_cell_info->supported_security_algorithms.
                integrity_algorithms.algorithms[index++] = lclTemp_value;
            /* SPR 12663 Fix End */
        }
    }
    p_cell_info->supported_security_algorithms.
        integrity_algorithms.num_algorithms = index;
    /*SPR 11444 FIX END*/

    if(!p_cell_info->supported_security_algorithms.
            ciphering_algorithms.num_algorithms ||
            !p_cell_info->supported_security_algorithms.
            integrity_algorithms.num_algorithms) {
        retVal = OAM_FAILURE;
    }


    OAM_FUN_EXIT_TRACE();
    return retVal;
}




/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_device_specific_s1ap_params
 *  DESCRIPTION      : This function is used to populate the l3 s1ap parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_device_specific_s1ap_params(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    UInt32 index        = OAM_ZERO;

    Char8 *temp2 = OAM_NULL;   
    UInt8 temp3[HOME_ENB_ID_OCTET_SIZE] = {0};
    xmlChar *tag_value = OAM_NULL;
    Char8 *temp = OAM_NULL;
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    /* SPR 19703 changes start */
    U8 s1ap_log_level = 0;
    /* SPR 19703 changes end */
    /* SPR 23504/SES-341 Fix Start */
    oam_return_et retVal = OAM_SUCCESS;
    SInt32 num_plmns = 0;
    UInt8 tmp_plmnid[MAX_PLMN_ID_BYTES] = {0};
    UInt8 temp_plmnid1[OAM_SEVEN] = {0};
    /* SPR 23504/SES-341 Fix End */

    UInt8 nnsf_flag =
        oam_prov_req.oam_tr069_req.tr069_init_params.NNSFSupported;

    temp2 = (Char8*)oam_xmlNodeGetContent(xml_struct_g.S1AP,
            "logLevel");
    if(oam_strcmp(temp2, OAM_INVALID_STR)) {
        /* SPR 19703 changes start */
        s1ap_log_level = oam_atoi(temp2);

        /* SPR 20007 : CID 110651 fix start */
        if(s1ap_log_level <= MAX_S1AP_LOGLEVEL) {
            /* SPR 20007 : CID 110651 fix end */
            oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                log_level = s1ap_log_level;

            OAM_LOG(OAM, OAM_INFO,"Populated value of S1AP logLevel: %d,  temp2 %d",
                    s1ap_log_level,oam_atoi(temp2));
        }
        else {
            OAM_LOG(OAM, OAM_WARNING, "Value of logLevel is %d and range "
                    "is from %d to %d", s1ap_log_level,
                    /* SPR 19703 changes end */
                    MIN_S1AP_LOGLEVEL,
                    MAX_S1AP_LOGLEVEL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
        OAM_LOG(OAM, OAM_WARNING, "Mandatory tag logLevel not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,
            /* spr_21013_fix_end */
            "S1ConnectionMode");
    /* SPR-13171 START */
    if(p_temp)
    {
        if(oam_strlen((char *)p_temp)!=OAM_THREE)
        {
			OAM_LOG(OAM, OAM_WARNING,
					"Value of S1ConnectionMode is %s and valid value is either ONE or ALL",
                    p_temp);
            return OAM_FAILURE;

        }
        if((p_temp[0]=='O' || p_temp[0]=='o')
                &&(p_temp[1]=='N' || p_temp[1]=='n')
                &&(p_temp[2]=='E' || p_temp[2]=='e'))
        {
            /* Coverity 69692 Fix Start */
            if(nnsf_flag) {
				OAM_LOG(OAM, OAM_WARNING,
                        "NNSFSupported = 1 and S1ConnectionMode = one "
                        "is invalid combination");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            /* Coverity 69692 Fix End */
            sig_count = OAM_ONE;
            /* SPR 13171 START */
            oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                bitmask |= S1AP_OAM_MME_S1_CONN_MODE_ONE_PRESENT;
            /* SPR 13171 END */
        }
        else if((p_temp[0]=='A' || p_temp[0]=='a')
                &&(p_temp[1]=='L' || p_temp[1]=='l')
                &&(p_temp[2]=='L' || p_temp[2]=='l'))
        {
            sig_count = OAM_ZERO;
        }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,
					"Value of S1ConnectionMode is wrong and valid value is either ONE or ALL");
            return OAM_FAILURE;

        }

        /* spr_21013_fix_start */
        p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,
                /* spr_21013_fix_end */
                "S1SigLinkServerList");

        temp2 = strtok((Char8*)p_temp, ",");
        /* Ipv6 Support Start*/ 
        index = 0;
        while(temp2) {
            /*COVERTY FIX*/
            if(oam_isValidIp4((UInt8*)temp2) == OAM_SUCCESS) {
                oam_strncpy((Char8*)OAM_S1AP_INFO.mme_comm_info[index].
                        ip_addr[0].ip_addr, temp2, MAX_IP_ADDRESS_LENGTH);
                ++OAM_S1AP_INFO.mme_comm_info[index].num_ip_addr;
            }
            else if(oam_isValidIp6((UInt8*)temp2) == OAM_SUCCESS) {
                oam_strncpy((Char8*)OAM_S1AP_INFO.mme_comm_info[index].
                        ipv6_addr[0].ipv6_addr, temp2,
                        MAX_IPV6_ADDRESS_LENGTH);
                OAM_S1AP_INFO.mme_comm_info[index].
                    bitmask |= MME_COMM_INFO_IPV6_NUM_ADDR_PRESENT;
                oam_strncpy(((Char8*)OAM_S1AP_INFO.mme_comm_info[index].
                            ip_addr[0].ip_addr), OAM_LOCALHOST_IP4_ADDR,
                        MAX_IP_ADDRESS_LENGTH);
                OAM_S1AP_INFO.mme_comm_info[index].num_ipv6_addr = 1;
                OAM_S1AP_INFO.mme_comm_info[index].
                    bitmask |= MME_COMM_INFO_IPV6_ADDR_PRESENT;;
            }
            else {
				OAM_LOG(OAM, OAM_INFO,
                        "S1AP mme_comm info Ip Address Validation Failed");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            /* CSR 00051709 Change Start */
            /* SPR 15781 Fix Start */
            oam_siglink_server_info.num_ip_addr = OAM_ONE;
            /* SPR 15781 Fix End */
            oam_strcpy((Char8*)oam_siglink_server_info.oam_mme_info[index].
                    ip_addr, temp2);
            oam_siglink_server_info.oam_mme_info[index].status = OAM_ADD_MME;
            /* CSR 00051709 Changes End */

            ++index;
            temp2 = strtok(OAM_NULL, ",");
        }
        /* Ipv6 Support End*/ 

        oam_strncpy((Char8*)oam_prov_req.oam_igd_params.fap_control_params.
                S1SigLinkServerList, (Char8*)p_temp, OAM_MAX_MME_LIST_LEN);

        OAM_S1AP_INFO.num_mme = index;
    }
    /* SPR-13171 END */
    L3_PROV_REQ.mme_data.num_mme_id = OAM_ZERO; /* SPR 8764 FIX */
    oam_memset(L3_PROV_REQ.mme_data.mme_id, 0, MAX_NUM_MME);

    L3_PROV_REQ.peer_enb_data.num_peer_enb = OAM_ZERO;
    oam_memset(L3_PROV_REQ.peer_enb_data.eNB_id, 0, OAM_MAX_NUM_PEER_ENB);

    #ifdef ENDC_ENABLED
    /* MENB CHANGES - START */
    L3_PROV_REQ.peer_gnb_data.num_peer_enb = OAM_ZERO;
    oam_memset(L3_PROV_REQ.peer_gnb_data.gNB_id, OAM_ZERO, OAM_MAX_NUM_PEER_GNB);
    /* MENB CHANGES - END */
    #endif


    for(index = OAM_ZERO; index < OAM_S1AP_INFO.num_mme; ++index) {
        /* spr_21013_fix_start */
        p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,
                /* spr_21013_fix_end */
                "S1SigLinkPort");

        OAM_S1AP_INFO.mme_comm_info[index].port = oam_atoi((Char8*)p_temp);

        /* CSR 00070293 FIX START */
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    /* spr_21013_fix_start */
                    xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,"HBInterval"));
        /* spr_21013_fix_end */
        oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.
            s1apInfo.mme_comm_info[index].heart_beat_timer=lclTemp_value;

        /* CSR 00070293 FIX END */
    }
    /* SPR 10884 Fix Start */

    Char8 temp_arr[STR_LEN_128]={OAM_ZERO};

    /* OAM SPR 12495 Fix Start */  
    UInt16 counter = OAM_ZERO;
    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,
            /* spr_21013_fix_end */
            "X_VENDOR_RELOFMME");
	SInt8 remaining_mme = oam_prov_req.oam_l3_req.oam_s1ap_req.
                          s1ap_oam_prov.s1apInfo.num_mme;


    temp = strtok((char *)p_temp,",");
    while (temp != OAM_NULL)
    {
        temp_arr[counter]=oam_atoi(temp);
        counter++ ;
        remaining_mme--;
        temp = strtok(OAM_NULL,",");
    }

    while (remaining_mme > 0)
    {
        temp_arr[counter+1] = temp_arr[counter];
        remaining_mme--;
        counter++;
    }
    /* OAM SPR 12495 Fix End */  

    /* spr_21013_fix_start */
    tag_value = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,
            /* spr_21013_fix_end */
            "X_VENDOR_NUMSTREAM");

    temp2 = strtok_r((Char8*)tag_value, ",",(Char8 **)&tag_value);

    /* SPR 10884 Fix End */

    /* OAM SPR 12495 Fix Start */  
    if(temp2) {
        /* OAM SPR 12495 Fix End */  
        for(index = OAM_ZERO; index < OAM_S1AP_INFO.num_mme; ++index) {
            /* 
             * If rel_of_mme, or num_streams has lesser number of comma saperated
             * values then num_mme, last read entry will be mapped to all the 
             * remaining MME's after 1 to 1 mapping.
             */
            if(temp2) {
                lclTemp_value = oam_atoi((Char8*)temp2);
            }
            else {
                lclTemp_value =
                    OAM_S1AP_INFO.mme_comm_info[index - 1].num_streams;
            }

            if(lclTemp_value >= MIN_S1AP_NUMSTREAM &&
                    lclTemp_value <= MAX_S1AP_NUMSTREAM) {
                OAM_S1AP_INFO.mme_comm_info[index].num_streams =
                    lclTemp_value;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Value of numStream[%d] is %d and "
                        "range is from %d to %d",
                        index, lclTemp_value,
                        MIN_S1AP_NUMSTREAM,
                        MAX_S1AP_NUMSTREAM);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            /* OAM SPR 12495 Fix Start */  
            lclTemp_value = temp_arr[index];
            /* OAM SPR 12495 Fix End */  
            if(lclTemp_value >= MIN_S1AP_RELOFMME &&
                    lclTemp_value <= MAX_S1AP_RELOFMME) {
                OAM_S1AP_INFO.mme_comm_info[index].rel_of_mme =
                    lclTemp_value;
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Value of rel_of_mme[%d] is %d and "
                        "range is from %d to %d",
                        index, lclTemp_value,
                        MIN_S1AP_RELOFMME,
                        MAX_S1AP_RELOFMME);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            /* SPR 10884 Fix Start */
            /* OAM SPR 12495 Fix Start */  
            temp2 = strtok_r(OAM_NULL, ",",(Char8 **)&tag_value);
            /* OAM SPR 12495 Fix End */  
            /* SPR 10884 Fix End */
        }
    }


    OAM_S1AP_INFO.bitmask |= S1AP_OAM_SCTP_CONF_INFO_PRESENT;

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "MaxPathRetransmits");
    OAM_S1AP_INFO.s1ap_sctp_conf_param.path_max_retrans =
        oam_atoi((Char8*)p_temp);

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "MaxAssociationRetransmits");
    OAM_S1AP_INFO.s1ap_sctp_conf_param.assoc_max_retrans =
        oam_atoi((Char8*)p_temp);

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP, "RTOInitial");
    /* spr_21013_fix_end */

    OAM_S1AP_INFO.s1ap_sctp_conf_param.rto_initial =
        oam_atoi((Char8*)p_temp);

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP, "RTOMax");
    /* spr_21013_fix_end */

    OAM_S1AP_INFO.s1ap_sctp_conf_param.rto_max = oam_atoi((Char8*)p_temp);

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP, "RTOMin");
    /* spr_21013_fix_end */

    OAM_S1AP_INFO.s1ap_sctp_conf_param.rto_min = oam_atoi((Char8*)p_temp);

    if(OAM_S1AP_INFO.s1ap_sctp_conf_param.rto_max <
            OAM_S1AP_INFO.s1ap_sctp_conf_param.rto_min) {
		OAM_LOG(OAM, OAM_WARNING, "Value of RTOMax must be greater than or "
                "equal to the value of RTOMin");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP, "ValCookieLife");
    /* spr_21013_fix_end */
    OAM_S1AP_INFO.s1ap_sctp_conf_param.valid_cookie_life =
        oam_atoi((Char8*)p_temp);

    /* SPR-11423 Start */
    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "X_VENDOR_S1AP_DSCP_VALUE");

    if (oam_strcmp((Char8 *)p_temp, OAM_INVALID_STR))
    {
        OAM_S1AP_INFO.s1ap_sctp_conf_param.bitmask |= S1AP_OAM_DSCP_VALUE_PRESENT;
        OAM_S1AP_INFO.s1ap_sctp_conf_param.s1ap_dscp_value = oam_atoi((Char8*)p_temp);
    }
    /* SPR-11423 End */

    /* SPR-11897 FIX START */
    if (1 == oam_prov_req.num_cells_configured) {
        /* spr_21013_fix_start */
        tag_value = oam_get_xml_text_node_content(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3,
                /* spr_21013_fix_end */
                "HNBName", buf,
                OAM_TAG_VALUE_STR_MAX_LEN);

        if(tag_value) {
            oam_strncpy(
                    (Char8*)(OAM_S1AP_INFO.s1_setup_req_parameters.enb_name),
                    buf, MAX_ENB_NAME_STR_SIZE);
            OAM_S1AP_INFO.s1_setup_req_parameters.
                bitmask |= S1AP_OAM_ENB_NAME_PRESENT;
        }
    }

    /* SPR-11897 FIX END */

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_1,
            /* spr_21013_fix_end */
            "CellIdentity");
    lclTemp_value = oam_atoi((Char8*)p_temp);

    /* Spr 10784 Fix Start */
    oam_encode_eutran_cellidentity_into_bit_stream(temp3, lclTemp_value);
    /* Spr 10784 Fix End*/

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3,
            /* spr_21013_fix_end */
            "X_VENDOR_CELL_TYPE");
    lclTemp_value = oam_atoi((Char8*)p_temp);
    if(OAM_MACRO_ENB_TYPE == lclTemp_value) {
        OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
            presence_bitmask |= S1AP_OAM_MACRO_ENB_ID_PRESENT;
        /* Spr 11071 Fix Start */
        oam_memcpy(OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
                macro_enb_id.eNB_id, temp3, MACRO_ENB_ID_OCTET_SIZE);
        /* Spr 11071 Fix End */        
    }
    else {
        OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
            presence_bitmask |= S1AP_OAM_HOME_ENB_ID_PRESENT; 

        oam_memcpy(OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
                home_enb_id.eNB_id, temp3, HOME_ENB_ID_OCTET_SIZE);
    }
    /* SPR 23504/SES-341 Fix Start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EPC,
            "PLMNListNumberOfEntries");
    num_plmns = oam_atoi((Char8*)p_temp);

    for(index = OAM_ZERO; index < num_plmns; ++index) {
        tag_value = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PLMNList[index],
                "Enable");

        if(!oam_strcmp((Char8*)tag_value, "1") ||
                !oam_strcasecmp((Char8*)tag_value, "true")) {
            tag_value =
                oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PLMNList[index],
                        "PLMNID");
            oam_convert_plmnid((Char8 *)temp_plmnid1,tag_value);
            retVal = oam_encode_plmnid((Char8*)temp_plmnid1, tmp_plmnid);

            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_WARNING, "Failed to encode PLMNID[%s]",
                        tag_value);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            p_temp =
                oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PLMNList[index],
                        "IsPrimary");
            if(!oam_strcasecmp((Char8*)p_temp, "true") ||
                    !oam_strcmp((Char8*)p_temp, "1")) {
                oam_memcpy((void *)OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.plmn_identity.plmn_id,
                        tmp_plmnid,MAX_PLMN_ID_BYTES);
            }
        }
    }
    /* SPR 23504/SES-341 Fix End */

    p_temp = oam_xmlNodeGetContent(xml_struct_g.S1AP_procedural_timers,
            "S1_SetUp_Timer");
    lclTemp_value = oam_atoi((Char8*)p_temp);
    if(lclTemp_value >= OAM_S1AP_CONFIG_TIMER_MIN_VAL) {
        OAM_S1AP_INFO.s1_config_timer = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Incorrect value[%d] of S1_SetUp_Timer, "
                "should be greater than %d",
                lclTemp_value,
                OAM_S1AP_CONFIG_TIMER_MIN_VAL);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    p_temp = oam_xmlNodeGetContent(xml_struct_g.S1AP_procedural_timers,
            "reset_ep_Timer");
    lclTemp_value = oam_atoi((Char8*)p_temp);

    if(lclTemp_value >= OAM_S1AP_RESET_EP_TIMER_MIN_VAL) {
        OAM_S1AP_INFO.reset_ep_timer = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Incorrect value[%d] of reset_ep_Timer, "
                "should be greater than %d",
                lclTemp_value,
                OAM_S1AP_RESET_EP_TIMER_MIN_VAL);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    p_temp = oam_xmlNodeGetContent(xml_struct_g.S1AP_procedural_timers,
            "maxRetry");
    lclTemp_value = oam_atoi((Char8*)p_temp);
    OAM_S1AP_INFO.max_s1_config_retries = lclTemp_value;

    p_temp = oam_xmlNodeGetContent(xml_struct_g.S1AP_procedural_timers,
            "maxResetRetry");
    lclTemp_value = oam_atoi((Char8*)p_temp);
    OAM_S1AP_INFO.max_reset_retries = lclTemp_value;

    p_temp = oam_xmlNodeGetContent(xml_struct_g.S1AP_procedural_timers,
            "s1apPwsTimer");
    lclTemp_value = oam_atoi((Char8*)p_temp);

    if(lclTemp_value >= OAM_S1AP_PWS_TIMER_MIN_VAL) {
        OAM_S1AP_INFO.s1ap_pws_timer = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Incorrect value[%d] of s1apPwsTimer, "
                "should be greater than %d",
                lclTemp_value,
                OAM_S1AP_PWS_TIMER_MIN_VAL);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    p_temp = oam_xmlNodeGetContent(xml_struct_g.S1AP_procedural_timers,
            "s1apKillTimer");
    lclTemp_value = oam_atoi((Char8*)p_temp);

    if(lclTemp_value >= OAM_S1AP_KILL_TIMER_MIN_VAL) {
        OAM_S1AP_INFO.s1ap_kill_timer = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Incorrect value[%d] of s1apKillTimer, "
                "should be greater than %d",
                lclTemp_value,
                OAM_S1AP_KILL_TIMER_MIN_VAL);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    p_temp = oam_xmlNodeGetContent(xml_struct_g.S1AP,
            "mme_selection_algo");
    lclTemp_value = oam_atoi((Char8*)p_temp);
    if(oam_strcmp((Char8*)p_temp, OAM_INVALID_STR)) {
        if(MME_ROUND_ROBIN_ALGO == lclTemp_value ||
                MME_WEIGHT_FACTOR_ALGO == lclTemp_value) {
            OAM_S1AP_INFO.mme_selection_algo = lclTemp_value;
            OAM_S1AP_INFO.bitmask |= S1AP_OAM_MME_SELECTION_ALGO_PRESENT;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Incorrect value[%d] of mme_selection_algo, "
                    "should be %d or %d",
                    lclTemp_value, MME_ROUND_ROBIN_ALGO,
                    MME_WEIGHT_FACTOR_ALGO);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    p_temp = oam_xmlNodeGetContent(xml_struct_g.S1AP,
            "connRecDuration");

    if(oam_strcmp((Char8*)p_temp, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)p_temp);
        if(lclTemp_value >= OAM_S1_CONN_RECOV_DURATION_MIN_VAL) {
            OAM_S1AP_INFO.s1_conn_recovery_duration = lclTemp_value;
            OAM_S1AP_INFO.bitmask |=
                S1AP_OAM_S1_CONN_RECOVERY_DURATION_PRESENT;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Incorrect value[%d] of connRecDuration,"
                    " should be greater than %d",
                    lclTemp_value,
                    OAM_S1_CONN_RECOV_DURATION_MIN_VAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "X_VENDOR_INIT_MAX_ATTEMPTS");
    lclTemp_value = oam_atoi((Char8*)p_temp);

    OAM_S1AP_INFO.s1ap_sctp_conf_param.init_max_attempts = lclTemp_value;

    /* SPR 22055 FIXED START*/
    temp2 = (Char8*)oam_xmlNodeGetContent(xml_struct_g.health_monitoring,"healthMonitoringTimeInterval");
    if(oam_strcmp((Char8*)temp2, OAM_INVALID_STR))
    {    
        lclTemp_value = oam_atoi((Char8*)temp2);

        OAM_S1AP_INFO.s1ap_health_mon_time_int = lclTemp_value;
        OAM_S1AP_INFO.bitmask |= S1AP_OAM_S1_HEALTH_MONITORING_TIMER_PRESENT;
    }
    /* SPR 22055 FIXED END*/

    OAM_FUN_EXIT_TRACE();  
    return OAM_SUCCESS; 
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_cell_specific_s1ap_params
 *  DESCRIPTION      : This function is used to populate the l3 cell specific s1ap 
 parameters
 *  PARAMETERS       
 *      IN           : Pointers of XML_struct_cell_config & oam_rrm_cell_config_req_t
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_cell_specific_s1ap_params
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_rrm_cell_config_req_t *p_rrm_cellconfig
 )
{
    UInt8 cnt = 0;
    xmlChar *tag_value = OAM_NULL;
    oam_return_et retVal = OAM_SUCCESS;
    SInt32 num_plmns = 0;
    UInt8 tmp_plmnid[MAX_PLMN_ID_BYTES] = {0};
    UInt8 temp_plmnid1[OAM_SEVEN] = {0};
    UInt32 plmn_cnt      = OAM_ZERO;
    UInt8 index = 0;

    supp_ta_list_t *p_tai_list =
        &OAM_S1AP_INFO.s1_setup_req_parameters.supp_ta_list;

    for(cnt = 0; cnt < p_tai_list->num_supported_tais; ++cnt) {
        if(!oam_memcmp(p_rrm_cellconfig->epc_info.epc_params.
                    general_epc_params.tac,
                    p_tai_list->supp_tais[cnt].tac,
                    TAC_OCTET_SIZE)) {
            break;
        }
    }

    if(cnt == p_tai_list->num_supported_tais) {
        /* SPR 11071 Fix Start */
        oam_memcpy(p_tai_list->supp_tais[cnt].tac,
                p_rrm_cellconfig->epc_info.epc_params.
                general_epc_params.tac, TAC_OCTET_SIZE);
        /* SPR 11071 Fix End */
        ++p_tai_list->num_supported_tais;
    }

    p_temp = oam_xmlNodeGetContent(p_cell_spec_params->EPC,
            "PLMNListNumberOfEntries");
    num_plmns = oam_atoi((Char8*)p_temp);

    for(index = OAM_ZERO; index < num_plmns; ++index) {
        if(MAX_BC_PLMN == p_tai_list->supp_tais[cnt].bc_plmn_list.
                num_bplmn) {
			OAM_LOG(OAM, OAM_WARNING, "PLMNList size exceeds the max size of "
                    "%d, skipping other PLMNS", MAX_BC_PLMN);
            break;
        }

        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->PLMNList[index],
                "Enable");

        if(!oam_strcmp((Char8*)tag_value, "1") ||
                !oam_strcasecmp((Char8*)tag_value, "true")) {
            tag_value =
                oam_xmlNodeGetContent(p_cell_spec_params->PLMNList[index],
                        "PLMNID");
            oam_convert_plmnid((Char8 *)temp_plmnid1,tag_value);
            retVal = oam_encode_plmnid((Char8*)temp_plmnid1, tmp_plmnid);

            if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_WARNING, "Failed to populate PLMNID[%s]",
                        tag_value);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            for(plmn_cnt = 0;
                    plmn_cnt < p_tai_list->supp_tais[cnt].bc_plmn_list.num_bplmn;
                    ++plmn_cnt) {
                if(!oam_memcmp(tmp_plmnid, p_tai_list->supp_tais[cnt].
                            bc_plmn_list.plmn_identity[plmn_cnt].plmn_id,
                            MAX_PLMN_ID_BYTES)) {
                    break;
                }
            }

            if(p_tai_list->supp_tais[cnt].bc_plmn_list.num_bplmn
                    == plmn_cnt) {
                oam_memcpy(p_tai_list->supp_tais[cnt].bc_plmn_list.
                        plmn_identity[plmn_cnt].plmn_id, tmp_plmnid,
                        MAX_PLMN_ID_BYTES);
                ++p_tai_list->supp_tais[cnt].bc_plmn_list.num_bplmn;
            }
            else {
                continue;
            }
            /* SPR 23504/SES-341 Fix +- */
        }
    }

    if(p_rrm_cellconfig->operator_info.sib_2_info.radio_res_config_common_sib.
            bitmask & RRM_OAM_DEFAULT_PAGING_CYCLE_PRESENT) {
        OAM_S1AP_INFO.s1_setup_req_parameters.default_paging_drx =
            p_rrm_cellconfig->operator_info.sib_2_info.
            radio_res_config_common_sib.default_paging_cycle;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory parameter DEFAULT_PAGING_CYCLE "
                "could not be read.");
        retVal = OAM_FAILURE;
    }

    if(RRM_OAM_ACCESS_MODE_OPEN != p_rrm_cellconfig->access_mgmt_params.
            access_mode) {
        cnt = OAM_S1AP_INFO.s1_setup_req_parameters.csg_id_list.num_csg_ids;
        oam_memcpy(OAM_S1AP_INFO.s1_setup_req_parameters.csg_id_list.
                csg_ids[cnt].csg_id,
                p_rrm_cellconfig->access_mgmt_params.csg_id,
                CSG_ID_OCTET_SIZE);
        ++OAM_S1AP_INFO.s1_setup_req_parameters.csg_id_list.num_csg_ids;

        OAM_S1AP_INFO.s1_setup_req_parameters.
            bitmask |= S1AP_OAM_CSG_ID_LIST_PRESENT;
    }

    return retVal;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_device_specific_x2ap_params
 *  DESCRIPTION      : This function is used to populate the device specific
 *  		       l3 x2ap parameters
 *  PARAMETERS       :
 *      IN           : NONE
 *                   :
 *      OUT          : NONE
 *                   :
 *                   :
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_device_specific_x2ap_params(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

#if !defined  (OAM_SON_ENABLE) || defined (ENDC_ENABLED)
    UInt32 counter = OAM_ZERO;
    UInt32 index = OAM_ZERO;
    Char8* temp2 = OAM_NULL;
#endif

#ifdef ENDC_ENABLED
    U8 lclTemp_value_1 = OAM_ZERO;
#endif

    oam_return_et retVal = OAM_SUCCESS;
    Char8 * tag_value = OAM_NULL;
    /* SPR 19703 changes start */
    U8 x2ap_log_level = 0;
    /* SPR 19703 changes end */


    oam_memcpy(X2AP_PROV_REQ.x2ap_info.global_enb_id.plmn_identity.plmn_id,
            OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.
            plmn_identity.plmn_id, MAX_PLMN_ID_BYTES);


    if(OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
            presence_bitmask & S1AP_OAM_MACRO_ENB_ID_PRESENT) {
        X2AP_PROV_REQ.x2ap_info.global_enb_id.enb_id.
            presence_bitmask |= X2AP_OAM_MACRO_ENB_ID_PRESENT;

        oam_memcpy(X2AP_PROV_REQ.x2ap_info.global_enb_id.enb_id.
                macro_enb_id.eNB_id,
                OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
                macro_enb_id.eNB_id, MACRO_ENB_ID_OCTET_SIZE);
    }
    else {
        X2AP_PROV_REQ.x2ap_info.global_enb_id.enb_id.
            presence_bitmask |= X2AP_OAM_HOME_ENB_ID_PRESENT;


        oam_memcpy(X2AP_PROV_REQ.x2ap_info.global_enb_id.enb_id.
                home_enb_id.eNB_id,
                OAM_S1AP_INFO.s1_setup_req_parameters.gb_enb_id.enb_id.
                home_enb_id.eNB_id,
                HOME_ENB_ID_OCTET_SIZE); 
    }
    /*Multiple support activity Ends here*/

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.X2AP,
            "logLevel");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        /* SPR 19703 changes start */
        x2ap_log_level = oam_atoi(tag_value);

        /* SPR 20007 : CID 110653 fix start */
        if(x2ap_log_level <= MAX_X2AP_LOGLEVEL) {
            /* SPR 20007 : CID 110653 fix end */
            X2AP_PROV_REQ.x2ap_info.log_level = x2ap_log_level;
            OAM_LOG(OAM, OAM_INFO,"Populated value of X2AP logLevel: %d, tag_value %d",
                    x2ap_log_level,oam_atoi(tag_value));
            /* SPR 19703 changes end */
        }
        else {
            OAM_LOG(OAM, OAM_WARNING, "Value of logLevel is %d and range "
                    /* SPR 19703 changes start */
                    "is from %d to %d", x2ap_log_level,
                    /* SPR 19703 changes end */
                    MIN_X2AP_LOGLEVEL,
                    MAX_X2AP_LOGLEVEL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
        OAM_LOG(OAM, OAM_WARNING, "Mandatory tag logLevel not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    /* coverity 41160 */
//#ifndef OAM_SON_ENABLE //rm for support x2ap
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.X2AP,
            "numPeereNB");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if (MAX_PEER_ENB < lclTemp_value) {
			OAM_LOG(OAM, OAM_WARNING, "Value of numPeereNB: %d is out"
                    " of range (0-%d)", lclTemp_value, MAX_PEER_ENB);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        X2AP_PROV_REQ.x2ap_info.num_peer_enb = lclTemp_value;

        for(index = 0; index < X2AP_PROV_REQ.x2ap_info.num_peer_enb; ++index) {
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    xml_struct_g.peer_eNB_CommInfo[index],
                    "IPAddr");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                counter = OAM_ZERO;
                temp2 = strtok(tag_value, ",");

                while(temp2 && counter < MAX_NUM_IP_ADDR) {
                    oam_strncpy((Char8*)X2AP_PROV_REQ.x2ap_info.
                            peer_enb_comm_info[index].ip_addr[counter].ip_addr,
                            temp2,
                            MAX_X2AP_IP_ADDRESS_LENGTH);
                    ++counter ;
                    temp2 = strtok(NULL, ",");
                }
            }


            X2AP_PROV_REQ.x2ap_info.peer_enb_comm_info[index].
                num_ip_addr = counter;
			/*add by wood begin*/
			if (counter){
				X2AP_PROV_REQ.x2ap_info.peer_enb_comm_info[index].
					bitmask |= X2_ENB_COMM_INFO_IPV4_NUM_ADDR_PRESENT;
				X2AP_PROV_REQ.x2ap_info.peer_enb_comm_info[index].
					bitmask |= X2_ENB_COMM_INFO_IPV4_IP_ADDR_PRESENT;
			}
			/*add by wood end*/
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    xml_struct_g.peer_eNB_CommInfo[index],
                    "Port");

            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                if(lclTemp_value >= MIN_X2AP_PORT &&
                        lclTemp_value <= MAX_X2AP_PORT) {         
                    X2AP_PROV_REQ.x2ap_info.peer_enb_comm_info[index].
                        port = lclTemp_value;   
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "Value of Port is %d and range is from %d to %d",
                            lclTemp_value, MIN_X2AP_PORT, MAX_X2AP_PORT);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }   
            }

            /* Ipv6 Support Start*/ 
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    xml_struct_g.peer_eNB_CommInfo[index],
                    "numIPv6Addr");

            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                counter = OAM_ZERO;

                if(lclTemp_value >= MIN_X2AP_NUMIPADDR &&
                        lclTemp_value <= MAX_X2AP_NUMIPADDR) {
                    tag_value = (Char8*)oam_xmlNodeGetContent(
                            xml_struct_g.peer_eNB_CommInfo[index],
                            "IPv6Addr");

                    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                        temp2 = strtok(tag_value, ",");
                        /* SPR 18741 Fix Start */
                        while(temp2 && counter < (UInt32)lclTemp_value &&
                                counter < MAX_NUM_IP_ADDR) {
                            /* SPR 18741 Fix End */
                            oam_strncpy((Char8*)X2AP_PROV_REQ.x2ap_info.
                                    peer_enb_comm_info[index].
                                    ipv6_addr[counter].ipv6_addr,
                                    temp2,
                                    MAX_X2AP_IPV6_ADDRESS_LENGTH);
                            ++counter;
                            temp2 = strtok(NULL, ",");
                        }
                    }

                    if(counter) {
                        X2AP_PROV_REQ.x2ap_info.peer_enb_comm_info[index].
                            num_ipv6_addr = counter;
                        X2AP_PROV_REQ.x2ap_info.peer_enb_comm_info[index].
                            bitmask |= X2_ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT;       
                        X2AP_PROV_REQ.x2ap_info.peer_enb_comm_info[index].
                            bitmask |= X2_ENB_COMM_INFO_IPV6_IP_ADDR_PRESENT;
                    }
                }
            }
            /* Ipv6 Support End*/
        }
    }
//#endif //rm for support x2ap

    #ifdef ENDC_ENABLED
    /* MENB CHNAGES - START */
    tag_value =(Char8*)oam_xmlNodeGetContent(
                              xml_struct_g.EN_DC_Params,"ENDCEnabled");
    if(oam_strcmp(tag_value, OAM_INVALID_STR))
    {
        lclTemp_value = oam_atoi(tag_value);
        if(lclTemp_value)
        {

            tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.X2AP,
                    "numPeergNB");

            if ( oam_strcmp(tag_value, OAM_INVALID_STR) )
            {
                lclTemp_value = oam_atoi(tag_value);

                if ( MAX_PEER_GNB < lclTemp_value )
                {
                    OAM_LOG(OAM, OAM_WARNING, "Value of numPeergNB: %d is out"
                            " of range (0-%d)", lclTemp_value, MAX_PEER_GNB);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                X2AP_PROV_REQ.x2ap_info.num_peer_gnb = lclTemp_value;

                U8 default_sgnb_found = 0;
                for ( index = OAM_ZERO; index < X2AP_PROV_REQ.x2ap_info.num_peer_gnb; ++index )
                {
                    tag_value = (Char8*)oam_xmlNodeGetContent(
                            xml_struct_g.peer_gNB_CommInfo[index],
                            "IPAddr");
                    if ( oam_strcmp(tag_value, OAM_INVALID_STR) )
                    {
                        counter = OAM_ZERO;
                        temp2 = strtok(tag_value, ",");

                        while ( temp2 && counter < MAX_NUM_IP_ADDR )
                        {
                            oam_strncpy((Char8*)X2AP_PROV_REQ.x2ap_info.
                                    peer_gnb_comm_info[index].ip_addr[counter].ip_addr,
                                    temp2,
                                    MAX_X2AP_IP_ADDRESS_LENGTH);
                            ++counter;
                            temp2 = strtok(NULL, ",");
                        }
                    }

                    X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                        num_ip_addr = counter;

                    if ( counter > 0 )
                    {
                        X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                            bitmask |= X2_ENB_COMM_INFO_IPV4_NUM_ADDR_PRESENT;       
                        X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                            bitmask |= X2_ENB_COMM_INFO_IPV4_IP_ADDR_PRESENT;
                    }

                    tag_value = (Char8*)oam_xmlNodeGetContent(
                            xml_struct_g.peer_gNB_CommInfo[index],
                            "Port");

                    if ( oam_strcmp(tag_value, OAM_INVALID_STR) )
                    {
                        lclTemp_value = oam_atoi(tag_value);
                        if ( lclTemp_value >= MIN_X2AP_PORT &&
                                lclTemp_value <= MAX_X2AP_PORT )
                        {         
                            X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                                port = lclTemp_value;   
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Value of Port is %d and range is from %d to %d",
                                    lclTemp_value, MIN_X2AP_PORT, MAX_X2AP_PORT);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }   
                    }

                    tag_value = (Char8*)oam_xmlNodeGetContent(
                            xml_struct_g.peer_gNB_CommInfo[index],
                            "numIPv6Addr");

                    if ( oam_strcmp(tag_value, OAM_INVALID_STR) )
                    {
                        lclTemp_value = oam_atoi(tag_value);
                        counter = OAM_ZERO;

                        if ( lclTemp_value >= MIN_X2AP_NUMIPADDR &&
                                lclTemp_value <= MAX_X2AP_NUMIPADDR )
                        {
                            tag_value = (Char8*)oam_xmlNodeGetContent(
                                    xml_struct_g.peer_gNB_CommInfo[index],
                                    "IPv6Addr");

                            if ( oam_strcmp(tag_value, OAM_INVALID_STR) )
                            {
                                temp2 = strtok(tag_value, ",");
                                while ( temp2 && counter < (UInt32)lclTemp_value &&
                                        counter < MAX_NUM_IP_ADDR )
                                {
                                    oam_strncpy((Char8*)X2AP_PROV_REQ.x2ap_info.
                                            peer_gnb_comm_info[index].
                                            ipv6_addr[counter].ipv6_addr,
                                            temp2,
                                            MAX_X2AP_IPV6_ADDRESS_LENGTH);
                                    ++counter;
                                    temp2 = strtok(NULL, ",");
                                }
                            }

                            if ( counter )
                            {
                                X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                                    num_ipv6_addr = counter;
                                X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                                    bitmask |= X2_ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT;       
                                X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                                    bitmask |= X2_ENB_COMM_INFO_IPV6_IP_ADDR_PRESENT;
                            }
                        }
                    }
                    tag_value = (Char8*)oam_xmlNodeGetContent(
                            xml_struct_g.peer_gNB_CommInfo[index],
                            "default_gNB");

                    if ( oam_strcmp(tag_value, OAM_INVALID_STR) )
                    {
                        lclTemp_value = oam_atoi(tag_value);

                        lclTemp_value_1 = oam_atoi((const char *)oam_xmlNodeGetContent(
                                    xml_struct_g.EN_DC_Params,"is_MaSgnbAddition"));

                        if ( ( OAM_ZERO == lclTemp_value ) && ( OAM_ZERO == lclTemp_value_1 ) )
                        {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Tag value of default_sgnb should be one  check next index");
                        }
                        else
                        {
                            default_sgnb_found++;
                            X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                                default_sgnb = lclTemp_value;
                            X2AP_PROV_REQ.x2ap_info.peer_gnb_comm_info[index].
                                bitmask |= X2_ENB_COMM_INFO_DEFAULT_SGNB_PRESENT; 
                        }
                    }
                }
                lclTemp_value_1 = oam_atoi((const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"is_MaSgnbAddition"));
                if( OAM_ZERO == lclTemp_value_1 )
                {
                    if ( default_sgnb_found < 1 )
                    {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Tag value of default_sgnb should be one ");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                    else if ( default_sgnb_found > 1 ) 
                    {
                        OAM_LOG(OAM, OAM_ERROR,
                                "More than one default_sgnb present ");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
            }
        }
    }
    /* MENB CHNAGES - END */
    #endif

    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "HBInterval");

    lclTemp_value = oam_atoi(tag_value);
    X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.
        hbinterval = lclTemp_value;

    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "MaxPathRetransmits");

    lclTemp_value = oam_atoi(tag_value);
    X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.
        pathmaxrxt = lclTemp_value;

    /* SPR 16045 Fix Start */
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,"X_VENDOR_X2AP_NUMSTREAM"));
    /* spr_21013_fix_end */

    X2AP_PROV_REQ.x2ap_info.
        conf_param.sctp_conf_param.init_max_instreams=lclTemp_value;

    X2AP_PROV_REQ.x2ap_info.
        conf_param.sctp_conf_param.init_num_ostreams=lclTemp_value;
    /* SPR 16045 Fix End */

    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "X_VENDOR_INIT_MAX_ATTEMPTS");

    lclTemp_value = oam_atoi(tag_value);
    X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.
        init_max_attempts = lclTemp_value;

    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "X_VENDOR_INIT_MAX_INIT_TIMEOUT");

    lclTemp_value = oam_atoi(tag_value);
    X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.
        init_max_init_timeo = lclTemp_value;

    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "RTOInitial");

    lclTemp_value = oam_atoi(tag_value);
    X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.
        rto_initial = lclTemp_value;

    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "RTOMax");

    lclTemp_value = oam_atoi(tag_value);
    X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.
        rto_max = lclTemp_value;

    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "RTOMin");

    lclTemp_value = oam_atoi(tag_value);
    X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.
        rto_min = lclTemp_value; 


    /* SPR-11423 Start */
    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP,
            /* spr_21013_fix_end */
            "X_VENDOR_X2AP_DSCP_VALUE");

    if (oam_strcmp(tag_value, OAM_INVALID_STR))
    {
        lclTemp_value=oam_atoi(tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.bitmask |= X2AP_OAM_DSCP_VALUE_PRESENT;
        X2AP_PROV_REQ.x2ap_info.conf_param.sctp_conf_param.x2ap_dscp_value=lclTemp_value;
    }
    /* SPR-11423 End */

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "sctp_connect_time_val");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            sctp_connect_tim_val = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag sctp_connect_time_val not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_guard_timers,
            "x2ap_csi_guard_time_val");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_csi_guard_tim_val = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag x2ap_csi_guard_time_val not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "x2ap_time_to_wait_index");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_time_to_wait_index = lclTemp_value;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            bitmask |= X2AP_TIME_TO_WAIT_INDEX_PRESENT;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "x2ap_setup_retry_time_val");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);
        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_setup_retry_tim_val = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag x2ap_setup_retry_time_val not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "sctp_connect_retry_cnt");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            sctp_connect_retry_cnt = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag sctp_connect_retry_cnt not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "x2ap_setup_retry_cnt");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_setup_retry_cnt = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag x2ap_setup_retry_cnt not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "enb_config_update_retry_cnt");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            eNB_Config_Update_retry_cnt = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag x2ap_setup_retry_cnt not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    SInt32 time_to_wait_retry_cnt = 0;
    SInt32 time_to_wait_offset = 0;
    SInt32 retry_timer_val = 0;

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "eNB_Config_Update_retry_timer_val");
    retry_timer_val = oam_atoi(tag_value);

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "eNB_Config_Update_time_to_wait_retry_cnt");
    time_to_wait_retry_cnt = oam_atoi(tag_value);


    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "eNB_Config_Update_time_to_wait_offset");
    time_to_wait_offset = oam_atoi(tag_value);


    if(retry_timer_val != OAM_INVALID_VALUE && 
            time_to_wait_retry_cnt != OAM_INVALID_VALUE &&
            time_to_wait_offset != OAM_INVALID_VALUE) {
        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            eNB_Config_Update_retry_timer_val = retry_timer_val;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            eNB_Config_Update_time_to_wait_retry_cnt = time_to_wait_retry_cnt;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            eNB_Config_Update_time_to_wait_offset = time_to_wait_offset;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            bitmask |= X2AP_ENB_CFG_INFO_PRESENT;
    }

    SInt32 retry_cnt = 0;
    SInt32 guard_tim_val = 0;

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "x2ap_enb_reset_retry_cnt");
    retry_cnt = oam_atoi(tag_value);

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_guard_timers,
            "x2ap_enb_reset_guard_tim_val");
    guard_tim_val = oam_atoi(tag_value);

    if(retry_cnt != OAM_INVALID_VALUE && 
            guard_tim_val != OAM_INVALID_VALUE) {
        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_enb_reset_retry_cnt = retry_cnt;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_enb_reset_guard_tim_val = guard_tim_val;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            bitmask |= X2AP_RESET_CFG_INFO_PRESENT;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_guard_timers,
            "x2ap_rsu_enb_guard_tim_val");
    lclTemp_value = oam_atoi(tag_value);

    X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
        x2ap_rsu_enb_guard_tim_val = lclTemp_value;     

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_guard_timers,
            "x2ap_rsu_rrm_guard_tim_val");
    lclTemp_value = oam_atoi(tag_value);

    X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
        x2ap_rsu_rrm_guard_tim_val = lclTemp_value;

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "x2ap_cell_activation_retry_cnt");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_cell_activation_retry_cnt = lclTemp_value;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            bitmask |= X2AP_CELL_ACTIVATION_TIMER_INFO_PRESENT;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.X2AP_guard_timers,
            "x2ap_cell_activation_guard_tim_val");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_cell_activation_guard_tim_val = lclTemp_value;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            bitmask |= X2AP_CELL_ACTIVATION_TIMER_INFO_PRESENT;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.X2AP_procedural_timers,
            "x2ap_mobility_setting_change_retry_cnt");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_mobility_setting_change_retry_cnt = lclTemp_value;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            bitmask |= X2AP_MOBILITY_CHANGE_INFO_PRESENT;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.X2AP_guard_timers,
            "x2ap_mobility_setting_change_guard_tim_val");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_mobility_setting_change_guard_tim_val = lclTemp_value;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            bitmask |= X2AP_MOBILITY_CHANGE_INFO_PRESENT;
    }
    /* SPR 22055 FIXED START*/

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.health_monitoring,
            "healthMonitoringTimeInterval");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            x2ap_health_mon_time_int = lclTemp_value;

        X2AP_PROV_REQ.x2ap_info.conf_param.timer_conf_info.
            bitmask |= X2AP_OAM_X2_HEALTH_MONITORING_TIMER_PRESENT;
    }
    /* SPR 22055 FIXED END*/
    OAM_FUN_EXIT_TRACE();
    return retVal; 
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_cell_specific_x2ap_params
 *  DESCRIPTION      : This function is used to populate the l3 cell specific x2ap 
 parameters
 *  PARAMETERS       
 *      IN           : Pointers of XML_struct_cell_config, rrc_oam_sector_info_t,
 oam_rrm_cell_config_req_t & x2apOam_srvd_cell_arry_t
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          : OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 *******************************************************************************/

oam_return_et
    oam_populate_cell_specific_x2ap_params
(
 XML_struct_cell_config         *p_cell_spec_params,
 rrc_oam_sector_info_t          *p_rrc_cell_info,
 oam_rrm_cell_config_req_t      *p_rrm_cellconfig,
 x2apOam_srvd_cell_arry_t       *p_cell_info
 )
{
    UInt32 num_entries = 0;
    UInt8 temp3[HOME_ENB_ID_OCTET_SIZE] = {0};
    Char8 * tag_value = OAM_NULL;
    UInt32 counter = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;
    UInt8 temp_plmnid[OAM_SEVEN] = {0};

    /*SPR 16372 fix start*/
    UInt32 serv_earfcn = 0;
    UInt32 nbr_earfcn  = 0;
    UInt32 nbr_pci     = 0;
    /*  coverity 94780 fix start */
    oam_access_mode_et calculated_access_mode;
    /*  coverity 94780 fix end */
    /*SPR 16372 fix stop*/
    /* SPR 18930  FIX START */
    UInt8 lte_cell_enable = OAM_ZERO;  
    UInt8 lte_cell_mi = OAM_ZERO;
    UInt8 lte_count = OAM_ZERO;
    /* SPR 18930  FIX END */

    p_cell_info->served_cell_info.prach_config.root_sequence_index =
        p_rrm_cellconfig->ran_info.physical_layer_params.
        physical_layer_param_prach.root_sequence_index;

    p_cell_info->served_cell_info.prach_config.zero_correlation_zone_config
        = p_rrm_cellconfig->ran_info.physical_layer_params.
        physical_layer_param_prach.zero_correlation_zone_config;

    p_cell_info->served_cell_info.prach_config.prach_frequency_offset =
        p_rrm_cellconfig->ran_info.physical_layer_params.
        physical_layer_param_prach.frequency_offset;

    p_cell_info->served_cell_info.prach_config.high_speed_flag =
        p_rrm_cellconfig->ran_info.physical_layer_params.
        physical_layer_param_prach.high_speed_flag;

    p_cell_info->served_cell_info.
        bitmask |= X2AP_PRACH_CONFIG_INFO_PRESENT;

    p_cell_info->served_cell_info.prach_config.prach_config_index =
        p_rrm_cellconfig->ran_info.physical_layer_params.
        physical_layer_param_prach.configuration_index;

    p_cell_info->served_cell_info.prach_config.
        bitmask |= X2AP_PRACH_CONFIG_INDEX_PRESENT;

    p_cell_info->served_cell_info.pci = p_rrm_cellconfig->ran_info.rf_params.
        rf_configurations.phy_cell_id;

    p_cell_info->served_cell_info.cell_id = p_rrc_cell_info->cell_index;

    oam_memcpy(p_cell_info->served_cell_info.track_area_code.tac,
            p_rrm_cellconfig->epc_info.epc_params.general_epc_params.tac,
            MAX_TAC_BYTES);

    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->EPC,
            "PLMNListNumberOfEntries");
    lclTemp_value = oam_atoi(tag_value);
    p_cell_info->served_cell_info.broadcast_plmn_info.
        num_bcast_plmn_id = lclTemp_value;

    for(counter = 0; counter < (UInt16)lclTemp_value; ++counter) {
        tag_value = (Char8*)oam_xmlNodeGetContent(
                p_cell_spec_params->PLMNList[counter],
                "Enable");

        if(!oam_strcmp(tag_value, "1") ||
                !oam_strcasecmp(tag_value, "true")) {
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->PLMNList[counter],
                    "PLMNID");
            oam_convert_plmnid((Char8*)temp_plmnid,tag_value); 

            oam_encode_plmnid((Char8 *)temp_plmnid,
                    p_cell_info->served_cell_info.broadcast_plmn_info.
                    plmn_identity[counter].plmn_id);
        }
    }

    /* spr_21013_fix_start */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,
            /* spr_21013_fix_end */
            "DuplexMode");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        /* 1 for FDD and 2 for TDD */
        if(!oam_strcmp(tag_value, "FDDMode")) {
            SInt32 earfcn_u = 0;
            SInt32 earfcn_d = 0;

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,
                    "EARFCNUL");
            earfcn_u = oam_atoi(tag_value);
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,
                    "EARFCNDL");
            earfcn_d = oam_atoi(tag_value);
            if(earfcn_u != OAM_INVALID_VALUE && earfcn_d != OAM_INVALID_VALUE) {
                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.bitmask |= X2AP_EUTRA_MODE_FDD;

                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.fdd_info.ul_earfcn.earfcn = earfcn_u;

                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.fdd_info.dl_earfcn.earfcn = earfcn_d;

                /*SPR 16372 fix start*/
                serv_earfcn = earfcn_d; 
                /*SPR 16372 fix stop*/

                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_cell_spec_params->RF_1,
                        "DLBandwidth");

                lclTemp_value = oam_xml_search_string_to_integer(tag_value,
                        DLBandwidth,
                        DL_BANDWIDTH_COUNT);
                if(lclTemp_value >= MIN_DLBANDWIDTH &&
                        lclTemp_value <= MAX_DLBANDWIDTH) {
                    p_cell_info->served_cell_info.choice_eutra_mode.
                        choice_eutra_mode.fdd_info.
                        dl_trnsmission_bdwidth = lclTemp_value;
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "DLBandwidth value: %s is out of range", tag_value);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_cell_spec_params->RF_1,
                        "ULBandwidth");

                lclTemp_value = oam_xml_search_string_to_integer(tag_value,
                        UlBandwidth,
                        UL_BANDWIDTH_COUNT);

                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.fdd_info.
                    ul_trnsmission_bdwidth = lclTemp_value;
            }
        }
        else if(!oam_strcmp(tag_value, "TDDMode")) {
            SInt32 transmission_bandwidth = 0;
            SInt32 SubFrameAssignment = 0;
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,
                    "DLBandwidth");
            transmission_bandwidth = oam_atoi(tag_value);

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->TDDFrame,
                    "SubFrameAssignment");
            SubFrameAssignment = oam_atoi(tag_value);
            if(transmission_bandwidth != OAM_INVALID_VALUE &&
                    SubFrameAssignment != OAM_INVALID_VALUE) {
                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.bitmask |= X2AP_EUTRA_MODE_TDD;

                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_cell_spec_params->RF_1,
                        "EARFCNDL");
                lclTemp_value = oam_atoi(tag_value);
                /*SPR 16372 fix start*/
                serv_earfcn = lclTemp_value; 
                /*SPR 16372 fix stop*/

                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.tdd_info.earfcn.earfcn = lclTemp_value;
                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.tdd_info.
                    trnsmission_bdwidth = transmission_bandwidth;

                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.tdd_info.
                    subframe_assn = SubFrameAssignment;

                tag_value = (Char8*)oam_xmlNodeGetContent(
                        p_cell_spec_params->TDDFrame,
                        "SpecialSubframePatterns");
                lclTemp_value = oam_atoi(tag_value);

                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.tdd_info.special_subframe_info.
                    special_subframe_patterns = lclTemp_value;

                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.tdd_info.
                    special_subframe_info.dl_cp = OAM_DL_CP;

                p_cell_info->served_cell_info.choice_eutra_mode.
                    choice_eutra_mode.tdd_info.
                    special_subframe_info.ul_cp = OAM_UL_CP;
            }
        }
    }

    /* START SPR_7554_FIX */

    tag_value = (Char8*)oam_xmlNodeGetContent(
            p_cell_spec_params->AntennaInfo,
            "AntennaPortsCount");
    lclTemp_value = oam_xml_search_integer_to_integer(tag_value,
            NUM_ANTENNA_PORT[0],
            NUM_ANTENNA_COUNT);
    if(lclTemp_value >= MIN_NUMANTENNA && 
            lclTemp_value <= MAX_NUMANTENNA) {
        p_cell_info->served_cell_info.num_antenna_port = lclTemp_value;

        p_cell_info->served_cell_info.bitmask |= NUM_ANTENNA_PORT_BITMASK;
    }

    /* END SPR_7554_FIX */


    /* START RT  SPR_8709_FIX */
    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->NeighborList,
            "LTECellNumberOfEntries");
    num_entries = oam_atoi(tag_value);

    /* SPR 18930  FIX START */
    for(counter = 0; counter < num_entries; ++counter) {

        lte_cell_enable = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[counter],"Enable"));
        lte_cell_mi = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[counter],"MustInclude"));

        if ((OAM_TRUE == lte_cell_enable)&& (OAM_TRUE == lte_cell_mi))
        { 
            /* SPR 18930  FIX END */
            /*PLMN Changes Starts here*/
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[counter],
                    "PLMNID");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                oam_convert_plmnid((Char8 *)temp_plmnid,tag_value);
                oam_encode_plmnid((Char8 *)temp_plmnid,
                        p_cell_info->nbour_cell_info.
                        neighbour_info_arr[counter].ecgi.plmn_identity.plmn_id);
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Mandatory param LTECell[%d].PLMNID is missing",
                        counter);
                retVal = OAM_FAILURE;
                break;
            }
            /*PLMN Changes Ends here*/

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[counter],
                    "CID");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);

                /* Spr 10784 Fix Start */
                oam_encode_eutran_cellidentity_into_bit_stream(temp3, lclTemp_value);
                /* Spr 10784 Fix End*/
                oam_memcpy(p_cell_info->nbour_cell_info.
                        neighbour_info_arr[counter].ecgi.eutran_cell_id,
                        temp3,
                        HOME_ENB_ID_OCTET_SIZE);
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Mandatory param LTECell[%d].CID is missing",
                        counter);
                retVal = OAM_FAILURE;
                break;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[counter],
                    "PhyCellID");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);

                p_cell_info->nbour_cell_info.neighbour_info_arr[counter].
                    pci = lclTemp_value;

                /*SPR 16372 fix start*/
                nbr_pci = lclTemp_value;
                /*SPR 16372 fix stop*/
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Mandatory param LTECell[%d].PhyCellID is missing",
                        counter);
                retVal = OAM_FAILURE;
                break;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[counter],
                    "EUTRACarrierARFCN");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);

                p_cell_info->nbour_cell_info.neighbour_info_arr[counter].
                    earfcn.earfcn = lclTemp_value;

                /*SPR 16372 fix start*/
                nbr_earfcn = lclTemp_value;
                /*SPR 16372 fix stop*/
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "Mandatory param LTECell[%d].EUTRACarrierARFCN is missing",
                        counter);
                retVal = OAM_FAILURE;
                break;
            }

            /*SPR 16372 fix start*/
            lclTemp_value = oam_atoi((char*)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],
                        "X_VENDOR_ACCESS_MODE"));
            if(lclTemp_value != OAM_MINUS_FIVE_HUNDRED)
            {
                if(serv_earfcn == nbr_earfcn)
                {
                    calculated_access_mode = oam_init_nbr_cell_access_mode_pci_validation(
                            p_cell_spec_params,
                            OAM_INTRA_FREQ_NBR_CELL, 
                            nbr_earfcn,
                            nbr_pci,
                            lclTemp_value);
                }
                else
                {
                    calculated_access_mode = oam_init_nbr_cell_access_mode_pci_validation(
                            p_cell_spec_params,
                            OAM_INTER_FREQ_NBR_CELL, 
                            nbr_earfcn,
                            nbr_pci,
                            lclTemp_value);
                }
                if (lclTemp_value != (SInt32)calculated_access_mode)
                {
                    lclTemp_value =  calculated_access_mode;
                }
            }
            else
            {
                continue;
            }
            tag_value = (char*)oam_xmlNodeGetContent(p_cell_spec_params->LTECell[counter],"X_VENDOR_CSGID");
            if( !oam_strcmp((Char8*)tag_value, OAM_INVALID_STR) && 
                    ((OAM_CLOSED ==lclTemp_value)  || (OAM_HYBRID == lclTemp_value)))
            {
                continue;	
            }
            /*SPR 16372 fix stop*/

            /* SPR 15799 START */
            /* SPR 18930  FIX START */
            /* Code Remooved */
            /* SPR 18930  FIX END */
            /* SPR 15799 END */ 
            lte_count++;
        }

    }
    /* SPR 18930  FIX START */
    p_cell_info->nbour_cell_info.num_neighbour_cell = lte_count;
    /* SPR 18930  FIX END */
    /* END RT  SPR_8709_FIX */
    return retVal; 
}


/******************************************************************************
 *  FUNCTION NAME    : oam_atoh
 *  DESCRIPTION      : This function is a wrapper function of atoh (conversion
 ASCII to Hex)
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/ 


unsigned int oam_atoh(char *str)
{
    unsigned int value = OAM_ZERO;
    unsigned int digit = OAM_ZERO;
    char c;
    while(( c=*str++)!= '\0')
    {
        if (c >= '0' && c <= '9')
            digit = (unsigned int)(c - '0');
        else if( c >= 'a' && c<='f')
            digit = (unsigned int)(c - 'a') + 10;
        else if(c >='A' && c<='F')
            digit = (unsigned int)(c - 'A') + 10;
        else
            break;
        value = (value << 4) + digit;
    }
    return value;
}

#ifdef OAM_SON_ENABLE
/******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_init_config_param
 *  DESCRIPTION      : This function is used to populate the son init parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_son_init_param(void)
{
    /* - SPR 17439 */

    OAM_FUN_ENTRY_TRACE();
    UInt8 son_int_id=OAM_ZERO;
    UInt8 log_on_off=OAM_ZERO;
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    xmlChar *tag_value = OAM_NULL;
    /* SPR 22055 FIXED START*/
    char *tag_value1 = OAM_NULL;
    /* SPR 22055 FIXED END*/

    /* SPR 19703 changes start */
    UInt32 log_level=OAM_ZERO;
    son_oam_log_level_et son_log_level = SON_OAM_LOG_LEVEL_INFO;
    /* SPR 19703 changes end */

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.SONParams,"log_on_off"));

    if ((lclTemp_value >= MIN_SON_INIT_LOG_ON_OFF) &&
            (lclTemp_value <= MAX_SON_INIT_LOG_ON_OFF))
    {
        log_on_off=lclTemp_value; 
    }
    else
    {
		OAM_LOG(OAM, OAM_WARNING, "Value of log_on_off is %d"
				" and range is from %d to %d", lclTemp_value,
                MIN_SON_INIT_LOG_ON_OFF, MAX_SON_INIT_LOG_ON_OFF);
        return OAM_FAILURE;
    }

    /* SPR 19703 changes start */
    log_level=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.SONParams,"log_level"));

    /* SPR 20007 : CID 110655 fix start */
    if (son_log_level <= MAX_SON_INIT_LOG_LEVEL)
        /* SPR 20007 : CID 110655 fix end */
    {
        son_log_level = (son_oam_log_level_et)log_level;
        OAM_LOG(OAM, OAM_INFO,"Populated value of SON logLevel: %d",
                son_log_level);

    }
    else
    {
		OAM_LOG(OAM, OAM_WARNING, "Value of log_level is %d and"
				" range is from %d to %d", log_level,
                /* SPR 19703 changes end */
                MIN_SON_INIT_LOG_LEVEL, MAX_SON_INIT_LOG_LEVEL);
        return OAM_FAILURE;
    }


    oam_prov_req.oam_son_req.oam_son_init_config_req.bitmask |= SON_INIT_CONFIG_PRESENT;

    for (son_int_id = OAM_ZERO ; son_int_id < SON_MAX_NO_INT_MODULES ; son_int_id++)
    {
        oam_prov_req.oam_son_req.oam_son_init_config_req.
            int_module_config[son_int_id].module_id=(son_module_id_et)(SON_MIN_MODULE_ID + son_int_id);

        oam_prov_req.oam_son_req.oam_son_init_config_req.
            int_module_config[son_int_id].log_configuration.log_on_off = (son_oam_log_on_off_et)log_on_off;

        /* SPR 19703 changes start */
        oam_prov_req.oam_son_req.oam_son_init_config_req.
            int_module_config[son_int_id].log_configuration.log_level = son_log_level;
        /* SPR 19703 changes end */
        oam_prov_req.oam_son_req.oam_son_init_config_req.
            int_module_config[son_int_id].log_configuration.bitmask |= SON_OAM_MODULE_LOG_LEVEL_PRESENT;

    }


    /* SPR 12944 START */

    /* SPR 12944 REVIEW COMMENTS FIX START */
    tag_value = oam_get_xml_text_node_content(xml_struct_g.SONParams,
            "NMMSupported", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);

    if(tag_value) {
        if (oam_atoi(buf) <= OAM_ONE) {
            oam_prov_req.oam_son_req.oam_son_init_config_req.
                nmm_supported = (son_bool_et)oam_atoi(buf);
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Value of NMMSupported(Boolean) is %d",
                    oam_atoi(buf));

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /*SPR_15770 Fix start*/
        /*Code removed for NMMEnabled flag and used NMMSupported Flag instead*/
        oam_prov_req.system_status.is_nmm_enabled = oam_prov_req.oam_son_req.oam_son_init_config_req.nmm_supported; 
        /*SPR_15770 Fix end*/

        oam_prov_req.oam_son_req.oam_son_init_config_req.
            bitmask |= SON_NMM_SUPPORT_PRESENT;
    }
    else {
        oam_prov_req.oam_son_req.oam_son_init_config_req.
            nmm_supported = SON_FALSE; /* Coverity 69694 Fix */
    }
    /* SPR 22055 FIXED START*/
    tag_value1 = (Char8*)oam_xmlNodeGetContent(xml_struct_g.health_monitoring,"healthMonitoringTimeInterval");
    if(oam_strcmp(tag_value1, OAM_INVALID_STR))
    {
        lclTemp_value = oam_atoi((Char8*)tag_value1);
        oam_prov_req.oam_son_req.oam_son_init_config_req.health_upd_tmr_period = lclTemp_value;
        oam_prov_req.oam_son_req.oam_son_init_config_req.bitmask |= SON_HEALTH_UPD_TMR_PERIOD_PRESENT;
    }    
    /* SPR 22055 FIXED END*/

    /* SPR 12944 REVIEW COMMENTS FIX END */
    /* SPR 12944 END */
    /* SPR 19322 START */
    /* Code Removed */
    /* SPR 19322 END */
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
#endif 

/*******************************************************************************
 *  FUNCTION NAME    : populate_son_shutdown_param
 *  DESCRIPTION      : This function is used to populate the son init parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
#ifdef OAM_SON_ENABLE

/* + SPR 17439 */
    oam_return_et
populate_son_shutdown_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS; /* klocwork fix */
} 
#endif 


/*******************************************************************************
 *  FUNCTION NAME    : populate_son_set_log_level_param
 *  DESCRIPTION      : This function is used to populate the son init parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
#ifdef OAM_SON_ENABLE
/* + SPR 17439 */
    oam_return_et
populate_son_set_log_level_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();


    OAM_FUN_EXIT_TRACE();

    return OAM_SUCCESS;
} 
#endif 

/*******************************************************************************
 *  FUNCTION NAME    : populate_son_send_cell_info_param
 *  DESCRIPTION      : This function is used to populate the son init parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
#ifdef OAM_SON_ENABLE
/* + SPR 17439 */
    oam_return_et
populate_son_send_cell_info_param(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS; /*klocwork fix */
}
#endif 

#ifdef OAM_SON_ENABLE
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_es_params
 *  DESCRIPTION      : This function is used to populate the enable energy saving
 parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
    oam_return_et
oam_populate_son_es_params(EnergySavingConfig_t *p_es_config)
{
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.son_es_params,"es_enable_disable"));
    p_es_config->es_enable_disable = lclTemp_value;   

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.son_es_params,"interval"));
    p_es_config->ActiveUECountIntervalSeconds = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.son_es_params,"threshold_value"));
    p_es_config->ActiveUECountThreshold = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.son_es_params,"auto_switch_on_off"));
    p_es_config->auto_switch_on_off = lclTemp_value;

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_mro_params
 *  DESCRIPTION      : This function is used to populate the enable mro 
 parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_son_mro_params(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.SONParams,"mro_enable_disable"));
    oam_prov_req.oam_son_req.mro_config.mro_enable_disable_flag = lclTemp_value;

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_mlb_params
 *  DESCRIPTION      : This function is used to populate the enable mlb 
 parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_son_mlb_params(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.SONParams,"mlb_enable_disable"));
    oam_prov_req.oam_son_req.mlb_config.mlb_enable_disable_flag = lclTemp_value;

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_rach_opt_params
 *  DESCRIPTION      : This function is used to populate the rach opt 
 parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_populate_son_rach_opt_params(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.rach_opt_params,"rachopt_enable_disable"));
    oam_prov_req.oam_son_req.rachopt_config.rachopt_enable_disable_flag = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.rach_opt_params,"rachopt_mode"));
    oam_prov_req.oam_son_req.rachopt_config.rachopt_mode = lclTemp_value;

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_nr_add_req
 *  DESCRIPTION      : This function is used to populate the son oam anr disable req parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

oam_return_et
    oam_populate_son_nr_add_req
(
 XML_struct_cell_config        *p_cell_spec_params,
 oam_rrm_cell_config_req_t     *p_rrm_cellconfig,
 oam_cell_neighbourlist_info_t *p_nr_info
 )
{
    OAM_FUN_ENTRY_TRACE();

    xmlChar *temp = OAM_NULL;
    xmlChar *temp1 = OAM_NULL;
    UInt16 lte_cell_cnt = OAM_ZERO;    
    UInt16 umts_cell_cnt = OAM_ZERO;
    UInt16 cdma_cell_cnt = OAM_ZERO;
    UInt16 geran_cell_cnt = OAM_ZERO;
    UInt16 plmn_id_count = OAM_ZERO;
    Char8  *p_temp_token = OAM_NULL; 
    oam_return_et retVal = OAM_FAILURE;
    UInt16 instance_id = OAM_ZERO;
    /* RT SPR 8981 FIX START */
    UInt32 loop = 0, count1 = 0;
    UInt32 num_inter_rat_neighbors = 0;
    /* RT SPR 8981 FIX END */
    UInt8 temp_plmnid[OAM_SEVEN] = {0};
    /* SPR 12932 FIX START */
    UInt16 num_inter_rat_cdma_neighbors = OAM_ZERO;
    UInt16 num_inter_rat_gran_neighbors = OAM_ZERO;
    /* SPR 12932 FIX END */

    /* RT SPR 8627 START */
    UInt32 utran_cid = 0;
    UInt32 utran_rncid = 0;
    /* RT SPR 8627 END */

    /* RT SPR 9019 START */
    oam_freq_type_et freq_found = OAM_FREQ_NOT_AVAILABLE;
    UInt16 uarfcn = 0;
    /* RT SPR 9019 END */
    /* SPR-13586 START */
    UInt16 arfcn = 0;
    /* SPR-13586 END */

    /* Spr 15438 Fix Start */ 
    UInt8 lte_cell_enable = OAM_ZERO;  
    UInt8 lte_cell_mi = OAM_ZERO;
    /* Spr 15438 Fix End */  
    /* Spr 15612  Fix Start*/
    UInt8 umts_cell_enable = OAM_ZERO;  
    UInt8 umts_cell_mi = OAM_ZERO;
    /* Spr 15612  Fix End*/


    /* SPR 15238 START */
    /*  coverity 83279 fix start */
    oam_access_mode_et calculated_access_mode;
    /*  coverity 83279 fix end */
    oam_eutran_nbr_cell_type_et nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
    /* SPR 15238 END */
    oam_son_nr_add_req_t *p_son_nr_add = &p_nr_info->oam_son_nr_add_req;

    /* Populate src_cgi start */

    oam_memcpy(p_son_nr_add->src_cgi.
            cell_identity,
            p_rrm_cellconfig->global_cell_info.eutran_global_cell_id.
            cell_identity,
            SON_CELL_ID_OCTET_SIZE);

    /* SPR 15917 START */
    oam_find_primary_plmnid((Char8 **)&temp,p_cell_spec_params);

    if(OAM_NULL == temp) 
    {
        OAM_LOG(OAM,OAM_WARNING,"Failure in populating Primary PLMNID");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    /* SPR 15917 END */

	OAM_LOG(OAM, OAM_INFO,
            "Content of node is %s and parameter name is PLMNID", temp);
    oam_convert_plmnid((Char8 *)temp_plmnid,temp);
    retVal = oam_populate_plmnid((Char8*)temp_plmnid,
            &(p_son_nr_add->src_cgi.plmn_id));


    if (OAM_FAILURE == retVal) {
		OAM_LOG(OAM, OAM_WARNING, "Population of PLMN-ID failed.");
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }

    /* Populate src_cgi end */

    parmeter_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->NeighborList,
            "MaxLTECellEntries");
    p_nr_info->max_nr_intra_entries = oam_atoi((Char8*)parmeter_value);

    temp = oam_xmlNodeGetContent(p_cell_spec_params->NeighborList,
            "LTECellNumberOfEntries");

    p_son_nr_add->nr_list.intra_rat_nr_list_size = 0;

    lte_cell_cnt = oam_atoi((Char8*)temp);
/*SPR 22442 Fix Start*/ 
    if(lte_cell_cnt > p_nr_info->max_nr_intra_entries) {
		OAM_LOG(OAM, OAM_WARNING, "LTECellNumberOfEntries(%u) > MaxLTECellEntries(%u)",
				lte_cell_cnt,p_nr_info->max_nr_intra_entries);
        OAM_FUN_EXIT_TRACE();
        retVal = OAM_FAILURE;
        return retVal;
    }
/*SPR 22442 Fix End*/ 
    /* SPR 12932 FIX START */
    UInt16 instance_id_index = OAM_ZERO;
    /* SPR 12932 FIX END */

    while (loop < lte_cell_cnt) {
        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_INSTANCE_ID");

        instance_id = oam_atoi((Char8*)temp);
        /* SPR 12932 FIX START */
        /*ut_bug_fix__15468_start CID 78993*/
        if(instance_id == 0)
        {
            loop++;
            continue;
        }
/*SPR 22442 Fix Start*/
        count1 = instance_id -1;

        if(!((OAM_ONE << count1) & SON_PROV_REQ.intra_rat_daho_bitmask)) 
        {
            /*Other then DAHO Cell. If Cell is DAHO Cell, Then nrEntryBitMap is not set. 
              But the DAHO entry is filled in SON NR LIST. DAHO cell*/
            p_nr_info->intra_rat_nr_entry_bitmap |= (OAM_ONE << count1);
        }  
/*SPR 22442 Fix End*/
        /* SPR 13185 FIX START */
        else
        {
            loop++;
            continue;
        }
        /*ut_bug_fix__15468_end CID 78993*/
        /* SPR 13185 FIX END */
        /* SPR 12932 FIX END */

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "EUTRACarrierARFCN");

        freq_found = OAM_FREQ_NOT_AVAILABLE;
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi((Char8*)temp);
            freq_found =
                oam_find_arfcn_in_available_freqs((UInt16)lclTemp_value,
                        OAM_ARFCN_EUTRAN,
                        p_rrm_cellconfig);
            if (OAM_FREQ_NOT_AVAILABLE == freq_found) {
				OAM_LOG(OAM, OAM_WARNING, "EARFCN of the neighbor is not in "
                        "the available freq list");
                /* SPR 18930 FIX START */
                /* Code Removed */
                /* SPR 18930 FIX END */
            }

            /*Coverity 87743 Fix Start*/
/*SPR 22442 Fix Start*/
	/*Code Deleted*/
/*SPR 22442 Fix End*/

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                earfcn = lclTemp_value;
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_EARFCN_PRESENT;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Mandatory tag EUTRACarrierARFCN[%d] not found", loop);
            OAM_FUN_EXIT_TRACE();
            retVal = OAM_FAILURE;
            return retVal;
        }

        /* Spr 15438 Fix Start */ 
        lte_cell_enable = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[loop],"Enable"));

        lte_cell_mi = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->LTECell[loop],"MustInclude"));

        /* SPR 18930  FIX START */
        p_nr_info->eutran_nbr_ctxt[instance_id - 1].enable = lte_cell_enable ;
        p_nr_info->eutran_nbr_ctxt[instance_id - 1].bitmask |= OAM_SON_NEIGHBOUR_ENABLE_PRESENT;

        p_nr_info->eutran_nbr_ctxt[instance_id - 1].must_include = lte_cell_mi;
        p_nr_info->eutran_nbr_ctxt[instance_id - 1].bitmask |= OAM_SON_NEIGHBOUR_MI_PRESENT;
        /* SPR 18930  FIX END */
        /* Spr 15438 Fix End */ 

        /* SPR 18930  FIX START */
        if((lte_cell_enable == OAM_TRUE && lte_cell_mi == OAM_TRUE))
        {
            p_nr_info->first_nr_add_state = FIRST_NR_ADD_REQ_TO_BE_SENT;
        }
        /* SPR 18930  FIX END */

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "PLMNID");
        if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
			OAM_LOG(OAM, OAM_WARNING,
                    "XML file reading failed! Node FAPService->CellConfig"
                    "->LTE->RAN->NeighborList->LTECell->PLMNID not found.");
            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        oam_convert_plmnid((Char8 *)temp_plmnid,temp);
        retVal = oam_populate_plmnid((Char8*)temp_plmnid,
                &(p_son_nr_add->nr_list.
                    intra_rat_nr_list[count1].
                    nbr_cgi.plmn_id));
        if (OAM_SUCCESS == retVal) {
			OAM_LOG(OAM, OAM_INFO,
                    "Neighbor[%d]: PLMNID Populated Successfully",
                    instance_id - OAM_ONE);
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Neighbor[%d]: PLMNID Population Failed", loop);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "CID");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi((Char8*)temp);
            /* SPR 10784 Fix Start */
            oam_encode_eutran_cellidentity_into_bit_stream(
                    p_son_nr_add->nr_list. intra_rat_nr_list[count1].
                    nbr_cgi.cell_identity, lclTemp_value);
            /* SPR 10784 Fix End*/
			OAM_LOG(OAM, OAM_INFO,
                    "Content of node is %s and parameter name is CID", temp);
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "PhyCellID");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].pci =
                oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_PCI_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "QOffset");
        if (oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp,
                    RAN_NeighborList_LTECell_QOffset[0], 31);

            /* coverity 35749 */
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                cell_specific_offset =
                (son_q_offset_range_et)oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_CELL_OFFSET_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_TAC");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                tac[1] = (lclTemp_value & OAM_LOWER_EIGHT_BITS_SET);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                tac[0] = ((lclTemp_value >> OAM_EIGHT) & OAM_LOWER_EIGHT_BITS_SET);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_TAC_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_NUMPLMNID");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                num_plmn_id = oam_atoi((Char8*)temp);

            if (p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                    num_plmn_id > OAM_ZERO) {

                /* SPR 16603 Fix Start */
                temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                        "X_VENDOR_PLMN_ID");
                if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
					OAM_LOG(OAM, OAM_WARNING, "XML file reading failed! "
                            "Node FAPService->CellConfig->LTE->RAN->NeighborList"
                            "->LTECell->X_VENDOR_PLMN_ID not found.");
                    retVal = OAM_FAILURE;
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }
                /* SPR 16603 Fix Start */

                p_temp_token = oam_strtok((Char8*)temp, ",");

                do {
                    retVal = oam_populate_plmnid(p_temp_token,
                            &(p_son_nr_add->nr_list.
                                intra_rat_nr_list[count1].
                                plmn_id[plmn_id_count++]));
                    if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_WARNING,
                                "PLMN-ID list reading failed.");
                        retVal = OAM_FAILURE;
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }

                    p_temp_token = oam_strtok(OAM_NULL, ",");
                } while((OAM_NULL != p_temp_token) &&
                        (plmn_id_count < p_son_nr_add->nr_list.
                         intra_rat_nr_list[count1].num_plmn_id));

                p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                    bitmask |= SON_PLMN_ID_PRESENT;
            }
        }
        /* SPR 17408 Fix +- */
        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_RSRP");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                rsrp = oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_RSRP_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_RSRQ");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                rsrq = oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_RSRQ_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_NR_STATUS");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            /* coverity 35751 */
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                nr_status = (son_nr_status_et)oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_ENABLE_NR_STATUS_PRESENT;
        }
        else {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                nr_status = SON_NR_LOCKED;
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_ENABLE_NR_STATUS_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "Blacklisted");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp,
                    NR_Blacklisted[OAM_ZERO], 2);
            /* coverity 35750 */
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                ho_status = (son_ho_status_et)oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_ENABLE_HO_STATUS_PRESENT;
        }


        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "CIO");
        /* coverity 35754 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            /* SPR 9648 Fix Start*/
            oam_search_integer_to_interger((Char8*)temp,
                    RAN_NeighborList_LTECell_CIO[OAM_ZERO],
                    OAM_THIRTY_ONE );
            /* SPR 9648 Fix End*/
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                cm_cell_specific_offset =
                (son_q_offset_range_et)oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_CM_CELL_OFFSET_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_BROADCAST_STATUS");
        /* coverity 35753 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                broadcast_status = (son_bool_et)oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_BROADCAST_STATUS_PRESENT;
        }


        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_ACCESS_MODE");
        /* coverity 35752 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            /* SPR 15238 START */
            SInt32 temp_access_mode = oam_atoi((Char8*)temp);
            if(p_son_nr_add->nr_list.intra_rat_nr_list[instance_id - 1].earfcn == 
                    p_rrm_cellconfig->ran_info.
                    rf_params.rf_configurations.dl_earfcn)   
            {
                OAM_LOG(OAM,OAM_INFO,"IntraFreq Nbr Cell Addition recieved ");
                nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
            }
            else
            {
                OAM_LOG(OAM,OAM_INFO,"InterFreq Nbr Cell Addition recieved ");
                nbr_cell_type = OAM_INTER_FREQ_NBR_CELL;
            }
            calculated_access_mode = oam_init_nbr_cell_access_mode_pci_validation(
                    p_cell_spec_params,
                    nbr_cell_type, 
                    p_son_nr_add->nr_list.intra_rat_nr_list[instance_id - 1].earfcn,
                    p_son_nr_add->nr_list.intra_rat_nr_list[instance_id - 1].pci,
                    temp_access_mode);
            if (temp_access_mode!= (SInt32)calculated_access_mode)
            {
                temp_access_mode =  calculated_access_mode;
            }

            p_son_nr_add->nr_list.intra_rat_nr_list[instance_id - 1].access_mode =
                (son_access_mode_et)temp_access_mode;
            /* SPR 15238 END */

            /* SPR 17296 FIX code removed */

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_ACCESS_MODE_PRESENT;
        }
        /* SPR 17408 Fix Start */
        if((p_son_nr_add->nr_list.intra_rat_nr_list[count1].bitmask & SON_ACCESS_MODE_PRESENT) &&
           ((p_son_nr_add->nr_list.intra_rat_nr_list[count1].access_mode == SON_OPEN) ||
            (p_son_nr_add->nr_list.intra_rat_nr_list[count1].access_mode == SON_OPEN_FEMTO)))
        {
            OAM_LOG(OAM, OAM_INFO, "CSGID will not be read into "
                    "lte_ncl.intra_freq_cells as ACCESS_MODE is present"
                    " and its value is Open/Open Femto");
        }
        else 
        {
            temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                    "X_VENDOR_CSGID");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi((Char8*)temp);
                /* BITSTRING FIX START */
                oam_conversion_from_int_to_byte_string(
                        p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                        csg_identity, lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                /* BITSTRING FIX START */
                p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                    bitmask |= SON_INTRA_CSG_ID_PRESENT;
            }
        }
        /* SPR 17408 Fix End */

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_PRACH_ROOT_SEQUENCE_INDEX");
        /* coverity 35752 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                prach_config.root_sequence_index = oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_PRACH_ZERO_CORRELATION_ZONE_CONFIG");
        /* coverity 35752 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                prach_config.zero_correlation_zone_config = oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_PRACH_HIGH_SPEED_FLAG");
        /* coverity 35752 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                prach_config.high_speed_flag = oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_PRACH_FREQUENCY_OFFSET");
        /* coverity 35752 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                prach_config.prach_frequency_offset = oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_PRACH_CONFIGURATION_INDEX");
        /* coverity 35752 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                prach_config.prach_configuration_index = oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].prach_config.
                bitmask |= SON_PRACH_CONFIG_INDEX_PRESENT;
        }
        /* SPR 17408 Fix +- */

        /* SPR 18930  FIX START */
        /* Code Removed */
        /* SPR 18930  FIX END */



        /*eICIC_PHASE_1_2_CHANGES_START */
        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_INTERFERENCE_SCHEME");
        /* coverity 35752 */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            /*CID:69230 start*/
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].eicic_info.
                interference_scheme =(son_intf_scheme_type_et)oam_atoi((Char8*)temp);
            /*CID:69230 end*/
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_EICIC_INFO_PRESENT;

            p_son_nr_add->nr_list.intra_rat_nr_list[count1].eicic_info.
                bitmask |= SON_CELL_INTF_SCHEME_TYPE_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_MIN_ABS_USAGE_THRESHOLD");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].eicic_info.
                abs_usage_threshold.min_abs_usage_threshold =oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_EICIC_INFO_PRESENT;
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].eicic_info.
                bitmask |= SON_CELL_ABS_USAGE_THRESHOLD_PRESENT;
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].eicic_info.
                abs_usage_threshold.bitmask |= SON_CELL_MIN_ABS_USAGE_THRESHOLD_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell[loop],
                "X_VENDOR_MAX_ABS_USAGE_THRESHOLD");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].eicic_info.
                abs_usage_threshold.max_abs_usage_threshold =oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].
                bitmask |= SON_EICIC_INFO_PRESENT;
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].eicic_info.
                bitmask |= SON_CELL_ABS_USAGE_THRESHOLD_PRESENT;
            p_son_nr_add->nr_list.intra_rat_nr_list[count1].eicic_info.
                abs_usage_threshold.bitmask |= SON_CELL_MAX_ABS_USAGE_THRESHOLD_PRESENT;
        }

        /*eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
#ifdef OAM_SON_ENABLE
        retVal = oam_populate_son_intra_rat_mbms_config(
                p_cell_spec_params,
                p_son_nr_add,
                count1);
        if (OAM_SUCCESS == retVal) 
        {
            OAM_LOG(OAM, OAM_INFO, "eMBMS parameters populated for SON");
        }
        else 
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "Unable to populate eMBMS parameters for SON");
            retVal = OAM_SUCCESS;
        }
#endif
#endif
/*SPR 22442 Fix Start*/
	/*Code Deleted*/
/*SPR 22442 Fix End*/
        ++loop;
        ++p_son_nr_add->nr_list.intra_rat_nr_list_size;
    } /* End of for loop */

    parmeter_value =
        (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_1,
                "MaxUMTSEntries");
    /* SPR-13586 START */
    /* RT SPR 8627 START */
    p_nr_info->max_nr_umts_inter_entries = oam_atoi((Char8*)parmeter_value);
    /* RT SPR 8627 END */
    /* SPR-13586 END */

    temp = oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_1,
            "UMTSNumberOfEntries");


    /* RT SPR 8981 FIX START */
    p_son_nr_add->nr_list.inter_rat_nr_list_size = 0;
    umts_cell_cnt = oam_atoi((Char8*)temp);
    /* SPR-13586 START */
    if(umts_cell_cnt > p_nr_info->max_nr_umts_inter_entries) {
        /* SPR-13586 END */
        /* RT SPR 8981 FIX END */
		OAM_LOG(OAM, OAM_WARNING,
                "Failed because UMTSNumberOfEntries > MaxUMTSEntries.");
        retVal = OAM_FAILURE;
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    /* Assigning current number of enteries to last added instance id*/
    /* RT SPR 8981 FIX START */

    /* SPR-13586 START */ 
    if(umts_cell_cnt > OAM_ZERO){
        p_nr_info->inter_rat_umts_last_added_instance_id = umts_cell_cnt;
    }
    /* SPR-13586 END */

    /* RT SPR 9019 FIX START */
    loop = 0;
    /* SPR-13586 START */
    p_nr_info->inter_rat_umts_list_size = 0; 
    /* SPR-13586 END */
    while(loop < umts_cell_cnt) {
        /* SPR 12982 FIX START */
        /* code moved */
        /* SPR 12982 FIX END */
        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "UARFCNDL");
        freq_found = OAM_FREQ_NOT_AVAILABLE;
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            uarfcn = oam_atoi((Char8*)temp);

            freq_found = oam_find_arfcn_in_available_freqs(uarfcn,
                    OAM_ARFCN_UTRAN,
                    p_rrm_cellconfig);
            if(OAM_FREQ_NOT_AVAILABLE == freq_found) {
				OAM_LOG(OAM, OAM_WARNING, "UARFCN of UMTS neighbor not found "
                        "in available frequencies");
                /* SPR 12828 FIX START */
                OAM_ALARM(CRITICAL_CONFIGURATION_FAILURE_ALARM_ID,CRITICAL,NOTIFY_NEW_ALARM,
                        PROCESSING_ERROR_ALARM,UNAVAILABLE,EXPEDITED_ALARM,
                        "Startup Configuration Failure: Neighbor uarfcn not configured",
                        OAM_NULL,OAM_ZERO);
                oam_abort();
                return OAM_FAILURE;
                /* SPR 12828 FIX END */


            }

            /* SPR 12982 FIX START */
            /* SPR 12367 FIX START */
            temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                    "X_VENDOR_INSTANCE_ID");
            /* coverity 41176 */
            instance_id = oam_atoi((Char8*)temp);
            /* SPR 12932 FIX START */
            /** ut_bug_fix_14998_start CID 66978 **/   
            if(instance_id==0)
            {
                loop++;
                continue;
            }
            instance_id_index = instance_id -1;
            /** ut_bug_fix_14998_end CID 66978 **/   


            /* SPR-13586 START */
            if(!((OAM_ONE << instance_id_index) & SON_PROV_REQ.inter_rat_umts_daho_bitmask)) 
            {
                /*Other then DAHO Cell. If Cell is DAHO Cell, Then nrEntryBitMap is not set. 
                  But the DAHO entry is filled in SON NR LIST. DAHO cell*/
                /* SPR-13586 END */
                p_nr_info->inter_rat_umts_entry_bitmap |= (OAM_ONE << instance_id_index);
                /* SPR 13185 FIX START */
                p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    bitmask |= SON_INTER_UTRAN_NEIGHBOR;
            }
            else
            {
                ++loop;
                /* SPR-13586 START */ 
                /* code removed */
                /* SPR-13586 END */
                continue;
                /* SPR 13185 FIX END */
            }   
            /* SPR 12932 FIX END */
            /* SPR 13399 START */
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                bitmask |= SON_INTER_UTRAN_NEIGHBOR;
            /* SPR 13399 END */

            /* Initiatlizing the is valid field of inter rat cell*/
            /* SPR-13586 START */
            /*ut_bug_fix__15477_start CID 81778*/
/*SPR 22442 Fix Start*/
	/*Code Deleted*/
/*SPR 22442 Fix End*/
            /* SPR-13586 END */

            /* currently only UTRAN support is there */
            /* coverity 35720 */
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].utran_neighbor.
                nbr_cgi.rat_type = SON_UTRAN_CELL;
            /* SPR 12982 FIX END */


            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.uarfcn = uarfcn;

            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_UARFCN_PRESENT;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Mandatory tag \"UARFCNDL\" missing");
            retVal = OAM_FAILURE;
            OAM_FUN_ENTRY_TRACE();
            return retVal;
        }
        /* Spr 15612  Fix Start*/
        umts_cell_enable = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS[loop],"Enable"));

        umts_cell_mi = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS[loop],"MustInclude"));

        /* SPR 18930  FIX START */
        p_nr_info->utran_nbr_ctxt[instance_id - 1].enable = umts_cell_enable ;
        p_nr_info->utran_nbr_ctxt[instance_id - 1].bitmask |= OAM_SON_NEIGHBOUR_ENABLE_PRESENT;


        p_nr_info->utran_nbr_ctxt[instance_id - 1].must_include = umts_cell_mi;
        p_nr_info->utran_nbr_ctxt[instance_id - 1].bitmask |= OAM_SON_NEIGHBOUR_MI_PRESENT;
        /* SPR 18930  FIX END */
        /* Spr 15612  Fix End*/
        /* SPR 18930  FIX START */
        if((umts_cell_enable == OAM_TRUE && umts_cell_mi == OAM_TRUE))
        {
            p_nr_info->first_nr_add_state = FIRST_NR_ADD_REQ_TO_BE_SENT;
        }
        /* SPR 18930  FIX END */

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "PCPICHScramblingCode");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            if(OAM_UTRAN_FREQ_FDD == freq_found) {
                p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.pci.bitmask = SON_PCI_FDD_PRESENT;

                p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.pci.pci_fdd = oam_atoi((Char8*)temp);
            }
            else if(OAM_UTRAN_FREQ_TDD == freq_found) {
                p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.pci.bitmask = SON_PCI_TDD_PRESENT;
                p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.pci.pci_tdd = oam_atoi((Char8*)temp);
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "UARFCN of UMTS neighbor not found "
                        "in available frequencies");

                ++loop;
                continue;
            }

            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_PCI_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "PLMNID");
        oam_convert_plmnid((Char8 *)temp_plmnid,temp);
        retVal = oam_populate_plmnid((Char8*)temp_plmnid,
                &(p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.nbr_cgi.plmn_id));
        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING, "PLMN population failed.");
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "RNCID");

        utran_rncid = oam_atoi((Char8*)temp);

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "CID");

        utran_cid = oam_atoi((Char8*)temp);

        /* Check if the RNCID and CID values put together don't excceed
         * the 28-bit value range
         */
        if(utran_cid > OAM_12BIT_MAX_VALUE &&
                utran_rncid > OAM_12BIT_MAX_VALUE) {
			OAM_LOG(OAM, OAM_WARNING,
                    "The CellIdentity is 28-bit value, hence if RNCID is "
                    "greater than 4095, then CID must be less than 4096 or "
                    "vice versa.");

            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        oam_encode_rncid_to_utran_cell_identity(p_son_nr_add->nr_list.
                inter_rat_nr_list[instance_id_index].
                utran_neighbor.nbr_cgi.cell_identity,
                utran_rncid);

        oam_encode_cid_to_utran_cell_identity(p_son_nr_add->nr_list.
                inter_rat_nr_list[instance_id_index].
                utran_neighbor.nbr_cgi.cell_identity,
                utran_cid);
        /* RT SPR 9019 FIX START */
        /* LINES MOVED */
        /* RT SPR 9019 FIX END */

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_CELL_SPECIFIC_OFFSET");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.cell_specific_offset = oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_CSO_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "LAC");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi((Char8*)temp);
            /*SPR 19721 FIX START*/
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.lac[OAM_ONE] =
                (lclTemp_value & OAM_LOWER_EIGHT_BITS_SET);
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.lac[OAM_ZERO] =
                ((lclTemp_value >> OAM_EIGHT) & OAM_LOWER_EIGHT_BITS_SET);
            /*SPR 19721 FIX START*/

            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_LAC_PRESENT ;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "RAC");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.rac = oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_RAC_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_NUMPLMNID");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.num_plmn_id = oam_atoi((Char8*)temp);

            if(p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.num_plmn_id > OAM_ZERO) {
                temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                        "X_VENDOR_PLMN_LIST");

                p_temp_token = oam_strtok((Char8*)temp, ",");
                plmn_id_count = OAM_ZERO;
                do {
                    retVal = oam_populate_plmnid(p_temp_token,
                            &(p_son_nr_add->nr_list.
                                inter_rat_nr_list[instance_id_index].
                                utran_neighbor.plmn_id[plmn_id_count++]));
                    if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_WARNING, "PLMN-ID list reading failed.");
                        retVal = OAM_FAILURE;
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }

                    p_temp_token = oam_strtok(OAM_NULL, ",");
                } while(OAM_NULL != p_temp_token &&
                        plmn_id_count < p_son_nr_add->nr_list.
                        inter_rat_nr_list[instance_id_index].
                        utran_neighbor.num_plmn_id);

                p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.bitmask |= SON_UTRAN_PLMN_ID_PRESENT;
            }
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_ACCESS_MODE");

        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            /* coverity 35722 */
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.access_mode =
                (son_access_mode_et)oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_ACCESS_MODE_PRESENT;
        }
        /* SPR 17408 Fix Start */
        if((p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.bitmask & SON_UTRAN_ACCESS_MODE_PRESENT) &&
                ((p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                  utran_neighbor.access_mode != SON_OPEN) &&
                 (p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                  utran_neighbor.access_mode != SON_OPEN_FEMTO)))
            /* SPR 17408 Fix End */
        {
            temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                    "X_VENDOR_CSGID");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi((Char8*)temp);
                /* BITSTRING FIX START */
                oam_conversion_from_int_to_byte_string(p_son_nr_add->nr_list.
                        inter_rat_nr_list[instance_id_index].
                        utran_neighbor.csg_identity, lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                /* BITSTRING FIX START */
                p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                    utran_neighbor.bitmask |= SON_UTRAN_CSG_ID_PRESENT;
            }
        }
        else {
            /* SPR 17408 Fix Start */
            OAM_LOG(OAM, OAM_INFO, "Ignoring CSG ID as access_mode is set to Open/Open Femto");
            /* SPR 17408 Fix End */
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_RSCP");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.rscp = oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_RSCP_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_ECNO");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.ecno = oam_atoi((Char8*)temp);

            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_ECNO_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_NR_STATUS");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            /* coverity 35721 */
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.nr_status =
                (son_nr_status_et)oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_ENABLE_NR_STATUS_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_HO_STATUS");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            /* SPR-11757 removed code */  
            /* coverity 35723 */
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.ho_status =
                (son_ho_status_et)oam_atoi((Char8*)temp);
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_ENABLE_HO_STATUS_PRESENT;
        }

        /* SPR-13407 Start*/
        temp1 = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_PS_HO_SUPPORTED");
        if(oam_strcmp((Char8*)temp1, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp1,
                    NR_PS_HO_SUPPORTED[OAM_ZERO], OAM_TWO);
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.ps_ho_supported =
                (son_bool_et)oam_atoi((Char8*)temp1);
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_PS_HO_SUPPORT_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS[loop],
                "X_VENDOR_VOIP_CAPABLE");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp,
                    NR_VOIP_CAPABLE[OAM_ZERO], OAM_TWO);
            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.voip_capable = (son_bool_et)oam_atoi((Char8*)temp);
            if(!oam_strcmp((Char8*)temp, "1")) {
                if((p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].utran_neighbor.ps_ho_supported == SON_FALSE) && (p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].utran_neighbor.bitmask & SON_UTRAN_PS_HO_SUPPORT_PRESENT)) {
					OAM_LOG(OAM, OAM_WARNING, "value of voip_capable cannot be "
                            "1(true) when value of ps_ho_supported is "
                            "0(false) for UMTS neighor instance_id %d thus "
                            "considering ps_ho_supported as 1(true)",
                            instance_id);
                    p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                        utran_neighbor.voip_capable =
                        SON_FALSE; 
                }
                /* SPR-13407 End */
            }

            p_son_nr_add->nr_list.inter_rat_nr_list[instance_id_index].
                utran_neighbor.bitmask |= SON_UTRAN_VOIP_CAPABLE_PRESENT;
        }
        /* RT SPR 8981 FIX START */
        ++p_son_nr_add->nr_list.inter_rat_nr_list_size;
        /* SPR-13586 START */
        ++p_nr_info->inter_rat_umts_list_size;
        /* SPR-13586 END */
        ++loop;
    }


    num_inter_rat_neighbors = p_son_nr_add->nr_list.inter_rat_nr_list_size;
    temp = oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_1,
            "CDMA2000NumberOfEntries");


    /* SPR 12932 FIX START */
    num_inter_rat_cdma_neighbors  = oam_atoi((Char8*)temp);
    num_inter_rat_neighbors += num_inter_rat_cdma_neighbors;
    /* SPR 12932 FIX END */

    if(num_inter_rat_neighbors > SON_MAX_NO_INTER_RAT_NEIGHBOUR_CELLS) {
		OAM_LOG(OAM, OAM_WARNING, "Configured number of inter-RAT neighbors "
                "exceeds the max limit of %d",
                SON_MAX_NO_INTER_RAT_NEIGHBOUR_CELLS);
        OAM_FUN_EXIT_TRACE();
        retVal = OAM_FAILURE;
        return retVal ;
    }

    /* CDMA CHANGES START */
    /* SPR 12932 FIX START */
    for(cdma_cell_cnt = 0 ; cdma_cell_cnt  < num_inter_rat_cdma_neighbors;cdma_cell_cnt++) {

        if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                            "X_VENDOR_INSTANCE_ID"),OAM_INVALID_STR))!= OAM_ZERO)
        {
            instance_id = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],"X_VENDOR_INSTANCE_ID"));
            /*ut_bug_fix__154670_start CID 78995*/
            /*if (instance_id != OAM_ZERO)
              {
              loop = instance_id -1;
              }
              else
              {
              loop = OAM_ZERO;
              }*/
            if(instance_id==0 || instance_id > OAM_MAX_GSM_INST_ID_VAL)
            {
                loop++;
                continue;
            }
            loop = instance_id -1;
            /*ut_bug_fix__154670_end CID 78995*/

            if(!((OAM_ONE << loop) & SON_PROV_REQ.inter_rat_daho_bitmask)) 
            {
                /*Other then DAHO Cell. If Cell is DAHO Cell, Then nrEntryBitMap is not set. 
                  But the DAHO entry is filled in SON NR LIST. DAHO cell*/
                /* SPR 18930  FIX START */
                p_nr_info->inter_rat_cdma_entry_bitmap |= (OAM_ONE << loop);
                /* SPR 18930  FIX END */
            }   
            /* SPR 13185 FIX START */
            else
            {
                loop++;
                continue;
            }
            /* SPR 13185 FIX END */

            /* SPR 12932 FIX END */

            p_son_nr_add->nr_list.inter_rat_nr_list[loop].bitmask |= 
                SON_INTER_CDMA_NEIGHBOR;

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "PNOffset");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.pci = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |= 
                    SON_CDMA_PCI_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "BandClass");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                /* coverity 35745*/
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.band_class = 
                    (son_cdma_band_class_et)oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |=
                    SON_CDMA_BAND_CLASS_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "ARFCN");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.arfcn = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |=
                    SON_CDMA_BAND_CLASS_ARFCN_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_CELL_SPECIFIC_OFFSET");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.cell_specific_offset =
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |=
                    SON_CDMA_CSO_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "Type");

            if(!oam_strcmp((const char *)temp,(const char *) "HRPD")) {

#ifdef OAM_SON_ENABLE

                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    nbr_cgi.bitmask = SON_CGI_HRPD_PRESENT;

#endif
            }
            else if(!oam_strcmp((const char *)temp,(const char *) "1xRTT")) {

#ifdef OAM_SON_ENABLE

                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    nbr_cgi.bitmask = SON_CGI_1X_RTT_PRESENT;

#endif 
            }
            else {
				OAM_LOG(OAM, OAM_WARNING, "Unknown CDMA2000 type: %s", temp);
            }

            if (p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.bitmask == SON_CGI_1X_RTT_PRESENT)
            {
                temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                        "CID");
                /*CDMA CID CHANGES START*/
                lclTemp_value3 = oam_atoll((char *)temp);

                oam_conversion_from_int64_to_byte_string
                    (p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.cell_global_id_1X_RTT,
                     lclTemp_value3,OAM_CDMA_1XRTT_CELL_ID_BITSTRING_SIZE);

                /*oam_memcpy(NR_LIST.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.cell_global_id_1X_RTT,
                  temp , strlen((Char8 *)temp));
                  oam_memcpy(p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.cell_global_id_1X_RTT,
                  temp , oam_strlen((Char8 *)temp));*/
            }
            if (p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.bitmask == SON_CGI_HRPD_PRESENT)
            {
                temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                        "CID");

                lclTemp_value3 = oam_atoll((char *)temp);

                /*memset(p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.cell_global_id_HRPD,
                  0,RRM_SON_CELL_GLOBAL_ID_HRPD_SIZE);*/

                oam_conversion_from_int128_to_byte_string(
                        p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.cell_global_id_HRPD,
                        lclTemp_value3,OAM_MAX_CDMA_HRPD_INT_BITSTRING_SIZE);

                /*oam_memcpy(NR_LIST.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.cell_global_id_HRPD,
                  temp , strlen((Char8 *)temp));
                  oam_memcpy(p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.nbr_cgi.cell_global_id_HRPD,
                  temp , oam_strlen((Char8 *)temp));
                  */
                /*CDMA CID CHANGES END*/
            }        


            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PILOT_PN_PHASE");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.pilot_pn_phase = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |=
                    SON_CDMA_PILOT_PN_PHASE_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PILOT_STRENGTH");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.pilot_strength = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |=
                    SON_CDMA_PILOT_STRENGTH_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_NR_STATUS");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                /* coverity 35748*/
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.nr_status = 
                    (son_nr_status_et)oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |=
                    SON_CDMA_ENABLE_NR_STATUS_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_HO_STATUS");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                /* coverity 35747 */
                /* SPR-11757 removed code */ 
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.ho_status = 
                    (son_ho_status_et)oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |=
                    SON_CDMA_ENABLE_HO_STATUS_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_BROADCAST_STATUS");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                /* coverity 35746*/
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.broadcast_status = 
                    (son_bool_et)oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |=
                    SON_CDMA_BROADCAST_MODE_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PKT_ZONE_HYST_ENABLED");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.pz_hyst_enabled = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.bitmask |=
                    SON_OAM_PZ_HYST_ENABLED_PRESENT;

            }   

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PKT_ZONE_HYST_INFO_INCL");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.pz_hyst_info_incl = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.bitmask |=
                    SON_OAM_PZ_HYST_INFO_INCL_PRESENT;

            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PKT_ZONE_HYST_ACT_TIMER");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.pz_hyst_act_timer = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.bitmask |=
                    SON_OAM_PZ_HYST_TIMER_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PKT_ZONE_HYST_TIMER_MUL");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.pz_hyst_timer_mul = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.bitmask |=
                    SON_OAM_PZ_HYST_TIMER_MUL_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PKT_ZONE_HYST_TIMER_EXP");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.pz_hyst_timer_exp = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.bitmask |=
                    SON_OAM_PZ_HYST_TIMER_EXP_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PKT_ZONE_HYST_LIST_LEN");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.pz_hyst_list_len = 
                    oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.bitmask |=
                    SON_OAM_PZ_HYST_LIST_LEN_PRESENT;

            }   

            if (0x00 != p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pz_hyst_params_included.bitmask)
            {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_PZ_HYST_PARAMS_INCLUDED_PRESENT;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PROTOCOL_REV_LEVEL");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.p_rev =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_P_REV_PRESENT;

            }   

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_MIN_PROTOCOL_REV_LEVEL");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.min_p_rev =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_MIN_P_REV_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_NEG_SLOT_CYCLE_INDEX_SUP");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.neg_slot_cycle_index_sup =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_NEG_SLOT_CYCLE_INDEX_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_ENCRYPT_MODE");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.encrypt_mode =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_ENCRYPT_MODE_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_ENCRYPT_SUPPORTED");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.encrypt_suported =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_ENCRYPT_SUPPORTED_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_SIG_ENCRYPT_SUPPORTED");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.sig_encrypt_suported =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_SIG_ENCRYPT_SUPPORTED_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_MSG_INTEGRITY_SUPPORTED");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.msg_integrity_sup =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_MSG_INT_SUPPORTED_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_SIG_INTEGRITY_SUPPORTED_INCL");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.sig_integrity_sup_incl =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_SIG_INT_SUPPORTED_INCL_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_SIG_INTEGRITY_SUPPORTED");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.sig_integrity_sup =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_SIG_INT_SUPPORTED_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_MS_INIT_POS_LOC_SUPPORTED_IND");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.ms_init_pos_loc_sup_ind =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_MS_INIT_POS_LOC_SUP_IND_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_BAND_CLASS_INFO_REQ");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.band_class_info_req =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_BAND_CLASS_INFO_REQ_PRESENT;

            }   
            /* CSR 00058352 Fix Start*/
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "BandClass");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                /* coverity 35739 */
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.band_class =  (son_cdma_band_class_et)oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_BAND_CLASS_PRESENT ;

                /* SPR 12920 Fix Start */
                lclTemp_value = oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],"X_VENDOR_ALT_BAND_CLASS"),altBandClass[OAM_ZERO],ALT_BAND_CLASS_COUNT);
                /* SPR 12920 Fix End */
                /* coverity 35738 */
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.alt_band_class =  (son_cdma_band_class_et)lclTemp_value;
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_ALT_BAND_CLASS_PRESENT;
            }
            /* CSR 00058352 FIx End*/  
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_TRACKING_ZONE_MODE_SUPPORTED");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.tkz_mode_supported =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_TKZ_MODE_SUP_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_TRACKING_ZONE_ID");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.tkz_id =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_TKZ_ID_PRESENT;

            }  

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_FPC_FCH_INIT_SETPT_RC3");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.fpc_fch_included.fpc_fch_init_setpt_rc3 =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.fpc_fch_included.bitmask |= SON_OAM_FPC_FCH_INCL_RC3_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_FPC_FCH_INIT_SETPT_RC4");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.fpc_fch_included.fpc_fch_init_setpt_rc4 =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.fpc_fch_included.bitmask |= SON_OAM_FPC_FCH_INCL_RC4_PRESENT;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_FPC_FCH_INIT_SETPT_RC5");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.fpc_fch_included.fpc_fch_init_setpt_rc5 =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.fpc_fch_included.bitmask |= SON_OAM_FPC_FCH_INCL_RC5_PRESENT ;

            }   

            if (0x00 != p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.fpc_fch_included.bitmask)
            {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_FPC_FCH_INCLUDED;
            }    

            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_T_ADD");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.t_add =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_T_ADD;

            }   
            temp = oam_xmlNodeGetContent(p_cell_spec_params->CDMA2000_2[cdma_cell_cnt],
                    "X_VENDOR_PILOT_INC");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.pilot_inc =  oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask |= SON_CDMA_CSP_PILOT_INC_PRESENT;

            }  

            if (0x00 != p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.
                    cell_specific_params.bitmask)
            {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].cdma_neighbor.bitmask |= 
                    SON_CDMA_CELL_SPECIFIC_PARAMS_PRESENT;
            }
            ++p_son_nr_add->nr_list.inter_rat_nr_list_size;
            /* SPR 18930  FIX START */
            p_nr_info->first_nr_add_state = FIRST_NR_ADD_REQ_TO_BE_SENT;
            /* SPR 18930  FIX END */
        }
    }
    /* CDMA CHANGES END */

    /* Geran Changes START */
    /* SPR-13586 START */
    parmeter_value =
        (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_1,
                "MaxGSMEntries");

    p_nr_info->max_nr_gsm_inter_entries = oam_atoi((Char8*)parmeter_value);
    /* SPR-13586 END */

    temp = oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_1,
            "GSMNumberOfEntries");

    /* SPR 12932 FIX START */
    num_inter_rat_gran_neighbors  = oam_atoi((Char8*)temp);
    /* SPR 12932 FIX END */
    /* SPR-13586 START */
    if(num_inter_rat_gran_neighbors > OAM_ZERO){
        p_nr_info->inter_rat_gsm_last_added_instance_id = num_inter_rat_gran_neighbors;
    }

    if(num_inter_rat_gran_neighbors > p_nr_info->max_nr_gsm_inter_entries) {
		OAM_LOG(OAM, OAM_WARNING, "GSMNumberOfEntries > MaxGSMEntries");
        OAM_FUN_EXIT_TRACE();
        retVal = OAM_FAILURE;
        return retVal;
    }

    num_inter_rat_neighbors += num_inter_rat_gran_neighbors;

    if(num_inter_rat_neighbors > SON_MAX_NO_INTER_RAT_NEIGHBOUR_CELLS) {
		OAM_LOG(OAM, OAM_WARNING, "Configured number of inter-RAT neighbors "
                "exceeds the max limit of %d",
                SON_MAX_NO_INTER_RAT_NEIGHBOUR_CELLS);
        OAM_FUN_EXIT_TRACE();
        retVal = OAM_FAILURE;
        return retVal ;
    }

    p_nr_info->inter_rat_gsm_list_size = 0;
    /* SPR 12932 FIX START */
    for( geran_cell_cnt = 0 ; geran_cell_cnt < num_inter_rat_gran_neighbors; geran_cell_cnt++) {

        temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                "BCCHARFCN");
        freq_found = OAM_FREQ_NOT_AVAILABLE;
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            arfcn = oam_atoi((Char8*)temp);

            freq_found = oam_find_arfcn_in_available_freqs(arfcn,
                    OAM_ARFCN_GERAN,
                    p_rrm_cellconfig);
            if(OAM_FREQ_NOT_AVAILABLE == freq_found) {
				OAM_LOG(OAM, OAM_WARNING, "BCCHARFCN of GSM neighbor not found "
                        "in available frequencies");
                OAM_ALARM(CRITICAL_CONFIGURATION_FAILURE_ALARM_ID,CRITICAL,NOTIFY_NEW_ALARM,
                        PROCESSING_ERROR_ALARM,UNAVAILABLE,EXPEDITED_ALARM,
                        "Startup Configuration Failure: Neighbor BCCHARFCN not configured",
                        OAM_NULL,OAM_ZERO);
                oam_abort();
                return OAM_FAILURE;
            }
        }
        if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                            "X_VENDOR_INSTANCE_ID"),OAM_INVALID_STR))!= OAM_ZERO)
        {
            instance_id = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],"X_VENDOR_INSTANCE_ID"));
            /* Coverity ID 78995 Fix Start*/
            if(instance_id==0 || instance_id > OAM_MAX_GSM_INST_ID_VAL)
            {
                loop++;
                continue;
            }
            /* Coverity ID 78995 Fix Start*/
            loop = instance_id -1;

            if(!((OAM_ONE << loop) & SON_PROV_REQ.inter_rat_gsm_daho_bitmask)) 
            {
                /*Other then DAHO Cell. If Cell is DAHO Cell, Then nrEntryBitMap is not set. 
                  But the DAHO entry is filled in SON NR LIST. DAHO cell*/
                p_nr_info->inter_rat_gsm_entry_bitmap |= (OAM_ONE << loop);
            }   
            /* SPR-13586 END */
            /* SPR 13185 FIX START */
            else
            {
                loop++;
                continue;
            }
            /* SPR 13185 FIX END */

            /* SPR 12932 FIX END */

            p_son_nr_add->nr_list.inter_rat_nr_list[loop].bitmask |=
                SON_INTER_GERAN_NEIGHBOR;


            p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.nbr_cgi.
                rat_type = SON_GERAN_CELL;

            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "PLMNID");
            if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
				OAM_LOG(OAM, OAM_WARNING,
						"XML file reading failed! Node FAPService->CellConfig"
                        "->LTE->RAN->NeighborList->InterRATCell->GSM->PLMNID not found.");
                retVal = OAM_FAILURE;
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            oam_convert_plmnid((Char8 *)temp_plmnid,temp);
            retVal = oam_populate_plmnid((Char8*)temp_plmnid,
                    &(p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                        nbr_cgi.plmn_id));
            if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_WARNING, "PLMN population failed.");
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }

            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "LAC");

            SInt32 LAC_Value = oam_atoi((Char8*)temp);

            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "CI");
            /* coverity 41176 */
            OAM_NULL_CHECK(temp != OAM_NULL);
            SInt32 CI_Value = oam_atoi((Char8*)temp);
            /*SPR 19721 FIX START*/
            p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.nbr_cgi.
                cell_identity[OAM_ONE] = (UInt8) (LAC_Value & 0x000000FF);

            p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.nbr_cgi.
                cell_identity[OAM_ZERO]  = (UInt8) ((LAC_Value >> OAM_EIGHT)& 0x000000FF);
            /*SPR 19721 FIX End*/

            p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.nbr_cgi.
                cell_identity[OAM_TWO] = (UInt8) (CI_Value & 0x000000FF);

            p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.nbr_cgi.
                cell_identity[OAM_THREE]  = (UInt8) ((CI_Value >> OAM_EIGHT)& 0x000000FF);
            p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.nbr_cgi.
                cell_identity[3] &= OAM_LOWER_FOUR_BIT_SET;

            /* SPR-13586 START */
            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "BSIC");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.pci.
                    bscc = lclTemp_value & OAM_GSM_CELL_BSIC_BSCC_MASK;
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.pci.
                    ncc = (lclTemp_value >> OAM_GSM_CELL_BSIC_NUM_NCC_BITS) & OAM_GSM_CELL_BSIC_BSCC_MASK;
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_PCI_PRESENT;
            }
            /* SPR-13586 END */

            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "X_VENDOR_CELL_SPECIFIC_OFFSET");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    cell_specific_offset = oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_CSO_PRESENT;
            }    
            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "X_VENDOR_RAC");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    rac = oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_RAC_PRESENT;
            }    
            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "BCCHARFCN");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    arfcn = oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_ARFCN_BAND_IND_PRESENT;
            }    
            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "BandIndicator");

            /* CSR 00070293 FIX START */
            /* SPR-13586 START */ 
            lclTemp_value = 
                oam_xml_search_string_to_integer((char *)temp, SON_GSM_BANDINDICATOR,
                        GSM_BANDINDICATOR_COUNT);  
            /* SPR-13586 END */

            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                /* coverity 35737 */
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    band_ind = (son_geran_band_indicator_et)lclTemp_value;
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_ARFCN_BAND_IND_PRESENT;

                /* CSR 00070293 FIX END */

            }    

            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "X_VENDOR_RSSI");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    rssi = oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_RSSI_PRESENT;
            }    
            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "X_VENDOR_NR_STATUS");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                /* coverity 35741 */
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    nr_status = (son_nr_status_et)oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_ENABLE_NR_STATUS_PRESENT;
            }    
            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "X_VENDOR_HO_STATUS");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                /* coverity 35740 */
                /* SPR-11757 removed code */ 
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    ho_status = (son_ho_status_et)oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_ENABLE_HO_STATUS_PRESENT;
            }
            /* SPR 11121 CHANGES START*/
            temp = oam_xmlNodeGetContent(p_cell_spec_params->GSM[geran_cell_cnt],
                    "X_VENDOR_DTM_SUPPORTED");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    dtm_supported  = oam_atoi((Char8*)temp);
                p_son_nr_add->nr_list.inter_rat_nr_list[loop].geran_neighbor.
                    bitmask |= SON_GERAN_DTM_SUPPORT_PRESENT;
            }
            /* SPR 11121 CHANGES END*/

            /* SPR 18930  FIX START */
            p_nr_info->first_nr_add_state = FIRST_NR_ADD_REQ_TO_BE_SENT;
            /* SPR 18930  FIX END */
            ++p_son_nr_add->nr_list.inter_rat_nr_list_size;
            /* SPR-13586 START */
            ++p_nr_info->inter_rat_gsm_list_size;
            ++loop;
            /* SPR-13586 END */
        }
    }

    /* Spr 15438 Fix Start */
    oam_son_nr_add_access_mode_handling(&p_son_nr_add->nr_list);
    /* Spr 15438 Fix End */
    /* RT SPR 8981 FIX END */
    /* GSM CHANGES END */
    OAM_FUN_EXIT_TRACE();
    return retVal;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_neigh_list_in_use
 *  DESCRIPTION      : This function is used to populate the son oam anr disable req parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

    oam_return_et
oam_populate_son_neigh_list_in_use(XML_struct_cell_config *p_cell_spec_params, oam_son_neigh_list_in_use_t  *p_neigh_list_in_use ,oam_rrm_cell_config_req_t *p_rrm_cellconfig)
{
    /*SPR 15604 START */
    OAM_FUN_ENTRY_TRACE();

    xmlChar *temp = OAM_NULL;
    xmlChar *temp1 = OAM_NULL;
    UInt16 lte_cell_cnt = OAM_ZERO;    
    UInt16 umts_cell_cnt = OAM_ZERO;
    UInt16 plmn_id_count = OAM_ZERO;
    Char8  *p_temp_token = OAM_NULL; 
    oam_return_et retVal = OAM_SUCCESS;
    UInt32 loop = 0;

    UInt32 utran_cid = 0;
    UInt32 utran_rncid = 0;
    oam_freq_type_et freq_found = OAM_FREQ_NOT_AVAILABLE;
    UInt16 uarfcn = 0;
    Char8 temp_plmnid[OAM_SEVEN] = {0};
    /* SPR 18930  FIX START */
    oam_eutran_nbr_cell_type_et nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
    /* SPR 18930  FIX END */

    /*SPR 16372 fix start*/
    SInt32 access_mode_in_file = OAM_OPEN_FEMTO;
    oam_bool_et is_access_mode_present  = OAM_FALSE;
    /* SPR 18930  FIX START */
    oam_access_mode_et calculated_access_mode = OAM_OPEN_FEMTO;
    /* SPR 18930  FIX END */
    /*SPR 16372 fix stop*/

    temp = oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,
            "MaxLTECellEntries");
    p_neigh_list_in_use->max_lte_cell_entries = oam_atoi((Char8*)temp);
    temp = oam_xmlNodeGetContent(p_cell_spec_params->NeighborListInUse,
            "LTECellNumberOfEntries");
    if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
        OAM_LOG(OAM, OAM_WARNING, "XML file reading failed! Node FAPService"
                "->CellConfig->LTE->RAN->NeighborList->"
                "LTECellNumberOfEntries not found.");
        retVal = OAM_FAILURE;
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list_size = oam_atoi((Char8*)temp);

    /* Assigning current number of enteries to last added instance id*/
    p_neigh_list_in_use->intra_rat_last_added_instance_id = p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list_size;
    SInt16 instance_id = OAM_ZERO;

    lte_cell_cnt = p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list_size;
    while(loop < lte_cell_cnt) {

        /* SPR 18930  FIX START */
        /* Code Removed */
        /* SPR 18930  FIX END */
        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop], "X_VENDOR_INSTANCE_ID");

        instance_id = oam_atoi((Char8*)temp);

        if (OAM_ZERO>=instance_id)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    " Returning as the instance_id value is : %d",instance_id);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        /* Initiatlizing the is valid field of intra rat cell*/
        /*SPR 16372 fix start*/
        /* p_neigh_list_in_use->
           intra_rat_is_valid[instance_id - 1] =  OAM_TRUE; */
        /*SPR 16372 fix stop*/

        temp =
            oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                    "EUTRACarrierARFCN");

        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi((Char8*)temp);
            freq_found =
                oam_find_arfcn_in_available_freqs((UInt16)lclTemp_value,
                        OAM_ARFCN_EUTRAN,
                        p_rrm_cellconfig);
            if(OAM_FREQ_NOT_AVAILABLE == freq_found) {
                /* SPR 15799 START */ 
                if(SON_NR_LOCKED ==(son_nr_status_et)oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->LTECell[loop],
                                "X_VENDOR_NR_STATUS")))
                {
                   OAM_LOG(OAM,OAM_WARNING,"EARFCN of the neighbor is not in the available freq list."
                            " NR Status of the neighbour is locked.Invalid Configuration !!!!");
                    return OAM_FAILURE; 

                }
                /* SPR 15799 END */ 
            }
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].earfcn = lclTemp_value;
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_EARFCN_PRESENT;
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,
                    "Mandatory tag EUTRACarrierARFCN[%d] not found", loop);
            OAM_FUN_EXIT_TRACE();
            retVal = OAM_FAILURE;
            return retVal;
        }

        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop], "PLMNID");
        if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            OAM_LOG(OAM, OAM_WARNING,
                    "XML file reading failed! Node FAPService->CellConfig"
                    "->LTE->RAN->NeighborList->LTECell->PLMNID not found.");
            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        oam_convert_plmnid(temp_plmnid,temp);
        retVal = oam_populate_plmnid((Char8*)temp_plmnid, 
                &(p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].nbr_cgi.plmn_id));
        if (OAM_SUCCESS == retVal) {
            OAM_LOG(OAM, OAM_INFO,
                    "Neighbor[%d]: PLMNID Populated Successfully",
                    instance_id - OAM_ONE);
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Neighbor[%d]: PLMNID Population Failed", loop);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop], "CID");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi((Char8*)temp);

            oam_conversion_from_int_to_byte_string(
                    p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                    nbr_cgi.cell_identity,lclTemp_value,OAM_CELL_ID_BITSTRING_SIZE ); 
        }

        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop], "PhyCellID");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].pci =
                oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_PCI_PRESENT;
        }

        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop], "QOffset");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp,
                    RAN_NeighborList_LTECell_QOffset[0], 31);

            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].cell_specific_offset =
                (son_q_offset_range_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_CELL_OFFSET_PRESENT;
        }

        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop], "X_VENDOR_TAC");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].tac[1] =					//BIT STRING FIX
                (lclTemp_value & OAM_LOWER_EIGHT_BITS_SET);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].tac[0] =
                ((lclTemp_value >> OAM_EIGHT ) & OAM_LOWER_EIGHT_BITS_SET);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_TAC_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_NUMPLMNID");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].num_plmn_id =
                oam_atoi((Char8*)temp);

            if(p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].num_plmn_id >
                    OAM_ZERO) {
                p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                    bitmask |= SON_PLMN_ID_PRESENT;
                temp = oam_xmlNodeGetContent(
                        p_cell_spec_params->LTECell_NLIU[loop],
                        "X_VENDOR_PLMN_ID");
                if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                    OAM_LOG(OAM, OAM_WARNING, "XML file reading failed! "
                            "Node FAPService->CellConfig->LTE->RAN->NeighborList"
                            "->LTECell->X_VENDOR_PLMN_ID not found.");
                    retVal = OAM_FAILURE;
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }

                p_temp_token = oam_strtok((Char8*)temp, ",");
                do {
                    retVal = oam_populate_plmnid(p_temp_token,
                            &(p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                                plmn_id[plmn_id_count++]));
                    if(OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_WARNING, "PLMN-ID list reading"
                                " failed.");
                        retVal = OAM_FAILURE;
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }

                    p_temp_token = oam_strtok(OAM_NULL, ",");
                } while(OAM_NULL != p_temp_token && plmn_id_count <  p_neigh_list_in_use->nrt_info.nr_list.
                        intra_rat_nr_list[instance_id - 1].num_plmn_id);
            }
        }

        /*SPR 16372 fix start*/
        /*temp = oam_xmlNodeGetContent(
          p_cell_spec_params->LTECell_NLIU[loop], "X_VENDOR_CSGID");
          if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
          lclTemp_value = oam_atoi((Char8*)temp);
          oam_conversion_from_int_to_byte_string(
          p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].csg_identity,
          lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
          p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
          bitmask |= SON_INTRA_CSG_ID_PRESENT;
          }*/
        /*SPR 16372 fix stop*/

        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_RSRP");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].rsrp =
                oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_RSRP_PRESENT;
        }

        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_RSRQ");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].rsrq =
                oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_RSRQ_PRESENT;
        }

        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_NR_STATUS");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].nr_status =
                (son_nr_status_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_ENABLE_NR_STATUS_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                "Blacklisted");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp,
                    NR_Blacklisted[OAM_ZERO], 2);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].ho_status =
                (son_ho_status_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_ENABLE_HO_STATUS_PRESENT;
        }


        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop], "CIO");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp,
                    RAN_NeighborList_LTECell_CIO[OAM_ZERO],OAM_THIRTY_ONE );
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].cm_cell_specific_offset =
                (son_q_offset_range_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_CM_CELL_OFFSET_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_BROADCAST_STATUS");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].broadcast_status =
                (son_bool_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_BROADCAST_STATUS_PRESENT;
        }

        /*SPR 16372 fix start*/
        access_mode_in_file = OAM_OPEN_FEMTO;
        is_access_mode_present  = OAM_FALSE;
        /*SPR 16372 fix stop*/

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_ACCESS_MODE");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {

            /*SPR 16372 fix start*/
            SInt32 temp_access_mode = oam_atoi((Char8*)temp);
            /*SPR 16372 fix stop*/
            if(p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].earfcn == 
                    p_rrm_cellconfig->ran_info.
                    rf_params.rf_configurations.dl_earfcn)   
            {
                OAM_LOG(OAM,OAM_INFO,"IntraFreq Nbr Cell Addition recieved ");
                /* SPR 18930  FIX START */
                nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
                /* SPR 18930  FIX END */
            }
            else
            {
                OAM_LOG(OAM,OAM_INFO,"InterFreq Nbr Cell Addition recieved ");
                /* SPR 18930  FIX START */
                nbr_cell_type = OAM_INTER_FREQ_NBR_CELL;
                /* SPR 18930  FIX END */
            }

            /*SPR 16372 fix start*/
            access_mode_in_file = temp_access_mode;
            is_access_mode_present  = OAM_TRUE;
            /*SPR 16372 fix stop*/


        }
        /* SPR 18930  FIX START */
        calculated_access_mode = oam_init_nbr_cell_access_mode_pci_validation(
                p_cell_spec_params,
                nbr_cell_type, 
                p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id -1].earfcn,
                p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id -1].pci,
                access_mode_in_file);

        /* Cov CID 107816 Fix Start */
        p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id -1].access_mode =(son_access_mode_et)calculated_access_mode;
        /* Cov CID 107816 Fix End */
        p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id -1].bitmask |= SON_ACCESS_MODE_PRESENT; 
        /* SPR 18930  FIX END */

        if((p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].access_mode == SON_OPEN ||
                    p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].access_mode == SON_OPEN_FEMTO))
        {
            if (oam_strcmp((const char *)oam_xmlNodeGetContent
                        (p_cell_spec_params->LTECell_NLIU[loop],"X_VENDOR_CSGID"),OAM_INVALID_STR)!= OAM_ZERO)
            {
                OAM_LOG(OAM,OAM_WARNING,"LTECell X_VENDOR_ACCESS_MODE is Open Access and" 
                        " CSG ID is present. Invalid Configuration ignoring CSGID Value");
                /*SPR 16372 fix start*/
                /*p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                  bitmask &= ~SON_INTRA_CSG_ID_PRESENT;*/
                /*SPR 16372 fix stop*/
            }
        }
        else
        {
            if((p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].access_mode == SON_CLOSED ||
                        p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].access_mode == SON_HYBRID) &&
                    (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],"X_VENDOR_CSGID"), OAM_INVALID_STR)!= OAM_ZERO))
            {

                /*SPR 16372 fix start*/
                if(!((OAM_TRUE == is_access_mode_present) && ((SON_OPEN ==  access_mode_in_file)||(SON_OPEN_FEMTO == access_mode_in_file))) )
                {
                    /*SPR 16372 fix stop*/
                    temp = oam_xmlNodeGetContent(
                            p_cell_spec_params->LTECell_NLIU[loop], "X_VENDOR_CSGID");
                    if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                        lclTemp_value = oam_atoi((Char8*)temp);
                        oam_conversion_from_int_to_byte_string(
                                p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].csg_identity,
                                lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                        p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                            bitmask |= SON_INTRA_CSG_ID_PRESENT;
                    }
                    /*SPR 16372 fix start*/
                }
                /*SPR 16372 fix stop*/
            }
            else
            {
                OAM_LOG(OAM,OAM_WARNING,"LTECell X_VENDOR_ACCESS_MODE is Closed/Hybrid Access but CSG ID is not present invalid Configuration");
                /*SPR 16372 fix start*/
                /* oam_handle_invalid_startup_config(); */
                /*SPR 16372 fix stop*/
            }
        }


        temp = oam_xmlNodeGetContent(
                p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_PRACH_ROOT_SEQUENCE_INDEX");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].prach_config.root_sequence_index =
                oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;

        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_PRACH_ZERO_CORRELATION_ZONE_CONFIG");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].prach_config.zero_correlation_zone_config =
                oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;

        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_PRACH_HIGH_SPEED_FLAG");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].prach_config.high_speed_flag = 
                oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;

        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_PRACH_FREQUENCY_OFFSET");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].prach_config.prach_frequency_offset =
                oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;

        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->LTECell_NLIU[loop],
                "X_VENDOR_PRACH_CONFIGURATION_INDEX");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].prach_config.prach_configuration_index =
                oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].
                bitmask |= SON_PRACH_CONFIGURATION_PRESENT;

            p_neigh_list_in_use->nrt_info.nr_list.intra_rat_nr_list[instance_id - 1].prach_config.
                bitmask |= SON_PRACH_CONFIG_INDEX_PRESENT;
        }
        /* SPR 17408 Fix +- */

        ++loop;
    }/* End of for loop */

    parmeter_value =
        (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_2,
                "MaxUMTSEntries");
    p_neigh_list_in_use->max_umts_entries = oam_atoi((Char8*)parmeter_value);
    temp = oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_2,
            "UMTSNumberOfEntries");
    if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
        OAM_LOG(OAM, OAM_WARNING,
                "XML file reading failed! Node FAPService->CellConfig->LTE"
                "->RAN->NeighborList->InterRATCell->UMTSNumberOfEntries not found.");
        retVal = OAM_FAILURE;
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }


    p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list_size = 0;
    umts_cell_cnt = oam_atoi((Char8*)temp);
    if(umts_cell_cnt > p_neigh_list_in_use->max_umts_entries) {
        OAM_LOG(OAM, OAM_WARNING,
                "Failed because UMTSNumberOfEntries > MaxUMTSEntries.");
        retVal = OAM_FAILURE;
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    /* Assigning current number of enteries to last added instance id*/
    p_neigh_list_in_use->inter_rat_last_added_instance_id
        = umts_cell_cnt;

    oam_memset(p_neigh_list_in_use->inter_rat_is_valid,0,32);

    /* RT SPR 9019 FIX START */
    loop = 0;
    while(loop < umts_cell_cnt) {

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_INSTANCE_ID");
        instance_id = oam_atoi((Char8*)temp);
        if (OAM_ZERO>=instance_id)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    " Returning as the instance_id value is : %d",instance_id);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        /* Initiatlizing the is valid field of inter rat cell*/
        p_neigh_list_in_use->  
            inter_rat_is_valid[instance_id - 1] =  OAM_TRUE;

        p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
            nbr_cgi.rat_type = SON_UTRAN_CELL;

        p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].
            bitmask |= SON_INTER_UTRAN_NEIGHBOR;

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "UARFCNDL");
        /*  coverity 85406 fix start */
        /* code removed */
        /*  coverity 85406 fix end */
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            uarfcn = oam_atoi((Char8*)temp);

            freq_found = oam_find_arfcn_in_available_freqs(uarfcn,
                    OAM_ARFCN_UTRAN,
                    p_rrm_cellconfig);
            if(OAM_FREQ_NOT_AVAILABLE == freq_found) {
                OAM_LOG(OAM, OAM_WARNING, "UARFCN of UMTS neighbor not found "
                        "in available frequencies");
                ++loop;
                continue;
            }
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].
                utran_neighbor.uarfcn = uarfcn;
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                bitmask |= SON_UTRAN_UARFCN_PRESENT;
        }
        else {
            OAM_LOG(OAM, OAM_WARNING, "Mandatory tag \"UARFCNDL\" missing");
            retVal = OAM_FAILURE;
            OAM_FUN_ENTRY_TRACE();
            return retVal;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "PCPICHScramblingCode");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            if(OAM_UTRAN_FREQ_FDD == freq_found) {
                p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                    pci.bitmask = SON_PCI_FDD_PRESENT;
                p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                    pci.pci_fdd = oam_atoi((Char8*)temp);
            }
            else if(OAM_UTRAN_FREQ_TDD == freq_found) {
                p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                    pci.bitmask = SON_PCI_TDD_PRESENT;
                p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                    pci.pci_tdd = oam_atoi((Char8*)temp);
            }
            else {
                OAM_LOG(OAM, OAM_WARNING, "UARFCN of UMTS neighbor not found "
                        "in available frequencies");

                ++loop;
                continue;
            }

            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                bitmask |= SON_UTRAN_PCI_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "PLMNID");
        if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            OAM_LOG(OAM, OAM_WARNING,
                    "XML file reading failed! Node FAPService->CellConfig"
                    "->LTE->RAN->NeighborList->InterRATCell->UMTS->PLMNID not found.");
            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        oam_convert_plmnid(temp_plmnid,temp);		//SPR 11315 PLMNID FIX

        retVal =
            oam_populate_plmnid((Char8*)temp_plmnid,
                    &(p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                        nbr_cgi.plmn_id));
        if(OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_WARNING, "PLMN population failed.");
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        temp =
            oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                    "RNCID");
        if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            OAM_LOG(OAM, OAM_WARNING,
                    "XML file reading failed! Node FAPService->CellConfig"
                    "->LTE->RAN->NeighborList->InterRATCell->UMTS->RNCID not found.");
            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        utran_rncid = oam_atoi((Char8*)temp);

        temp =
            oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                    "CID");
        if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            OAM_LOG(OAM, OAM_WARNING,
                    "XML file reading failed! Node FAPService->CellConfig"
                    "->LTE->RAN->NeighborList->InterRATCell->UMTS->CID not found.");
            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        utran_cid = oam_atoi((Char8*)temp);

        /* Check if the RNCID and CID values put together don't excceed
         * the 28-bit value range
         */
        if(utran_cid > OAM_12BIT_MAX_VALUE &&
                utran_rncid > OAM_12BIT_MAX_VALUE) {
            OAM_LOG(OAM, OAM_WARNING,
                    "The CellIdentity is 28-bit value, hence if RNCID is "
                    "greater than 4095, then CID must be less than 4096 or "
                    "vice versa.");

            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        oam_encode_rncid_to_cell_identity(p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].
                utran_neighbor.nbr_cgi.cell_identity,
                utran_rncid);

        oam_encode_cid_to_cell_identity(p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].
                utran_neighbor.nbr_cgi.cell_identity,
                utran_cid);

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_CELL_SPECIFIC_OFFSET");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                cell_specific_offset = oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_CSO_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "LAC");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi((Char8*)temp);
            /* SPR 19721 FIX START*/
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                lac[OAM_ONE] = (lclTemp_value & OAM_LOWER_EIGHT_BITS_SET);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                lac[OAM_ZERO] = ((lclTemp_value >> OAM_EIGHT) & OAM_LOWER_EIGHT_BITS_SET);
            /* SPR 19721 FIX END*/

            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_LAC_PRESENT ;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "RAC");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                rac = oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_RAC_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_NUMPLMNID");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                num_plmn_id = oam_atoi((Char8*)temp);
            if(p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                    num_plmn_id > OAM_ZERO) {
                temp = oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS_NLIU[loop],
                        "X_VENDOR_PLMN_LIST");
                if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                    OAM_LOG(OAM, OAM_WARNING, "XML file reading failed! "
                            "Node FAPService->CellConfig->LTE->RAN->NeighborList"
                            "->InterRATCell->UMTS->X_VENDOR_PLMN_LIST not found.");
                    retVal = OAM_FAILURE;
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }

                p_temp_token = oam_strtok((Char8*)temp, ",");
                plmn_id_count = OAM_ZERO;
                do {
                    retVal = oam_populate_plmnid(p_temp_token,
                            &(p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].
                                utran_neighbor.plmn_id[plmn_id_count++]));
                    if(OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_WARNING,
                                "PLMN-ID list reading failed.");
                        retVal = OAM_FAILURE;
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }

                    p_temp_token = oam_strtok(OAM_NULL, ",");
                } while(OAM_NULL != p_temp_token && plmn_id_count < p_neigh_list_in_use->nrt_info.nr_list.
                        inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                        num_plmn_id);
                p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                    bitmask |= SON_UTRAN_PLMN_ID_PRESENT;
            }
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_ACCESS_MODE");

        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                access_mode = (son_access_mode_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].utran_neighbor.
                bitmask |= SON_UTRAN_ACCESS_MODE_PRESENT;
        }
        /* SPR 17408 Fix Start */
        if((p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].
                    bitmask & SON_UTRAN_ACCESS_MODE_PRESENT) &&
                (p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].
                 utran_neighbor.access_mode != SON_OPEN) &&
                (p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - 1].
                 utran_neighbor.access_mode != SON_OPEN_FEMTO))
            /* SPR 17408 Fix End */
        {
            temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                    "X_VENDOR_CSGID");
            if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi((Char8*)temp);
                oam_conversion_from_int_to_byte_string(
                        p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                        csg_identity,
                        lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                    bitmask |= SON_UTRAN_CSG_ID_PRESENT;
            }
        }
        else {
            /* SPR 17408 Fix Start */
            OAM_LOG(OAM, OAM_INFO, "Ignoring CSGID as access_mode is set to Open/Open Femto");
            /* SPR 17408 Fix End */
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_RSCP");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.rscp
                = oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_RSCP_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_ECNO");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.ecno
                = oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_ECNO_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_NR_STATUS");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                nr_status = (son_nr_status_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_ENABLE_NR_STATUS_PRESENT;
        }

        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_HO_STATUS");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                ho_status = (son_ho_status_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_ENABLE_HO_STATUS_PRESENT;
        }

        temp = temp1 = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_PS_HO_SUPPORTED");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp, NR_PS_HO_SUPPORTED[OAM_ZERO], OAM_TWO);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                ps_ho_supported = (son_bool_et)oam_atoi((Char8*)temp);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_PS_HO_SUPPORT_PRESENT;
        }
        temp = oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[loop],
                "X_VENDOR_VOIP_CAPABLE");
        if(oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            oam_search_integer_to_interger((Char8*)temp, NR_VOIP_CAPABLE[OAM_ZERO], OAM_TWO);
            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                voip_capable = (son_bool_et)oam_atoi((Char8*)temp);
            if(!oam_strcmp((Char8*)temp,"1")){
                if(!oam_strcmp((Char8*)temp1,"0")){
                    OAM_LOG(OAM, OAM_WARNING,
                            "value of voip_capable cannot be 1(true) when value of ps_ho_supported is 0(false) for UMTS neighor instance_id %d thus considering ps_ho_supported as 1(true)", instance_id);
                    p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                        voip_capable = (son_bool_et)oam_atoi((Char8*)temp1); 
                }  
            }

            p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list[instance_id - OAM_ONE].utran_neighbor.
                bitmask |= SON_UTRAN_VOIP_CAPABLE_PRESENT;
        }  
        ++p_neigh_list_in_use->nrt_info.nr_list.inter_rat_nr_list_size;
        /* SPR 18930  FIX START */
        ++p_neigh_list_in_use->inter_rat_umts_neigh_size;
        /* SPR 18930  FIX END */
        p_neigh_list_in_use->inter_rat_umts_neigh_valid_bitmap |= OAM_ONE << (instance_id -1);
        ++loop;
    }


    oam_son_nr_add_access_mode_handling(&p_neigh_list_in_use->nrt_info.nr_list);
    temp = oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_2,
            "MaxGSMEntries");
    OAM_NULL_CHECK(temp != OAM_NULL);
    if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
        OAM_LOG(OAM, OAM_WARNING,
                "XML file reading failed! Node FAPService->CellConfig->LTE"
                "->RAN->NeighborListInUse->InterRATCell->MaxGSMEntries not found.");
        retVal = OAM_FAILURE;
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }

    p_neigh_list_in_use->max_gsm_entries = oam_atoi((Char8*)temp);

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/*SPR 15604 END*/


#endif

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_rrm_inter_rat_ncl_utran
 *  DESCRIPTION      : This function is used to populate the rrm dynamic icic 
 *                                         parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_rrm_inter_rat_ncl_utran
(
 oam_rrm_cell_config_req_t  *p_rrm_cellconfig,
 XML_struct_cell_config *p_cell_spec_params
 )
{

    Char8 *temp;
    UInt16 umts_cell_cnt = OAM_ZERO;
    /* RT SPR 8627 FIX START */
    UInt32 utran_cid = OAM_ZERO;
    UInt32 utran_rncid = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;
    UInt8 temp_plmnid[OAM_SEVEN] = {0};
    /* RT SPR 8627 FIX END */
    /* Spr 15612  Fix Start*/
    /* SPR 18930  FIX START */
    UInt16 umts_cell_cnt_1 = OAM_ZERO;
    /* SPR 18930  FIX END */
    UInt16 umts_cell_num_entries =  OAM_ZERO;
    UInt16 max_umts_cell_entries = OAM_ZERO;
    UInt8 umts_cell_enable = OAM_ZERO;  
    UInt8 umts_cell_mi = OAM_ZERO;
    /* Spr 15612  Fix End*/


    OAM_FUN_ENTRY_TRACE();
    if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_1,
                        "UMTSNumberOfEntries"),OAM_INVALID_STR))!= OAM_ZERO)
    {
        /* Spr 15612  Fix Start*/
        umts_cell_num_entries = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->InterRATCell_1,"UMTSNumberOfEntries"));
        /* SPR 18930  FIX START */
        /*Code Removed*/
        /* SPR 18930  FIX END */
        /* Spr 15612  Fix End*/
    }
    /* Spr 15612  Fix Start*/
    if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_1,
                        "MaxUMTSEntries"),OAM_INVALID_STR))!= OAM_ZERO)
    {
        max_umts_cell_entries = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->InterRATCell_1,"MaxUMTSEntries"));
    }
    if(umts_cell_num_entries > max_umts_cell_entries)
    {
        OAM_LOG(OAM, OAM_INFO,"Population Fail,MaxUMTSEntries < UMTSNumberOfEntries");
        return OAM_FAILURE;
    }


    for (umts_cell_cnt = OAM_ZERO;umts_cell_cnt <umts_cell_num_entries;
            umts_cell_cnt++)
    {
        umts_cell_enable = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS[umts_cell_cnt],"Enable"));
        umts_cell_mi = oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS[umts_cell_cnt],"MustInclude"));

        if((umts_cell_enable == OAM_TRUE)&&(umts_cell_mi == OAM_TRUE))
        {
            /* Spr 15612  Fix End*/

            temp = (char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],"PLMNID");
            /* Coverity FIX 41166 */
            if(OAM_NULL == temp)
            {
                return OAM_FAILURE;
            }
            oam_convert_plmnid((Char8 *)temp_plmnid,temp); 
            /* SPR 18930  FIX START */
            oam_fill_mcc_mnc_from_plmnid((Char8 *)temp_plmnid,&p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].rai.lai.plmn_id);

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS[umts_cell_cnt],"LAC"));
            /* SPR 19721 FIX START*/
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].rai.lai.lac[OAM_ONE]= (lclTemp_value & OAM_LOWER_EIGHT_BITS_SET);

            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].rai.lai.lac[OAM_ZERO]=(lclTemp_value >>OAM_EIGHT ) & OAM_LOWER_EIGHT_BITS_SET;
            /* SPR 19721 FIX End*/

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS[umts_cell_cnt],"RAC"));
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].rai.rac=lclTemp_value;


            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS[umts_cell_cnt],"UARFCNDL"));
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].uarfcndl=lclTemp_value;

            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                "UARFCNUL"),OAM_INVALID_STR))!= OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"UARFCNUL"));
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].uarfcnul=lclTemp_value;

                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].bitmask|=RRM_OAM_UTRAN_FREQ_UARFCNUL_PRESENT;
            } 

            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS[umts_cell_cnt],"PCPICHScramblingCode"));
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].pcpich_scrambling_code=lclTemp_value;

            /* Spr 15612  Fix Start*/
            if (((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                    "PCPICHTxPower"),OAM_INVALID_STR))!= OAM_ZERO))
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"PCPICHTxPower"));
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].pcpich_tx_power=lclTemp_value;
            }
            else
            {
                OAM_LOG(OAM, OAM_INFO,
                        "Node NeighborList->InterRATCell->UMTS->PCPICHTxPower not found"
                        " Filling Default Value =%d",OAM_PCPICH_TX_POWER_DEFAULT_VALUE);

                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].pcpich_tx_power=OAM_PCPICH_TX_POWER_DEFAULT_VALUE;
            }
            /* Spr 15612  Fix end*/


            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_OFFSETFREQ"));
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].offset_freq=lclTemp_value;


            /* Spr 15612  Fix Start*/
            if (((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                    "URA"),OAM_INVALID_STR))!= OAM_ZERO))
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"URA"));
                p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].ura=lclTemp_value;
            }
            else
            {
                OAM_LOG(OAM, OAM_INFO,
                        "Node NeighborList->InterRATCell->UMTS->URA not found"
                        " Filling Default Value =%d",OAM_URA_DEFAULT_VALUE);


                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].ura = OAM_URA_DEFAULT_VALUE;
            }
            /* Spr 15612  Fix end*/


            /* RT SPR 8627 FIX START */
            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                    "RNCID");
            if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
			OAM_LOG(OAM, OAM_WARNING,
                        "XML file reading failed! Node FAPService->CellConfig"
                        "->LTE->RAN->NeighborList->InterRATCell->UMTS->RNCID not found.");
                retVal = OAM_FAILURE;
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }

            utran_rncid = oam_atoi((Char8*)temp);

            temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                    "CID");
            if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
			OAM_LOG(OAM, OAM_WARNING,
                        "XML file reading failed! Node FAPService->CellConfig"
                        "->LTE->RAN->NeighborList->InterRATCell->UMTS->CID not found.");
                retVal = OAM_FAILURE;
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }

            utran_cid = oam_atoi((Char8*)temp);

            /* Check if the RNCID and CID values put together don't excceed
             * the 28-bit value range
             */
            if(utran_cid > OAM_12BIT_MAX_VALUE &&
                    utran_rncid > OAM_12BIT_MAX_VALUE) {
			OAM_LOG(OAM, OAM_WARNING,
                        "The CellIdentity is 28-bit value, hence if RNCID is "
                        "greater than 4095, then CID must be less than 4096 and "
                        "vice versa.");
                retVal = OAM_FAILURE;
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].uc_id.
                cell_id[0] = (utran_cid & 0x00FF);
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].uc_id.
                cell_id[1] = (utran_cid & 0xFF00) >> 8;

            if(utran_rncid <= OAM_12BIT_MAX_VALUE) {
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].uc_id.rnc_id =
                    utran_rncid;
            }
            else {
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].uc_id.
                    rnc_id = OAM_ZERO;

                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].uc_id.
                    extended_rnc_id = utran_rncid;

                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].uc_id.
                    bitmask |= RRM_OAM_UTRAN_EXTN_RNC_ID_PRESENT;
            }
            /* Code removed SPR #13315 Fix*/
            /* RT SPR 8627 FIX END */
            /* SPR 17408 Fix Start */
            /* 2.2 New parameters population start */

            if (((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                    "X_VENDOR_ACCESS_MODE"),OAM_INVALID_STR))!= OAM_ZERO))
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_ACCESS_MODE"));
                p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.
                    utran_freq_cells[umts_cell_cnt_1].cell_access_mode=lclTemp_value;
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].bitmask |= RRM_OAM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT;


            }
            if((p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].
                        bitmask & RRM_OAM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                    ((p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].
                     cell_access_mode == RRM_OAM_ACCESS_MODE_OPEN) ||
                    (p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].
                     cell_access_mode == RRM_OAM_ACCESS_MODE_OPEN_FEMTO)))
            {
                OAM_LOG(OAM, OAM_WARNING, "CSGID will not be read into "
                        " inter_rat_ncl.utran_freq_cells as ACCESS_MODE is present"
                        " and its value is Open/Open Femto");
            }
            else 
            {
                if (((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                        "X_VENDOR_CSGID"),OAM_INVALID_STR))!= OAM_ZERO))
                {
                    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                                p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_CSGID"));
                    oam_conversion_from_int_to_byte_string(p_rrm_cellconfig->ran_info.ncl_params.
                            inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].csg_identity, lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                    p_rrm_cellconfig->ran_info.ncl_params.
                        inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].bitmask |= RRM_OAM_UTRAN_FREQ_CSG_ID_PRESENT;

                }
            }
            /* SPR 17408 Fix End */

            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                "X_VENDOR_BLACKLISTED"),OAM_INVALID_STR))!= OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_BLACKLISTED"));
                p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].blacklisted=lclTemp_value;
            }

            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                "X_VENDOR_HO_STATUS"),OAM_INVALID_STR))!= OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_HO_STATUS"));
                p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].ho_status=lclTemp_value;
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].bitmask |= RRM_OAM_UTRAN_HO_STATUS_PRESENT;
            }

            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                "X_VENDOR_PS_HO_SUPPORTED"),OAM_INVALID_STR))!= OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_PS_HO_SUPPORTED"));
                p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].ps_ho_supported=(rrm_bool_et)lclTemp_value;
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].bitmask |= RRM_OAM_UTRAN_PS_HO_SUPPORTED_PRESENT;
            }

            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                "X_VENDOR_VOIP_CAPABLE"),OAM_INVALID_STR))!= OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_VOIP_CAPABLE"));
                p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].voip_capable=(rrm_bool_et)lclTemp_value;
                /* coverity 60889 */
                if((lclTemp_value == OAM_ONE) && (p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].ps_ho_supported == (rrm_bool_et)OAM_ZERO) && (p_rrm_cellconfig->ran_info.ncl_params.
                            inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].bitmask & RRM_OAM_UTRAN_PS_HO_SUPPORTED_PRESENT)){
                    p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].voip_capable = (rrm_bool_et)OAM_ZERO;
                }
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].bitmask |= RRM_OAM_UTRAN_VOIP_CAPABLE_PRESENT;
            }

            if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                "X_VENDOR_DAHO_INDICATION"),OAM_INVALID_STR))!= OAM_ZERO)
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_DAHO_INDICATION"));
                p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].daho_indication=lclTemp_value;
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt_1].bitmask |= RRM_OAM_UTRAN_DAHO_IND_PRESENT;
#ifdef OAM_SON_ENABLE
                /* SPR 12932 FIX START */
                UInt32 instance_id = OAM_ZERO;

                if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],
                                    "X_VENDOR_INSTANCE_ID"),OAM_INVALID_STR))!= OAM_ZERO)
                {
                    instance_id = oam_atoi((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_INSTANCE_ID"));

                }
                /* SPR 12932 FIX END */

                /* SPR-10462 Start*/
                /* SPR 12932 FIX START */
                if((lclTemp_value == OAM_ONE) && (umts_daho_found_flag == OAM_FALSE))
                {
                    umts_daho_found_flag = OAM_TRUE;
                    /* SPR-13586 START */
                    /*ut_bug_fix__15467_start CID 78991*/
                    if (instance_id > OAM_ZERO)
                    {
                        SON_PROV_REQ.inter_rat_umts_daho_bitmask |= OAM_ONE<<(instance_id - OAM_ONE);
                    }
                    /*ut_bug_fix__15467_end CID 78991*/
                    /* SPR-13586 END */

                }  
                /* SPR 12932 FIX END */
#endif

            }
            /* 2.2 New parameters population end */
            /* Spr 15612 Fix Start*/
            umts_cell_cnt_1 ++;
        } /* End Of Enable MI If Condition */
    }/* End of for loop */

    if(umts_cell_cnt_1 > OAM_ZERO)
    {
        p_rrm_cellconfig->ran_info.bitmask |= RRM_OAM_NCL_PARAMS_PRESENT;
        p_rrm_cellconfig->ran_info.ncl_params.bitmask |= RRM_OAM_INTER_RAT_NCL_PRESENT;
    }
    p_rrm_cellconfig->ran_info.ncl_params.
        inter_rat_ncl.num_valid_utran_freq_cell= umts_cell_cnt_1;
    /* SPR 18930  FIX END */
    /* Spr 15612 Fix End*/


    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_cell_info_ind
 *  DESCRIPTION      : This function is used to populate the son oam cell info indication parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
#ifdef OAM_SON_ENABLE
oam_return_et
    oam_populate_son_cell_info_ind
(
 XML_struct_cell_config *p_cell_spec_params,
 son_cell_t *p_serving_cell,
 oam_rrm_cell_config_req_t *p_rrm_cellconfig
 )
{

    OAM_FUN_ENTRY_TRACE();

    Char8 *temp;
    UInt16 counter = OAM_ZERO;
    oam_return_et retVal = OAM_FAILURE;
    SInt32 tag_found1 = OAM_ZERO;
    SInt32 tag_found2 = OAM_ZERO;
    UInt8 temp_plmnid[OAM_SEVEN] = {0};
    /* SPR 15917 START */
    UInt8 index = OAM_ZERO;
    /* SPR 15917 END */
    /*SPR 21702 +-*/
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EPC,"PLMNListNumberOfEntries"));/* Populate num_plmn_id */


    /* SPR 15917 START */
    for (counter= OAM_ZERO; counter<lclTemp_value; counter++)
    {
        if (OAM_TRUE == (oam_bool_et)oam_atoi((char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PLMNList[counter],"Enable"))) 
        {
            if (((oam_strcmp((const char *)oam_xmlNodeGetContent( p_cell_spec_params->PLMNList[counter],"PLMNID"),OAM_INVALID_STR))!= OAM_ZERO)) 
            {
                temp = (char *)oam_xmlNodeGetContent( p_cell_spec_params->PLMNList[counter],"PLMNID"); 
                /* SPR 13806 FIX Start */
                oam_convert_plmnid((Char8 *)temp_plmnid,temp);
                /* SPR 13806 FIX End */
                /* Populate plmn_id list*/
                /* SPR 13806 FIX Start */
                retVal = oam_populate_plmnid((Char8 *)temp_plmnid,&(p_serving_cell->plmn_id[index]));
                /* SPR 13806 FIX End */

                p_serving_cell->num_plmn_id= lclTemp_value;

                p_serving_cell->bitmask = SON_CELL_PLMN_PRESENT;

                index++;
            }
        }
        /* Coverity FIX 33639 */
        if(OAM_FAILURE == retVal) 
        {
					OAM_LOG(OAM, OAM_WARNING, "Population of PLMN-ID failed.");
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        /* SPR 15917 END */
    }

    /* SPR 15917 START */
    /* Find Primary PLMNID to fill global ECGI */
    oam_find_primary_plmnid(&temp,p_cell_spec_params);
    if(OAM_NULL == temp)
    {
        OAM_LOG(OAM,OAM_WARNING,"Failure in populating Primary PLMNID");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    oam_convert_plmnid((Char8 *)temp_plmnid,temp);
    /*Populate Primary PLMN ID */
    retVal = oam_populate_plmnid((Char8 *)temp_plmnid,&(p_serving_cell->src_cgi.plmn_id));
    /* Coverity FIX 33639 */
    if(OAM_FAILURE == retVal) 
    {
			OAM_LOG(OAM, OAM_WARNING, "Population of PLMN-ID failed.");
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }

    /* SPR 15917 END */


    oam_memcpy(p_serving_cell->src_cgi.cell_identity,
            p_rrm_cellconfig->global_cell_info.eutran_global_cell_id.
            cell_identity,
            SON_CELL_ID_OCTET_SIZE);

    /* SPR 13060 FIX START */
    p_serving_cell->pci = p_rrm_cellconfig->ran_info.rf_params.
        rf_configurations.phy_cell_id;
    /* SPR 13060 FIX END */

    if(  (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->EPC,"TAC"), OAM_INVALID_STR) != OAM_ZERO))
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->EPC,"TAC"));
        p_serving_cell->bitmask |= SON_CELL_TAC_PRESENT;

        p_serving_cell->tac[OAM_ONE] = (lclTemp_value & OAM_LOWER_EIGHT_BITS_SET);
        p_serving_cell->tac[OAM_ZERO] = ((lclTemp_value >>  OAM_EIGHT) & OAM_LOWER_EIGHT_BITS_SET );
    }

    /* CSR00053377_CHANGES_START */
    /*Bug Fix 8607 start*/
    if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
                    /* spr_21013_fix_start */
                    xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"FDDMode",oam_strlen("FDDMode")+1))
        /* spr_21013_fix_end */
    {
        p_serving_cell->choice_eutra_mode.bitmask |= SON_EUTRA_MODE_FDD;
        p_serving_cell->bitmask |= SON_CELL_EUTRA_MODE_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"EARFCNUL"));

        p_serving_cell->choice_eutra_mode.fdd_info.ul_earfcn = lclTemp_value;
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"EARFCNDL"));
        p_serving_cell->choice_eutra_mode.fdd_info.dl_earfcn = lclTemp_value;
        lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"DLBandwidth"),DLBandwidth,DL_BANDWIDTH_COUNT);

        p_serving_cell->choice_eutra_mode.fdd_info.dl_trnsmission_bdwidth = lclTemp_value;

        lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"ULBandwidth"),UlBandwidth,UL_BANDWIDTH_COUNT);

        p_serving_cell->choice_eutra_mode.fdd_info.ul_trnsmission_bdwidth = lclTemp_value;
    }
    else if(OAM_ZERO == oam_strncmp((const char *)oam_xmlNodeGetContent(
                    /* spr_21013_fix_start */
                    xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode"),"TDDMode",oam_strlen("TDDMode")+1))
        /* spr_21013_fix_end */
    {
        p_serving_cell->choice_eutra_mode.bitmask |= SON_EUTRA_MODE_TDD;

        p_serving_cell->bitmask |= SON_CELL_EUTRA_MODE_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"EARFCNDL"));
        p_serving_cell->choice_eutra_mode.tdd_info.earfcn=lclTemp_value;
        /* RT-SPR 9260 Fix Start*/ 
        lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->RF_1,"DLBandwidth"),DLBandwidth,DL_BANDWIDTH_COUNT);
        /* RT-SPR 9260 Fix End*/ 
        p_serving_cell->choice_eutra_mode.tdd_info.trnsmission_bdwidth=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->TDDFrame,"SubFrameAssignment"));

        p_serving_cell->choice_eutra_mode.tdd_info.subframe_assn=lclTemp_value;


        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->TDDFrame,"SpecialSubframePatterns"));

        p_serving_cell->choice_eutra_mode.tdd_info.special_subframe_info.special_subframe_patterns=lclTemp_value;

        p_serving_cell->choice_eutra_mode.tdd_info.special_subframe_info.dl_cp=OAM_DL_CP;

        p_serving_cell->choice_eutra_mode.tdd_info.special_subframe_info.ul_cp=OAM_UL_CP;
    }
    else
    {
		OAM_LOG(OAM, OAM_WARNING, "Value of DuplexMode is not set to "
				"either FDDMode or TDDMode");
        return OAM_FAILURE;
    }
    /* CSR00053377_CHANGES_END */
    /*Filling Tdd params end*/

    /*Bug Fix 8607 End*/


    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->RF_1,"EARFCNUL"), OAM_INVALID_STR) != OAM_ZERO))
    {
        p_serving_cell->bitmask |= SON_CELL_EUTRA_MODE_PRESENT;
    }



    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"ULBandwidth"),UlBandwidth,UL_BANDWIDTH_COUNT);

    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"DLBandwidth"),DLBandwidth,DL_BANDWIDTH_COUNT);

    /* SPR 8808 start */
    if(RRM_OAM_ACCESS_MODE_OPEN != p_rrm_cellconfig->access_mgmt_params.
            access_mode) {
        oam_memcpy(p_serving_cell->csg_identity,
                p_rrm_cellconfig->access_mgmt_params.csg_id,
                SON_CSG_ID_OCTET_SIZE);

        p_serving_cell->bitmask |=  SON_CELL_CSG_IDENTITY_PRESENT;
    }
    /* SPR 8808 end */

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(p_cell_spec_params->RACH,"PreambleInitialReceivedTargetPower"),RAN_MAC_RACH_preambleInitialReceivedTargetPower[OAM_ZERO],  PREAMBLEINITIALRECEIVEDTARGETPOWER_COUNT);
    /* coverity 52793 */	
    p_serving_cell->preamble_initial_rcvd_target_power = (son_preamble_init_rec_target_pow_et)lclTemp_value;
    p_serving_cell->bitmask |= SON_CELL_PREAMBLE_INITIAL_RCVD_TARGET_POWER_PRESENT;

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(p_cell_spec_params->RACH,"SizeOfRaGroupA"), RAN_MAC_RACH_sizeOfRaGroupA[OAM_ZERO], SIZEOFRAGROUPA_COUNT);
    /* coverity 52773 53543*/
    p_serving_cell->size_of_ra_group_a = (son_oam_ra_preambles_group_a_size_et)lclTemp_value;
    p_serving_cell->bitmask |=SON_CELL_SIZE_OF_RA_GROUP_A_PRESENT; 

    lclTemp_value=oam_atoi(( char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"RootSequenceIndex"));
    p_serving_cell->prach_config.root_sequence_index = lclTemp_value;
    p_serving_cell->bitmask |= SON_CELL_PRACH_CONFIG_PRESENT;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"ZeroCorrelationZoneConfig"));
    p_serving_cell->prach_config.zero_correlation_zone_config=lclTemp_value;
    p_serving_cell->bitmask |= SON_CELL_PRACH_CONFIG_PRESENT;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"HighSpeedFlag"));
    p_serving_cell->prach_config.high_speed_flag=lclTemp_value;
    p_serving_cell->bitmask |= SON_CELL_PRACH_CONFIG_PRESENT;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"FreqOffset"));
    p_serving_cell->prach_config.prach_frequency_offset=lclTemp_value;  
    p_serving_cell->bitmask |= SON_CELL_PRACH_CONFIG_PRESENT;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PRACH,"ConfigurationIndex"));
    p_serving_cell->prach_config.bitmask |= SON_PRACH_CONFIG_INDEX_PRESENT;
    p_serving_cell->bitmask |= SON_CELL_PRACH_CONFIG_PRESENT;
    p_serving_cell->prach_config.prach_configuration_index = lclTemp_value;

    lclTemp_value=oam_xml_search_integer_to_integer((char *)oam_xmlNodeGetContent(
                p_cell_spec_params->RACH,"NumberOfRaPreambles"),RAN_MAC_RACH_NumberOfRaPreambles[OAM_ZERO],NUMBEROFRAPREAMBLES_COUNT);
    /* coverity 53544 */
    p_serving_cell->number_of_ra_preambles = (son_oam_ra_preamble_count_et)lclTemp_value;
    p_serving_cell->bitmask |=SON_CELL_NUMBER_OF_RA_PREAMBLES_PRESENT;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->PUSCH,"HoppingOffset"));
    p_serving_cell->pusch_hopping_offset = lclTemp_value;
    p_serving_cell->bitmask |= SON_CELL_PUSCH_HOPPING_OFFSET_PRESENT;
    /* SPR 9574 Fix Start */

    /* SPR 11245 FIX START */
    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
            "X_VENDOR_OPEN_PHY_CELLID_START");
    tag_found1 = oam_strcmp(temp, OAM_INVALID_STR);

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
            "X_VENDOR_OPEN_PHY_CELLID_RANGE");
    tag_found2 = oam_strcmp(temp, OAM_INVALID_STR);

    if(tag_found1 && tag_found2) {
        temp =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                    "X_VENDOR_OPEN_PHY_CELLID_START");

        p_serving_cell->intra_freq_open_pci_range.
            pci_start = oam_atoi(temp);

		OAM_LOG(OAM, OAM_INFO,
                "X_VENDOR_OPEN_PHY_CELLID_START: %s", temp);

        /* SPR 12920 Fix Start */
        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_OPEN_PHY_CELLID_RANGE"),PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);
        /* SPR 12920 Fix End */


        p_serving_cell->intra_freq_open_pci_range.
            pci_range = (son_oam_cell_id_range_et)lclTemp_value;

		OAM_LOG(OAM, OAM_INFO,
                "X_VENDOR_OPEN_PHY_CELLID_RANGE: %d", lclTemp_value);

        p_serving_cell->bitmask |=
            SON_CELL_INTRA_FREQ_OPEN_PCI_RANGE_PRESENT;
    }

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
            "X_VENDOR_CSG_PHY_CELLID_START");
    tag_found1 = oam_strcmp(temp, OAM_INVALID_STR);

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
            "X_VENDOR_CSG_PHY_CELLID_RANGE");
    tag_found2 = oam_strcmp(temp, OAM_INVALID_STR);

    if(tag_found1 && tag_found2) {
        temp =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                    "X_VENDOR_CSG_PHY_CELLID_START");

        p_serving_cell->intra_freq_closed_pci_range.
            pci_start = oam_atoi(temp);

		OAM_LOG(OAM, OAM_INFO,
                "X_VENDOR_CSG_PHY_CELLID_START: %s", temp);

        /* SPR 12920 Fix Start */
        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_CSG_PHY_CELLID_RANGE"),PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);
        /* SPR 12920 Fix End */


        p_serving_cell->intra_freq_closed_pci_range.
            pci_range = (son_oam_cell_id_range_et)lclTemp_value;

		OAM_LOG(OAM, OAM_INFO,
                "X_VENDOR_CSG_PHY_CELLID_RANGE: %d", lclTemp_value);

        p_serving_cell->bitmask |=
            SON_CELL_INTRA_FREQ_CLOSED_PCI_RANGE_PRESENT;
    }

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
            "X_VENDOR_HYBRID_PHY_CELLID_START");
    tag_found1 = oam_strcmp(temp, OAM_INVALID_STR);

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
            "X_VENDOR_HYBRID_PHY_CELLID_RANGE");
    tag_found2 = oam_strcmp(temp, OAM_INVALID_STR);

    if(tag_found1 && tag_found2) {
        temp =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                    "X_VENDOR_HYBRID_PHY_CELLID_START");

        p_serving_cell->intra_freq_hybrid_pci_range.
            pci_start = oam_atoi(temp);

		OAM_LOG(OAM, OAM_INFO,
                "X_VENDOR_HYBRID_PHY_CELLID_START: %s", temp);

        /* SPR 12920 Fix Start */
        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_HYBRID_PHY_CELLID_RANGE"),PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);
        /* SPR 12920 Fix End */


        p_serving_cell->intra_freq_hybrid_pci_range.
            pci_range = (son_oam_cell_id_range_et)lclTemp_value;

		OAM_LOG(OAM, OAM_INFO,
                "X_VENDOR_HYBRID_PHY_CELLID_RANGE: %d", lclTemp_value);

        p_serving_cell->bitmask |=
            SON_CELL_INTRA_FREQ_HYBRID_PCI_RANGE_PRESENT;
    }
    /* SPR 11245 FIX END */

    /* SPR 9574 Fix End */
    /*SPR 14154:start*/

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
            "X_VENDOR_ABS_USAGE_THRESHOLD_MIN");

    tag_found1 = oam_strcmp(temp, OAM_INVALID_STR);
    if(tag_found1){

        p_serving_cell->abs_usage_threshold.min_abs_usage_threshold =oam_atoi(temp);
        p_serving_cell->bitmask |= SON_CELL_ABS_USAGE_THRESHOLD_RANGE;
        p_serving_cell->abs_usage_threshold.bitmask |= SON_CELL_MIN_ABS_USAGE_THRESHOLD_PRESENT;


    }

    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
            "X_VENDOR_ABS_USAGE_THRESHOLD_MAX");

    tag_found1 = oam_strcmp(temp, OAM_INVALID_STR);
    if(tag_found1){

        p_serving_cell->abs_usage_threshold.max_abs_usage_threshold =oam_atoi(temp);
        p_serving_cell->bitmask |= SON_CELL_ABS_USAGE_THRESHOLD_RANGE;
        p_serving_cell->abs_usage_threshold.bitmask |= SON_CELL_MAX_ABS_USAGE_THRESHOLD_PRESENT;


    }
    /*SPR 14154:end*/

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

#endif

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_nr_enb_add_req
 *  DESCRIPTION      : This function is used to populate the son enable add req parameters
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
#ifdef OAM_SON_ENABLE
/* + SPR 17439 */
    oam_return_et
oam_populate_son_nr_enb_add_req(void)
{
    /* - SPR 17439 */

    OAM_FUN_ENTRY_TRACE();

    UInt32    enb_count = OAM_ZERO,
              addr_count = OAM_ZERO;
    Char8     *temp;
    oam_return_et retVal = OAM_FAILURE;
    UInt8 *p_temp = OAM_NULL;
    UInt8 temp3[SON_ENB_ID_OCTET_SIZE] = {OAM_ZERO};
    UInt8 temp_plmnid[OAM_SEVEN] = {0};

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.nbr_enb_list,"nbr_enb_list_size"));
    oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
        nbr_enb_list_size = lclTemp_value;

    for(enb_count= OAM_ZERO; enb_count < oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list_size; enb_count++)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.nbr_enb_info[enb_count],"enb_type"));

        /* coverity 35773 */
        oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
            nbr_enb_list[enb_count].enb_id.enb_type = (son_enb_type_et)lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.nbr_enb_info[enb_count],"enb_id"));
        /* X2HO Fix Start */
        /* SPR 12385 FIX START */
        if(SON_MACRO_ENB == oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[enb_count].enb_id.enb_type)
        {
            oam_conversion_from_macro_enb_to_byte_string(temp3,lclTemp_value, OAM_TWELVE);
            oam_memcpy(oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[enb_count].enb_id.enb_id,
                    temp3, SON_ENB_ID_OCTET_SIZE - OAM_ONE);
        }
        else if (SON_HOME_ENB == oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[enb_count].enb_id.enb_type)
        {
            oam_conversion_from_int_to_byte_string(temp3,lclTemp_value,OAM_HOME_ENB_ID_BITSTRING_SIZE);
            oam_memcpy(oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[enb_count].enb_id.enb_id,
                    temp3,SON_ENB_ID_OCTET_SIZE);
        }
        /* SPR 12385 FIX END */
        /* X2HO Fix End */

        temp = (char *)oam_xmlNodeGetContent(xml_struct_g.nbr_enb_info[enb_count],"PLMNID"); 

        /* Coverity FIX 33640 */
        oam_convert_plmnid((Char8 *)temp_plmnid,temp); 
        retVal=oam_populate_plmnid((Char8 *)temp_plmnid,
                &(oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[enb_count].enb_id.plmn_id));
        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING, "Population of PLMN-ID failed.");
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        temp =
            (Char8*)oam_xmlNodeGetContent(xml_struct_g.nbr_enb_info[enb_count], 
                    "TAC");
        if(temp == OAM_NULL)
        {
            return OAM_FAILURE;
        }

        if(oam_strcmp(temp, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi(temp);
            oam_conversion_bitstring_short_to_byte_string(oam_prov_req.oam_son_req.
                    oam_son_nr_enb_add_req.nbr_enb_list[enb_count].
                    tac_list[OAM_ZERO].tac, lclTemp_value);
            oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                nbr_enb_list[enb_count].bitmask |= SON_ANR_ENB_TAC_PRESENT;
            oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                nbr_enb_list[enb_count].tac_list_size = OAM_ONE;
        }

        /* At least Bit 1 or Bit2 should be set for nr_enb_add_req
           return failure when the bits are not set */
        if (!((oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                        nbr_enb_list[OAM_ZERO].bitmask & SON_ANR_ENB_TNL_ADD_LIST_PRESENT) ||
                    (oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                     nbr_enb_list[OAM_ZERO].bitmask & SON_ANR_ENB_TAC_PRESENT)))
        {
            /* either bit-1 or bit-2 should be set for this request */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }


        p_temp = oam_xmlNodeGetContent(xml_struct_g.nbr_enb_info[enb_count],"myAddr");
        OAM_NULL_CHECK(p_temp != OAM_NULL);
        if((oam_strcmp((const char *)p_temp,OAM_INVALID_STR))!= OAM_ZERO)
        {
            addr_count = OAM_ZERO;
            p_temp = (oam_xmlNodeGetContent(xml_struct_g.nbr_enb_info[enb_count],"myAddr"));
            char ip_add[OAM_THIRTY_TWO][OAM_THIRTY_NINE] = {{OAM_ZERO}};
            char * temp2 = OAM_NULL;
            temp2 = strtok((char *)p_temp,",");
            while (temp2 != OAM_NULL)
            {
                oam_strcpy(ip_add[addr_count],temp2);
                addr_count++ ;
                temp2 = strtok(OAM_NULL,",");
            }

            oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                nbr_enb_list[enb_count].bitmask |= SON_ANR_ENB_TNL_ADD_LIST_PRESENT;

            oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                nbr_enb_list[enb_count].enb_tnl_address_list_size = addr_count;


            for(addr_count= OAM_ZERO; addr_count < SON_MAX_NO_ENB_X2_TLAS ;addr_count++)
            {
                if(oam_isValidIp4((UInt8 *)ip_add[addr_count])==OAM_ONE)
                {
                    change_address_format(p_temp, oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                            nbr_enb_list[enb_count].enb_tnl_address_list[addr_count].ipv4_add);

                    oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                        nbr_enb_list[enb_count].enb_tnl_address_list[addr_count].bitmask |= IPV4_ADD_PRESENT;
                }
                else if (oam_isValidIp6((UInt8 *)ip_add[addr_count])==OAM_ONE)
                {
                    oam_inet_pton(AF_INET6,(char *)ip_add[addr_count],oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[enb_count].enb_tnl_address_list[addr_count].ipv6_add);

                    oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                        nbr_enb_list[enb_count].enb_tnl_address_list[addr_count].bitmask |= IPV6_ADD_PRESENT;
                }      
            }   
        }
        {

            /* SPR_11780_FIX Start */
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        xml_struct_g.nbr_enb_info[enb_count],"x2_ho_status"));
            /* SPR_11780_FIX End */
            /* coverity 35757 */
			oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                nbr_enb_list[enb_count].x2_status = (son_x2_status_et)lclTemp_value;
			oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                nbr_enb_list[enb_count].bitmask |= SON_ANR_ENB_X2_HO_STATUS_PRESENT;

        }
        /*coverity 41177 */
        p_temp = oam_xmlNodeGetContent(xml_struct_g.nbr_enb_info[enb_count],"x2_connection_status");
        OAM_NULL_CHECK(p_temp != OAM_NULL);
        if((oam_strcmp((const char *)p_temp,OAM_INVALID_STR))!= OAM_ZERO)
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        xml_struct_g.nbr_enb_info[enb_count],"x2_connection_status"));
            oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                nbr_enb_list[enb_count].x2_connection_status = (son_x2_connection_status_et)lclTemp_value;
            oam_prov_req.oam_son_req.oam_son_nr_enb_add_req.
                nbr_enb_list[enb_count].bitmask |= SON_ANR_ENB_CUR_X2_CONN_PRESENT;
        }
        /*SPR 20771 FIXED START*/
    }/* End of for loop for enb count */ 
    /*SPR 15799 START*/
    p_temp = oam_xmlNodeGetContent(xml_struct_g.SONParams,"TNLDiscoveryEnabled");
    if((oam_strcmp((const char *)p_temp,OAM_INVALID_STR))!= OAM_ZERO)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.SONParams,"TNLDiscoveryEnabled"));

        oam_prov_req.oam_son_req.tnl_discovery_enable_disable_flag = lclTemp_value;
    }
    /*SPR 15799 END*/
    /*SPR 20771 FIXED END*/


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;

}


/****************************************************************************
 *  FUNCTION NAME   : oam_populate_son_pci_selection_params
 *  DESCRIPTION     : This function is used to populate the son pci 
 *                    selection params
 *  PARAMETERS
 *      IN          : p_cell_spec_params: pointer to CellConfig xmlNode from
 *                    TR-196 data model xml file
 *                    p_pci_selection_req: pointer to pci_selection structure
 *                    to populate
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 ***************************************************************************/
oam_return_et 
oam_populate_son_pci_selection_params
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_son_pci_selection_req_t  *p_pci_selection_req,
 /* SPR 15267 START */
 oam_son_pci_reselection_req_t  *p_pci_reselection_req,

 /* Spr 17753 Changes Start */
  oam_cell_neighbourlist_info_t *p_nr_info,
 /* SPR 15267 START */
 son_cell_t *p_serving_cell
 /* Spr 17753 Changes End */

 )
{
    OAM_FUN_ENTRY_TRACE();
    /* CSR 58157 FIX START*/
    /* SPR 13060 FIX START */
    /* Code remode */
    /* SPR 13060 FIX END */
    UInt16 count = OAM_ZERO;
    /* CSR 58157 FIX END*/
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    xmlChar *tag_value = OAM_NULL;
    /* SPR 13060 FIX START */
    oam_error_code_et err = NO_ERROR;
    /* SPR 13060 FIX END */

    /* SPR 18568 FIX START */
    p_pci_selection_req->earfcn = oam_atoi((char *)oam_get_xml_text_node_content
            (p_cell_spec_params->RF_1,
             "EARFCNDL", buf,
             OAM_TAG_VALUE_STR_MAX_LEN));
    /* SPR 18568 FIX END */

    tag_value = oam_get_xml_text_node_content(p_cell_spec_params->RF_1,
            "PhyCellID", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);

    /* SPR 13060 FIX START */
    if(tag_value) {
        /* SPR 15267 START */
        p_pci_selection_req->pci_list_size =
            oam_tokenize_son_pci_list(buf, ",", "..",
                    p_pci_selection_req,
                    p_nr_info,
                    SON_MAX_PCI, &err);
        /* SPR 15267 END */
        for (count = OAM_ZERO;
                count < p_pci_selection_req->pci_list_size;
                ++count) {
            p_pci_reselection_req->pci_list[count] =
                p_pci_selection_req->pci_list[count];
        }

        p_pci_reselection_req->pci_list_size =
            p_pci_selection_req->pci_list_size;
        /* SPR 13060 FIX END */
        /* SPR 18569 FIX START */
        p_pci_selection_req->meas_bw_list[0] =
            /* spr_21013_fix_start */
            oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_MEAS_BANDWIDTH"));
        /* spr_21013_fix_end */

        ++p_pci_selection_req->meas_bw_list_size;
        /* SPR 18569 FIX END */
    }

 /* Spr 17753 Changes Start */
    if(oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.SONParams,"ConfilctWithSecondDegreeNBR"), OAM_INVALID_STR) != OAM_ZERO)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.SONParams,"ConfilctWithSecondDegreeNBR"));

        
          p_serving_cell->son_x2_second_degree_conflict_config.second_degree_conflict_enable = (son_bool_et)lclTemp_value ;    /* Coverity_Fix 52773 +- */

        p_serving_cell->bitmask |= SON_CELL_SECOND_DEGREE_CONFLICT_CONFIG_PRESENT;

        if(SON_TRUE == p_serving_cell->son_x2_second_degree_conflict_config.second_degree_conflict_enable)
        {
            p_pci_reselection_req->level = SON_LEVEL_2;
        }
        else
        {
            p_pci_reselection_req->level = SON_LEVEL_1;
        }
    }
    if(oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.SONParams,"NRAddWaitTimer"), OAM_INVALID_STR) != OAM_ZERO)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.SONParams,"NRAddWaitTimer"));

         p_serving_cell->son_x2_second_degree_conflict_config.nr_add_wait_timer = lclTemp_value ;

         p_serving_cell->bitmask |=
            SON_CELL_SECOND_DEGREE_CONFLICT_CONFIG_PRESENT;
    }
    if(oam_strcmp((const char *)oam_xmlNodeGetContent(xml_struct_g.SONParams,"ConflictDetectionBackoffTimer"), OAM_INVALID_STR) != OAM_ZERO)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.SONParams,"ConflictDetectionBackoffTimer"));

        p_serving_cell->son_x2_second_degree_conflict_config.conflict_detection_backoff_timer = lclTemp_value;
         p_serving_cell->bitmask |= SON_CELL_SECOND_DEGREE_CONFLICT_CONFIG_PRESENT;
    }
    /* Spr 17753 Changes End */ 

    OAM_FUN_ENTRY_TRACE();
    return OAM_SUCCESS;
}
#endif

/*SON Drop 3 Changes Ends*/

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_tr069_params
 *  DESCRIPTION      : This function is used to populate tr069 params
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          : OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 *******************************************************************************/

/* + SPR 17439 */
    oam_return_et
oam_populate_tr069_params(void)
{
    /* - SPR 17439 */

    OAM_FUN_ENTRY_TRACE();

    lclTemp_value = oam_atoi((Char8*)oam_xmlNodeGetContent(
                xml_struct_g.eNodeBParams,
                "tr069Mode"));
    oam_prov_req.oam_tr069_req.tr069_mode = lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_g.eNodeBParams,"ManagementMode"));

    oam_prov_req.oam_tr069_req.tr069_mode=lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.ManagementServer,"X_VENDOR_CONNECT_TO_IHEMS"));
    oam_prov_req.oam_tr069_req.connect_to_iHeMS=lclTemp_value;
    /* spr_21013_fix_start */
    /* check removed */
    /* spr_21013_fix_end */


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_tr069_tr196_params 
 *  DESCRIPTION      : This function is used to populate tr069 & tr196 params
 *  PARAMETERS
 *      IN           : Pointer of XML_struct_cell_config
 *
 *      OUT          : NONE
 *
 *  RETURNS          : OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 *******************************************************************************/
    oam_return_et
oam_populate_tr069_tr196_params(XML_struct_cell_config *p_cell_spec_params)
{
    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %p", p_cell_spec_params);
    oam_return_et ret_val = OAM_SUCCESS;

    /* spr_21013_fix_start */
    lclTemp_value=oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].Capabilities,"SupportedSystems"),SUPPORTED_SYS,SUPP_SYSTEM_COUNT);
    oam_prov_req.oam_tr069_req.tr069_init_params.supported_system=(supported_system_et)lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].Capabilities,"GPSEquipped"));
    oam_prov_req.oam_tr069_req.tr069_init_params.GPSEquipped = lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].Capabilities,"MaxTxPower"));
    oam_prov_req.oam_tr069_req.tr069_init_params.MaxTxPower = lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].Capabilities,"Beacon"));
    oam_prov_req.oam_tr069_req.tr069_init_params.Beacon=lclTemp_value;

    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"BandsSupported",oam_prov_req.oam_tr069_req.tr069_init_params.bands_supported,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.bands_supported));

    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"DuplexMode",oam_prov_req.oam_tr069_req.tr069_init_params.DuplexMode,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.DuplexMode));

    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1, "NNSFSupported");
    /* spr_21013_fix_end */
    if(!oam_strcmp((Char8*)p_temp, "1") ||
            !oam_strcasecmp((Char8*)p_temp, "true")) {
        oam_prov_req.oam_tr069_req.tr069_init_params.NNSFSupported = 1;
        /* SPR 12274 FIX START */
        nnsf_flag = OAM_TRUE;		
        /* SPR 12274 FIX END */
    }
    else {
        oam_prov_req.oam_tr069_req.tr069_init_params.NNSFSupported = 0;
        /* SPR 12274 FIX START */
        nnsf_flag = OAM_FALSE;		
        /* SPR 12274 FIX END */
    }


    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"UMTSRxSupported"));
    oam_prov_req.oam_tr069_req.tr069_init_params.UMTSRx_supported = lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"GSMRxSupported"));
    oam_prov_req.oam_tr069_req.tr069_init_params.GSMRx_supported = lclTemp_value;

    lclTemp_value = oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,"CDMA2000RxSupported"));
    oam_prov_req.oam_tr069_req.tr069_init_params.CDMA2000Rx_supported = lclTemp_value;

    /* Spr 15596 Fix Start */
    ret_val = oam_populate_string_param_with_validation(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,"SecGWServer1",
            oam_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server1,
            sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server1),oam_isValidIp4SecGWServer);

    if(ret_val == OAM_SUCCESS)
    {
        ret_val = oam_populate_string_param_with_validation(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,"SecGWServer2",
                oam_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server2,
                sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server2),oam_isValidIp4SecGWServer);

        if(ret_val == OAM_SUCCESS)
        {
            ret_val = oam_populate_string_param_with_validation(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,"SecGWServer3",
                    oam_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server3,
                    /* spr_21013_fix_end */
                    sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server3),oam_isValidIp4SecGWServer);
        }

    }
    else
    {
		OAM_LOG(OAM, OAM_WARNING,"Value of SecGWServer is incorrect");
    }    
    /* Spr 15596 Fix End */

    /* SPR 13024 FIX START */
    /* Code removed */
    /* SPR 13024 FIX END */


    /* spr_21013_fix_start */
    oam_populate_string_params (xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"REMPLMNList",oam_prov_req.oam_tr069_req.tr069_init_params.rem_plmn_list,sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.rem_plmn_list));

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_2,"AdminState"));
    /* coverity 41287 */
    oam_prov_req.system_status.admin_state= (oam_admin_state_et)lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_2,"OpState"));
    /* coverity 41289 */
    oam_prov_req.system_status.op_state = (oam_op_state_et)lclTemp_value;

    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_2,"RFTxStatus"));
    /* spr_21013_fix_end */
    if(OAM_ONE==lclTemp_value)
    {
        oam_prov_req.system_status.rftx_status = OAM_TRUE;
    }
    else
    {
        oam_prov_req.system_status.rftx_status = OAM_FALSE;
    } 
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_2,"X_VENDOR_AvailabilityState"));
    /* spr_21013_fix_end */
    /* coverity 41288 */
    oam_prov_req.system_status.availability_status = (oam_avail_state_et)lclTemp_value;

    OAM_FUN_EXIT_TRACE();
    return ret_val;

}
#ifdef OAM_SON_ENABLE
/* SPR 13065 CHANGE START */
/* SPR 13065 CHANGE END */
/****************************************************************************
 *  FUNCTION NAME   : oam_populate_son_career_freq_and_dl_tx_power_params 
 *  DESCRIPTION     : This function is used to populate SON Carrier Frequency 
 *                    and DL Tx power params
 *  PARAMETERS
 *      IN          : pointer to XML_struct_cell_config i.e. pointer to 
 *                    CellConfig xml node in the TR-196 xml data file
 *
 *      OUT         : NONE
 *
 *  RETURNS         : OAM_SUCCESS on Success
 *                    OAM_FAILURE on Failure
 ****************************************************************************/
oam_return_et
    oam_populate_son_career_freq_and_dl_tx_power_params
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_son_carrier_freq_and_dl_tx_power_req_t *p_earfcn_selection_req,
 oam_cell_carrier_params_t *p_cell_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();

    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    xmlChar *tag_value = OAM_NULL;
    UInt16 cnt = OAM_ZERO;
    Char8 *earfcn_str = OAM_NULL;


    tag_value = oam_get_xml_text_node_content(p_cell_spec_params->RF_1,
            "DLBandwidth", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);

    if(tag_value) {
        lclTemp_value = oam_xml_search_string_to_integer(buf,
                DLBandwidth_MAP,
                DL_BANDWIDTH_COUNT);

        p_earfcn_selection_req->meas_bandwidth = lclTemp_value;
    }

    tag_value = oam_get_xml_text_node_content(p_cell_spec_params->RF_1,
            "EARFCNDL", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);

    /* Coverity 99558 , 99560 FIX START */
    if(tag_value) {
        /* SPR-13074 Start */
        oam_strcpy((char *)p_cell_carr_params->earfcn_list, (const char *)tag_value);
        /* SPR-13074 End */
        /* Coverity 99558 , 99560 FIX END */
        earfcn_str = oam_strtok(buf, ",");

        while (earfcn_str) {
            p_cell_carr_params->earfcn_list_dl[cnt] = oam_atoi(earfcn_str);
            p_earfcn_selection_req->earfcn_list[cnt] = oam_atoi(earfcn_str);
            earfcn_str = oam_strtok(OAM_NULL, ",");
            ++cnt;
        }

        p_earfcn_selection_req->earfcn_list_size = cnt;

        p_cell_carr_params->earfcndl_list_size = cnt;
    }

    tag_value = oam_get_xml_text_node_content(p_cell_spec_params->RF_1,
            "EARFCNUL", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);
    cnt = OAM_ZERO;
    /* Coverity 99558 , 99560 FIX START */
    if(tag_value) {
        /* SPR-13074 Start */
        oam_strcpy((char *)p_cell_carr_params->earfcnul_list, (const char *)tag_value);
        /* SPR-13074 End */
        /* Coverity 99558 , 99560 FIX END */
        earfcn_str = oam_strtok(buf, ",");

        while (earfcn_str) {
            p_cell_carr_params->earfcn_list_ul[cnt] = oam_atoi(earfcn_str);
            earfcn_str = oam_strtok(OAM_NULL, ",");
            ++cnt;
        }

        p_cell_carr_params->earfcnul_list_size = cnt;
    }

    /* Start: CSR 00058940 */    
    tag_value = oam_get_xml_text_node_content(p_cell_spec_params->RF_1,
            "ReferenceSignalPower", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);
    if(tag_value) {
        lclTemp_value = oam_atoi(buf);

        p_earfcn_selection_req->p_tx_upp =
            lclTemp_value + OAM_REFERENCE_POWER_DIFF;
        p_earfcn_selection_req->p_tx_low =
            lclTemp_value - OAM_REFERENCE_POWER_DIFF;

        if (MIN_REFERENCESIGNALPOWER > p_earfcn_selection_req->p_tx_low) {
            p_earfcn_selection_req->p_tx_low = MIN_REFERENCESIGNALPOWER;
        }

        if (MAX_REFERENCESIGNALPOWER < p_earfcn_selection_req->p_tx_upp) {
            p_earfcn_selection_req->p_tx_upp = MAX_REFERENCESIGNALPOWER;
        }
    }
    /*SPR 14600 START*/
    else
    {
        OAM_LOG(OAM, OAM_INFO, "ReferenceSignalPower is not provided in eNodeB_Data_Model_TR_196_based.xml");
    }
    /*SPR 14600 END*/



    tag_value = oam_get_xml_text_node_content(p_cell_spec_params->IntraFreq,
            "PMax", buf,
            OAM_TAG_VALUE_STR_MAX_LEN);
    if(tag_value) {
        lclTemp_value = oam_atoi(buf);

        p_earfcn_selection_req->p_ue_max = lclTemp_value + OAM_P_MAX_DIFF;
        p_earfcn_selection_req->p_ue_min = lclTemp_value - OAM_P_MAX_DIFF;

        if (OAM_MIN_DL_TX_P_MAX > p_earfcn_selection_req->p_ue_min) {
            p_earfcn_selection_req->p_ue_min = OAM_MIN_DL_TX_P_MAX;
        }

        if (OAM_MAX_DL_TX_P_MAX < p_earfcn_selection_req->p_ue_max) {
            p_earfcn_selection_req->p_ue_max = OAM_MAX_DL_TX_P_MAX;
        }
    }

    /*End: CSR 00058940 */

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
#endif

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_s1ap_enb_cfg_update_params
 *  DESCRIPTION      : This function is used to populate the s1ap config
 *                   : update parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_s1ap_enb_cfg_update_params(void)
{
    /* - SPR 17439 */

    OAM_FUN_ENTRY_TRACE();
    /*LTE_OAM_BUG_13082_FIXED_START */
    UInt8 cnt = OAM_ZERO;
    UInt32 plmn_cnt      = OAM_ZERO;
    supp_ta_list_t *p_tai_list =
        &OAM_S1AP_INFO.s1_setup_req_parameters.supp_ta_list;

    /*LTE_OAM_BUG_13082_FIXED_END */

    /* Populating bitmask for s1ap config update */ 

    oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |= 
        S1AP_OAM_ENB_CONFIG_UPDATE_ENB_NAME_PRESENT |
        S1AP_OAM_ENB_CONFIG_UPDATE_MME_LIST_PRESENT |
        S1AP_OAM_ENB_CONFIG_UPDATE_TA_LIST_PRESENT | 
        S1AP_OAM_ENB_CONFIG_UPDATE_PAGING_DRX_PRESENT ;


    /* spr_21013_fix_start */
    p_temp = oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3,
            /* spr_21013_fix_end */
            "AccessMode");
    if(oam_strcasecmp((Char8*)p_temp, "openaccess")) {
        oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |=
            S1AP_OAM_ENB_CONFIG_UPDATE_CSG_ID_LIST_PRESENT;
    }

    /* Populating eNodeB name  for bitmak S1AP_OAM_ENB_CONFIG_UPDATE_ENB_NAME_PRESENT */

    oam_strcpy((char *)oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.enb_name ,
            (char *)oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
            s1_setup_req_parameters.enb_name);

    /* Populating mme list present  for bitmask S1AP_OAM_ENB_CONFIG_UPDATE_MME_LIST_PRESENT */

    oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.s1ap_oam_mme_id_list.num_mme_id = OAM_ONE;
    oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.s1ap_oam_mme_id_list.mme_id[OAM_ZERO] = OAM_ZERO;

    /* Populating supported TAI info for bitmask S1AP_OAM_ENB_CONFIG_UPDATE_TA_LIST_PRESENT */

    oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.num_supported_tais = oam_prov_req.
        oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1_setup_req_parameters.
        supp_ta_list.num_supported_tais; 
    /*LTE_OAM_BUG_13082_FIXED_START */

    for(cnt = 0; cnt < p_tai_list->num_supported_tais; ++cnt) {
        /* SPR 13542 REVIEW COMMENTS FIX START */
        /* SPR 13542 START */
        oam_memcpy(oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                supp_ta_list.supp_tais[cnt].tac,
                OAM_S1AP_INFO.s1_setup_req_parameters.supp_ta_list.
                supp_tais[cnt].tac,
                TAC_OCTET_SIZE);
        /* SPR 13542 END */

        oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
            supp_ta_list.supp_tais[cnt].bc_plmn_list.
            num_bplmn = OAM_S1AP_INFO.s1_setup_req_parameters.
            supp_ta_list.supp_tais[cnt].
            bc_plmn_list.num_bplmn;
        /* SPR 13542 REVIEW COMMENTS FIX END */

        for(plmn_cnt = 0;
                plmn_cnt < p_tai_list->supp_tais[cnt].bc_plmn_list.num_bplmn;
                ++plmn_cnt) {


            oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[cnt].
                bc_plmn_list.plmn_identity[plmn_cnt].plmn_id[OAM_ZERO] = 
                oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1_setup_req_parameters.
                supp_ta_list.supp_tais[cnt].bc_plmn_list.plmn_identity[plmn_cnt].plmn_id[OAM_ZERO];

            oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[cnt].
                bc_plmn_list.plmn_identity[plmn_cnt].plmn_id[OAM_ONE] = oam_prov_req.oam_l3_req.oam_s1ap_req.
                s1ap_oam_prov.s1apInfo.s1_setup_req_parameters.supp_ta_list.supp_tais[cnt].
                bc_plmn_list.plmn_identity[plmn_cnt].plmn_id[OAM_ONE];

            oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[cnt].
                bc_plmn_list.plmn_identity[plmn_cnt].plmn_id[OAM_TWO] = oam_prov_req.oam_l3_req.oam_s1ap_req.
                s1ap_oam_prov.s1apInfo.s1_setup_req_parameters.supp_ta_list.supp_tais[cnt].
                bc_plmn_list.plmn_identity[plmn_cnt].plmn_id[OAM_TWO];

        }

        /* Populating info for bitmask S1AP_OAM_ENB_CONFIG_UPDATE_PAGING_DRX_PRESENT */
    }
    /*LTE_OAM_BUG_13082_FIXED_END */

    oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.default_paging_drx = oam_prov_req.
        oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1_setup_req_parameters.default_paging_drx;


    /* Populating info for bitmask S1AP_OAM_ENB_CONFIG_UPDATE_CSG_ID_LIST_PRESENT */

    if(oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask &
            S1AP_OAM_ENB_CONFIG_UPDATE_CSG_ID_LIST_PRESENT){
        oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.num_csg_ids = OAM_ONE;

        /* SPR 13542 START */
        oam_memcpy((char *)oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.csg_ids[OAM_ZERO].csg_id,
                (char *)oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1_setup_req_parameters.csg_id_list.csg_ids[OAM_ZERO].csg_id,
                sizeof(oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.csg_ids[OAM_ZERO].csg_id));
        /* SPR 13542 END */

    }


    OAM_FUN_ENTRY_TRACE();
    return OAM_SUCCESS;
}

#ifdef OAM_SON_ENABLE
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_nw_scan_params
 *  DESCRIPTION      : Populates the parameters for SON_NW_SCAN_REQ
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_son_nw_scan_params(void)
{
    /* - SPR 17439 */
    /*SPR 12001 FIX START*/
    UInt8 earfcn_index = OAM_ZERO;
    Char8  *csv_list_1;
    /*SPR 12001 FIX END*/
    UInt16 earfcn_count   = OAM_ZERO;
    Char8  csv_list[300] = "";
    UInt16 earfcn_list[SON_MAX_NO_EARFCN] = {0};

    /*SPR 17740 +-*/
    OAM_FUN_ENTRY_TRACE();

    oam_prov_req.oam_son_req.nw_scan.bitmask |=
        SON_INTRA_RAT_NW_SCAN_REQ_PRESENT;
    /* spr_21013_fix_start */
    oam_strncpy((Char8*)csv_list,  (Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "EUTRACarrierARFCNDLList"), 
            /* spr_21013_fix_end */
            sizeof(csv_list)-1);

    /* Populate in local structure to support gpv/spv */
    oam_memcpy(oam_prov_req.oam_son_req.temp_values.nw_scan_earfcn_list,csv_list,oam_strlen((char*)csv_list));
    /* SPR 15238 START */
    /*SPR 17740 +-*/
    if (0 != oam_strncmp(OAM_INVALID_STR, csv_list, oam_strlen(OAM_INVALID_STR)))
    {
		OAM_LOG(OAM, OAM_INFO, "EUTRACarrierARFCNDLList Tag present");
        oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.bitmask |=
            /*SPR 12001 FIX START*/
            SON_MEAS_BANDWINDTH_PER_EARFCN_PRESENT;
        /*SPR 12001 FIX END*/
        oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.meas_bandwidth_per_earfcn.num_earfcn = 
            oam_tokenize_string_to_u16(csv_list, ",", SON_MAX_NO_EARFCN, earfcn_list);

        /*SPR_15770 Fix start*/
        /*if num_earfcn is zero use known earfcn list*/
        if (OAM_ZERO ==  oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.meas_bandwidth_per_earfcn.num_earfcn)
        {
            oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.
                meas_bandwidth_per_earfcn.num_earfcn = oam_fill_known_earfcn(earfcn_list);

        }
        /*SPR_15770 Fix end*/

        for(earfcn_count = OAM_ZERO;earfcn_count < oam_prov_req.oam_son_req.nw_scan.
                start_intra_rat_scan_req.meas_bandwidth_per_earfcn.num_earfcn;earfcn_count++)
        {
            oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.
                meas_bandwidth_per_earfcn.meas_bandwidth_per_earfcn[earfcn_count].earfcn = 
                earfcn_list[earfcn_count];
            /* SPR 19828 Fix Start */
            oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.
                meas_bandwidth_per_earfcn.meas_bandwidth_per_earfcn[earfcn_count].
                meas_bandwidth_for_earfcn = 
                oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_MEAS_BANDWIDTH"));
            /* SPR 19828 Fix End */
        }
    }
    else
    {
		OAM_LOG(OAM, OAM_INFO, "X_VENDOR_MEAS_BANDWIDTH Tag present");
        oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.bitmask |=
            /*SPR 12001 FIX START*/
            SON_MEAS_BANDWINDTH_PRESENT;
        /*SPR 12001 FIX END*/
        oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.meas_bandwidth =
            /* spr_21013_fix_start */
            oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_MEAS_BANDWIDTH"));
        /* spr_21013_fix_end */
        if ((6 > oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.meas_bandwidth) ||
                (100 < oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.meas_bandwidth))
        {
			OAM_LOG(OAM, OAM_WARNING, "Value of X_VENDOR_MEAS_BANDWIDTH[%d] is out of range (6:100)",
                    oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.meas_bandwidth);
            return OAM_FAILURE;
        }

    }
    lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"ScanOnBoot"));
    oam_prov_req.oam_son_req.temp_values.scan_on_boot=lclTemp_value;

    oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.measurement_period =
        oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_MEASUREMENT_PERIOD"));
    oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.retry_count = 
        oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_RETRY_COUNT"));
    /* coverity 41179 */
    oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.freq_band_id = 
        oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "REMBandList"));
    /* spr_21013_fix_end */
    if (64 < oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.freq_band_id)
    {
		OAM_LOG(OAM, OAM_WARNING, "Value of REMBandList[%u] is out of range (0:64)",
                oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.freq_band_id);
        return OAM_FAILURE;
    }

    /*SPR 12001 FIX START*/
    if (oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.bitmask &
            SON_MEAS_BANDWINDTH_PER_EARFCN_PRESENT)
    {
        oam_prov_req.oam_son_req.temp_values.temp_bitmask |= OAM_TEMP_PCI_LIST_PRESENT;
        oam_memset(csv_list, 0, sizeof(csv_list));
        oam_strncpy((char*)csv_list,
                /* spr_21013_fix_start */
                (const char*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_PCI_LIST"),
                /* spr_21013_fix_end */
                sizeof(csv_list)-1);
        if (0 == oam_strncmp(OAM_INVALID_STR, csv_list, oam_strlen(OAM_INVALID_STR)))
        {
			OAM_LOG(OAM, OAM_WARNING, "X_VENDOR_PCI_LIST Tag not found in xml file");
            return OAM_FAILURE;
        }

        char *saveptr1, *str1;


        for (earfcn_index = 0, str1 = csv_list; ; earfcn_index++, str1 = NULL) {
            csv_list_1 = strtok_r(str1, ":", &saveptr1);
            if (csv_list_1 == NULL)
                break;

            oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.meas_bandwidth_per_earfcn.
                meas_bandwidth_per_earfcn[earfcn_index].num_pci =
                oam_tokenize_string_to_u16(csv_list_1, ",", SON_MAX_NO_CELLS_PER_EARFCN,
                        oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.
                        meas_bandwidth_per_earfcn.meas_bandwidth_per_earfcn[earfcn_index].pci);
        }
    }
    /*SPR 12001 FIX END*/
    OAM_FUN_ENTRY_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_nw_scan_cfg
 *  DESCRIPTION      : Populate the parameters for SON_NW_SCAN_CONFIG_REQ
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_son_nw_scan_cfg(void)
{
    /* - SPR 17439 */
    UInt8 temp_byte = OAM_ZERO;
    UInt32 temp_int = OAM_ZERO;

    OAM_FUN_ENTRY_TRACE();
    /* coverity 41178 */ 
    temp_byte = 
        /* spr_21013_fix_start */
        oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_FORCE_SCAN_ON_OFF"));
    /* spr_21013_fix_end */
    if ((0 != temp_byte) && (1 != temp_byte))          /*COVERITY FIX 25may*/
    {
		OAM_LOG(OAM, OAM_WARNING, "Value of X_VENDOR_FORCE_SCAN_ON_OFF:%d is invalid,"
                " valid values(0/1)", temp_byte);
        return OAM_FAILURE;
    }
    /* coverity 41178 */
    temp_int = 
        /* spr_21013_fix_start */
        oam_atoi((const char *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_SCAN_TIME_INTERVAL"));
    /* spr_21013_fix_end */

    oam_prov_req.oam_son_req.nw_scan_config.force_scan_on_off  = temp_byte; 
    oam_prov_req.oam_son_req.nw_scan_config.scan_time_interval = temp_int;

    OAM_FUN_ENTRY_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_periodic_nw_scan_req
 *  DESCRIPTION      : Populate the parameters for SON_PERIODIC_NW_SCAN_REQ
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_son_periodic_nw_scan_req(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    oam_prov_req.oam_son_req.periodic_nw_scan.bitmask |=
        SON_INTRA_RAT_NW_SCAN_REQ_PRESENT;
    oam_prov_req.oam_son_req.periodic_nw_scan.scan_on_off =
        /* spr_21013_fix_start */
        oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "ScanPeriodically"));
    /* spr_21013_fix_end */
    if (1 < oam_prov_req.oam_son_req.periodic_nw_scan.scan_on_off)
    {
		OAM_LOG(OAM, OAM_WARNING, "Value of ScanPeriodically[%u] is out of range (0:1)",
                oam_prov_req.oam_son_req.periodic_nw_scan.scan_on_off);
        return OAM_FAILURE;
    }    
    /* coverity 41181 */ 
    oam_prov_req.oam_son_req.periodic_nw_scan.scan_time_interval =
        /* spr_21013_fix_start */
        oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "PeriodicInterval"));
    /* spr_21013_fix_end */
    oam_memcpy(&oam_prov_req.oam_son_req.periodic_nw_scan.start_intra_rat_periodic_scan_req,
            &oam_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req,
            sizeof(son_start_intra_rat_scan_req_t));

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
#endif

/* FLAG_CHANGES - Removed Code Here */

#ifdef OAM_SON_ENABLE

/*******************************************************************************
 *  FUNCTION NAME    : oam_read_int_from_xml
 *  DESCRIPTION      : This Function is used to read int data from XML file
 *  PARAMETERS
 *      IN           : type: UInt8 parameter
 *                     p_node: Pointer of xmlNode
 *                     p_tag_name: Pointer of Char8 type 
 *		       
 *      OUT          : Int value read in p_value
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et oam_read_int_from_xml(void* p_value, UInt8 type, xmlNode* p_node, Char8* p_tag_name)
{
    oam_return_et ret_val = OAM_FAILURE;
    Char8 *p_temp_str = "";

    OAM_FUN_ENTRY_TRACE();    

    p_temp_str = (Char8 *)oam_xmlNodeGetContent(p_node, p_tag_name);
    /* coverity 41188 */ 
    OAM_NULL_CHECK(p_temp_str != OAM_NULL);
    if (oam_strcmp(OAM_INVALID_STR, p_temp_str) != OAM_ZERO)
    {
        switch(type)
        {
            case 1:
            *(UInt8 *)p_value = oam_atoi(p_temp_str);
            break;
            case 3:
            *(UInt32 *)p_value = oam_atol(p_temp_str);
            break;
            case 4:
            *(SInt8 *)p_value = oam_atoi(p_temp_str);
            break;
            case 5:
            *(SInt16 *)p_value = oam_atoi(p_temp_str);
            break;
            case 2:
            *(UInt16 *)p_value = oam_atoi(p_temp_str);
            break;
            default:
            *(UInt32 *)p_value = oam_atol(p_temp_str);
        }
        ret_val = OAM_SUCCESS;
    }

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_read_str_from_xml
 *  DESCRIPTION      : This Function is used to read string value from XML file
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          : OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et oam_read_str_from_xml(Char8* p_final_str, UInt32 size, xmlNode* p_node, Char8* p_tag_name)
{
    oam_return_et ret_val = OAM_FAILURE;
    Char8* p_temp_str = OAM_NULL;

    OAM_FUN_ENTRY_TRACE();    

    p_temp_str = (Char8 *)oam_xmlNodeGetContent(p_node, p_tag_name);
    /* coverity 41189 */
    OAM_NULL_CHECK(p_temp_str != OAM_NULL);
    if (oam_strcmp(OAM_INVALID_STR, p_temp_str) != OAM_ZERO)
    {
        ret_val = OAM_SUCCESS;
    }
    oam_strncpy(p_final_str, p_temp_str, size);

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}


#ifdef OAM_SON_ENABLE
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_nw_scan_results
 *  DESCRIPTION      : Populate the parameters for oam_populate_nw_scan_results
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 ******************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_nw_scan_results(void)
{
    /* - SPR 17439 */
    UInt32 plmnid_counter = OAM_ZERO;
    UInt8 cell_counter= OAM_ZERO;
    xmlNode* p_cell_node = OAM_NULL;
    xmlNode* p_rf_node = OAM_NULL;
    xmlNode* p_bcch_node = OAM_NULL;
    xmlNode* p_plmn_list_node = OAM_NULL;
    OAM_FUN_ENTRY_TRACE();    

    /*SPR_16048 Fix Start*/
    if (OAM_SUCCESS != oam_read_str_from_xml((Char8*)oam_prov_req.oam_igd_params.nw_scan_status.scan_status,
                sizeof(oam_prov_req.oam_igd_params.nw_scan_status.scan_status), 
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, (Char8*)"ScanStatus"))
        /* spr_21013_fix_end */
    {
        return OAM_FAILURE;
    }
    if (OAM_SUCCESS != oam_read_str_from_xml((Char8*)oam_prov_req.oam_igd_params.nw_scan_status.error_details
                ,sizeof(oam_prov_req.oam_igd_params.nw_scan_status.error_details),
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, (Char8*)"ErrorDetails"))
        /* spr_21013_fix_end */
    {
        return OAM_FAILURE;
    }
    if (OAM_SUCCESS != oam_read_str_from_xml((Char8*)oam_prov_req.oam_igd_params.nw_scan_status.last_scan_time,
                sizeof(oam_prov_req.oam_igd_params.nw_scan_status.last_scan_time),
                /* spr_21013_fix_start */
                xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, (Char8*)"LastScanTime"))
        /* spr_21013_fix_end */
    {
        return OAM_FAILURE;
    }
    if (OAM_SUCCESS != oam_read_int_from_xml((void*)&oam_prov_req.oam_igd_params.nw_scan_status.max_cell_entry
                /* spr_21013_fix_start */
                ,1, xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, (Char8*)"MaxCellEntries"))
        /* spr_21013_fix_end */
    {
        return OAM_FAILURE;
    }
    if (OAM_SUCCESS != oam_read_int_from_xml((void*)&oam_prov_req.oam_igd_params.nw_scan_status.num_cell_entry
                /* spr_21013_fix_start */
                ,1,xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, (Char8*)"CellNumberOfEntries"))
        /* spr_21013_fix_end */
    {
        return OAM_FAILURE;
    }
    /* spr_21013_fix_start */
    p_cell_node = oam_xml_find_tag(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5->children, (UInt8*)"Cell");
    /* spr_21013_fix_end */
    /*SPR_16048 Fix End*/
    for (cell_counter = 0; cell_counter < 
            oam_prov_req.oam_igd_params.nw_scan_status.num_cell_entry &&
            (OAM_NULL != p_cell_node); cell_counter++)

    {
        p_rf_node = oam_xml_find_tag(p_cell_node->children, (UInt8*)"RF");
        if (OAM_NULL == p_rf_node)
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag RF not found in Cell");
            return OAM_FAILURE;
        }
        p_bcch_node = oam_xml_find_tag(p_cell_node->children, (UInt8*)"BCCH");
        if (OAM_NULL == p_rf_node)
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag BCCH not found in Cell");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].carrier_earfcn, 
                    2, p_rf_node, "EUTRACarrierARFCN"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.RF");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].rssi, 
                    5,p_rf_node, "RSSI"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.RSSI");
            return OAM_FAILURE;
        }       
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].phy_cell_id,           
                    2,p_rf_node, "PhyCellID"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.PhyCellID");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].rsrp,               
                    5,p_rf_node, "RSRP"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.RSRP");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].rsrq,               
                    5,p_rf_node, "RSRQ"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.RSRQ");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.dl_bandwidth,               
                    2,p_bcch_node, "DLBandwidth"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.DLBandwidth");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.ul_bandwidth,               
                    2,p_bcch_node, "ULBandwidth"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.ULBandwidth");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.rx_tx_power,               
                    4,p_bcch_node, "RSTxPower"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.RSTxPower");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.tac,               
                    2,
                    /* coverity 35822 */p_bcch_node, "TAC"))
            /* coverity 35888 */
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.TAC");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.cell_identity,               
                    3,p_bcch_node, "CellID"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.CellID");
            return OAM_FAILURE;
        }

        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.cell_barred,               
                    1,p_bcch_node, "CellBarred"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.CellBarred");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.csg_indication,               
                    1,p_bcch_node, "CSGIndication"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.CSGIndication");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.csg_identity,               
                    3,p_bcch_node, "CSGIdentity"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.CSGIdentity");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.max_plmn_entry,               
                    1,p_bcch_node, "MaxPLMNListEntries"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.MaxPLMNListEntries");
            return OAM_FAILURE;
        }
        if (OAM_SUCCESS != oam_read_int_from_xml((void*)
                    &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.num_plm_entry,
                    1,p_bcch_node, "PLMNListNumberOfEntries"))
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN not found in Cell.PLMNListNumberOfEntries");
            return OAM_FAILURE;
        }
        p_plmn_list_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"PLMNList"); 
        while((p_plmn_list_node != OAM_NULL) &&( plmnid_counter < oam_prov_req.oam_son_req.
                    oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.num_plm_entry))
        {
            if(OAM_SUCCESS != oam_read_str_from_xml((Char8*)(oam_prov_req.oam_son_req.
                            oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.
                            oam_plmn_list[plmnid_counter].plmnid),
                        sizeof(oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].
                            oam_bcch_data.oam_plmn_list[plmnid_counter].plmnid), p_plmn_list_node, (Char8*)"PLMNID"))
            {
				OAM_LOG(OAM, OAM_WARNING, "Tag  not found in PLMNList");
            }
            /*SPR_16048 Fix Start*/
            if(OAM_SUCCESS != oam_read_str_from_xml((void*)
                        &oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].oam_bcch_data.
                        oam_plmn_list[plmnid_counter].cell_reserver_for_operator_use,
                        sizeof(oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[cell_counter].
                            oam_bcch_data.oam_plmn_list[plmnid_counter].cell_reserver_for_operator_use), p_plmn_list_node, "CellReservedForOperatorUse"))
            {
		    OAM_LOG(OAM, OAM_WARNING, "Tag not found in PLMNList");
            }
            /*SPR_16048 Fix End*/

            p_plmn_list_node = p_plmn_list_node->next;
            plmnid_counter++;
        }
        p_cell_node = p_cell_node->next;
    }

    OAM_FUN_EXIT_TRACE();

    return OAM_SUCCESS;
}
#endif
#endif
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_string_params 
 *  DESCRIPTION      : This function is used to populate string parameters without validation
 *  PARAMETERS
 *      IN           : parent_tag, tag_name, dest 
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
void  oam_populate_string_params(xmlNode *parent_tag, Char8 *tag_name, UInt8 *dest, UInt32 dest_size)
{
    xmlChar * p_temp=OAM_NULL;

    if ( (OAM_NULL == parent_tag) || (OAM_NULL == tag_name) )
    {
		OAM_LOG(OAM, OAM_WARNING, "Tag %s cannot be read, either parent_tag or the tag name is NULL", tag_name);
    }
    else
    {
        p_temp = xmlNodeGetContent(oam_xml_find_tag((xmlNode *)(parent_tag->children),(xmlChar *)tag_name));
        if(p_temp == OAM_NULL)
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag %s not found", tag_name);
        }
        oam_strncpy((char *)dest,(const char *) p_temp, dest_size);
        xmlFree(p_temp);
    }
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_string_param_with_validation
 *  DESCRIPTION      : This function is used to populate string parameters with validation
 *  PARAMETERS
 *      IN           : parent_tag, tag_name, dest , validateFunc
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et oam_populate_string_param_with_validation(xmlNode *parent_tag, Char8 *tag_name, UInt8 *dest,UInt32 dest_size, p_validateFunc validateFunc) 
{ 
    xmlChar * p_temp=OAM_NULL;
    oam_return_et retVal = OAM_SUCCESS;

    if ( (OAM_NULL == parent_tag) || (OAM_NULL == tag_name) )
    {
		OAM_LOG(OAM, OAM_WARNING, "Tag %s cannot be read, either parent_tag or the tag name is NULL", tag_name);
        retVal = OAM_FAILURE;
    }
    else
    {
        p_temp = xmlNodeGetContent(oam_xml_find_tag((xmlNode *)(parent_tag->children),(xmlChar *)tag_name));
        if(p_temp == OAM_NULL)
        {
			OAM_LOG(OAM, OAM_WARNING, "Tag %s not found", tag_name);
            retVal = OAM_FAILURE;
        }
        else {
            if(OAM_NULL == validateFunc ||
                    validateFunc(p_temp) == OAM_SUCCESS) {
                oam_strncpy((Char8*)dest, (Char8*)p_temp, dest_size);
            }
            else {
				OAM_LOG(OAM, OAM_WARNING,
                        "Wrong value %s received of %s Parameter ",
                        p_temp, tag_name);
                retVal = OAM_FAILURE; 
            }
        }
        xmlFree(p_temp);
    }
    return retVal;
}

/****************************************************************************
 *  FUNCTION NAME    : oam_populate_device_specific_rrc_params
 *  DESCRIPTION      : This function is used to populate the eNB specific RRC
 *                     parameters.
 *  PARAMETERS       :
 *      IN           : NONE
 *                   :
 *      OUT          : NONE
 *                   :
 *                   :
 *  RETURNS          :  OAM_SUCCESS on Success
 *                       OAM_FAILURE on Failure
 ****************************************************************************/
/* SPR 11952 FIX START */
    oam_return_et
oam_populate_device_specific_rrc_params(XML_struct_cell_config *p_cell_spec_params)
    /* SPR 11952 FIX END */
{
    OAM_FUN_ENTRY_TRACE();
    Char8 *tag_value = OAM_NULL;
    UInt32 cnt = 0;
    char *p_temp_token = OAM_NULL; /* SPR 10745 */
    U8    counter = OAM_ZERO; /* SPR 10745 */
    /* SPR 19703 changes start */
    U8 rrc_log_level = 0;
    /* SPR 19703 changes end */

    OAM_LOG(OAM, OAM_INFO, "Populating eNB specific RRC params from xml...");

    RRC_PROV_REQ.bitmask = OAM_ZERO;
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.RRCparams,
            "logLevel");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        /* SPR 19703 changes start */
        rrc_log_level = oam_atoi(tag_value);

        /* SPR 20007 : CID 110654 fix start */
        if(rrc_log_level <= MAX_RRC_LOGLEVEL) {
            /* SPR 20007 : CID 110654 fix end */
            RRC_PROV_REQ.log_level = rrc_log_level;

            OAM_LOG(OAM, OAM_INFO,"Populated value of RRC logLevel: %d, tag_value %d",
                    rrc_log_level,oam_atoi(tag_value));
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Value of logLevel is %d and range "
					"is from %d to %d", rrc_log_level,
                    /* SPR 19703 changes end */
                    MIN_RRC_LOGLEVEL,
                    MAX_RRC_LOGLEVEL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag logLevel not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.RRCparams,
            "phySyncMode");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        RRC_PROV_REQ.phy_sync_mode = lclTemp_value;

        OAM_LOG(OAM, OAM_INFO, "Populated value of phy_sync_mode: %d",
                lclTemp_value);
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag phySyncMode not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    /**************** TimerInfo Changes ****************/
    /* currently Supported 14 LLIM Timers */
    RRC_PROV_REQ.llim_timer_info.num_of_timers = MAX_LLIM_TIMER_INFO;

    /* currently Supported 7 CSC Timers */
    RRC_PROV_REQ.csc_timer_info.num_of_timers = MAX_CSC_TIMER_INFO;

    /* currently Supported 21 UECC Timers */
    RRC_PROV_REQ.uecc_timer_info.num_of_timers = MAX_UECC_TIMER_INFO;

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CELL_SETUP_TIMER_TIMERID_1_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO1_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO1_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;  
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_CELL_SETUP_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CELL_SETUP_TIMER_TIMERID_1_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO1_TIMERVAL, 
                    MAX_TIMERINFO1_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag LLIM_CELL_SETUP_TIMER_TIMERID_1_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CREATE_UE_ENTITY_TIMER_TIMERID_3_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO3_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO3_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;  
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_CREATE_UE_ENTITY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CREATE_UE_ENTITY_TIMER_TIMERID_3_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO3_TIMERVAL, 
                    MAX_TIMERINFO3_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_CREATE_UE_ENTITY_TIMER_TIMERID_3_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_RECONFIG_UE_ENTITY_TIMER_TIMERID_5_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO5_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO5_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_RECONFIG_UE_ENTITY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_RECONFIG_UE_ENTITY_TIMER_TIMERID_5_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO5_TIMERVAL, 
                    MAX_TIMERINFO5_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_RECONFIG_UE_ENTITY_TIMER_TIMERID_5_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_DELETE_UE_ENTITY_TIMER_TIMERID_7_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO7_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO7_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_DELETE_UE_ENTITY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_DELETE_UE_ENTITY_TIMER_TIMERID_7_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO7_TIMERVAL, 
                    MAX_TIMERINFO7_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_DELETE_UE_ENTITY_TIMER_TIMERID_7_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CONFIG_UE_SECURITY_TIMER_TIMERID_8_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO8_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO8_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_CONFIG_UE_SECURITY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CONFIG_UE_SECURITY_TIMER_TIMERID_8_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO8_TIMERVAL, 
                    MAX_TIMERINFO8_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_CONFIG_UE_SECURITY_TIMER_TIMERID_8_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CELL_RECONFIG_TIMER_TIMERID_12_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO12_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO12_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_CELL_RECONFIG_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CELL_RECONFIG_TIMER_TIMERID_12_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO12_TIMERVAL,
                    MAX_TIMERINFO12_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_CELL_RECONFIG_TIMER_TIMERID_12_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CELL_SUSPEND_UE_ENTITY_TIMER_TIMERID_27_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO27_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO27_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_SUSPEND_UE_ENTITY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CELL_SUSPEND_UE_ENTITY_TIMER_TIMERID_27_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO27_TIMERVAL,
                    MAX_TIMERINFO27_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_CELL_SUSPEND_UE_ENTITY_TIMER_TIMERID_27_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_REESTABLISH_UE_ENTITY_TIMER_TIMERID_28_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO28_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO28_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_REESTABLISH_UE_ENTITY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_REESTABLISH_UE_ENTITY_TIMER_TIMERID_28_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO28_TIMERVAL,
                    MAX_TIMERINFO28_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_REESTABLISH_UE_ENTITY_TIMER_TIMERID_28_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_RECONFIG_SECURITY_UE_ENTITY_TIMER_TIMERID_29_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO29_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO29_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_RECONFIG_SECURITY_UE_ENTITY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_RECONFIG_SECURITY_UE_ENTITY_TIMER_TIMERID_29_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO29_TIMERVAL,
                    MAX_TIMERINFO29_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_RECONFIG_SECURITY_UE_ENTITY_TIMER_TIMERID_29_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_RESUME_UE_ENTITY_TIMER_TIMERID_30_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO30_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO30_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_RESUME_UE_ENTITY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_RESUME_UE_ENTITY_TIMER_TIMERID_30_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO30_TIMERVAL,
                    MAX_TIMERINFO30_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_RESUME_UE_ENTITY_TIMER_TIMERID_30_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CHANGE_CRNTI_TIMER_TIMERID_32_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO32_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO32_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_CHANGE_CRNTI_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CHANGE_CRNTI_TIMER_TIMERID_32_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO32_TIMERVAL,
                    MAX_TIMERINFO32_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_CHANGE_CRNTI_TIMER_TIMERID_32_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CELL_START_TIMER_TIMERID_36_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO36_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO36_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_CELL_START_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CELL_START_TIMER_TIMERID_36_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO36_TIMERVAL,
                    MAX_TIMERINFO36_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_CELL_START_TIMER_TIMERID_36_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CELL_STOP_TIMER_TIMERID_38_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO38_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO38_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_CELL_STOP_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CELL_STOP_TIMER_TIMERID_38_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO38_TIMERVAL,
                    MAX_TIMERINFO38_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_CELL_STOP_TIMER_TIMERID_38_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "LLIM_CELL_DELETE_TIMER_TIMERID_39_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO39_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO39_TIMERVAL) {
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.llim_timer_info.timer_info[cnt++].
                timer_id = LLIM_CELL_DELETE_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "LLIM_CELL_DELETE_TIMER_TIMERID_39_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO39_TIMERVAL,
                    MAX_TIMERINFO39_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "LLIM_CELL_DELETE_TIMER_TIMERID_39_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    cnt = 0;
    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "CSC_CELL_SETUP_TIMER_TIMERID_0_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO0_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO0_TIMERVAL) {
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt++].
                timer_id = CSC_CELL_SETUP_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "CSC_CELL_SETUP_TIMER_TIMERID_0_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO0_TIMERVAL,
                    MAX_TIMERINFO0_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "CSC_CELL_SETUP_TIMER_TIMERID_0_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "CSC_CELL_RECONFIG_TIMER_TIMERID_11_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO11_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO11_TIMERVAL) {
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt++].
                timer_id = CSC_CELL_RECONFIG_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "CSC_CELL_RECONFIG_TIMER_TIMERID_11_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO11_TIMERVAL,
                    MAX_TIMERINFO11_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "CSC_CELL_RECONFIG_TIMER_TIMERID_11_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "CSC_CELL_DELETE_TIMER_TIMERID_13_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO13_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO13_TIMERVAL) {
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt++].
                timer_id = CSC_CELL_DELETE_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "CSC_CELL_DELETE_TIMER_TIMERID_13_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO13_TIMERVAL,
                    MAX_TIMERINFO13_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "CSC_CELL_DELETE_TIMER_TIMERID_13_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "CSC_PWS_TIMER_TIMERID_33_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO33_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO33_TIMERVAL) {
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt++].
                timer_id = CSC_PWS_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "CSC_PWS_TIMER_TIMERID_33_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO33_TIMERVAL,
                    MAX_TIMERINFO33_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "CSC_PWS_TIMER_TIMERID_33_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "CSC_KILL_TIMER_TIMERID_34_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO34_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO34_TIMERVAL) {
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt++].
                timer_id = CSC_KILL_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "CSC_KILL_TIMER_TIMERID_34_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO34_TIMERVAL,
                    MAX_TIMERINFO34_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "CSC_KILL_TIMER_TIMERID_34_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "CSC_CELL_START_TIMER_TIMERID_35_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO35_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO35_TIMERVAL) {
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt++].
                timer_id = CSC_CELL_START_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "CSC_CELL_START_TIMER_TIMERID_35_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO35_TIMERVAL,
                    MAX_TIMERINFO35_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "CSC_CELL_START_TIMER_TIMERID_35_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "CSC_CELL_STOP_TIMER_TIMERID_37_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO37_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO37_TIMERVAL) {
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.csc_timer_info.timer_info[cnt++].
                timer_id = CSC_CELL_STOP_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "CSC_CELL_STOP_TIMER_TIMERID_37_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO37_TIMERVAL,
                    MAX_TIMERINFO37_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "CSC_CELL_STOP_TIMER_TIMERID_37_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    cnt = 0;
    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RRC_CONN_SETUP_TIMER_TIMERID_2_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO2_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO2_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_CONN_SETUP_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_CONN_SETUP_TIMER_TIMERID_2_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO2_TIMERVAL,
                    MAX_TIMERINFO2_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRC_CONN_SETUP_TIMER_TIMERID_2_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RRC_CONN_RECONFIG_TIMER_TIMERID_4_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO4_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO4_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_CONN_RECONFIG_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_CONN_RECONFIG_TIMER_TIMERID_4_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO4_TIMERVAL,
                    MAX_TIMERINFO4_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRC_CONN_RECONFIG_TIMER_TIMERID_4_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RRC_CONN_RELEASE_TIMER_TIMERID_6_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO6_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO6_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_CONN_RELEASE_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_CONN_RELEASE_TIMER_TIMERID_6_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO6_TIMERVAL,
                    MAX_TIMERINFO6_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRC_CONN_RELEASE_TIMER_TIMERID_6_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_guard_timers,
            "UECC_RRC_MME_GUARD_TIMER_TIMERID_9_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO9_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO9_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_MME_GUARD_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_MME_GUARD_TIMER_TIMERID_9_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO9_TIMERVAL,
                    MAX_TIMERINFO9_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRC_MME_GUARD_TIMER_TIMERID_9_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RRM_UE_CAPABILITY_ENQ_TIMER_TIMERID_10_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO10_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO10_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRM_UE_CAPABILITY_ENQ_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRM_UE_CAPABILITY_ENQ_TIMER_TIMERID_10_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO10_TIMERVAL,
                    MAX_TIMERINFO10_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRM_UE_CAPABILITY_ENQ_TIMER_TIMERID_10_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_UE_CONTXT_MODIFY_TIMER_TIMERID_14_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO14_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO14_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_UE_CONTXT_MODIFY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_UE_CONTXT_MODIFY_TIMER_TIMERID_14_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO14_TIMERVAL,
                    MAX_TIMERINFO14_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_UE_CONTXT_MODIFY_TIMER_TIMERID_14_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_ERAB_SETUP_TIMER_TIMERID_15_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO15_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO15_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_ERAB_SETUP_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_ERAB_SETUP_TIMER_TIMERID_15_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO15_TIMERVAL,
                    MAX_TIMERINFO15_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_ERAB_SETUP_TIMER_TIMERID_15_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_ERAB_MODIFY_TIMER_TIMERID_16_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO16_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO16_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_ERAB_MODIFY_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_ERAB_MODIFY_TIMER_TIMERID_16_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO16_TIMERVAL,
                    MAX_TIMERINFO16_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_ERAB_MODIFY_TIMER_TIMERID_16_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_ERAB_RELEASE_CMD_TIMER_TIMERID_17_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO17_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO17_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_ERAB_RELEASE_CMD_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_ERAB_RELEASE_CMD_TIMER_TIMERID_17_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO17_TIMERVAL,
                    MAX_TIMERINFO17_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_ERAB_RELEASE_CMD_TIMER_TIMERID_17_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_ERAB_RELEASE_IND_TIMER_TIMERID_18_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO18_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO18_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_ERAB_RELEASE_IND_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_ERAB_RELEASE_IND_TIMER_TIMERID_18_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO18_TIMERVAL,
                    MAX_TIMERINFO18_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_ERAB_RELEASE_IND_TIMER_TIMERID_18_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RLF_WAIT_FOR_REEST_TIMER_TIMERID_19_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO19_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO19_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RLF_WAIT_FOR_REEST_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RLF_WAIT_FOR_REEST_TIMER_TIMERID_19_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO19_TIMERVAL,
                    MAX_TIMERINFO19_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RLF_WAIT_FOR_REEST_TIMER_TIMERID_19_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RLF_UE_SUSPEND_TIMER_TIMERID_20_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO20_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO20_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RLF_UE_SUSPEND_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RLF_UE_SUSPEND_TIMER_TIMERID_20_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO20_TIMERVAL,
                    MAX_TIMERINFO20_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RLF_UE_SUSPEND_TIMER_TIMERID_20_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    /* SPR 11952 FIX START */
    tag_value =
        (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->S1AP,"TRelocPrep");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = OAM_HUNDRED * oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO21_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO21_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_HO_PREP_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_HO_PREP_TIMER_TIMERID_21_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO21_TIMERVAL,
                    MAX_TIMERINFO21_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "TRelocPrep not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value =
        (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->S1AP,"TRelocOverall");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = OAM_HUNDRED * oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO22_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO22_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_HO_OVERALL_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_HO_OVERALL_TIMER_TIMERID_22_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO22_TIMERVAL,
                    MAX_TIMERINFO22_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "TRelocOverall not found");
        /* SPR 11952 FIX END */
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_guard_timers,
            "UECC_LL_GUARD_TIMER_TIMERID_23_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO23_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO23_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_LL_GUARD_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_LL_GUARD_TIMER_TIMERID_23_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO23_TIMERVAL,
                    MAX_TIMERINFO23_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_LL_GUARD_TIMER_TIMERID_23_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RRC_OFFSET_TIMER_TIMERID_24_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO24_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO24_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_OFFSET_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_OFFSET_TIMER_TIMERID_24_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO24_TIMERVAL,
                    MAX_TIMERINFO24_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRC_OFFSET_TIMER_TIMERID_24_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_guard_timers,
            "UECC_MEAS_CONFIG_GUARD_TIMER_TIMERID_25_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO25_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO25_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_MEAS_CONFIG_GUARD_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_MEAS_CONFIG_GUARD_TIMER_TIMERID_25_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO25_TIMERVAL,
                    MAX_TIMERINFO25_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_MEAS_CONFIG_GUARD_TIMER_TIMERID_25_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_guard_timers,
            "UECC_RRC_TRG_HO_GUARD_TIMER_TIMERID_26_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO26_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO26_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_TRG_HO_GUARD_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_TRG_HO_GUARD_TIMER_TIMERID_26_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO26_TIMERVAL,
                    MAX_TIMERINFO26_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRC_TRG_HO_GUARD_TIMER_TIMERID_26_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_guard_timers,
            "UECC_CRE_GUARD_TIMER_TIMERID_31_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO31_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO31_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_CRE_GUARD_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_CRE_GUARD_TIMER_TIMERID_31_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO31_TIMERVAL,
                    MAX_TIMERINFO31_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_CRE_GUARD_TIMER_TIMERID_31_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RRC_X2_HO_PREP_TIMER_TIMERID_40_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO40_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO40_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_X2_HO_PREP_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_X2_HO_PREP_TIMER_TIMERID_40_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO40_TIMERVAL,
                    MAX_TIMERINFO40_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRC_X2_HO_PREP_TIMER_TIMERID_40_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "UECC_RRC_X2_HO_OVERALL_TIMER_TIMERID_41_VALUE");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_TIMERINFO41_TIMERVAL &&
                lclTemp_value <= MAX_TIMERINFO41_TIMERVAL) {
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt].
                timer_val = lclTemp_value;
            RRC_PROV_REQ.uecc_timer_info.timer_info[cnt++].
                timer_id = UECC_RRC_X2_HO_OVERALL_TIMER;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "UECC_RRC_X2_HO_OVERALL_TIMER_TIMERID_41_VALUE",
                    lclTemp_value,
                    MIN_TIMERINFO41_TIMERVAL,
                    MAX_TIMERINFO41_TIMERVAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag "
                "UECC_RRC_X2_HO_OVERALL_TIMER_TIMERID_41_VALUE not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    /**************** TimerInfo Changes ****************/

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.RRCparams,
            "nonBroadcastSfnOffset");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_RRC_NONBROADCASTSFNOFFSET &&
                lclTemp_value <= MAX_RRC_NONBROADCASTSFNOFFSET) {
            RRC_PROV_REQ.non_broadcast_sfn_offset = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "nonBroadcastSfnOffset",
                    lclTemp_value,
                    MIN_RRC_NONBROADCASTSFNOFFSET,
                    MAX_RRC_NONBROADCASTSFNOFFSET);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag nonBroadcastSfnOffset not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.RRCparams,
            "maxCellReconfigRetryCount");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_RRC_MAXCELLRECONFIGRETRYCOUNT &&
                lclTemp_value <= MAX_RRC_MAXCELLRECONFIGRETRYCOUNT) {
            RRC_PROV_REQ.max_cell_reconfig_retry_count = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "maxCellReconfigRetryCount",
                    lclTemp_value,
                    MIN_RRC_MAXCELLRECONFIGRETRYCOUNT,
                    MAX_RRC_MAXCELLRECONFIGRETRYCOUNT);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Mandatory tag maxCellReconfigRetryCount not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.Cell_Traffic_Trace_feature,
            "vendorName");


    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_strlen(tag_value);
        if(lclTemp_value < RRC_VENDOR_NAME_LEN) {
            oam_strncpy((Char8*)RRC_PROV_REQ.vendor_name, tag_value,
                    RRC_VENDOR_NAME_LEN);
            RRC_PROV_REQ.len_vendor_name = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Maximum length of vendorName should be less than %d",
                    RRC_VENDOR_NAME_LEN);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag vendorName not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    /* SPR 7002 : FIX START */

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_guard_timers,
            "uecc_intra_cell_ho_guard_timer");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= RRC_UECC_INTRA_CELL_HO_GUARD_TIMER_MIN_VAL &&
                lclTemp_value <= RRC_UECC_INTRA_CELL_HO_GUARD_TIMER_MAX_VAL) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_MODULE_TIMERS_INFO;
            RRC_PROV_REQ.module_timers_info.
                bitmask |= RRC_OAM_UECC_INTRA_CELL_HO_GUARD_TIMER_PRESENT;

            RRC_PROV_REQ.module_timers_info.
                uecc_intra_cell_ho_guard_timer = lclTemp_value; 
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "uecc_intra_cell_ho_guard_timer",
                    lclTemp_value,
                    RRC_UECC_INTRA_CELL_HO_GUARD_TIMER_MIN_VAL,
                    RRC_UECC_INTRA_CELL_HO_GUARD_TIMER_MAX_VAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "uecc_ue_reconfig_timer");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= RRC_UECC_UE_RECONFIG_TIMER_MIN_VAL &&
                lclTemp_value <= RRC_UECC_UE_RECONFIG_TIMER_MAX_VAL) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_MODULE_TIMERS_INFO;
            RRC_PROV_REQ.module_timers_info.
                bitmask |= RRC_OAM_UECC_UE_RECONFIG_TIMER_PRESENT;

            RRC_PROV_REQ.module_timers_info.
                uecc_ue_reconfig_timer = lclTemp_value; 
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "uecc_ue_reconfig_timer",
                    lclTemp_value,
                    RRC_UECC_UE_RECONFIG_TIMER_MIN_VAL,
                    RRC_UECC_UE_RECONFIG_TIMER_MAX_VAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "uecc_integrity_threshold_timer_value");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        RRC_PROV_REQ.bitmask |= RRC_OAM_MODULE_TIMERS_INFO;
        RRC_PROV_REQ.module_timers_info.
            bitmask |= RRC_OAM_UECC_INTEGRITY_THRESHOLD_TIMER_PRESENT;

        RRC_PROV_REQ.module_timers_info.
            uecc_integrity_threshold_timer_value = lclTemp_value; 
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_guard_timers,
            "uecc_cco_guard_timer_value");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= RRC_UECC_CCO_GUARD_TIMER_MIN_VAL &&
                lclTemp_value <= RRC_UECC_CCO_GUARD_TIMER_MAX_VAL) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_MODULE_TIMERS_INFO;
            RRC_PROV_REQ.module_timers_info.
                bitmask |= RRC_OAM_UECC_CCO_GUARD_TIMER_PRESENT;

            RRC_PROV_REQ.module_timers_info.
                uecc_cco_guard_timer_value = lclTemp_value; 
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "uecc_cco_guard_timer_value",
                    lclTemp_value,
                    RRC_UECC_CCO_GUARD_TIMER_MIN_VAL,
                    RRC_UECC_CCO_GUARD_TIMER_MAX_VAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "ueccStoreUeContextTimer");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= RRC_UECC_STORE_UE_CONTEXT_TIMER_MIN_VAL &&
                lclTemp_value <= RRC_UECC_STORE_UE_CONTEXT_TIMER_MAX_VAL) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_MODULE_TIMERS_INFO;
            RRC_PROV_REQ.module_timers_info.
                bitmask |= RRC_OAM_UECC_STORE_UE_CONTEXT_TIMER_PRESENT;

            RRC_PROV_REQ.module_timers_info.
                uecc_store_ue_context_timer = lclTemp_value; 
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "ueccStoreUeContextTimer",
                    lclTemp_value,
                    RRC_UECC_STORE_UE_CONTEXT_TIMER_MIN_VAL,
                    RRC_UECC_STORE_UE_CONTEXT_TIMER_MAX_VAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "ueccCounterCheckTimer");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= RRC_UECC_UE_COUNTER_CHECK_TIMER_MIN_VAL &&
                lclTemp_value <= RRC_UECC_UE_COUNTER_CHECK_TIMER_MAX_VAL) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_MODULE_TIMERS_INFO;
            RRC_PROV_REQ.module_timers_info.
                bitmask |= RRC_OAM_UECC_UE_COUNTER_CHECK_TIMER_PRESENT;

            RRC_PROV_REQ.module_timers_info.
                uecc_ue_counter_check_timer = lclTemp_value; 
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "ueccCounterCheckTimer",
                    lclTemp_value,
                    RRC_UECC_UE_COUNTER_CHECK_TIMER_MIN_VAL,
                    RRC_UECC_UE_COUNTER_CHECK_TIMER_MAX_VAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.RRCparams_procedural_timers,
            "ueccUeInformationTimer");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= RRC_UECC_UE_INFORMATION_TIMER_MIN_VAL &&
                lclTemp_value <= RRC_UECC_UE_INFORMATION_TIMER_MAX_VAL) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_MODULE_TIMERS_INFO;
            RRC_PROV_REQ.module_timers_info.
                bitmask |= RRC_OAM_UECC_UE_INFORMATION_TIMER_PRESENT;

            RRC_PROV_REQ.module_timers_info.
                uecc_ue_information_timer = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "ueccUeInformationTimer",
                    lclTemp_value,
                    RRC_UECC_UE_INFORMATION_TIMER_MIN_VAL,
                    RRC_UECC_UE_INFORMATION_TIMER_MAX_VAL);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    /* SPR 22055 FIXED START*/
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.health_monitoring,"healthMonitoringTimeInterval");

    if(oam_strcmp(tag_value, OAM_INVALID_STR))
    {
        lclTemp_value = oam_atoi(tag_value);

        RRC_PROV_REQ.bitmask |= RRC_OAM_MODULE_TIMERS_INFO;
        RRC_PROV_REQ.module_timers_info.
            bitmask |= RRC_OAM_UECC_HEALTH_MONITORING_TIMER_PRESENT;

        RRC_PROV_REQ.module_timers_info.
            rrc_health_mon_time_int = lclTemp_value; 
    }
    /* SPR 22055 FIXED END*/

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.RRCparams,
            "advance_logging_config_option");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_ADVANCE_LOGGING_CONFIG_OPTION &&
                lclTemp_value <= MAX_ADVANCE_LOGGING_CONFIG_OPTION) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_CONFIG_OPTION_PRESENT;
            RRC_PROV_REQ.advance_logging_config_option = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of %s is %d and range is from %d to %d",
                    "advance_logging_config_option",
                    lclTemp_value,
                    MIN_ADVANCE_LOGGING_CONFIG_OPTION,
                    MAX_ADVANCE_LOGGING_CONFIG_OPTION);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.RRCparams,
            "network_ip_port");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        RRC_PROV_REQ.network_ip_port[OAM_ZERO] = lclTemp_value;
        RRC_PROV_REQ.bitmask |= RRC_OAM_NETWORK_IP_PORT_PRESENT;
    }

    /*ADD RRC SHM PARA */


    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.shared_mem_logging_config,
            "SharedMemSize");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_SHARED_MEM_SIZE &&
                lclTemp_value <= MAX_SHARED_MEM_SIZE) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_SHARED_MEM_NAME_PRESENT;
            RRC_PROV_REQ.shared_mem_logging_config.
                SharedMemSize = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of SharedMemSize is %d and range is from %d to %d",
                    lclTemp_value, MIN_SHARED_MEM_SIZE, MAX_SHARED_MEM_SIZE);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.shared_mem_logging_config,
            "MaxLogFileSize");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= MIN_LOG_FILE_SIZE &&
                lclTemp_value <= MAX_LOG_FILE_SIZE) {
            RRC_PROV_REQ.bitmask |= RRC_OAM_SHARED_MEM_NAME_PRESENT;
            RRC_PROV_REQ.shared_mem_logging_config.
                MaxLogFileSize = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of MaxLogFileSize is %d and range is from %d to %d",
                    lclTemp_value, MIN_LOG_FILE_SIZE, MIN_LOG_FILE_SIZE);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.shared_mem_logging_config,
            "LogFilePath");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_strlen(tag_value);

        if(lclTemp_value < MAX_FILE_NAME_SIZE) {
            RRC_PROV_REQ.shared_mem_logging_config.
                bitmask |= RRC_OAM_SHARED_MEM_LOG_FILE_PATH_PRESENT;
            oam_strncpy((Char8*)RRC_PROV_REQ.shared_mem_logging_config.
                    LogFilePath, tag_value, MAX_FILE_NAME_SIZE);
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Maximum allowed length of LogFilePath is %d",
                    MAX_FILE_NAME_SIZE);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(
            xml_struct_g.shared_mem_logging_config,
            "core_no");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);
        if(lclTemp_value >= 0) {
            RRC_PROV_REQ.shared_mem_logging_config.
                bitmask |= RRC_OAM_SHARED_MEM_CORE_NUMBER_PRESENT;
            RRC_PROV_REQ.shared_mem_logging_config.core_no = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Invalid value[%s] of core_no", tag_value);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.L3Params,
            "num_uecc_instances");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        /* SPR 11156 FIX START */
        lclTemp_value = oam_atoi(tag_value);
        /* SPR 11156 FIX END */
        if(lclTemp_value >= OAM_L3_MIN_UECC_INSTANCES &&
                lclTemp_value <= OAM_L3_MAX_UECC_INSTANCES) {
            RRC_PROV_REQ.no_of_uecc_instances = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Invalid value[%s] of num_uecc_instances", tag_value);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory param num_uecc_instances missing");

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    /* Start :SPR 10745 */
    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.L3Params,
            "core_num_mapping");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        p_temp_token = oam_strtok((char *)tag_value,",");        

        while (OAM_NULL != p_temp_token && counter < (RRC_PROV_REQ.no_of_uecc_instances + OAM_ONE))
        {
            lclTemp_value = oam_atoi(p_temp_token);
            RRC_PROV_REQ.core_no[counter] = lclTemp_value;
            counter++;
            p_temp_token = oam_strtok(OAM_NULL,",");
        }
        /* SPR_19838 : Coverity_10470 Fix Start */
        if (counter > 0)
        {
            RRC_PROV_REQ.rest_rrc_core_no = RRC_PROV_REQ.core_no[counter - 1]; /* Assigning last core no to rest_rrc_core_no */ 
            RRC_PROV_REQ.core_no[counter - 1] = OAM_ZERO;  
        }
        /* SPR_19838 : Coverity_10470 Fix Stop */
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory param core_num_mapping missing");

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    /* End :SPR 10745 */

    tag_value = (Char8*)oam_xmlNodeGetContent(xml_struct_g.RRCparams,
            "ue_context_list_size");

    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_strlen(tag_value);

        if(lclTemp_value >= 0) {
            RRC_PROV_REQ.ue_context_list_size = lclTemp_value;
            RRC_PROV_REQ.bitmask |= RRC_OAM_UE_CONTEXT_LIST_SIZE_PRESENT;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Invalid value[%s] of ue_context_list_size", tag_value);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }

    /* SPR 7002 : FIX END */

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_cell_specific_rrc_params
 *  DESCRIPTION      : This function is used to populate the cell specific rrc 
 parameters
 *  PARAMETERS       
 *      IN           : Pointers of XML_struct_cell_config, prop_cellconfig_xml_st
 oam_rrm_cell_config_req_t & rrc_oam_sector_info_t
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          : OAM_SUCCESS on Success
 *                     OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_cell_specific_rrc_params
(
 XML_struct_cell_config *p_cell_spec_params,
 prop_cellconfig_xml_st *p_prop_cellconfig,
 oam_rrm_cell_config_req_t *p_rrm_cellconfig,
 rrc_oam_sector_info_t *p_cell_info
 )
{
    OAM_FUN_ENTRY_TRACE();
    Char8 *tag_value = OAM_NULL;

    OAM_LOG(OAM, OAM_INFO, "Populating cell specific RRC params from xml...");

    tag_value = (Char8*)oam_xmlNodeGetContent(p_prop_cellconfig->dimension_params,
            "Max_no_of_ue");
    if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi(tag_value);

        if(lclTemp_value >= OAM_RRC_MIN_NUM_SUPP_UE &&
                lclTemp_value <= OAM_RRC_MAX_NUM_SUPP_UE) {
            p_cell_info->max_num_supported_ue = lclTemp_value;
            OAM_LOG(OAM, OAM_INFO, "Value of RRC Max_no_of_ue is %d",
                    lclTemp_value);
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Value of Max_no_of_ue is %s and range "
					"is from %d to %d", tag_value,
                    OAM_RRC_MIN_NUM_SUPP_UE,
                    OAM_RRC_MAX_NUM_SUPP_UE);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag Max_no_of_ue not found");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    tag_value = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->EPC,
            "X_VENDOR_PDCP_INTEGRITY_THRESHOLD_COUNTER");

    lclTemp_value = oam_atoi(tag_value);
    RRC_PROV_REQ.bitmask |= RRC_OAM_INTEGRITY_THRESHOLD_COUNTER_PRESENT;
    RRC_PROV_REQ.pdcp_integrity_threshold_counter = lclTemp_value;

    oam_populate_epc_cipher_and_integrity_algo_data(p_cell_spec_params,
            p_cell_info);

    p_cell_info->cell_index = oam_extract_cid_from_eutran_cellidentity(
            p_rrm_cellconfig->global_cell_info.
            eutran_global_cell_id.cell_identity);


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

#ifdef OAM_SON_ENABLE
/****************************************************************************
 *  FUNCTION NAME    : oam_populate_son_utra_fdd_list
 *  DESCRIPTION      : This function is used to populate SON parameters 
 *  		           for carrier frequency measurement
 *  PARAMETERS
 *      IN           : ponter to oam_rrm_cell_config_req_t
 *
 *      OUT          : pointer to oam_son_inter_freq_carrier_t
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_son_utra_fdd_list
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params,
 oam_rrm_cell_config_req_t *p_rrm_cell_config
 )
{
    UInt32 count = OAM_ZERO;
    UInt32 index = OAM_ZERO;
    UInt32 bitmask = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    xmlChar* tag_value = OAM_NULL;
    SInt32   count1 = 0;

    OAM_FUN_ENTRY_TRACE();

    oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
        &p_son_inter_freq_carr_params->oam_son_anr_meas_config_req;

    count = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_inter_rat_utra_params.
        irat_eutran_to_utran_fdd_list.
        num_irat_eutran_to_utran_fdd_carriers;

    p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
        utran_fdd_list_size = count;

    for(index = 0; index < count; ++index) {
        tag_value = oam_get_xml_text_node_content(
                p_cell_spec_params->UTRANFDDFreq[index],
                "X_VENDOR_INSTANCE_ID", buf,
                OAM_TAG_VALUE_STR_MAX_LEN);

        if(tag_value) {
            count1  =  oam_atoi(buf);

            --count1;

            if(count1 < 0 || count1 >= SON_MAX_CONFIG_OBJECT) {
				OAM_LOG(OAM, OAM_WARNING,
                        "Invalid X_VENDOR_INSTANCE_ID value[%d]", count1);

                retVal = OAM_FAILURE;
                break;
            }

            /* Required to support add/delete */
            p_son_inter_freq_carr_params->utran_fdd_meas_entry_bitmap |=
                (1 << count1);
        }

        if (count1 + 1 >
                p_son_inter_freq_carr_params->utran_fdd_last_inst_id) {
            p_son_inter_freq_carr_params->utran_fdd_last_inst_id =
                (count1 + 1);
        }

        /* SPR 14651 START */
        lclTemp_value = oam_atoi((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UTRANFDDFreq[index],
                    "Enable"));   

        p_son_inter_freq_carr_params->utran_meas_enable[index].enable = lclTemp_value;
        p_son_inter_freq_carr_params->utran_meas_enable[index].bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
        /* SPR 14651 START */

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].uarfcn = (son_u16)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].
            utra_carrier_arfcn;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].q_rx_lev_min =
            (son_s8)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].
            q_rx_lev_min;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].
            bitmask |= SON_MC_UTRAN_FDD_Q_RX_LEV_MIN_PRESENT;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].q_qual_min =
            (son_s8)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].
            q_qual_min;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].bitmask |= SON_MC_UTRAN_FDD_Q_QUAL_MIN_PRESENT;

        bitmask = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].bitmask;

        if (bitmask & RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT) {
            p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_fdd_list[count1].
                cell_reselection_priority = (son_u8)p_rrm_cell_config->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_utra_params.
                irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].
                cell_reselection_priority;

            p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_fdd_list[count1].
                bitmask |= SON_MC_UTRAN_FDD_CELL_RESELECTION_PRIORITY_PRESENT;
        }

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].threshX_high =
            (son_u8)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].
            thresh_x_high;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].
            bitmask |= SON_MC_UTRAN_FDD_THRESH_HIGH_PRESENT;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].threshX_low =
            (son_u8)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].
            thresh_x_low;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].
            bitmask |= SON_MC_UTRAN_FDD_THRESH_LOW_PRESENT;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].p_max = (son_s8)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].
            p_max_utra;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_fdd_list[count1].bitmask |= SON_MC_UTRAN_FDD_P_MAX_PRESENT;

        bitmask = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_fdd_list.
            irat_eutran_to_utran_fdd_carriers[index].bitmask;

        if (bitmask & RRM_OAM_THRESHOLD_Q_R9_T_PRESENT) {
            p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_fdd_list[count1].threshx_highq_r9 =
                (son_u8)p_rrm_cell_config->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_utra_params.
                irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].
                threshx_q_r9.thresh_serving_highq_r9;

            p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_fdd_list[count1].bitmask |= SON_MC_UTRAN_THRESHX_HIGH_Q_R9;

            p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_fdd_list[count1].threshx_lowq_r9 =
                (son_u8)p_rrm_cell_config->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_utra_params.
                irat_eutran_to_utran_fdd_list.
                irat_eutran_to_utran_fdd_carriers[index].
                threshx_q_r9.thresh_serving_lowq_r9;

            p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_fdd_list[count1].bitmask |= SON_MC_UTRAN_THRESHX_LOW_Q_R9;
        }
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/****************************************************************************
 *  FUNCTION NAME    : oam_populate_son_utran_config_list
 *  DESCRIPTION      : This function is used to populate SON parameters 
 *  		           for carrier frequency measurement
 *  PARAMETERS
 *      IN           : ponter to oam_rrm_cell_config_req_t
 *
 *      OUT          : pointer to oam_son_inter_freq_carrier_t
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_son_utran_config_list
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params,
 oam_rrm_cell_config_req_t *p_rrm_cell_config
 )
{
    UInt32 bitmask = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;

    oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
        &p_son_inter_freq_carr_params->oam_son_anr_meas_config_req;

    p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
        t_reselection = (son_u8)p_rrm_cell_config->ran_info.
        mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_inter_rat_utra_params.
        irat_eutra_to_utra_reselection_params.
        t_reselection_utra;

    p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
        bitmask |= SON_UTRAN_RESELECTION_PRESENT;

    bitmask = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_inter_rat_utra_params.
        irat_eutra_to_utra_reselection_params.bitmask;

    if (bitmask & RRM_OAM_EUTRA_UTRA_RESELECTION_SPEED_SCALE_FACTOR_PRESENT) {
        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            t_reselection_sf.sf_medium =
            (son_speed_state_scale_factors_sf_medium_et)p_rrm_cell_config->
            ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutra_to_utra_reselection_params.
            speed_scale_factors.
            t_reselection_eutra_sf_medium;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            t_reselection_sf.sf_high =
            (son_speed_state_scale_factors_sf_high_et)p_rrm_cell_config->
            ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutra_to_utra_reselection_params.
            speed_scale_factors.
            t_reselection_eutra_sf_high;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            bitmask |= SON_UTRAN_RESELECTION_SF_PRESENT;
    }


    bitmask = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_inter_rat_utra_params.bitmask;
    if (bitmask & RRM_OAM_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT) {
        retVal = oam_populate_son_utra_tdd_list(p_son_inter_freq_carr_params,
                p_rrm_cell_config);
        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
                    "Population of UTRAN TDD carrier params failed");
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Population of UTRAN TDD carrier params successful");
        }
    }

    bitmask = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_inter_rat_utra_params.bitmask;
    if (bitmask & RRM_OAM_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT) {
        retVal = oam_populate_son_utra_fdd_list(p_cell_spec_params,
                p_son_inter_freq_carr_params,
                p_rrm_cell_config);

        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
                    "Population of UTRAN FDD carrier params failed");
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Population of UTRAN FDD carrier params successful");
        }
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/****************************************************************************
 *  FUNCTION NAME    : oam_populate_son_geran_config_list
 *  DESCRIPTION      : This function is used to populate SON parameters 
 *  		           for carrier frequency measurement
 *  PARAMETERS
 *      IN           : 1. pointer to XML_struct_cell_config for cell specific
 *                     TR-196 params
 *                     2. ponter to oam_rrm_cell_config_req_t
 *
 *      OUT          : pointer to oam_son_inter_freq_carrier_t
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_son_geran_config_list
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params,
 oam_rrm_cell_config_req_t *p_rrm_cellconfig
 )
{
    UInt32 bitmask = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;
    UInt32 count = OAM_ZERO;
    UInt32 index = OAM_ZERO;
    UInt32 count1 = OAM_ZERO;
    UInt32 count2 = OAM_ZERO;
    UInt32 index1 = OAM_ZERO;
    xmlChar* tag_value = OAM_NULL;
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};

    oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
        &p_son_inter_freq_carr_params->oam_son_anr_meas_config_req;

    OAM_FUN_ENTRY_TRACE();

    p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
        t_reselection = (son_u8)p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_inter_rat_geran_params.
        geran_reselection_params.t_reselection_geran;

    p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
        bitmask |= SON_MC_GERAN_RESELECTION_PRESENT;

    bitmask = p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_inter_rat_geran_params.
        geran_reselection_params.bitmask;

    if (bitmask & RRM_OAM_T_RESELECTION_GERAN_SPEED_SCALE_FACTOR_PRESENT) {
        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            t_reselection_sf.sf_medium =
            (son_speed_state_scale_factors_sf_medium_et)p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            geran_reselection_params.speed_scale_factors.
            t_reselection_eutra_sf_medium;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            bitmask |= SON_MC_GERAN_RESELECTION_SF_PRESENT;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            t_reselection_sf.sf_high =
            (son_speed_state_scale_factors_sf_high_et)p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            geran_reselection_params.speed_scale_factors.
            t_reselection_eutra_sf_high;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            bitmask |= SON_MC_GERAN_RESELECTION_SF_PRESENT;
    }

    count = p_rrm_cellconfig->ran_info.mobility_params.
        idle_mode_mobility_params.
        idle_mode_mobility_inter_rat_geran_params.
        carrier_freq_info_list.count_geran_carrier;

    p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
        geran_freq_info_list_size = count;
    for(index = 0; index < count; ++index) {
        tag_value = oam_get_xml_text_node_content(
                p_cell_spec_params->GERANFreqGroup[index],
                "X_VENDOR_INSTANCE_ID", buf,
                OAM_TAG_VALUE_STR_MAX_LEN);

        if(tag_value) {
            count1  =  oam_atoi(buf);
            /* SPR_19838: Coverity_10208 Fix Start */
            if(count1 > 0)
            {
                --count1;
            }
            /* SPR_19838: Coverity_10208 Fix Stop */

            /**  Coverity 67040  Fix Start **/
            if(count1 >= SON_MAX_CONFIG_OBJECT) {
                /**  Coverity 67040  Fix End **/
				OAM_LOG(OAM, OAM_WARNING,
                        "Invalid X_VENDOR_INSTANCE_ID value[%d]", count1);

                retVal = OAM_FAILURE;
                break;
            }

            /* Required to support add/delete */
            p_son_inter_freq_carr_params->geran_meas_entry_bitmap |=
                (1 << count1);
        }

        if ((count1 + 1) >
                p_son_inter_freq_carr_params->geran_freq_group_last_inst_id) {
            p_son_inter_freq_carr_params->geran_freq_group_last_inst_id =
                (count1 + 1);
        }

        /* SPR 14651 START */
        lclTemp_value = oam_atoi((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->GERANFreqGroup[index],
                    "Enable"));    

        p_son_inter_freq_carr_params->geran_meas_enable[index].enable = lclTemp_value;
        p_son_inter_freq_carr_params->geran_meas_enable[index].bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
        /* SPR 14651 END */

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].geran_car_freqs.
            starting_arfcn = (son_u16)p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.
            carrier_list[index].carrier_freq.
            starting_arfcn;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            /* SPR 11001 FIX START */
            geran_freq_info_list[count1].geran_car_freqs.band_ind =
            /* SPR 11001 FIX END */
            (son_geran_band_indicator_et)p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            carrier_freq.band_indicator;

        bitmask = p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            common_info.present_bitmask;

        if (bitmask & RRM_OAM_CARRIER_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG) {
            p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
                geran_freq_info_list[count1].cell_reselection_priority =
                (son_u8)p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_geran_params.
                carrier_freq_info_list.carrier_list[index].
                common_info.cell_reselection_priority;

            p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
                geran_freq_info_list[count1].
                bitmask |= SON_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT;
        }

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].ncc_permitted =
            (son_u8)p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            common_info.ncc_peritted[OAM_ZERO];

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].
            bitmask |= SON_GERAN_CFI_NCC_PERMITTED_PRESENT;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].q_rx_lev_min =
            (son_u8)p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            common_info.q_rx_lev_min;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].
            bitmask |= SON_GERAN_CFI_Q_RX_LEV_MIN_PRESENT;

        bitmask = p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            common_info.present_bitmask;

        if (bitmask & RRM_OAM_CARRIER_GERAN_P_MAX_GERAN_PRESENCE_FLAG) {
            p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
                geran_freq_info_list[count1].p_max_geran =
                (son_u8)p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_geran_params.
                carrier_freq_info_list.carrier_list[index].
                common_info.p_max_geran;

            p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
                geran_freq_info_list[count1].
                bitmask |= SON_GERAN_CFI_MAX_ALLOWED_TRANS_PWR_PRESENT;
        }

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].threshX_high =
            (son_u8)p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            common_info.thres_x_high;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].
            bitmask |= SON_GERAN_CFI_THRESH_HIGH_PRESENT;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].threshX_low =
            (son_u8)p_rrm_cellconfig->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            common_info.thres_x_low;

        p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list[count1].
            bitmask |= SON_GERAN_CFI_THRESH_LOW_PRESENT;

        bitmask = p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            carrier_freq.following_arfcn.presence_bitmask;

        if (bitmask & RRM_OAM_GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG) {
            count2 = p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_geran_params.
                carrier_freq_info_list.carrier_list[index].
                carrier_freq.following_arfcn.
                explicit_list_of_arfcns.count_explicit_arfcn;

            p_son_anr_meas_config_req->other_rat_config_list.
                geran_config_list.geran_freq_info_list[count1].
                geran_car_freqs.following_arfcns.exp_arfcn_list_size = count2;

            if(count2 > 0) {
                p_son_anr_meas_config_req->other_rat_config_list.
                    geran_config_list.geran_freq_info_list[count1].
                    geran_car_freqs.following_arfcns.
                    bitmask |= SON_MC_GERAN_EXP_ARFCN_SET_PRESENT;
            }

            for(index1 = OAM_ZERO; index1 < count2; ++index1) {
                p_son_anr_meas_config_req->other_rat_config_list.
                    geran_config_list.geran_freq_info_list[count1].
                    geran_car_freqs.following_arfcns.
                    exp_arfcn_list[index1] = p_rrm_cellconfig->ran_info.
                    mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.
                    carrier_freq_info_list.carrier_list[index].
                    carrier_freq.following_arfcn.
                    explicit_list_of_arfcns.
                    data_explicit_arfcn[index1];
            }
        }

        bitmask = p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            carrier_freq.following_arfcn.presence_bitmask;

        if (bitmask & RRM_OAM_GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG) {
            p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
                geran_freq_info_list[count1].geran_car_freqs.following_arfcns.
                arfcn_spacing = (son_u8)p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_geran_params.
                carrier_freq_info_list.carrier_list[index].
                carrier_freq.following_arfcn.
                equally_spaced_arfcns.arfcn_spacing;

            p_son_anr_meas_config_req->other_rat_config_list.
                geran_config_list.geran_freq_info_list[count1].
                geran_car_freqs.following_arfcns.
                bitmask |= SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT;

            p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
                geran_freq_info_list[count1].geran_car_freqs.following_arfcns.
                num_of_following_arfcn = (son_u8)p_rrm_cellconfig->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_geran_params.
                carrier_freq_info_list.carrier_list[index].
                carrier_freq.following_arfcn.
                equally_spaced_arfcns.num_of_following_arfcns;

            p_son_anr_meas_config_req->other_rat_config_list.
                geran_config_list.geran_freq_info_list[count1].
                geran_car_freqs.following_arfcns.
                bitmask |= SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT;
        }

        bitmask = p_rrm_cellconfig->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_geran_params.
            carrier_freq_info_list.carrier_list[index].
            carrier_freq.following_arfcn.presence_bitmask;

        if (bitmask & RRM_OAM_GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG) {
            count2 = p_rrm_cellconfig->ran_info.mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_geran_params.
                carrier_freq_info_list.carrier_list[index].
                carrier_freq.following_arfcn.
                var_bitmap_of_arfcns.count_var_bit_map;

            p_son_anr_meas_config_req->other_rat_config_list.
                geran_config_list.geran_freq_info_list[count1].
                geran_car_freqs.following_arfcns.
                arfcn_bmp_list_size = (son_u8)count2;

            p_son_anr_meas_config_req->other_rat_config_list.
                geran_config_list.geran_freq_info_list[count1].
                geran_car_freqs.following_arfcns.
                bitmask |= SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT;

            oam_memcpy(p_son_anr_meas_config_req->other_rat_config_list.
                    geran_config_list.geran_freq_info_list[count1].
                    geran_car_freqs.following_arfcns.arfcn_bmp_list,
                    p_rrm_cellconfig->ran_info.mobility_params.
                    idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params.
                    carrier_freq_info_list.carrier_list[index].
                    carrier_freq.following_arfcn.var_bitmap_of_arfcns.
                    data_var_bitmap,
                    count2);
        }
    }

    return retVal;
}

/****************************************************************************
 *  FUNCTION NAME    : oam_populate_son_eutran_config_list
 *  DESCRIPTION      : This function is used to populate SON parameters 
 *                     for carrier frequency measurement
 *  PARAMETERS
 *      IN           : ponter to oam_rrm_cell_config_req_t
 *
 *      OUT          : pointer to oam_son_inter_freq_carrier_t
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_son_eutran_config_list
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params,
 oam_rrm_cell_config_req_t *p_rrm_cell_config
 )
{
    UInt32   count = 0;
    SInt32   count1 = 0;
    UInt32   bitmask = 0;
    UInt8    index = 0;
    xmlChar* tag_value = OAM_NULL;
    xmlChar* tag_value1 = OAM_NULL;
    SInt32 found = OAM_ZERO;
    SInt32 found1 = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    /* SPR 14651 START */
    UInt8 eutran_meas_enable = OAM_ZERO;
    /* SPR 14651 END */

    oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
        &p_son_inter_freq_carr_params->oam_son_anr_meas_config_req;

    Char8     *temp;

    OAM_FUN_ENTRY_TRACE();

    tag_value = oam_xmlNodeGetContent(p_cell_spec_params->InterFreq,
            "MaxCarrierEntries");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(lclTemp_value > OAM_MAX_INTER_FREQ_CARRIER_OBJECTS) {
			OAM_LOG(OAM, OAM_WARNING, "Maximum allowable value of the tag "
                    "MaxCarrierEntries is %d",
                    OAM_MAX_INTER_FREQ_CARRIER_OBJECTS);

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /* SPR_18371 Fix Start */
        p_son_inter_freq_carr_params->MaxCarrierEntries =
            (UInt16)lclTemp_value;

        /* SPR_18371 Fix End */

    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Mandatory tag MaxCarrierEntries missing");

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    /* OAM BCOM Code Comment Changes Start */
    SInt32 eutran_meas_cnt = OAM_ZERO;
    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->InterFreq,
            "CarrierNumberOfEntries");

    if(strcmp(temp, OAM_INVALID_STR)) {
        eutran_meas_cnt = oam_atoi(temp);

        if(eutran_meas_cnt > lclTemp_value) {
            OAM_LOG(OAM, OAM_WARNING, "Maximum allowable value of the tag "
                    "CarrierNumberOfEntries is %d", lclTemp_value);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    /* OAM BCOM Code Comment Changes End */

    count = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_inter_freq_params_list.
        num_valid_inter_freq_list;

    p_son_anr_meas_config_req->eutran_config_list_size = (son_u8)count;

    for(index = 0; index < count; ++index) {
        tag_value = oam_get_xml_text_node_content(
                p_cell_spec_params->Carrier[index],
                "X_VENDOR_INSTANCE_ID", buf,
                OAM_TAG_VALUE_STR_MAX_LEN);

        if(tag_value) {
            count1  =  oam_atoi(buf);

            --count1;

            if(count1 < 0 || count1 >= SON_MAX_CONFIG_OBJECT) {
				OAM_LOG(OAM, OAM_WARNING,
                        "Invalid X_VENDOR_INSTANCE_ID value[%d]", count1);

                retVal = OAM_FAILURE;
                break;
            }

            /* Required to support add/delete */
            p_son_inter_freq_carr_params->eutran_meas_entry_bitmap |=
                (1 << count1);
        }

        if (count1 + 1 > p_son_inter_freq_carr_params->eutran_last_inst_id) {
            p_son_inter_freq_carr_params->eutran_last_inst_id = count1 + 1;
        }

        /* SPR 14651 START */
        eutran_meas_enable = oam_atoi((Char8*)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                    "Enable"));  
        p_son_inter_freq_carr_params->eutran_meas_enable[index].enable = eutran_meas_enable;
        p_son_inter_freq_carr_params->eutran_meas_enable[index].bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
        /* SPR 14651 END */

        p_son_anr_meas_config_req->eutran_config_list[count1].
            earfcn = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            eutra_carrier_arfcn;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            q_rx_lev_min = (son_s8)p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            q_rx_lev_min_sib_5;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            bitmask |= SON_MC_EUTRAN_Q_RX_LEV_MIN_PRESENT;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            offset_frequency =
            (son_q_offset_range_et)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            q_offset_freq;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            bitmask |= SON_MC_EUTRAN_OFFSET_FREQ_PRESENT;


        p_son_anr_meas_config_req->eutran_config_list[count1].
            t_reselection = (son_u8)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            t_reselection_eutra;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            bitmask |= SON_MC_EUTRAN_RESELECTION_PRESENT;


        bitmask = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].bitmask;

        if(bitmask & RRM_OAM_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT) {
            p_son_anr_meas_config_req->eutran_config_list[count1].
                cell_reselection_priority = (son_u8)p_rrm_cell_config->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[index].
                cell_reselection_priority;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT;
        }


        p_son_anr_meas_config_req->eutran_config_list[count1].
            threshX_high = (son_u8)p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            thresh_x_high;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            bitmask |= SON_MC_EUTRAN_CELL_THRESH_HIGH_PRESENT;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            threshX_low = (son_u8)p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            thresh_x_low;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            bitmask |= SON_MC_EUTRAN_CELL_THRESH_LOW_PRESENT;

        bitmask = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].bitmask;

        if (bitmask & RRM_OAM_P_MAX_PRESENT) {
            p_son_anr_meas_config_req->eutran_config_list[count1].p_max =
                (son_s8)p_rrm_cell_config->ran_info. mobility_params.
                idle_mode_mobility_params.idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[index].p_max;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_EUTRAN_P_MAX_PRESENT;
        }

        p_son_anr_meas_config_req->eutran_config_list[count1].
            meas_bandwidth_for_earfcn =
            (son_allowed_meas_bandwidth_et)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            measurement_bandwidth;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            bitmask |= SON_MC_EUTRAN_ALLOW_MEAS_BW_PRESENT;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            presence_antenna_port = (son_u8)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            presence_antenna_port1;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            bitmask |= SON_MC_EUTRAN_PRESENCE_ANTENNA_PORT_PRESENT;

        p_son_anr_meas_config_req->eutran_config_list[count1].
            neighbor_cell_config = (son_u8)p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].
            neigh_cell_config;
        p_son_anr_meas_config_req->eutran_config_list[count1].
            bitmask |= SON_MC_EUTRAN_NBR_CELL_CONFIG_PRESENT;


        bitmask = p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].bitmask;

        if (bitmask & RRM_OAM_T_EUTR_SPEED_SCALE_FACTOR_PRESENT) {
            p_son_anr_meas_config_req->eutran_config_list[count1].
                t_reselection_sf.sf_medium =
                (son_speed_state_scale_factors_sf_medium_et)p_rrm_cell_config->
                ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[index].
                speed_scale_factors.t_reselection_eutra_sf_medium;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                t_reselection_sf.sf_high =
                (son_speed_state_scale_factors_sf_high_et)p_rrm_cell_config->
                ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[index].
                speed_scale_factors.t_reselection_eutra_sf_high;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_EUTRAN_RESELECTION_SF_PRESENT;
        }


        bitmask = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].bitmask;
        if (bitmask & RRM_OAM_Q_QUAL_MIN_R9_PRESENT) {
            p_son_anr_meas_config_req->eutran_config_list[count1].
                q_qualmin_r9 = (son_s8)p_rrm_cell_config->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[index].
                q_qual_min_r9;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_EUTRAN_Q_QUAL_MIN_R9;
        }

        bitmask = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[index].bitmask;

        if (bitmask & RRM_OAM_THRESHX_Q_R9_PRESENT) {
            p_son_anr_meas_config_req->eutran_config_list[count1].
                threshx_highq_r9 = (son_u8)p_rrm_cell_config->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[index].
                threshx_q_r9.thresh_serving_highq_r9;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_EUTRAN_THRESHX_HIGH_Q_R9;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                threshx_lowq_r9 = (son_u8)p_rrm_cell_config->ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[index].
                threshx_q_r9.thresh_serving_lowq_r9; 

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_EUTRAN_THRESHX_LOW_Q_R9; 
        }

        if (bitmask & RRM_OAM_CM_OFFSET_FREQ_PRESENT) {
            p_son_anr_meas_config_req->eutran_config_list[count1].
                cm_offset_frequency =
                (son_q_offset_range_et)p_rrm_cell_config->ran_info.mobility_params.       /* coverity 66643 fix */
                idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.
                idle_mode_mobility_inter_freq_params[index].
                cm_offset_freq;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_EUTRAN_CM_OFFSET_FREQ_PRESENT; 
        }

        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                "X_VENDOR_OPEN_PHY_CELLID_START");

        /*SPR 20772 Fix Start*/
        found = oam_strcmp((Char8*)tag_value, OAM_INVALID_STR);
        tag_value1 = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                "X_VENDOR_OPEN_PHY_CELLID_START");
        found1 = oam_strcmp((Char8*)tag_value1, OAM_INVALID_STR);
        /*SPR 20772 Fix End*/

        /* SPR 9574 Fix Start */
        if(found && found1) {    
            tag_value = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                    "X_VENDOR_OPEN_PHY_CELLID_START");

            p_son_anr_meas_config_req->eutran_config_list[count1].
                inter_freq_open_pci_range.pci_start =
                (son_oam_cell_id_range_et)oam_atoi((Char8*)tag_value);

            /* SPR 12920 Fix Start */
            lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->Carrier[index],"X_VENDOR_OPEN_PHY_CELLID_RANGE"),PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);
            /* SPR 12920 Fix End */

            p_son_anr_meas_config_req->eutran_config_list[count1].
                inter_freq_open_pci_range.pci_range =
                (son_oam_cell_id_range_et)lclTemp_value;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_INTER_FREQ_OPEN_PCI_RANGE_PRESENT;
        }

        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                "X_VENDOR_CSG_PHY_CELLID_START");

        /*SPR 20772 Fix Start*/
        found = oam_strcmp((Char8*)tag_value, OAM_INVALID_STR);
        tag_value1 = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                "X_VENDOR_CSG_PHY_CELLID_RANGE");
        found1 = oam_strcmp((Char8*)tag_value1, OAM_INVALID_STR);
        /*SPR 20772 Fix End*/

        if(found && found1) {
            tag_value = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                    "X_VENDOR_CSG_PHY_CELLID_START");

            /* coverity 62104 */
            p_son_anr_meas_config_req->eutran_config_list[count1].
                inter_freq_closed_pci_range.pci_start =
                (son_oam_cell_id_range_et)oam_atoi((Char8*)tag_value);

            /* SPR 12920 Fix Start */
            lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->Carrier[index],"X_VENDOR_CSG_PHY_CELLID_RANGE"),PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);
            /* SPR 12920 Fix End */

            p_son_anr_meas_config_req->eutran_config_list[count1].
                inter_freq_closed_pci_range.pci_range =
                (son_oam_cell_id_range_et)lclTemp_value;

            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_INTER_FREQ_CLOSED_PCI_RANGE_PRESENT;
        }

        tag_value = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                "X_VENDOR_HYBRID_PHY_CELLID_START");

        /*SPR 20772 Fix Start*/
        found = oam_strcmp((Char8*)tag_value, OAM_INVALID_STR);
        tag_value1 = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                "X_VENDOR_HYBRID_PHY_CELLID_RANGE");
        found1 = oam_strcmp((Char8*)tag_value1, OAM_INVALID_STR);
        /*SPR 20772 Fix End*/

        if(found && found1) {
            tag_value = oam_xmlNodeGetContent(p_cell_spec_params->Carrier[index],
                    "X_VENDOR_HYBRID_PHY_CELLID_START");

            /* coverity 62104 */
            p_son_anr_meas_config_req->eutran_config_list[count1].
                inter_freq_hybrid_pci_range.pci_start =
                (son_oam_cell_id_range_et)oam_atoi((Char8*)tag_value);

            /* SPR 12920 Fix Start */
            lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->Carrier[index],"X_VENDOR_HYBRID_PHY_CELLID_RANGE"),PhyCellidRange, 
                    SON_OAM_PHY_CELLID_RANGE_COUNT);
            /* SPR 12920 Fix End */

            /* SPR 20430 Changes Start*/
            /*SPR 20772 Fix Start*/
            p_son_anr_meas_config_req->eutran_config_list[count1].
                inter_freq_hybrid_pci_range.pci_range =
                (son_oam_cell_id_range_et)lclTemp_value;
            /*SPR 20772 Fix End*/
            /* SPR 20430 Changes End*/
            p_son_anr_meas_config_req->eutran_config_list[count1].
                bitmask |= SON_MC_INTER_FREQ_HYBRID_PCI_RANGE_PRESENT;
        }

        /* SPR 9574 Fix End */
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/****************************************************************************
 *  FUNCTION NAME    : oam_populate_son_utra_tdd_list
 *  DESCRIPTION      : This function is used to populate SON parameters 
 *  		           for carrier frequency measurement
 *  PARAMETERS
 *      IN           : ponter to oam_rrm_cell_config_req_t
 *
 *      OUT          : pointer to oam_son_inter_freq_carrier_t
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_son_utra_tdd_list
(
 oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params,
 oam_rrm_cell_config_req_t *p_rrm_cell_config
 )
{
    UInt32   count = 0;
    UInt32   bitmask = 0;
    UInt8    index = 0;
    oam_return_et retVal = OAM_SUCCESS;
    oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
        &p_son_inter_freq_carr_params->oam_son_anr_meas_config_req;

    OAM_FUN_ENTRY_TRACE();

    count = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.
        irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers;

    p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
        utran_tdd_list_size = count;

    for(index = 0; index < count; ++index) {
        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_tdd_list[index].
            uarfcn = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            utra_carrier_arfcn;


        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_tdd_list[index].
            q_rx_lev_min = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            q_rx_lev_min;

			OAM_LOG(OAM, OAM_INFO,
                "q_rx_lev_min = %d and index = %d",p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_tdd_list[index].q_rx_lev_min, index);
        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_tdd_list[index].bitmask |= SON_MC_UTRAN_TDD_Q_RX_LEV_MIN_PRESENT;

        bitmask = p_rrm_cell_config->ran_info.mobility_params.
            idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            bitmask;
        if(bitmask & RRM_OAM_IRAT_CELL_RESELECTION_PRIORITY_PRESENT) {
            p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_tdd_list[index].
                cell_reselection_priority = p_rrm_cell_config->ran_info.
                mobility_params.
                idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_utra_params.
                irat_eutran_to_utran_tdd_list.
                irat_eutran_to_utran_tdd_carriers[index].
                cell_reselection_priority;

            p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
                utran_tdd_list[index].
                bitmask |= SON_MC_UTRAN_TDD_CELL_RESELECTION_PRIORITY_PRESENT;
        }


        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_tdd_list[index].threshX_high = p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            threshold_x_high;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_tdd_list[index].
            bitmask |= SON_MC_UTRAN_TDD_THRESH_HIGH_PRESENT;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_tdd_list[index].threshX_low = p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            threshold_x_low;

        p_son_anr_meas_config_req->other_rat_config_list.
            utran_config_list.utran_tdd_list[index].
            bitmask |= SON_MC_UTRAN_TDD_THRESH_LOW_PRESENT;


        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_tdd_list[index].p_max = p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_mobility_inter_rat_utra_params.
            irat_eutran_to_utran_tdd_list.
            irat_eutran_to_utran_tdd_carriers[index].
            p_max_utra;

        p_son_anr_meas_config_req->other_rat_config_list.utran_config_list.
            utran_tdd_list[index].bitmask |= SON_MC_UTRAN_TDD_P_MAX_PRESENT;
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/****************************************************************************
 *  FUNCTION NAME    : oam_populate_son_anr_meas_params
 *  DESCRIPTION      : This function is used to populate SON parameters 
 *  		           for carrier frequency measurement
 *  PARAMETERS
 *      IN           : 1. pointer to XML_struct_cell_config for cell specific
 *                     TR-196 params
 *                     2. ponter to oam_rrm_cell_config_req_t
 *
 *      OUT          : pointer to oam_son_inter_freq_carrier_t
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_son_anr_meas_params
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params,
 oam_rrm_cell_config_req_t *p_rrm_cell_config
 )
{
    oam_return_et retVal = OAM_SUCCESS;
    UInt32 bitmask = OAM_ZERO;


    bitmask = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.bitmask;

    if (bitmask & RRM_OAM_IDLE_MODE_MOBILITY_INTER_FREQ_PRESENT) {
        retVal = oam_populate_son_eutran_config_list(p_cell_spec_params,
                p_son_inter_freq_carr_params,
                p_rrm_cell_config);
        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
                    "Population of InterFreq EUTRAN carrier params failed");
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Population of InterFreq EUTRAN carrier params successful");
        }
    }


    bitmask = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.bitmask;

    if (bitmask & RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT) {
        retVal = oam_populate_son_utran_config_list(p_cell_spec_params,
                p_son_inter_freq_carr_params,
                p_rrm_cell_config);
        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
                    "Population of UTRAN carrier params failed");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Population of UTRAN carrier params successful");
        }
    }

    bitmask = p_rrm_cell_config->ran_info.mobility_params.
        idle_mode_mobility_params.bitmask;

    if (bitmask & RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT) {
        retVal = oam_populate_son_geran_config_list(p_cell_spec_params,
                p_son_inter_freq_carr_params,
                p_rrm_cell_config);

        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
                    "Population of GERAN carrier params failed");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Population of GERAN carrier params successful");
        }
    }


    OAM_FUN_EXIT_TRACE();
    return retVal;
}
#endif


/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_ca_params
 *  DESCRIPTION      : This function is used to populate the CA parameters
 *                                         
 *  PARAMETERS
 *      IN           : pointers to oam_rrm_cell_config_req_t,XML_struct_cell_config
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

    oam_return_et
oam_populate_ca_params(oam_rrm_cell_config_req_t  *p_cellconfig,
        XML_struct_cell_config     *p_cell_spec_params)
{
    OAM_FUN_ENTRY_TRACE();
    Char8 *tag_value = OAM_NULL;
    UInt64 bitrate = 0;

    if(p_cellconfig->operator_info.ca_config.bitmask &
            RRM_OAM_IS_CA_ELIGIBLE_INFO_PRESENT) {
        tag_value =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->ca_params,
                    "minNumUEThruputReport");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi(tag_value);
            p_cellconfig->operator_info.ca_config.
                num_of_report = lclTemp_value;
            p_cellconfig->operator_info.
                ca_config.bitmask |= RRM_OAM_NUM_OF_REPORT_PRESENT;
        }

        tag_value =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->ca_params,
                    "applicableBitrateDL");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            bitrate = oam_strtoull(tag_value, OAM_NULL, 0);
            p_cellconfig->operator_info.ca_config.
                ca_applicable_bitrate_dl = bitrate;
            p_cellconfig->operator_info.ca_config.
                bitmask |= RRM_OAM_CA_APPLICABLE_BITRATE_DL_PRESENT;
        }

        tag_value =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->ca_params,
                    "isMASA");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi(tag_value);
            p_cellconfig->operator_info.ca_config.is_masa = lclTemp_value;
            p_cellconfig->operator_info.ca_config.
                bitmask |= RRM_OAM_IS_MASA_INFO_PRESENT;
        }

        tag_value =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->ca_params,
                    "ScellDeactTimer");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            lclTemp_value =
                oam_xml_search_string_to_integer(tag_value,
                        scell_deact_timer_map,
                        OAM_SCELL_DEACT_TIMER_MAP_MAX_LEN);
            p_cellconfig->operator_info.ca_config.scell_deactivation_timer =
                (rrm_oam_scell_deactivation_timer_et)lclTemp_value;
            p_cellconfig->operator_info.ca_config.
                bitmask |= RRM_OAM_SCELL_DEACTIVATION_TIMER_PRESENT;
        }

        tag_value =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->ca_params,
                    "MeasCycleScell");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            lclTemp_value =
                oam_xml_search_string_to_integer(tag_value,
                        meas_cycle_scell_enum_tbl,
                        OAM_MEAS_CYCLE_SCELL_LEN);
            p_cellconfig->operator_info.ca_config.meas_cycle_scell =
                (rrm_meas_cycle_scell_et)lclTemp_value;
            p_cellconfig->operator_info.ca_config.
                bitmask |= RRM_OAM_MEAS_CYCLE_SCELL_PRESENT;
        }
        if(p_cellconfig->operator_info.ca_config.bitmask &
                RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT) {
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "loadCalcWindowSize");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.load_calcualtion_window_size =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "loadDisparityThresh");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.load_disparity_threshold =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_LOAD_DISPARITY_THRESHOLD_PRESENT;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "MCSDiffThresh");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.mcs_diff_threshold =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_MCS_DIFF_THRESHOLD_PRESENT;
            }
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "PRBUsageWatermark");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.prb_usage_water_mark =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_PRB_USAGE_WATER_MARK_PRESENT;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "DLDeactCMDThresh");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.dl_deact_command_thresh =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_DL_DEACT_COMMAND_THRESH_PRESENT;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "DLDeactMCSLowThresh");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.dl_deact_mcs_low_thresh =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_DL_DEACT_MCS_LOW_THRESH_PRESENT;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "DLQLoadUPThresh");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.dl_qload_up_threshold =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_DL_Q_LOAD_UP_THRESH_PRESENT;
            }
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "DLQLoadLowThresh");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.dl_qload_low_threshold =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_DL_Q_LOAD_LOW_THRESH_PRESENT;
            }

            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "ActDeactTriggerCountThresh");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.act_deact_trigger_count_threshold =
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT;
            }
            /* SPR 16422 START */
            tag_value = (Char8*)oam_xmlNodeGetContent(
                    p_cell_spec_params->ca_mac_sched_params,
                    "cqiValidityTimer");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.cqi_validity_timer=
                    lclTemp_value;
                p_cellconfig->operator_info.ca_config.
                    ca_mac_scheduler_params.
                    bitmask |= RRM_OAM_CQI_VALIDITY_TIMER_PRESENT;
            }
            /* SPR 16422 END */

        }
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_layer_specific_params
 *  DESCRIPTION      : This function is used to populate the layer specific parameters
 *                     of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, oam_rrm_cell_config_req_t
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

oam_return_et
oam_populate_l2_layer_specific_params
(
 XML_struct_cell_config     *p_cell_spec_params,
 prop_cellconfig_xml_st     *p_prop_cellconfig,
 oam_l2_req_t               *p_l2_req,
 oam_rrm_cell_config_req_t *p_rrm_cellconfig,
 /*SPR 21321 Start*/
 UInt8				cell_cnt,
 UInt8 				l2_instance
 /*SPR 21321 End*/
 )
{
    xmlChar *tag_value = OAM_NULL;
    UInt8 tm_cnt = 0;
    oam_bool_et  is_cell_ca_enable = OAM_TRUE;
    UInt8   cell_num = OAM_ZERO;
    UInt8   rrm_cell_id = OAM_ZERO;
    UInt8   l2_cell_id = OAM_ZERO;
    /*SPR 21321 +-*/
	oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_pdcp_init_layer_req_t *p_pdcp_init =
        &p_l2_req->oam_pdcp_req.pdcp_init_req;

    oam_rlc_init_layer_req_t *p_rlc_init =
        &p_l2_req->oam_rlc_req.rlc_init_req;


    tag_value = oam_xmlNodeGetContent(xml_struct_g.L2params, "logLevelMAC");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        p_mac_init->logLevel = oam_atoi((Char8*)tag_value);
    }

    tag_value = oam_xmlNodeGetContent(xml_struct_g.L2params, "logLevelRLC");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        p_rlc_init->logLevel = oam_atoi((Char8*)tag_value);
    }

    tag_value = oam_xmlNodeGetContent(xml_struct_g.L2params, "logLevelPDCP");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        p_pdcp_init->logLevel = oam_atoi((Char8*)tag_value);
    }

    tag_value = oam_xmlNodeGetContent(xml_struct_g.MACParams,
            "ulConfigAdvanceSubFrame");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(lclTemp_value >= MIN_ULCONFIGADVANCESUBFRAME &&
                lclTemp_value <= MAX_ULCONFIGADVANCESUBFRAME) {
            p_mac_init->ulConfigAdvanceSubFrame = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Value of ulConfigAdvanceSubFrame is "
					"%d and range is from %d to %d",
                    lclTemp_value,
                    MIN_ULCONFIGADVANCESUBFRAME,
                    MAX_ULCONFIGADVANCESUBFRAME);
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read ulConfigAdvanceSubFrame");
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->scheduler_Params,
            "siSchedulingRATPolicy");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(lclTemp_value >= MIN_SISCHEDULINGRATPOLICY &&
                lclTemp_value <= MAX_SISCHEDULINGRATPOLICY) {
            p_mac_init->siSchedulingRATPolicy = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Value of siSchedulingRATPolicy is "
					"%d and range is from %d to %d",
                    lclTemp_value,
                    MIN_SISCHEDULINGRATPOLICY,
                    MAX_SISCHEDULINGRATPOLICY);
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read siSchedulingRATPolicy");
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(xml_struct_g.MACParams,
            "avgNumAmLcPerUE");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(lclTemp_value >= MIN_AVGNUMAMLCPERUE &&
                lclTemp_value <= MAX_AVGNUMAMLCPERUE) {
            p_mac_init->avgNumAmLcPerUE = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Value of avgNumAmLcPerUE is "
					"%d and range is from %d to %d",
                    lclTemp_value,
                    MIN_AVGNUMAMLCPERUE,
                    MAX_AVGNUMAMLCPERUE);
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read avgNumAmLcPerUE");
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(xml_struct_g.MACParams,
            "avgNumUmLcPerUE");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(lclTemp_value >= MIN_AVGNUMUMLCPERUE &&
                lclTemp_value <= MAX_AVGNUMUMLCPERUE) {
            p_mac_init->avgNumUmLcPerUE = lclTemp_value;
        }
        else {
			OAM_LOG(OAM, OAM_WARNING, "Value of avgNumUmLcPerUE is "
					"%d and range is from %d to %d",
                    lclTemp_value,
                    MAX_AVGNUMUMLCPERUE,
                    MIN_AVGNUMUMLCPERUE);
            return OAM_FAILURE;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read avgNumUmLcPerUE");
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(xml_struct_g.health_monitoring,
            "healthMonitoringTimeInterval");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);
        p_mac_init->healthMonitoringTimeInterval = lclTemp_value;
        p_pdcp_init->healthMonitoringTimeInterval = lclTemp_value;
        p_rlc_init->healthMonitoringTimeInterval = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Failed to read healthMonitoringTimeInterval");
        return OAM_FAILURE;
    }

    /* 4x4 MIMO SUPPORT ADD Start */
    tag_value = oam_xmlNodeGetContent(
            p_cell_spec_params->X_VENDOR_ICIC_PARAMS,
            "CQIThresholdLayer4");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_mac_init->CQIThresholdLayer4 = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read CQIThresholdLayer4");
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_cell_spec_params->X_VENDOR_ICIC_PARAMS,
            "CQIThresholdCellEdgeLayer4");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_mac_init->CQIThresholdCellEdgeLayer4 = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read CQIThresholdCellEdgeLayer4");
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_cell_spec_params->X_VENDOR_ICIC_PARAMS,
            "CQIThresholdLayer3");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_mac_init->CQIThresholdLayer3 = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read CQIThresholdLayer3");
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_cell_spec_params->X_VENDOR_ICIC_PARAMS,
            "CQIThresholdCellEdgeLayer3");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
        lclTemp_value = oam_atoi((Char8*)tag_value);

        p_mac_init->CQIThresholdCellEdgeLayer3 = lclTemp_value;
    }
    else {
		OAM_LOG(OAM, OAM_WARNING, "Failed to read CQIThresholdCellEdgeLayer3");
        return OAM_FAILURE;
    }
    /*4x4 MIMO SUPPORT ADD End*/

    oam_populate_l2_qos_params(p_l2_req, p_rrm_cellconfig);

    tag_value = oam_xmlNodeGetContent(xml_struct_g.RLC_Q_Management,
            "queueSizeFactorGBR");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_QUEUESIZEFACTORGBR &&
            lclTemp_value <= MAX_QUEUESIZEFACTORGBR) {
        p_rlc_init->qSizeFactorGBR = lclTemp_value; 
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of queueSizeFactorGBR is %d and range is from %d to %d",
                lclTemp_value, MIN_QUEUESIZEFACTORGBR, MAX_QUEUESIZEFACTORGBR);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(xml_struct_g.RLC_Q_Management,
            "queueSizeFactorNGBR");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_QUEUESIZEFACTORNGBR &&
            lclTemp_value <= MAX_QUEUESIZEFACTORNGBR) {
        p_rlc_init->qSizeFactorNGBR = lclTemp_value; 
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of queueSizeFactorNGBR is %d and range is from %d to %d",
                lclTemp_value, MIN_QUEUESIZEFACTORNGBR, MAX_QUEUESIZEFACTORNGBR);

        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->preferredPrimaryDCIFormatForSingleTB,
            "TM1");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    p_mac_init->preferredPrimaryDCIFormatForSingleTB[tm_cnt++] =
        lclTemp_value;

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->preferredPrimaryDCIFormatForSingleTB,
            "TM2");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    p_mac_init->preferredPrimaryDCIFormatForSingleTB[tm_cnt++] =
        lclTemp_value;

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->preferredPrimaryDCIFormatForSingleTB,
            "TM3");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    p_mac_init->preferredPrimaryDCIFormatForSingleTB[tm_cnt++] =
        lclTemp_value;

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->preferredPrimaryDCIFormatForSingleTB,
            "TM4");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    p_mac_init->preferredPrimaryDCIFormatForSingleTB[tm_cnt++] =
        lclTemp_value;

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->preferredPrimaryDCIFormatForSingleTB,
            "TM5");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    p_mac_init->preferredPrimaryDCIFormatForSingleTB[tm_cnt++] =
        lclTemp_value;

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->preferredPrimaryDCIFormatForSingleTB,
            "TM6");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    p_mac_init->preferredPrimaryDCIFormatForSingleTB[tm_cnt++] =
        lclTemp_value;

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->preferredPrimaryDCIFormatForSingleTB,
            "TM7");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    p_mac_init->preferredPrimaryDCIFormatForSingleTB[tm_cnt++] =
        lclTemp_value;

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->preferredPrimaryDCIFormatForSingleTB,
            "TM8");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    p_mac_init->preferredPrimaryDCIFormatForSingleTB[tm_cnt++] =
        lclTemp_value;
    /*SPR 21321 Start*/
    if(oam_prov_req.l2_setup_info.instance_info[l2_instance].l2_cell_info.
            num_cells != OAM_SINGLE_CELL_SETUP) {
        for(cell_num = 0;
                cell_num < L2_INSTANCE_INFO(l2_instance).num_cells;
                ++cell_num) {
            /*SPR 21321 +-*/
            rrm_cell_id = oam_extract_cid_from_eutran_cellidentity(
                    /*SPR 21321 Start*/
                    OWN_CELL_CGI(cell_cnt).
                    /*SPR 21321 End*/
                    cell_identity);
            l2_cell_id = 
                L2_INSTANCE_CELL_INFO(l2_instance, cell_num).cell_idx;
            if(rrm_cell_id == l2_cell_id) {
                is_cell_ca_enable &=
                    /*SPR 21321 Start*/
                    RRM_CELL_CONFIG(cell_cnt).
                    /*SPR 21321 End*/
                    operator_info.ca_config.is_ca_eligible;
            }
            /*SPR 21321 +-*/
        }

        L2_MAC_INIT_LAYER_REQ(l2_instance).
            isCASupported = is_cell_ca_enable;
        L2_MAC_INIT_LAYER_REQ(l2_instance).
            fieldBitMask |= IS_CA_SUPPORTED_RECEIVED;

        L2_MAC_INIT_LAYER_REQ(l2_instance).
            fieldBitMask |= NUM_OF_CELLS_RECEIVED;
    }
    /*SPR 21321 End*/
    
    /* Spr 23393 Changes Start */  
    /* SES-527 Changes Start */  
    tag_value = oam_xmlNodeGetContent(xml_struct_g.MACParams,
            "maxRarPduPerTTI");
    if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) 
    {
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(lclTemp_value >0 && lclTemp_value <= 4)
        {
            p_mac_init->maxRarPduPerTTI = lclTemp_value; 
            OAM_LOG(OAM, OAM_INFO, "Value of maxRarPduPerTTI = %d ",p_mac_init->maxRarPduPerTTI);
        }
        else 
        {
            OAM_LOG(OAM, OAM_INFO, "Invalid Value of maxRarPduPerTTI = %d ",lclTemp_value);
            return OAM_FAILURE;
        }
    }
    else
    {
        p_mac_init->maxRarPduPerTTI = 4;
        OAM_LOG(OAM, OAM_ERROR, "Failed to read maxRarPduPerTTI Taking Default Value 4");
    }
    /* Spr 23393 Changes End */  
    /* SES-527  Changes End */  
   

    return OAM_SUCCESS;
}

/* SPR 20653 Fix Start */
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_olpc_config_params
 *  DESCRIPTION      : This function is used to populate the olpc config params
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config, oam_rrm_cell_config_req_t
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
oam_return_et
    oam_populate_olpc_config_params
(
 XML_struct_cell_config *p_cell_spec_params,
 oam_rrm_cell_config_req_t *p_rrm_cellconfig
 )
{
    OAM_FUN_ENTRY_TRACE();
    UInt8      count= OAM_ZERO;
    for(count = OAM_ZERO ; (count < RRM_OLPC_CATEGORY_TABLE_SIZE); count++)
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->olpc_tupple_pusch[count],"is_pathloss_high"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pusch_config_params.
            olpc_pusch_supported_table[count].rrm_olpc_tupple.is_pathloss_high = (rrm_bool_t)lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->olpc_tupple_pusch[count],"is_sinr_high"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pusch_config_params.
            olpc_pusch_supported_table[count].rrm_olpc_tupple.is_sinr_high = (rrm_bool_t)lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->olpc_tupple_pusch[count],"action"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pusch_config_params.
            olpc_pusch_supported_table[count].rrm_olpc_tupple.action = (rrm_olpc_action_et)lclTemp_value;

    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_pusch_snr_threshold_for_cell_center_ue"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_pusch_snr_threshold_for_cell_center_ue"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pusch_config_params.olpc_pusch_snr_threshold_for_cell_center_ue = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of olpc_pusch_snr_threshold_for_cell_center_ue not found");
        return OAM_FAILURE;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_pusch_snr_threshold_for_cell_edge_ue"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_pusch_snr_threshold_for_cell_edge_ue"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pusch_config_params.olpc_pusch_snr_threshold_for_cell_edge_ue = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of olpc_pusch_snr_threshold_for_cell_edge_ue not found");
        return OAM_FAILURE;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_p0_ue_pusch_range_start"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_p0_ue_pusch_range_start"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pusch_config_params.olpc_p0_ue_pusch_range_start = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of olpc_p0_ue_pusch_range_start not found");
        return OAM_FAILURE;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_p0_ue_pusch_range_end"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_p0_ue_pusch_range_end"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pusch_config_params.olpc_p0_ue_pusch_range_end = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of olpc_p0_ue_pusch_range_end not found");
        return OAM_FAILURE;
    }
    for(count = OAM_ZERO ; (count < RRM_OLPC_CATEGORY_TABLE_SIZE); count++)
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->olpc_tupple_pucch[count],"is_pathloss_high"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pucch_config_params.
            olpc_pucch_supported_table[count].rrm_olpc_tupple.is_pathloss_high = (rrm_bool_t)lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->olpc_tupple_pucch[count],"is_sinr_high"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pucch_config_params.
            olpc_pucch_supported_table[count].rrm_olpc_tupple.is_sinr_high = (rrm_bool_t)lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->olpc_tupple_pucch[count],"action"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pucch_config_params.
            olpc_pucch_supported_table[count].rrm_olpc_tupple.action = (rrm_olpc_action_et)lclTemp_value;

    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_pucch_snr_threshold"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_pucch_snr_threshold"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pucch_config_params.olpc_pucch_snr_threshold = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of olpc_pucch_snr_threshold not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_p0_ue_pucch_range_start"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_p0_ue_pucch_range_start"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pucch_config_params.olpc_p0_ue_pucch_range_start = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of olpc_p0_ue_pucch_range_start not found");
        return OAM_FAILURE;
    }
    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_p0_ue_pucch_range_end"),OAM_INVALID_STR)!= OAM_ZERO))
    {

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"olpc_p0_ue_pucch_range_end"));

        p_rrm_cellconfig->ran_info.olpc_config_params.rrm_olpc_pucch_config_params.olpc_p0_ue_pucch_range_end = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of olpc_p0_ue_pucch_range_end not found");
        return OAM_FAILURE;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"ULPathlossThreshold"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        p_rrm_cellconfig->ran_info.olpc_config_params.bitmask |= RRM_OAM_UL_PATHLOSS_THRESHOLD_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"ULPathlossThreshold"));

        p_rrm_cellconfig->ran_info.olpc_config_params.ul_pathloss_threshold = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of ULPathlossThreshold not found");
        return OAM_FAILURE;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"UeHandoverCountThreshold"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        p_rrm_cellconfig->ran_info.olpc_config_params.bitmask |= RRM_OAM_UE_HO_COUNT_THRESHOLD_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"UeHandoverCountThreshold"));

        p_rrm_cellconfig->ran_info.olpc_config_params.ue_handover_count_threshold = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of UeHandoverCountThreshold not found");
        return OAM_FAILURE;
    }

    if((oam_strcmp
                ((const char *)oam_xmlNodeGetContent(p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"MinUePower"),OAM_INVALID_STR)!= OAM_ZERO))
    {
        p_rrm_cellconfig->ran_info.olpc_config_params.bitmask |= RRM_OAM_MIN_UE_POWER_PRESENT;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->X_VENDOR_OLPC_CONFIG_PARAMS,"MinUePower"));

        p_rrm_cellconfig->ran_info.olpc_config_params.min_ue_power = lclTemp_value;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of MinUePower not found");
        return OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/* SPR 20653 Fix End */
/* LAA Rel13 Code + */ 
/* LAA Rel13 Code - */ 
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_cell_specific_params
 *  DESCRIPTION      : This function is used to populate the cell specific parameters
 *                     of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, oam_rrm_cell_config_req_t,cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

oam_return_et
oam_populate_l2_cell_specific_params
(
 XML_struct_cell_config     *p_cell_spec_params,
 prop_cellconfig_xml_st     *p_prop_cellconfig,
 oam_rrm_cell_config_req_t  *p_rrm_cellconfig,
 oam_l2_req_t               *p_l2_req,
 UInt8                      cell_cnt_index,
 /*SPR 21096 Start*/
 UInt8 			    l2_instance
 /*SPR 21096 End*/
 )
{
	oam_return_et retVal = OAM_SUCCESS;
	/* SPR 22248 MBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
	Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
#endif
	/* SPR 22248 MBMS Changes Stop */

	xmlChar *tag_value = OAM_NULL;
	oam_mac_init_req_params_t *p_mac_init =
		&p_l2_req->oam_mac_req.mac_init_req;
	oam_rlc_init_layer_req_t *p_rlc_init_req =
		&p_l2_req->oam_rlc_req.rlc_init_req;
	oam_pdcp_init_layer_req_t *p_pdcp_init_req =
		&p_l2_req->oam_pdcp_req.pdcp_init_req;
	oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;
	oam_rlc_s_cell_info_t *p_rlc_s_cell_info = OAM_NULL;
	oam_pdcp_s_cell_info_t *p_pdcp_s_cell_info = OAM_NULL;
    /*SPR 21096 Start*/
	static oam_l2_instance_flag_t oam_l2_instance_flag[OAM_MAX_NUM_L2_INSTANCE];
    /*SPR 21096 End*/
    /*SPR 21321 Start*/
	U8 cid = cell_cnt_index;
    /*SPR 21321 End*/
    /*SPR 21096 Start*/
	if(oam_l2_instance_flag[l2_instance].instance_id_flag == OAM_ZERO)
	{
		oam_l2_instance_flag[l2_instance].instance_id_flag = OAM_ONE;	
		cell_cnt_index = OAM_ZERO;
	}
	else
	{	
		oam_l2_instance_flag[l2_instance].init_cell_cnt++;
		cell_cnt_index = oam_l2_instance_flag[l2_instance].init_cell_cnt;
	}
    /*SPR 21096 End*/
	if(cell_cnt_index) {
		p_mac_cell_init = &p_l2_req->oam_mac_req.
			mac_init_cell_req[cell_cnt_index - 1];
		p_rlc_s_cell_info = &p_l2_req->oam_rlc_req.rlc_init_req.
			sCellInfo[cell_cnt_index - 1];
		p_rlc_s_cell_info->cellId =
        /*SPR 21321 Start*/
			oam_prov_req.cell_cntxt.cell_ctxt_status[cid].cid;
        /*SPR 21321 End*/
		p_pdcp_s_cell_info = &p_l2_req->oam_pdcp_req.pdcp_init_req.
			sCellInfo[cell_cnt_index - 1];
		p_pdcp_s_cell_info->cellId = 
        /*SPR 21321 Start*/ 
			oam_prov_req.cell_cntxt.cell_ctxt_status[cid].cid;
        /*SPR 21321 End*/
	}
	tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->dimension_params,
			"Max_no_of_ue");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	OAM_LOG(OAM, OAM_DETAILED, "Value of L2 MaxSupportedUEs is %d",
			lclTemp_value);
	if(!cell_cnt_index) {
		p_mac_init->numOfUE = lclTemp_value;
		p_rlc_init_req->numOfUEs = lclTemp_value;
		p_pdcp_init_req->maxUeNumber = lclTemp_value;
	}
	else {
		p_mac_cell_init->numOfUE = lclTemp_value;
		p_rlc_s_cell_info->numOfUEs = lclTemp_value;
		p_pdcp_s_cell_info->maxUeNumber = lclTemp_value;
	}
	tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->RNTI,
			"rntiStartRange");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(!cell_cnt_index) {
		p_mac_init->rntiStartRange = lclTemp_value;
		p_rlc_init_req->rntiStartRange = lclTemp_value;
		p_pdcp_init_req->rntiStartRange = lclTemp_value;
	}
	else {
		p_mac_cell_init->rntiStartRange = lclTemp_value;
	}
	tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->RNTI,
			"rntiEndRange");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(!cell_cnt_index) {
		p_mac_init->rntiEndRange = lclTemp_value;
		p_rlc_init_req->rntiEndRange = lclTemp_value;
		p_pdcp_init_req->rntiEndRange = lclTemp_value;
	}
	else {
		p_mac_cell_init->rntiEndRange = lclTemp_value;
	}
	tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->scheduler_Params,
			"maxMcs16QAM");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(!cell_cnt_index) {
		p_mac_init->maxMcs16QAM = lclTemp_value;
	}
	else {
		p_mac_cell_init->maxMcs16QAM = lclTemp_value;
	}
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->scheduler_Params,
			"ulSchedulerStrategy");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_UL_SCHEDULER_STRATEGY &&
			lclTemp_value <= MAX_UL_SCHEDULER_STRATEGY) {
		if(!cell_cnt_index) {
			p_mac_init->ulSchedulerStrategy = lclTemp_value;
		}
		else {
			p_mac_cell_init->ulSchedulerStrategy = lclTemp_value;
            /* Spr 12453 Fix Start*/
			p_mac_cell_init->fieldBitMask |= UL_SCHEDULAR_STRATEGY; 
            /* Spr 12453 Fix End*/
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of ulSchedulerStrategy is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_UL_SCHEDULER_STRATEGY,
				MAX_UL_SCHEDULER_STRATEGY);
		return OAM_FAILURE;
	}
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->scheduler_Params,
			"dlSchedulerStrategy");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_DL_SCHEDULER_STRATEGY &&
			lclTemp_value <= MAX_DL_SCHEDULER_STRATEGY) {
		if(!cell_cnt_index) {
			p_mac_init->dlSchedulerStrategy = lclTemp_value;
		}
		else {
			p_mac_cell_init->dlSchedulerStrategy = lclTemp_value;
            /* Spr 12453 Fix Start*/
			p_mac_cell_init->fieldBitMask |= DL_SCHEDULAR_STRATEGY; 
            /* Spr 12453 Fix End*/
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of dlSchedulerStrategy is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_DL_SCHEDULER_STRATEGY,
				MAX_DL_SCHEDULER_STRATEGY);
		return OAM_FAILURE;
	}
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->No_Of_UEs,
			"maxUEsToBeScheduledDL");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_MAX_UES_TO_BE_SCHEDULED_DL &&
			lclTemp_value <= MAX_MAX_UES_TO_BE_SCHEDULED_DL) {
		if(!cell_cnt_index) {
			p_mac_init->maxUEsToBeScheduledDL = lclTemp_value;
		}
		else {
			p_mac_cell_init->maxUEsToBeScheduledDL = lclTemp_value;
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of maxUEsToBeScheduledDL is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_MAX_UES_TO_BE_SCHEDULED_DL,
				MAX_MAX_UES_TO_BE_SCHEDULED_DL);
		return OAM_FAILURE;
	}
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->No_Of_UEs,
			"maxUEsToBeScheduledUL");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_MAX_UES_TO_BE_SCHEDULED_UL &&
			lclTemp_value <= MAX_MAX_UES_TO_BE_SCHEDULED_UL) {
		if(!cell_cnt_index) {
			p_mac_init->maxUEsToBeScheduledUL = lclTemp_value;
		}
		else {
			p_mac_cell_init->maxUEsToBeScheduledUL = lclTemp_value;
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of maxUEsToBeScheduledDL is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_MAX_UES_TO_BE_SCHEDULED_DL,
				MAX_MAX_UES_TO_BE_SCHEDULED_DL);
		return OAM_FAILURE;
	}
	tag_value = oam_xmlNodeGetContent(p_prop_cellconfig->scheduler_Params,
			"CQIThreshold");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_CQI_THRESHOLD &&
			lclTemp_value <= MAX_CQI_THRESHOLD) {
		if(!cell_cnt_index) {
			p_mac_init->CQIThreshold = lclTemp_value;
		}
		else {
			p_mac_cell_init->CQIThreshold = lclTemp_value;
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of CQIThreshold is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_CQI_THRESHOLD,
				MAX_CQI_THRESHOLD);
		return OAM_FAILURE;
	}
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->bucket_management_params,
			"dlRbRestrictionFactor");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_DL_RB_RESTRICTION_FACTOR &&
			lclTemp_value <= MAX_DL_RB_RESTRICTION_FACTOR) {
		if(!cell_cnt_index) {
			p_mac_init->dlRBRestrictionFactor = lclTemp_value;
		}
		else {
			p_mac_cell_init->dlRBRestrictionFactor = lclTemp_value;
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of dlRBRestrictionFactor is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_DL_RB_RESTRICTION_FACTOR,
				MAX_DL_RB_RESTRICTION_FACTOR);
		return OAM_FAILURE;
	}
    /* SPR 11953 FIX START */
	tag_value = oam_xmlNodeGetContent(xml_struct_g.MACParams,
			"commChWithMIBAllowed");
    /* SPR 11953 FIX END */
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_COMM_CH_WITH_MIB_ALLOWED &&
			lclTemp_value <= MAX_COMM_CH_WITH_MIB_ALLOWED) {
		if(!cell_cnt_index) {
			p_mac_init->commChWithMIBAllowed = lclTemp_value;
		}
		else {
			p_mac_cell_init->commChWithMIBAllowed = lclTemp_value;
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of commChWithMIBAllowed is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_COMM_CH_WITH_MIB_ALLOWED,
				MAX_COMM_CH_WITH_MIB_ALLOWED);
		return OAM_FAILURE;
	}
    /* SPR 11953 FIX START */
	tag_value = oam_xmlNodeGetContent(xml_struct_g.MACParams,
			"dlSchWithMIBAllowed");
    /* SPR 11953 FIX END */
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_DL_SCH_WITH_MIB_ALLOWED &&
			lclTemp_value <= MAX_DL_SCH_WITH_MIB_ALLOWED) {
		if(!cell_cnt_index) {
			p_mac_init->dlSchWithMIBAllowed = lclTemp_value;
		}
		else {
			p_mac_cell_init->dlSchWithMIBAllowed = lclTemp_value;
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of dlSchWithMIBAllowed is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_DL_SCH_WITH_MIB_ALLOWED,
				MAX_DL_SCH_WITH_MIB_ALLOWED);
		return OAM_FAILURE;
	}
#ifdef LTE_EMBMS_SUPPORTED
    tag_value = oam_get_xml_text_node_content(xml_struct_g.MACParams,
                                              "embmsMaxSyncPeriod", buf,
                                              OAM_TAG_VALUE_STR_MAX_LEN);
    if (tag_value)
    {
        lclTemp_value = oam_atoi(buf);

        if(lclTemp_value >= MIN_EMBMS_MAX_SYNC_PERIOD &&
           lclTemp_value <= MAX_EMBMS_MAX_SYNC_PERIOD) {
            p_mac_init->embmsMaxSyncPeriod = lclTemp_value;
        }
        else {
            OAM_LOG(OAM, OAM_ERROR,
                    "Value of embmsMaxSyncPeriod is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_EMBMS_MAX_SYNC_PERIOD,
                    MAX_EMBMS_MAX_SYNC_PERIOD);
            return OAM_FAILURE;
        }
    }
    else
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to read parameter embmsMaxSyncPeriod");
        return OAM_FAILURE;
    }

    tag_value = oam_get_xml_text_node_content(xml_struct_g.MACParams,
                                              "embmsSyncSeqDuration", buf,
                                              OAM_TAG_VALUE_STR_MAX_LEN);
    if (tag_value)
    {
        lclTemp_value = oam_atoi(buf);

        if(lclTemp_value >= MIN_SYNC_SEQ_DURATION &&
           lclTemp_value <= MAX_SYNC_SEQ_DURATION) {
            p_mac_init->embmsSyncSeqDuration = lclTemp_value;
        }
        else {
            OAM_LOG(OAM, OAM_ERROR, "Value of embmsSyncSeqDuration is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_SYNC_SEQ_DURATION,
                    MAX_SYNC_SEQ_DURATION);
            return OAM_FAILURE;
        }
    }
    else
    {
        OAM_LOG(OAM, OAM_ERROR,
                     "Failed to read parameter embmsSyncSeqDuration");
        return OAM_FAILURE;
    }

    tag_value = oam_get_xml_text_node_content(xml_struct_g.MACParams,
                                              "embmsSyncMarginTimer", buf,
                                              OAM_TAG_VALUE_STR_MAX_LEN);
    if (tag_value)
    {
        lclTemp_value = oam_atoi(buf);

        if(lclTemp_value >= MIN_SYNC_MARGIN_TIMER &&
           lclTemp_value <= MAX_SYNC_MARGIN_TIMER) {
            p_mac_init->embmsSyncMarginTimer = lclTemp_value;
        }
        else {
            OAM_LOG(OAM, OAM_ERROR, "Value of embmsSyncMarginTimer is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_SYNC_MARGIN_TIMER,
                    MAX_SYNC_MARGIN_TIMER);
            return OAM_FAILURE;
        }
    }
    else
    {
        OAM_LOG(OAM, OAM_ERROR,
                     "Failed to read parameter embmsSyncMarginTimer");
        return OAM_FAILURE;
    }
#endif
	/* SPR 21958 PUSCH RAT1 Support Start */
	if((oam_strcmp
		     ((const char *)oam_xmlNodeGetContent(xml_struct_g.MACParams,
					"uplinkRat1Supported"),OAM_INVALID_STR)!= OAM_ZERO))
	{
		lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
					xml_struct_g.MACParams,"uplinkRat1Supported"));

		if(lclTemp_value >= OAM_ZERO && lclTemp_value <= OAM_ONE) 
		{

            p_rrm_cellconfig->ran_info.
                mac_layer_params.is_uplink_rat_1_supported = lclTemp_value;
            p_rrm_cellconfig->ran_info.
                mac_layer_params.bitmask |= RRM_OAM_UPLINK_RAT1_SUPPORT_INFO_PRESENT;

            /* SPR 22548 Fix Start */
            /* According to Spec ref 36.212, In R10 resource allocation type field should be present
             * only when nULRBs <= nDLRBs . Since resource allocation type field can not be sent as zero
             * if Uplink Rat 1 is enabled at eNodeb. So in this case is_uplink_rat_1_supported is explicitly 
             * set as FALSE so that if the above condition is met , alloaction should not be done through RAT1*/
            if(ul_num_rbs[cid] > dl_num_rbs[cid])
            {
                p_rrm_cellconfig->ran_info.
                    mac_layer_params.is_uplink_rat_1_supported = OAM_FALSE;
                OAM_LOG(OAM, OAM_WARNING,
                        "Uplink RAT 1 support is explicitly disabled as nULRBs > nDLRBs");
            }
            /* SPR 22548 Fix End */
            else if(OAM_ONE == p_rrm_cellconfig->ran_info.mac_layer_params.is_uplink_rat_1_supported)
			{
                /* SPR 22549 Fix Start */
                if((OAM_ONE == tti_bundling_flag[cid]) || (OAM_ONE == icic_flag[cid])
                        || (OAM_ONE == fss_flag[cid]) || (OAM_ONE == sps_flag[cid]) 
                        || (OAM_ONE == ca_eligible_flag[cid]) || (OAM_ONE == duplex_mode_flag))
				{
                    OAM_LOG(OAM, OAM_WARNING,
							"Invalid combination with PUSCH RAT1::"
							"Any combination of PUSCH RAT1 feature support enabled along with"
                            " tti_bundling[%d] or icic[%d] or fss[%d] or sps[%d]"
                            " or isCaEligible[%d] or duplexing_mode[%d] is not supported for CELL_INDEX[%d]",
                            tti_bundling_flag[cid],icic_flag[cid],fss_flag[cid],
                            sps_flag[cid],ca_eligible_flag[cid],duplex_mode_flag,cid);
                    /* SPR 22549 Fix End */

                    p_rrm_cellconfig->ran_info.
                        mac_layer_params.is_uplink_rat_1_supported = OAM_FALSE;

                    OAM_LOG(OAM, OAM_WARNING,
                            "Uplink RAT 1 support is explicitly disabled due to above invalid combination");
                }
                else
            {
                    OAM_LOG(OAM, OAM_INFO,
                        "Value of is_uplink_rat_1_supported is  %u ",lclTemp_value);
            }
				}
            else
            {
                OAM_LOG(OAM, OAM_INFO,
                        "Uplink Rat1 support is configured as FALSE ");
			}	
		}
		else 
		{
			OAM_LOG(OAM, OAM_ERROR,
					"Value of is_uplink_rat_1_supported is  %u which is out of range",lclTemp_value);

			return OAM_FAILURE;
		}	
	}
    else
    {
        OAM_LOG(OAM, OAM_ERROR,
					"Tag uplinkRat1Supported is not found");
    }
        /* SPR 21958 PUSCH RAT1 Support End */

	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->bucket_management_params,
			"ulRbRestrictionFactor");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_ULRBRESTRICTIONFACTOR &&
			lclTemp_value <= MAX_ULRBRESTRICTIONFACTOR) {
		if(!cell_cnt_index) {
			p_mac_init->ulRBRestrictionFactor = lclTemp_value;
		}
		else {
			p_mac_cell_init->ulRBRestrictionFactor = lclTemp_value;
		}
	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Value of ulRbRestrictionFactor is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_ULRBRESTRICTIONFACTOR,
				MAX_ULRBRESTRICTIONFACTOR);
		return OAM_FAILURE;
	}
    /* SPR 12975 Changes Start */
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->bucket_management_params,
			"dlAmbrTokenLimitFactor");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_DL_AMBRTOKENLIMITFACTOR &&
			lclTemp_value <= MAX_DL_AMBRTOKENLIMITFACTOR) 
	{
		if(!cell_cnt_index) 
		{
			p_mac_init->dlAmbrTokenLimitFactor = lclTemp_value;
		}
		else 
		{
			p_mac_cell_init->dlAmbrTokenLimitFactor = lclTemp_value;
		}
	}
	else 
	{
		OAM_LOG(OAM, OAM_ERROR,
				"Value of dlAmbrTokenLimitFactor is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_DL_AMBRTOKENLIMITFACTOR,
				MAX_DL_AMBRTOKENLIMITFACTOR);
		return OAM_FAILURE;
	}
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->bucket_management_params,
			"ulAmbrTokenLimitFactor");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_UL_AMBRTOKENLIMITFACTOR &&
			lclTemp_value <= MAX_UL_AMBRTOKENLIMITFACTOR) 
	{
		if(!cell_cnt_index) 
		{
			p_mac_init->ulAmbrTokenLimitFactor = lclTemp_value;
		}
		else 
		{
			p_mac_cell_init->ulAmbrTokenLimitFactor = lclTemp_value;
		}
	}
	else 
	{
		OAM_LOG(OAM, OAM_ERROR,
				"Value of ulAmbrTokenLimitFactor is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_UL_AMBRTOKENLIMITFACTOR,
				MAX_UL_AMBRTOKENLIMITFACTOR);
		return OAM_FAILURE;
	}
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->bucket_management_params,
			"dlGbrTokenLimitFactor");
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_DL_GBRTOKENLIMITFACTOR &&
			lclTemp_value <= MAX_DL_GBRTOKENLIMITFACTOR) 
	{
		if(!cell_cnt_index) 
		{
			p_mac_init->dlGbrTokenLimitFactor = lclTemp_value;
		}
		else 
		{
			p_mac_cell_init->dlGbrTokenLimitFactor = lclTemp_value;
		}
	}
	else 
	{
		OAM_LOG(OAM, OAM_ERROR,
				"Value of dlGbrTokenLimitFactor is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_DL_GBRTOKENLIMITFACTOR,
				MAX_DL_GBRTOKENLIMITFACTOR);
		return OAM_FAILURE;
	}
    /* SPR 13871 Changes Start */
	tag_value = oam_xmlNodeGetContent(
			p_prop_cellconfig->bucket_management_params,
			"ulGbrTokenLimitFactor");
    /* SPR 13871 Changes End */
	lclTemp_value = oam_atoi((Char8*)tag_value);
	if(lclTemp_value >= MIN_UL_GBRTOKENLIMITFACTOR &&
			lclTemp_value <= MAX_UL_GBRTOKENLIMITFACTOR) 
	{
		if(!cell_cnt_index) 
		{
			p_mac_init->ulGbrTokenLimitFactor = lclTemp_value;
		}
		else 
		{
			p_mac_cell_init->ulGbrTokenLimitFactor = lclTemp_value;
		}
	}
	else 
	{
		OAM_LOG(OAM, OAM_ERROR,
				"Value of ulGbrTokenLimitFactor is %d and "
				"range is from %d to %d",
				lclTemp_value, MIN_UL_GBRTOKENLIMITFACTOR,
				MAX_UL_GBRTOKENLIMITFACTOR);
		return OAM_FAILURE;
	}
    /* SPR 12975 Changes End */
    tag_value = oam_xmlNodeGetContent(p_cell_spec_params->EPC,
			"X_VENDOR_COUNT_WRAP_AROUND_THRESHOLD_VALUE");

	if(oam_strcmp((Char8*)tag_value, OAM_INVALID_STR)) {
		p_pdcp_init_req->bitMask |= 0x01;

		lclTemp_value = oam_atoll((Char8*)tag_value);

			if(!cell_cnt_index) {	
				p_pdcp_init_req->thresholdValue = lclTemp_value;
			}else
			{
				p_pdcp_s_cell_info->bitMask |= 0x01;
				p_pdcp_s_cell_info->thresholdValue = lclTemp_value;
			}
	}
    retVal = oam_populate_l2_sps_syswide_params(p_cell_spec_params,
            p_prop_cellconfig,
            p_rrm_cellconfig,
            p_l2_req, cell_cnt_index);

    /* SPR 17777 fix */
    retVal = oam_populate_l2_sps_dl_interval_profile(
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);
    /* SPR 17777 fix */
    retVal = oam_populate_l2_sps_ul_interval_profile(
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);
    /* SPR 17777 fix */
    retVal = oam_populate_l2_sps_comm_interval_profile(
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);

    retVal = oam_populate_l2_dl_qos_params(p_cell_spec_params,
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);

    retVal = oam_populate_l2_ul_qos_params(p_cell_spec_params,
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);
    /* SPR 17777 */
    retVal = oam_populate_l2_ul_pfs_params(
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);
    /* SPR 17777 fix */
    retVal = oam_populate_l2_dl_pfs_params(
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);
    /* SPR 17777 fix */
    retVal = oam_populate_l2_icic_params(p_cell_spec_params,
            p_l2_req,
            cell_cnt_index);
    if(OAM_SUCCESS == retVal && cell_cnt_index) {
        ++p_l2_req->oam_rlc_req.rlc_init_req.sCellCount;
        ++p_l2_req->oam_pdcp_req.pdcp_init_req.sCellCount;
    }

    ++p_l2_req->oam_mac_req.mac_init_req.numCells;

    return retVal;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_sps_dl_interval_profile
 *  DESCRIPTION      : This function is used to populate the sps dl interval profile
 *                     parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t,cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* SPR 17777 fix */
oam_return_et
oam_populate_l2_sps_dl_interval_profile
(
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    UInt16 count = OAM_ZERO;
    xmlChar *tag_value = OAM_NULL;

    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_rlc_init_layer_req_t *p_rlc_init =
        &p_l2_req->oam_rlc_req.rlc_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;
    oam_rlc_s_cell_info_t *p_rlc_s_cell_info = OAM_NULL;

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];

        p_rlc_s_cell_info = &p_l2_req->oam_rlc_req.rlc_init_req.
            sCellInfo[cell_cnt_index - 1];
    }
    for(count = OAM_ZERO; count < SPS_INTERVAL_LIST; ++count) {
        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsDLIntervalProfile[count],
                "dlMinMcsSps");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(lclTemp_value >= MIN_UL_MIN_MCS_SPS &&
                lclTemp_value <= MAX_UL_MIN_MCS_SPS) {

            if(!cell_cnt_index) {
                p_mac_init->spsDLIntervalProfile[count].dlMinMcsSps =
                    lclTemp_value;
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsDLIntervalProfile[count].
                    dlMinMcsSps = lclTemp_value;
            }
        }else
        {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of ulMinMcsSps is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_UL_MIN_MCS_SPS,
                    MIN_UL_MIN_MCS_SPS);
            return OAM_FAILURE;
        }

        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsDLIntervalProfile[count],
                "dlMcsMargin");
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(lclTemp_value >= MIN_DL_MCS_MARGIN &&
                lclTemp_value <= MAX_DL_MCS_MARGIN) {

            if(!cell_cnt_index) {
                p_mac_init->spsDLIntervalProfile[count].dlMcsMargin =
                    lclTemp_value;
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsDLIntervalProfile[count].
                    dlMcsMargin = lclTemp_value;
            }
        }else
        {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of dlMcsMargin is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_DL_MCS_MARGIN,
                    MAX_DL_MCS_MARGIN);
            return OAM_FAILURE;
        }


        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsDLIntervalProfile[count],
                "dlTbsizeMarginSps");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(lclTemp_value >= MIN_DL_TB_SIZE_MARGIN_SPS &&
                lclTemp_value <= MAX_DL_TB_SIZE_MARGIN_SPS ) {

            if(!cell_cnt_index) {
                p_mac_init->spsDLIntervalProfile[count].dlTbsizeMarginSps =
                    lclTemp_value;
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsDLIntervalProfile[count].
                    dlTbsizeMarginSps = lclTemp_value;
            }
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of dlTbSizeMarginSps is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_DL_TB_SIZE_MARGIN_SPS,
                    MAX_DL_TB_SIZE_MARGIN_SPS);
            return OAM_FAILURE;
        }

        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsCommIntervalProfile[count],
                "enableSegConcatSpsRlcSdu");
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(!cell_cnt_index) {
            p_rlc_init->rlcSpsIntervalProfileParams[count].
                enableSegConcatSpsRlcSdu = lclTemp_value;
        }
        else {
            p_rlc_s_cell_info->rlcSpsIntervalProfileParams[count].
                enableSegConcatSpsRlcSdu = lclTemp_value;
        }

        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsDLIntervalProfile[count],
                "dlJitterHandlingOption");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(lclTemp_value >= MIN_DL_JITTER_HANDLING_OPTION &&
                lclTemp_value <= MAX_DL_JITTER_HANDLING_OPTION) {

            if(!cell_cnt_index) {
                p_mac_init->spsDLIntervalProfile[count].dlJitterHandlingOption =
                    (JitterHandlingOption)lclTemp_value;
                p_rlc_init->rlcSpsIntervalProfileParams[count].
                    dlJitterHandlingOption = (JitterHandlingOption)lclTemp_value;
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsDLIntervalProfile[count].
                    dlJitterHandlingOption =(JitterHandlingOption)lclTemp_value;
                p_rlc_s_cell_info->rlcSpsIntervalProfileParams[count].
                    dlJitterHandlingOption = lclTemp_value;
            }
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of dlJitterHandlingOption is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_DL_JITTER_HANDLING_OPTION,
                    MAX_DL_JITTER_HANDLING_OPTION);
            return OAM_FAILURE;
        }

        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsDLIntervalProfile[count],
                "rlcSduThresForDra");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(!cell_cnt_index) {
            p_mac_init->spsDLIntervalProfile[count].rlcSduThresForDra =
                lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitSPSParams.spsDLIntervalProfile[count].
                rlcSduThresForDra = lclTemp_value;
        }
    }

    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_sps_ul_interval_profile 
 *  DESCRIPTION      : This function is used to populate the sps ul interval profile                                                                                                   parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* SPR 17777 fix */
oam_return_et
    oam_populate_l2_sps_ul_interval_profile
(
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    UInt16 count = OAM_ZERO;
    xmlChar *tag_value = OAM_NULL;
    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];
    }
    for(count = OAM_ZERO; count < SPS_INTERVAL_LIST; ++count) {
        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsULIntervalProfile[count],
                "ulMinMcsSps");
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(lclTemp_value >= MIN_UL_MIN_MCS_SPS &&
                lclTemp_value <= MAX_UL_MIN_MCS_SPS) {

            if(!cell_cnt_index) {
                p_mac_init->spsULIntervalProfile[count].ulMinMcsSps =
                    lclTemp_value;
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsULIntervalProfile[count].
                    ulMinMcsSps = lclTemp_value;
            }
        }else
        {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of ulMinMcsSps is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_UL_MIN_MCS_SPS,
                    MIN_UL_MIN_MCS_SPS);
            return OAM_FAILURE;
        }

        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsULIntervalProfile[count],
                "ulMcsMargin");
        lclTemp_value = oam_atoi((Char8*)tag_value);
        if(lclTemp_value >= MIN_UL_MCS_MARGIN &&
                lclTemp_value <= MAX_UL_MCS_MARGIN) {

            if(!cell_cnt_index) {
                p_mac_init->spsULIntervalProfile[count].ulMcsMargin =
                    lclTemp_value;
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsULIntervalProfile[count].
                    ulMcsMargin = lclTemp_value;
            }
        }else
        {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of ulMcsMargin is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_UL_MCS_MARGIN,
                    MAX_UL_MCS_MARGIN);
            return OAM_FAILURE;
        }

        tag_value = oam_xmlNodeGetContent(
                p_prop_cellconfig->spsULIntervalProfile[count],
                "ulTbSizeMarginSps");
        lclTemp_value = oam_atoi((Char8*)tag_value);

        if(lclTemp_value >= MIN_UL_TB_SIZE_MARGIN_SPS &&
                lclTemp_value <= MAX_UL_TB_SIZE_MARGIN_SPS ) {

            if(!cell_cnt_index) {
                p_mac_init->spsULIntervalProfile[count].ulTbSizeMarginSps =
                    lclTemp_value;
            }
            else {
                p_mac_cell_init->macInitSPSParams.spsULIntervalProfile[count].
                    ulTbSizeMarginSps = lclTemp_value;
            }
        }
        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Value of ulTbSizeMarginSps is %d and "
                    "range is from %d to %d",
                    lclTemp_value, MIN_UL_TB_SIZE_MARGIN_SPS,
                    MAX_UL_TB_SIZE_MARGIN_SPS);
            return OAM_FAILURE;
        }
    }

    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_sps_comm_interval_profile 
 *  DESCRIPTION      : This function is used to populate the sps comm interval profile
 *                     parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* SPR 17777 fix */
oam_return_et
oam_populate_l2_sps_comm_interval_profile
(
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
	UInt16 count = OAM_ZERO;
	xmlChar *tag_value = OAM_NULL;
	xmlNode *node = OAM_NULL;
	UInt16 rohc_cnt = OAM_ZERO;
	oam_mac_init_req_params_t *p_mac_init =
		&p_l2_req->oam_mac_req.mac_init_req;
	oam_pdcp_init_layer_req_t *p_pdcp_init_req =
		&p_l2_req->oam_pdcp_req.pdcp_init_req;
	oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;
	oam_pdcp_s_cell_info_t *p_pdcp_s_cell_info = OAM_NULL;
	if(cell_cnt_index) {
		p_mac_cell_init = &p_l2_req->oam_mac_req.
			mac_init_cell_req[cell_cnt_index - 1];
		p_pdcp_s_cell_info = &p_l2_req->oam_pdcp_req.pdcp_init_req.
			sCellInfo[cell_cnt_index - 1];
	}
	for(count = OAM_ZERO; count < SPS_INTERVAL_LIST; ++count) {
		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"overrideSpsOccassionForOtherUe");
		lclTemp_value = oam_atoi((Char8*)tag_value);
		if(!cell_cnt_index) {
			p_mac_init->spsCommIntervalProfile[count].
				overrideSpsOccassionForOtherUe = lclTemp_value;
		}
		else {
			p_mac_cell_init->macInitSPSParams.spsCommIntervalProfile[count].
				overrideSpsOccassionForOtherUe = lclTemp_value;
		}
		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"strictSpsResourceUsageForSpsLc");
		lclTemp_value = oam_atoi((Char8*)tag_value);
		if(!cell_cnt_index) {
			p_mac_init->spsCommIntervalProfile[count].
				strictSpsResourceUsageForSpsLc = lclTemp_value;
		}
		else {
			p_mac_cell_init->macInitSPSParams.spsCommIntervalProfile[count].
				strictSpsResourceUsageForSpsLc = lclTemp_value;
		}
		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"enableSilenceDetection");
		lclTemp_value = oam_atoi((Char8*)tag_value);
		if(!cell_cnt_index) {
			p_mac_init->spsCommIntervalProfile[count].
				enableSilenceDetection = lclTemp_value;
			p_pdcp_init_req->spsProfileParams[count].enableSilenceDetection =
				lclTemp_value;
		}
		else {
			p_mac_cell_init->macInitSPSParams.spsCommIntervalProfile[count].
				enableSilenceDetection = lclTemp_value;
			p_pdcp_s_cell_info->spsProfileParams[count].
				enableSilenceDetection = lclTemp_value;
		}
		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"interPktDelayForSilenceDetection");
		lclTemp_value = oam_atoi((Char8*)tag_value);
		if(!cell_cnt_index) {
			p_mac_init->spsCommIntervalProfile[count].
				interPktDelayForSilenceDetection = lclTemp_value;
			p_pdcp_init_req->spsProfileParams[count].
				interPktDelayForSilenceDetection = lclTemp_value;
		}
		else {
			p_mac_cell_init->macInitSPSParams.spsCommIntervalProfile[count].
				interPktDelayForSilenceDetection = lclTemp_value;
			p_pdcp_s_cell_info->spsProfileParams[count].
				interPktDelayForSilenceDetection = lclTemp_value;
		}
		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"silencePdcpSduSizeIpv4");
		lclTemp_value = oam_atoi((Char8*)tag_value);
		if(!cell_cnt_index) {
			p_pdcp_init_req->spsProfileParams[count].
				silencePdcpSduSizeIpv4 = lclTemp_value;
		}
		else {
			p_pdcp_s_cell_info->spsProfileParams[count].
				silencePdcpSduSizeIpv4 = lclTemp_value;
		}
		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"silencePdcpSduSizeIpv6");
		lclTemp_value = oam_atoi((Char8*)tag_value);
		if(!cell_cnt_index) {
			p_pdcp_init_req->spsProfileParams[count].
				silencePdcpSduSizeIpv6 = lclTemp_value;
		}
		else {
			p_pdcp_s_cell_info->spsProfileParams[count].
				silencePdcpSduSizeIpv6 = lclTemp_value;
		}
		node = oam_xml_find_tag(
				p_prop_cellconfig->spsCommIntervalProfile[count]->children,
				(xmlChar*)"maxPdcpPduSizeIpv4");
		if(node) {
			node = node->children;
			for (rohc_cnt = OAM_ZERO;
					rohc_cnt < OAM_MAX_MAC_ROHC_PROFILE;
					++rohc_cnt) {
				tag_value = xmlNodeGetContent(node);
				if(tag_value) {
					lclTemp_value = oam_atoi((Char8*)tag_value);
					if(!cell_cnt_index) {
						p_mac_init->spsCommIntervalProfile[count].
							maxPdcpPduSizeIpv4[rohc_cnt] = lclTemp_value;
					}
					else {
						p_mac_cell_init->macInitSPSParams.
							spsCommIntervalProfile[count].
							maxPdcpPduSizeIpv4[rohc_cnt] = lclTemp_value;
					}
					xmlFree(tag_value);
				}
				node = node->next;
			}
		}
		node = oam_xml_find_tag(
				p_prop_cellconfig->spsCommIntervalProfile[count]->children,
				(xmlChar*)"maxPdcpPduSizeIpv6");
		if(node) {
			node = node->children;
			for (rohc_cnt = OAM_ZERO;
					rohc_cnt < OAM_MAX_MAC_ROHC_PROFILE;
					++rohc_cnt) {
				tag_value = xmlNodeGetContent(node);
				if(tag_value) {
					lclTemp_value = oam_atoi((Char8*)tag_value);
					if(!cell_cnt_index) {
						p_mac_init->spsCommIntervalProfile[count].
							maxPdcpPduSizeIpv6[rohc_cnt] = lclTemp_value;
					}
					else {
						p_mac_cell_init->macInitSPSParams.
							spsCommIntervalProfile[count].
							maxPdcpPduSizeIpv6[rohc_cnt] = lclTemp_value;
					}
					xmlFree(tag_value);
				}
				node = node->next;
			}
		}
		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"minRbSavedReactivationThres");
		lclTemp_value = oam_atoi((Char8*)tag_value);
		if(!cell_cnt_index) {
			p_mac_init->spsCommIntervalProfile[count].
				minRbSavedReactivationThres = lclTemp_value;
		}
		else {
			p_mac_cell_init->macInitSPSParams.spsCommIntervalProfile[count].
				minRbSavedReactivationThres = lclTemp_value;
		}
		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"spsBlerThres");
		lclTemp_value = oam_atoi((Char8*)tag_value);
		if(!cell_cnt_index) {
			p_mac_init->spsCommIntervalProfile[count].spsBlerThres =
				lclTemp_value;
		}
		else {
			p_mac_cell_init->macInitSPSParams.spsCommIntervalProfile[count].
				spsBlerThres = lclTemp_value;
		}
	tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"auditInterval");
		lclTemp_value = oam_atoi((Char8*)tag_value);

		if(!cell_cnt_index) {
			p_mac_init->spsCommIntervalProfile[count].auditInterval =
				lclTemp_value;
		}
		else {
			p_mac_cell_init->macInitSPSParams.spsCommIntervalProfile[count].
				auditInterval = lclTemp_value;
		}

		tag_value = oam_xmlNodeGetContent(
				p_prop_cellconfig->spsCommIntervalProfile[count],
				"spsResAllocTtiAdv");
		lclTemp_value = oam_atoi((Char8*)tag_value);

		if(!cell_cnt_index) {
			p_mac_init->spsCommIntervalProfile[count].spsResAllocTtiAdv =
				lclTemp_value;
		}
		else {
			p_mac_cell_init->macInitSPSParams.spsCommIntervalProfile[count].
				spsResAllocTtiAdv = lclTemp_value;
		}
	}

	return OAM_SUCCESS;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_ul_pfs_params 
 *  DESCRIPTION      : This function is used to populate the ul pfs 
 *                     parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* SPR 17777 fix */
oam_return_et
    oam_populate_l2_ul_pfs_params
(
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    xmlChar *tag_value = OAM_NULL;

    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "ulMsWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->ulMsWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitULPFSParams.ulMsWt = lclTemp_value;
        /* Spr 12453 Fix Start*/
        p_mac_cell_init->fieldBitMask |= UL_PFS_PARAMS; 
        /* Spr 12453 Fix End*/
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "ulMs64QAMFactorWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->ulMs64QAMFactorWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitULPFSParams.ulMs64QAMFactorWt =
            lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "ulMs16QAMFactorWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->ulMs16QAMFactorWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitULPFSParams.ulMs16QAMFactorWt =
            lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "ulMsQPSKFactorWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->ulMsQPSKFactorWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitULPFSParams.ulMsQPSKFactorWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "ulUePriorityWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->ulUePriorityWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitULPFSParams.ulUePriorityWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "ulUeDelayWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->ulUeDelayWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitULPFSParams.ulUeDelayWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "ulUeBsrLoadWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->ulUeBsrLoadWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitULPFSParams.ulUeBsrLoadWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "ulLcgPriorityWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->ulLcgPriorityWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitULPFSParams.ulLcgPriorityWt = lclTemp_value;
    }

    return OAM_SUCCESS;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_dl_pfs_params
 *  DESCRIPTION      : This function is used to populate the dl pfs
 *                     parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* SPR 17777 fix */
oam_return_et
    oam_populate_l2_dl_pfs_params
(
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    xmlChar *tag_value = OAM_NULL;

    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlUeQueueLoadWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlUeQueueLoadWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlUeQueueLoadWt = lclTemp_value;
        /* Spr 12453 Fix Start*/
        p_mac_cell_init->fieldBitMask |= DL_PFS_PARAMS; 
        /* Spr 12453 Fix End*/
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlLcQueueLoadWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlLcQueueLoadWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlLcQueueLoadWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlMsWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlMsWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlMsWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlMs64QAMFactorWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlMs64QAMFactorWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlMs64QAMFactorWt =
            lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlMs16QAMFactorWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlMs16QAMFactorWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlMs16QAMFactorWt =
            lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlMsQPSKFactorWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlMsQPSKFactorWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlMsQPSKFactorWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlUePriorityWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlUePriorityWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlUePriorityWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlLcPriorityWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlLcPriorityWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlLcPriorityWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlUeDelayWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlUeDelayWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlUeDelayWt = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "dlLcDelayWt");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->dlLcDelayWt = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitDLPFSParams.dlLcDelayWt = lclTemp_value;
    }

    return OAM_SUCCESS;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_dl_qos_params
 *  DESCRIPTION      : This function is used to populate the dl qos
 *                     parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

oam_return_et
    oam_populate_l2_dl_qos_params
(
 XML_struct_cell_config    *p_cell_spec_params,
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    xmlChar *tag_value = OAM_NULL;
    oam_return_et retVal = OAM_SUCCESS;

    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %p", p_cell_spec_params);

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->bucket_management_params,
            "gbrBucketFactor");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_GBR_BUCKET_FACTOR &&
            lclTemp_value <= MAX_GBR_BUCKET_FACTOR) {
        if(!cell_cnt_index) {
            p_mac_init->gbrBktDepthFactor = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.gbrBktDepthFactor =
                lclTemp_value;
            /* Spr 12453 Fix Start*/
            p_mac_cell_init->fieldBitMask |= DL_QOS_PARAMS; 
            /* Spr 12453 Fix End*/
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of gbrBucketFactor is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_GBR_BUCKET_FACTOR,
                MAX_GBR_BUCKET_FACTOR);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->bucket_management_params,
            "ambrBucketFactor");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_AMBR_BUCKET_FACTOR &&
            lclTemp_value <= MAX_AMBR_BUCKET_FACTOR) {
        if(!cell_cnt_index) {
            p_mac_init->ambrBktDepthFactor = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.ambrBktDepthFactor =
                lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of ambrBucketFactor is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_AMBR_BUCKET_FACTOR,
                MAX_AMBR_BUCKET_FACTOR);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->bucket_management_params,
            "tokenPeriodicity");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_TOKEN_PERIODICITY &&
            lclTemp_value <= MAX_TOKEN_PERIODICITY) {
        if(!cell_cnt_index) {
            p_mac_init->tokenPeriodicity = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.tokenPeriodicity =
                lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of tokenPeriodicity is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_TOKEN_PERIODICITY,
                MAX_TOKEN_PERIODICITY);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->bucket_management_params,
            "qosStrategyOverallocFactor");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    /*+- SPR 20896 Fix*/
    if(lclTemp_value <= MAX_QOS_STRATEGY_OVER_ALLOC_FACTOR) {
        /*+- SPR 20896 Fix*/
        if(!cell_cnt_index) {
            p_mac_init->qosStrategyOverallocFactor = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.qosStrategyOverallocFactor =
                lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of qosStrategyOverallocFactor is %d and "
                /*+- SPR 20896 Fix*/
                "range is from 0 to %d",
                lclTemp_value, 
                /*+- SPR 20896 Fix*/
                MAX_QOS_STRATEGY_OVER_ALLOC_FACTOR);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Bit_Rate_Factor,
            "enableAllocAfterAllowedBitrate");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_ENABLE_ALLOC_AFTER_ALLOWED_BITRATE &&
            lclTemp_value <= MAX_ENABLE_ALLOC_AFTER_ALLOWED_BITRATE) {
        if(!cell_cnt_index) {
            p_mac_init->enableAllocAfterAllowedBitrate = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.
                enableAllocAfterAllowedBitrate = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of enableAllocAfterAllowedBitrate is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_ENABLE_ALLOC_AFTER_ALLOWED_BITRATE,
                MAX_ENABLE_ALLOC_AFTER_ALLOWED_BITRATE);
        return OAM_FAILURE;
    }
    /* SPR 17777 fix */
    retVal = oam_populate_l2_dl_qos_strategy_wt_params(
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);

    return retVal;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_dl_qos_strategy_wt_params
 *  DESCRIPTION      : This function is used to populate the dl qos strategy qos
 *                     strategy wt parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* SPR 17777 fix */
oam_return_et
    oam_populate_l2_dl_qos_strategy_wt_params
(
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    xmlChar *tag_value = OAM_NULL;

    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "pdbWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_DL_PDB_WEIGHT &&
            lclTemp_value <= MAX_DL_PDB_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->dlQosStrategyWeights.pdbWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.dlQosStrategyWeights.
                pdbWeight = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of pdbWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_DL_PDB_WEIGHT,
                MAX_DL_PDB_WEIGHT);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "qciWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_DL_QCI_WEIGHT &&
            lclTemp_value <= MAX_DL_QCI_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->dlQosStrategyWeights.qciWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.dlQosStrategyWeights.
                qciWeight = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of qciWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_DL_QCI_WEIGHT,
                MAX_DL_QCI_WEIGHT);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "tokenWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_DL_TOKEN_WEIGHT &&
            lclTemp_value <= MAX_DL_TOKEN_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->dlQosStrategyWeights.tokenWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.dlQosStrategyWeights.
                tokenWeight = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of qciWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_DL_QCI_WEIGHT,
                MAX_DL_QCI_WEIGHT);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "qloadWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_DL_QLOAD_WEIGHT &&
            lclTemp_value <= MAX_DL_QLOAD_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->dlQosStrategyWeights.qLoadWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.dlQosStrategyWeights.
                qLoadWeight = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of qloadWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_DL_QLOAD_WEIGHT,
                MAX_DL_QLOAD_WEIGHT);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_DL,
            "mcsWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_DL_MCS_WEIGHT &&
            lclTemp_value <= MAX_DL_MCS_WEIGHT) {
        if(!cell_cnt_index) {
            /*SPR22043 Start*/
            p_mac_init->dlQosStrategyWeights.mcsWeight = lclTemp_value;
            /*SPR22043 End*/
        }
        else {
            p_mac_cell_init->macInitDLQOSParams.dlQosStrategyWeights.
                mcsWeight = lclTemp_value;
        }
    }
    else {
        OAM_LOG(OAM, OAM_ERROR,
                /*SPR22043 Start*/
                "Value of mcsWeight is %d and "
                /*SPR22043 End*/
                "range is from %d to %d",
                lclTemp_value, MIN_DL_MCS_WEIGHT,
                MAX_DL_MCS_WEIGHT);
        return OAM_FAILURE;
    }

    return OAM_SUCCESS;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_ul_qos_params
 *  DESCRIPTION      : This function is used to populate the ul qos
 *                     parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

oam_return_et
    oam_populate_l2_ul_qos_params
(
 XML_struct_cell_config    *p_cell_spec_params,
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %p", p_cell_spec_params);

    return oam_populate_l2_ul_qos_strategy_wt_params(
            p_prop_cellconfig,
            p_l2_req,
            cell_cnt_index);
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_ul_qos_strategy_wt_params
 *  DESCRIPTION      : This function is used to populate the ul qos strategy qos
 *                     strategy wt parameters of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* SPR 17777 fix */
oam_return_et
    oam_populate_l2_ul_qos_strategy_wt_params
(
 prop_cellconfig_xml_st    *p_prop_cellconfig,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    xmlChar *tag_value = OAM_NULL;

    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];
    }


    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "pdbWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_UL_PDB_WEIGHT &&
            lclTemp_value <= MAX_UL_PDB_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->ulQosStrategyWeights.pdbWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitULQOSParams.ulQosStrategyWeights.
                pdbWeight = lclTemp_value;
            /* Spr 12453 Fix Start*/
            p_mac_cell_init->fieldBitMask |= UL_QOS_PARAMS; 
            /* Spr 12453 Fix End*/
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of pdbWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_UL_PDB_WEIGHT,
                MAX_UL_PDB_WEIGHT);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "qciWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_UL_QCI_WEIGHT &&
            lclTemp_value <= MAX_UL_QCI_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->ulQosStrategyWeights.qciWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitULQOSParams.ulQosStrategyWeights.
                qciWeight = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of qciWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_UL_QCI_WEIGHT,
                MAX_UL_QCI_WEIGHT);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "tokenWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_UL_TOKEN_WEIGHT &&
            lclTemp_value <= MAX_UL_TOKEN_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->ulQosStrategyWeights.tokenWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitULQOSParams.ulQosStrategyWeights.
                tokenWeight = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of tokenWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_UL_TOKEN_WEIGHT,
                MAX_UL_TOKEN_WEIGHT);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "qloadWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_UL_QLOAD_WEIGHT &&
            lclTemp_value <= MAX_UL_QLOAD_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->ulQosStrategyWeights.qLoadWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitULQOSParams.ulQosStrategyWeights.
                qLoadWeight = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of qloadWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_UL_QLOAD_WEIGHT,
                MAX_UL_QLOAD_WEIGHT);
        return OAM_FAILURE;
    }

    tag_value = oam_xmlNodeGetContent(
            p_prop_cellconfig->Scheduling_Weights_Params_UL,
            "mcsWeight");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(lclTemp_value >= MIN_UL_MCS_WEIGHT &&
            lclTemp_value <= MAX_UL_MCS_WEIGHT) {
        if(!cell_cnt_index) {
            p_mac_init->ulQosStrategyWeights.mcsWeight = lclTemp_value;
        }
        else {
            p_mac_cell_init->macInitULQOSParams.ulQosStrategyWeights.
                mcsWeight = lclTemp_value;
        }
    }
    else {
		OAM_LOG(OAM, OAM_WARNING,
                "Value of mcsWeight is %d and "
                "range is from %d to %d",
                lclTemp_value, MIN_UL_MCS_WEIGHT,
                MAX_UL_MCS_WEIGHT);
        return OAM_FAILURE;
    }

    return OAM_SUCCESS;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_icic_params
 *  DESCRIPTION      : This function is used to populate the icic parameters
 *                     of L2
 *  PARAMETERS
 *      IN           : pointers to XML_struct_cell_config,prop_cellconfig_xml_st,
 *                     oam_l2_req_t, oam_rrm_cell_config_req_t,cell_cnt_index
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/
/* SPR 17777 fix */
oam_return_et
    oam_populate_l2_icic_params
(
 XML_struct_cell_config    *p_cell_spec_params,
 oam_l2_req_t              *p_l2_req,
 UInt8                      cell_cnt_index
 )
{
    xmlChar *tag_value = OAM_NULL;

    oam_mac_init_req_params_t *p_mac_init =
        &p_l2_req->oam_mac_req.mac_init_req;

    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;

    if(cell_cnt_index) {
        p_mac_cell_init = &p_l2_req->oam_mac_req.
            mac_init_cell_req[cell_cnt_index - 1];
    }

    tag_value = oam_xmlNodeGetContent(
            p_cell_spec_params->X_VENDOR_ICIC_PARAMS,
            "maxCellEdgeUEsToBeScheduledDL");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->maxCellEdgeUEsToBeScheduledDL = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitICICParams.
            maxCellEdgeUEsToBeScheduledDL = lclTemp_value;
        /* Spr 12453 Fix Start*/
        p_mac_cell_init->fieldBitMask |= ICIC_PARAMS;
        /* Spr 12453 Fix End*/
    }

    tag_value = oam_xmlNodeGetContent(
            p_cell_spec_params->X_VENDOR_ICIC_PARAMS,
            "maxCellEdgeUEsToBeScheduledUL");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->maxCellEdgeUEsToBeScheduledUL = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitICICParams.
            maxCellEdgeUEsToBeScheduledUL = lclTemp_value;
    }

    tag_value = oam_xmlNodeGetContent(
            p_cell_spec_params->X_VENDOR_ICIC_PARAMS,
            "cellEdgeUECQIThreshold");
    lclTemp_value = oam_atoi((Char8*)tag_value);

    if(!cell_cnt_index) {
        p_mac_init->cellEdgeUECQIThreshold = lclTemp_value;
    }
    else {
        p_mac_cell_init->macInitICICParams.cellEdgeUECQIThreshold =
            lclTemp_value;
    }

    return OAM_SUCCESS;
}
/*SPR 21889 +- */
/*SPR 15604 START */
#ifdef OAM_SON_ENABLE
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_rrm_inter_rat_ncl_utran_nliu
 *  DESCRIPTION      : This function used to populate the rrm parameters
 *  PARAMETERS
 *      IN           : NONE
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
*******************************************************************************/

oam_return_et oam_populate_rrm_inter_rat_ncl_utran_nliu(oam_rrm_cell_config_req_t *p_rrm_cellconfig ,XML_struct_cell_config *p_cell_spec_params )

{
    Char8 *temp;
    UInt16 umts_cell_cnt = OAM_ZERO;
    UInt16 umts_num_nliu_cells = OAM_ZERO;
    UInt16 umts_max_nliu_cells = OAM_ZERO;
    UInt16 umts_ncl_idx = OAM_ZERO;
    UInt8 idx = OAM_ZERO;
    //    oam_rrm_cell_config_req_t *p_rrm_cellconfig = OAM_NULL;
    //  XML_struct_cell_config *p_cell_spec_params = OAM_NULL ;
    oam_bool_et duplicate_nbr_found = OAM_FALSE;
    rrm_oam_cell_plmn_info_t temp_nliu_plmn = {{OAM_ZERO},OAM_ZERO,{OAM_ZERO}};
    UInt8 temp_nliu_cid[OAM_FOUR] = {OAM_ZERO};
    UInt32 utran_cid = OAM_ZERO;
    UInt32 utran_rncid = OAM_ZERO;
    /*  coverity 85425 fix start */
    oam_return_et retVal;
    /*  coverity 85425 fix end */
    Char8 temp_plmnid[OAM_SEVEN] = {0};

    if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_2,
                        "MaxUMTSEntries"),OAM_INVALID_STR))!= OAM_ZERO)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->InterRATCell_2,"MaxUMTSEntries"));
        umts_max_nliu_cells = (UInt16) lclTemp_value;
    }


    if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->InterRATCell_2,
                        "UMTSNumberOfEntries"),OAM_INVALID_STR))!= OAM_ZERO)
    {
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->InterRATCell_2,"UMTSNumberOfEntries"));
        umts_num_nliu_cells = (UInt16) lclTemp_value;
    }

    if(umts_num_nliu_cells > umts_max_nliu_cells)
    {
        OAM_LOG(OAM,OAM_WARNING,"UMTSNumberOfEntries > MaxUMTSEntries in NLIU");
        return OAM_FAILURE;
    }

    umts_ncl_idx = p_rrm_cellconfig->ran_info.
        ncl_params.inter_rat_ncl.num_valid_utran_freq_cell;

    for (umts_cell_cnt = OAM_ZERO;umts_cell_cnt < umts_num_nliu_cells; umts_cell_cnt++)
    {
        temp = (char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"PLMNID");

        if(OAM_NULL == temp)
        {
            return OAM_FAILURE;
        }
        oam_convert_plmnid(temp_plmnid,temp);
        oam_fill_mcc_mnc_from_plmnid(temp_plmnid,&temp_nliu_plmn);
        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                "CID");
        if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            OAM_LOG(OAM, OAM_WARNING,
                    "XML file reading failed! Node FAPService->CellConfig"
                    "->LTE->RAN->NeighborList->InterRATCell->UMTS->CID not found.");
            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        utran_cid = oam_atoi((Char8*)temp);
        temp_nliu_cid[0] = (utran_cid & 0x00FF);
        temp_nliu_cid[1] = (utran_cid & 0xFF00) >> 8;


        for( idx = OAM_ZERO; idx < umts_ncl_idx;
                ++idx)
        {
            if(are_plmns_same((son_cell_plmn_info_t *)&p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.
                        utran_freq_cells[idx].rai.lai.plmn_id,
                        (son_cell_plmn_info_t *)&temp_nliu_plmn) &&
                    !oam_memcmp(&p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.
                        utran_freq_cells[idx].uc_id.cell_id,
                        temp_nliu_cid,
                        SON_CELL_ID_OCTET_SIZE))
            {
                duplicate_nbr_found = OAM_TRUE;
                break;
            }
        }
        if(duplicate_nbr_found)
        {
            OAM_LOG(OAM,OAM_INFO,"Duplicate Neighbor Cell Entry [%d] found in NLIU UMTS"
                    "Skipping Population",umts_cell_cnt);
            duplicate_nbr_found = OAM_FALSE;
            continue;
        }

        oam_memcpy(&p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.
                utran_freq_cells[umts_cell_cnt].rai.lai.plmn_id,&temp_nliu_plmn,sizeof(temp_nliu_plmn));

        oam_fill_mcc_mnc_from_plmnid(temp_plmnid,&p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].rai.lai.plmn_id);
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"LAC"));
        /* SPR 19721 FIX START*/
        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].rai.lai.lac[OAM_ONE]= (lclTemp_value & OAM_LOWER_EIGHT_BITS_SET);

        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].rai.lai.lac[OAM_ZERO]=(lclTemp_value >>OAM_EIGHT ) & OAM_LOWER_EIGHT_BITS_SET;
        /* SPR 19721 FIX End*/

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"RAC"));
        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].rai.rac=lclTemp_value;


        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"UARFCNDL"));
        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].uarfcndl=lclTemp_value;

        if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                            "UARFCNUL"),OAM_INVALID_STR))!= OAM_ZERO)
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"UARFCNUL"));
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].uarfcnul=lclTemp_value;

            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].bitmask|=RRM_OAM_UTRAN_FREQ_UARFCNUL_PRESENT;
        }

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"PCPICHScramblingCode"));
        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].pcpich_scrambling_code=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"PCPICHTxPower"));
        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].pcpich_tx_power=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"X_VENDOR_OFFSETFREQ"));
        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].offset_freq=lclTemp_value;

        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"URA"));
        p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].ura=lclTemp_value;


        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                "RNCID");
        if(!oam_strcmp((Char8*)temp, OAM_INVALID_STR)) {
            OAM_LOG(OAM, OAM_WARNING,
                    "XML file reading failed! Node FAPService->CellConfig"
                    "->LTE->RAN->NeighborList->InterRATCell->UMTS->RNCID not found.");
            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        utran_rncid = oam_atoi((Char8*)temp);


        /* Check if the RNCID and CID values put together don't excceed
         * the 28-bit value range
         */
        if(utran_cid > OAM_12BIT_MAX_VALUE &&
                utran_rncid > OAM_12BIT_MAX_VALUE) {
            OAM_LOG(OAM, OAM_WARNING,
                    "The CellIdentity is 28-bit value, hence if RNCID is "
                    "greater than 4095, then CID must be less than 4096 and "
                    "vice versa.");
            retVal = OAM_FAILURE;
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].uc_id.
            cell_id[0] = (utran_cid & 0x00FF);
        p_rrm_cellconfig->ran_info.ncl_params.
            inter_rat_ncl.utran_freq_cells[umts_cell_cnt].uc_id.
            cell_id[1] = (utran_cid & 0xFF00) >> 8;

        if(utran_rncid <= OAM_12BIT_MAX_VALUE) {
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].uc_id.rnc_id =
                utran_rncid;
        }
        else {
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].uc_id.
                rnc_id = OAM_ZERO;

            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].uc_id.
                extended_rnc_id = utran_rncid;

            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].uc_id.
                bitmask |= RRM_OAM_UTRAN_EXTN_RNC_ID_PRESENT;
        }

        if (((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                                "X_VENDOR_ACCESS_MODE"),OAM_INVALID_STR))!= OAM_ZERO))
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS[umts_cell_cnt],"X_VENDOR_ACCESS_MODE"));
            p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.
                utran_freq_cells[umts_cell_cnt].cell_access_mode=lclTemp_value;
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].bitmask |= RRM_OAM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT;


        }
        /* SPR 17408 Fix Start */
        if(
                (p_rrm_cellconfig->ran_info.
                 ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].
                 bitmask & RRM_OAM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT)
                &&
                ((p_rrm_cellconfig->ran_info.
                 ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].
                 cell_access_mode == RRM_OAM_ACCESS_MODE_OPEN)
                ||
                (p_rrm_cellconfig->ran_info.
                 ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].
                 cell_access_mode == RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
          )
        {
            OAM_LOG(OAM, OAM_WARNING, "CSGID will not be read into "
                    " inter_rat_ncl.utran_freq_cells as ACCESS_MODE is present"
                    " and its value is Open/Open Femto");
        }
        /* SPR 17408 Fix End */
        else {
            if (((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                                    "X_VENDOR_CSGID"),OAM_INVALID_STR))!= OAM_ZERO))
            {
                lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"X_VENDOR_CSGID"));
                oam_conversion_from_int_to_byte_string(p_rrm_cellconfig->ran_info.ncl_params.
                        inter_rat_ncl.utran_freq_cells[umts_cell_cnt].csg_identity, lclTemp_value,OAM_CSG_ID_BITSTRING_SIZE);
                p_rrm_cellconfig->ran_info.ncl_params.
                    inter_rat_ncl.utran_freq_cells[umts_cell_cnt].bitmask |= RRM_OAM_UTRAN_FREQ_CSG_ID_PRESENT;

            }
        }
        if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                            "X_VENDOR_BLACKLISTED"),OAM_INVALID_STR))!= OAM_ZERO)
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"X_VENDOR_BLACKLISTED"));
            p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].blacklisted=lclTemp_value;
        }
        if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                            "X_VENDOR_HO_STATUS"),OAM_INVALID_STR))!= OAM_ZERO)
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"X_VENDOR_HO_STATUS"));
            p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].ho_status=lclTemp_value;
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].bitmask |= RRM_OAM_UTRAN_HO_STATUS_PRESENT;
        }
        if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                            "X_VENDOR_PS_HO_SUPPORTED"),OAM_INVALID_STR))!= OAM_ZERO)
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"X_VENDOR_PS_HO_SUPPORTED"));
            p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].ps_ho_supported=(rrm_bool_et)lclTemp_value;
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].bitmask |= RRM_OAM_UTRAN_PS_HO_SUPPORTED_PRESENT;
        }

        if ((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],
                            "X_VENDOR_VOIP_CAPABLE"),OAM_INVALID_STR))!= OAM_ZERO)
        {
            lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->UMTS_NLIU[umts_cell_cnt],"X_VENDOR_VOIP_CAPABLE"));
            p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].voip_capable=(rrm_bool_et)lclTemp_value;
            if((lclTemp_value == OAM_ONE) && (p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].ps_ho_supported == (rrm_bool_et)OAM_ZERO) && (p_rrm_cellconfig->ran_info.ncl_params.
                        inter_rat_ncl.utran_freq_cells[umts_cell_cnt].bitmask & RRM_OAM_UTRAN_PS_HO_SUPPORTED_PRESENT)){
                p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].voip_capable = (rrm_bool_et)OAM_ZERO;
            }
            p_rrm_cellconfig->ran_info.ncl_params.
                inter_rat_ncl.utran_freq_cells[umts_cell_cnt].bitmask |= RRM_OAM_UTRAN_VOIP_CAPABLE_PRESENT;
        }

        /* Filling Default Values for NLIU Neighbors */
        p_rrm_cellconfig->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[umts_cell_cnt].pcpich_tx_power = 0; 

    }/* End of for loop */

    return OAM_SUCCESS;
}
/*SPR 15604 END */

#endif


/*eICIC_PHASE_1_2_CHANGES_START*/  
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_eicic_params 
 *  DESCRIPTION      : This function is used to populate the eicic parameters
 *                                         
 *  PARAMETERS
 *      IN           : pointers to oam_rrm_cell_config_req_t,XML_struct_cell_config
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

    oam_return_et
oam_populate_eicic_params(oam_rrm_cell_config_req_t  *p_cellconfig,
        XML_struct_cell_config     *p_cell_spec_params)
{
    OAM_FUN_ENTRY_TRACE();
    Char8 *tag_value = OAM_NULL;
    /* SPR 16200 FIX START */
    rrm_oam_sub_frame_asgmnt_et tdd_config = RRM_OAM_SA0;
    oam_return_et retVal = OAM_FAILURE;
    Char8 buf[OAM_TAG_VALUE_STR_MAX_LEN] = {OAM_ZERO};
    /* SPR 16200 FIX END */

    if(p_cellconfig->operator_info.eicic_info.bitmask &
            RRM_OAM_EICIC_PROVISIONED_TYPE_PRESENT) {

        /*SPR 14165 start */
        /*deleted Rsrp,Rsrq*/
        /*SPR 14165 end*/

        if(p_cellconfig->operator_info.eicic_info.bitmask &
                RRM_OAM_ABS_INFO_PRESENT) {

            tag_value =
                (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->AbsInfo,
                        "NumAbsReport");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.eicic_info.abs_info.
                    num_abs_report= lclTemp_value;
                p_cellconfig->operator_info.eicic_info.abs_info.
                    bitmask |= RRM_OAM_NUM_ABS_REPORT_PRESENT;
            }

            tag_value =
                (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->AbsInfo,
                        "AbsUsageLowThreshold");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.eicic_info.abs_info.
                    abs_usage_low_threshold= lclTemp_value;
                p_cellconfig->operator_info.eicic_info.abs_info.
                    bitmask |= RRM_OAM_ABS_USAGE_LOW_THRESHOLD_PRESENT;
            }

            tag_value =
                (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->AbsInfo,
                        "AbsUsageHighThreshold");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.eicic_info.abs_info.
                    abs_usage_high_threshold= lclTemp_value;
                p_cellconfig->operator_info.eicic_info.abs_info.
                    bitmask |= RRM_OAM_ABS_USAGE_HIGH_THRESHOLD_PRESENT;
            }

            if(p_cellconfig->operator_info.eicic_info.abs_info.bitmask &
                    RRM_OAM_ABS_PATTERN_INFO_PRESENT) {
                /* SPR 16200 FIX START */
                /* spr_21013_fix_start */
                oam_get_xml_text_node_content(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1,
                        /* spr_21013_fix_end */
                        "DuplexMode", buf,
                        OAM_TAG_VALUE_STR_MAX_LEN);
                tdd_config = p_cellconfig->ran_info.physical_layer_params.
                    physical_layer_param_tdd_frame_structure.
                    sub_frame_assignment;
                /* SPR 16200 FIX END */

                tag_value =
                    (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->AbsPattern,
                            "LowLoadAbsPattern");
                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    /* SPR 16200 FIX START */
                    retVal = oam_validate_abs_pattern(tag_value, buf,
                            tdd_config);
                    if (OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_WARNING,
                                "ABS pattern length is too long");

                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }
                    /* SPR 16200 FIX END */

                    oam_conversion_abs_pattern_byte_string_to_bitstring(
                            tag_value ,p_cellconfig->operator_info.
                            eicic_info.abs_info.abs_pattern.low_load_abs_pattern);
                    p_cellconfig->operator_info.eicic_info.abs_info.abs_pattern.
                        bitmask |= RRM_OAM_LOW_LOAD_ABS_PATTERN_PRESENT;
                }

                tag_value =
                    (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->AbsPattern,
                            "VictimAbsPattern");
                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                    /* SPR 16200 FIX START */
                    retVal = oam_validate_abs_pattern(tag_value, buf,
                            tdd_config);
                    if (OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_WARNING,
                                "ABS pattern length is too long");

                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }
                    /* SPR 16200 FIX END */

                    oam_conversion_abs_pattern_byte_string_to_bitstring(
                            tag_value ,p_cellconfig->operator_info.
                            eicic_info.abs_info.abs_pattern.victim_abs_pattern);
                    p_cellconfig->operator_info.eicic_info.abs_info.abs_pattern.
                        bitmask |= RRM_OAM_VICTIM_ABS_PATTERN_PRESENT;
                }
                /*SPR 14180 start*/
                tag_value =
                    (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->AbsPattern,
                            "VictimMeasSubset");
                if(oam_strcmp(tag_value, OAM_INVALID_STR)) {

                    oam_conversion_abs_pattern_byte_string_to_bitstring(
                            tag_value ,p_cellconfig->operator_info.
                            eicic_info.abs_info.abs_pattern.victim_meas_subset);
                    p_cellconfig->operator_info.eicic_info.abs_info.abs_pattern.
                        bitmask |=RRM_OAM_VICTIM_MEAS_SUBSET_PRESENT ;
                }

                /*SPR 14180 end*/

            }
        }

        tag_value =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->eicic_params,
                    "eligible_ue");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi(tag_value);
            p_cellconfig->operator_info.eicic_info.eligible_ue= lclTemp_value;
            p_cellconfig->operator_info.eicic_info.
                bitmask |= RRM_OAM_EICIC_ELIGIBLE_UE_PRESENT ;
        }


        if(p_cellconfig->operator_info.eicic_info.bitmask &
                RRM_OAM_EICIC_TIMER_INFO_PRESENT) {
            tag_value =
                (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->eICICTimerInfo,
                        "MacEicicMeasReportPeriodicity");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.eicic_info.eicic_timer_info.
                    mac_eicic_meas_report_periodicity= lclTemp_value;
                p_cellconfig->operator_info.eicic_info.eicic_timer_info.
                    bitmask |= RRM_OAM_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT;
            }

            tag_value =
                (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->eICICTimerInfo,
                        "AggressorSelTimer");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.eicic_info.eicic_timer_info.
                    aggressor_sel_timer= lclTemp_value;
                p_cellconfig->operator_info.eicic_info.eicic_timer_info.
                    bitmask |= RRM_OAM_AGGRESSOR_SEL_TIMER_PRESENT;
            }

            tag_value =
                (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->eICICTimerInfo,
                        "LoadInformationGuardTimer");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.eicic_info.eicic_timer_info.
                    load_information_guard_timer= lclTemp_value;
                p_cellconfig->operator_info.eicic_info.eicic_timer_info.
                    bitmask |= RRM_OAM_LOAD_INFORMATION_GUAURD_TIMER_PRESENT;
            }

            tag_value =
                (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->eICICTimerInfo,
                        "LoadInformationCollationTimer");
            if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
                lclTemp_value = oam_atoi(tag_value);
                p_cellconfig->operator_info.eicic_info.eicic_timer_info.
                    load_information_collation_timer = lclTemp_value;
                /*bug_13922_start */
                p_cellconfig->operator_info.eicic_info.eicic_timer_info.
                    bitmask |= RRM_OAM_LOAD_INFORMATION_COLLATION_TIMER;
                /*bug_13922_end */
            }

        }
        tag_value =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->eicic_params,
                    "DlSinrThreshLowMark");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi(tag_value);
            p_cellconfig->operator_info.eicic_info.
                dl_sinr_threshold_low_mark= lclTemp_value;
            p_cellconfig->operator_info.eicic_info.
                bitmask |= RRM_OAM_DL_SINR_THRESHOLD_LOW_MARK_PRESENT;
        }

        tag_value =
            (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->eicic_params,
                    "DlSinrThreshHighMark");
        if(oam_strcmp(tag_value, OAM_INVALID_STR)) {
            lclTemp_value = oam_atoi(tag_value);
            p_cellconfig->operator_info.eicic_info.
                dl_sinr_threshold_high_mark= lclTemp_value;
            p_cellconfig->operator_info.eicic_info.
                bitmask |= RRM_OAM_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT;
        }


    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

#ifdef OAM_SON_ENABLE
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_anr_neighbor_default_config_params
 *  DESCRIPTION      : This function is used to populate the default config
 params of SON
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
 *******************************************************************************/

/* + SPR 17439 */
    oam_return_et
oam_populate_anr_neighbor_default_config_params(void)
{
    /* - SPR 17439 */

    OAM_FUN_ENTRY_TRACE();
    /*eICIC_PHASE_1_2_CHANGES_START*/ 
    Char8 *tag_value = OAM_NULL;
    /*SPR 14107 start */
    /*CID:69723 start*/
    oam_return_et ret_val = OAM_FAILURE;
    /*CID:69723 end*/
    /*SPR 14107 end */
    tag_value = ((Char8 *)oam_xmlNodeGetContent(xml_struct_g.
                son_oam_anr_neighbor_default_config_req,"nr_status"));

    if (oam_strcmp(tag_value, OAM_INVALID_STR)){
        lclTemp_value2 = oam_atoi(tag_value);
        /*bug_13876_start */
        if(lclTemp_value2 <= SON_NR_UNDEFINED)
        {
            /*CID:69635 start*/
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                nr_status = (son_nr_status_et)lclTemp_value2;
            /*CID:69635 end*/
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                bitmask |= SON_OAM_ANR_NBR_DEF_NR_STATUS_PRESENT;
            /*SPR 14107 start */
            ret_val = OAM_SUCCESS;
            /*SPR 14107 end */
        }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,"OUT OF RANGE value of nr_status [%d]",lclTemp_value2 );
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /*bug_13876_end */
    }

    tag_value = ((Char8 *)oam_xmlNodeGetContent(xml_struct_g.
                son_oam_anr_neighbor_default_config_req,"ho_status"));
    if (oam_strcmp(tag_value, OAM_INVALID_STR)){
        lclTemp_value2 = oam_atoi(tag_value);
        /*bug_13876_start */
        if(lclTemp_value2 <= SON_HO_UNDEFINED){
            /*CID:69592 start*/
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                ho_status= (son_ho_status_et)lclTemp_value2;
            /*CID:69592 end*/
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                bitmask |= SON_OAM_ANR_NBR_DEF_HO_STATUS_PRESENT;
            /*SPR 14107 start */
            ret_val = OAM_SUCCESS;
            /*SPR 14107 end */
        }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,"OUT OF RANGE value of ho_status [%d]",lclTemp_value2 );
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /*bug_13876_end */
    }

    tag_value = ((Char8 *)oam_xmlNodeGetContent(xml_struct_g.
                son_oam_anr_neighbor_default_config_req,"x2_status"));

    if (oam_strcmp(tag_value, OAM_INVALID_STR)){
        lclTemp_value2 = oam_atoi(tag_value);
        /*bug_13876_start */
        if(lclTemp_value2 <= SON_X2_UNDEFINED ){
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                x2_status= (son_x2_status_et)lclTemp_value2;
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                bitmask |= SON_OAM_ANR_NBR_DEF_X2_STATUS_PRESENT;
            /*SPR 14107 start */
            ret_val = OAM_SUCCESS;
            /*SPR 14107 end */
        }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,"OUT OF RANGE value of x2_status [%d]",lclTemp_value2 );
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /*bug_13876_end */
    }

    tag_value = ((Char8 *)oam_xmlNodeGetContent(xml_struct_g.
                son_oam_anr_neighbor_default_config_req,"csg_cell_intf_scheme"));

    if (oam_strcmp(tag_value, OAM_INVALID_STR)){
        lclTemp_value2 = oam_atoi(tag_value);
        /*bug_13876_start */
        if(lclTemp_value2 <= SON_NO_INTF_SCHEME){ 
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                csg_cell_intf_scheme= (son_intf_scheme_type_et)lclTemp_value2;
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                bitmask |= SON_OAM_ANR_CSG_DEF_SCHEME_PRESENT ;
            /*SPR 14107 start */
            ret_val = OAM_SUCCESS;
            /*SPR 14107 end */
        }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,"OUT OF RANGE value of pico_cell_intf_scheme [%d]",lclTemp_value2 );
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /*bug_13876_end */
    }

    tag_value = ((Char8 *)oam_xmlNodeGetContent(xml_struct_g.
                son_oam_anr_neighbor_default_config_req,"pico_cell_intf_scheme"));

    if (oam_strcmp(tag_value, OAM_INVALID_STR)){
        lclTemp_value2 = oam_atoi(tag_value);
        /*bug_13876_start */
        if(lclTemp_value2 <= SON_NO_INTF_SCHEME){
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                pico_cell_intf_scheme= (son_intf_scheme_type_et)lclTemp_value2;
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                bitmask |= SON_OAM_ANR_PICO_DEF_SCHEME_PRESENT;
            /*SPR 14107 start */
            ret_val = OAM_SUCCESS;
            /*SPR 14107 end */
        }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,"OUT OF RANGE value of pico_cell_intf_scheme [%d]",lclTemp_value2 );
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /*bug_13876_end */
    }

    tag_value = ((Char8 *)oam_xmlNodeGetContent(xml_struct_g.
                son_oam_anr_neighbor_default_config_req,"macro_cell_intf_scheme"));

    if (oam_strcmp(tag_value, OAM_INVALID_STR)){
        lclTemp_value2 = oam_atoi(tag_value);
        /*bug_13876_start */
        /*CID:69634 start*/
        if(lclTemp_value2 <= SON_NO_INTF_SCHEME){
            /*CID:69634 end*/
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                macro_cell_intf_scheme= (son_intf_scheme_type_et)lclTemp_value2;
            oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.
                bitmask |= SON_OAM_ANR_MACRO_DEF_SCHEME_PRESENT;
            /*SPR 14107 start */
            ret_val = OAM_SUCCESS;
            /*SPR 14107 end */
        }
        else
        {
			OAM_LOG(OAM, OAM_WARNING,"OUT OF RANGE value of macro_cell_intf_scheme [%d]",lclTemp_value2 );
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    /*bug_13876_end */

    /*eICIC_PHASE_1_2_CHANGES_END*/ 

    OAM_FUN_EXIT_TRACE();
    /*SPR 14107 start */
    return ret_val;
    /*SPR 14107 end */
}

/*SPR 15438 START */
/****************************************************************************
 * Function Name  : oam_tokenize_son_pci_list
 * Inputs         : p_str: string to be tokenized
 *                  item_sep: delimiter to separate individual tokens
 *                  range_sep: delimiter to identify a range of tokens
 *                  max_tokens: maximum number of tokens allowed
 * Outputs        : p_tokens: array of u16 type
 * Returns        : number of tokens successfully interpreted
 * Description    : This function is used to convert a character string to
 *                  a list of UInt16 integer numbers
 ****************************************************************************/
UInt32 oam_tokenize_son_pci_list(const Char8* p_str,
        const Char8* item_sep,  
        const Char8* range_sep,
        oam_son_pci_selection_req_t  *p_pci_selection_req,
        oam_cell_neighbourlist_info_t *p_nr_info,
        UInt32 max_tokens,
        oam_error_code_et *p_err)
{
    OAM_FUN_ENTRY_TRACE();
    UInt32 token_count = OAM_ZERO;
    Char8 *token = OAM_NULL;
    Char8 *save_ptr = OAM_NULL;
    Char8 *save_ptr1 = OAM_NULL;
    Char8 temp_str[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
    SInt32 str_len = OAM_ZERO;
    oam_return_et retVal = OAM_FAILURE;
    Char8 *list = OAM_NULL;
    Char8 *range_val = OAM_NULL;
    SInt32 start_val = OAM_ZERO;
    SInt32 end_val = OAM_ZERO;
    SInt32 count = OAM_ZERO;
    UInt32 count1 = OAM_ZERO;
    oam_son_nr_add_req_t *p_son_nr_add = &p_nr_info->oam_son_nr_add_req;
    /*coverity 94848 fix start*/
    if(!p_str || !p_pci_selection_req || !p_err) {
        /*coverity 94848 fix end*/    
		OAM_LOG(OAM, OAM_WARNING, "Null pointer error!!");

        if (p_err) {
            *p_err = OAM_NULL_POINTER_ERR;
        }

        OAM_FUN_EXIT_TRACE();
        return token_count;
    }

    str_len = oam_strlen(p_str) + 1;

    retVal = oam_mem_alloc(str_len, (void**)&list, p_err);

    if (OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to list failed"
                " with Error Code:%d",
                *p_err);
        *p_err = OAM_MALLOC_FAIL;

        OAM_FUN_EXIT_TRACE();
        return token_count;
    }

    oam_memset(list, 0, str_len);
    oam_strcpy(list, p_str);

    token = oam_strtok_r(list, item_sep, &save_ptr);
    /* SPR 13060 FIX START */
    while (token && token_count <= max_tokens) {
        /* SPR 13060 FIX END */
        oam_memset(temp_str, 0, sizeof(temp_str));
        oam_trim_spaces(token, temp_str);

        if (range_sep && oam_strstr(temp_str, range_sep)) {
            save_ptr1 = OAM_NULL;
            range_val = oam_strtok_r(temp_str, range_sep, &save_ptr1);

            if (!range_val) {
                token = oam_strtok_r(OAM_NULL, item_sep, &save_ptr);
                continue;
            }

            start_val = oam_atoi(range_val);
            range_val = oam_strtok_r(OAM_NULL, range_sep, &save_ptr1);

            if (!range_val) {
                token = oam_strtok_r(OAM_NULL, item_sep, &save_ptr);
                continue;
            }

            end_val = oam_atoi(range_val);

            /* SPR 17753 Fix Start */
            for (count = start_val; (count <= end_val && count <= MAX_PHYCELLID) ; ++count) {
                /* SPR 17753 Fix End */
                /* Spr 15438 Fix Start */ 
                if(p_pci_selection_req->pci_list[OAM_ZERO]== count)
                    continue;
                /*  coverity 94853 fix start */
                count1 = OAM_ZERO;
                while (count1 < p_son_nr_add->nr_list.intra_rat_nr_list_size)
                {
                    if ((p_son_nr_add->nr_list.intra_rat_nr_list[count1].earfcn == 
                                p_pci_selection_req->earfcn) &&
                            p_son_nr_add->nr_list.intra_rat_nr_list[count1].pci == count)
                    {
                        /* SPR 18930  FIX START */
                        if((p_nr_info->eutran_nbr_ctxt[count1].enable == OAM_TRUE)&&
                                (p_nr_info->eutran_nbr_ctxt[count1].must_include == OAM_TRUE))
                            /* SPR 18930  FIX END */
                        {
                            break;
                        }
                    }
                    count1++;
                }
                if (count1 == p_son_nr_add->nr_list.intra_rat_nr_list_size)
                {  
                    p_pci_selection_req->pci_list[token_count++] = count;
                }
                /*  coverity 94853 fix end */
                /* Spr 15438 Fix End */ 
            }

            start_val = end_val = OAM_ZERO;
        }
        else {
            count1 = OAM_ZERO;  
            while (count1 < p_son_nr_add->nr_list.intra_rat_nr_list_size)
            {               
                if ((p_son_nr_add->nr_list.intra_rat_nr_list[count1].earfcn == 
                            p_pci_selection_req->earfcn) &&
                        p_son_nr_add->nr_list.intra_rat_nr_list[count1].pci == oam_atoi((const char *)token))
                {
                    /* SPR 18930  FIX START */
                    if((p_nr_info->eutran_nbr_ctxt[count1].enable == OAM_TRUE)&&
                            (p_nr_info->eutran_nbr_ctxt[count1].must_include == OAM_TRUE))
                        /* SPR 18930  FIX END */
                    {
                        break;
                    }
                }
                count1++;
            }
            if (count1 == p_son_nr_add->nr_list.intra_rat_nr_list_size)
            {
                p_pci_selection_req->pci_list[token_count++] = oam_atoi(temp_str);
            }
        }

        token = oam_strtok_r(OAM_NULL, item_sep, &save_ptr);
    }

    oam_mem_free(list, p_err);

    OAM_FUN_EXIT_TRACE();
    return token_count;
}
/*SPR 15438 END */

/*SPR_15770 Fix start*/

/*******************************************************************************
 *  FUNCTION NAME    : oam_fill_known_earfcn 
 *  DESCRIPTION      : Thhis function populates known earfcn 
 *                     in EarFCn list to be given to SON
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : Number of Earfcn  
 *
 *  RETURNS          :  
*******************************************************************************/
UInt8 oam_fill_known_earfcn(UInt16 *p_earfcn_list)
{
    UInt8 loop = OAM_ZERO;
    UInt8 num_earfcn = oam_prov_req.oam_igd_params.rem_lte_params.known_earfcn_list.num_earfcn;
    for (loop = OAM_ZERO; loop < num_earfcn; loop++)
    {
        p_earfcn_list[loop] = oam_prov_req.oam_igd_params.rem_lte_params.known_earfcn_list.meas_bandwidth_per_earfcn[loop].earfcn;
    }
    return num_earfcn;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_son_nr_scan_params
 *  DESCRIPTION      : Populates the parameters for SON_NR_SCAN_REQ
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
*******************************************************************************/
/* + SPR 17439 */
oam_return_et oam_populate_son_nr_scan_params(void)
{
    /* - SPR 17439 */
    UInt16 earfcn_count   = OAM_ZERO;
    Char8  csv_list[300] = "";
    UInt16 earfcn_list[SON_MAX_NO_EARFCN] = {0};
    /*SPR_15948_FIX_start*/
    SInt16 lc_temp = 0;
    /*SPR_15948_FIX_end*/

    OAM_FUN_ENTRY_TRACE();

    oam_prov_req.oam_son_req.nr_scan.bitmask |=
        SON_INTRA_RAT_NW_SCAN_REQ_PRESENT;
    /* spr_21013_fix_start */
    strncpy((Char8*)csv_list,  (const Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "EUTRACarrierARFCNDLList"), 
            /* spr_21013_fix_end */
            sizeof(csv_list)-1);

    /* Populate in local structure to support gpv/spv */
    oam_memcpy(oam_prov_req.oam_son_req.temp_values.nw_scan_earfcn_list,csv_list,oam_strlen((char*)csv_list));

    if (0 != strncmp(OAM_INVALID_STR, csv_list, oam_strlen(OAM_INVALID_STR)))
    {
        OAM_LOG(OAM, OAM_INFO, "EUTRACarrierARFCNDLList Tag present");
        oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.bitmask |=
            SON_MEAS_UTRAN_BANDWINDTH_PER_ARFCN_PRESENT;

        oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.meas_bandwidth_per_earfcn.num_earfcn = 
            oam_tokenize_string_to_u16(csv_list, ",", SON_MAX_NO_EARFCN, earfcn_list);

        /*if num_earfcn is zero use known earfcn list*/
        if (OAM_ZERO ==  oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.meas_bandwidth_per_earfcn.num_earfcn)
        {
            oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.
                meas_bandwidth_per_earfcn.num_earfcn = oam_fill_known_earfcn(earfcn_list);

        }

        for(earfcn_count = OAM_ZERO;earfcn_count < oam_prov_req.oam_son_req.nr_scan.
                start_intra_rat_scan_req.meas_bandwidth_per_earfcn.num_earfcn;earfcn_count++)
        {
            oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.
                meas_bandwidth_per_earfcn.meas_bandwidth_per_earfcn[earfcn_count].earfcn = 
                earfcn_list[earfcn_count];
            /*SPR_15948_FIX_start*/
            /* spr_21013_fix_start */
            lc_temp = oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_MEAS_BANDWIDTH"));
            /* spr_21013_fix_end */
            oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.
                meas_bandwidth_per_earfcn.meas_bandwidth_per_earfcn[earfcn_count].
                meas_bandwidth_for_earfcn = lc_temp; 

            if ((6 > lc_temp) ||
                    (100 < lc_temp))
            {
                    OAM_LOG(OAM, OAM_WARNING, "Value of X_VENDOR_MEAS_BANDWIDTH[%d] is out of range (6:100)",
                        lc_temp);
                return OAM_FAILURE;
            }
            /*SPR_15948_FIX_end*/
        }
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO, "X_VENDOR_MEAS_BANDWIDTH Tag present");
        oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.bitmask |=
            SON_MEAS_UTRAN_BANDWINDTH_PRESENT;
        oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.meas_bandwidth =
            /* spr_21013_fix_start */
            oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_MEAS_BANDWIDTH"));
        /* spr_21013_fix_end */
        if ((6 > oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.meas_bandwidth) ||
                (100 < oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.meas_bandwidth))
        {
            OAM_LOG(OAM, OAM_WARNING, "Value of X_VENDOR_MEAS_BANDWIDTH[%d] is out of range (6:100)",
                    oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.meas_bandwidth);
            return OAM_FAILURE;
        }

    }

    oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.measurement_period =
        /* spr_21013_fix_start */
        oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_MEASUREMENT_PERIOD"));
    oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.retry_count = 
        oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_RETRY_COUNT"));
    /* coverity 41179 */
    oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.freq_band_id = 
        oam_atoi((Char8 *)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "REMBandList"));
    /* spr_21013_fix_end */
    if (64 < oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.freq_band_id)
    {
        OAM_LOG(OAM, OAM_WARNING, "Value of REMBandList[%u] is out of range (0:64)",
                oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.freq_band_id);
        return OAM_FAILURE;
    }

    oam_memset(csv_list, 0, sizeof(csv_list));
    /* spr_21013_fix_start */
    strncpy((Char8*)csv_list, (const Char8*)oam_xmlNodeGetContent(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5, "X_VENDOR_PCI_LIST"), 
            /* spr_21013_fix_end */
            sizeof(csv_list)-1);
    if (0 == strncmp(OAM_INVALID_STR, csv_list, oam_strlen(OAM_INVALID_STR)))
    {
        OAM_LOG(OAM, OAM_WARNING, "X_VENDOR_PCI_LIST Tag not found in xml file");
        return OAM_FAILURE;
    }

    /* Start: CSR 00053250 */
    oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.meas_bandwidth_per_earfcn.
        meas_bandwidth_per_earfcn[OAM_ZERO].num_pci =
        oam_tokenize_string_to_u16(csv_list, ",", SON_MAX_NO_CELLS_PER_EARFCN, 
                oam_prov_req.oam_son_req.nr_scan.start_intra_rat_scan_req.
                meas_bandwidth_per_earfcn.meas_bandwidth_per_earfcn[OAM_ZERO].pci); 
    /*End: CSR 00053250 end */   
    OAM_FUN_ENTRY_TRACE();
    return OAM_SUCCESS;
}
#endif
/*SPR_15770 Fix end*/
/* SPR 15238 START */
/*******************************************************************************
 *  FUNCTION NAME    : oam_init_nbr_cell_access_mode_pci_validation 
 *  DESCRIPTION      : This function used to calcilate the access mode according 
 *                     to the pci ranges and validate the access mode provided by
 *                     the operator
 *  PARAMETERS
 *      IN           : nbr_cell_type, eutra_carrier_arfcn , nbr_pci, access_mode
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  calculated access mode 
*******************************************************************************/
    oam_access_mode_et
oam_init_nbr_cell_access_mode_pci_validation(
        XML_struct_cell_config *p_cell_spec_params,
        oam_eutran_nbr_cell_type_et nbr_cell_type,
        UInt32 eutra_carrier_arfcn,
        U16 nbr_pci,
        SInt32 access_mode)
{
    oam_access_mode_et nbr_access_mode = (oam_access_mode_et)access_mode;
    oam_access_mode_et expected_access_mode = OAM_OPEN_FEMTO;
    per_freq_pci_ranges_t per_freq_pci_ranges = {OAM_ZERO};
    OAM_FUN_ENTRY_TRACE();

    switch(nbr_cell_type)
    {
        case OAM_INTRA_FREQ_NBR_CELL:
        /* Check AccessMode value based on PCI
         * and PCI ranges for IntraFreq Neighbor Cell */

        if(OAM_FAILURE == oam_populate_eutran_intra_freq_pci_ranges(
                    p_cell_spec_params,
                    &per_freq_pci_ranges))
        {
            OAM_FUN_EXIT_TRACE();
            return nbr_access_mode;
        }

        break;

        case OAM_INTER_FREQ_NBR_CELL:
        /* Check AccessMode value based on PCI
         * and PCI ranges for InterFreq Neighbor Cell */

        if(OAM_FAILURE == oam_populate_eutran_inter_freq_pci_ranges(
                    p_cell_spec_params,
                    &per_freq_pci_ranges, eutra_carrier_arfcn))
        {
            OAM_FUN_EXIT_TRACE();
            return nbr_access_mode;
        }
        break;

        default:
        OAM_LOG(OAM, OAM_WARNING, "Unknown frequency input type");
        return nbr_access_mode;
    }

    if((nbr_pci >= per_freq_pci_ranges.open_pci_start) 
            && (nbr_pci <= per_freq_pci_ranges.open_pci_start 
                + per_freq_pci_ranges.open_pci_range - OAM_ONE))
    {
        expected_access_mode = OAM_OPEN_FEMTO;
    }
    else if((nbr_pci >= per_freq_pci_ranges.closed_pci_start)  
            && (nbr_pci<= per_freq_pci_ranges.closed_pci_start 
                + per_freq_pci_ranges.closed_pci_range - OAM_ONE))
    {
        expected_access_mode = OAM_CLOSED;
    }
    else if((nbr_pci >= per_freq_pci_ranges.hybrid_pci_start)
            && (nbr_pci<= per_freq_pci_ranges.hybrid_pci_start 
                + per_freq_pci_ranges.hybrid_pci_range - OAM_ONE))
    {
        expected_access_mode = OAM_HYBRID;
    }
    else
    {
        expected_access_mode = OAM_OPEN_MACRO;
    }

    if(expected_access_mode != nbr_access_mode)
    {
        OAM_LOG(OAM,OAM_WARNING,
                "Access Mode value does not match with the given pci_ranges."
                " Expected Access Mode value is %d and present is %d."
                " Changing the Access Mode value of nbr to %d.",
                expected_access_mode,nbr_access_mode,expected_access_mode);
        OAM_FUN_EXIT_TRACE();
        return expected_access_mode;
    }
    else
    {
        OAM_LOG(OAM,OAM_INFO," Access Mode successfully validated for nbr cell");
    }

    OAM_FUN_EXIT_TRACE();
    return nbr_access_mode;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_eutran_intra_freq_pci_ranges 
 *  DESCRIPTION      : This function used to populate intra_freq pci ranges
 *  PARAMETERS
 *      IN           : *per_freq_pci_ranges 
 *
 *      OUT          : per_freq_pci_ranges
 *
 *  RETURNS          :  OAM_SUCCESS/OAM_FAILURE 
 *******************************************************************************/
    oam_return_et 
oam_populate_eutran_intra_freq_pci_ranges(
        XML_struct_cell_config *p_cell_spec_params,
        per_freq_pci_ranges_t *per_freq_pci_ranges)
{
    SInt32 lclTemp_value = OAM_ZERO;
    OAM_FUN_ENTRY_TRACE();


    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                        "X_VENDOR_OPEN_PHY_CELLID_START"), OAM_INVALID_STR) != OAM_ZERO) &&
            (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                                                            "X_VENDOR_OPEN_PHY_CELLID_RANGE"), OAM_INVALID_STR) != OAM_ZERO))
    {    
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_OPEN_PHY_CELLID_START"));


        per_freq_pci_ranges->open_pci_start = lclTemp_value;

        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_OPEN_PHY_CELLID_RANGE"),
                PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);

        per_freq_pci_ranges->open_pci_range = oam_map_pci_range(
                (rrm_oam_cell_id_range_et)lclTemp_value);

    }

    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                        "X_VENDOR_CSG_PHY_CELLID_START"), OAM_INVALID_STR) != OAM_ZERO) &&
            (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                                                            "X_VENDOR_CSG_PHY_CELLID_RANGE"), OAM_INVALID_STR) != OAM_ZERO))
    {    
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_CSG_PHY_CELLID_START"));

        per_freq_pci_ranges->closed_pci_start = lclTemp_value;

        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_CSG_PHY_CELLID_RANGE"),
                PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);

        per_freq_pci_ranges->closed_pci_range = oam_map_pci_range(
                (rrm_oam_cell_id_range_et)lclTemp_value);

    }

    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                        "X_VENDOR_HYBRID_PHY_CELLID_START"), OAM_INVALID_STR) != OAM_ZERO) &&
            (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->IntraFreq,
                                                            "X_VENDOR_HYBRID_PHY_CELLID_RANGE"), OAM_INVALID_STR) != OAM_ZERO))
    {    
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_HYBRID_PHY_CELLID_START"));

        per_freq_pci_ranges->hybrid_pci_start = lclTemp_value;

        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->IntraFreq,"X_VENDOR_HYBRID_PHY_CELLID_RANGE"),
                PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);

        per_freq_pci_ranges->hybrid_pci_range = oam_map_pci_range(
                (rrm_oam_cell_id_range_et)lclTemp_value);

    }        

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_eutran_inter_freq_pci_ranges 
 *  DESCRIPTION      : This function used to populate inter_freq pci ranges
 *  PARAMETERS
 *      IN           : *per_freq_pci_ranges 
 *
 *      OUT          : per_freq_pci_ranges
 *
 *  RETURNS          :  OAM_SUCCESS/OAM_FAILURE 
 *******************************************************************************/
    oam_return_et 
oam_populate_eutran_inter_freq_pci_ranges(
        XML_struct_cell_config *p_cell_spec_params,
        per_freq_pci_ranges_t *per_freq_pci_ranges, 
        UInt32 eutra_carrier_arfcn)
{

    SInt32 lclTemp_value = OAM_ZERO;
    UInt16 max_cnt = OAM_ZERO;
    UInt16 freq_indx = OAM_ZERO;
    UInt32 avail_freq = OAM_ZERO;
    oam_rrm_cell_config_req_t *p_rrm_cell_config = OAM_NULL;
    OAM_FUN_ENTRY_TRACE();


    UInt8 cell_arr_idx = OAM_ZERO;
    /*SPR 17740 Start*/
    cell_arr_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);
    /*SPR 17740 End*/
    /* Coverity Fixes 95487 95477 */
    /*  coverity fix 95487/96487/96480 start */
    if(cell_arr_idx >= OAM_MAX_CELL_SUPPORTED)
    {
        OAM_LOG(OAM,OAM_WARNING," oam_get_rrm_cell_config_idx returned unsupported value for oam_prov_req.cell_cntxt.curr_cell_cid %d  ", 
                oam_prov_req.cell_cntxt.curr_cell_cid);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    /*  coverity fix 95487/96487/96480 end */

    p_rrm_cell_config =
        &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx];

    max_cnt = p_rrm_cell_config->ran_info.
        mobility_params.idle_mode_mobility_params.
        idle_mode_inter_freq_params_list.
        num_valid_inter_freq_list;

    for(freq_indx = OAM_ZERO; freq_indx < max_cnt; ++freq_indx) 
    {
        avail_freq = p_rrm_cell_config->ran_info.
            mobility_params.idle_mode_mobility_params.
            idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[freq_indx].
            eutra_carrier_arfcn;

        if(eutra_carrier_arfcn == avail_freq) {
            break;
        }
    }
    if(freq_indx >= max_cnt)
    {
        OAM_LOG(OAM,OAM_WARNING," InterFreq %d not found in the Added List ", 
                eutra_carrier_arfcn);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[freq_indx],
                        "X_VENDOR_OPEN_PHY_CELLID_START"), OAM_INVALID_STR) != OAM_ZERO)
            && (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[freq_indx],
                        "X_VENDOR_OPEN_PHY_CELLID_RANGE"), OAM_INVALID_STR) != OAM_ZERO))
    {    
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Carrier[freq_indx],"X_VENDOR_OPEN_PHY_CELLID_START"));

        per_freq_pci_ranges->open_pci_start = lclTemp_value;

        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Carrier[freq_indx],"X_VENDOR_OPEN_PHY_CELLID_RANGE"),
                PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);

        per_freq_pci_ranges->open_pci_range = oam_map_pci_range(
                (rrm_oam_cell_id_range_et)lclTemp_value);
    }        

    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[freq_indx],
                        "X_VENDOR_CSG_PHY_CELLID_START"), OAM_INVALID_STR) != OAM_ZERO) &&
            (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[freq_indx],
                                                            "X_VENDOR_CSG_PHY_CELLID_RANGE"), OAM_INVALID_STR) != OAM_ZERO))
    {    
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Carrier[freq_indx],"X_VENDOR_CSG_PHY_CELLID_START"));
        per_freq_pci_ranges->closed_pci_start = lclTemp_value;

        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Carrier[freq_indx],"X_VENDOR_CSG_PHY_CELLID_RANGE"),
                PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);
        per_freq_pci_ranges->closed_pci_range = oam_map_pci_range(
                (rrm_oam_cell_id_range_et)lclTemp_value);

    }

    if((oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[freq_indx],
                        "X_VENDOR_HYBRID_PHY_CELLID_START"), OAM_INVALID_STR) != OAM_ZERO) &&
            (oam_strcmp((const char *)oam_xmlNodeGetContent(p_cell_spec_params->Carrier[freq_indx],
                                                            "X_VENDOR_HYBRID_PHY_CELLID_RANGE"), OAM_INVALID_STR) != OAM_ZERO))
    {    
        lclTemp_value=oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Carrier[freq_indx],"X_VENDOR_HYBRID_PHY_CELLID_START"));
        per_freq_pci_ranges->hybrid_pci_start = lclTemp_value;

        lclTemp_value = oam_xml_search_string_to_integer((char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->Carrier[freq_indx],"X_VENDOR_HYBRID_PHY_CELLID_RANGE"),
                PhyCellidRange,SON_OAM_PHY_CELLID_RANGE_COUNT);
        per_freq_pci_ranges->hybrid_pci_range = oam_map_pci_range(
                (rrm_oam_cell_id_range_et)lclTemp_value);
    }       

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/* SPR 15238 END */
/* SPR 15917 START */
/*******************************************************************************
 *  FUNCTION NAME    : oam_find_primary_plmnid 
 *  DESCRIPTION      : This function is used to find the primary PLMNID 
 *                     from the PLMNList 
 *  PARAMETERS
 *      IN           : temp
 *
 *      OUT          : NONE
 *
 *  RETURNS          : Primary PLMNID
*******************************************************************************/
void oam_find_primary_plmnid(Char8 **temp,
        XML_struct_cell_config *p_cell_spec_params)
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 index = OAM_ZERO;
    UInt8 num_plmn_entries = OAM_ZERO;
    oam_bool_et plmn_enable = OAM_FALSE;
    oam_bool_et plmn_is_primary = OAM_FALSE;
    *temp = OAM_NULL;

    num_plmn_entries = oam_atoi((const char *)oam_xmlNodeGetContent(
                p_cell_spec_params->EPC,"PLMNListNumberOfEntries"));

    for(index = OAM_ZERO;index <num_plmn_entries;index++)
    {
        plmn_enable = (oam_bool_et) oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PLMNList[index],"Enable"));

        plmn_is_primary = (oam_bool_et) oam_atoi((const char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PLMNList[index],"IsPrimary"));
        if((OAM_TRUE == plmn_enable) && (OAM_TRUE == plmn_is_primary))
        {
            /* First Enabled PLMN entry with
             * IsPrimary set is the Primary PLMNID*/
            *temp =(char *)oam_xmlNodeGetContent(
                    p_cell_spec_params->PLMNList[index],"PLMNID");
            break;
        }
    }
    OAM_FUN_EXIT_TRACE();
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_validate_plmnList 
 *  DESCRIPTION      : This function is used to validate the PLMNList 
 *  PARAMETERS
 *      IN           : num_plmn_entries
 *
 *      OUT          : NONE
 *
 *  RETURNS          : OAM_SUCCESS/OAM_FAILURE
*******************************************************************************/
oam_return_et oam_validate_plmnList(UInt8 num_plmn_entries,
        XML_struct_cell_config *p_cell_spec_params)
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 idx = OAM_ZERO;
    UInt8 isPrimary_count = OAM_ZERO;
    for(idx = OAM_ZERO;idx < num_plmn_entries; idx++)
    {
        if(OAM_TRUE == (oam_bool_et) oam_atoi((const char *)oam_xmlNodeGetContent(
                        p_cell_spec_params->PLMNList[idx],"Enable")))
        {
            if(OAM_TRUE == (oam_bool_et) oam_atoi((const char *)oam_xmlNodeGetContent(
                            p_cell_spec_params->PLMNList[idx],"IsPrimary")))
            {
                isPrimary_count++;
            }

        }
    }
    if(isPrimary_count != OAM_ONE)
    {
        OAM_LOG(OAM,OAM_WARNING,"Multiple PLMNs have IsPrimary set: Invalid Configuration");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/* SPR 15917 END */

/* Spr 17753 Changes Start*/
/****************************************************************************
 * FUNCTION NAME  : oam_populate_serving_cell_phy_cell_id 
 * DESCRIPTION    : This function is used to populate
 *                  the serving cell phycellId, it fills the pci for serving
 *                  cell which is not conflicting with the INTRA Freq NBR 
 * PARAMETERS
 *     IN         : NONE
 *
 *     OUT        : NONE
 *
 * RETURNS        : VOID
****************************************************************************/
void oam_populate_serving_cell_phy_cell_id(oam_rrm_cell_config_req_t *p_rrm_cellconfig,
                                           XML_struct_cell_config     *p_cell_spec_params )
{

    UInt8 *p_temp = OAM_NULL;
    UInt8 *value = OAM_NULL;
    UInt8 *range_val = OAM_NULL;
    UInt16 start_val = OAM_ZERO;
    UInt16 end_val = OAM_ZERO;
    UInt16 count = OAM_ZERO;
    UInt16 PhyCellId = 0xFFFF;

    OAM_FUN_ENTRY_TRACE();

    p_temp = ((UInt8 *)oam_xmlNodeGetContent(
                p_cell_spec_params->RF_1,"PhyCellID"));         

    value = (UInt8 *)strtok_r((char *)p_temp,",",(char **)&p_temp);

    while(OAM_NULL != value)
    {                                                                                               
        if(OAM_NULL != strstr((char *)value,".."))
        {
            range_val = (UInt8 *)strtok_r((char *)value,"..",(char **)&value);
            start_val = oam_atoi((char *)range_val);
            range_val = (UInt8 *)strtok_r(OAM_NULL,"..",(char **)&value);
            end_val = oam_atoi((char *)range_val);
            for(count = start_val; count <= end_val ;count++)
            {
                if(OAM_TRUE == is_pci_available_for_seving_cell(count,p_rrm_cellconfig))
                {
                    PhyCellId = count;
                    break;
                }
            }
            if(PhyCellId != 0xFFFF)
            {
                p_rrm_cellconfig->ran_info.
                    rf_params.rf_configurations.phy_cell_id = PhyCellId;	
                break;      
            }
            else
            {
                start_val = end_val = OAM_ZERO;
                value = (UInt8 *)strtok_r(OAM_NULL,",",(char **)&p_temp);
            }
        }
        else if((oam_atoi((const char *)value) >= MIN_PHYCELLID)
                && 	oam_atoi((const char *)value) <= MAX_PHYCELLID)
        {
            if(OAM_TRUE == is_pci_available_for_seving_cell(oam_atoi((const char *)value),p_rrm_cellconfig))
            {     
                PhyCellId = oam_atoi((const char *)value);
            }
            if(PhyCellId != 0xFFFF)
            {
                p_rrm_cellconfig->ran_info.
                    rf_params.rf_configurations.phy_cell_id = PhyCellId;
                break;
            }
            else
            { 
                value = (UInt8 *)strtok_r(OAM_NULL,",",(char **)&p_temp);
            }
        }
    }
    if(PhyCellId == 0xFFFF)
    {
        PhyCellId = oam_atoi((char *)oam_xmlNodeGetContent(
               p_cell_spec_params->RF_1,"PhyCellID"));

        p_rrm_cellconfig->ran_info.
            rf_params.rf_configurations.phy_cell_id = PhyCellId;

        OAM_LOG(OAM,OAM_ERROR,"\nAll pci present in configuration file"
                " are conflicting with neighbors." 
                " Selecting first PCI = %d"
                " for servig cell from the available pci list",PhyCellId);
    }
    else
    {
        OAM_LOG(OAM,OAM_INFO,"Populated pci for serving cell = %d",PhyCellId);
    }

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 * FUNCTION NAME  : is_pci_available_for_seving_cell 
 * DESCRIPTION    : This function is used to validate the input pci 
 *                  if it is conflicting with the INTRA Freq NBR or not 
 * PARAMETERS
 *     IN         : pci 
 *
 *     OUT        : NONE
 *
 * RETURNS        : OAM_FALSE/OAM_TRUE 
****************************************************************************/
oam_bool_et 
is_pci_available_for_seving_cell(UInt16 pci,
                                 oam_rrm_cell_config_req_t *p_rrm_cellconfig)
{
    UInt16 count1 = OAM_ZERO;
    UInt16 intra_freq_nr_list_size = OAM_ZERO;
    oam_bool_et retVal = OAM_FALSE;

    OAM_FUN_ENTRY_TRACE();

    intra_freq_nr_list_size = p_rrm_cellconfig->ran_info.ncl_params.lte_ncl.
                               num_valid_intra_freq_cell;

    while (count1 < intra_freq_nr_list_size)
    {     
        if( p_rrm_cellconfig->ran_info.
                ncl_params.lte_ncl.intra_freq_cells[count1].phy_cell_id == pci)
        {     
            break;
        }     
        count1++;
    }     
    if (count1 == intra_freq_nr_list_size)
    {    
        OAM_LOG(OAM,OAM_INFO,"PCI = %d,is available for serving cell",pci);
        retVal = OAM_TRUE;
    }   
    OAM_FUN_EXIT_TRACE();
    return retVal; 
}
/* Spr 17753 Changes End*/
/*SPR 21889 Start*/
/*******************************************************************************
 *  FUNCTION NAME    : oam_fill_process_name
 *  DESCRIPTION      : This function fills the actual name of binary
 *                     corresponding to the operator name given to the binary
 *                     in the Proprietary_eNodeB_Data_Model.xml file
 *  PARAMETERS
 *      IN           : Pointers to string of argument (p_args)
 *                     Pointer to string working as separator between arguments
 *
 *      OUT          : Pointers to count
 *
 *  RETURNS          : OAM_SUCCESS on successful processing and OAM_FAILURE in
 *                     case of error 
 *******************************************************************************/
oam_return_et
oam_fill_process_name(Char8 *p_dst_name, Char8 *p_src_name)
{
    UInt8 i;

    OAM_FUN_ENTRY_TRACE();

    p_dst_name[OAM_ZERO] = '\0';
    for (i = OAM_ZERO; i < sizeof(g_oam_bin_name_mapping_table)/sizeof(g_oam_bin_name_mapping_table[OAM_ZERO]); i++)
    {
        if (OAM_ZERO == oam_strcmp(g_oam_bin_name_mapping_table[i].p_bin_nick_name, p_src_name))
        {
            oam_strncpy(p_dst_name, g_oam_bin_name_mapping_table[i].p_bin_real_name, MAX_BIN_NAME_LEN);
            p_dst_name[MAX_BIN_NAME_LEN - OAM_ONE] = '\0';
        }
    }

    if (p_dst_name[OAM_ZERO] == '\0')
    {
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_count_num_of_args
 *  DESCRIPTION      : This function count number of arguments present in argument string
 *  PARAMETERS
 *      IN           : Pointers to string of argument (p_args)
 *                     Pointer to string working as separator between arguments
 *
 *      OUT          : Pointers to count
 *
 *  RETURNS          : OAM_SUCCESS on successful processing and OAM_FAILURE in
 *                     case of error 
 *******************************************************************************/
oam_return_et
oam_count_num_of_args(Char8 *p_args, Char8 *p_sep, UInt8 *p_count)
{
    UInt8   count       = OAM_ZERO;
    Char8   *p_token    = OAM_NULL;
    Char8   *p_tmp_str   = OAM_NULL;
    oam_error_code_et err = NO_ERROR;

	OAM_NULL_CHECK(p_args != OAM_NULL);	
	OAM_NULL_CHECK(p_sep != OAM_NULL);	
	OAM_NULL_CHECK(p_count != OAM_NULL);	

    OAM_FUN_ENTRY_TRACE();
    if (OAM_SUCCESS != oam_mem_alloc(oam_strlen(p_args) + OAM_ONE, (void*)&p_tmp_str, &err))
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to allocate memory");
        return OAM_FAILURE;
    }
    /* CID 147322 fix start */
    oam_memset(p_tmp_str,OAM_ZERO,oam_strlen(p_args) + OAM_ONE);
    /* CID 147322 fix end */


    oam_strcpy(p_tmp_str, p_args);
    p_token = strtok(p_tmp_str, p_sep);

    while (OAM_NULL != p_token)
    {
        p_token = strtok(OAM_NULL, p_sep);
        count++;
    }

    oam_mem_free(p_tmp_str, &err);
    *p_count = count;
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_fill_process_args
 *  DESCRIPTION      : This function convert list of arguments in the form of array
 *  PARAMETERS
 *      IN           : Pointers to string of argument (p_args)
 *
 *      OUT          : Pointers to argument array (p_args_arr)
 *
 *  RETURNS          : OAM_SUCCESS on successful processing and OAM_FAILURE in
 *                     case of error 
 *******************************************************************************/
oam_return_et
oam_fill_process_args(Char8 *p_bin_name, oam_process_info_t *p_proc_info, Char8 *p_args)
{
    UInt8 count             = OAM_ZERO;
    UInt8 i                 = OAM_ZERO;
    oam_error_code_et err   = NO_ERROR;
    Char8   *p_token        = OAM_NULL;
    UInt16  len             = OAM_ZERO;
    UInt16  num_of_args     = OAM_ZERO;


    OAM_FUN_ENTRY_TRACE();
    if (OAM_SUCCESS != oam_count_num_of_args(p_args, " ", &count))
    {
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    num_of_args = (count + OAM_TWO) * sizeof(SInt8*);
    /* Get space for number of argument + one additional space for filling NULL in the end of array */
    if (OAM_SUCCESS != oam_mem_alloc(num_of_args, (void*)&(p_proc_info->pp_args), &err))
    {
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    
    /* Fill the binary name first */
    len = oam_strlen(p_bin_name) + OAM_ONE;
    if (OAM_SUCCESS != oam_mem_alloc(len, (void*)&(p_proc_info->pp_args[i]), &err))
    {
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    oam_strcpy(p_proc_info->pp_args[i], p_bin_name);
    i++;

    p_token = strtok(p_args, " ");

    while ((OAM_NULL != p_token) && (i <= count))
    {
        len = oam_strlen(p_token) + OAM_ONE;
        if (OAM_SUCCESS != oam_mem_alloc(len, (void*)&(p_proc_info->pp_args[i]), &err))
        {
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_strcpy(p_proc_info->pp_args[i], p_token);
        p_token = strtok(OAM_NULL, " ");
        i++;
    }

    p_proc_info->pp_args[i] = OAM_NULL;

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*SPR 23209 FIXED START */
/*******************************************************************************
 *  FUNCTION NAME    : oam_populate_l2_mac_init_mocn_param
 *  DESCRIPTION      : This function used to populate the MOCN parameters
 *                     for MAC INIT.
 *  PARAMETERS
 *      IN           : None
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
*******************************************************************************/
oam_return_et
oam_populate_l2_mac_init_mocn_param(
 XML_struct_cell_config     *p_cell_spec_params,
 oam_rrm_cell_config_req_t  *p_rrm_cellconfig,
 /* SPR 23504/SES-341 Fix Start */
 oam_l2_req_t               *p_mac_req, 
 UInt8                      oam_cell_index,
 UInt8                      l2_instance
 /* SPR 23504/SES-341 Fix End */
)
{
	UInt16 dl_resource_per_operator       = OAM_ZERO;
	UInt16 ul_resource_per_operator       = OAM_ZERO;
	UInt16 dl_total_resource_count        = OAM_ZERO;
	UInt16 ul_total_resource_count        = OAM_ZERO;
	UInt8  operator_id                    = MOCN_OPERATOR_ID_START;
	UInt8  configured_operator_count      = OAM_ZERO;
	UInt8  valid_operator_count           = OAM_ZERO;
	Char8  temp_plmnid[OAM_SEVEN]         = {OAM_ZERO};
	Char8  *temp                          = OAM_NULL;
	UInt32 count                          = OAM_ZERO;

	rrm_oam_cell_plmn_info_t p_mocn_plmn;
    /* SPR 23504/SES-341 Fix Start */
    UInt8 l2_cell_index = OAM_ZERO;
	oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;
	static oam_l2_instance_flag_t oam_l2_instance_flag[OAM_MAX_NUM_L2_INSTANCE];
    /* SPR 23504/SES-341 Fix End */
    oam_mac_init_req_params_t *p_mac_init =
        &p_mac_req->oam_mac_req.mac_init_req;

	OAM_FUN_ENTRY_TRACE();

    /* SPR 23504/SES-341 Fix Start */
    if(oam_l2_instance_flag[l2_instance].instance_id_flag == OAM_ZERO)
    {
        oam_l2_instance_flag[l2_instance].instance_id_flag = OAM_ONE;	
        l2_cell_index = OAM_ZERO;
    }
    else
    {	
        oam_l2_instance_flag[l2_instance].init_cell_cnt++;
        l2_cell_index = oam_l2_instance_flag[l2_instance].init_cell_cnt;
    }
    if(!l2_cell_index) {
	oam_memset(&(p_mac_init->mocnParams),
					OAM_ZERO , sizeof(MocnParams));
    }
    else
    {
		p_mac_cell_init = &p_mac_req->oam_mac_req.
            mac_init_cell_req[l2_cell_index - 1];
        oam_memset(&(p_mac_cell_init->mocnParams),
                OAM_ZERO , sizeof(MocnParams));
	}
    /* SPR 23504/SES-341 Fix End */

	temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->mocn_params,
					"mocn_enable");
    lclTemp_value = oam_atoi(temp);
	/* If MOCN feature is enabled by operator */
	if(OAM_ONE == lclTemp_value)
	{
        /* SPR 23504/SES-341 Fix Start */
        if(!l2_cell_index) {
            if( (p_mac_init->dlSchedulerStrategy == QOS_SCHEDULER_STRATEGY) &&
                    (p_mac_init->ulSchedulerStrategy == QOS_SCHEDULER_STRATEGY ))
            {
                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operator_list,
                        "OperatorListNumberofEntries");
                /* Validate OperatorListNumberofEntries */
                if( OAM_FAILURE == 
                        oam_range_validation_for_mocn_param(temp,MIN_MOCN_OPERATOR,MAX_MOCN_OPERATOR))
                {
                    OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for OperatorListNumberofEntries");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
                configured_operator_count = oam_atoi(temp);

                /* If number of operators configured is greater than 1, only
                   then  MOCN specific entries will be read otherwise disable the MOCN*/
                if( OAM_ONE < configured_operator_count)
                {
                    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->mocn_params,
                            "prbUsageMeasForgettingFactor");
                    /* Validate prbUsageMeasForgettingFactor */
                    if( OAM_FAILURE ==
                            oam_range_validation_for_mocn_param(temp,MIN_FORGETTING_FACTOR,MAX_FORGETTING_FACTOR))
                    {
                        OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for prbUsageMeasForgettingFactor");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }

                    p_mac_init->mocnParams.prbUsageMeasForgettingFactor = lclTemp_value;
                    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->mocn_params,
                            "prbUsageMeasResetPeriod");
                    /* Validate prbUsageMeasResetPeriod */
                    if( OAM_FAILURE ==
                            oam_range_validation_for_mocn_param(temp,MIN_RESETPERIOD,MAX_RESETPERIOD))
                    {
                        OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for prbUsageMeasResetPeriod");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                    p_mac_init->mocnParams.prbUsageMeasResetPeriod = lclTemp_value;
                    OAM_LOG(OAM, OAM_DETAILED, "Total number of configured operators for MOCN [%d]",
                            configured_operator_count);

                    /* Reading resource sharing information per operator */ 
                    for (count = OAM_ZERO;count < configured_operator_count;count++) 
                    {
                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "plmnid");
                        oam_memset(&p_mocn_plmn, OAM_ZERO , sizeof(rrm_oam_cell_plmn_info_t));
                        if( (OAM_SUCCESS != oam_convert_plmnid(temp_plmnid,temp)) ||
                                (OAM_SUCCESS != oam_fill_mcc_mnc_from_plmnid(temp_plmnid ,&p_mocn_plmn )))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid PLMN Configured for %d MOCN operator",
                                    count+OAM_ONE);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        /* 
                         ** Check that this PLMN Id is presnet in List of PLMN ids to be 
                         ** configured in SIB1.
                         */
                        if(OAM_FAILURE == oam_validate_mocn_operator_plmn_id_with_sib1(&p_mocn_plmn, p_rrm_cellconfig))
                        {
                            OAM_LOG(OAM, OAM_ERROR, "PLMN ID [%d] is not present in PLMN List of SIB1 "
                                    " Skipping this operator configuration", oam_atoi(temp));
                            continue;
                        }
                        /* 
                         ** validate the duplicate entry in MOCN operator list
                         ** if no duplicate entry found, then update the global
                         ** array of plmn list otherwise return failure
                         */
                        if(OAM_FAILURE == oam_update_plmnid_in_mocn_plmn_list(&p_mocn_plmn, oam_cell_index))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Duplicate PLMN id [%d] present for MOCN configuraton"
                                    "Disable MOCN feature implicitly",
                                    oam_atoi(temp));
                            OAM_FUN_EXIT_TRACE();
                            return OAM_SUCCESS;
                        }

                        p_mac_init->mocnParams.mocnPerOperatorParams[valid_operator_count].
                            operator_id = operator_id;

                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "dedicatedDLResource");
                        if( OAM_FAILURE ==
                                oam_range_validation_for_mocn_param(temp,MIN_RB_PERCENTAGE,MAX_RB_PERCENTAGE))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for dedicatedDLResource");
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        dl_resource_per_operator+= lclTemp_value;

                        p_mac_init->mocnParams.mocnPerOperatorParams[valid_operator_count].
                            dedicatedDLPRBsPerOperator = lclTemp_value;

                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "dedicatedULResource");
                        if( OAM_FAILURE ==
                                oam_range_validation_for_mocn_param(temp,MIN_RB_PERCENTAGE,MAX_RB_PERCENTAGE))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for dedicatedULResource");
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        ul_resource_per_operator += lclTemp_value;

                        p_mac_init->    
                            mocnParams.mocnPerOperatorParams[valid_operator_count].
                            dedicatedULPRBsPerOperator = lclTemp_value;

                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "reservedDLResource");
                        if( OAM_FAILURE ==
                                oam_range_validation_for_mocn_param(temp,MIN_RB_PERCENTAGE,MAX_RB_PERCENTAGE))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for reservedDLResource");
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        dl_resource_per_operator += lclTemp_value;

                        p_mac_init->mocnParams.mocnPerOperatorParams[valid_operator_count].
                            reservedDLPRBsPerOperator = lclTemp_value;

                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "reservedULResource");
                        if( OAM_FAILURE ==
                                oam_range_validation_for_mocn_param(temp,MIN_RB_PERCENTAGE,MAX_RB_PERCENTAGE))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for reservedDLResource");
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        ul_resource_per_operator += lclTemp_value;

                        p_mac_init->	
                            mocnParams.mocnPerOperatorParams[valid_operator_count].
                            reservedULPRBsPerOperator = lclTemp_value;

                        OAM_LOG(OAM, OAM_DETAILED, "Total Resource(%) allocated to operator [%d] is DL[%d] UL[%d]",
                                valid_operator_count+OAM_ONE,dl_resource_per_operator,ul_resource_per_operator);

                        dl_total_resource_count += dl_resource_per_operator;
                        ul_total_resource_count += ul_resource_per_operator;

                        /*
                         ** total_resource_count is used to keep track of the total Percent PRBs
                         ** being allocated among the operators.Later this parameter is validated
                         ** to verify that 100% is not utilized.
                         */
                            dl_resource_per_operator = OAM_ZERO;
                        ul_resource_per_operator = OAM_ZERO;

                        valid_operator_count++;
                        operator_id++;
                    }

                    if(OAM_ONE < valid_operator_count)
                    {
                        if( (MOCN_PARTITION_LIMIT < dl_total_resource_count) ||
                                (MOCN_PARTITION_LIMIT < ul_total_resource_count))

                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Configured Resource Partition DL[%d] UL[%d]"
                                    "exceededs the limit of 100, Disable MOCN feature implicitly",
                                    dl_total_resource_count,ul_total_resource_count);
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Total Resources(%) allocated for operators DL[%d] UL[%d]",
                                    dl_total_resource_count,ul_total_resource_count);
                            /*
                             ** Check if operators configured for resource sharing is lesser
                             ** than the total operators in SIB1 , then we can only proceed with MOCN if
                             ** Few PRBS are left for the operators that are not part of 
                             ** resource sharing
                             */
                            if(p_rrm_cellconfig->epc_info.epc_params.general_epc_params.num_valid_plmn > 
                                    valid_operator_count )
                            {
                                if((ul_total_resource_count == MOCN_PARTITION_LIMIT) 
                                        || ( dl_total_resource_count == MOCN_PARTITION_LIMIT ))
                                {
                                    OAM_LOG(OAM, OAM_DETAILED, "Configured Resource Partition is"
                                            "100 %, Can't create a common PRB pool for non configured "
                                            "MOCN operator PLMN. Disable MOCN feature implicitly");
                                }
                                else
                                {
                                    OAM_LOG(OAM, OAM_DETAILED,"Update MOCN params in MAC INIT req,"
                                            " to accomodate all PLMNs Broadcasted in SIB1");
                                    p_mac_init->mocnParams.numOfOperator = valid_operator_count;
                                    oam_update_l2_mac_init_mocn_param(p_rrm_cellconfig, p_mac_req, l2_cell_index, oam_cell_index);
                                    OAM_LOG(OAM, OAM_DETAILED,"Operator configuration for MOCN is valid,"
                                            "MOCN is ENABLED in system");
                                }
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_DETAILED,"Operator configuration for MOCN is valid,"
                                        "MOCN is ENABLED in system");
                                /*
                                 ** Update the operator count in MAC init req with valid operator count. i.e.
                                 ** For which MOCN will be enabled.
                                 */
                                p_mac_init->mocnParams.numOfOperator = valid_operator_count;
                            }
                        }
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED,"Insufficient(0/1) num of configured/valid operators for "
                                "enabling MOCN resource partition.Disable MOCN feature implicitly");
                    }
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED,"Insufficient(0/1) num of operators for enabling MOCN resource partition"
                            "Disable MOCN feature implicitly");
                }
            }
            else
            {
                /* If MOCN feature is Disabled by operator */
                OAM_LOG(OAM, OAM_DETAILED, "MOCN Feature is Enabled, But type of scheduler strategy is" 
                        "not QOS, Disable MOCN feature implicitly");
            }
        }
        else
        {
            if( (p_mac_cell_init->dlSchedulerStrategy == QOS_SCHEDULER_STRATEGY) &&
                    (p_mac_cell_init->ulSchedulerStrategy == QOS_SCHEDULER_STRATEGY ))
            {
                temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operator_list,
                        "OperatorListNumberofEntries");
                /* Validate OperatorListNumberofEntries */
                if( OAM_FAILURE == 
                        oam_range_validation_for_mocn_param(temp,MIN_MOCN_OPERATOR,MAX_MOCN_OPERATOR))
                {
                    OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for OperatorListNumberofEntries");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
                configured_operator_count = oam_atoi(temp);

                /* If number of operators configured is greater than 1, only
                   then  MOCN specific entries will be read otherwise disable the MOCN*/
                if( OAM_ONE < configured_operator_count)
                {
                    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->mocn_params,
                            "prbUsageMeasForgettingFactor");
                    /* Validate prbUsageMeasForgettingFactor */
                    if( OAM_FAILURE ==
                            oam_range_validation_for_mocn_param(temp,MIN_FORGETTING_FACTOR,MAX_FORGETTING_FACTOR))
                    {
                        OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for prbUsageMeasForgettingFactor");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }

                    p_mac_cell_init->mocnParams.prbUsageMeasForgettingFactor = lclTemp_value;
                    temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->mocn_params,
                            "prbUsageMeasResetPeriod");
                    /* Validate prbUsageMeasResetPeriod */
                    if( OAM_FAILURE ==
                            oam_range_validation_for_mocn_param(temp,MIN_RESETPERIOD,MAX_RESETPERIOD))
                    {
                        OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for prbUsageMeasResetPeriod");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                    p_mac_cell_init->mocnParams.prbUsageMeasResetPeriod = lclTemp_value;
                    OAM_LOG(OAM, OAM_DETAILED, "Total number of configured operators for MOCN [%d]",
                            configured_operator_count);

                    /* Reading resource sharing information per operator */ 
                    for (count = OAM_ZERO;count < configured_operator_count;count++) 
                    {
                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "plmnid");
                        oam_memset(&p_mocn_plmn, OAM_ZERO , sizeof(rrm_oam_cell_plmn_info_t));
                        if( (OAM_SUCCESS != oam_convert_plmnid(temp_plmnid,temp)) ||
                                (OAM_SUCCESS != oam_fill_mcc_mnc_from_plmnid(temp_plmnid ,&p_mocn_plmn )))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid PLMN Configured for %d MOCN operator",
                                    count+OAM_ONE);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        /* 
                         ** Check that this PLMN Id is presnet in List of PLMN ids to be 
                         ** configured in SIB1.
                         */
                        if(OAM_FAILURE == oam_validate_mocn_operator_plmn_id_with_sib1(&p_mocn_plmn, p_rrm_cellconfig))
                        {
                            OAM_LOG(OAM, OAM_ERROR, "PLMN ID [%d] is not present in PLMN List of SIB1 "
                                    " Skipping this operator configuration", oam_atoi(temp));
                            continue;
                        }
                        /* 
                         ** validate the duplicate entry in MOCN operator list
                         ** if no duplicate entry found, then update the global
                         ** array of plmn list otherwise return failure
                         */
                        if(OAM_FAILURE == oam_update_plmnid_in_mocn_plmn_list(&p_mocn_plmn, oam_cell_index))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,"Duplicate PLMN id [%d] present for MOCN configuraton"
                                    "Disable MOCN feature implicitly",
                                    oam_atoi(temp));
                            OAM_FUN_EXIT_TRACE();
                            return OAM_SUCCESS;
                        }

                        p_mac_cell_init->mocnParams.mocnPerOperatorParams[valid_operator_count].
                            operator_id = operator_id;

                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "dedicatedDLResource");
                        if( OAM_FAILURE ==
                                oam_range_validation_for_mocn_param(temp,MIN_RB_PERCENTAGE,MAX_RB_PERCENTAGE))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for dedicatedDLResource");
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        dl_resource_per_operator+= lclTemp_value;

                        p_mac_cell_init->mocnParams.mocnPerOperatorParams[valid_operator_count].
                            dedicatedDLPRBsPerOperator = lclTemp_value;

                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "dedicatedULResource");
                        if( OAM_FAILURE ==
                                oam_range_validation_for_mocn_param(temp,MIN_RB_PERCENTAGE,MAX_RB_PERCENTAGE))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for dedicatedULResource");
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        ul_resource_per_operator += lclTemp_value;

                        p_mac_cell_init->    
                            mocnParams.mocnPerOperatorParams[valid_operator_count].
                            dedicatedULPRBsPerOperator = lclTemp_value;

                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "reservedDLResource");
                        if( OAM_FAILURE ==
                                oam_range_validation_for_mocn_param(temp,MIN_RB_PERCENTAGE,MAX_RB_PERCENTAGE))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for reservedDLResource");
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        dl_resource_per_operator += lclTemp_value;

                        p_mac_cell_init->mocnParams.mocnPerOperatorParams[valid_operator_count].
                            reservedDLPRBsPerOperator = lclTemp_value;

                        temp = (Char8*)oam_xmlNodeGetContent(p_cell_spec_params->operators_info[count],
                                "reservedULResource");
                        if( OAM_FAILURE ==
                                oam_range_validation_for_mocn_param(temp,MIN_RB_PERCENTAGE,MAX_RB_PERCENTAGE))
                        {
                            OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value for reservedDLResource");
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        ul_resource_per_operator += lclTemp_value;

                        p_mac_cell_init->	
                            mocnParams.mocnPerOperatorParams[valid_operator_count].
                            reservedULPRBsPerOperator = lclTemp_value;

                        OAM_LOG(OAM, OAM_DETAILED, "Total Resource(%) allocated to operator [%d] is DL[%d] UL[%d]",
                                valid_operator_count+OAM_ONE,dl_resource_per_operator,ul_resource_per_operator);

                        dl_total_resource_count += dl_resource_per_operator;
                        ul_total_resource_count += ul_resource_per_operator;

                        /*
                         ** total_resource_count is used to keep track of the total Percent PRBs
                         ** being allocated among the operators.Later this parameter is validated
                         ** to verify that 100% is not utilized.
                         */
                            dl_resource_per_operator = OAM_ZERO;
                        ul_resource_per_operator = OAM_ZERO;

                        valid_operator_count++;
                        operator_id++;
                    }

                    if(OAM_ONE < valid_operator_count)
                    {
                        if( (MOCN_PARTITION_LIMIT < dl_total_resource_count) ||
                                (MOCN_PARTITION_LIMIT < ul_total_resource_count))

                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Configured Resource Partition DL[%d] UL[%d]"
                                    "exceededs the limit of 100, Disable MOCN feature implicitly",
                                    dl_total_resource_count,ul_total_resource_count);
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Total Resources(%) allocated for operators DL[%d] UL[%d]",
                                    dl_total_resource_count,ul_total_resource_count);
                            /*
                             ** Check if operators configured for resource sharing is lesser
                             ** than the total operators in SIB1 , then we can only proceed with MOCN if
                             ** Few PRBS are left for the operators that are not part of 
                             ** resource sharing
                             */
                            if(p_rrm_cellconfig->epc_info.epc_params.general_epc_params.num_valid_plmn > 
                                    valid_operator_count )
                            {
                                if((ul_total_resource_count == MOCN_PARTITION_LIMIT) 
                                        || ( dl_total_resource_count == MOCN_PARTITION_LIMIT ))
                                {
                                    OAM_LOG(OAM, OAM_DETAILED, "Configured Resource Partition is"
                                            "100 %, Can't create a common PRB pool for non configured "
                                            "MOCN operator PLMN. Disable MOCN feature implicitly");
                                }
                                else
                                {
                                    OAM_LOG(OAM, OAM_DETAILED,"Update MOCN params in MAC INIT req,"
                                            " to accomodate all PLMNs Broadcasted in SIB1");
                                    p_mac_cell_init->mocnParams.numOfOperator = valid_operator_count;
                                    oam_update_l2_mac_init_mocn_param(p_rrm_cellconfig, p_mac_req, l2_cell_index, oam_cell_index);
                                    OAM_LOG(OAM, OAM_DETAILED,"Operator configuration for MOCN is valid,"
                                            "MOCN is ENABLED in system");
                                }
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_DETAILED,"Operator configuration for MOCN is valid,"
                                        "MOCN is ENABLED in system");
                                /*
                                 ** Update the operator count in MAC init req with valid operator count. i.e.
                                 ** For which MOCN will be enabled.
                                 */
                                p_mac_cell_init->mocnParams.numOfOperator = valid_operator_count;
                            }
                        }
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED,"Insufficient(0/1) num of configured/valid operators for "
                                "enabling MOCN resource partition.Disable MOCN feature implicitly");
                    }
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED,"Insufficient(0/1) num of operators for enabling MOCN resource partition"
                            "Disable MOCN feature implicitly");
                }
            }
        }
        /* SPR 23504/SES-341 Fix End */
    }
    else
    {
		/* If MOCN feature is Disabled by operator */
		OAM_LOG(OAM, OAM_DETAILED, "MOCN Feature is Disabled by operator");
	}

	OAM_FUN_EXIT_TRACE();    
	return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_validate_mocn_operator_plmn_id_with_sib1
 *  DESCRIPTION      : This function is used to validate the plmn id presence in
 *                     Cell Config structure
 *  PARAMETERS
 *      IN           : RRM cell PLMN ID structure
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
*******************************************************************************/
oam_return_et 
oam_validate_mocn_operator_plmn_id_with_sib1
(
    rrm_oam_cell_plmn_info_t *p_mocn_plmn,
    oam_rrm_cell_config_req_t  *p_rrm_cellconfig
)
{
    oam_return_et ret_val = OAM_FAILURE;
    Char8  num_plmn_cell_config = 0;
    UInt8 count = 0;

    OAM_LOG(OAM, OAM_DETAILED,"Check configured operator PLMN MCC[%d][%d][%d] , MNC [%d][%d][%d] in "
                   " Cell config configuration for SIB1 ",
                     p_mocn_plmn->mcc[0],
                     p_mocn_plmn->mcc[1],
                     p_mocn_plmn->mcc[2],
                     p_mocn_plmn->mnc[0],
                     p_mocn_plmn->mnc[1],
                     p_mocn_plmn->mnc[2]);

    /* check whether  p_mocn_list_val is subset in cell config or not */
    num_plmn_cell_config =  p_rrm_cellconfig->epc_info.epc_params.general_epc_params.num_valid_plmn;
    OAM_LOG(OAM, OAM_DETAILED,"Number of PLMN IDs present in Cell Config [%d] for SIB1", num_plmn_cell_config);
    for(count = 0 ; count < num_plmn_cell_config ; count++)
    {
        OAM_LOG(OAM, OAM_DETAILED,"Cell SIB1 PLMN MCC[%d][%d][%d] , MNC [%d][%d][%d]",
                p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[count].plmn_info.mcc[0],
                p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[count].plmn_info.mcc[1],
                p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[count].plmn_info.mcc[2],
                p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[count].plmn_info.mnc[0],
                p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[count].plmn_info.mnc[1],
                p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[count].plmn_info.mnc[2]);

        if(!oam_memcmp(&(p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[count].plmn_info),
                    p_mocn_plmn,
                    sizeof(rrm_oam_cell_plmn_info_t)))
        {
            ret_val = OAM_SUCCESS;
            break;
        }
    }
    return ret_val;
}
/*******************************************************************************
 *  FUNCTION NAME    : fill_operator_id_in_rrm
 *  DESCRIPTION      : This function used to fill operator id in rrm structure 
 *                     if plmn id of cell config is present in mocn plmn list
 *                     else operator id is filled and it's corresponding resource
 *                     sharing information is filled as 0
 *  PARAMETERS
 *      IN           : NONE
 *
 *      OUT          : NONE
 *
 *  RETURNS          : NONE 
*******************************************************************************/
oam_return_et
oam_populate_rrm_cell_config_mocn_param(
 oam_rrm_cell_config_req_t  *p_rrm_cellconfig,
 /* SPR 23504/SES-341 Fix Start */
 oam_l2_req_t               *p_mac_req,
 UInt8                      oam_cell_index,
 UInt8                      l2_instance
 /* SPR 23504/SES-341 Fix End */
)
{

    UInt8 maxPlmnEpc      = OAM_ZERO;
    UInt8 len             = OAM_ZERO;
    UInt8 mocn_list_idx   = OAM_ZERO;
    oam_mac_init_req_params_t *p_mac_init =
        &p_mac_req->oam_mac_req.mac_init_req;

    /* SPR 23504/SES-341 Fix Start */
    UInt8 l2_cell_index = OAM_ZERO;
    UInt8 num_of_operators = OAM_ZERO;
	oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;
	static oam_l2_instance_flag_t oam_l2_instance_flag[OAM_MAX_NUM_L2_INSTANCE];

    if(oam_l2_instance_flag[l2_instance].instance_id_flag == OAM_ZERO)
    {
        oam_l2_instance_flag[l2_instance].instance_id_flag = OAM_ONE;	
        l2_cell_index = OAM_ZERO;
    }
    else
    {	
        oam_l2_instance_flag[l2_instance].init_cell_cnt++;
        l2_cell_index = oam_l2_instance_flag[l2_instance].init_cell_cnt;
    }
    if(l2_cell_index) {
        p_mac_cell_init = &p_mac_req->oam_mac_req.
            mac_init_cell_req[l2_cell_index - 1];
    }
    /* SPR 23504/SES-341 Fix End */
    OAM_FUN_ENTRY_TRACE();
    /* SPR 23504/SES-341 Fix Start */
    if(!l2_cell_index)
    {
        num_of_operators = p_mac_init->mocnParams.numOfOperator;
    }
    else
    {
        num_of_operators = p_mac_cell_init->mocnParams.numOfOperator;
    }
    if(OAM_ONE < num_of_operators)
    /* SPR 23504/SES-341 Fix End */
    {

        maxPlmnEpc =  p_rrm_cellconfig->epc_info.epc_params.general_epc_params.num_valid_plmn;

        for(len = OAM_ZERO; len < maxPlmnEpc; len++)
        {
            /*
             ** Check if PLMN Id present in Cell Config EPC params ( for broadcast in SIB1 )
             ** is also configured for MOCN operator configuration, then fill the operator id for the
             ** corresponding PLMN in Cell Config req for RRM
             */
            /* SPR 23504/SES-341 Fix Start */
            if( OAM_SUCCESS == oam_check_epc_plmn_in_mocn_list(&(p_rrm_cellconfig->
                            epc_info.epc_params.general_epc_params.
                            plmn_list[len].plmn_info),
                        &mocn_list_idx, oam_cell_index))
            {
                if(!l2_cell_index)
            {
                p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[len].
                    mocn_operator_identity = 
                    p_mac_init->mocnParams.mocnPerOperatorParams[mocn_list_idx].operator_id; 
                }
                else
                {
                    p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[len].
                        mocn_operator_identity = 
                        p_mac_cell_init->mocnParams.mocnPerOperatorParams[mocn_list_idx].operator_id; 
                }
                /* SPR 23504/SES-341 Fix End */
                p_rrm_cellconfig->epc_info.epc_params.general_epc_params.plmn_list[len].bitmask = RRM_OAM_MOCN_OPERATOR_IDENTITY_PRESENT;

            }
        }
    }
    else
    {
        /* If MOCN feature is Disabled by operator */
        OAM_LOG(OAM, OAM_DETAILED, "MOCN Feature is Disabled , system comes up without MOCN");
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_check_epc_plmn_in_mocn_list
 *  DESCRIPTION      : This function used to check the presence of PLMN Id that is
 *                     configured for broadcast in SIB1 in the MOCN operator 
 *                     configuration.
 *  PARAMETERS
 *      IN           : Cell Config EPC params
 *
 *      OUT          : p_mocn_list_idx
 *
 *  RETURNS          :  OAM_SUCCESS : If PLMN of EPC is present for MOCN
 *                      OAM_FAILURE : If PLMN of EPC is not present for MOCN
*******************************************************************************/
oam_return_et
oam_check_epc_plmn_in_mocn_list
(
 rrm_oam_cell_plmn_info_t *p_epc_plmn,
 /* SPR 23504/SES-341 Fix Start */
 UInt8 *p_mocn_list_idx,
 UInt8 cell_cnt
 /* SPR 23504/SES-341 Fix End */
 )
{

    UInt8 count           = OAM_ZERO;
    oam_return_et ret_val = OAM_FAILURE;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 23504/SES-341 Fix Start */
    for(count = OAM_ZERO; count < mocn_plmn_count[cell_cnt]; count++){

        if(!oam_memcmp(p_epc_plmn, &(mocn_plmn_list[cell_cnt][count]),sizeof(rrm_oam_cell_plmn_info_t)))
            /* SPR 23504/SES-341 Fix End */
        {
            *p_mocn_list_idx = count;
            ret_val = OAM_SUCCESS;
            break;
        }

    }
    OAM_FUN_EXIT_TRACE();
    return ret_val;
}
/*******************************************************************************
 *  FUNCTION NAME    : oam_update_plmnid_in_mocn_plmn_list
 *  DESCRIPTION      : This function used to validate the duplicate entry
 *                     of plmn id in mocn plmn list
 *  PARAMETERS
 *      IN           : RRM cell PLMN ID structure
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
*******************************************************************************/
oam_return_et 
oam_update_plmnid_in_mocn_plmn_list
(
 /* SPR 23504/SES-341 Fix Start */
    rrm_oam_cell_plmn_info_t *p_mocn_plmn,
    UInt8                   cell_cnt
 /* SPR 23504/SES-341 Fix End */
)
{
    oam_return_et ret_val = OAM_SUCCESS;
    UInt8 count = OAM_ZERO;
    
    OAM_FUN_ENTRY_TRACE();

    /* SPR 23504/SES-341 Fix Start */
    for(count = OAM_ZERO ; count < mocn_plmn_count[cell_cnt]; count++)
    {
        if(!oam_memcmp(&(mocn_plmn_list[cell_cnt][count]),
                    /* SPR 23504/SES-341 Fix End */
                    p_mocn_plmn,
                    sizeof(rrm_oam_cell_plmn_info_t)))
        {
            ret_val = OAM_FAILURE;
            break;
        }
    }

    if(ret_val)
    {
        /*
         ** If entry is not duplicate , update it in the list 
         */
        /* SPR 23504/SES-341 Fix Start */
        oam_memcpy(&(mocn_plmn_list[cell_cnt][(mocn_plmn_count[cell_cnt])++]), p_mocn_plmn, sizeof(rrm_oam_cell_plmn_info_t));
        /* SPR 23504/SES-341 Fix End */
    }

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_range_validation_for_mocn_param
 *  DESCRIPTION      : This function used to validate the range of MOCN 
 *                     parameters
 *  PARAMETERS
 *      IN           : Parameter, Minimum value, Maximum value
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
*******************************************************************************/
oam_return_et
oam_range_validation_for_mocn_param
(
   Char8  *param, 
   UInt16 lower_bound, 
   UInt16 upper_bound
)
{
	oam_return_et ret_val = OAM_FAILURE;
	OAM_FUN_ENTRY_TRACE();
	if (oam_strcmp(param, OAM_INVALID_STR)) 
	{
		lclTemp_value = oam_atoi(param);

		if ((lclTemp_value >= lower_bound)&&
						(lclTemp_value <= upper_bound)) 
		{
			ret_val = OAM_SUCCESS;
		}
		else
		{
			OAM_LOG(OAM, OAM_CRITICAL, "Invalid Value of parameter is %llu "
										"and range is from %d to %d\n",
										lclTemp_value,
										lower_bound,
										upper_bound);
		}
	}
	else
	{
		OAM_LOG(OAM, OAM_CRITICAL, "Failed to read mandatory parameter ");
	}
    /*CID 115048 fix start*/
	OAM_FUN_EXIT_TRACE();
	return ret_val;
    /*CID 115048 fix End*/
}

/*******************************************************************************
 *  FUNCTION NAME    : oam_update_l2_mac_init_mocn_param
 *  DESCRIPTION      : This function used to fill operator id to be sent to rrm
 *                     if PLMN Id present in Cell Config EPC params ( for
 *                     broadcast in SIB1 ) is NOT configured for MOCN operator
 *                     configuration.
 *  PARAMETERS
 *      IN           : None
 *
 *      OUT          : NONE
 *
 *  RETURNS          : NONE  
*******************************************************************************/
void
oam_update_l2_mac_init_mocn_param(
oam_rrm_cell_config_req_t  *p_rrm_cellconfig,
/* SPR 23504/SES-341 Fix Start */
oam_l2_req_t               *p_mac_req,
UInt8                      l2_cell_index,
UInt8                      oam_cell_index
/* SPR 23504/SES-341 Fix End */
)
{
	UInt8 maxPlmnEpc      = OAM_ZERO;
	UInt8 len             = OAM_ZERO;
	UInt8 mocn_list_idx   = OAM_ZERO;
	UInt8 last_allocated_opertor_id = OAM_ZERO;
    oam_mac_init_req_params_t *p_mac_init =
        &p_mac_req->oam_mac_req.mac_init_req;

    /* SPR 23504/SES-341 Fix Start */
    oam_mac_init_cell_req_params_t *p_mac_cell_init = OAM_NULL;
    if(l2_cell_index) {
        p_mac_cell_init = 
            &p_mac_req->oam_mac_req.mac_init_cell_req[l2_cell_index - 1];
    }
    /* SPR 23504/SES-341 Fix End */


	OAM_FUN_ENTRY_TRACE();

    /* SPR 23504/SES-341 Fix Start */
    if(!l2_cell_index)
    {
        last_allocated_opertor_id = p_mac_init->mocnParams.mocnPerOperatorParams[p_mac_init->mocnParams.numOfOperator - OAM_ONE].operator_id;
    }
    else
    {
        last_allocated_opertor_id = p_mac_cell_init->mocnParams.mocnPerOperatorParams[p_mac_cell_init->mocnParams.numOfOperator - OAM_ONE].operator_id;
    }
    /* SPR 23504/SES-341 Fix End */
	maxPlmnEpc = p_rrm_cellconfig->epc_info.epc_params.general_epc_params.num_valid_plmn;

	for(len = OAM_ZERO; len < maxPlmnEpc; len++)
	{
		/*
		 ** if PLMN Id present in Cell Config EPC params ( for broadcast in SIB1 )
		 ** is NOT configured for MOCN operator configuration, then fill this PLMN id in 
		 ** opeator configuration to be sent to MAC.
		 */

        /* SPR 23504/SES-341 Fix Start */
		if( OAM_FAILURE == oam_check_epc_plmn_in_mocn_list(&(p_rrm_cellconfig->
										epc_info.epc_params.general_epc_params.
										plmn_list[len].plmn_info),
										&mocn_list_idx, oam_cell_index))
		{
			oam_memcpy(&(mocn_plmn_list[oam_cell_index][mocn_plmn_count[oam_cell_index]]),&(p_rrm_cellconfig->
									epc_info.epc_params.general_epc_params.plmn_list[len].plmn_info),
									sizeof(rrm_oam_cell_plmn_info_t));

            if(!l2_cell_index)
            {
                p_mac_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    operator_id = ++last_allocated_opertor_id;
                p_mac_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    dedicatedDLPRBsPerOperator = OAM_ZERO;
                p_mac_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    dedicatedULPRBsPerOperator = OAM_ZERO;
                p_mac_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    reservedDLPRBsPerOperator = OAM_ZERO;
                p_mac_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    reservedULPRBsPerOperator = OAM_ZERO;
                p_mac_init->mocnParams.numOfOperator++;
            }
            else
            {
                p_mac_cell_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    operator_id = ++last_allocated_opertor_id;
                p_mac_cell_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    dedicatedDLPRBsPerOperator = OAM_ZERO;
                p_mac_cell_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    dedicatedULPRBsPerOperator = OAM_ZERO;
                p_mac_cell_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    reservedDLPRBsPerOperator = OAM_ZERO;
                p_mac_cell_init->mocnParams.mocnPerOperatorParams[mocn_plmn_count[oam_cell_index]].
                    reservedULPRBsPerOperator = OAM_ZERO;
                p_mac_cell_init->mocnParams.numOfOperator++;
            }
            mocn_plmn_count[oam_cell_index]++;
        }
        /* SPR 23504/SES-341 Fix End */
	}
    OAM_FUN_EXIT_TRACE();
}
/* MOCN Feature Changes End */

/*SPR 23209 FIXED END */
/*SPR 21889 End */
/* SPR 23504/SES-341 Fix Start */
/*******************************************************************************
 *  FUNCTION NAME    : oam_validate_and_update_plmnid_in_rrm_oam_plmn_list
 *  DESCRIPTION      : This function used to validate the duplicate entry
 *                     of plmn id in RRM_OAM plmn list
 *  PARAMETERS
 *      IN           : RRM cell PLMN ID structure
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure
*******************************************************************************/
oam_return_et 
oam_validate_and_update_plmnid_in_rrm_oam_plmn_list
(
 rrm_oam_cell_plmn_info_t *p_rrm_oam_plmn,
 UInt8                   cell_cnt
)
{
    oam_return_et ret_val = OAM_SUCCESS;
    UInt8 count = OAM_ZERO;
    
    OAM_FUN_ENTRY_TRACE();

    for(count = OAM_ZERO ; count < rrm_oam_plmn_count[cell_cnt]; count++)
    {
        if(!oam_memcmp(&(rrm_oam_plmn_list[cell_cnt][count]),
                    p_rrm_oam_plmn,
                    sizeof(rrm_oam_cell_plmn_info_t)))
        {
            ret_val = OAM_FAILURE;
            break;
        }
    }

    if(ret_val)
    {
        /*
         ** If entry is not duplicate , update it in the list 
         */
        oam_memcpy(&(rrm_oam_plmn_list[cell_cnt][(rrm_oam_plmn_count[cell_cnt])++]), p_rrm_oam_plmn, sizeof(rrm_oam_cell_plmn_info_t));
    }

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}
/* SPR 23504/SES-341 Fix End */


/*NR_DC Code Change Start*/
#ifdef ENDC_ENABLED
/**************************************************************************
 *  FUNCTION NAME    : oam_populate_en_dc_config_params
 *  DESCRIPTION      : This function is used to populate the EN_DC
 *                     config parameters
 *  PARAMETERS       
 *      IN           : NONE
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  OAM_SUCCESS on Success
 *                      OAM_FAILURE on Failure

 *************************************************************************/
oam_return_et
    oam_populate_en_dc_config_params(void)
{
    Char8 *en_dc_enabled_tag = OAM_NULL;
    oam_return_et  
            ret_val     =  OAM_SUCCESS;

    U8 sgnb_ambr_share    = OAM_ZERO;
    U8 temp_val           = OAM_ZERO;
    U8 cellId             = OAM_ZERO;
    UInt16 dc_prep_timer  = OAM_ZERO;
/* OPTION3X Changes Start */
    UInt16 dc_bearer_change_timer  = OAM_ZERO;
    U64 threshold           = OAM_ZERO;
/* OPTION3X Changes End */

    OAM_FUN_ENTRY_TRACE();

    en_dc_enabled_tag = (Char8*)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"ENDCEnabled");
    /*Check for ENDCEnabled to set to True(1)*/
    if ( (OAM_ZERO != oam_strcmp(en_dc_enabled_tag, OAM_INVALID_STR)) && 
            (OAM_TRUE == oam_atoi(en_dc_enabled_tag))
       )
    {
        /*populating dc_prep_timer in RRC_PROV_REQ*/
        dc_prep_timer = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"dc_prep_timer"),OAM_INVALID_STR);

        if(OAM_ZERO != dc_prep_timer)
        {
            /*populating dc_prep_timer*/ 
            lclTemp_value = oam_atoi((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"dc_prep_timer"));

            if(lclTemp_value >= MIN_DC_PREP_TIMER &&
                    lclTemp_value <= MAX_DC_PREP_TIMER )
            {
                RRC_PROV_REQ.module_timers_info.uecc_dc_prep_timer = 
                    lclTemp_value;

                /*Setting bitmask for DC PREP Timer*/
                RRC_PROV_REQ.module_timers_info.bitmask |=
                    RRC_OAM_UECC_DC_PREP_TIMER_PRESENT;

                OAM_LOG(OAM , OAM_INFO,"dc_prep_timer [%u]",
                        RRC_PROV_REQ.module_timers_info.uecc_dc_prep_timer);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of dc_prep_timer is %u and range "
                        "is from [%u to %u ] ",
                        lclTemp_value, MIN_DC_PREP_TIMER,
                        MAX_DC_PREP_TIMER);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }    
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tags dc_prep_timer not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        

/* OPTION3X Changes Start */
        /*populating dc_bearer_change_guard_timer in RRC_PROV_REQ*/
        dc_bearer_change_timer = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"dc_bearer_change_guard_timer"),OAM_INVALID_STR);

        if(OAM_ZERO != dc_bearer_change_timer)
        {
            /*populating dc_bearer_change_guard_timer*/ 
            lclTemp_value = oam_atoi((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"dc_bearer_change_guard_timer"));

            if(lclTemp_value >= MIN_DC_BEARER_CHANGE_GUARD_TIMER &&
                    lclTemp_value <= MAX_DC_BEARER_CHANGE_GUARD_TIMER )
            {
                RRC_PROV_REQ.module_timers_info.uecc_dc_bearer_change_guard_timer = 
                    lclTemp_value;

                /*Setting bitmask for DC Bearer Change Guard Timer*/
                RRC_PROV_REQ.module_timers_info.bitmask |=
                    RRC_OAM_UECC_DC_BEARER_CHANGE_GUARD_TIMER;

                OAM_LOG(OAM , OAM_INFO,"dc_bearer_change_guard_timer [%u]",
                        RRC_PROV_REQ.module_timers_info.uecc_dc_bearer_change_guard_timer);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of dc_bearer_change_guard_timer is %u and range "
                        "is from [%u to %u ] ",
                        lclTemp_value, MIN_DC_BEARER_CHANGE_GUARD_TIMER,
                        MAX_DC_BEARER_CHANGE_GUARD_TIMER);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }    
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tags dc_bearer_change_guard_timer not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
/* OPTION3X Changes End */
        /*Populating SgNBAmbrShare in RRM_PROV_REQ*/
        sgnb_ambr_share = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"SgNBAmbrShare"),OAM_INVALID_STR);

        if(OAM_ZERO != sgnb_ambr_share)
        {
            /*populating SgNBAmbrShare*/ 
            sgnb_ambr_share = oam_atoi((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"SgNBAmbrShare"));

            if(sgnb_ambr_share >= MIN_SGNB_AMBR_SHARE &&
                    sgnb_ambr_share <= MAX_SGNB_AMBR_SHARE)
            {
                for(cellId = 0;cellId < OAM_MAX_CELL_SUPPORTED; cellId++)
                {
                	/*fill SgNBAmbrShare in RRM_PROV_REQ*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.endc_info.sgnb_ambr_share = 
                    	sgnb_ambr_share;

                	/*Setting bitmask for SgNBAmbrShare*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.bitmask |=
                    	RRM_OAM_ENDC_INFO_PRESENT;
                }

                OAM_LOG(OAM , OAM_INFO,"SgNBAmbrShare [%u]",
                        sgnb_ambr_share);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of SgNBAmbrShare is %u and range "
                        "is from [%u to %u ] ",
                        sgnb_ambr_share, MIN_SGNB_AMBR_SHARE,
                        MAX_SGNB_AMBR_SHARE);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tag SgNBAmbrShare not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /*Populating minNumUEThruputReport in RRM_PROV_REQ*/
        temp_val = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"minNumUEThruputReport"),OAM_INVALID_STR);

        if(OAM_ZERO != temp_val)
        {
            /*populating minNumUEThruputReport*/ 
            temp_val = oam_atoi((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"minNumUEThruputReport"));

            if(temp_val && temp_val <= MAX_NUM_THROUGHPUT_REPORT)
            {
                for(cellId = 0;cellId < OAM_MAX_CELL_SUPPORTED; cellId++)
                {
                	/*fill min_num_ue_thp_report in RRM_PROV_REQ*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.endc_info.min_num_ue_thp_report = 
                    	temp_val;

                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.bitmask |=
                    	RRM_OAM_ENDC_INFO_PRESENT;
                }

                OAM_LOG(OAM , OAM_INFO,"minNumUEThruputReport [%u]",
                        temp_val);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of minNumUEThruputReport is %u and range "
                        "is from [%u to %u ] ",
                        temp_val, 0,
                        MAX_NUM_THROUGHPUT_REPORT);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tag minNumUEThruputReport not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
/* ENDC_MEAS_CHANGES_START */
        temp_val = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"bearer_throughput_threshold_ul"),OAM_INVALID_STR);

        if(OAM_ZERO != temp_val)
        {
            /*populating bearer_throughput_threshold_ul*/ 
            threshold = oam_atoll((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"bearer_throughput_threshold_ul"));

            if(threshold > MIN_BEARER_THROUGHPUT_THRESHOLD_UL)
            {
                for(cellId = 0;cellId < OAM_MAX_CELL_SUPPORTED; cellId++)
                {
                	/*fill min_num_ue_thp_report in RRM_PROV_REQ*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.endc_info.bearer_throughput_threshold_ul = threshold; 

                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.bitmask |=
                    	RRM_OAM_ENDC_INFO_PRESENT;
                }

                OAM_LOG(OAM , OAM_INFO,"bearer_throughput_threshold_ul [%llu]",
                        threshold);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of bearer_throughput_threshold_ul is %llu and range "
                        "is from [%llu to %llu ] ",
                        threshold, MIN_BEARER_THROUGHPUT_THRESHOLD_UL,
                        0xFFFFFFFF);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tag bearer_throughput_threshold_ul not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
       #if 1 
       temp_val = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"bearer_throughput_threshold_dl"),OAM_INVALID_STR);

        if(OAM_ZERO != temp_val)
        {
            /*populating bearer_throughput_threshold_dl*/ 
            threshold = oam_atoll((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"bearer_throughput_threshold_dl"));

            if(threshold > MIN_BEARER_THROUGHPUT_THRESHOLD_DL)
            {
                for(cellId = 0;cellId < OAM_MAX_CELL_SUPPORTED; cellId++)
                {
                	/*fill min_num_ue_thp_report in RRM_PROV_REQ*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.endc_info.bearer_throughput_threshold_dl = threshold;

                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.bitmask |=
                    	RRM_OAM_ENDC_INFO_PRESENT;
                }

                OAM_LOG(OAM , OAM_INFO,"bearer_throughput_threshold_dl [%llu]",
                        threshold);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of bearer_throughput_threshold_dl is %llu and range "
                        "is from [%llu to %llu ] ",
                        threshold, MIN_BEARER_THROUGHPUT_THRESHOLD_DL,
                        0xFFFFFFFF);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tag bearer_throughput_threshold_dl not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
 
       temp_val = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"endc_sinr_thershold_ul"),OAM_INVALID_STR);

        if(OAM_ZERO != temp_val)
        {
            /*populating bearer_throughput_threshold_dl*/ 
            threshold = oam_atoll((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"endc_sinr_thershold_ul"));

            if(threshold <= MAX_ENDC_SINR_THRESHOLD_UL)
            {
                for(cellId = 0;cellId < OAM_MAX_CELL_SUPPORTED; cellId++)
                {
                	/*fill min_num_ue_thp_report in RRM_PROV_REQ*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.endc_info.endc_sinr_thershold_ul = 
                    	threshold;

                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.bitmask |=
                    	RRM_OAM_ENDC_INFO_PRESENT;
                }

                OAM_LOG(OAM , OAM_INFO,"endc_sinr_thershold_ul [%llu]",
                        threshold);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of endc_sinr_thershold_ul is %u and range "
                        "is from [%llu to %llu ] ",
                        0, MAX_ENDC_SINR_THRESHOLD_UL);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tag endc_sinr_thershold_ul not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
 
       temp_val = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"endc_sinr_thershold_dl"),OAM_INVALID_STR);

        if(OAM_ZERO != temp_val)
        {
            /*populating bearer_throughput_threshold_dl*/ 
            threshold = oam_atoll((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"endc_sinr_thershold_dl"));

            if( threshold <= MAX_ENDC_SINR_THRESHOLD_DL)
            {
                for(cellId = 0;cellId < OAM_MAX_CELL_SUPPORTED; cellId++)
                {
                	/*fill min_num_ue_thp_report in RRM_PROV_REQ*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.endc_info.endc_sinr_thershold_dl = 
                    	threshold;

                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.bitmask |=
                    	RRM_OAM_ENDC_INFO_PRESENT;
                }

                OAM_LOG(OAM , OAM_INFO,"endc_sinr_thershold_dl [%llu]",
                        threshold);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of endc_sinr_thershold_dl is %u and range "
                        "is from [%llu to %llu ] ",
                        0, MAX_ENDC_SINR_THRESHOLD_DL);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tag endc_sinr_thershold_dl not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
 
       temp_val = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"endc_bler_thershold_ul"),OAM_INVALID_STR);

        if(OAM_ZERO != temp_val)
        {
            threshold = oam_atoll((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"endc_bler_thershold_ul"));

            if( threshold <= MAX_BLER_THRESHOLD_UL)
            {
                for(cellId = 0;cellId < OAM_MAX_CELL_SUPPORTED; cellId++)
                {
                	/*fill min_num_ue_thp_report in RRM_PROV_REQ*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.endc_info.endc_bler_thershold_ul = 
                    	threshold;

                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.bitmask |=
                    	RRM_OAM_ENDC_INFO_PRESENT;
                }

                OAM_LOG(OAM , OAM_INFO,"endc_bler_thershold_ul [%llu]",
                       threshold);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of endc_bler_thershold_ul is %u and range "
                        "is from [%llu to %llu ] ",
                        0,MAX_BLER_THRESHOLD_UL);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tag endc_bler_thershold_ul not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
 
       temp_val = oam_strcmp((const char *)oam_xmlNodeGetContent(
                    xml_struct_g.EN_DC_Params,"endc_bler_thershold_dl"),OAM_INVALID_STR);

        if(OAM_ZERO != temp_val)
        {
            /*populating bearer_throughput_threshold_dl*/ 
            threshold = oam_atoll((
                        const char *)oam_xmlNodeGetContent(
                            xml_struct_g.EN_DC_Params,"endc_bler_thershold_dl"));

            if( threshold <= MAX_BLER_THRESHOLD_DL)
            {
                for(cellId = 0;cellId < OAM_MAX_CELL_SUPPORTED; cellId++)
                {
                	/*fill min_num_ue_thp_report in RRM_PROV_REQ*/
                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.endc_info.endc_bler_thershold_dl = 
                    	threshold;

                	RRM_PROV_REQ.oam_rrm_cell_config_req[cellId].operator_info.bitmask |=
                    	RRM_OAM_ENDC_INFO_PRESENT;
                }

                OAM_LOG(OAM , OAM_INFO,"endc_bler_thershold_dl [%llu]",
                       threshold);      
            }
            else    
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Value of endc_bler_thershold_dl is %u and range "
                        "is from [%llu to %llu ] ",
                        0,MAX_BLER_THRESHOLD_DL);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else    
        {
            OAM_LOG(OAM, OAM_ERROR, "Tag endc_bler_thershold_dl not found");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
#endif
/* ENDC_MEAS_CHANGES_END */
    }
    else
    {
            OAM_LOG(OAM, OAM_INFO, "EN_DC not enabled!");
    }

    OAM_FUN_EXIT_TRACE();
    return ret_val; 
}
#endif
/*NR_DC Code Change Stop*/
