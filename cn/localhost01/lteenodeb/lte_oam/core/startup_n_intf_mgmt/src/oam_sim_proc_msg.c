/* vim:ts=4:et:ai:ci:sw=4
*/
/*************************************************************************************

 * File Name    : oam_sim_proc_msg.c
 * Description : This file contains the startup procedure for forking all the LTE
 *               layers (L2,L3,RRM,SON) according to the process table.
 * Revision History :
 * Date             Author                  Reference      Comments
 * ---------        -------------           -----------    -------------------------------
 *
 * September,2012   Vivek K Gupta           OAM Rel 1.0    Incorporated changes for new API
 *                                                         header, and new handling of QCLI
 *                                                         messages.
 * October,2012     Vivek K Gupta           OAM Rel 1.0    Incorporated changes for handling
 *                                                         of RRH Software Upgrade Request
 *
 * October,2012     Shivam/ Rajesh/ Shivam                 SET / GET Parameter functionality added                         
 * September,2013   Raveen Sharma           CSR 51606 Fix  Code Changes for CSR Fix
 * September,2013   Vinod Vyas              IPV6 Support 
 * September, 2013  Nitin Vijay             RACH_OPT_SUPOORT      
 * Nov, 2013        Vinod Vyas              CSR 00051709 Fix      
 * Jan, 2014        Vinod Vyas              CSR 00058746 Fix      
 * Jan, 2014        Ravi Gupta              CSR 00058940 Fix      
 * March, 2014      Vinod Vyas              CSR 00058157 Fix 
 * JAN, 2014	    Ankita Jain		    SRVCC, FAPI error handling
 * April,2014       Ekta Jain           Parameter Map table changes for multi cell support
 * April 2014       Nitin/Vinod             Cell State handling for multicell
 * May 2014         Shalu Sagar         SPR 11324 FIX
 * May 2014         Vinod Vyas          SON Cell Delete Support
 * Jun.2014         Shalu Sagar         SPR 11467 Fix
 * MAY 2014         Ekta Jain           SPR 11488 FIX
 * May,  2014       Swetank Srivastava      SPR 11426 Fix - Set the KPI bitmask for bitmap[5]
 * May, 2014	    Avinash 			    SPR 11090 Fix
 * May, 2014	    Avnish	 			    SPR 10258 Fix
 * June 2014        Ashish Sharma           SPR 11249 FIX
 * June 2014        Ekta Jain               SPR 11480 FIX
 * June, 2014       Vivek K Gupta       Release 3.0         Changes for xml 
 *                                                       add/delete frwk code
 * June,2014        Shalu Sagar         SPR 11266 FIX                                                       
 * June 2014        Shalu Sagar         SPR 11597 FIX
 * JUne 2014        Shalu Sagar         SPR 11687 FIX
 * June 2014        Shalu Sagar         SPR 11553 FIX
 * June 2014        Shalu Sagar         Coverity Fix
 * June 2014        Aditi Singh         SPR 11519 FIX
 * June, 2014       Swetank Srivastava     SPR 11314 Fix
 * June, 2014	    Ekta Jain				SPR 11480
 * June, 2014       Vivek Kumar Gupta      SPR 12214 FIX
 * June, 2014       Ankita Jain             SPR 11590 Fix
 * June, 2014       Ankita Jain             SPR 11592 Fix
 * June, 2014       Ankita Jain             SPR 11757 Fix
 * June 2014        Shalu Sagar         SPR 11820 FIX
 * June 2014        Shalu Sagar         SPR 11791 FIX
 * June 2014        Shalu Sagar         SPR 12049 FIX
 * June 2014        Shalu Sagar         SPR 11961 FIX 
 * June 2014        Ekta Jain           SPR 11830 FIX 
 * July 2014        Vinod Vyas          SPR 12200 Fix
 * July 2014        Ekta Jain           SPR 12001 FIX 
 * July 2014        Ekta Jain           SPR 12091 FIX
 * July,2014        Aditi Singh         SPR 9620 Fix                  Guard timer Added
 * July, 2014       Swetank Srivastava  SPR 12665 Fix
 * July, 2014       Swetank Srivastava  SPR 12664 Fix
 * July, 2014       Swetank Srivastava  SPR 12754 Fix
 * July, 2014       Swetank Srivastava  SPR 12755 Fix
 * July, 2014       NITIN VIJAY         PM Trans ID FIXES
 * Aug,  2014       NITIN VIJAY         Trans ID Changes
 * July, 2014      Ekta Jain             SPR 12515
 * Aug,2014         Aditi Singh          SPR 13065
 * July, 2014       Ekta Jain           SPR 12515
 * Aug, 2014        Ankita Jain         SPR 13024 Fix
 * Aug,2014         Vinod Vyas          SPR 11243
 *  
 * Aug, 2014        Ankita Jain         SPR 13139 Fix
* Aug, 2014        RAVI GUPTA          SPR 13176 Fix
* Aug 2014          Shalu Sagar         SPR 13199 FIX
* Aug, 2014        Swetank Srivastava  SPR 9614 Fix
* Aug, 2014        Ankita Jain         SPR 13074 Fix
* Aug, 2014        Ankita Jain         SPR 13187 Fix
* Aug, 2014        Ankita Jain         SPR 13253 Fix
* Aug, 2014        NITIN VIJAY         PM SPV FIX
* Aug, 2014        Ankita Jain         SPR 12596 Fix
* Aug, 2014        Ankita Jain         SPR 13074 Fix
* Aug 2014         Aditi singh         SPR 13116
* Aug 2014         Swetank             SPR 12901
* Oct, 2014        Ankita Jain         SPR 13586
* Dec  2014        Vivek Gupta         SPR 14152
* Dec  2014        Vivek Gupta         SPR 14153
* Sep 1024         Mohit Anand         eICIC Changes
* Sept 2014        Karuna              eICIC changes 
* Copyright (c) 2014, Aricent Inc. All Rights Reserved
*************************************************************************************/

#include<oam_defines.h>
#include<oam_types.h>
#include<oam_proto.h>
#include<oam_config_mgmt.h>
#include<oam_config_tcb.h>
#include<oam_sim_utils.h>
#include<oam_sim.h>
#include<oam_l2_if.h>
#include<oam_xml_header.h>
#include<oam_xml_enum.h>
#include<oam_perf_mgmt.h>
#include<oam_qcli_proto.h>
#include<oam_hm.h>
#include<oam_fault_mgmt.h>
#include<oam_rrm_composer.h>
#include<oam_rrm_parser.h>
#include<oam_son_composer.h>
#include<oam_son_parser.h> 
#include<oam_s1ap_il_composer.h> 
#include<oam_s1ap_il_parser.h> 
#include<oam_x2ap_il_composer.h> 
#include<oam_x2ap_il_parser.h> 
#include<oam_rrc_il_composer.h> 
#include<oam_rrc_il_parser.h> 
#include<oam_s1apCommon_il_composer.h>
#include<oam_s1apCommon_il_parser.h>
/* SPR-16334 START */
#include<oam_x2apCommon_il_composer.h>
#include<oam_x2apCommon_il_parser.h>
/* SPR-16334 END */
#include<oam_fm_alarm_defs.h>
/*SPR 11314 FIX*/
#include<oam_fm_alarm_defs.h>
/*SPR 11314 FIX*/
/* CSR 57877 FIx Start */
#include <oam_mgmt_intf_api.h>
/* CSR 57877 FIx End*/
/* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
#include<rrc_m2apOam_intf.h>
#include<oam_embms_types.h>
#include<oam_embms_proto.h>
#include<oam_m2ap_il_composer.h>
#include<oam_m2ap_il_parser.h>


extern parameter_map_element_t
g_parameter_mbsfn_non_tr196_params[OAM_MAX_MBSFN_NO_TR196_TBL_SIZE];

extern parameter_map_element_t
g_parameter_mbsfn_l3_params[OAM_MAX_MBSFN_L3_TBL_SIZE];

extern parameter_map_element_t
g_parameter_mbsfn_rrm_params[OAM_MAX_MBSFN_RRM_TBL_SIZE];

extern parameter_map_element_t
g_parameter_sfconfig_list_params[OAM_MAX_SFCONFIG_LIST_TBL_SIZE];

extern enumerated_string_fields_mapping_tbl_t
m2ap_log_level[M2AP_LOG_LEVEL_COUNT];

extern enumerated_string_fields_mapping_tbl_t
radioframeAllocOffset_tbl[RADIO_FRAME_ALLOC_OFFSET_COUNT];
#endif
/* EMBMS Changes End */
#include <son_api_defines.h>
#include "oam_agnt_intf.h"
#include "oam_agnt_il_composer.h"
#include "oam_agnt_il_parser.h"


extern UInt8 g_config_lower_layer_resp;
extern UInt8 g_cli_kpi_config_flag;
/* SPR 21030 Fix Start */
UInt16 g_egtpu_trans_id=OAM_ZERO;
/* SPR 21030 Fix End */
/* SPR 20908 Start */
extern lower_layer_init_info_t l2_comm_info[OAM_MAX_NUM_L2_INSTANCE];
/* SPR 20908 End */

typedef oam_return_et (*oam_agent_func_ptr)(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data);
oam_agent_func_ptr oam_agent_fsm_tbl[OAM_AGENT_MAX_STATE][OAM_AGENT_MAX_PROCDR_STATE][OAM_AGENT_EVENT_MAX];
extern SInt32
carrier_qoffset_freq_tbl[OAM_PARAM_VAL_ENUM_MAP_TBL_MAX_COL]
[INTERFREQ_CARRIER_QOFFSETFREQ_COUNT];

UInt8 oam_sys_log = OAM_ZERO;
oam_s1SigLinkServerList_t oam_siglink_server_info;
UInt8 g_flag_add_mme_sent;
/* Spr 17753 Changes Start */
UInt8 g_son_triggered_reconfig_flag = OAM_FALSE; 
/* Spr 17753 Changes End */

/* SPR Fix 18741 Start */
#ifdef OAM_SON_ENABLE
static UInt8 g_oam_nmm_bulk_resp_first_time = OAM_TRUE;   /*keep track of first bulk resp received*/
#endif
/* SPR Fix 18741 End */

/*- SPR 18394*/
#ifndef OAM_SON_ENABLE
UInt8 g_flag_add_enb = OAM_FALSE; 
UInt8 g_x2_ecu_send_check = OAM_FALSE;
#endif
/* SPR-16334 END */
/* CSR 00051709 Change End*/
QTIMER g_admin_state_timer;
UInt16 g_admin_state_trans_id= OAM_ZERO; 
UInt8 Config_CapacityEnc_flag = OAM_FALSE;
UInt8 Config_CapacityEnc_dis_flag = OAM_FALSE;
/* SPR 17842 START */
UInt32 global_trans_bitmap_l2_log;
UInt16 global_trans_l2_log_flag;
/* SPR 17842 START */
extern UInt8 sig_count;
extern UInt8 sig_server;
extern UInt8 nnsf_flag;
/* SPR 15604 START */
extern enumerated_string_fields_mapping_tbl_t NeighborList_Mapping_Table[OAM_THIRTY_TWO];
/* SPR 15604 END */

/* SPR 12214 FIX START */ 
/* CODE DELETED */
/* SPR 12214 FIX END*/
LOCAL oam_ul_dl_qci_cli_input_t oam_ul_dl_qci_cli_input; 

/* CSR 00051709 Change start*/
oam_connected_mme_info_t g_oam_connected_mme_info;
/* CSR 00051709 Change End*/

/* SPR 13501 FIX START */
LOCAL char temp_string[20]  = {OAM_ZERO};
LOCAL char temp_string_1[20]  = {OAM_ZERO};
LOCAL char temp_string_2[20]  = {OAM_ZERO};
LOCAL char temp_string_3[20]  = {OAM_ZERO};
/* SPR 13501 FIX END */
LOCAL UInt8 oam_rrc_lgw_enable = OAM_FALSE;
/* SPR_12955_CHANGES */
UInt8 cli_flag=OAM_FALSE;
oam_bool_et usr_intf_flag = OAM_FALSE;
UInt16 resp_destination_id = OAM_ZERO;
UInt8 g_srvcc_check_flag = OAM_ZERO;
/* SPR 11090 Change start*/
UInt8 g_S1ConnectionMode_flag = OAM_FALSE;
/* SPR 11090 Change End*/
/*SPR 17008 Fixed Start*/
oam_return_et validate_download_file_name(UInt8 *file_name);
/*SPR 17008 Fixed End*/

/* SPR 16567 START */
UInt16 current_enb_config_count = OAM_ZERO;
/* SPR 16567 END */
/* SPR 19938 Fix Start */
UInt32 bitmask_to_start_cell = OAM_ZERO;
/* SPR 19938 Fix Stop */

oam_egtpu_stats_res_t getStatsResp;
oam_return_et oam_cell_state_check_for_unblock(Char8 *cmd_error);
/* + SPR 17439 */
void oam_update_enb_config_info_from_current_mme_list(void);
/* - SPR 17439 */
oam_bool_et oam_is_sdm_alive = OAM_FALSE;


/* SPR 11001 FIX START */
/* CODE DELETED */
/* SPR 11001 FIX END */

/* CSR No 00055803 Start */
extern UInt8 g_resp_sent_user_interface;
/* CSR No 00055803 End */

/* Start: CSR 00058940 */
UInt8 initialisation_flag = OAM_ZERO;
/*End: CSR 00058940 */
extern SInt32 Config_Flag;
extern oam_prov_req_t oam_prov_req;

/* + SPR 17439 */
/* SPR 22296 Fix Start */
#ifndef PDCP_GTPU_INTF
extern oam_return_et oam_handle_pm_reporting_at_startup(void);
#endif
/* SPR 22296 Fix End */
/* - SPR 17439 */
/* SPR 1248 FIX START */
extern rrm_bool_et cell_to_be_started_by_operator;
/* SPR 1248 FIX END */
/* SPR 12932 FIX START */
extern SInt8 daho_umts_cell_cnt;
extern oam_bool_et umts_daho_found_flag;
extern SInt8 daho_lte_cell_cnt;
extern oam_bool_et lte_daho_found_flag;
/* SPR 12932 FIX END */

#ifdef OAM_SON_ENABLE
/* Spr 15438 Fix Start */
/* SPR 18930  FIX START */
        /* Code Removed */ 
/* SPR 18930  FIX END */
/* Spr 15438 Fix End */
 /*SPR_15950 Fix Start*/
/*SPR_16048 Fix Start*/
static void oam_fill_last_scan_time_format(UInt8 *last_scan_time,oam_time_stamp_t time_stamp);
/*SPR_16048 Fix End*/
 /*SPR_15950 Fix End*/
#endif
#ifndef OAM_SON_ENABLE
static void oam_log_load_config_info(rrm_cell_load_info_t *load_info);
/* BCOM Compiltaion Fix */
extern oam_void_t
oam_print_enb_id
(
    oam_global_enb_id_t *p_enb_id
);
extern oam_void_t  
oam_x2_convert_l3_enbid_to_oam_enbid
(
    x2_gb_enb_id_t      *p_l3_enbid, 
    oam_global_enb_id_t *p_oam_enbid
); 
extern oam_return_et
oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(
		UInt16 trans_id,
		UInt16 *tid,
		UInt16 *dest_id
		);
/* BCOM Compiltaion Fix */
#endif

/* SPR_19279_START */
static oam_bool_et g_is_Primary_PLMN_present = OAM_TRUE;
/* SPR_19279_END */
/* SPR 21738 Fix Start */
typedef enum 
{
    OAM_NO_S1_LINK_STATUS_SET,
    OAM_S1_LINK_UP_SET,
    OAM_S1_LINK_DOWN_SET
}link_status_et;
static link_status_et flag_for_s1_link = OAM_NO_S1_LINK_STATUS_SET;
oam_return_et
oam_start_all_cells(void *p_api_buf, UInt16 msg_len);

oam_return_et
oam_stop_all_cells(void *p_api_buf, UInt16 msg_len);
/* SPR 21738 Fix End */
#ifdef OAM_RADIO_HEAD_SUPPORT
#ifdef OAM_RRH_TYPE_1_SUPPORT

#include<oam_rcm_if.h>
#include<oam_rcm_proto.h>
#include<oam_rcm_core.h>

oam_return_et
oam_rrh_intf_msg_handler(void *p_api_buf, UInt16 transid,UInt16 api_id);
oam_return_et oam_rrh_process_user_req(UInt8 *p_api_buf, UInt16 msg_len,
		UInt16 api_mask, UInt16 transaction_id,
		UInt16 src_module_id,
		oam_error_code_et *p_error_code);

void
set_bitmask_s1ap_sctp_conf_param
(
 /*OAM_REVIEW_CHANGES*/
 int loop,
 oam_rrm_cell_reconfig_req_t *p_cell_reconfig_req
 /*OAM_REVIEW_CHANGES*/
 );


void set_bitmask_ran_phy_tdd_frame
(
 int loop,
 void    *p_cell_reconfig_req
 );

LOCAL parameter_map_element_t parameter_RRH_element[OAM_MAX_RRH_TABLE_SIZE];
#endif
#endif

LOCAL UInt8 admin_cmd_restart_flag = OAM_ZERO;

#ifdef OAM_SON_ENABLE
LOCAL char nmm_tmp_str[OAM_NMM_MAX_STR_SIZE] = {OAM_ZERO};
UInt8 g_oam_nmm_scan_first_time;
LOCAL UInt8 rach_usr_req_flag = OAM_ZERO;
#endif

oam_pm_xml_params_t g_pm_xml_params = 
{OAM_FALSE, OAM_FALSE, OAM_ZERO, OAM_NULL, STR_LEN_255, OAM_ZERO, OAM_ZERO, OAM_ZERO, OAM_ZERO, "","", OAM_ZERO,OAM_ZERO,OAM_ZERO,OAM_ZERO,OAM_ZERO,{0},{0}};

oam_rrm_xml_params_t g_pm_rrm_xml_params = {OAM_FALSE, OAM_ZERO, OAM_ZERO, "rrm_kpi.log", OAM_ZERO};

oam_return_et
oam_alloc_n_copy_api_buf
(
 void **,void *
 );
/* SPR 10926 Fix start */
UInt8 user_trigger_admin_state_lock_unlock_flag = OAM_FALSE;
UInt8 cell_stop_sent_to_lock_admin_state = OAM_ZERO;
/* SPR 10926 Fix start */
extern oam_alarm_report_t oam_table_alarm_report_mechanism[];
extern enumerated_string_fields_mapping_tbl_t access_mode_str_enum_tbl[3];

oam_return_et oam_save_current_logs(
		UInt8 *p_buf,
		oam_error_code_et *p_error_code,
		UInt16 trans_id,
		UInt8 dest_id
		);

extern xmlSchemaValidCtxtPtr oam_schema_valid_ctxt;

extern int init_time_startup;

/* + SPR 17439 */
oam_return_et
oam_perform_log_archival(void);
/* - SPR 17439 */

extern void
set_bitmask_nr_enb_add_tnl_address_ipv4
(
 int loop,
 void * p_cell_reconfig_req
 );

extern void
set_bitmask_nr_enb_add_tnl_address_ipv6
(
 int loop,
 void * p_cell_reconfig_req
 );

UInt16 g_upgrade_req_retry_counter = OAM_ZERO;  
/* + SPR 17439 */
void oam_port_process_shutdown(void);
/* - SPR 17439 */

oam_return_et oam_libxml_tr069_init(int ,char *);

oam_bool_et shutdown_flag = OAM_FALSE;   

extern oam_sim_table_t g_oam_sim_t;


extern oam_return_et
oam_startup_init
(
 oam_sim_error_info_et *p_error_code
 );
/*SPR 21478 Start*/
static oam_return_et check_if_set_cell_context_cli(void *p_api_buf)
{
	UInt8 *p_api_buf_temp = p_api_buf;
	Char8 Parent_Name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
         oam_length_t Parent_length = OAM_ZERO;
	p_api_buf_temp += OAM_MGMT_INTF_HEADER_SIZE;
	p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE;

	++p_api_buf_temp;
	++p_api_buf_temp; /* Reserved byte */
	p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE; /* Reserved word */

	Parent_length = get_word_from_header(p_api_buf_temp);
	p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE;

    oam_memset(&Parent_Name, OAM_ZERO, MAX_PARENT_NAME_LENGTH);
	oam_memcpy(Parent_Name, p_api_buf_temp, Parent_length);
	OAM_LOG(OAM, OAM_DETAILED, "Parent Name: %s", Parent_Name);
	if (!oam_strcmp(Parent_Name, "Cell_Context.Context")) {

          return OAM_SUCCESS;
        }

        return OAM_FAILURE;

}


/*SPR 21478 End*/

/* SPR 15527 START */
void oam_find_fap_index(Char8 *p_parent_name, UInt8 *p_fap_index_value);
/* SPR 15527 END */


oam_usr_intf_err_tbl_t ERROR_STR[OAM_MAX_NUM_INTERNAL_ERR_CODE] = {
	{ "NO_ERROR", NO_ERROR, 0 },
	{ "OAM_MALLOC_FAIL", OAM_MALLOC_FAIL, OAM_ERR_RESOURCES_EXCEEDED },
	{ "OAM_SEND_FAIL", OAM_SEND_FAIL, OAM_ERR_INTERNAL_ERROR },
	{ "OAM_NULL_POINTER_ERR", OAM_NULL_POINTER_ERR, OAM_ERR_INTERNAL_ERROR },
	{ "OAM_INSUFFICIENT_BUFFER", OAM_INSUFFICIENT_BUFFER,
		OAM_ERR_RESOURCES_EXCEEDED },
	{ "OAM_MODULE_DISABLED", OAM_MODULE_DISABLED, OAM_ERR_REQUEST_DENIED },
	{ "OAM_INVALID_REQ", OAM_INVALID_REQ, OAM_ERR_REQUEST_DENIED },
	{ "OAM_PARSE_MSG_DMG", OAM_PARSE_MSG_DMG, OAM_ERR_INTERNAL_ERROR },
	{ "OAM_SET_PARAMETER_INPUT_INCORRECT", OAM_SET_PARAMETER_INPUT_INCORRECT,
		OAM_ERR_INVALID_PARAM_VALUE },
	{ "OAM_GET_PARAMETER_INPUT_INCORRECT", OAM_GET_PARAMETER_INPUT_INCORRECT,
		OAM_ERR_INVALID_PARAM_NAME },
	/*SPR 14045 Fixed Start */
	/* SPR 14941 Changes Start */

	{ "OAM_SET_PARAMETER_MODE_MISMATCH",OAM_ERR_ATTEMPT_SET_FOR_NON_WRITABLE_PARAM_VAL,
		OAM_ERR_ATTEMPT_SET_FOR_NON_WRITABLE_PARAM},
	/* SPR 14941 Changes End */
	/*SPR 14045 Fixed End */

	{ "OAM_PARAMETER_NOT_FOUND", OAM_PARAMETER_NOT_FOUND,
		OAM_ERR_INVALID_PARAM_NAME },
	{ "OAM_INVALID_ARFCN_VALUE", OAM_INVALID_ARFCN_VALUE,
		/* SPR 11156 FIX START */
		OAM_ERR_INVALID_PARAM_VALUE },
	{ "Invalid cell context", OAM_INVALID_CELL_CONTEXT,
		OAM_ERR_REQUEST_DENIED },
	/* SPR 11156 FIX END */
	{ "Parameter name too long", OAM_PARAM_NAME_TOO_LONG,
		OAM_ERR_INVALID_PARAM_NAME },
	{ "Resource excceeded", OAM_RESOURCE_EXCCEED, OAM_ERR_REQUEST_DENIED },
	{ "Attempt to delete the primary PLMNID",
		OAM_ATTEMPT_TO_DELETE_PRIM_PLMNID,
		OAM_ERR_REQUEST_DENIED },
	{ "Method not supported", OAM_FEATURE_NOT_SUPPORTED,
		OAM_ERR_METHOD_NOT_SUPPORTED },
	{ "Error in file operation", OAM_FILE_OPERATION_ERR,
		OAM_ERR_FILE_ACCESS_FAILURE },
    /* spr 21390 fix start */
	{ "Data exists", OAM_ERR_DATA_EXISTS, OAM_ERR_REQUEST_DENIED },
    { "M2AP-MCE link is down", OAM_M2AP_MCE_LINK_DOWN, OAM_ERR_REQUEST_DENIED },
    {"eMBMS is disabled in cell, as TDDconfig is wrong", 
        OAM_MBMS_DISABLED_WRONG_TDD_CONFIG, OAM_ERR_REQUEST_DENIED},
    {"SIB2 config is wrong",OAM_MBMS_SIB2_IS_DISABLED, OAM_ERR_REQUEST_DENIED},
    {"NeighborCellConfig is wrong", OAM_MBMS_DISABLED_WRONG_NEIGHCELLCONFIG,
        OAM_ERR_REQUEST_DENIED},
	{ "OAM_INTERNAL_ERROR", OAM_INTERNAL_ERROR,
    /* spr 21390 fix end */
		OAM_ERR_INTERNAL_ERROR },
        /* spr 21390 fix end */
	/*SPR 21478 Start*/
	{ "OAM CELL DELETE IN PROGRESS FOR THIS CELL PLEASE CHECK HM STATUS", OAM_CELL_DELETE_IN_PROGRESS,
		OAM_ERR_INTERNAL_ERROR }
        /*SPR 21478 End*/
};

LOCAL UInt64 paramter_app_map_tbl = OAM_ZERO;

#ifdef OAM_RADIO_HEAD_SUPPORT
#ifdef OAM_RRH_TYPE_1_SUPPORT
LOCAL UInt16 alarm_id_set;
#endif
#endif
extern struct XML_struct_tr196 xml_struct_tr196_g;
extern struct XML_struct xml_struct_g;
extern xml_struct_nw_scan_t xml_struct_nw_scan;
extern xmlSchemaParserCtxtPtr oam_schema_ctxt; 
oam_prov_req_t local_prov_req;    
parameter_map_element_t *g_parameter_map_element = OAM_NULL;
parameter_map_element_t *g_parameter_map_element_bcch = OAM_NULL;

extern oam_cm_cntxt_t *p_cm_cntxt;
extern oam_prov_req_t oam_prov_req;
extern prov_request_t  prov_req;

UInt8 trace_start;
UInt8 SET_L2_ALL_FLAG;

UInt16 flag_shutdown_for_soft_upgrade =OAM_FALSE;

extern int g_no_of_arguments;
extern char **g_list_of_init_arguments; 
LOCAL int send_config_update_flag = OAM_ZERO;

LOCAL UInt16 destination_id= OAM_ZERO;
LOCAL UInt16 tcb_transaction_id= OAM_ZERO;
/*SPR Fix 21412 Start*/
/*SPR Fix 21412 End*/
/* SPR 11001 FIX START */
/* CODE DELETED */
/* SPR 11001 FIX END */
extern oam_sim_table_t g_oam_sim_t;
extern  oam_rrm_cell_config_req_t rrm_cell_config_ptr[OAM_MAX_CELL_PRESENT_MULTICELL];

/*SPR 13518 START*/
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_cell_bloack_cleanup_timer
 *   DESCRIPTION: : This function will set the parameter for resource cleanup timer
 *  Inputs       :  loop value for future reference
 *  Output       :  NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : NONE
 ******************************************************************************/
void set_bitmask_cell_bloack_cleanup_timer
(
 int loop,
 void *p_cell_reconfig_req
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);
	local_prov_req.oam_rrm_req.rrm_cell_block_req.bitmask |= RRM_OAM_CELL_BLOCK_WAIT_TIMER_PRESENT;
	OAM_FUN_EXIT_TRACE();
}
/*SPR 13518 END*/

/* SPR 17880 START */
void oam_update_EnableCWMP(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ENABLE_CWMP_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_PeriodicInformEnable(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= PERIODIC_INFORM_ENABLE_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_PeriodicInformInterval(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= PERIODIC_INFORM_INTERVAL_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_PeriodicInformTime(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= PERIODIC_INFORM_TIME_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_ConnectionRequestUsername(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= CONNECTION_REQUEST_USERNAME_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_ConnectionRequestPassword(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= CONNECTION_REQUEST_PASSWORD_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_CWMPRetryMinimumWaitInterval(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= CWMP_RETRY_MINIMUM_WAIT_INTERVAL_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_CWMPRetryIntervalMultiplier(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= CWMP_RETRY_INTERVAL_MULTIPLIER_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_ConReqURL(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= CON_REQ_URL_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_serving_hems_address_present(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    /* SPR 17880 18JAN FIX START */
    //local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= SERVING_HEMS_ADDRESS_PRESENT;
    /* SPR 17880 18JAN FIX END */

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_initial_hems_address_present(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= INITIAL_HEMS_ADDRESS_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_Username(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= USERNAME_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}

void oam_update_Password(int loop, void* ptr)
{
    OAM_FUN_ENTRY_TRACE();

    if(NULL != ptr){
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);}

    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= PASSWORD_PRESENT;

    OAM_LOG(OAM, OAM_DETAILED,"In %s, local_prov_req.oam_tr069_req.tr069_init_params.bitmask %d",
    __FUNCTION__,local_prov_req.oam_tr069_req.tr069_init_params.bitmask);         

    OAM_FUN_EXIT_TRACE();
    return;
}
/* SPR 17880 END */

/**************************************************************************
 *   FUNCTION NAME: set_bitmask_ran_phy_tdd_frame
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_ran_phy_tdd_frame
(
 int loop,
 void   *p_cell_reconfig_req
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);

	((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |= 
		RRM_OAM_PHYSICAL_LAYER_PARAM_TDD_FRAME_PRESENT;
	OAM_FUN_EXIT_TRACE();
}

LOCAL cmd_map_element_t cmd_map_element[OAM_MAX_NO_OF_COMMANDS] =
{
	{   
		"Shutdown",
		&oam_handle_shutdown_cmd,
		OAM_ZERO
	},
	{   
		"Restart",
		&oam_handle_restart_cmd,
		OAM_ZERO
	},
	{   
		"FactoryReset",
		&oam_handle_factory_reset_cmd,
		OAM_ZERO
	},
	{
		"InitiateConfiguration",
		&oam_handle_init_config_cmd,
		OAM_ZERO
	}

};

/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_lte_l3_sctp_list[] =
{
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.Enable",
		&(local_prov_req.oam_l3_req),
		OAM_NULL,
		&(local_prov_req.oam_l3_req.sctp_params.enable),
		S1AP_OAM_PROVISION_REQ_MASK, 
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP),
		"Enable",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.HBInterval",
		&(local_prov_req.oam_l3_req.oam_s1ap_req),
		OAM_NULL,
		&(local_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.mme_comm_info[OAM_ZERO].heart_beat_timer),
		S1AP_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		&set_bitmask_x2ap_prov,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP),
		"HBInterval",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},

	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.MaxPathRetransmits",
		&(local_prov_req.oam_l3_req.oam_s1ap_req),
		OAM_NULL,
		&(local_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1ap_sctp_conf_param.path_max_retrans),
		S1AP_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		&set_bitmask_s1ap_sctp_conf_param,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP),
		"MaxPathRetransmits",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.MaxAssociationRetransmits",
		&(local_prov_req.oam_l3_req.oam_s1ap_req),
		OAM_NULL,
		&(local_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1ap_sctp_conf_param.assoc_max_retrans),
		S1AP_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		&set_bitmask_s1ap_sctp_conf_param,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP),
		"MaxAssociationRetransmits",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.RTOInitial",
		&(local_prov_req.oam_l3_req.oam_s1ap_req),
		OAM_NULL,
		&(local_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1ap_sctp_conf_param.rto_initial),
		S1AP_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		&set_bitmask_s1ap_sctp_conf_param,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP),
		"RTOInitial",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.RTOMax",
		&(local_prov_req.oam_l3_req.oam_s1ap_req),
		OAM_NULL,
		&(local_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1ap_sctp_conf_param.rto_max),
		S1AP_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		&set_bitmask_s1ap_sctp_conf_param,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP),
		"RTOMax",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.RTOMin",
		&(local_prov_req.oam_l3_req.oam_s1ap_req),
		OAM_NULL,
		&(local_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1ap_sctp_conf_param.rto_min),
		S1AP_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		&set_bitmask_s1ap_sctp_conf_param,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP),
		"RTOMin",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.ValCookieLife",
		&(local_prov_req.oam_l3_req.oam_s1ap_req),
		OAM_NULL,
		&(local_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.s1ap_sctp_conf_param.valid_cookie_life),
		S1AP_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		&set_bitmask_s1ap_sctp_conf_param,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].SCTP),
		"ValCookieLife",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	}

};
/* spr_21013_fix_end */

#ifdef OAM_SON_ENABLE
parameter_map_element_t g_parameter_son_mlb_modify_attribute_val[] = {
	/* SPR 11519 CHANGE START */	
	{
		"SON.MLB.MODIFY.Mlb_Mode",
		&(LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[OAM_ZERO]),
		OAM_NULL,
		&(LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[OAM_ZERO].
				mlb_mode),
		OAM_SON_MLB_MODIFY_ATTRIBUTE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mlb_modify_mlb_mode,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	/* SPR 11519 CHANGE END */
	{
		"SON.MLB.MODIFY.Q-Offset-Min",
		&(LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[0]),
		OAM_NULL,
		&(LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[0].
				eutra_q_offset_config.q_offset_min),
		OAM_SON_MLB_MODIFY_ATTRIBUTE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mlb_eutra_q_offset_config_q_offset_min,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MLB.MODIFY.Q-Offset-Max",
		&(LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[0]),
		OAM_NULL,    
		&(LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[0].
				eutra_q_offset_config.q_offset_max),
		OAM_SON_MLB_MODIFY_ATTRIBUTE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mlb_eutra_q_offset_config_q_offset_max,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	}
};
#endif

parameter_map_element_t g_parameter_cell_context[] = 
{
	{
		/* SPR 11249 FIX START */
		/* Changed from ActiveCellIndex to CurrentCellIndex */
		"Cell_Context.Context.CurrentCellIndex",
		/* SPR 11249 FIX END */
		OAM_NULL,
		OAM_NULL,
		&(local_prov_req.cell_cntxt.curr_cell_cid),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	}
};

/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_lte_l3_Assoc_list[] =
{
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc.Status",
		&(local_prov_req.oam_l3_req.sctp_params),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO]),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO].status),
		X2AP_OAM_GET_SCTP_STATUS_RESP_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc.PrimaryPeerAddress",
		&(local_prov_req.oam_l3_req.sctp_params),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO]),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO].primary_peer_addr),
		X2AP_OAM_GET_SCTP_STATUS_RESP_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc.LocalPort",
		&(local_prov_req.oam_l3_req.sctp_params),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO]),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO].local_port),
		X2AP_OAM_GET_SCTP_STATUS_RESP_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc.InStreams",
		&(local_prov_req.oam_l3_req.sctp_params),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO]),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO].in_streams),
		X2AP_OAM_GET_SCTP_STATUS_RESP_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc.OutStreams",
		&(local_prov_req.oam_l3_req.sctp_params),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO]),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO].out_streams),
		X2AP_OAM_GET_SCTP_STATUS_RESP_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)

	},
	/*BUG_FIX_ID : 743*/
	{
		"InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc.StartTime",
		&(local_prov_req.oam_l3_req.sctp_params),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO]),
		&(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[OAM_ZERO].start_time.tv_sec),
		X2AP_OAM_GET_SCTP_STATUS_RESP_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		TIMESTAMP_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};

#ifdef OAM_SON_ENABLE
parameter_map_element_t g_param_intra_rat_neigh_list_in_use[] = {
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.LTECell.PLMNID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				intra_rat_nr_list[OAM_ZERO].nbr_cgi.plmn_id),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
	/*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        "PLMNID",
		PLMN_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
	/*SPR 15604 END*/
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
        /* SPR 17601 changes start */
			"NeighborListInUse.LTECell.CID",
        /* SPR 17601 changes end */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
        /* SPR 17601 changes start */
				intra_rat_nr_list[OAM_ZERO].nbr_cgi.cell_identity),
        /* SPR 17601 changes end */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
	/*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17601 changes start */
        "CID",
		EUTRAN_CELL_IDENTITY_TYPE,
        /* SPR 17601 changes end */
/* SPR 18930  FIX START */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
/* SPR 18930  FIX END */
	/*SPR 15604 END*/

	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
        /* SPR 17601 changes start */
			"NeighborListInUse.LTECell.EUTRACarrierARFCN",
        /* SPR 17601 changes end */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
        /* SPR 17601 changes start */
				intra_rat_nr_list[OAM_ZERO].earfcn),
        /* SPR 17601 changes end */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		/*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17601 changes start */
        "EUTRACarrierARFCN",
		UINT16_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
		/*SPR 15604 END*/
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.LTECell.PhyCellID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				intra_rat_nr_list[OAM_ZERO].pci),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		/*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17454 changes start */
        /* "PLMNID", */
        "PhyCellID",
        /* SPR 17454 changes end */
        PLMN_TYPE,
        /* SPR 17601 changes end */
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
		/*SPR 15604 END*/
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.LTECell.QOffset",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				intra_rat_nr_list[OAM_ZERO].cell_specific_offset),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        "QOffset",
		SINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
		/*SPR 15604 END*/
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
        /* SPR 17601 changes start */
			"NeighborListInUse.LTECell.Blacklisted",
        /* SPR 17601 changes end */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
        /* SPR 17601 changes start */
				intra_rat_nr_list[OAM_ZERO].ho_status),
        /* SPR 17601 changes end */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 17601 changes start */
/* SPR 18930  FIX START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
    /*SPR 17059 FIX START */
		"Blacklisted",
    /*SPR 17059 FIX END */
		OAM_ENUM_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
/* SPR 18930  FIX END */
        /* SPR 17601 changes end */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
        /* SPR 17601 changes start */
			"NeighborListInUse.LTECell.X_VENDOR_RSRP",
        /* SPR 17601 changes end */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
        /* SPR 17601 changes start */
				intra_rat_nr_list[OAM_ZERO].rsrp),
        /* SPR 17601 changes end */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		/*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17601 changes start */
        "X_VENDOR_RSRP",
		UINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
        /* SPR 17601 changes end */
		/*SPR 15604 END*/
	},
    /*SPR 17059 FIX : code removed */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.LTECell.X_VENDOR_CSGID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				intra_rat_nr_list[OAM_ZERO].csg_identity),
		OAM_ZERO,
		OAM_NULL,
		/*SPR 15604 START*/
		OAM_NULL,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        "X_VENDOR_CSGID",
		FOUR_BYTE_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
		/*SPR 15604 END*/
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
        /* SPR 17601 changes start */
			"NeighborListInUse.LTECell.X_VENDOR_NR_STATUS",
        /* SPR 17601 changes end */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
        /* SPR 17601 changes start */
				intra_rat_nr_list[OAM_ZERO].nr_status),
        /* SPR 17601 changes end */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 17601 changes start */
		/*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        "X_VENDOR_NR_STATUS",
        /* SPR 17601 changes end */
		UINT8_TYPE,
        /* SPR 17601 changes start */
        /* OAM BCOM Code Comment Changes Start */
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
		/*SPR 15604 END*/
        /* SPR 17601 changes end */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
        /* SPR 17601 changes start */
			"NeighborListInUse.LTECell.X_VENDOR_RSRQ",
        /* SPR 17601 changes end */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
        /* SPR 17601 changes start */
				intra_rat_nr_list[OAM_ZERO].rsrq),
        /* SPR 17601 changes end */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		/*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17601 changes start */
        "X_VENDOR_RSRQ",
        /* SPR 17601 changes end */
		UINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
		/*SPR 15604 END*/
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
        /* SPR 17601 changes start */
			"NeighborListInUse.LTECell.X_VENDOR_TAC",
        /* SPR 17601 changes end */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
        /* SPR 17601 changes start */
				intra_rat_nr_list[OAM_ZERO].tac),
        /* SPR 17601 changes end */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		/*SPR 15604 START*/
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17601 changes start */
        "X_VENDOR_TAC",
		TWO_BYTE_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
        /* SPR 17601 changes end */
		/*SPR 15604 END*/

/* SPR 17524 changes start */
/* code removed */
/* SPR 17524 changes ends */
	}
};

/* SPR-13586 START */
/* RT SPR 9019 FIX START */
/* SPR 18930  FIX START */
parameter_map_element_t g_param_inter_rat_neigh_list_in_use[] = {
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.PLMNID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.nbr_cgi.plmn_id),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "PLMNID",
		PLMN_TYPE,
        (OAM_READ_ONLY | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
/* SPR 18930  FIX START */
            "NeighborListInUse.InterRATCell.UMTS.RNCID",
/* SPR 18930  FIX END */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
/* SPR 18930  FIX START */
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.nbr_cgi.cell_identity),
/* SPR 18930  FIX END */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
/* SPR 18930  FIX START */
        "RNCID",
		FOUR_BYTE_TYPE,
/* SPR 18930  FIX END */
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.CID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.nbr_cgi.cell_identity),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "CID",
		FOUR_BYTE_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* SPR 15604 END */
	},
	{
/* SPR 18930  FIX START */
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborListInUse.InterRATCell.UMTS.LAC",
        &(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.lac),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "LAC",
		TWO_BYTE_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.RAC",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.rac),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "RAC",
		UINT8_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
	},
    {
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.UARFCNDL",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.uarfcn),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "UARFCNDL",
		UINT16_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
    },
	/* RT SPR 8627 FIX START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.PCPICHScramblingCode",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.pci),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "PCPICHScramblingCode",
		STRUCTURE_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.X_VENDOR_RSCP",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.rscp),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "X_VENDOR_RSCP",
		SINT8_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.X_VENDOR_CELL_SPECIFIC_OFFSET",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.cell_specific_offset),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "X_VENDOR_CELL_SPECIFIC_OFFSET",
		SINT8_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.X_VENDOR_NUM_PLMN_ID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.num_plmn_id),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        /* SPR 15604 START */
        "X_VENDOR_NUMPLMNID",
		UINT8_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.X_VENDOR_PLMN_ID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.plmn_id),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        /* SPR 15604 START */
        "X_VENDOR_PLMN_ID",
		PLMN_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.X_VENDOR_CSGID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.csg_identity),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "X_VENDOR_CSGID",
		FOUR_BYTE_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
	},
	
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.X_VENDOR_ECNO",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.ecno),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "X_VENDOR_ECNO",
		UINT8_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.X_VENDOR_NR_STATUS",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.nr_status),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        /* SPR 15604 START */
	    &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "X_VENDOR_NR_STATUS",
		UINT8_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	/* SPR 15604 END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTS.X_VENDOR_HO_STATUS",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.ho_status),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
	/* SPR 15604 START */
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "X_VENDOR_HO_STATUS",
        UINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborListInUse.InterRATCell.UMTS.X_VENDOR_ACCESS_MODE",
        &(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
        &(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
        &(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
                inter_rat_nr_list[OAM_ZERO].utran_neighbor.access_mode),
        OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS_NLIU[OAM_ZERO],
        "X_VENDOR_ACCESS_MODE",
		UINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
	/* SPR 15604 END */
	}
};
/* SPR 18930  FIX END */
/* RT SPR 9019 FIX END */

parameter_map_element_t g_parameter_lte_inter_rat_geran_neighbor_list_in_use[] =
{
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInuse.InterRATCell.GSM.PLMNID",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.nbr_cgi.plmn_id),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		PLMN_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	/* GSM LAC and CI map to the same variable cell_identity, as
	   they together make the cell identity */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.LAC",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.nbr_cgi.cell_identity),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		STRUCTURE_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.CI",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.nbr_cgi.cell_identity),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		STRUCTURE_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.BandIndicator",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.band_ind),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.BCCHARFCN",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.arfcn),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.BSIC",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.pci),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		STRUCTURE_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.X_VENDOR_NR_STATUS",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.nr_status),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.X_VENDOR_HO_STATUS",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.ho_status),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.X_VENDOR_RAC",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.rac),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.X_VENDOR_CELL_SPECIFIC_OFFSET",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.cell_specific_offset),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		SINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.GSM.X_VENDOR_RSSI",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.rssi),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
			/* SPR 13850 FIX END */
	}
};
/* spr_21013_fix_end */
/* SPR-13586 END */

/******* DROP 4 CODE *******/
parameter_map_element_t g_parameter_lte_son_es_list[] =
{
	{
		"Set.SON.ES.Modify.UE_Count_interval.ActiveUECountIntervalSecond",
		&(local_prov_req.oam_son_req.oam_son_es_modify_ue_count_interval_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_es_modify_ue_count_interval_req.interval),
		SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)        
	},
	{
		"Set.SON.ES.Modify.UE_Count_threshold.ActiveUECountThreshold",
		&(local_prov_req.oam_son_req.oam_son_es_modify_ue_count_threshold_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_es_modify_ue_count_threshold_req.threshold_value),
		SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"Set.SON.ES.Cell.Autonomous_SwitchOff.TriggerCriteria.LoadLevel.TimerDuration",
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req.timer_duration),
		SON_OAM_ES_AUTONOMOUS_CELL_SWITCH_OFF_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"Set.SON.ES.Cell.Autonomous_SwitchOff.TriggerCriteria.LoadLevel.LoadLevelThreshold",
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req.load_level_threshold),
		SON_OAM_ES_AUTONOMOUS_CELL_SWITCH_OFF_REQ_MASK,
		OAM_NULL,
		&set_bitmask_autonomous_switch_off_load,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"Set.SON.ES.Cell.Autonomous_SwitchOff.TriggerCriteria.ActiveUECount.TimerDuration",
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req.timer_duration),
		SON_OAM_ES_AUTONOMOUS_CELL_SWITCH_OFF_REQ_MASK,
		OAM_NULL,
		&set_bitmask_autonomous_switch_off_active,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"Set.SON.ES.Cell.Autonomous_SwitchOff.TriggerCriteria.Both.TimerDuration",
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req.timer_duration),
		SON_OAM_ES_AUTONOMOUS_CELL_SWITCH_OFF_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"Set.SON.ES.Cell.Autonomous_SwitchOff.TriggerCriteria.Both.LoadLevelThreshold",
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.autonomous_switch_off_config_req.load_level_threshold),
		SON_OAM_ES_AUTONOMOUS_CELL_SWITCH_OFF_REQ_MASK,
		OAM_NULL,
		&set_bitmask_autonomous_switch_off_both,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	}
};

/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_lte_intra_rat_neighbor_list[] = 
{
    /* Spr 15438 Fix Start */
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborList.LTECell.Enable",
        /* SPR 18930  FIX START */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).eutran_nbr_ctxt[OAM_ZERO]),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).eutran_nbr_ctxt[OAM_ZERO].enable),
        /* SPR 18930  FIX END */
        SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
        OAM_NULL,
        &set_bitmask_for_lte_cell_enable,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
        "Enable",
        UINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborList.LTECell.MustInclude",
        /* SPR 18930  FIX START */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).eutran_nbr_ctxt[OAM_ZERO]),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).eutran_nbr_ctxt[OAM_ZERO].must_include),
        /* SPR 18930  FIX END */
        SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
        OAM_NULL,
        &set_bitmask_for_lte_cell_must_include,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
        "MustInclude",
        UINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
    },
    /* Spr 15438 Fix End*/

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.PLMNID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].nbr_cgi.plmn_id),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"PLMNID",
		PLMN_TYPE,
		/* SPR 13850 FIX START */
		(OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},    
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.CID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].nbr_cgi.cell_identity),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"CID",
		EUTRAN_CELL_IDENTITY_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.EUTRACarrierARFCN",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].earfcn),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_earfcn,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"EUTRACarrierARFCN",
		UINT16_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN." 
			"NeighborList.LTECell.PhyCellID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].pci),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_intra_pci,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"PhyCellID",
		UINT16_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.QOffset",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].cell_specific_offset),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_intra_cell_specific_offset,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"QOffset",
		SINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.CIO",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].cm_cell_specific_offset),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_cm_cio,
        /* SPR 17373 START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17373 END */
		"CIO",
        /* SPR 17373 START */
		OAM_ENUM_TYPE,
        /* SPR 17373 END */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    /* SPR 16603 Fix Start */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.RSTxPower",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		&( local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].ran_info.
				ncl_params.lte_ncl.intra_freq_cells[OAM_ZERO]),
		&( local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].ran_info.
				ncl_params.lte_ncl.intra_freq_cells[OAM_ZERO].r_stx_power),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rstx_power,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"RSTxPower",
		SINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
    /* SPR 16603 Fix End */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.Blacklisted",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].ho_status),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_intra_ho_status,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"Blacklisted",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN." 
			"NeighborList.LTECell.X_VENDOR_NUMPLMNID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		/*parameter not found in populate and xml file */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].num_plmn_id),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_plmn_id,
		OAM_NULL,
		"X_VENDOR_NUMPLMNID",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_PLMN_ID",
		/*parameter not found in populate and xml file */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].plmn_id[OAM_ZERO]),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_plmn_id,
		OAM_NULL,
		"X_VENDOR_PLMN_ID",
		PLMN_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_RSRP",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].rsrp),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_rsrp,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"X_VENDOR_RSRP",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN." 
			"NeighborList.LTECell.X_VENDOR_CSGID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].csg_identity),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_csg_id,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"X_VENDOR_CSGID",
		FOUR_BYTE_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_NR_STATUS",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].nr_status),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_nr_status,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"X_VENDOR_NR_STATUS",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_RSRQ",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].rsrq),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_rsrq,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"X_VENDOR_RSRQ",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_TAC",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].tac),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_tac,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
		"X_VENDOR_TAC",
		TWO_BYTE_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	/* SPR 11682 FIX START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_BROADCAST_STATUS",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].broadcast_status),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_broadcast_status,
        /* SPR 17373 START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17373 END */
		"X_VENDOR_BROADCAST_STATUS",
		UINT32_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_ACCESS_MODE",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].access_mode),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_access_mode,
        /* SPR 17373 START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17373 END */
		"X_VENDOR_ACCESS_MODE",
		UINT32_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_PRACH_ROOT_SEQUENCE_INDEX",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].prach_config.root_sequence_index),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_root_sequence_index,
        /* SPR 17373 START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17373 END */
		"X_VENDOR_PRACH_ROOT_SEQUENCE_INDEX",
        /* SPR 17373 START */
		UINT32_TYPE,
        /* SPR 17373 END */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_PRACH_ZERO_CORRELATION_ZONE_CONFIG",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].prach_config.
				zero_correlation_zone_config),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_zero_correlation_zone_config,
        /* SPR 17373 START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17373 END */
		"X_VENDOR_PRACH_ZERO_CORRELATION_ZONE_CONFIG",
        /* SPR 17373 START */
		UINT32_TYPE,
        /* SPR 17373 END */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_PRACH_HIGH_SPEED_FLAG",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].prach_config.high_speed_flag),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_high_speed_flag,
        /* SPR 17373 START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17373 END */
		"X_VENDOR_PRACH_HIGH_SPEED_FLAG",
        /* SPR 17373 START */
		UINT32_TYPE,
        /* SPR 17373 END */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_PRACH_FREQUENCY_OFFSET",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].prach_config.
				prach_frequency_offset),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_prach_frequency_offset,
        /* SPR 17373 START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17373 END */
		"X_VENDOR_PRACH_FREQUENCY_OFFSET",
        /* SPR 17373 START */
		UINT32_TYPE,
        /* SPR 17373 END */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECell.X_VENDOR_PRACH_CONFIGURATION_INDEX",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].prach_config.
				prach_configuration_index),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_prach_configuration_index,
        /* SPR 17373 START */
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell_NLIU[OAM_ZERO],
        /* SPR 17373 END */
		"X_VENDOR_PRACH_CONFIGURATION_INDEX",
        /* SPR 17373 START */
		UINT32_TYPE,
        /* SPR 17373 END */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN." 
			"NeighborList.LTECell.X_VENDOR_SUSPECTED_PCI",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO]),
		/* parameter not found */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list[OAM_ZERO].suspected_pci),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		&set_bitmask_add_req_intra_rat_suspected_pci,
		OAM_NULL,
		"X_VENDOR_SUSPECTED_PCI",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
	}
	/* SPR 11682 FIX END */
	,
		/*eICIC_PHASE_1_2_CHANGES_START */
		{
			"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"NeighborList.LTECell.X_VENDOR_INTERFERENCE_SCHEME",
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
			/*SPR 14119 start*/
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
					intra_rat_nr_list[OAM_ZERO]),
			/*SPR 14119 end*/
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
					intra_rat_nr_list[OAM_ZERO].eicic_info.interference_scheme),
			SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
			OAM_NULL,
			&set_bitmask_add_req_intra_rat_interference_scheme, 
			/*SPR 14119 start*/
			&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
			/*SPR 14119 end*/
			"X_VENDOR_INTERFERENCE_SCHEME",
			UINT32_TYPE,
			(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
		},

		{
			"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"NeighborList.LTECell.X_VENDOR_MIN_ABS_USAGE_THRESHOLD",
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
			/*SPR 14119 start*/
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
					intra_rat_nr_list[OAM_ZERO]),
			/*SPR 14119 end*/
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
					intra_rat_nr_list[OAM_ZERO].eicic_info.abs_usage_threshold.
					min_abs_usage_threshold),
			SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
			OAM_NULL,
			&set_bitmask_add_req_intra_rat_min_abs_usage_threshold, 
			/*SPR 14119 start*/
			&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
			/*SPR 14119 end*/
			"X_VENDOR_MIN_ABS_USAGE_THRESHOLD",
			/*SPR 14380 start*/
			UINT8_TYPE,
			/*SPR 14380 end*/
			(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
		},

		{
			"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"NeighborList.LTECell.X_VENDOR_MAX_ABS_USAGE_THRESHOLD",
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
			/*SPR 14119 start*/
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
					intra_rat_nr_list[OAM_ZERO]),
			/*SPR 14119 end*/
			&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
					intra_rat_nr_list[OAM_ZERO].eicic_info.abs_usage_threshold.
					max_abs_usage_threshold),
			SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
			OAM_NULL,
			&set_bitmask_add_req_intra_rat_max_abs_usage_threshold, 
			/*SPR 14119 start*/
			&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
			/*SPR 14119 end*/
			"X_VENDOR_MAX_ABS_USAGE_THRESHOLD",
			/*SPR 14380 start*/
			UINT8_TYPE,
			/*SPR 14380 end*/
			(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
		}

	/*eICIC_PHASE_1_2_CHANGES_END */

};

/* RT SPR 9142 FIX START */
/* Number of parameter entries in the following table is defined as
   OAM_INTER_RAT_UTRAN_NEIGH_PARAMS_COUNT, if one adds some entries
   in the following table, do not forget to update the macro value
 */ 
/* RT SPR 9142 FIX END */
parameter_map_element_t g_parameter_lte_inter_rat_neighbor_list[] =
{
/* Spr 15612  Fix Start*/
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborList.InterRATCell.UMTS.Enable",
        /* SPR 18930  FIX START */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).utran_nbr_ctxt[OAM_ZERO]),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).utran_nbr_ctxt[OAM_ZERO].enable),
        /* SPR 18930  FIX END */
        SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
        OAM_NULL,
        &set_bitmask_for_umts_cell_enable,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
        "Enable",
        UINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborList.InterRATCell.UMTS.MustInclude",
        /* SPR 18930  FIX START */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).utran_nbr_ctxt[OAM_ZERO]),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).utran_nbr_ctxt[OAM_ZERO].must_include),
        /* SPR 18930  FIX END */
        SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
        OAM_NULL,
        &set_bitmask_for_umts_cell_must_include,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
        "MustInclude",
        UINT8_TYPE,
        /* OAM BCOM Code Comment Changes Start */
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /* OAM BCOM Code Comment Changes End */    
    },
/* Spr 15612  Fix End*/

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.PLMNID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.nbr_cgi.plmn_id),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		OAM_NULL, 
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"PLMNID",
		PLMN_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	/* RT SPR 8627 FIX START */
	/* UMTS RNCID and CID map to the same variable cell_identity, as
	   they together make the cell identity */ 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.RNCID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.nbr_cgi.cell_identity),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"RNCID",
		FOUR_BYTE_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	/* RT SPR 8627 FIX END */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.CID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.nbr_cgi.cell_identity),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		OAM_NULL, 
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"CID",
		FOUR_BYTE_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.LAC",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.lac),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_lac,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"LAC",
		TWO_BYTE_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.RAC",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.rac),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_rac,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"RAC",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
/* Spr 15612  Fix Start*/
    /* Parameter URA is currently not used in Aricent IPR */
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborListInUse.InterRATCell.UMTS.URA",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].ran_info.
                ncl_params.inter_rat_ncl.utran_freq_cells[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].ran_info.
                ncl_params.inter_rat_ncl.utran_freq_cells[OAM_ZERO].ura),
        OAM_ZERO,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        "URA",
        UINT8_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
    },
/* Spr 15612  Fix end*/

	/* RT SPR 8627 FIX START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.PCPICHScramblingCode",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		/* RT SPR 9019 FIX START */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.pci),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_pci,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"PCPICHScramblingCode",
		STRUCTURE_TYPE,
		/* RT SPR 9019 FIX END */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
    /* SPR 16603 Fix Start */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.PCPICHTxPower",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		/* RT SPR 9019 FIX START */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.cell_specific_offset),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_pci,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"PCPICHTxPower",
		SINT8_TYPE,
		/* RT SPR 9019 FIX END */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
    /* SPR 16603 Fix End */

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_RSCP",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.rscp),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_rscp,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_RSCP",
		SINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_CELL_SPECIFIC_OFFSET",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.cell_specific_offset),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_cso,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_CELL_SPECIFIC_OFFSET",
		SINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_NUMPLMNID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.num_plmn_id),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_plmn_id,
		OAM_NULL,
		/* RT SPR 9142 FIX START */
		"X_VENDOR_NUMPLMNID",
		/* RT SPR 9142 FIX END */
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_PLMN_ID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		/* parameter not found */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.plmn_id),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_plmn_id,
		OAM_NULL,
		/* RT SPR 9142 FIX START */
		"X_VENDOR_PLMN_ID",
		/* RT SPR 9142 FIX END */
		PLMN_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_CSGID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.csg_identity),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_csg_id,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_CSGID",
		FOUR_BYTE_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_ECNO",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.ecno),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_ecno,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_ECNO",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_NR_STATUS",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.nr_status),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_nr_status,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_NR_STATUS",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_HO_STATUS",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.ho_status),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_ho_status, 
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_HO_STATUS",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_PS_HO_SUPPORTED",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.ps_ho_supported),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_ps_ho_supported,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_PS_HO_SUPPORTED",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_VOIP_CAPABLE",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.voip_capable),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_voip_capable,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_VOIP_CAPABLE",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.UARFCNDL",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.uarfcn),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_inter_uarfcn,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"UARFCNDL",
		UINT16_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTS.X_VENDOR_ACCESS_MODE",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].utran_neighbor.access_mode),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		&set_bitmask_add_req_inter_rat_access_mode, 
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO],
		"X_VENDOR_ACCESS_MODE",
		UINT32_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	}
};
/* SPR-13586 START */
parameter_map_element_t g_parameter_lte_inter_rat_geran_neighbor_list[] =
{
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.PLMNID",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.nbr_cgi.plmn_id),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"PLMNID",
		PLMN_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	/* GSM LAC and CI map to the same variable cell_identity, as
	   they together make the cell identity */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.LAC",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.nbr_cgi.cell_identity),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"LAC",
		STRUCTURE_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.CI",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.nbr_cgi.cell_identity),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"CI",
		STRUCTURE_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.BandIndicator",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.band_ind),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		&set_bitmask_son_nr_geran_band_ind,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"BandIndicator",
		OAM_ENUM_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.BCCHARFCN",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.arfcn),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		&set_bitmask_son_nr_geran_arfcn,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"BCCHARFCN",
		UINT16_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.BSIC",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.pci),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		&set_bitmask_son_nr_geran_bsic,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"BSIC",
		STRUCTURE_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.X_VENDOR_NR_STATUS",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.nr_status),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		&set_bitmask_son_nr_geran_nr_status,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"X_VENDOR_NR_STATUS",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.X_VENDOR_HO_STATUS",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.ho_status),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		&set_bitmask_son_nr_geran_ho_status,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"X_VENDOR_HO_STATUS",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.X_VENDOR_RAC",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.rac),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		&set_bitmask_son_nr_geran_rac,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"X_VENDOR_RAC",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.X_VENDOR_CELL_SPECIFIC_OFFSET",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.cell_specific_offset),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		&set_bitmask_son_nr_geran_cell_spec_offset,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"X_VENDOR_CELL_SPECIFIC_OFFSET",
		SINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.GSM.X_VENDOR_RSSI",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO]),
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list[OAM_ZERO].geran_neighbor.rssi),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
		OAM_NULL,
		&set_bitmask_son_nr_geran_rssi,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GSM[OAM_ZERO],
		"X_VENDOR_RSSI",
		UINT8_TYPE,
		(MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY)
	}
};
/* spr_21013_fix_end */
/* SPR-13586 END */

parameter_map_element_t g_parameter_nr_delete_from_rem_list[] =
{
	{
		"SON_NR_DELETE_FROM_REMOVE_LIST_INTRA_RAT.PLMNID",
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.
				trgt_cgi_list[OAM_ZERO].intra_rat_global_cell_id.plmn_id),
		SON_OAM_NR_DELETE_FROM_REM_LIST_MASK,
		OAM_NULL,
		&set_bitmask_son_nr_del_from_rem_list_intra,
		OAM_NULL,
		OAM_NULL,
		PLMN_TYPE,
		/* SPR 11156 FIX START */
		OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION
			/* SPR 11156 FIX END */
	},
	{
		"SON_NR_DELETE_FROM_REMOVE_LIST_INTRA_RAT.CID",
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO].intra_rat_global_cell_id.cell_identity),
		SON_OAM_NR_DELETE_FROM_REM_LIST_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		EUTRAN_CELL_IDENTITY_TYPE,
		/* SPR 11156 FIX START */
		OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION
			/* SPR 11156 FIX END */
	}
};

parameter_map_element_t g_parameter_nr_delete_from_rem_list_utran[] =
{
	{
		"SON_NR_DELETE_FROM_REMOVE_LIST_INTER_RAT_UTRAN.PLMNID",
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.
				trgt_cgi_list[OAM_ZERO].inter_rat_global_cell_id.
				utran_geran_global_cell_id.plmn_id),
		SON_OAM_NR_DELETE_FROM_REM_LIST_MASK,
		OAM_NULL,
		&set_bitmask_son_nr_del_from_rem_list_utran,
		OAM_NULL,
		OAM_NULL,
		PLMN_TYPE,
		/* SPR 11156 FIX START */
		OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION
			/* SPR 11156 FIX END */
	},
	/* RT SPR 8627 FIX START */
	/* UMTS RNCID and CID map to the same variable cell_identity, as
	   they together make the cell identity */ 
	{
		"SON_NR_DELETE_FROM_REMOVE_LIST_INTER_RAT_UTRAN.RNCID",
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.
				trgt_cgi_list[OAM_ZERO].inter_rat_global_cell_id.
				utran_geran_global_cell_id.cell_identity),
		SON_OAM_NR_DELETE_FROM_REM_LIST_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		FOUR_BYTE_TYPE,
		/* SPR 11156 FIX START */
		OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION
			/* SPR 11156 FIX END */
	},
	/* RT SPR 8627 FIX END */
	{
		"SON_NR_DELETE_FROM_REMOVE_LIST_INTER_RAT_UTRAN.CID",
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nr_delete_from_remove_list.
				trgt_cgi_list[OAM_ZERO].inter_rat_global_cell_id.
				utran_geran_global_cell_id.cell_identity),
		SON_OAM_NR_DELETE_FROM_REM_LIST_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		FOUR_BYTE_TYPE,
		/* SPR 11156 FIX START */
		OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION
			/* SPR 11156 FIX END */
	}
};

/* spr_21013_fix_start */
parameter_map_element_t g_parameter_TR_InterFreq_Carrier_element[] = {
 /* SPR 14651 START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.Enable",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).eutran_meas_enable[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).eutran_meas_enable[0].enable),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"Enable",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
	},
 /* SPR 14651 END */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.EUTRACarrierARFCN",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].earfcn),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"EUTRACarrierARFCN",
		UINT32_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier."
			"X_VENDOR_MEAS_BANDWIDTH_FOR_EARFCN",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].meas_bandwidth_for_earfcn),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_meas_bandwidth,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"X_VENDOR_MEAS_BANDWIDTH_FOR_EARFCN",
		UINT32_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier."
			"X_VENDOR_PRESENCE_ANTENNA_PORT1",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].presence_antenna_port),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_presence_antenna_port,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"X_VENDOR_PRESENCE_ANTENNA_PORT1",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier."
			"X_VENDOR_NEIGHBOR_CELL_CONFIG",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].neighbor_cell_config),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_neighbor_cell_config,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"X_VENDOR_NEIGHBOR_CELL_CONFIG",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.QOffsetFreq",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].offset_frequency),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_offset_frequency,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"QOffsetFreq",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.QRxLevMinSIB5",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].q_rx_lev_min),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_q_rx_lev_min,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"QRxLevMinSIB5",
		SINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.PMax",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].p_max),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_p_max,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"PMax",
		SINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.TReselectionEUTRA",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].t_reselection),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_t_reselection,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"TReselectionEUTRA",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN." 
			"Mobility.IdleMode.InterFreq.Carrier.TReselectionEUTRASFMedium",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].t_reselection_sf.sf_medium),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_t_reselection_sf,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"TReselectionEUTRASFMedium",
		UINT32_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.TReselectionEUTRASFHigh",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].t_reselection_sf.sf_high),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_t_reselection_sf,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"TReselectionEUTRASFHigh",
		UINT32_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.ThreshXHigh",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].threshX_high),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_threshX_high,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"ThreshXHigh",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.ThreshXLow",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].threshX_low),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_threshX_low,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"ThreshXLow",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.CellReselectionPriority",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].cell_reselection_priority),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_cell_reselection_priority,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"CellReselectionPriority",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_Q_QUAL_MIN_R9",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].q_qualmin_r9),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_q_qualmin_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"X_VENDOR_Q_QUAL_MIN_R9",
		SINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_THRESHX_HIGHQ_R9",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].threshx_highq_r9),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_threshx_highq_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"X_VENDOR_THRESHX_HIGHQ_R9",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_CM_OFFSET_FREQ",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].cm_offset_frequency),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_cm_offset_freq,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[0]),
		"X_VENDOR_CM_OFFSET_FREQ",
		UINT32_TYPE,
		/* SPR 13850 FIX START */
		(MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_THRESHX_LOWQ_R9",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].threshx_lowq_r9),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_threshx_lowq_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		"X_VENDOR_THRESHX_LOWQ_R9",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	/* SPR 9574 Fix Start */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_OPEN_PHY_CELLID_START",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].inter_freq_open_pci_range.pci_start),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		/* SPR 13177 FIX START */
		"X_VENDOR_OPEN_PHY_CELLID_START",
		/* SPR 13177 FIX END */
		UINT16_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_OPEN_PHY_CELLID_RANGE",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].inter_freq_open_pci_range.pci_range),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_open_pci_range,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		/* SPR 13177 FIX START */
		"X_VENDOR_OPEN_PHY_CELLID_RANGE",
		/* SPR 13177 FIX END */
		/* SPR 12920 START */
		OAM_ENUM_TYPE,
		/* SPR 12920 END */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_CSG_PHY_CELLID_START",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].inter_freq_closed_pci_range.pci_start),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		/* SPR 13177 FIX START */
		"X_VENDOR_CSG_PHY_CELLID_START",
		/* SPR 13177 FIX END */
		UINT16_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{ 
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_CSG_PHY_CELLID_RANGE",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].inter_freq_closed_pci_range.pci_range),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_closed_pci_range,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		/* SPR 13177 FIX START */
		"X_VENDOR_CSG_PHY_CELLID_RANGE",
		/* SPR 13177 FIX END */
		/* SPR 12920 START */
		OAM_ENUM_TYPE,
		/* SPR 12920 END */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_HYBRID_PHY_CELLID_START",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].inter_freq_hybrid_pci_range.pci_start),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		/* SPR 13177 FIX START */
		"X_VENDOR_HYBRID_PHY_CELLID_START",
		/* SPR 13177 FIX END */
		UINT16_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_HYBRID_PHY_CELLID_RANGE",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list[0].inter_freq_hybrid_pci_range.pci_range),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_hybrid_pci_range,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Carrier[OAM_ZERO]),
		/* SPR 13177 FIX START */
		"X_VENDOR_HYBRID_PHY_CELLID_RANGE",
		/* SPR 13177 FIX END */
		/* SPR 12920 START */
		OAM_ENUM_TYPE,
		/* SPR 12920 END */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	}
	/* SPR 9574 Fix End */
};





parameter_map_element_t g_parameter_TR_UTRA_FDD_element[] = {
 /* SPR 14651 START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.Enable",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).utran_meas_enable[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).utran_meas_enable[0].enable),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"Enable",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
	},
 /* SPR 14651 END */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.UTRACarrierARFCN",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.utran_config_list.utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.utran_config_list.
				utran_fdd_list[OAM_ZERO].uarfcn),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"UTRACarrierARFCN",
		UINT16_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.X_VENDOR_OFFSET_FREQUENCY",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.utran_config_list.
				utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.utran_config_list.
				utran_fdd_list[OAM_ZERO].offset_frequency),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_offset_frequency,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"X_VENDOR_OFFSET_FREQUENCY",
		SINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY) 
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.QRxLevMin",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO].q_rx_lev_min),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_q_rx_lev_min,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"QRxLevMin",
		SINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.QQualMin",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO].q_qual_min),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_q_qual_min,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"QQualMin",
		SINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.CellReselectionPriority",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.utran_config_list.
				utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.utran_config_list.
				utran_fdd_list[OAM_ZERO].cell_reselection_priority),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_cell_reselection_priority,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"CellReselectionPriority",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.ThreshXHigh",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO].threshX_high),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_threshX_high,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"ThreshXHigh",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.ThreshXLow",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO].threshX_low),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_threshX_low,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"ThreshXLow",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.PMaxUTRA",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO].p_max),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_p_max,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"PMaxUTRA",
		SINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq."
			"X_VENDOR_THRESHX_HIGHQ_R9",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO].threshx_highq_r9),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_threshx_highq_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"X_VENDOR_THRESHX_HIGHQ_R9",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.X_VENDOR_THRESHX_LOWQ_R9",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[OAM_ZERO].threshx_lowq_r9),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_fdd_threshx_lowq_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANFDDFreq[OAM_ZERO]),
		"X_VENDOR_THRESHX_LOWQ_R9",
		UINT8_TYPE,
		/* SPR 13850 FIX START */
		(OAM_IS_CELL_SPEC_PARAM | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY
		 | OAM_MANDATORY_PARAM)
			/* SPR 13850 FIX END */
	}
};

/* SPR FIX 11266 - */

/* RT SPR 9019 FIX START */

/* CA_CHANGE_FOR_GET_SET_START */
parameter_map_element_t g_parameter_UTRA_TDD_element[] = {
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS."
			"UTRA_CARRIER_ARFCN",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0].uarfcn),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANTDDFreq[0],
		"UTRA_CARRIER_ARFCN",
		UINT16_TYPE,
		(OAM_IGNORE_VALIDATION | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
    /*SPR 13944 START*/
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
        "Mobility.IdleMode.IRAT.UTRA.UTRANTDDFreq.X_VENDOR_OFFSET_FREQUENCY",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[OAM_ZERO].offset_frequency),
        OAM_SON_ANR_MEAS_CONFIG_MASK,
        OAM_NULL,
        &set_bitmask_utra_tdd_offset_frequency,
        OAM_NULL,
        "OFFSET_FREQUENCY",
        SINT8_TYPE,
        (OAM_READ_ONLY | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
    },
    /*SPR 13944 END*/
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS."
			"CELL_RESELECTION_PRIORITY",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0].cell_reselection_priority),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_tdd_cell_reselection_priority,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANTDDFreq[0],
		"CELL_RESELECTION_PRIORITY",
		UINT8_TYPE,
		(OAM_IGNORE_VALIDATION | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS."
			"THRESH_X_HIGH",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0].threshX_high),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_tdd_threshX_high,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANTDDFreq[0],
		"THRESH_X_HIGH",
		UINT8_TYPE,
		(OAM_IGNORE_VALIDATION | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS."
			"THRESH_X_LOW",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0].threshX_low),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_tdd_threshX_low,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANTDDFreq[0],
		"THRESH_X_LOW",
		UINT8_TYPE,
		(OAM_IGNORE_VALIDATION | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS."
			"Q_RX_LEV_MIN",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0].q_rx_lev_min),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_tdd_q_rx_lev_min,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANTDDFreq[0],
		"Q_RX_LEV_MIN",
		SINT8_TYPE,
		(OAM_IGNORE_VALIDATION | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS."
			"P_MAX_UTRA",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_tdd_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list[0].p_max),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_tdd_p_max,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRANTDDFreq[0],
		"P_MAX_UTRA",
		SINT8_TYPE,
		(OAM_IGNORE_VALIDATION | MULTI_INSTANCE_PARAM | OAM_WRITE_ONLY)
	}
};
/* RT SPR 9019 FIX END */
/* SPR FIX 11266 START */
parameter_map_element_t g_parameter_TR_UTRA_element[] = {
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreqNumberOfEntries",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.utran_fdd_list_size),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRA),
		"UTRANFDDFreqNumberOfEntries",
		UINT8_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.TReselectionUTRA",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.t_reselection),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_t_reselection,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRA),
		"TReselectionUTRA",
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_READ_ONLY )
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.TReselectionUTRASFMedium",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.t_reselection_sf.sf_medium),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_t_reselection_sf,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRA),
		"TReselectionUTRASFMedium",
		UINT32_TYPE,
		(OAM_WRITE_ONLY | OAM_READ_ONLY )
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.UTRA.TReselectionUTRASFHigh",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				utran_config_list.t_reselection_sf.sf_high),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_utra_t_reselection_sf,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UTRA),
		"TReselectionUTRASFHigh",
		UINT32_TYPE,
		(OAM_WRITE_ONLY | OAM_READ_ONLY )
	}
};
/* spr_21013_fix_end */
/* SPR FIX 11266 END */
/* CA_CHANGE_FOR_GET_SET_END*/
parameter_map_element_t g_parameter_son_anr_enable_req[] = 
{
	{
		"SON_ANR_ENABLE.ue_count",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].ue_cnt),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_ue_count,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON_ANR_ENABLE.reporting_interval",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].reporting_interval),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_reporting_interval,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,        
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON_ANR_ENABLE.limited_mode",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].limited_mode),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_limited_mode,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,        
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON_ANR_ENABLE.no_activity_interval",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].removal_criteria.
				no_activity_interval),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_no_act_int,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,        
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON_ANR_ENABLE.ho_failure_threshold",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].removal_criteria.
				handover_failure_threshold),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_ho_failure_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,        
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON_ANR_ENABLE.timeout_no_nr_neighbors",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].removal_criteria.
				timeout_no_nr_neighbors),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_timeout_no_nr_neighbors,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,        
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON_ANR_ENABLE.suspect_pci_threshold",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].pci_confusion_cfg.
				suspect_pci_threshold),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_suspect_pci_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON_ANR_ENABLE.clear_suspect_pci_threshold",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].pci_confusion_cfg.
				clear_suspect_pci_threshold),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_clear_suspect_pci_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
    /* SPR 20653 Fix Start */
	{
		"SON_ANR_ENABLE.ue_throughput_dl_anr_threshold",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].ue_throughput_dl_anr_threshold),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_ue_throughput_dl_anr_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON_ANR_ENABLE.ue_throughput_ul_anr_threshold",
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.anr_enable[OAM_ZERO].ue_throughput_ul_anr_threshold),
		OAM_SON_ANR_ENABLE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_enable_ue_throughput_ul_anr_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	}
    /* SPR 20653 Fix End */
};

/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_son_nw_scan_req[] = 
{
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.InServiceHandling",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.in_service_handling),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"InServiceHandling",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanOnBoot",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.temp_values.scan_on_boot),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"ScanOnBoot",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanPeriodically",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.periodic_nw_scan.scan_on_off),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"ScanPeriodically",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.PeriodicInterval",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.periodic_nw_scan.scan_time_interval),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"PeriodicInterval",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.PeriodicTime",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.periodic_time),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"PeriodicTime",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.REMPLMNList",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.temp_values.nw_scan_plmn_list),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		&set_bitmask_son_nw_scan_plmn_list,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"REMPLMNList",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.REMBandList",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nw_scan.
				start_intra_rat_scan_req.freq_band_id),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"REMBandList",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)        
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.EUTRACarrierARFCNDLList",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.temp_values.nw_scan_earfcn_list),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		&oam_nw_scan_set_bitmask_earfcn_dl_list,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"EUTRACarrierARFCNDLList",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanTimeout",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.scan_timeout),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"ScanTimeout",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE."
			"X_VENDOR_PCI_LIST",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.temp_values.nw_scan_pci_list),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		/*SPR 12001 FIX START*/
		&set_bitmask_son_nw_scan_pci_list,
		/*SPR 12001 FIX END*/
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"X_VENDOR_PCI_LIST",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)        
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE."
			"X_VENDOR_MEAS_BANDWIDTH",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.
				meas_bandwidth),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		&set_bitmask_son_nw_scan_meas_bandwidth,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"X_VENDOR_MEAS_BANDWIDTH",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)        
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE."
			"X_VENDOR_RETRY_COUNT",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.
				retry_count),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"X_VENDOR_RETRY_COUNT",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)        
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE."
			"X_VENDOR_MEASUREMENT_PERIOD",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.
				measurement_period),
		OAM_SON_NW_SCAN_EUTRAN_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"X_VENDOR_MEASUREMENT_PERIOD",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
    /* OAM BCOM Code Comment Changes Start */
    {
        "InternetGatewayDevice.Services.FAPService.REM.LTE.CarrierARFCNDL",
        &(local_prov_req.oam_son_req),
        OAM_NULL,        
        &(local_prov_req.oam_son_req.temp_values.CarrierARFCNDL),
        OAM_SON_NW_SCAN_EUTRAN_MASK,
        OAM_NULL,
        &oam_nw_scan_set_bitmask_carrier_ch_width,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas,
        "CarrierARFCNDL",
        OAM_TWO,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.Services.FAPService.REM.LTE.CarrierChWidth",
        &(local_prov_req.oam_son_req),
        OAM_NULL,        
        &(local_prov_req.oam_son_req.temp_values.CarrierChWidth),
        OAM_SON_NW_SCAN_EUTRAN_MASK,
        OAM_NULL,
        OAM_NULL,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas,
        "CarrierChWidth",
        OAM_ONE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    }
    /* OAM BCOM Code Comment Changes End */
};

/*+ SPR 18392*/
/*SPR_16048 Fix Start*/
parameter_map_element_t g_parameter_son_nw_scan_status[] =
{
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanStatus",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.nw_scan_status.scan_status),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"ScanStatus",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)

	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.ErrorDetails",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.nw_scan_status.error_details),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"ErrorDetails",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.LastScanTime",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.nw_scan_status.last_scan_time),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"LastScanTime",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},   
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.MaxCellEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.nw_scan_status.max_cell_entry),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"MaxCellEntries",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},   
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.CellNumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.nw_scan_status.num_cell_entry),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"CellNumberOfEntries",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.MaxCarrierMeasEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.nw_scan_status.max_carrier_meas_entry),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"MaxCarrierMeasEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.CarrierMeasNumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.carrier_meas_number_of_entries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,
		"CarrierMeasNumberOfEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	}
};
/*SPR_16048 Fix End*/
/*- SPR 18392*/
parameter_map_element_t g_parameter_son_nw_scan_results_rf []= 
{
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF.EUTRACarrierARFCN",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].carrier_earfcn),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,
		"EUTRACarrierARFCN",
		UINT16_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF.RSSI",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].rssi),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,
		"RSSI",
		SINT16_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF.PhyCellID",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].phy_cell_id),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,
		"PhyCellID",
		UINT16_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF.RSRP",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].rsrp),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,
		"RSRP",
		SINT16_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF.RSRQ",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].rsrq),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2,
		"RSRQ",
		SINT16_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};
#endif
/* spr_21013_fix_end */

/* SPR 9986 FIX START */ 
parameter_map_element_t g_parameter_pm_gpv_spv_param [] =
{
	{
		"InternetGatewayDevice.FAP.PerfMgmt.ConfigNumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.ConfigNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.PerfMgmt),
		"ConfigNumberOfEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},


	{
		"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].X_VENDOR_FileWriteTimer",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.file_write_timer),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Config),
		"X_VENDOR_FileWriteTimer",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].X_VENDOR_SamplingInterval",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.sampling_interval_timer),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Config),
		"X_VENDOR_SamplingInterval",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},

	{
		"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].Enable",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.Enable),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Config),
		"Enable",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].PeriodicUploadInterval",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadInterval),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Config),
		"PeriodicUploadInterval",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	}, 
	{
		"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].PeriodicUploadTime",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadTime),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Config),
		"PeriodicUploadTime",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].URL",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.URL),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Config),
		"URL",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].Username",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.Username),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Config),
		"Username",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].Password",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.perf_mgmt_params.Password),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Config),
		"Password",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	}
};

/* SPR 9986 FIX END */ 
/***************9854 bug fix***************/
#ifdef OAM_SON_ENABLE
/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_son_rem_lte_carrierMeas[] = {
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE."
			"CarrierMeas.CarrierARFCNDL",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.carrier_arfcndl),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas),
		"CarrierARFCNDL",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE."
			"CarrierMeas.CarrierChWidth",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.carrier_chwidth),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas),
		"CarrierChWidth",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE."
			"CarrierMeas.CarrierRSSI",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.carrier_rssi),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas),
		"CarrierRSSI",
		SINT8_TYPE,
		(OAM_READ_ONLY)
	}
};
/* spr_21013_fix_end */
/***************9854 bug end***************/
/* BUG_FIXED_11744_START */
/****************************************************************************
 * Function Name : set_bitmask_rachopt_report_periodicity
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/

void 
set_bitmask_rachopt_report_periodicity
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;  
	if(OAM_NULL != p_req)
	{ 
		p_req->rach_config_params.bitmask |= 
			SON_RACHOPT_REPORT_PERIODICITY_PRESENT;
	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_report_periodicity");

	}
	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_rachopt_min_ue_rach_report_count
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/


void 
set_bitmask_rachopt_min_ue_rach_report_count
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;  
	if(OAM_NULL != p_req)
	{

		p_req->rach_config_params.bitmask |= 
			SON_RACHOPT_MIN_UE_RACH_REPORT_COUNT_PRESENT;
	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_min_ue_rach_report_count");

	}


	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_rachopt_ue_rach_attempts_threshold
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void 
set_bitmask_rachopt_ue_rach_attempts_threshold
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;  
	if(OAM_NULL != p_req)
	{

		p_req->rach_config_params.bitmask |= 
			SON_RACHOPT_UE_RACH_ATTEMPTS_THRESHOLD_PRESENT;
	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_ue_rach_attempts_threshold");

	}

	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_rachopt_start_threshold
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void 
set_bitmask_rachopt_start_threshold
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;  
	if(OAM_NULL != p_req)
	{


		p_req->rach_config_params.bitmask |= 
			SON_RACHOPT_START_THRESHOLD_PRESENT;
	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_start_threshold");

	}


	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_rachopt_stop_threshold
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void 
set_bitmask_rachopt_stop_threshold
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;  
	if(OAM_NULL != p_req)
	{

		p_req->rach_config_params.bitmask |= 
			SON_RACHOPT_STOP_THRESHOLD_PRESENT;
	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_stop_threshold");

	}


	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_rachopt_degrade_stop_offset
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void 
set_bitmask_rachopt_degrade_stop_offset
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;  
	if(OAM_NULL != p_req)
	{

		p_req->rach_config_params.bitmask |=
			SON_RACHOPT_DEGRADE_STOP_OFFSET_PRESENT;
	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_degrade_stop_offset");

	}


	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_rachopt_max_iterations_to_reach_stop_threshold
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void 
set_bitmask_rachopt_max_iterations_to_reach_stop_threshold
(
 int loop,
 void *p_rachopt_req
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;   
	if(OAM_NULL != p_req)
	{

		p_req->rach_config_params.bitmask |=
			SON_RACHOPT_MAX_ITERATIONS_TO_REACH_STOP_THRESHOLD_PRESENT;

	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in"  
				"set_bitmask_rachopt_max_iterations_to_reach_stop_threshold");

	}


	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_rachopt_contention_threshold
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void 
set_bitmask_rachopt_contention_threshold
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;   
	if(OAM_NULL != p_req)
	{
		p_req->rach_config_params.bitmask |=
			SON_RACHOPT_CONTENTION_THRESHOLD_PRESENT;
	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_contention_threshold");

	}


	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_rachopt_power_rampup_threshold
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void 
set_bitmask_rachopt_power_rampup_threshold
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;   
	if(OAM_NULL != p_req)
	{

		p_req->rach_config_params.bitmask |=
			SON_RACHOPT_POWER_RAMPUP_THRESHOLD_PRESENT;
	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_power_rampup_threshold");

	}


	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_rachopt_min_cfra_preambles
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void 
set_bitmask_rachopt_min_cfra_preambles
(
 int loop,
 void * p_rachopt_req 
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_rach_opt_modify_config_params_req_t *p_req  = p_rachopt_req;   
	if(OAM_NULL != p_req)
	{
		p_req->rach_config_params.bitmask |=
			SON_RACHOPT_MIN_CFRA_PREAMBLES_PRESENT;

	}
	else
	{

		OAM_LOG(OAM,OAM_WARNING,"NULL POINTER FAIL in set_bitmask_rachopt_min_cfra_preambles");

	}


	OAM_FUN_EXIT_TRACE();
}

/* BUG_FIXED_11744_END */

/* SPR 11687 FIX START */
parameter_map_element_t g_parameter_rach_opt_config_params [] =
{
	{
		"SON_RACH-OPT_CONFIG.RACHOPT_REPORT_PERIODICITY",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_report_periodicity),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_report_periodicity),
		OAM_NULL,
        /* SPR 17375 START */
		"RACHOPT_REPORT_PERIODICITY",
        /* SPR 17375 END */
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_MIN_UE_RACH_REPORT_COUNT",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_min_ue_rach_report_count),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_min_ue_rach_report_count),
		OAM_NULL,
        /* SPR 17375 START */
		"RACHOPT_MIN_UE_RACH_REPORT_COUNT",
        /* SPR 17375 END*/
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_UE_RACH_ATTEMPTS_THRESHOLD",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_ue_rach_attempts_threshold),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_ue_rach_attempts_threshold),
		OAM_NULL,
        /* SPR 17375 START */
        "RACHOPT_UE_RACH_ATTEMPTS_THRESHOLD",
        /* SPR 17375 END*/
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_START_THRESHOLD",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_start_threshold),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_start_threshold),
		OAM_NULL,
        /* SPR 17375 START */
        "RACHOPT_START_THRESHOLD",
        /* SPR 17375 END*/
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_STOP_THRESHOLD",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_stop_threshold),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_stop_threshold),
		OAM_NULL,
        /* SPR 17375 START */
        "RACHOPT_STOP_THRESHOLD",
        /* SPR 17375 END*/
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_DEGRADE_STOP_OFFSET",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_degrade_stop_offset),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_degrade_stop_offset),
		OAM_NULL,
        /* SPR 17375 START */
        "RACHOPT_DEGRADE_STOP_OFFSET",
        /* SPR 17375 END*/
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_MAX_ITERATIONS_TO_REACH_STOP_THRESHOLD",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_max_iterations_to_reach_stop_threshold),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_max_iterations_to_reach_stop_threshold),
		OAM_NULL,
        /* SPR 17375 START */
        "RACHOPT_MAX_ITERATIONS_TO_REACH_STOP_THRESHOLD",
        /* SPR 17375 END*/
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_CONTENTION_THRESHOLD",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_contention_threshold),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_contention_threshold),
		OAM_NULL,
        /* SPR 17375 START */
        "RACHOPT_CONTENTION_THRESHOLD",
        /* SPR 17375 END*/
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_POWER_RAMPUP_THRESHOLD",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_power_rampup_threshold),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_power_rampup_threshold),
		OAM_NULL,
        /* SPR 17375 START */
        "RACHOPT_POWER_RAMPUP_THRESHOLD",
        /* SPR 17375 END*/
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},      

	{
		"SON_RACH-OPT_CONFIG.RACHOPT_MIN_CFRA_PREAMBLES",
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.rach_opt_modify_config_params[OAM_ZERO].rach_config_params.rachopt_min_cfra_preambles),
		OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK,
		OAM_NULL,
		&(set_bitmask_rachopt_min_cfra_preambles),
		OAM_NULL,
        /* SPR 17375 START */
        "RACHOPT_MIN_CFRA_PREAMBLES",
        /* SPR 17375 END*/
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	}       


};
/* SPR 11687 FIX END */


#endif


/******************************************************************************
 * Function Name  : fill_str_for_multi_instance 
 * Inputs         :
 * Outputs        :
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : this function handles the Rem Lte for partial path 
 *******************************************************************************/
void 
fill_str_for_multi_instance
(  
 UInt8 *des_str,
 UInt8 *src_parent_str,
 UInt8 *src_parameter_str,
 UInt16 loop
 )
{
	/* SPR 12698 FIX START */
	oam_snprintf((char * )des_str,TEMP_PTR_BUFFER_SIZE,"%s[%d].",src_parent_str,loop);/* Coverity FIX 33228 */
	/* SPR 12698 FIX END */
	oam_strcat((char *)des_str,(char *)src_parameter_str); /* Coverity FIX 33228 */
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_cell_restriction_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
set_bitmask_cell_restriction_params
(
 int loop,
 void * p_cell_reconfig_req  
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_CELL_ACCESS_PARAMS_PRESENT;

	OAM_FUN_EXIT_TRACE();
}

#ifdef OAM_SON_ENABLE
/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_son_nw_scan_results_bcch_plmnlist[] =
{
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.PLMNList.PLMNID",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.plmn_id),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].PLMNList_2),
		"PLMNID",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.PLMNList.CellReservedForOperatorUse",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.cell_reserved_for_operator_use),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].PLMNList_2),
		"CellReservedForOperatorUse",
		UINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
};

parameter_map_element_t g_parameter_son_nw_scan_results_bcch [] =
{
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.DLBandwidth",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.dl_bandwidth),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"DLBandwidth",
		UINT16_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.ULBandwidth",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.ul_bandwidth),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"ULBandwidth",
		UINT16_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.RSTxPower",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.rx_tx_power),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"RSTxPower",
		SINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.TAC",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.tac),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"TAC",
		UINT16_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.CellID",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.cell_identity),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"CellID",
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.CellBarred",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.cell_barred),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"CellBarred",
		UINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.CSGIndication",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.csg_indication),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"CSGIndication",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.CSGIdentity",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.csg_identity),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"CSGIdentity",
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.MaxPLMNListEntries",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.max_plmn_entry),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"MaxPLMNListEntries",
		UINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.PLMNListNumberOfEntries",
		&(local_prov_req.oam_son_req.oam_nw_scan_result),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]),
		&(local_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[OAM_ZERO].oam_bcch_data.num_plm_entry),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH,
		"PLMNListNumberOfEntries",
		UINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};
/* spr_21013_fix_end */
#endif

/*SPR 13518 START*/
parameter_map_element_t g_parameter_cell_block_param [] =
{
	{
		"Cell.Block.Cell_Identity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.eutran_global_cell_id),
		OAM_RRM_CELL_BLOCK_REQ_MASK,
		&validate_start_stop_cell_identity,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_ZERO,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"Cell.Block.Cell_Block_Priority",
		/*SPR 14451 START*/
		&(local_prov_req.oam_rrm_req),
		/*SPR 14451 END*/
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_priority),
		OAM_RRM_CELL_BLOCK_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"Cell.Block.Resource_Cleanup_Timer",
		/*SPR 14451 START*/
		&(local_prov_req.oam_rrm_req),
		/*SPR 14451 END*/
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_resource_cleanup_timer),
		OAM_RRM_CELL_BLOCK_REQ_MASK,
		OAM_NULL,
		&set_bitmask_cell_bloack_cleanup_timer,
		OAM_NULL,
		OAM_NULL,
		SINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	}
};
/*SPR 13518 END*/

/*SPR 15527 START*/
/* Modified oam_rrm_req.qos_obj_list[OAM_ZERO] to
 * oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO],
 * throughout the file to support dual cell. */
/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_TR_QOS_element[] = {
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.Enable",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_enable),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_epc_info,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "Enable",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"QoS.QCI",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.qci),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_epc_info,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
		"QCI",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"QoS.Type",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.type),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_epc_info,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
		"Type",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"QoS.Priority",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.priority),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_epc_info,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
		"Priority",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"QoS.PacketDelayBudget",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.packet_delay_budget),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_epc_info,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
		"PacketDelayBudget",
		OAM_ENUM_TYPE,
		(OAM_READ_ONLY  | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"QoS.X_VENDOR_TTI_BUNDLING",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.tti_bundling),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_tti_bundling,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
		"X_VENDOR_TTI_BUNDLING",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"QoS.X_VENDOR_PACKETERRORLOSSRATE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.packet_error_loss_rate),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
        /*SPR 17376 START*/
		&set_bitmask_packet_error_loss_rate,
        /*SPR 17376 END*/
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
		"X_VENDOR_PACKETERRORLOSSRATE",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
        /*SPR 17376 START*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
        /*SPR 17376 END*/
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DSCP",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.dscp),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_dscp,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DSCP",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SPS_CONFIG_ENABLED",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_config_enabled),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sps_config_enabled,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SPS_CONFIG_ENABLED",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_DL",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_data.sps_config_dl.semi_persist_sched_interval_dl),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sps_config_dl,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_DL",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_NUMBER_OF_CONF_SPS_PROCESSES",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_data.sps_config_dl.number_of_conf_sps_processes),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sps_config_dl,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_NUMBER_OF_CONF_SPS_PROCESSES",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_MAX_SPS_HARQ_RETX",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_data.sps_config_dl.max_sps_harq_retx),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sps_config_dl,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_MAX_SPS_HARQ_RETX",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_EXPLICIT_RELEASE_AFTER",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_data.sps_config_dl.explicit_release_after),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sps_config_dl,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_EXPLICIT_RELEASE_AFTER",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_data.sps_config_ul.semi_persist_sched_interval_ul),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sps_config_ul,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SEMI_PERSIST_SCHED_INTERVAL_UL",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_IMPLICIT_RELEASE_AFTER",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_data.sps_config_ul.implicit_release_after),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sps_config_ul,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_IMPLICIT_RELEASE_AFTER",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_P_ZERO_NOMINAL_PUSCH_PERSISTENT",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_data.sps_config_ul.p_zero_nominal_pusch_persistent),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sps_config_ul,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_P_ZERO_NOMINAL_PUSCH_PERSISTENT",
        SINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_TWO_INTERVAL_CONFIG",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sps_data.sps_config_ul.two_interval_supported),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_TWO_INTERVAL_CONFIG",
        SINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IGNORE_VALIDATION | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_LOSSLESS_HO_REQUIRED",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.lossless_ho_required),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_lossless_ho_required,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_LOSSLESS_HO_REQUIRED",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DL_FORWARDING_APPLICABILTIY",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.dl_forwarding_applicability),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_dl_forwarding_applicability,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DL_FORWARDING_APPLICABILTIY",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_UE_INACTIVITY_TIMER_CONFIG",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.ue_inactivity_timer_config),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_ue_inactivity_timer_config,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_UE_INACTIVITY_TIMER_CONFIG",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SUPPORTED_RAT",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.supported_rat),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_epc_info,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SUPPORTED_RAT",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.MIN_UL_BITRATE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.ul_min_bitrate),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/
        &set_bitmask_ul_min_bitrate,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "MIN_UL_BITRATE",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
	},
    {

        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.MIN_DL_BITRATE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.dl_min_bitrate ),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/
        &set_bitmask_dl_min_bitrate,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "MIN_DL_BITRATE",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_RLC_MODE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rlc_mode),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_rlc_mode,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_RLC_MODE",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SN_LEN_DL_RLC",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sn_field_len.dl_rlc),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sn_field_len_dl_rlc,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SN_LEN_DL_RLC",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SN_LEN_UL_RLC",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sn_field_len.ul_rlc),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sn_field_len_ul_rlc,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SN_LEN_UL_RLC",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DL_PARAM_T_REORDERING_AM",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.addl_rlc_param.t_reordering_am),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_t_reordering_am,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DL_PARAM_T_REORDERING_AM",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DL_PARAM_T_REORDERING_UM",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.addl_rlc_param.t_reordering_um),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_t_reordering_um,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DL_PARAM_T_REORDERING_UM",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_UL_AM_POLL_BYTE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.addl_rlc_param.ul_am_poll_byte),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_ul_am_poll_byte,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_UL_AM_POLL_BYTE",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_MAX_RETX_THRESHOLD",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.addl_rlc_param.ul_am_rrc_max_retx_threshold),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_ul_am_rrc_max_retx_threshold,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_MAX_RETX_THRESHOLD",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DISCARD_TIMER",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.pdcp_discard_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_pdcp_discard_timer,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DISCARD_TIMER",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_RLC_AM_STATUS_REPORT_REQUIRED",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rlc_am_status_report_required),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_rlc_am_status_report_required,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_RLC_AM_STATUS_REPORT_REQUIRED",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_RLC_AM_ENB_STATUS_REPORT_REQUIRED",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rlc_am_enb_status_report_required),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_rlc_am_enb_status_report_required,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_RLC_AM_ENB_STATUS_REPORT_REQUIRED",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_RLC_UM_PDCP_SN_SIZE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sn_field_len.rlc_um_pdcp_sn_size),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_rlc_um_pdcp_sn_size,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_RLC_UM_PDCP_SN_SIZE",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ENABLE_ROHC",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.enable_rohc),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/
        &set_bitmask_enable_rohc,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ENABLE_ROHC",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.MAX_CID",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.max_cid),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/
        &set_bitmask_max_cid,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "MAX_CID",
        UINT16_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0001",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0001),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0001,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0001",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0002",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0002),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0002,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0002",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0003",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0003),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0003,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0003",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0004",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0004),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0004,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0004",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0006",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0006),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0006,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0006",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0101",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0101),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0101,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0101",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0102",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0102),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0102,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0102",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0103",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0103),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0103,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0103",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.ROHC_PROFILE0X0104",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.rohc_params.rohc_profiles.rohc_profile0x0104),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        /*SPR 17376 START*/
        &validate_qos_grandchild,
        /*SPR 17376 END*/        
        &set_bitmask_rohc_profile0x0104,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "ROHC_PROFILE0X0104",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_MAX_HARQ_TX",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.max_harq_tx),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_max_harq_tx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_MAX_HARQ_TX",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_MAX_HARQ_RETRANS",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.max_harq_retrans),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_max_harq_retrans,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_MAX_HARQ_RETRANS",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_LOGICAL_CHANNEL_GROUP",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.logical_channel_group),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_logical_channel_group,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_LOGICAL_CHANNEL_GROUP",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SR_MASK_FLAG",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sr_configuration.sr_mask_flag),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sr_configuration,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SR_MASK_FLAG",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SR_PROHIBIT_TIMER_R9",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sr_configuration.sr_prohibit_timer_r9),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sr_configuration,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SR_PROHIBIT_TIMER_R9",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */

    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DSR_MAX_TRANSMISSIONS",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.sr_configuration.dsr_trans_max),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_sr_configuration,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DSR_MAX_TRANSMISSIONS",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DDL_PARAM_T_STATUES_PROHIBIT",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.addl_rlc_param.t_status_prohibit),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_t_status_prohibit,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DDL_PARAM_T_STATUES_PROHIBIT",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DDL_PARAM_T_POLL_PDU",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.addl_rlc_param.t_poll_pdu),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_t_poll_pdu,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DDL_PARAM_T_POLL_PDU",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DDL_PARAM_T_POLL_RETRANSMIT",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.addl_rlc_param.t_poll_retransmit),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_t_poll_retransmit,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DDL_PARAM_T_POLL_RETRANSMIT",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SRVCC_OP_REQUIRED",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.srvcc_op_required),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_srvcc_op_required,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SRVCC_OP_REQUIRED",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DRX_ENABLED",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_enabled),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_epc_info,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DRX_ENABLED",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DRX_ON_DURATION_TIMER",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_per_qci_info.on_duration_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DRX_ON_DURATION_TIMER",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DRX_INACTIVITY_TIMER",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_per_qci_info.drx_inactivity_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DRX_INACTIVITY_TIMER",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DRX_RETRANSMISSION_TIMER",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_per_qci_info.drx_retransmission_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DRX_RETRANSMISSION_TIMER",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_LONG_DRX_CYCLE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_per_qci_info.long_drx_cycle),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_LONG_DRX_CYCLE",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
#ifdef ENDC_ENABLED
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_LONG_DRX_CYCLE_R15",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_per_qci_info.long_drx_cycle_r15),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_LONG_DRX_CYCLE_R15",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
#endif
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DRX_START_OFFSET",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_per_qci_info.drx_start_offset),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DRX_START_OFFSET",
        UINT16_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_SHORT_DRX_CYCLE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_per_qci_info.short_drx_cycle.short_drx_cycle),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_short_drx_cycle,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_SHORT_DRX_CYCLE",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_DRX_SHORT_CYCLE_TIMER",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].drx_per_qci_info.short_drx_cycle.drx_short_cycle_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_short_drx_cycle,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_DRX_SHORT_CYCLE_TIMER",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_BUCKET_SIZE_DURATION",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.bucket_size_duration),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_bucket_size_duration,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_BUCKET_SIZE_DURATION",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
            "QoS.X_VENDOR_PRIORITIZED_BIT_RATE",
		&(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].qos_obj_list[OAM_ZERO]),
        &(local_prov_req.oam_rrm_req.qos_data[OAM_ZERO].
                qos_obj_list[OAM_ZERO].qos_qci_info.prioritized_bit_rate),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_prioritized_bit_rate,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.QoS[OAM_ZERO]),
        "X_VENDOR_PRIORITIZED_BIT_RATE",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
    },
/*SPR 15527 END*/
};

parameter_map_element_t g_parameter_TR_element[] = {
#ifdef OAM_SON_ENABLE
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.LTECellNumberOfEntries",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		OAM_NULL,
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].nrt_info.nr_list.
				intra_rat_nr_list_size),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.MaxLTECellEntries",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		OAM_NULL,
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].max_lte_cell_entries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.UMTSNumberOfEntries",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		OAM_NULL,
        /* SPR 17373 START */
        /* SPR 18930  FIX START */
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].inter_rat_umts_neigh_size),
        /* SPR 18930  FIX END */
        /* SPR 17373 END */
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"UMTSNumberOfEntries",
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborListInUse.InterRATCell.MaxUMTSEntries",
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO]),
		OAM_NULL,
		&(LOCAL_SON_PROV_REQ.neigh_list_in_use[OAM_ZERO].max_umts_entries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"MaxUMTSEntries",
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.LTECellNumberOfEntries",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		OAM_NULL,
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				intra_rat_nr_list_size),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.NeighborList,
		"LTECellNumberOfEntries",
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.MaxLTECellEntries",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		OAM_NULL,
        /* SPR 17373 START */
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).max_nr_intra_entries),
        /* SPR 17373 END */
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.NeighborList,
		"MaxLTECellEntries",
		UINT16_TYPE,
		OAM_READ_ONLY
	},
    /* OAM BCOM Code Comment Changes Start */
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborList.LTECell.ACTION",
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
        OAM_NULL,        
//        &(LOCAL_SON_PROV_REQ.nr_action),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
                        inter_rat_nr_list_size),        
        SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        "ACTION",
        UINT16_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    /* OAM BCOM Code Comment Changes End */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.UMTSNumberOfEntries",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		OAM_NULL,
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
				inter_rat_nr_list_size),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.InterRATCell_1,
		"UMTSNumberOfEntries",
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	/* SPR-13586 START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"NeighborList.InterRATCell.MaxUMTSEntries",
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
		OAM_NULL,
		&(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).max_nr_umts_inter_entries),
		SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
		OAM_NULL,
		OAM_NULL,
		&xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.InterRATCell_1,
		"MaxUMTSEntries",
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	/* SPR-13586 END */
    /* OAM BCOM Code Comment Changes Start */
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborList.InterRATCell.UMTS.ACTION",
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
        OAM_NULL,        
//        &(LOCAL_SON_PROV_REQ.nr_action),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
                                inter_rat_nr_list_size),        
        SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT16_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborList.InterRATCell.GSM.ACTION",
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO)),
        OAM_NULL,        
//        &(LOCAL_SON_PROV_REQ.nr_action),
        &(LOCAL_SON_NEIGHBORLIST_INFO(OAM_ZERO).oam_son_nr_add_req.nr_list.
                                inter_rat_nr_list_size),        
        SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT16_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    /* OAM BCOM Code Comment Changes End */
#endif
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].RF."
			"EUTRACarrierARFCN",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.eutra_carrier_arfcn),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2),
		"EUTRACarrierARFCN",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].RF."
			"RSRP",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.rsrp),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2),
		"RSRP",
		SINT8_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].RF."
			"RSRQ",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.rsrq),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2),
		"RSRQ",
		SINT8_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].RF."
			"RSSI",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.rssi),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2),
		"RSSI",
		SINT8_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1]."
			"BCCH.RSTxPower",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.rstxpower),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"RSTxPower",
		SINT8_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1]."
			"BCCH.TAC",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.tac),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"TAC",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},      
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1]."
			"BCCH.CellID",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.cell_id),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"CellID",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1]."
			"BCCH.CellBarred",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.cell_barred),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"CellBarred",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].BCCH."
			"MaxPLMNListEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.max_plmn_list_entries),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"MaxPLMNListEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1]."
			"BCCH.PLMNListNumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.plmn_list_number_of_entries),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"PLMNListNumberOfEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1]."
			"BCCH.DLBandwidth",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.dl_bdwth),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"DLBandwidth",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceSummary",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.DeviceSummary),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.InternetGatewayDevice),
		"DeviceSummary",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	/* SPR_12373_CHANGES */
	/* Redundant Code Removed */
	/* SPR_12373_CHANGES */
	{
		"InternetGatewayDevice.DeviceInfo.Manufacturer",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.Manufacturer),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL, 
		&(xml_struct_tr196_g.DeviceInfo),
		"Manufacturer",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.ManufacturerOUI",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.ManufacturerOUI),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL, 
		&(xml_struct_tr196_g.DeviceInfo),
		"ManufacturerOUI",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.ModelName",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.ModelName),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL, 
		&(xml_struct_tr196_g.DeviceInfo),
		"ModelName",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.Description",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.Description),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"Description",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.ProductClass",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.ProductClass),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"ProductClass",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.SerialNumber",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.SerialNumber),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"SerialNumber",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.HardwareVersion",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.HardwareVersion),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"HardwareVersion",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.SoftwareVersion",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.SoftwareVersion),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"SoftwareVersion",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.ModemFirmwareVersion",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.
				ModemFirmwareVersion),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"ModemFirmwareVersion",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.AdditionalSoftwareVersion",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.
				AdditionalSoftwareVersion),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"AdditionalSoftwareVersion",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.UpTime",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.UpTime),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"UpTime",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.DeviceInfo.FirstUseDate",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.device_info_params.FirstUseDate),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.DeviceInfo),
		"FirstUseDate",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"Config.SaveConfig",
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"XML_TYPE",
		OAM_ZERO,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.FAP.Tunnel.VirtualInterfaceNumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.tunnel_params.
				VirtualInterfaceNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Tunnel),
		"VirtualInterfaceNumberOfEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.FAP.Tunnel.CryptoProfileNumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.tunnel_params.
				CryptoProfileNumberOfEntries),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Tunnel),
		"CryptoProfileNumberOfEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	/*SPR 12377 FIX START*/
	/*lines deleted*/
	/*SPR 12377 FIX END*/
	/* SPR_12373_CHANGES */
	/* Redundant Code Removed */
	/* SPR_12373_CHANGES */
	{
		"InternetGatewayDevice.FAP.Tunnel.IKESA.PeerAddress",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[0].PeerAddress),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.IKESA),
		"PeerAddress",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.DeviceType",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.services_params.DeviceType),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].FapService),
		"DeviceType",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.DNPrefix",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.services_params.DNPrefix),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].FapService),
		"DNPrefix",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl."
			"SelfConfigEvents",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.fap_control_params.SelfConfigEvents),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].FAPControl),
        /*SPR 21214 Fixed Start */
		"SelfConfigEvents",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY  )

        /*SPR 21214 Fixed End */
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl."
			"EnclosureTamperingDetected",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.fap_control_params.EnclosureTamperingDetected),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].FAPControl),
		"EnclosureTamperingDetected",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE."
			"Gateway.S1SigLinkServerList",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList),
		/* CSR 00051709 Change Start*/
		OAM_S1AP_ADD_MME_REQ_MASK,
		/* CSR 00051709 Change End*/
		&validate_s1siglink,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway),
		"S1SigLinkServerList",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE."
			"Gateway.S1ConnectionMode",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.fap_control_params.
				S1ConnectionMode),
		/* SPR 11090 Change Start*/
		OAM_S1AP_ADD_MME_REQ_MASK,
		/* SPR 11090 Change End*/
		&validate_s1connmode,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway),
		"S1ConnectionMode",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
			"TunnelNumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.cell_config_params.
				TunnelNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTE_4),
		"TunnelNumberOfEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
			"Tunnel.Enable",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.cell_config_params.Enable),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Tunnel_2),
		"Enable",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
			"Tunnel.TunnelRef",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.cell_config_params.TunnelRef),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Tunnel_2),
		"TunnelRef",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
			"Tunnel.PLMNID",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.cell_config_params.PLMNID),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Tunnel_2),
		"PLMNID",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE."
			"CDMA2000RxBandsSupported",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.capabilities_params.
				CDMA2000RxBandsSupported),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"CDMA2000RxBandsSupported",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE."
			"GSMRxBandsSupported",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.capabilities_params.
				GSMRxBandsSupported),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"GSMRxBandsSupported",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE."
			"UMTSRxBandsSupported",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.capabilities_params.
				UMTSRxBandsSupported),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"UMTSRxBandsSupported",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE."
			"Gateway.X_VENDOR_HENBIPADDRESS",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.henb_address),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway),
		"X_VENDOR_HENBIPADDRESS",
		STRING_TYPE,	
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.WANDevice.[1].WANEthernetInterfaceConfig."
			"MACAddress",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.wan_device_params.MACAddress),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.WANEthernetInterfaceConfig),
		"MACAddress",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPServiceNumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.services_params.
				FAPServiceNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Services),
		"FAPServiceNumberOfEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PUSCH.ULRS.GroupAssignmentPUSCH",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.addl_physical_layer_params.
				addtl_ul_reference_signal_params.group_assignment_pusch),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_group_assignment_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULRS),
		"GroupAssignmentPUSCH",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{      
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PUSCH.ULRS.CyclicShift",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.addl_physical_layer_params.
				addtl_ul_reference_signal_params.
				ul_reference_signal_pusch_cyclicshift),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_cyclic_shift_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULRS),
		"CyclicShift",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.ULPowerControl.DeltaFPUCCHFormat1",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				rrm_power_control_params.rrm_power_control_enable.
				delta_f_pucch_format_1),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_delta_pucch_format_1_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"DeltaFPUCCHFormat1",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.ULPowerControl.DeltaFPUCCHFormat1b",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				rrm_power_control_params.rrm_power_control_enable.
				delta_f_pucch_format_1b),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_delta_pucch_format_1b_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"DeltaFPUCCHFormat1b",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.ULPowerControl.DeltaFPUCCHFormat2",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				rrm_power_control_params.rrm_power_control_enable.
				delta_f_pucch_format_2),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_delta_pucch_format_2_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"DeltaFPUCCHFormat2",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.ULPowerControl.DeltaFPUCCHFormat2a",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				rrm_power_control_params.rrm_power_control_enable.
				delta_f_pucch_format_2a),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_delta_pucch_format_2a_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"DeltaFPUCCHFormat2a",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.ULPowerControl.DeltaFPUCCHFormat2b",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				rrm_power_control_params.rrm_power_control_enable.
				delta_f_pucch_format_2b),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_delta_pucch_format_2b_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"DeltaFPUCCHFormat2b",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.ULPowerControl.DeltaPreambleMsg3",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				rrm_power_control_params.rrm_power_control_enable.
				delta_preamble_msg_3),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_delta_preamble_msg_3_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"DeltaPreambleMsg3",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	/* START SPR_6719_FIX */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.AntennaInfo.AntennaPortsCount",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
        /* SPR 20653 Fix Start */
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
			    rf_params.rf_configurations.antenna_ports_count_number),
        /* SPR 20653 Fix End */
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	/* RT SPR 8154 FIX START */
	/*  LINES DELETED */
	/* RT SPR 8154 FIX END */
	/* END SPR_6719_FIX */

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.MBSFN.NeighCellConfig",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.neigh_cell_config),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		/* START CSR : 00056074, CSR : 00056171 */
		&set_bitmask_idle_mode_intra_freq_params,
		/* END CSR : 00056074, CSR : 00056171 */
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.MBSFN),
		"NeighCellConfig",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"S1AP.TRelocPrep",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				s1ap_params.t_reloc_prep),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_s1ap_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.S1AP),
		"TRelocPrep",
		UINT8_TYPE, /*Data Type on Layer is UInt8*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	/* SPR 21207 Fixed Start */
     /* code remove */
    /* SPR 21207 Fixed End */
	/* The following AccessMgmt.LTE parameters are exeception as its direct
	 * mapping depends upon the number of cells actually configured i.e.
	 * single cell, or multi-cell configuration. There are two different
	 * mapping of the parameter, therefore. The default mapping of this
	 * parameter fields are according to single cell configuration. However
	 * for multi-cell configuration these values are reassigned to
	 * appropriate values in oam_populate_func.c file
	 */
	{
		"InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE."
			"AccessMode",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				access_mgmt_params.access_mode),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_access_mgmt_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3),
		"AccessMode",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE."
			"MaxUEsServed",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				admission_control_info.max_num_ue_per_cell),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_access_mgmt_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3),
		"MaxUEsServed",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE.CSGID",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				access_mgmt_params.csg_id),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_access_mgmt_param_csg_id,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3),
		"CSGID",
		FOUR_BYTE_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE."
			"MaxCSGMembers",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				access_mgmt_params.max_csg_members),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_access_mgmt_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3),
		/*SPR 10258 FIX start*/
		"MaxCSGMembers",
		/*SPR 10258 FIX end*/
		SINT16_TYPE,  
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE."
			"MaxNonCSGMembers",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				access_mgmt_params.max_non_csg_members),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_access_mgmt_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3),
		"MaxNonCSGMembers",            
		SINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RF.PBCHPowerOffset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rf_params.rf_configurations.pbch_power_offset),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"PBCHPowerOffset",
		SINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.PRSConfigurationIndex",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.
				prs_configuration_index),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL, 
		&set_bitmask_phy_layer_param_prs,  
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS), /* Spr 11023 Fix */
        /*SPR 21209 Fixed Start */
		"PRSConfigurationIndex",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM )
        /*SPR 21209 Fixed End */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.NumConsecutivePRSSubfames",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.
				num_consecutive_prs_subfames),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_param_prs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS), /* Spr 11023 Fix */ 
		"NumConsecutivePRSSubfames",
        /*SPR 21209 Fixed Start */
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM )
       /*SPR 21209 Fixed End*/
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_PRS_ENABLE",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.prs_enable),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_param_prs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_PRS_ENABLE",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_MUTING_CONFIG_TWO",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_two
		 ),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_param_prs_muting_configuration_two,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_MUTING_CONFIG_TWO",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_MUTING_CONFIG_FOUR",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_four
		 ),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_param_prs_muting_configuration_four,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_MUTING_CONFIG_FOUR",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_MUTING_CONFIG_EIGHT",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_eight
		 ),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_param_prs_muting_configuration_eight,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_MUTING_CONFIG_EIGHT",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_MUTING_CONFIG_SIXTEEN",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_sixteen
		 ),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_param_prs_muting_configuration_sixteen,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_MUTING_CONFIG_SIXTEEN",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_PRS_TRANSMISSION_POWER",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.prs_transmission_power
		 ),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_param_prs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_PRS_TRANSMISSION_POWER",
		/*SPR 9314 change start */
		SINT16_TYPE,
		/*SPR 9314 change end*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_LATITUDE_SIGN",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.latitude_sign),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_LATITUDE_SIGN",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_DEG_OF_LATITUDE",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.deg_of_latitude),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_DEG_OF_LATITUDE",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_DEG_OF_LONGITUDE",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.deg_of_longitude),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_DEG_OF_LONGITUDE",
		/*SPR 9315 change start */
		SINT16_TYPE,
		/*SPR 9315 change end*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_DIR_OF_ALTITUDE",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.dir_of_altitude),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_DIR_OF_ALTITUDE",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_ALTITUDE",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.altitude),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_ALTITUDE",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_UNCERTAINTY_SEMI_MAJOR",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.uncertainty_semi_major),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_UNCERTAINTY_SEMI_MAJOR",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_UNCERTAINTY_SEMI_MINOR",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.uncertainty_semi_minor),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_UNCERTAINTY_SEMI_MINOR",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_ORIENTATION_OF_MAJOR_AXIS",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.orientation_of_major_axis),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_ORIENTATION_OF_MAJOR_AXIS",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_UNCERTAINTY_ALTITUDE",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.uncertainty_altitude),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_UNCERTAINTY_ALTITUDE",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.X_VENDOR_CONFIDENCE",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.rrm_eutran_access_point_pos.confidence),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eutran_access_point_pos,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
		"X_VENDOR_CONFIDENCE",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."

			"RF.PSCHPowerOffset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rf_params.rf_configurations.psch_power_offset),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"PSCHPowerOffset",
		SINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RF.SSCHPowerOffset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rf_params.rf_configurations.ssch_power_offset),
		RRM_OAM_CELL_CONFIG_REQ_MASK, 
		OAM_NULL,
		&set_bitmask_ran_info_rf_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"SSCHPowerOffset",
		SINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"S1AP.TRelocOverall",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				s1ap_params.t_reloc_overall),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_s1ap_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.S1AP),
		"TRelocOverall",
		UINT8_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.NumConsecutivePRSSubframes",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.
				num_consecutive_prs_subfames),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL, 
		&set_bitmask_phy_layer_param_prs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),/* Spr 11023 Fix */ 
		"NumConsecutivePRSSubframes",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRS.NumPRSResourceBlocks",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prs.
				num_prs_resource_blocks),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_param_prs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRS),
        /*SPR 21209 Fixed Start */
		"NumPRSResourceBlocks",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM )
        /*SPR 21209 Fixed Start */
	},
	

	/*SPR 21207 Fixed Start */
      /* code remove */  
    /*SPR 21207 Fixed End */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"EAID",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].epc_info.
				epc_params.general_epc_params.eaid),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eaid,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EPC),
		"EAID",
		THREE_BYTE_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"QoSNumberOfEntries",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].epc_info.
				epc_params.num_valid_qos_profiles),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_epc_info,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EPC),
		"QoSNumberOfEntries",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"MaxPLMNListEntries",
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[OAM_ZERO]),
		OAM_NULL,
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[OAM_ZERO].max_plmn_entries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EPC),
		"MaxPLMNListEntries",
		UINT16_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"AllowedCipheringAlgorithmList",
		&(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0]),
		OAM_NULL,
		&(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].
				supported_security_algorithms.ciphering_algorithms.algorithms[OAM_ZERO]),
		RRC_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EPC),
		"AllowedCipheringAlgorithmList",
		STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"AllowedIntegrityProtectionAlgorithmList",
		&(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0]),
		OAM_NULL,
		&(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].
				supported_security_algorithms.integrity_algorithms.algorithms[OAM_ZERO]),
		RRC_OAM_PROVISION_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EPC),
		"AllowedIntegrityProtectionAlgorithmList",
		/*CSR:00053605_CHANGE_START*/    
		STRING_TYPE,
		/*CSR:00053605_CHANGE_END*/    
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE."
			"HNBName",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				access_mgmt_params.hnb_name),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_access_mgmt_prms,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3),
		"HNBName",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
#ifdef LTE_EMBMS_SUPPORTED
    {
        "InternetGatewayDevice.Services.FAPService.[1].AccessMgmt.LTE."
            "X_VENDOR_ENB_NAME",
        &(local_prov_req.oam_l3_req.oam_m2ap_req.m2ap_oam_prov),
        OAM_NULL,
        (local_prov_req.oam_l3_req.oam_m2ap_req.m2ap_oam_prov.enb_name),
        M2AP_OAM_PROVISION_REQ_MASK,
        OAM_NULL,
        &set_bitmask_enb_name,
/* SPR 22248 MBMS Changes Start */
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_3),
/* SPR 22248 MBMS Changes Stop */
        "X_VENDOR_ENB_NAME",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
#endif
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RF.DLBandwidth",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rf_params.rf_configurations.dl_bandwidth),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"DLBandwidth",
		/*CSR:00053605_CHANGE_START*/    
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IntraFreq.QRxLevMinSIB1",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_1),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_idle_mode_intra_freq_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"QRxLevMinSIB1",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IntraFreq.QRxLevMinSIB3",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.q_rx_lev_min_sib_3),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_idle_mode_intra_freq_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"QRxLevMinSIB3",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IntraFreq.SIntraSearch",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.s_intra_search),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_SIntraSearch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"SIntraSearch",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IntraFreq.SNonIntraSearch",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.s_non_intra_search),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_SNonIntraSearch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"SNonIntraSearch",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
   /* SPR 21207 Fixed Start */
   /*Code Remove */
   /* SPR 21207 Fixed End */
	{
       "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.Common.TEvaluation",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_common_params.speed_state_params.t_evaluation),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_common_param_speed_state_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_2),
		"TEvaluation",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.Common.THystNormal",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_common_params.speed_state_params.t_hyst_normal),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_common_param_speed_state_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_2),
		"THystNormal",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RLC.SRB1.TPollRetransmit",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.
				t_poll_retransmit),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB1),
		"TPollRetransmit",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RLC.SRB2.TPollRetransmit",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.
				t_poll_retransmit),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb_2,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB2),
		"TPollRetransmit",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RLC.SRB1.TReordering",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.t_reordering),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB1),
		"TReordering",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RLC.SRB2.TReordering",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.t_reordering),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb_2,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB2),
		"TReordering",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IntraFreq.TReselectionEUTRA",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.t_reselection_eutra),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_idle_mode_intra_freq_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"TReselectionEUTRA",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IntraFreq.TReselectionEUTRASFHigh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.speed_scale_factors.
				t_reselection_eutra_sf_high),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_intra_f_spd_st_factor,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"TReselectionEUTRASFHigh",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IntraFreq.TReselectionEUTRASFMedium",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.speed_scale_factors.
				t_reselection_eutra_sf_medium),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_intra_f_spd_st_factor,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"TReselectionEUTRASFMedium",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RLC.SRB1.TStatusProhibit",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.
				t_status_prohibit),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB1),
		"TStatusProhibit",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RLC.SRB2.TStatusProhibit",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rlc_layer_params.rlc_layer_param_srb[OAM_ONE].srb_params.
				t_status_prohibit),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb_2,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB1),
		"TStatusProhibit",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"TAC",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].epc_info.
				epc_params.general_epc_params.tac),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_epc_info_general,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EPC),
		"TAC",
		TWO_BYTE_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Common.CellIdentity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.eutran_global_cell_id.cell_identity),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_1),
		"CellIdentity",    
		EUTRAN_CELL_IDENTITY_TYPE,            
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.BarringForEmergency",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.cell_access_restriction_params.
				barring_for_emergency),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_cell_restriction_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.CellRestriction),
		"BarringForEmergency",
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.IntraFreqCellReselectionIndicator",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.cell_access_restriction_params.
				intra_freq_reselection),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_cell_restriction_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.CellRestriction),
		"IntraFreqCellReselectionIndicator",
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.CellBarred",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.cell_access_restriction_params.cell_barred),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_cell_restriction_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.CellRestriction),
		"CellBarred",    
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	/* SPR 13970 FIX Start */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_MO_SIGNALLING.AC_BARRING_FACTOR",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ac_barring_for_mo_signalling.ac_barring_factor),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_mo_signalling,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_MO_SIGNALLING),
		"AC_BARRING_FACTOR",    
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},    


	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_MO_SIGNALLING.AC_BARRING_TIME",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ac_barring_for_mo_signalling.ac_barring_time),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_mo_signalling,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_MO_SIGNALLING),
		"AC_BARRING_TIME",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_MO_SIGNALLING.AC_BARRING_FOR_SPECIAL_AC",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ac_barring_for_mo_signalling.ac_barring_for_special_ac),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_mo_signalling,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_MO_SIGNALLING),
		"AC_BARRING_FOR_SPECIAL_AC",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_MO_DATA.AC_BARRING_FACTOR",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ac_barring_for_mo_data.ac_barring_factor),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_mo_data,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_MO_DATA),
		"AC_BARRING_FACTOR",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},


	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_MO_DATA.AC_BARRING_TIME",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ac_barring_for_mo_data.ac_barring_time),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_mo_data,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_MO_DATA),
		"AC_BARRING_TIME",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_MO_DATA.AC_BARRING_FOR_SPECIAL_AC",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ac_barring_for_mo_data.ac_barring_for_special_ac),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_mo_data,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_MO_DATA),
		"AC_BARRING_FOR_SPECIAL_AC",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},


	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.SSAC_BARRING_FOR_MMTEL_VOICE_R9.AC_BARRING_FACTOR",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_factor),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ssac_barring_for_mmtel_voice_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SSAC_BARRING_FOR_MMTEL_VOICE_R9),
		"AC_BARRING_FACTOR",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.SSAC_BARRING_FOR_MMTEL_VOICE_R9.AC_BARRING_TIME",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_time),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ssac_barring_for_mmtel_voice_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SSAC_BARRING_FOR_MMTEL_VOICE_R9),
		"AC_BARRING_TIME",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.SSAC_BARRING_FOR_MMTEL_VOICE_R9.AC_BARRING_FOR_SPECIAL_AC",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ssac_barring_for_mmtel_voice_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SSAC_BARRING_FOR_MMTEL_VOICE_R9),
		"AC_BARRING_FOR_SPECIAL_AC",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},


	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.SSAC_BARRING_FOR_MMTEL_VIDEO_R9.AC_BARRING_FACTOR",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_factor),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ssac_barring_for_mmtel_video_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SSAC_BARRING_FOR_MMTEL_VIDEO_R9),
		"AC_BARRING_FACTOR",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.SSAC_BARRING_FOR_MMTEL_VIDEO_R9.AC_BARRING_TIME",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_time),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ssac_barring_for_mmtel_video_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SSAC_BARRING_FOR_MMTEL_VIDEO_R9),
		"AC_BARRING_TIME",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.SSAC_BARRING_FOR_MMTEL_VIDEO_R9.AC_BARRING_FOR_SPECIAL_AC",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.radio_res_config_common_sib.access_barring_info.
				ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ssac_barring_for_mmtel_video_r9,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SSAC_BARRING_FOR_MMTEL_VIDEO_R9),
		"AC_BARRING_FOR_SPECIAL_AC",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_CSFB_R10.AC_BARRING_FACTOR",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.ac_barring_for_csfb_r10.ac_barring_factor),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_csfb_r10,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_CSFB_R10),
		"AC_BARRING_FACTOR",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_CSFB_R10.AC_BARRING_TIME",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
       /* SPR 15289 FIX START */
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.ac_barring_for_csfb_r10.ac_barring_time),
       /* SPR 15289 FIX END */
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_csfb_r10,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_CSFB_R10),
		"AC_BARRING_TIME",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"CellRestriction.X_VENDOR_ACCESS_BARRING_INFO.AC_BARRING_FOR_CSFB_R10.AC_BARRING_FOR_SPECIAL_AC",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
    /* SPR 15289 FIX START */
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
				sib_2_info.ac_barring_for_csfb_r10.ac_barring_for_special_ac),
    /* SPR 15289 FIX END */
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ac_barring_for_csfb_r10,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AC_BARRING_FOR_CSFB_R10),
		"AC_BARRING_FOR_SPECIAL_AC",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	/* SPR 13970 FIX End */

#ifdef OAM_SON_ENABLE
	/* SPR 13065 CHANGE START */    
	/* SPR 13065 CHANGE END */    
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1]."
			"BCCH.DLBandwidth",
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.
				meas_bw_list[OAM_ZERO]),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"DLBandwidth",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1]."
			"RF.PhyCellID",
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list[OAM_ZERO]),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"PhyCellID",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
#endif
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IntraFreq.QRxLevMinOffset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_intra_freq_params.q_rx_lev_min_offset),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_q_rx_lev_min_offset,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"QRxLevMinOffset",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	/* SPR 13850 FIX START */
	/* CODE REMOVED */
	/* SPR 13850 FIX END */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RF.FreqBandIndicator",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rf_params.rf_configurations.frequency_band_indicator),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"FreqBandIndicator",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.NumberOfRaPreambles",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.preamble_info.
				number_of_ra_preambles),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_rach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"NumberOfRaPreambles",        
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.SizeOfRaGroupA",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.preamble_info.
				ra_preamble_groupA_info.size_of_ra_group_a),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_preamble_info),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"SizeOfRaGroupA",        
		/*CSR:00053605_CHANGE_START*/        
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.MessageSizeGroupA",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.preamble_info.
				ra_preamble_groupA_info.message_size_group_a),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_preamble_info,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"MessageSizeGroupA",        
		/*CSR:00053605_CHANGE_START*/      
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.MessagePowerOffsetGroupB",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.preamble_info.
				ra_preamble_groupA_info.message_power_offset_group_b),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_preamble_info,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"MessagePowerOffsetGroupB",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.PowerRampingStep",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.power_ramping_step),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_rach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"PowerRampingStep",        
		/*CSR:00053605_CHANGE_START*/        
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.PreambleInitialReceivedTargetPower",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.
				preamble_initial_received_target_power),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_rach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"PreambleInitialReceivedTargetPower",        
		/*CSR:00053605_CHANGE_START*/        
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.PreambleTransMax",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.preamble_trans_max),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_rach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"PreambleTransMax",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.ResponseWindowSize",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.response_window_size),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_rach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"ResponseWindowSize",        
		/*CSR:00053605_CHANGE_START*/        
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.ContentionResolutionTimer",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.contention_resolution_timer),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_rach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"ContentionResolutionTimer",        
		/*CSR:00053605_CHANGE_START*/   
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/   
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.MaxHARQMsg3Tx",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.max_harq_msg_3tx),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_rach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"MaxHARQMsg3Tx",        
        /*SPR 21208 Fixed Start */
		UINT8_TYPE,
        /*SPR 21208 Fixed End */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    /* SPR 20653 Fix Start */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"MAC.RACH.ContentionFreeRachTimer",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				mac_layer_params.mac_layer_param_rach.contention_free_rach_timer),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_rach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RACH),
		"ContentionFreeRachTimer",        
		/*CSR:00053605_CHANGE_START*/  
        UINT8_TYPE, 
		/*CSR:00053605_CHANGE_END*/   
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    /* SPR 20653 Fix End */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRACH.RootSequenceIndex",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prach.
				root_sequence_index),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_prach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRACH),
		"RootSequenceIndex",        
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRACH.ConfigurationIndex",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prach.
				configuration_index),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_prach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRACH),
		"ConfigurationIndex",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRACH.HighSpeedFlag",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prach.high_speed_flag),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_prach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRACH),
		"HighSpeedFlag",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRACH.ZeroCorrelationZoneConfig",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prach.
				zero_correlation_zone_config),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_prach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRACH),
		"ZeroCorrelationZoneConfig",        
		UINT8_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PRACH.FreqOffset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_prach.frequency_offset),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_prach,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PRACH),
		"FreqOffset",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	/* SPR-13074 */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"RF.ReferenceSignalPower",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rf_params.rf_configurations.reference_signal_power),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"ReferenceSignalPower",        
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PDSCH.Pb",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_pdsch.p_b),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pdsch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PDSCH),
		"Pb",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PUSCH.NSB",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.physical_layer_param_pusch.n_sb),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pusch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUSCH),
		"NSB",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.HoppingMode",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pusch.pusch_hopping_mode),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pusch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUSCH),
		"HoppingMode",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.HoppingOffset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pusch.hopping_offset),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pusch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUSCH),
		"HoppingOffset",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    /* SPR 20653 Fix Start */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.X_VENDOR_BETA_OFFSET_ACK_INDEX",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pusch.beta_offset_ack_index),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pusch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUSCH),
		"BetaOffsetAckIndex",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.X_VENDOR_BETA_OFFSET_RI_INDEX",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pusch.beta_offset_ri_index),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pusch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUSCH),
		"BetaOffsetRIIndex",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.X_VENDOR_BETA_OFFSET_CQI_INDEX",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pusch.beta_offset_cqi_index),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pusch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUSCH),
		"BetaOffsetCQIIndex",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.X_VENDOR_PUSCH_BLER_THRESHOLD",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pusch.pusch_bler_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pusch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUSCH),
		"PUSCHBlerThreshold",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    /* SPR 20653 Fix End */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"PHY.PUSCH.Enable64QAM",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				physical_layer_params.addl_physical_layer_params. 
				additional_pusch_parameters.pusch_enable_64_qam),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_addl_physical_layer_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUSCH),
		"Enable64QAM",        
		UINT8_TYPE,
        /* SPR 15381 START */ 
        (OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* SPR 15381 START */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.ULRS.GroupHoppingEnabled",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.group_hopping_enabled),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_ul_reference_signal_power,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULRS),
		"GroupHoppingEnabled",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.ULRS.SequenceHoppingEnabled",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.sequence_hopping_enabled),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_ul_reference_signal_power,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULRS),
		"SequenceHoppingEnabled",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUCCH.DeltaPUCCHShift",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pucch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUCCH),
		"DeltaPUCCHShift",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUCCH.NCSAN",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.addl_physical_layer_params.addl_pucch_parameters.n1_cs),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_n1cs_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUCCH),
		"NCSAN",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUCCH.NRBCQI",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pucch.n_rb_cqi),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pucch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUCCH),
		"NRBCQI",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUCCH.N1PUCCHAN",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pucch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUCCH),
		"N1PUCCHAN",        
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.SRSBandwidthConfig",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.srs_bandwidth_config),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_srs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRS),
		"SRSBandwidthConfig",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,   
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.AckNackSRSSimultaneousTransmission",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.ack_nack_srs_simultaneous_transmission),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_srs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRS),
		"AckNackSRSSimultaneousTransmission",
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.SRSSubframeConfig",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.srs_subframe_config),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_srs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRS),
		"SRSSubframeConfig",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    /* SPR 20653 Fix Start */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.X_VENDOR_SRS_HOPPING_ENABLED",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.srs_hopping_enable),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_srs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRS),
		"SRSHoppingEnabled",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.X_VENDOR_SRS_DURATION",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.srs_duration),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_srs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRS),
		"SRSDuration",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.X_VENDOR_SRS_PERIODICITY",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.srs_periodicity),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_srs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRS),
		"SRSPeriodicity",        
		OAM_ENUM_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    /* SPR 20653 Fix End */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.SRSMaxUpPTS",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.srs_max_up_pts),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_srs_max_up_pts,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRS),
		"SRSMaxUpPTS",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.P0NominalPUSCH",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_ul_power_control.p_0_nominal_pusch),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_ul_power_control,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"P0NominalPUSCH",        
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.Alpha",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_ul_power_control.alpha),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_ul_power_control,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"Alpha",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.P0NominalPUCCH",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_ul_power_control.p_0_nominal_pucch),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_ul_power_control,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ULPowerControl),
		"P0NominalPUCCH",        
		SINT8_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.TDDFrame.SubFrameAssignment",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure.sub_frame_assignment),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
        /* OAM BCOM Code Comment Changes Start */
		&set_bitmask_ran_phy_tdd_frame,
        /* OAM BCOM Code Comment Changes End */
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.TDDFrame),
		"SubFrameAssignment",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM) 
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.TDDFrame.SpecialSubframePatterns",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure.special_sub_frame_patterns),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
        /* OAM BCOM Code Comment Changes Start */
		&set_bitmask_ran_phy_tdd_frame,
        /* OAM BCOM Code Comment Changes End */
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.TDDFrame),
		"SpecialSubframePatterns",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T300",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_timers.t300),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_timers,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"T300",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T301",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_timers.t301),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_timers,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"T301",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T310",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_timers.t310),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_timers,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"T310",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.N310",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_constants.n310),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_constants,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"N310",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T311",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_timers.t311),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_timers,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"T311",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.N311",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_constants.n311),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_constants,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"N311",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T302",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_timers.t302),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_timers,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"T302",
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T304EUTRA",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_timers.t304_eutra),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_timers,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"T304EUTRA",
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T304IRAT",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_timers.t304_irat),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_timers,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"T304IRAT",
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T320",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rrc_timers_and_constants.rrc_timers.t320),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rrc_timers_and_constants_timers,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RRCTimers),
		"T320",
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RF.ULBandwidth",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rf_params.rf_configurations.ul_bandwidth),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params_ul_bw,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"ULBandwidth",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}, 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PDSCH.Pa",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pdsch.p_a),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pdsch,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PDSCH),
		"Pa",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.SRSEnabled",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.srsEnabled),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_srs,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRS),
		"SRSEnabled",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    /* SPR 22311 Changes - Starts */
    /* Code Deleted */
    /* SPR 22311 Changes - Ends */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUCCH.TDDAckNackFeedbackMode",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pucch.tdd_ack_nack_feedback_mode),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pucch_tdd_ack_nack,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUCCH),
		"TDDAckNackFeedbackMode",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUCCH.PUCCHCqiSinrValue",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_pucch.pucch_cqi_sinr_value),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_physical_layer_params_pucch_cqi_sinr_value,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PUCCH),
		"PUCCHCqiSinrValue",        
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.DRXEnabled",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mac_layer_params.mac_layer_param_drx.drx_enabled),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_layer_params_drx,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.DRX),
		"DRXEnabled",        
		UINT8_TYPE,
        /*SPR 21156 FIXED START*/
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | OAM_READ_ONLY)
        /*SPR 21156 FIXED END*/
            
	},
 /* SPR 21207 Fixed Start */
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "MAC.DRX.OnDurationTimer",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
                mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].
                on_duration_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.DRX),
        "OnDurationTimer",
        /*CSR:00053605_CHANGE_START*/
        OAM_ENUM_TYPE,
        /*CSR:00053605_CHANGE_END*/
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "MAC.DRX.DRXInactivityTimer",             
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
                mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].
                drx_inactivity_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.DRX),
        "DRXInactivityTimer",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "MAC.DRX.DRXRetransmissionTimer",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
                mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].
                drx_retransmission_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.DRX),
        "DRXRetransmissionTimer",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.LongDRXCycle",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].long_drx_cycle),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.DRX),
        "LongDRXCycle",
        /*CSR:00053605_CHANGE_START*/ 
        OAM_ENUM_TYPE,	
        /*CSR:00053605_CHANGE_END*/
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.DRXStartOffset",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].drx_start_offset),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_mac_layer_params_drx,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.DRX),
        "DRXStartOffset",
        UINT16_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
    },


    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN." 
            "MAC.DRX.ShortDRXCycle",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
                mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].short_drx_cycle.
                short_drx_cycle),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_ShortDRXCycle,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.DRX),
        "ShortDRXCycle",
        /*CSR:00053605_CHANGE_START*/
        OAM_ENUM_TYPE,
        /*CSR:00053605_CHANGE_END*/
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
    },

    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.DRXShortCycleTimer",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].short_drx_cycle.drx_short_cycle_timer),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_drx_short_cy_timer,
        &(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.DRX),
        "DRXShortCycleTimer",
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
    },

    /* SPR 21207 Fixed End */

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.Qhyst",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.q_hyst),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_idle_mode_common_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_2),
		"Qhyst",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.QHystSFMedium",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.speed_state_params.q_hyst_sf_medium),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_common_param_speed_state_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_2),
		"QHystSFMedium",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.QHystSFHigh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.speed_state_params.q_hyst_sf_high),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_common_param_speed_state_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_2),
		"QHystSFHigh",        
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	/* START SPR_6719_FIX */
	/* END SPR_6719_FIX */

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.CellReselectionPriority",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.cell_reselection_priority),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_idle_mode_intra_freq_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"CellReselectionPriority",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
     /* SPR 21207 Fixed Start */
    /* Code Remove */
     /* SPR 21207 Fixed End */
    #ifdef OAM_SON_ENABLE

	/* CA_CHANGE_FOR_GET_SET_START */ 
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.InterFreq.MaxCarrierEntries",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_inter_freq_carrier_params[OAM_ZERO].MaxCarrierEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.InterFreq),
		"MaxCarrierEntries",
		UINT8_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.InterFreq.CarrierNumberOfEntries",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				eutran_config_list_size),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.InterFreq),
		"CarrierNumberOfEntries",
		UINT8_TYPE,
		OAM_READ_ONLY
	},
#endif
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.DefaultConfiguration",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].default_configuration),
		RRM_OAM_CELL_CONFIG_REQ_MASK, 
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb, /*POLL PDU BUG FIX  */
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB1),
		"DefaultConfiguration",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.DefaultConfiguration",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.rlc_layer_param_srb[1].default_configuration),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb_2,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB2),
		"DefaultConfiguration",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},


     /* SPR 21207 Fixed Start */
        /* Code Remove */
     /* SPR 21207 Fixed End */

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.MaxRetxThreshold",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.max_retx_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB1),
		"MaxRetxThreshold",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.MaxRetxThreshold",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.rlc_layer_param_srb[1].srb_params.max_retx_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb_2,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB2),
		"MaxRetxThreshold",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.NCellChangeHigh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.speed_state_params.n_cell_change_high),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_common_param_speed_state_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_2),
		"NCellChangeHigh",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.NCellChangeMedium",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.speed_state_params.n_cell_change_medium),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_common_param_speed_state_params),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.Common_2),
		"NCellChangeMedium",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.PollByte",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.poll_byte),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB1),
		"PollByte", 
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)

	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.PollByte",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.rlc_layer_param_srb[1].srb_params.poll_byte),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb_2,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB2),
		"PollByte",
		/*CSR:00053605_CHANGE_START*/ 
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)

	},

	{ 
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.PollPDU",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].srb_params.poll_pdu),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB1),
		"PollPDU",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,  
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.PollPDU",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.rlc_layer_param_srb[1].srb_params.poll_pdu),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_rlc_layer_param_srb_2,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.SRB2),
		"PollPDU",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,  
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	/* START SPR_6719_FIX */
	/* RT SPR 8154 FIX START */
	/*  LINES DELETED */
	/* RT SPR 8154 FIX END */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.ThreshServingLow",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.thresh_serving_low),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_idle_mode_intra_freq_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"ThreshServingLow",
		UINT8_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
#ifdef OAM_SON_ENABLE
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.PMax",
		&(local_prov_req.oam_params),
		OAM_NULL,
		&(local_prov_req.oam_params.ue_trans_power_list),
		OAM_P_MAX_LIST_MASK,
		OAM_NULL,
		&set_bitmask_PMax,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"PMax",
		ASCII_STRING_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
#else
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.PMax",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.mobility_params.
				idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.p_max_sib_1),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_PMax,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq),
		"PMax",
		UINT8_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
#endif
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.SupportedSystems",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.supported_system),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Capabilities),
		"SupportedSystems",
		/* SPR-10640 FIX Start */
		UINT32_TYPE,
		/* SPR-10640 FIX End */ 
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.GPSEquipped",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.GPSEquipped),
		OAM_TR069_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Capabilities),
		"GPSEquipped",
		UINT8_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.MaxTxPower",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.MaxTxPower),
		OAM_TR069_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Capabilities),
		"MaxTxPower",
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.Beacon",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.Beacon),
		OAM_TR069_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Capabilities),
		"Beacon",
		UINT8_TYPE,
		(OAM_READ_ONLY)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"PLMNListNumberOfEntries",
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[OAM_ZERO]),
		OAM_NULL,
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[OAM_ZERO].curr_plmn_entries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE.BandsSupported",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.bands_supported),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"BandsSupported",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE.UMTSRxSupported",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.UMTSRx_supported),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"UMTSRxSupported",
		UINT8_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE.GSMRxSupported",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.GSMRx_supported),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"GSMRxSupported",

		UINT8_TYPE,
		(OAM_READ_ONLY)
	},  
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE.CDMA2000RxSupported",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.CDMA2000Rx_supported),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"CDMA2000RxSupported",
		UINT8_TYPE,   
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE.DuplexMode",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.DuplexMode),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"DuplexMode",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.Capabilities.LTE.NNSFSupported",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.NNSFSupported),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_1),
		"NNSFSupported",
		UINT8_TYPE,
		(OAM_READ_ONLY)
	},

	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.SecGWServer1",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server1),
		OAM_TR069_PARAMS_MASK,
		OAM_NULL,
        /* + SPR 17439 */
		OAM_NULL,
        /* - SPR 17439 */
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway),
		"SecGWServer1",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.SecGWServer2",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server2),
		OAM_TR069_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway),
		"SecGWServer2",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.SecGWServer3",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.serving_sec_gw_server3),
		OAM_TR069_PARAMS_MASK,
		OAM_NULL,
        /* + SPR 17439 */
		OAM_NULL,
        /* - SPR 17439 */
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway),
		"SecGWServer3",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.S1SigLinkPort",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		/* SPR 11090 Change Start*/ 
		&(local_prov_req.oam_igd_params.fap_control_params.S1SigLinkPort),
		/* SPR 11090 Change End */
		/* SPR 11090 Final Change Start */
		OAM_S1AP_ADD_MME_REQ_MASK,
		/* SPR 11090 Final Change End */
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway),
		"S1SigLinkPort",
		UINT16_TYPE_2,
		/* SPR 11090 Change Start*/ 
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
			/* SPR 11090 Change End */
	},
#ifdef OAM_SON_ENABLE
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
			"RAN.RF.PhyCellID",
		/* SPR 13024 FIX START */
		&(LOCAL_SON_PROV_REQ.earfcn_pci_selection[0]),
		OAM_NULL,
		&(LOCAL_SON_PROV_REQ.earfcn_pci_selection[0].
				oam_son_pci_reselection_req.pci_list),
		OAM_PHY_CELL_ID_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"PhyCellID",
        /*SPR 21157 FIXED START */
		OAM_UINT16_TOKENIZED_LIST_TYPE,
        /*SPR 21157 FIXED END */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
			/* SPR 13024 FIX END */
	},
#endif
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RF.EARFCNDL",
        /* SPR fix 22928 start */
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rf_params.rf_configurations.dl_earfcn),
		OAM_EARFCN_DL_LIST_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params, 
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"EARFCNDL",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* SPR fix 22928 stop */
	},
	/* CSR 58157 START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RF.EARFCNUL",
        /* SPR fix 22928 start */
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
				rf_params.rf_configurations.ul_earfcn),
		OAM_EARFCN_UL_LIST_MASK,
		OAM_NULL,
		&set_bitmask_ran_info_rf_params, 
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"EARFCNUL",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
        /* SPR fix 22928 stop */
	},
	/* CSR 58157 END */
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE.AdminState",
		&(local_prov_req.system_status),
		OAM_NULL,
		&(local_prov_req.system_status.admin_state),
		OAM_ADMIN_STATE_CHANGED_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_2),
		"AdminState",
		UINT32_TYPE,   
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE.OpState",
		&(local_prov_req.system_status),
		OAM_NULL,
		&(local_prov_req.system_status.op_state),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,   
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE.RFTxStatus",
		&(local_prov_req.system_status),
		OAM_NULL,
		&(local_prov_req.system_status.rftx_status),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,   
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.Services.FAPService.FAPControl.LTE.AvailabilityStatus",
		&(local_prov_req.system_status),
		OAM_NULL,
		&(local_prov_req.system_status.availability_status),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_READ_ONLY)
	},
	{
		"InternetGatewayDevice.ManagementServer.URL",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.serving_hems_address),
        /* SPR 17880 START */
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        /* SPR 17880 END */
        /* + SPR 17439 */
		OAM_NULL,
        /* - SPR 17439 */
        /* SPR 17880 START */
        &oam_update_serving_hems_address_present,
        /* SPR 17880 END */
		&(xml_struct_tr196_g.ManagementServer),
		"URL",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	}, 
	{
		"InternetGatewayDevice.ManagementServer.X_VENDOR_IHEMS_URL",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
		&(local_prov_req.oam_tr069_req.tr069_init_params.initial_hems_address),
        /* SPR 17880 START */
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        /* SPR 17880 END */
        /* + SPR 17439 */
		OAM_NULL,
        /* - SPR 17439 */
        /* SPR 17880 START */
        &oam_update_initial_hems_address_present,
        /* SPR 17880 END */
		&(xml_struct_tr196_g.ManagementServer),
		"X_VENDOR_IHEMS_URL",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
    /* SPR 17880 START */ 
    {
        "InternetGatewayDevice.ManagementServer.EnableCWMP",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.EnableCWMP),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_EnableCWMP,
        &(xml_struct_tr196_g.ManagementServer),
        "EnableCWMP",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.PeriodicInformEnable",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformEnable),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_PeriodicInformEnable,
        &(xml_struct_tr196_g.ManagementServer),
        "PeriodicInformEnable",
        OAM_ENUM_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.PeriodicInformInterval",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformInterval),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_PeriodicInformInterval,
        &(xml_struct_tr196_g.ManagementServer),
        "PeriodicInformInterval",
        /* SPR 17880 18JAN FIX START */
        UINT32_TYPE,
        /* SPR 17880 18JAN FIX END */
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.PeriodicInformTime",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_PeriodicInformTime,
        &(xml_struct_tr196_g.ManagementServer),
        "PeriodicInformTime",
        TIMESTAMP_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.ParameterKey",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.ParameterKey),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.ManagementServer),
        "ParameterKey",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.ConnectionRequestUsername",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_ConnectionRequestUsername,
        &(xml_struct_tr196_g.ManagementServer),
        "ConnectionRequestUsername",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.ConnectionRequestPassword",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_ConnectionRequestPassword,
        &(xml_struct_tr196_g.ManagementServer),
        "ConnectionRequestPassword",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.Username",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.Username),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_Username,
        &(xml_struct_tr196_g.ManagementServer),
        "Username",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.Password",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.Password),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_Password,
        &(xml_struct_tr196_g.ManagementServer),
        "Password",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.ConnectionRequestURL",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.ConReqURL),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        /* SPR 17880 18JAN FIX START */
        &oam_update_ConReqURL,
        /* SPR 17880 18JAN FIX END */
        &(xml_struct_tr196_g.ManagementServer),
        "ConnectionRequestURL",
        ASCII_STRING_TYPE,
        OAM_READ_ONLY
    },
    {
        "InternetGatewayDevice.ManagementServer.CWMPRetryMinimumWaitInterval",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryMinimumWaitInterval),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_CWMPRetryMinimumWaitInterval,
        &(xml_struct_tr196_g.ManagementServer),
        "CWMPRetryMinimumWaitInterval",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "InternetGatewayDevice.ManagementServer.CWMPRetryIntervalMultiplier",
		&(local_prov_req.oam_tr069_req),
		OAM_NULL,
        &(local_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryIntervalMultiplier),
        OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK,
        OAM_NULL,
        &oam_update_CWMPRetryIntervalMultiplier,
        &(xml_struct_tr196_g.ManagementServer),
        "CWMPRetryIntervalMultiplier",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    /* SPR 17880 END */

	/*This block contains all the set of new RRM 1.2 41 PARAMETERS  which need to be made compatible corresponding to lte_rrm latest relaese*/
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.FilterCoefficientRSRP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.filter_coefficient_rsrp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"FilterCoefficientRSRP",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.FilterCoefficientRSRQ",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.filter_coefficient_rsrq),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"FilterCoefficientRSRQ",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A1ThresholdRSRP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a1_threshold_rsrp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A1ThresholdRSRP",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A1ThresholdRSRQ",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a1_threshold_rsrq),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A1ThresholdRSRQ",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A2ThresholdRSRP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a2_threshold_rsrp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A2ThresholdRSRP",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A2ThresholdRSRQ",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a2_threshold_rsrq),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A2ThresholdRSRQ",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A3Offset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a3_offset),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A3Offset",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportOnLeave",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.report_on_leave),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"ReportOnLeave",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A4ThresholdRSRP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a4_threshold_rsrp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A4ThresholdRSRP",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A4ThresholdRSRQ",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a4_threshold_rsrq),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A4ThresholdRSRQ",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A5Threshold1RSRP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a5_threshold_1rsrp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A5Threshold1RSRP",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A5Threshold1RSRQ",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a5_threshold_1rsrq),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A5Threshold1RSRQ",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A5Threshold2RSRP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a5_threshold_2rsrp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A5Threshold2RSRP",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.A5Threshold2RSRQ",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.a5_threshold_2rsrq),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"A5Threshold2RSRQ",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.Hysteresis",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.hysteresis),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"Hysteresis",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.TimeToTrigger",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.time_to_trigger),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"TimeToTrigger",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.TriggerQuantity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.trigger_quantity),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"TriggerQuantity",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportQuantity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.report_quantity),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"ReportQuantity",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportInterval",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.report_interval),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"ReportInterval",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportAmount",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.report_amount),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra), 
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"ReportAmount",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.PsHoEnabled",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.common_params_for_eutra.ps_ho_enabled),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_mob_common_params_for_eutra), 
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.EUTRA),
		"PsHoEnabled",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.QoffsettUTRA",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.qoffset_tutra),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"QoffsettUTRA",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.FilterCoefficientUTRA",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.filter_coefficient_utra),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"FilterCoefficientUTRA",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.QoffsetCDMA2000",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.q_offset_cdma2000),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_irat_q_offset_cdma2000),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"QoffsetCDMA2000",
		SINT8_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"LoadReporting.OverLoadLevel.Percentage",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				over_load_lvl_act.load_perctg),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		/* SPR 11001 FIX START */
		OAM_NULL,
		&(set_bitmask_load_config_overload_lvl_prcnt),
		&(xml_struct_g.CellConfig[0].load_level_info[OAM_ZERO]),
		/* SPR 11001 FIX END */
		"load_percentage",
		OAM_ONE,
		/* SPR 11001 FIX START */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11001 FIX END */
	},
	{
		"LoadReporting.OverLoadLevel.Action",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				over_load_lvl_act.action),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		/* SPR 11001 FIX START */
		OAM_NULL,
		&(set_bitmask_load_config_overload_action),
		&(xml_struct_g.CellConfig[0].load_level_info[OAM_ZERO]),
		/* SPR 11001 FIX END */
		"action",
		UINT32_TYPE,
		/* SPR 11001 FIX START */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11001 FIX END */
	},
	/*bug_13969_start */
	{
		"LoadReporting.OverLoadLevel.eligible_ue",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				over_load_lvl_act.eicic_load_config.eligible_ue),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_load_config_overload_eligible_ue),
		&(xml_struct_g.CellConfig[0].eicic_load_config[OAM_ZERO]),
		"eligible_ue",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"LoadReporting.OverLoadLevel.abs_pattern",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				over_load_lvl_act.eicic_load_config.abs_pattern),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_load_config_overload_abs_pattern),
		&(xml_struct_g.CellConfig[0].eicic_load_config[OAM_ZERO]),
		"abs_pattern",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	/*bug_13969_end */

	{
		"LoadReporting.HighLoadLevel.Percentage",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				high_load_lvl_act.load_perctg),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		/* SPR 11001 FIX START */
		OAM_NULL,
		&(set_bitmask_load_config_highload_lvl_prcnt),
		&(xml_struct_g.CellConfig[0].load_level_info[OAM_ONE]),
		/* SPR 11001 FIX END */
		"load_percentage",
		UINT8_TYPE,
		/* SPR 11001 FIX START */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11001 FIX END */
	},
	/*bug_13969_start */
	{
		"LoadReporting.HighLoadLevel.eligible_ue",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				high_load_lvl_act.eicic_load_config.eligible_ue),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_load_config_highload_eligible_ue),
		&(xml_struct_g.CellConfig[0].eicic_load_config[OAM_ZERO]),
		"eligible_ue",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"LoadReporting.HighLoadLevel.abs_pattern",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				high_load_lvl_act.eicic_load_config.abs_pattern),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_load_config_highload_abs_pattern),
		&(xml_struct_g.CellConfig[0].eicic_load_config[OAM_ZERO]),
		"abs_pattern",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},

	/*bug_13969_end */
	{
		"LoadReporting.HighLoadLevel.Action",
		&(local_prov_req.oam_rrm_req.oam_load_config_req),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				high_load_lvl_act.action),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		/* SPR 11001 FIX START */
		OAM_NULL,
		&(set_bitmask_load_config_highload_action),
		&(xml_struct_g.CellConfig[0].load_level_info[OAM_ONE]),
		/* SPR 11001 FIX END */
		"action",
		UINT32_TYPE,
		/* SPR 11001 FIX START */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11001 FIX END */
	},
	{
		"LoadReporting.MidLoadLevel.Percentage",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				mid_load_lvl_act.load_perctg),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		/* SPR 11001 FIX START */
		OAM_NULL,
		&(set_bitmask_load_config_midload_lvl_prcnt),
		&(xml_struct_g.CellConfig[0].load_level_info[OAM_TWO]),
		/* SPR 11001 FIX END */
		"load_percentage",
		UINT8_TYPE,
		/* SPR 11001 FIX START */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11001 FIX END */
	},
	{
		"LoadReporting.MidLoadLevel.Action",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				mid_load_lvl_act.action),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		/* SPR 11001 FIX START */
		OAM_NULL,
		/* SPR 11001 FIX END */
		&(set_bitmask_load_config_midload_action),
		&(xml_struct_g.CellConfig[0].load_level_info[OAM_TWO]),
		"action",
		UINT32_TYPE,
		/* SPR 11001 FIX START */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11001 FIX END */
	},
	/*bug_13969_start */
	{
		"LoadReporting.MidLoadLevel.eligible_ue",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				mid_load_lvl_act.eicic_load_config.eligible_ue),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_load_config_midload_eligible_ue),
		&(xml_struct_g.CellConfig[0].eicic_load_config[OAM_ZERO]),
		"eligible_ue",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"LoadReporting.MidLoadLevel.abs_pattern",
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[0].
				mid_load_lvl_act.eicic_load_config.abs_pattern),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_load_config_midload_abs_pattern),
		&(xml_struct_g.CellConfig[0].eicic_load_config[OAM_ZERO]),
		"abs_pattern",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},

	/*bug_13969_end */
	{
		"LoadReporting.serving_cell.ReportingInterval",
		&(local_prov_req.oam_rrm_req.oam_load_config_req),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.load_rpt_intrvl),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		/* SPR 11001 FIX START */
		OAM_NULL,
		/* SPR 11001 FIX END */
		&(set_bitmask_load_config_serving_cell), 
		&(xml_struct_g.load_configuration),
		"load_rpt_intrvl",
		UINT16_TYPE,
		/* SPR 11001 FIX START */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11001 FIX END */
	},
	{
		"LoadReporting.neighbor_cell.ReportingInterval",
		&(local_prov_req.oam_rrm_req.oam_load_config_req),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_load_config_req.ncl_load_ind_intrvl),
		RRM_OAM_LOAD_CONFIG_REQ_MASK,
		/* SPR 11001 FIX START */
		OAM_NULL,
		/* SPR 11001 FIX END */
		&(set_bitmask_load_config_neighbor_cell),
		&(xml_struct_g.load_configuration),
		"ncl_load_ind_intrvl",
		UINT8_TYPE,
		/* SPR 11001 FIX START */
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11001 FIX END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.MeasQuantityCDMA2000",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.meas_quantity_cdma2000),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_irat_meas_quan_cdma2000),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"MeasQuantityCDMA2000",
		UINT8_TYPE, 
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B1ThresholdCDMA2000",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b1_threshold_cdma2000),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_irat_b1_thresh_cdma2000),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B1ThresholdCDMA2000",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.MeasQuantityUTRAFDD",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.meas_quantity_utra_fdd),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_irat_meas_quant_utra_fdd),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"MeasQuantityUTRAFDD",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.MeasQuantityUTRATDD",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.meas_quantity_utra_tdd),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_irat_meas_quant_utra_tdd),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"MeasQuantityUTRATDD",
		STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B1ThresholdUTRARSCP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b1_threshold_utra_rscp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_irat_b1_th_utra_rscp),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B1ThresholdUTRARSCP",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B1ThresholdUTRAEcN0",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b1_threshold_utra_ecn0),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_b1_th_utra_ecn0),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B1ThresholdUTRAEcN0",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.QoffsetGERAN",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.q_offset_geran),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"QoffsetGERAN",
		SINT8_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.FilterCoefficientGERAN",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.filter_coefficient_geran),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"FilterCoefficientGERAN",
		/*CSR:00053605_CHANGE_START*/

		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B1ThresholdGERAN",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b1_threshold_geran),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_b1_th_geran),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B1ThresholdGERAN",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B2Threshold2UTRARSCP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b2_threshold_2utra_rscp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_b2_th_2u_rscp),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B2Threshold2UTRARSCP",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B2Threshold2UTRAEcN0",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b2_threshold_2utra_ecn0),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_b2_th_2u_ecn0),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B2Threshold2UTRAEcN0",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B2Threshold2GERAN",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b2_threshold_2geran),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_b2_th_2geran),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B2Threshold2GERAN",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B2Threshold2CDMA2000",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b2_threshold_2cdma),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_b2_th_2geran),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B2Threshold2CDMA2000",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.Hysteresis",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.hysteresis),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"Hysteresis",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.TimeToTrigger",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.time_to_trigger),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"TimeToTrigger",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.MaxReportCells",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.max_report_cells),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"MaxReportCells",
		UINT8_TYPE,
		(OAM_READ_ONLY |  OAM_IGNORE_VALIDATION | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.ReportInterval",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.report_interval),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"ReportInterval",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.ReportAmount",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.report_amount),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_connected_mode_irat),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"ReportAmount",
		/*CSR:00053605_CHANGE_START*/
		OAM_ENUM_TYPE,
		/*CSR:00053605_CHANGE_END*/
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},

	/* SPR 13020 START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B2Threshold1RSRP",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b2_threshold_1rsrp),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_b2_threshold_1rsrp),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B2Threshold1RSRP",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.B2Threshold1RSRQ",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.connected_mode_mobility_params.irat.b2_threshold_1rsrq),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_b2_threshold_1rsrq),
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IRAT_2),
		"B2Threshold1RSRQ",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	/* SPR 13020 END */

    /* SPR 17880 START*/
    /* Code removed */
    /* SPR 17880 END */

	/* SPR_12373_CHANGES */
	/* Redundant Code Removed */
	/* SPR_12373_CHANGES */
	{
		"InternetGatewayDevice.FAP.Tunnel.IKESANumberOfEntries",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.tunnel_params.IKESANumberOfEntries),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Tunnel),
		"IKESANumberOfEntries",
		UINT32_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.FAP.Tunnel.MaxVirtualInterfaces",
		&(local_prov_req.oam_igd_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.tunnel_params.MaxVirtualInterfaces),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.Tunnel),
		"MaxVirtualInterfaces",
		UINT32_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarmNumberOfEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.CurrentAlarmNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEventNumberOfEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.ExpeditedEventNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEventNumberOfEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.HistoryEventNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEventNumberOfEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.QueuedEventNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	/* SPR-8133,34,35 FIX START */
	{
		"InternetGatewayDevice.FaultMgmt.X_VENDOR_CurrentHistoryEventNumberOfEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.Current_HistoryEventNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.FaultMgmt.X_VENDOR_CurrentExpeditedEventNumberOfEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.Current_ExpeditedEventNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.FaultMgmt.X_VENDOR_CurrentQueuedEventNumberOfEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.Current_QueuedEventNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	/* SPR-8133,34,35 */
	{
		"InternetGatewayDevice.FaultMgmt.MaxCurrentAlarmEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.MaxCurrentAlarmEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},
	{
		"InternetGatewayDevice.FaultMgmt.SupportedAlarmNumberOfEntries",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.SupportedAlarmNumberOfEntries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		OAM_READ_ONLY
	},

    /* SPR 16603 Fix code moved */
    /******* bug fix 9854 start*******/

    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
            "NeighborList.LTECell.RSTxPower",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
                        ncl_params.lte_ncl.intra_freq_cells[OAM_ZERO].r_stx_power),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        &set_bitmask_rstx_power,
        &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.LTECell[OAM_ZERO],
        "RSTxPower",
         SINT8_TYPE,
        (MULTI_INSTANCE_PARAM | OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    /********* bug fix 9854 end ************/
/* SPR 13501 FIX START */
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
        "DynamicICICParams.DLResourcePartitionInfo.NumOfCellEdgeRegion",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
                dynamic_icic_info.dl_resource_partition_info.num_of_cell_edge_region),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_num_ce_region,
        &(set_bitmask_dl_resorce_partition_info),
        OAM_NULL,
        "NumOfCellEdgeRegion",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
        "DynamicICICParams.DLResourcePartitionInfo.NumOfCellCenterRegion",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
        dynamic_icic_info.dl_resource_partition_info.num_of_cell_center_region),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_num_cc_region,
        &(set_bitmask_dl_resorce_partition_info),
        OAM_NULL,
        "NumOfCellCenterRegion",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },

    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
        "DynamicICICParams.DLResourcePartitionInfo.start_rb_cell_center",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(temp_string),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_start_rb,
        &(set_bitmask_dl_resorce_partition_info),
        OAM_NULL,
        "start_rb_cell_center",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
        "DynamicICICParams.DLResourcePartitionInfo.end_rb_cell_center",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(temp_string_1),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_end_rb,
        &(set_bitmask_dl_resorce_partition_info),
        OAM_NULL,
        "end_rb_cell_center",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
        "DynamicICICParams.DLResourcePartitionInfo.start_rb_cell_edge",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
          dynamic_icic_info.dl_resource_partition_info.cell_edge_region.start_rb),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_start_rb,
        &(set_bitmask_cell_edge_region_dl),
        OAM_NULL,
        "start_rb_cell_edge",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
          "DynamicICICParams.DLResourcePartitionInfo.end_rb_cell_edge",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
         dynamic_icic_info.dl_resource_partition_info.cell_edge_region.num_of_rb),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_end_rb,
        &(set_bitmask_cell_edge_region_dl),
        OAM_NULL,
        "end_rb_cell_edge",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
        "DynamicICICParams.ULResourcePartitionInfo.NumOfCellEdgeRegion",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
           dynamic_icic_info.ul_resource_partition_info.num_of_cell_edge_region),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_num_ce_region,
        &(set_bitmask_ul_resorce_partition_info),
        OAM_NULL,
        "NumOfCellEdgeRegion",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
          "DynamicICICParams.ULResourcePartitionInfo.NumOfCellCenterRegion",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
           dynamic_icic_info.ul_resource_partition_info.num_of_cell_center_region),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_num_cc_region,
        &(set_bitmask_ul_resorce_partition_info),
        OAM_NULL,
        "NumOfCellCenterRegion",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
          "DynamicICICParams.ULResourcePartitionInfo.start_rb_cell_center",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(temp_string_2),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_start_rb,
        &(set_bitmask_ul_resorce_partition_info),
        OAM_NULL,
        "start_rb_cell_center",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
        "DynamicICICParams.ULResourcePartitionInfo.end_rb_cell_center",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(temp_string_3),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_end_rb,
        &(set_bitmask_ul_resorce_partition_info),
        OAM_NULL,
        "end_rb_cell_center",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
         "DynamicICICParams.ULResourcePartitionInfo.start_rb_cell_edge",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
           dynamic_icic_info.ul_resource_partition_info.cell_edge_region.start_rb),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_start_rb,
        &(set_bitmask_cell_edge_region_ul),
        OAM_NULL,
        "start_rb_cell_edge",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    },
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.OperatorInfo."
         "DynamicICICParams.ULResourcePartitionInfo.end_rb_cell_edge",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
        OAM_NULL,        
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.
          dynamic_icic_info.ul_resource_partition_info.cell_edge_region.num_of_rb),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        oam_validate_dyn_icic_end_rb,
        &(set_bitmask_cell_edge_region_ul),
        OAM_NULL,
        "end_rb_cell_edge",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
    }
/* SPR 13501 FIX END */
};
/* spr_21013_fix_end */

parameter_map_element_t g_parameter_FTP_Params[]={
	{
		"InternetGatewayDevice.FTPParams.enable",
		&(local_prov_req.oam_nms_ftp_server_params),
		OAM_NULL,
		&(local_prov_req.oam_nms_ftp_server_params.Enable),
		OAM_FTP_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.nms_ftp_server_params),
		"X_VENDOR_Enable",
		UINT32_TYPE,
		(OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FTPParams.FTPServerurl",
		&(local_prov_req.oam_nms_ftp_server_params),
		OAM_NULL,
		&(local_prov_req.oam_nms_ftp_server_params.ftp_server_url),
		OAM_FTP_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.nms_ftp_server_params),
		"X_VENDOR_FTPServerURL",
		ASCII_STRING_TYPE,
		(OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FTPParams.FTPServerUserName",
		&(local_prov_req.oam_nms_ftp_server_params),
		OAM_NULL,
		&(local_prov_req.oam_nms_ftp_server_params.ftp_server_username),
		OAM_FTP_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.nms_ftp_server_params),
		"X_VENDOR_FTPServerUsername",
		ASCII_STRING_TYPE,
		(OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FTPParams.FTPServerpassword",
		&(local_prov_req.oam_nms_ftp_server_params),
		OAM_NULL,
		&(local_prov_req.oam_nms_ftp_server_params.ftp_server_password),
		OAM_FTP_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.nms_ftp_server_params),
		"X_VENDOR_FTPServerUserPassword",
		ASCII_STRING_TYPE,
		(OAM_WRITE_ONLY)
	},
	{
		"InternetGatewayDevice.FTPParams.FilePath",
		&(local_prov_req.oam_nms_ftp_server_params),
		OAM_NULL,
		&(local_prov_req.oam_nms_ftp_server_params.local_download_upload_path),
		OAM_FTP_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.nms_ftp_server_params),
		"X_VENDOR_LocalDirectoryPath",
		ASCII_STRING_TYPE,
		(OAM_WRITE_ONLY)
	}
};

parameter_map_element_t g_parameter_multi_instanse_FM_SUPP_GET_SET[]={
	{
		"InternetGatewayDevice.FaultMgmt.SupportedAlarm.ReportingMechanism",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO].reporting_mechanism_str),
		OAM_FM_SUPP_ALARM_REP_MECH_SET_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.SupportedAlarm[OAM_ZERO]),
        /*SPR 21205 Fixed Start */
		"ReportingMechanism",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM )

        /*SPR 21205 Fixed End */
	},
	{
		"InternetGatewayDevice.FaultMgmt.SupportedAlarm.EventType",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO].event_type_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.SupportedAlarm[RRM_ZERO]),
		"EventType",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.SupportedAlarm.ProbableCause",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO].probable_cause_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.SupportedAlarm[RRM_ZERO]),
		"ProbableCause",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.SupportedAlarm.SpecificProblem",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO].specific_problem),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.SupportedAlarm[RRM_ZERO]),
		"SpecificProblem",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.SupportedAlarm.PerceivedSeverity",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO].perceived_severity_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.SupportedAlarm[RRM_ZERO]),
		"PerceivedSeverity",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};


parameter_map_element_t g_parameter_multi_instanse_FM_CURR_GET_SET[]={
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.AlarmIdentifier",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].alarm_identifier),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"AlarmIdentifier",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},

	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.AlarmRaisedTime",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].alarm_raised_time),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"AlarmRaisedTime",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.AlarmChangedTime",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].alarm_changed_time),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"AlarmChangedTime",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.ManagedObjectInstance",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].managed_object_instance),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"ManagedObjectInstance",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.EventType",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].event_type_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"EventType",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.ProbableCause",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].probable_cause_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"ProbableCause",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.SpecificProblem",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].specific_problem),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"SpecificProblem",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.PerceivedSeverity",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].perceived_severity_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"PerceivedSeverity",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.AdditionalText",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].additional_text),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"AdditionalText",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.CurrentAlarm.AdditionalInformation",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO].additional_information),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"AdditionalInformation",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};

parameter_map_element_t g_parameter_multi_instanse_FM_HIST_GET_SET[]={
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.EventTime",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].event_time),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"EventTime",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.AlarmIdentifier",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].alarm_identifier),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"AlarmIdentifier",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.NotificationType",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].notification_type_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"NotificationType",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.ManagedObjectInstance",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].managed_object_instance),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"ManagedObjectInstance",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.EventType",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].event_type_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"EventType",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.ProbableCause",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].probable_cause_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"ProbableCause",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.SpecificProblem",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].specific_problem),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"SpecificProblem",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.PerceivedSeverity",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].perceived_severity_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"PerceivedSeverity",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.AdditionalText",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].additional_text),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"AdditionalText",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.HistoryEvent.AdditionalInformation",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO].additional_information),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"AdditionalInformation",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};

parameter_map_element_t g_parameter_multi_instanse_FM_EXPD_GET_SET[]={
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.EventTime",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].event_time),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.AlarmIdentifier",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].alarm_identifier),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.NotificationType",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].notification_type_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.ManagedObjectInstance",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].managed_object_instance),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.EventType",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].event_type_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.ProbableCause",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].probable_cause_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.SpecificProblem",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].specific_problem),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.PerceivedSeverity",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].perceived_severity_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.AdditionalText",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].additional_text),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.AdditionalInformation",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO].additional_information),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};
parameter_map_element_t g_parameter_multi_instanse_FM_QUED_GET_SET[]={
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.EventTime",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].event_time),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.AlarmIdentifier",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].alarm_identifier),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.NotificationType",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].notification_type_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.ManagedObjectInstance",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].managed_object_instance),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.EventType",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].event_type_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.ProbableCause",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].probable_cause_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.SpecificProblem",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].specific_problem),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.PerceivedSeverity",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].perceived_severity_str),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.AdditionalText",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].additional_text),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.FaultMgmt.QueuedEvent.AdditionalInformation",
		&(local_prov_req.fm_cntxt),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]),
		&(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO].additional_information),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};

parameter_map_element_t g_parameter_CONTROL_COMMAND_element[] = {
	{
		"Cell.Start.Cell_Identity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.eutran_global_cell_id),
		RRM_OAM_CELL_START_REQ_MASK,
		&validate_start_stop_cell_identity,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,        
		OAM_ZERO,            
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"Cell.Stop.Cell_Identity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.eutran_global_cell_id),
		RRM_OAM_CELL_STOP_REQ_MASK,
		&validate_start_stop_cell_identity,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,        
		OAM_ZERO,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"Enable.RRM.Radio_admission_control",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].global_cell_info.eutran_global_cell_id),
		RRM_OAM_RAC_ENABLE_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,        
		OAM_ZERO,            
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"Disable.RRM.Radio_admission_control",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].global_cell_info.eutran_global_cell_id),
		RRM_OAM_RAC_DISABLE_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,        
		OAM_ZERO,            
		(OAM_READ_ONLY || OAM_WRITE_ONLY)
	},
	{
		"Cell.Delete.Cell_Identity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.eutran_global_cell_id),
		RRM_OAM_CELL_DELETE_REQ_MASK,
		&validate_start_stop_cell_identity,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_ZERO,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"Cell.Setup.Cell_Identity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		RRM_OAM_CELL_SETUP_REQ_MASK,
		&validate_start_stop_cell_identity,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_ZERO,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"Cell.Block.Cell_Identity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.eutran_global_cell_id),
		OAM_RRM_CELL_BLOCK_REQ_MASK,
		&validate_start_stop_cell_identity,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_ZERO,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"Cell.Unblock.Cell_Identity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
				global_cell_info.eutran_global_cell_id),
		OAM_RRM_CELL_UNBLOCK_REQ_MASK,
		&validate_start_stop_cell_identity,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_ZERO,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},



	/* CSR 59167 removed*/
	{   
		"Clean.AlarmHistory",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.History_List_Index),
		OAM_FM_CLEAN_HISTORY_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_ZERO,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{   
		"Clean.AlarmList",
		&(local_prov_req.fm_cntxt),
		OAM_NULL,
		&(local_prov_req.fm_cntxt.CurrentAlarmNumberOfEntries),
		OAM_FM_CLEAN_ALARM_LIST_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_ZERO,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	}
};

#ifdef OAM_SON_ENABLE
/*eICIC_PHASE_1_2_CHANGES_START*/
/*SPR 14554 start*/
parameter_map_element_t g_parameter_son_cell_info_eicic_params[] = {
	{
		"SON.CELL-INFO_eICICParams.max_abs_usage_threshold",
		&(local_prov_req.oam_son_req.oam_son_cell_info_ind),
		OAM_NULL,
		/*SPR 21702 Start*/
                &(local_prov_req.oam_son_req.oam_son_cell_info_ind[OAM_ZERO].serving_cell[OAM_ZERO].abs_usage_threshold.max_abs_usage_threshold),
		/*SPR 21702 End*/
		OAM_SON_INFO_IND_MASK,
		OAM_NULL,
		&set_bitmask_cell_info_max_abs_usage_threshold,
		&(xml_struct_g.son_info_ind),
		"max_abs_usage_threshold",
		UINT8_TYPE,
		(OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.CELL-INFO_eICICParams.min_abs_usage_threshold",
		&(local_prov_req.oam_son_req.oam_son_cell_info_ind),
		OAM_NULL,
		/*SPR 21702 Start*/
		&(local_prov_req.oam_son_req.oam_son_cell_info_ind[OAM_ZERO].serving_cell[OAM_ZERO].abs_usage_threshold.min_abs_usage_threshold),
		/*SPR 21702 End*/
		OAM_SON_INFO_IND_MASK,
		OAM_NULL,
		&set_bitmask_cell_info_min_abs_usage_threshold,
		&(xml_struct_g.son_info_ind),
		"min_abs_usage_threshold",
		UINT8_TYPE,
		(OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},


};
/*SPR 14554 end*/
parameter_map_element_t g_parameter_son_anr_neighbor_default_config_req[] = {

	{
		"SON.ANR.NEIGHBOR-DEFAULT-CONFIG.nr_status",
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.nr_status),
		OAM_SON_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_neighbour_default_config_nr_status,
		/*bug_13878_start */
		&(xml_struct_g.son_oam_anr_neighbor_default_config_req),
		"nr_status",
		/*bug_13878_end */
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.NEIGHBOR-DEFAULT-CONFIG.ho_status",
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.ho_status),
		OAM_SON_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_neighbour_default_config_ho_status,
		/*bug_13878_start */
		&(xml_struct_g.son_oam_anr_neighbor_default_config_req),
		"ho_status",
		/*bug_13878_end */
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.NEIGHBOR-DEFAULT-CONFIG.x2_status",
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.x2_status),
		OAM_SON_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_neighbour_default_config_x2_status,
		/*bug_13878_start */
		&(xml_struct_g.son_oam_anr_neighbor_default_config_req),
		"x2_status",
		/*bug_13878_end */
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.NEIGHBOR-DEFAULT-CONFIG.csg_cell_intf_scheme",
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.csg_cell_intf_scheme),
		OAM_SON_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_neighbour_default_config_csg_cell_intf_scheme,
		/*bug_13878_start */
		&(xml_struct_g.son_oam_anr_neighbor_default_config_req),
		"csg_cell_intf_scheme",
		/*bug_13878_end */
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.NEIGHBOR-DEFAULT-CONFIG.pico_cell_intf_scheme",
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.pico_cell_intf_scheme),
		OAM_SON_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_neighbour_default_config_pico_cell_intf_scheme,
		/*bug_13878_start */
		&(xml_struct_g.son_oam_anr_neighbor_default_config_req),
		"pico_cell_intf_scheme",
		/*bug_13878_end */
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.NEIGHBOR-DEFAULT-CONFIG.macro_cell_intf_scheme",
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.macro_cell_intf_scheme),
		OAM_SON_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_neighbour_default_config_macro_cell_intf_scheme,
		&(xml_struct_g.son_oam_anr_neighbor_default_config_req),
		"macro_cell_intf_scheme",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	}

};
/* SPR_19619 start*/

parameter_map_element_t g_parameter_son_cell_activation_params[] = {
	{
		"SON.PEER_CELL_ACTIVATION.PLMNID",
		&(local_prov_req.oam_son_req.oam_son_peer_cell_activation_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_peer_cell_activation_req.served_cell_list[0].plmn_id),
		OAM_SON_CELL_ACTIVATION_INFO_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_g.son_oam_peer_cell_activation_req),
		"PLMNID",
		PLMN_TYPE,
		(OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.PEER_CELL_ACTIVATION.EUTRANCID",
		&(local_prov_req.oam_son_req.oam_son_peer_cell_activation_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_peer_cell_activation_req.served_cell_list[0].cell_identity),
		OAM_SON_CELL_ACTIVATION_INFO_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_g.son_oam_peer_cell_activation_req),
		"EUTRANCID",
		EUTRAN_CELL_IDENTITY_TYPE,
		(OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	}


};

/* SPR_19619 stop*/


/*eICIC_PHASE_1_2_CHANGES_END*/
parameter_map_element_t g_parameter_son_anr_modify_ue_count[] = {

	{
		"SON.ANR.MODIFY.UE_COUNT.UE_COUNT",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_ue_count_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_ue_count_req[OAM_ZERO].ue_cnt),
		OAM_SON_ANR_MODIFY_UE_COUNT_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	}
};

parameter_map_element_t g_parameter_son_anr_modify_meas_reporting_interval[] = {
	{
		"SON.ANR.MODIFY.MEAS_REPORTING_INTERVAL.Meas_Reporting_Interval",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_meas_reporting_interval_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_meas_reporting_interval_req[OAM_ZERO].reporting_interval),
		OAM_SON_ANR_MODIFY_MEAS_REPORTING_INTERVAL_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	}
};
parameter_map_element_t g_parameter_son_anr_modify_removal_criteria[] = {
	{
		"SON.ANR.MODIFY.REMOVAL_ATTRIBUTES.No_Activity_Interval",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_removal_attributes_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_removal_attributes_req[OAM_ZERO].removal_criteria.no_activity_interval),
		OAM_SON_ANR_MODIFY_REMOVAL_ATTRIBUTES_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_modify_removal_attributes_no_activity_interval,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.MODIFY.REMOVAL_ATTRIBUTES.Handover_Failure_Threshold",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_removal_attributes_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_removal_attributes_req[OAM_ZERO].removal_criteria.handover_failure_threshold),
		OAM_SON_ANR_MODIFY_REMOVAL_ATTRIBUTES_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_modify_removal_attributes_handover_failure_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.MODIFY.REMOVAL_ATTRIBUTES.Timeout_No_NR_Neighbors",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_removal_attributes_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_removal_attributes_req[OAM_ZERO].removal_criteria.timeout_no_nr_neighbors),
		OAM_SON_ANR_MODIFY_REMOVAL_ATTRIBUTES_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_modify_removal_attributes_timeout_no_nr_neighbors,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	}
};
parameter_map_element_t g_parameter_son_anr_modify_pci_confusion_cfg[] = {
	{
		"SON.ANR.MODIFY.PCI_CONFUSION_CFG.Suspect_PCI_Threshold",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_pci_confusion_cfg_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_pci_confusion_cfg_req[OAM_ZERO].pci_confusion_cfg.suspect_pci_threshold),
		OAM_SON_ANR_MODIFY_PCI_CONFUSION_CFG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_modify_pci_confusion_cfg_suspect_pci_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.MODIFY.PCI_CONFUSION_CFG.Clear_Suspect_PCI_Threshold",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_pci_confusion_cfg_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_pci_confusion_cfg_req[OAM_ZERO].pci_confusion_cfg.clear_suspect_pci_threshold),
		OAM_SON_ANR_MODIFY_PCI_CONFUSION_CFG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_modify_pci_confusion_cfg_clear_suspect_pci_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	}
};
    /* SPR 20653 Fix Start */
parameter_map_element_t g_parameter_son_anr_modify_attribute[] = {

	{
		"SON.ANR.MODIFY.ATTRIBUTE.UE_Throughput_DL_ANR_Threshold",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_attribute_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_attribute_req[OAM_ZERO].anr_attribute.ue_throughput_dl_anr_threshold),
		OAM_SON_ANR_MODIFY_ATTRIBUTE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_modify_attribute_ue_throughput_dl_anr_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	},
	{
		"SON.ANR.MODIFY.ATTRIBUTE.UE_Throughput_UL_ANR_Threshold",
		&(local_prov_req.oam_son_req.oam_son_anr_modify_attribute_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_anr_modify_attribute_req[OAM_ZERO].anr_attribute.ue_throughput_ul_anr_threshold),
		OAM_SON_ANR_MODIFY_ATTRIBUTE_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_modify_attribute_ue_throughput_ul_anr_threshold,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY| OAM_IGNORE_VALIDATION)
	}
};
    /* SPR 20653 Fix End */
parameter_map_element_t g_parameter_son_mro_modify_config_param[] = {
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Mro_Mode",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.mro_mode),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_son_mro_modify_config_param_req_mro_mode,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Mro_Param",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.mro_param),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_son_mro_modify_config_param_req_mro_param,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Mro_Ho_Failure_Accumulation_Duration",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.mro_ho_failure_accumulation_duration),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_mro_ho_failure_accumulation_duration,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Delta_Cio",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.delta_cio),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_son_mro_modify_config_param_req_delta_cio,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Mro_Ho_Attempts_Threshold",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.mro_ho_attempts_threshold),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_mro_trigger_optimization_ho_attempts,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Mro_Ho_Optimization_Start_Threshold",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.mro_ho_optimization_start_threshold),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_mro_trigger_analysis_ho_failure_rate,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Mro_Ho_Optimization_Stop_Threshold",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.mro_ho_optimization_stop_threshold),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_mro_ho_fail_rate,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Mro_Ho_Fail_Rate_For_Optimization",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.mro_ho_fail_rate_for_optimization),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_mro_ho_fail_rate_for_optimization,
		OAM_NULL,
		OAM_NULL,
		UINT16_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.TTT",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.ttt),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_mro_default_ttt,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	},
	{
		"SON.MRO.MODIFY.CONFIG.PARAM.Delta_ttt",
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_son_req.mro_modify_config_params_req[0].
				eutran_config_params.delta_ttt),
		OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK,
		OAM_NULL,
		&set_bitmask_son_mro_modify_config_param_req_delta_ttt,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
	}
};

#endif
parameter_map_element_t g_parameter_NONTR_element[] = {
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.operator_specific_info.phich_config.phich_duration",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.phich_config.phich_duration),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"phich_duration",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
#ifdef OAM_SON_ENABLE
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].action",
		&(local_prov_req.oam_son_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.nr_enb_action),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		OAM_NULL,
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].enb_type",
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].enb_id.enb_type),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		"enb_type",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].plmn_id",
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].enb_id.plmn_id),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		"plmn_id",
		PLMN_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].enb_id",
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].enb_id.enb_id),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		"enb_id",
		FOUR_BYTE_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].tac",
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].
				tac_list[OAM_ZERO].tac),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_nr_enb_tac),
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		OAM_NULL,
		TWO_BYTE_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].enb_tnl_address0",
		OAM_NULL,
		OAM_NULL,
		(local_prov_req.son_enb_tnl_ip_address[OAM_ZERO]),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		"ip_add",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].enb_tnl_address1",
		OAM_NULL,
		OAM_NULL,
		(local_prov_req.son_enb_tnl_ip_address[OAM_ONE]),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		"ipv4_add",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].x2_status",
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].x2_status),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_nr_enb_x2_status),
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		"x2_status",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
	{
		"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].x2_connection_status",
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].x2_connection_status),
		OAM_SON_NR_ENB_REQ_MASK,
		OAM_NULL,
		&(set_bitmask_nr_enb_x2_connection_status),
		&(xml_struct_g.nbr_enb_info[OAM_ZERO]),
		"x2_connection_status",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY|OAM_IGNORE_VALIDATION)
	},
#endif
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.operator_specific_info.phich_config.phich_resource",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.phich_config.phich_resource),            
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"phich_resource",
        UINT8_TYPE, 
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	}, 
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.cell_info.eutran_global_cell_id.primary_plmn_id.mcc",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].global_cell_info.eutran_global_cell_id.primary_plmn_id.mcc),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,    
        STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.cell_info.eutran_global_cell_id.primary_plmn_id.mnc",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].global_cell_info.eutran_global_cell_id.primary_plmn_id.mnc),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,        
        STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.cell_info.cell_access_params.intraFreqReselection",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].global_cell_info.cell_access_restriction_params.intra_freq_reselection),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.operator_specific_info.additional_sib_2_info.modification_period_coeff",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.sib_2_info.radio_res_config_common_sib.modification_period_coeff),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mod_period_coeff,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.operator_specific_info.additional_sib_2_info.default_paging_cycle",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.sib_2_info.radio_res_config_common_sib.default_paging_cycle),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_default_paging_cycle,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.operator_specific_info.additional_sib_2_info.nB",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.sib_2_info.radio_res_config_common_sib.nB),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_nB,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.ran_info.physical_layer_param_srs.srs_subframe_config",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.physical_layer_params.physical_layer_param_srs.srs_subframe_config),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_phy_layer_params,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.operator_specific_info.additional_sib_2_info.ul_cyclic_prefix_length",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ul_cy_pre_len,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.operator_specific_info.additional_sib_2_info.additional_spectrum_emission",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.sib_2_info.additional_spectrum_emission),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_adl_sib_2,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.operator_specific_info.additional_sib_2_info.time_alignment_timer_common",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].operator_info.sib_2_info.time_alignment_timer_common),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_adl_sib_2,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.ran_info.rlc_layer_params.num_valid_srb_info",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rlc_layer_params.num_valid_srb_info),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,        
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.ran_info.ncl_params.lte_ncl.intra_freq_cells.blacklisted",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.ncl_params.lte_ncl.intra_freq_cells[OAM_ZERO].blacklisted),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ncl_params,
		OAM_NULL,
		OAM_NULL,
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.ran_info.ncl_params.lte_ncl.intra_freq_cells.cell_individual_offset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info. ncl_params.lte_ncl.intra_freq_cells[OAM_ZERO].cell_individual_offset),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_cell_ind_offset,
		OAM_NULL,
		OAM_NULL,
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams.RRMParams.cellConfig.ran_info.rf_params.dl_earfcn",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.rf_params.rf_configurations.dl_earfcn),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
        UINT16_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
	},
#ifdef OAM_SON_ENABLE
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams."
			"RRMParams.cellConfig.operator_info.measurement_configuration."
			"EUTRAN.gapOffsetGP0",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				meas_gap_config.eutran_gap_config.
				setup_gap_config.gap_offset_gp0),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_eutran_gap_offset_gp0,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		OAM_WRITE_ONLY
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams."
			"RRMParams.cellConfig.operator_info.measurement_configuration."
			"EUTRAN.gapOffsetGP1",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				meas_gap_config.eutran_gap_config.
				setup_gap_config.gap_offset_gp1),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_eutran_gap_offset_gp1,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		OAM_WRITE_ONLY
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams."
			"RRMParams.cellConfig.operator_info.measurement_configuration."
			"UTRAN.gapOffsetGP0",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				meas_gap_config.utran_gap_config.
				setup_gap_config.gap_offset_gp0),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_utran_gap_offset_gp0,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		OAM_WRITE_ONLY
	},
	{
		"eNodeBParams.CellParams.Parameters_Cell1.RadioCtrlAndMgmtParams."
			"RRMParams.cellConfig.operator_info.measurement_configuration."
			"UTRAN.gapOffsetGP1",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				meas_gap_config.utran_gap_config.
				setup_gap_config.gap_offset_gp1),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_anr_utran_gap_offset_gp1,
		OAM_NULL,
		OAM_NULL,
		UINT8_TYPE,
		OAM_WRITE_ONLY
	},
#endif
	{   "Show.Version.VersionID",
		&(local_prov_req.oam_rrm_req.oam_send_oam_rrm_ver_id_resp),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_send_oam_rrm_ver_id_resp.ver_id),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"VersionID",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY)
	}
};

/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_TR_PLMNList_element[] = {
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"PLMNList.Enable",
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0]),
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0].plmn_entries[0]),
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0].plmn_entries[0].enable),
		/* SPR_19279_START */
		RRM_OAM_PLMNLIST_CONFIG_REQ_MASK,
		/* SPR 19977 Fix START */
		OAM_NULL,
		/* SPR 19977 Fix  End */
		/* SPR_19279_END */
		set_bitmask_epc_info_general,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PLMNList[OAM_ZERO]),
		"Enable",
		UINT8_TYPE,
		/* SPR_19279_START */
		/* SPR 19977 Fix START */
		(OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM )		
        /* SPR_19279_END */
		/* SPR 19977 Fix  End */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"PLMNList.IsPrimary",
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0]),
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0].plmn_entries[0]),
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0].plmn_entries[0].is_primary),
		/* SPR_19279_START */
		RRM_OAM_PLMNLIST_CONFIG_REQ_MASK,
		/* SPR 19977 Fix START */
		OAM_NULL,
		/* SPR 19977 Fix End */
		/* SPR_19279_END */
		set_bitmask_epc_info_general,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PLMNList[OAM_ZERO]),
		"IsPrimary",
		UINT8_TYPE,
		/* SPR_19279_START */
		/* SPR 19977 Fix  START */
		(OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
		/* SPR 19977 Fix End */
		/* SPR_19279_END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"PLMNList.PLMNID",
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0]),
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0].plmn_entries[0]),
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0].plmn_entries[0].plmn_id),
		/* SPR_19279_START */
		RRM_OAM_PLMNLIST_CONFIG_REQ_MASK,
		/* SPR 19977 Fix START */
		OAM_NULL,
		/* SPR 19977 Fix End */
		/* SPR_19279_END */
		set_bitmask_epc_info_general,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PLMNList[OAM_ZERO]),
		"PLMNID",
		PLMN_TYPE,
		/* SPR_19279_START */
		/* SPR 19977 Fix START */
		(OAM_WRITE_ONLY| MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM)
		/* SPR 19977 Fix End */
		/* SPR_19279_END */
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
			"PLMNList.CellReservedForOperatorUse",
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0]),
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0].plmn_entries[0]),
		&(LOCAL_RRM_PROV_REQ.plmnlist_data[0].plmn_entries[0].
				reserve_operator_use),
		/* SPR_19279_START */
		RRM_OAM_PLMNLIST_CONFIG_REQ_MASK,
		/* SPR_19279_END */
		OAM_NULL,
		&set_bitmask_epc_info_general,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.PLMNList[OAM_ZERO]),
		"CellReservedForOperatorUse",
		UINT8_TYPE,
		/* SPR_19279_START */
		(OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM | OAM_IS_CELL_SPEC_PARAM | OAM_IGNORE_VALIDATION)
		/* SPR_19279_END */
	}
};
/* spr_21013_fix_end */


/*SPR 21210 Fixed Start */
parameter_map_element_t g_parameter_tunnel_crypto_profile[] = {
	{   /* SPR 17378 START */
		"InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].Enable",
        /* SPR 17378 END */
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].Enable),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.CryptoProfile),
		"Enable",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM )
	},
	{   /* SPR 17378 START */
		"InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].AuthMethod",
        /* SPR 17378 END */
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].AuthMethod),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.CryptoProfile),
		"AuthMethod",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM |OAM_IGNORE_VALIDATION)
	},
	{   /* SPR 17378 START */
		"InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IKERekeyLifetime",
        /* SPR 17378 END */
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IKERekeyLifetime),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.CryptoProfile),
		"IKERekeyLifetime",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM )
	},
	{   /* SPR 17378 START */
		"InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IPsecRekeyLifetimeTime",
        /* SPR 17378 END */
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IPsecRekeyLifetimeTime),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.CryptoProfile),
		"IPsecRekeyLifetimeTime",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM )
	},
	{   /* SPR 17378 START */
		"InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].DPDTimer",
        /* SPR 17378 END */
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].DPDTimer),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.CryptoProfile),
		"DPDTimer",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM )
	},
	{
        /* SPR 17378 START */
		"InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].NATTKeepaliveTimer",
        /* SPR 17378 END */
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].NATTKeepaliveTimer),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.CryptoProfile),
		"NATTKeepaliveTimer",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM )
	},
    /* SPR 17378 START */
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].MaxChildSA",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].MaxChildSA),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "MaxChildSA",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM  )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IKEEncrypt",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IKEEncrypt),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "IKEEncrypt",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IKEPRF",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IKEPRF),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "IKEPRF",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IKEIntegrity",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IKEIntegrity),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "IKEIntegrity",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM ) 
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IKEDH",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IKEDH),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "IKEDH",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM  )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].ESPEncrypt",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].ESPEncrypt),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "ESPEncrypt",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].ESPIntegrity",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].ESPIntegrity),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "ESPIntegrity",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IPsecWindowSize",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IPsecWindowSize),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "IPsecWindowSize",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IPsecRekeyLifetimeByte",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].IPsecRekeyLifetimeByte),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "IPsecRekeyLifetimeByte",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].SecMaxFragSize",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].SecMaxFragSize),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "SecMaxFragSize",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].SecDFBit",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO]),
        &(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].SecDFBit),
        OAM_LOCAL_PARAMS_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.CryptoProfile),
        "SecDFBit",
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
    }
    /* SPR 17378 END */
};

/*SPR 21210 Fixed End */
/* OAM BCOM Code Comment Changes Start */
parameter_map_element_t g_parameter_tunnel_ikesa[] =
{
    {
        "InternetGatewayDevice.FAP.Tunnel.IKESA.[1].Status",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].Status),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.IKESA.[1].PeerAddress",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].PeerAddress),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        &(xml_struct_tr196_g.IKESA),
        "PeerAddress",
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.IKESA.[1].CreationTime",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].CreationTime),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IPAddress",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].IPAddress),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].SubnetMask",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].SubnetMask),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].DNSServers",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].DNSServers),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].DHCPServers",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].DHCPServers),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].IntegrityErrors",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].IntegrityErrors),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].OtherErrors",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].OtherErrors),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    },
    {
        "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1].AuthErrors",
        &(local_prov_req.oam_igd_params),
        OAM_NULL,        
        &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa[OAM_ZERO].AuthErrors),
        RRM_OAM_CELL_CONFIG_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT32_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
    }
};
/* OAM BCOM Code Comment Changes End */

/*SPR 21204 Fixed Start */
parameter_map_element_t g_parameter_tunnel_virtualInterface[] =
{
	{
		"InternetGatewayDevice.FAP.Tunnel.VirtualInterface.[1].Enable",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.virtual_interface_params[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.virtual_interface_params[OAM_ZERO].Enable),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.VirtualInterface),
		"Enable",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM |OAM_IGNORE_VALIDATION)
	},
	{
		"InternetGatewayDevice.FAP.Tunnel.VirtualInterface.[1].DSCPMarkPolicy",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.virtual_interface_params[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.virtual_interface_params[OAM_ZERO].DSCPMarkPolicy),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.VirtualInterface),
		"DSCPMarkPolicy",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM )
	},
	{
		"InternetGatewayDevice.FAP.Tunnel.VirtualInterface.[1].CryptoProfile",
		&(local_prov_req.oam_igd_params.tunnel_params),
		&(local_prov_req.oam_igd_params.tunnel_params.virtual_interface_params[OAM_ZERO]),
		&(local_prov_req.oam_igd_params.tunnel_params.virtual_interface_params[OAM_ZERO].CryptoProfile),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_IGNORE_VALIDATION | OAM_WRITE_ONLY |MULTI_INSTANCE_PARAM )
	}
};

/*SPR 21204 Fixed End */
/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t  g_parameter_lte_rem[] = {
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF.EUTRACarrierARFCN",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.eutra_carrier_arfcn),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		"EUTRACarrierARFCN",
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF."
			"RSRP",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.rsrp),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2),
		"RSRP",
		SINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF."
			"RSRQ",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.rsrq),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2),
		"RSRQ",
		SINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF."
			"RSSI",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.rssi),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].RF_2),
		"RSSI",
		SINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.RSTxPower",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.rstxpower),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"RSTxPower",
		SINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.TAC",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.tac),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"TAC",
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.CellID",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.cell_id),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"CellID",
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.CellBarred",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.cell_barred),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"CellBarred",
		UINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH."
			"MaxPLMNListEntries",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.max_plmn_list_entries),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"MaxPLMNListEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.PLMNListNumberOfEntries",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.plmn_list_number_of_entries),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"PLMNListNumberOfEntries",
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.DLBandwidth",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.dl_bdwth),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"DLBandwidth",
		UINT32_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.PLMNList.PLMNID",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.plmn_id),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].PLMNList_2),
		"PLMNID",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.PLMNList.CellReservedForOperatorUse",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.cell_reserved_for_operator_use),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].PLMNList_2),
		"CellReservedForOperatorUse",
		UINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"CarrierMeas.[1].CarrierARFCNDL",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.carrier_arfcndl),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas),
		"CarrierARFCNDL",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"CarrierMeas.[1].CarrierChWidth",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.carrier_chwidth),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas),
		"CarrierChWidth",
		SINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"CarrierMeas.[1].CarrierRSSI",
		&(local_prov_req.oam_igd_params.rem_lte_params),
		OAM_NULL,
		&(local_prov_req.oam_igd_params.rem_lte_params.carrier_rssi),
		OAM_LOCAL_PARAMS_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CarrierMeas),
		"CarrierRSSI",
		SINT8_TYPE,
		(OAM_READ_ONLY | MULTI_INSTANCE_PARAM)
	}
};

#ifdef OAM_SON_ENABLE
/* SPR 13065 CHANGE START */    
/* SPR 13065 CHANGE END */    
parameter_map_element_t g_parameter_son_pci_reselction[] = {
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"BCCH.DLBandwidth",
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req),
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.
				meas_bw_list[OAM_ZERO]),
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.
				meas_bw_list[OAM_ZERO]),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].BCCH),
		"DLBandwidth",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell."
			"RF.PhyCellID",
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req),
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.
				pci_list[OAM_ZERO]),
		&(local_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list[OAM_ZERO]),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1),
		"PhyCellID",
		UINT16_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	}
};
/* spr_21013_fix_end */
/* BUG_1171_START */


parameter_map_element_t g_parameter_son_pci_conflit_enable[] = {
	{
		/* SPR 11467 START */
		"SON.PCI-CONFLICT.PCI-MODE.ENABLE",
		&(local_prov_req.oam_son_req.oam_son_pci_conflict_enable_disable_req),
		OAM_NULL,
		&(local_prov_req.oam_son_req.oam_son_pci_conflict_enable_disable_req.pci_mode),
		SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_MASK,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		OAM_NULL,
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IGNORE_VALIDATION)
			/* SPR 11467 END */
	}
};

/* BUG_1171_END */


/* RT SPR 8154 FIX START */
/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_son_anr_geran_params[] = {
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.MaxGERANFreqGroupEntries",
		&(LOCAL_SON_PROV_REQ.oam_son_inter_freq_carrier_params),
		OAM_NULL,
		&(LOCAL_SON_PROV_REQ.oam_son_inter_freq_carrier_params[OAM_ZERO].
				max_geran_freq_entries),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERAN),
		"MaxGERANFreqGroupEntries",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroupNumberOfEntries",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list_size),
		OAM_ZERO,
		OAM_NULL,
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERAN),
		"GERANFreqGroupNumberOfEntries",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.TReselectionGERAN",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.t_reselection),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_t_reselection,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERAN),
		"TReselectionGERAN",
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.TReselectionGERANSFMedium",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.t_reselection_sf.sf_medium),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_t_reselection_sf,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERAN),
		"TReselectionGERANSFMedium",
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.TReselectionGERANSFHigh",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		OAM_NULL,
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.t_reselection_sf.sf_high),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_t_reselection_sf,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERAN),
		"TReselectionGERANSFHigh",
		UINT8_TYPE,
		(OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}
};

parameter_map_element_t g_parameter_son_anr_GERANFreqGroup_params[] = {
/* SPR 14651 START */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.Enable",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).geran_meas_enable[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).geran_meas_enable[0].
				enable),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL, 
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"Enable",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
/* SPR 14651 END */
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.BandIndicator",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].geran_car_freqs.band_ind),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL, 
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"BandIndicator",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.BCCHARFCN",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].geran_car_freqs.
				starting_arfcn),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL, 
		OAM_NULL,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"BCCHARFCN",
		UINT16_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.X_VENDOR_P_MAX_GERAN",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].p_max_geran),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_pmax_geran,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"X_VENDOR_P_MAX_GERAN",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.X_VENDOR_NCC_PERMITTED",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].ncc_permitted),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_ncc_permitted,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"X_VENDOR_NCC_PERMITTED",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.QRxLevMin",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].q_rx_lev_min),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_qrxlevmin,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"QRxLevMin",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.CellReselectionPriority",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].
				cell_reselection_priority),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_cell_reselection_priority,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"CellReselectionPriority",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.ThreshXHigh",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].threshX_high),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL, 
		&set_bitmask_son_geran_threshX_high,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"ThreshXHigh",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.ThreshXLow",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].threshX_low),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_threshX_low,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"ThreshXLow",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.X_VENDOR_OFFSET_FREQ",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.geran_config_list.
				geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.geran_config_list.
				geran_freq_info_list[0].offset_frequency),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL, 
		&set_bitmask_son_geran_offset_freq,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"X_VENDOR_OFFSET_FREQ",
		SINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup."
			"X_VENDOR_EXPLICIT_ARFCN_LIST",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		/* SPR 13024 FIX START */
		&(LOCAL_SON_ANR_MEAS_CONFIG_REQ(0).other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_ANR_MEAS_CONFIG_REQ(0).other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].geran_car_freqs.
				following_arfcns.exp_arfcn_list),
		/* SPR 13024 FIX END */
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_exp_arfcn_list,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"X_VENDOR_EXPLICIT_ARFCN_LIST",
		OAM_UINT16_TOKENIZED_LIST_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.X_VENDOR_ARFCN_SPACING",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].geran_car_freqs.
				following_arfcns.arfcn_spacing),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL, 
		&set_bitmask_son_geran_arfcn_spacing,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"X_VENDOR_ARFCN_SPACING",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup."
			"X_VENDOR_NUM_OF_FOLLOWING_ARFCNS",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].geran_car_freqs.
				following_arfcns.num_of_following_arfcn),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL, 
		&set_bitmask_son_geran_arfcn_spacing,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"X_VENDOR_NUM_OF_FOLLOWING_ARFCNS",
		UINT8_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
			"Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup."
			"X_VENDOR_ARFCN_BITMAP",
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0)),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0]),
		&(LOCAL_SON_INTER_FREQ_CARR_PARAMS(0).oam_son_anr_meas_config_req.
				other_rat_config_list.
				geran_config_list.geran_freq_info_list[0].geran_car_freqs.
				following_arfcns.arfcn_bmp_list_size),
		OAM_SON_ANR_MEAS_CONFIG_MASK,
		OAM_NULL,
		&set_bitmask_son_geran_arfcn_bitmap,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.GERANFreqGroup[0]),
		"X_VENDOR_ARFCN_BITMAP",
		OAM_BITMAP_TOKENIZED_LIST_TYPE,
		(OAM_IS_CELL_SPEC_PARAM | OAM_WRITE_ONLY | MULTI_INSTANCE_PARAM)
	}
};
/* spr_21013_fix_end */
/* RT SPR 8154 FIX END */
#endif

/* SPR-16334 START */

parameter_map_element_t g_parameter_x2ap_nr_enb_del[] = {
    {
        "L3Params.X2AP.ENB_Delete."
            "enb_id",
        &(local_prov_req.oam_l3_req.peer_enb_data),
        OAM_NULL,
        &(local_prov_req.oam_l3_req.peer_enb_data.eNB_id[OAM_ZERO].enb_id),
        X2AP_OAM_ENB_ADD_UPDATE_DELETE_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "L3Params.X2AP.ENB_Delete."
            "plmn_identity",
        &(local_prov_req.oam_l3_req.peer_enb_data),
        OAM_NULL,
        &(local_prov_req.oam_l3_req.peer_enb_data.eNB_id[OAM_ZERO].plmn_identity),
        X2AP_OAM_ENB_ADD_UPDATE_DELETE_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    }
};

parameter_map_element_t g_parameter_x2ap_nr_enb_params[] = {
    {
        "L3Params.X2AP.peer_eNB_CommInfo.Action",
        &(local_prov_req.oam_l3_req.oam_x2ap_req),
        OAM_NULL,
        &(local_prov_req.oam_l3_req.oam_x2ap_req.action),
        OAM_ZERO,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT8_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },

    {
        "L3Params.X2AP.peer_eNB_CommInfo.IPAddr",
        &(local_prov_req.oam_l3_req.oam_x2ap_req),
        OAM_NULL,
        &(local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[0].ip_addr[0].ip_addr),
        X2AP_OAM_ENB_ADD_UPDATE_DELETE_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "L3Params.X2AP.peer_eNB_CommInfo.Port",
        &(local_prov_req.oam_l3_req.oam_x2ap_req),
        OAM_NULL,
        &(local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[0].port),
        X2AP_OAM_ENB_ADD_UPDATE_DELETE_REQ_MASK,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        OAM_NULL,
        UINT16_TYPE,
        ( OAM_READ_ONLY | OAM_WRITE_ONLY)
    },
    {
        "L3Params.X2AP.peer_eNB_CommInfo.IPv6Addr",
        &(local_prov_req.oam_l3_req.oam_x2ap_req),
        OAM_NULL,
        &(local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[0].ipv6_addr[0].ipv6_addr),
        X2AP_OAM_ENB_ADD_UPDATE_DELETE_REQ_MASK,
        OAM_NULL,
        &set_bitmask_IPV6Addr,
        OAM_NULL,
        OAM_NULL,
        ASCII_STRING_TYPE,
        (OAM_READ_ONLY | OAM_WRITE_ONLY )
    }
};
/* SPR-16334 END */



/*LTE_OAM_CA_PARAMETER_SUPPORT */
/* SPR 14295 FIX START */
/* spr_21013_fix_start */
/* Parameter name and xml_parameter_parent element of table have been 
 * modified */
parameter_map_element_t g_parameter_ca_general_params[] = {
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.isCAEligible",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].
                operator_info.ca_config.is_ca_eligible),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_is_ca_eligible,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_params),
		"isCAEligible",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.minNumUEThruputReport",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.num_of_report),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_num_of_report,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_params),
		"minNumUEThruputReport",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.applicableBitrateDL",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.ca_applicable_bitrate_dl),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_ca_applicable_bitrate_dl,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_params),
		"applicableBitrateDL",
		UINT64_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.isMASA",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.is_masa),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_is_masa,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_params),
		"isMASA",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.ScellDeactTimer",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.scell_deactivation_timer),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_scell_deactivation_timer,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_params),
		"ScellDeactTimer",
		OAM_ENUM_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
    }
};


parameter_map_element_t g_parameter_ca_mac_sched_params[] = {
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
            "loadCalcWindowSize",
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
        OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
             ca_config.ca_mac_scheduler_params.load_calcualtion_window_size),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_load_calcualtion_window_size,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"loadCalcWindowSize",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"loadDisparityThresh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.ca_mac_scheduler_params.load_disparity_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_load_disparity_threshold,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"loadDisparityThresh",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
    {
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"MCSDiffThresh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.ca_mac_scheduler_params.mcs_diff_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mcs_diff_threshold,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"MCSDiffThresh",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"PRBUsageWatermark",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.ca_mac_scheduler_params.prb_usage_water_mark),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_prb_usage_water_mark,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"PRBUsageWatermark",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"DLDeactCMDThresh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.ca_mac_scheduler_params.dl_deact_command_thresh),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_dl_deact_command_thresh,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"DLDeactCMDThresh",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"DLDeactMCSLowThresh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.ca_mac_scheduler_params.dl_deact_mcs_low_thresh),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_dl_deact_mcs_low_thresh,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"DLDeactMCSLowThresh",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"DLQLoadUPThresh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.ca_mac_scheduler_params.dl_qload_up_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_dl_qload_up_threshold,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"DLQLoadUPThresh",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"DLQLoadLowThresh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
                ca_config.ca_mac_scheduler_params.dl_qload_low_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_dl_qload_low_threshold,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"DLQLoadLowThresh",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"ActDeactTriggerCountThresh",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
           ca_config.ca_mac_scheduler_params.act_deact_trigger_count_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_act_deact_trigger_count_threshold,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"ActDeactTriggerCountThresh",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	/* SPR 16422 START */
	{
        "InternetGatewayDevice.Services.FAPService.CellConfig."
            "X_VENDOR_CARRIER_AGGREGATION_PARAMS.MACSchedParams."
			"cqiValidityTimer",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
        &(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.
           ca_config.ca_mac_scheduler_params.act_deact_trigger_count_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_cqi_validity_timer,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.ca_mac_sched_params),
		"cqiValidityTimer",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}
	/* SPR 16422 END */
};
/* SPR 14295 FIX END */

/*LTE_CA_PARAMETER_SUPPORT */

/* eICIC_PHASE_1_2_CHANGES_START */
/*SPR 15028 start*/
parameter_map_element_t  g_parameter_x_vendor_eicic_params[] = {
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICParams."
			"eICICProvisionType",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.eicic_provisioned_type),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eicic_provision_type,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.eicic_params),
		"eICICProvisionType",
		OAM_ENUM_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	/*SPR 14165 start*/
	/*Deleted Rsrp,Rsrq*/
	/*SPR 14165 end*/
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.AbsInfoParams.ABS_INFO."
			"NumAbsReport",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.abs_info.num_abs_report),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_num_abs_report,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AbsInfo),
		"NumAbsReport",
		UINT16_TYPE, 
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.AbsInfoParams.ABS_INFO."
			"AbsUsageLowThreshold",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.abs_info.abs_usage_low_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_abs_usage_low_threshold,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AbsInfo),
		"AbsUsageLowThreshold",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.AbsInfoParams.ABS_INFO."
			"AbsUsageHighThreshold",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.abs_info.abs_usage_high_threshold),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_abs_usage_high_threshold,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AbsInfo),
		"AbsUsageHighThreshold",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.AbsInfoParams.ABS_PATTERN."
			"LowLoadAbsPattern",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.abs_info.abs_pattern.low_load_abs_pattern),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_low_load_abs_pattern,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AbsPattern),
		"LowLoadAbsPattern",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.AbsInfoParams.ABS_PATTERN."
			"VictimAbsPattern",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.abs_info.abs_pattern.victim_abs_pattern),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_victim_abs_pattern,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AbsPattern),
		"VictimAbsPattern",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	/*SPR 14180 start*/
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.AbsInfoParams.ABS_PATTERN."
			"VictimMeasSubset",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.abs_info.abs_pattern.victim_meas_subset),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_victim_meas_subset,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.AbsPattern),
		"VictimMeasSubset",
		ASCII_STRING_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},

	/*SPR 14180 end*/

	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICParams."
			"eligible_ue",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.eligible_ue),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_eligible_ue,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.eicic_params),
		"eligible_ue",
		UINT8_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},


	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICTimers."
			"MacEicicMeasReportPeriodicity",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.eicic_timer_info.mac_eicic_meas_report_periodicity),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_mac_eicic_meas_report_periodicity,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.eICICTimerInfo),
		"MacEicicMeasReportPeriodicity",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICTimers."
			"AggressorSelTimer",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.eicic_timer_info.aggressor_sel_timer),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_aggressor_sel_timer,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.eICICTimerInfo),
		"AggressorSelTimer",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICTimers."
			"LoadInformationGuardTimer",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.eicic_timer_info.load_information_guard_timer),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_load_information_guard_timer,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.eICICTimerInfo),
		"LoadInformationGuardTimer",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICTimers."
			"LoadInformationCollationTimer",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.eicic_timer_info.load_information_collation_timer),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_load_information_collation_timer,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.eICICTimerInfo),
		"LoadInformationCollationTimer",
		UINT16_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICParams."
			"DlSinrThreshLowMark",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.dl_sinr_threshold_low_mark),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_dl_sinr_threshold_low_mark,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.eicic_params),
		"DlSinrThreshLowMark",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	},
	{
		"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICParams."
			"DlSinrThreshHighMark",
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0]),
		OAM_NULL,
		&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[0].operator_info.eicic_info.dl_sinr_threshold_high_mark),
		RRM_OAM_CELL_CONFIG_REQ_MASK,
		OAM_NULL,
		&set_bitmask_dl_sinr_threshold_high_mark,
		&(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.eicic_params),
		"DlSinrThreshHighMark",
		UINT32_TYPE,
		(OAM_READ_ONLY | OAM_WRITE_ONLY | OAM_IS_CELL_SPEC_PARAM)
	}

};
/* spr_21013_fix_end */
/*SPR 15028 end*/

/* eICIC_PHASE_1_2_CHANGES_END */

/******************************************************************************
 *   FUNCTION NAME: oam_find_global_table_size
 *
 *   DESCRIPTION:
 *      This function calculates size of global variable pointer
 *  Inputs       : g_parameter_map_element : Array pointer
 *  Output       :  NONE  
 *
 *  RETURNS: Size of array pointed by pointer 
 *
 ******************************************************************************/
UInt16
oam_find_global_table_size
(
 parameter_map_element_t *g_parameter_map_element
 )
{
	OAM_FUN_ENTRY_TRACE();
	UInt16 tab_size = OAM_ZERO;

	if (g_parameter_map_element == &g_parameter_TR_element[OAM_ZERO]) 
	{
		tab_size = (ARRSIZE(g_parameter_TR_element));
	}
	/*SPR 13518 START*/
	else if (g_parameter_map_element == &g_parameter_cell_block_param[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_cell_block_param));
	}
	/*SPR 13518 END*/
#ifdef OAM_SON_ENABLE /* FLAG_CHANGES */
	else if (g_parameter_map_element == &g_parameter_son_mlb_modify_attribute_val[OAM_ZERO]) 
	{
		tab_size = (ARRSIZE(g_parameter_son_mlb_modify_attribute_val));
	}
	else if (g_parameter_map_element == &g_parameter_TR_InterFreq_Carrier_element[OAM_ZERO]) 
	{
		tab_size = (ARRSIZE(g_parameter_TR_InterFreq_Carrier_element));
	}
	else if (g_parameter_map_element == g_parameter_son_mro_modify_config_param) 
	{
		tab_size = (ARRSIZE(g_parameter_son_mro_modify_config_param));
	}
	/* RT SPR 9019 FIX START */
	else if(g_parameter_map_element == g_parameter_TR_UTRA_FDD_element) {
		tab_size = (ARRSIZE(g_parameter_TR_UTRA_FDD_element));
	}
	else if(g_parameter_map_element == g_parameter_UTRA_TDD_element) {
		tab_size = (ARRSIZE(g_parameter_UTRA_TDD_element));
	}
	/* RT SPR 9019 FIX END */
	else if (g_parameter_map_element == &(g_parameter_son_anr_enable_req[OAM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_enable_req));
	}
	else if (g_parameter_map_element == &(g_parameter_son_nw_scan_req[OAM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_son_nw_scan_req));
	}
	else if (g_parameter_map_element == &(g_parameter_son_nw_scan_status[OAM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_son_nw_scan_status));
	}
	else if (g_parameter_map_element == &(g_parameter_son_nw_scan_results_rf[OAM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_son_nw_scan_results_rf));
	}
	else if (g_parameter_map_element == &(g_parameter_son_nw_scan_results_bcch[OAM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_son_nw_scan_results_bcch));
	}

#endif
	else if (g_parameter_map_element == &g_parameter_NONTR_element[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_NONTR_element));
	}
#ifdef OAM_RADIO_HEAD_SUPPORT
#ifdef OAM_RRH_TYPE_1_SUPPORT
	else if(g_parameter_map_element == &parameter_RRH_element[OAM_ZERO]) {
		tab_size = (ARRSIZE(parameter_RRH_element));
	}
#endif
#endif
	else if (g_parameter_map_element == &g_parameter_TR_QOS_element[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_TR_QOS_element));
	}
	else if (g_parameter_map_element == &g_parameter_lte_l3_sctp_list[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_lte_l3_sctp_list));
	}
	else if (g_parameter_map_element == &g_parameter_lte_l3_Assoc_list[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_lte_l3_Assoc_list));
	}

#ifdef OAM_SON_ENABLE /* FLAG_CHANGES */
	/******** SON_CODE HARSH BEGINS *********/
	/*eICIC_PHASE_1_2_CHANGES_START*/
	else if(g_parameter_map_element == &g_parameter_son_anr_neighbor_default_config_req[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_neighbor_default_config_req));
	}

	/*SPR 14554 start*/
	else if(g_parameter_map_element == &g_parameter_son_cell_info_eicic_params[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_son_cell_info_eicic_params));
	}

	/*SPR 14554 end*/
	/*eICIC_PHASE_1_2_CHANGES_END*/

    /* SPR_19619 start*/
	else if(g_parameter_map_element == &g_parameter_son_cell_activation_params[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_son_cell_activation_params));
	}
    /* SPR_19619 stop*/

	else if(g_parameter_map_element == &g_parameter_son_anr_modify_ue_count[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_modify_ue_count));
	} 

	else if(g_parameter_map_element == &g_parameter_son_anr_modify_meas_reporting_interval[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_modify_meas_reporting_interval));
	} 

	else if(g_parameter_map_element == &g_parameter_son_anr_modify_removal_criteria[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_modify_removal_criteria));
	} 

	else if(g_parameter_map_element == &g_parameter_son_anr_modify_pci_confusion_cfg[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_modify_pci_confusion_cfg));
	} 
    /* SPR 20653 Fix Start */
	else if(g_parameter_map_element == &g_parameter_son_anr_modify_attribute[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_modify_attribute));
	} 
    /* SPR 20653 Fix End */
	/******** SON_CODE HARSH ENDS *********/
	/**** DROP 4 CODE ****/
	else if(g_parameter_map_element == g_parameter_lte_intra_rat_neighbor_list)
	{
		tab_size = (ARRSIZE(g_parameter_lte_intra_rat_neighbor_list));
	}
	else if(g_parameter_map_element == g_parameter_lte_inter_rat_neighbor_list)
	{
		tab_size = (ARRSIZE(g_parameter_lte_inter_rat_neighbor_list));
	}
	/* SPR-13586 START */
	else if(g_parameter_map_element == g_parameter_lte_inter_rat_geran_neighbor_list)
	{
		tab_size = (ARRSIZE(g_parameter_lte_inter_rat_geran_neighbor_list));
	}
	/* SPR-13586 END */
	else if(g_parameter_map_element == g_param_intra_rat_neigh_list_in_use)
	{
		tab_size = (ARRSIZE(g_param_intra_rat_neigh_list_in_use));
	}
	else if(g_parameter_map_element == g_param_inter_rat_neigh_list_in_use)
	{
		tab_size = (ARRSIZE(g_param_inter_rat_neigh_list_in_use));
	}
	/* SPR-13586 START */
	else if(g_parameter_map_element == g_parameter_lte_inter_rat_geran_neighbor_list_in_use)
	{
		tab_size = (ARRSIZE(g_parameter_lte_inter_rat_geran_neighbor_list_in_use));
	}
	/* SPR-13586 END */
	else if (g_parameter_map_element == &g_parameter_lte_son_es_list[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_lte_son_es_list));
	}

	else if (g_parameter_map_element == &g_parameter_nr_delete_from_rem_list[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_nr_delete_from_rem_list));
	}   
	else if (g_parameter_map_element == &g_parameter_nr_delete_from_rem_list_utran[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_nr_delete_from_rem_list_utran));
	}   
	/*********************/
#endif
	else if (g_parameter_map_element == &g_parameter_TR_PLMNList_element[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_TR_PLMNList_element));
	}
	else if (g_parameter_map_element == &g_parameter_multi_instanse_FM_SUPP_GET_SET[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_multi_instanse_FM_SUPP_GET_SET));
	}
	else if (g_parameter_map_element == &g_parameter_multi_instanse_FM_HIST_GET_SET[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_multi_instanse_FM_HIST_GET_SET));
	}
	else if (g_parameter_map_element == &g_parameter_multi_instanse_FM_CURR_GET_SET[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_multi_instanse_FM_CURR_GET_SET));
	}
	else if (g_parameter_map_element == &g_parameter_multi_instanse_FM_EXPD_GET_SET[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_multi_instanse_FM_EXPD_GET_SET));
	}
	else if (g_parameter_map_element == &g_parameter_multi_instanse_FM_QUED_GET_SET[OAM_ZERO])
	{
		tab_size = (ARRSIZE(g_parameter_multi_instanse_FM_QUED_GET_SET));
	}
    /* SPR 17378 START */
	else if (g_parameter_map_element == &g_parameter_tunnel_crypto_profile[OAM_ZERO]) {
    /* SPR 17378 END */
		tab_size = (ARRSIZE(g_parameter_tunnel_crypto_profile));
	}
    /* OAM BCOM Code Comment Changes Start */
    else if (g_parameter_map_element == &(g_parameter_tunnel_ikesa[RRM_ZERO]))
    {
        tab_size = (ARRSIZE(g_parameter_tunnel_ikesa));
    }
    /* OAM BCOM Code Comment Changes End */
	else if (g_parameter_map_element == &(g_parameter_tunnel_virtualInterface[RRM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_tunnel_virtualInterface));
	}
	/*Bug fix 1113 */
	else if (g_parameter_map_element == &(g_parameter_pm_gpv_spv_param[RRM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_pm_gpv_spv_param));
	}
#ifdef OAM_SON_ENABLE
	else if (g_parameter_map_element == &(g_parameter_rach_opt_config_params[OAM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_rach_opt_config_params));
	}
	else if (g_parameter_map_element == &(g_parameter_son_rem_lte_carrierMeas[RRM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_son_rem_lte_carrierMeas));
	}
	else if (g_parameter_map_element == &(g_parameter_son_nw_scan_results_bcch_plmnlist[RRM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_son_nw_scan_results_bcch_plmnlist));
	}
	else if(g_parameter_map_element == g_parameter_son_anr_geran_params)
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_geran_params));
	}
	else if(g_parameter_map_element == g_parameter_son_anr_GERANFreqGroup_params)
	{
		tab_size = (ARRSIZE(g_parameter_son_anr_GERANFreqGroup_params));
	}
	/*BUG_1171_STARAT*/ 
	else if (g_parameter_map_element == &(g_parameter_son_pci_conflit_enable[OAM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_son_pci_conflit_enable));
	}
	/*BUG_1171_END*/
#endif
	else if (g_parameter_map_element == &(g_parameter_FTP_Params[OAM_ZERO]))
	{
		tab_size = (ARRSIZE(g_parameter_FTP_Params));
	}


	/* LTE_OAM_CA_PARAMETER_SUPPORT */
/* SPR 14295 FIX START */
    else if (g_parameter_map_element == g_parameter_ca_general_params) {
        tab_size = (ARRSIZE(g_parameter_ca_general_params));
    }
    else if (g_parameter_map_element == g_parameter_ca_mac_sched_params) {
        tab_size = (ARRSIZE(g_parameter_ca_mac_sched_params));
    }
/* SPR 14295 FIX END */
	/* LTE_OAM_CA_PARAMETER_SUPPORT */

	/* eICIC_PHASE_1_2_CHANGES_START */
	else if (g_parameter_map_element == &( g_parameter_x_vendor_eicic_params[OAM_ZERO]))
	{
		tab_size = (ARRSIZE( g_parameter_x_vendor_eicic_params));
	}
	/* eICIC_PHASE_1_2_CHANGES_END */

    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    else if (g_parameter_map_element ==
            &(g_parameter_mbsfn_non_tr196_params[OAM_ZERO]))
    {
        tab_size = (ARRSIZE(g_parameter_mbsfn_non_tr196_params));
    }
    else if (g_parameter_map_element ==
            &(g_parameter_mbsfn_l3_params[OAM_ZERO]))
    {
        tab_size = (ARRSIZE(g_parameter_mbsfn_l3_params));
    }
    else if (g_parameter_map_element ==
            &(g_parameter_mbsfn_rrm_params[OAM_ZERO]))
    {
        tab_size = (ARRSIZE(g_parameter_mbsfn_rrm_params));
    }
    else if (g_parameter_map_element ==
            &(g_parameter_sfconfig_list_params[OAM_ZERO]))
    {
        tab_size = (ARRSIZE(g_parameter_sfconfig_list_params));
    }
#endif
    /* EMBMS Changes End */

	else
	{
		tab_size = (ARRSIZE(g_parameter_CONTROL_COMMAND_element));  
	}

	OAM_FUN_EXIT_TRACE();
	return tab_size;
}
/* SPR 11001 FIX START */
/* REDUNDANT CODE DELETED */
/* SPR 11001 FIX END */

/******************************************************************************
 *   FUNCTION NAME: validate_s1siglink
 *      
 *      
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *   Inputs       : s1siglink : parameter value
 *                loop : loop value for future reference
 *   Output       : NONE
 *              
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *          
 *******************************************************************************/
oam_return_et
validate_s1siglink
(            
 UInt8 *p_val,
 int loop,   
 UInt8* get_value
 )               
{
	char* temp = OAM_NULL;      
	UInt8 counter = OAM_ZERO;
	OAM_FUN_ENTRY_TRACE();
	/* SPR 20904 Fix +- */
	/* Parameters loop and *get_value are NULL */
	Char8 TempValue[OAM_MAX_MME_LIST_LEN] = {0};

	if(oam_strlen((Char8*)p_val) > OAM_MAX_MME_LIST_LEN) {
		OAM_LOG(OAM, OAM_WARNING, "S1SigLinkServerList exceeds max length");
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}

	oam_strncpy(TempValue, (Char8*)p_val, OAM_MAX_MME_LIST_LEN);
	temp = oam_strtok(TempValue, ",");

	while(temp) {
		/* CSR 00051709 Change Start*/
		if(oam_isValidIp4((UInt8 *)temp)==OAM_SUCCESS);
		else if(oam_isValidIp6((UInt8 *)temp)==OAM_ONE);
		else
		{
			OAM_LOG(OAM,OAM_DETAILED,"mme_comm info Ip Address Validation Failed");
			return OAM_FAILURE;
		}
		counter++; 
		temp = oam_strtok(OAM_NULL,",");
	}

	if(counter==OAM_ONE || nnsf_flag==OAM_FALSE)
	{
		sig_count=counter;
	}
	sig_server = counter;
	OAM_LOG(OAM,OAM_DETAILED,"mme_comm info Ip Address Validation successfull");
	TempValue[0] = '\0'; 
	/* CSR 00051709 Change End*/
	return OAM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: validate_s1connmode
 *      
 *      
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *   Inputs       : s1siglink : parameter value
 *                loop : loop value for future reference
 *   Output       : NONE
 *              
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *          
 *******************************************************************************/
oam_return_et
validate_s1connmode
(
 UInt8 *p_val,
 int loop,
 UInt8* get_value
 )
{
	OAM_FUN_ENTRY_TRACE();
	/* SPR 20904 Fix +- */
	/* Parameters loop and *get_value are NULL */
	if(p_val)
	{
		if(oam_strlen((char *)p_val)!=OAM_THREE)
		{
			OAM_LOG(OAM, OAM_DETAILED,
					"Value of S1ConnectionMode is %s and valid value is either ONE or ALL",
					p_val);
			return OAM_FAILURE;

		}
		if((p_val[0]=='O' || p_val[0]=='o')
				&&(p_val[1]=='N' || p_val[1]=='n')
				&&(p_val[2]=='E' || p_val[2]=='e'))
		{
			sig_count=OAM_ONE;
			return OAM_SUCCESS;
		}
		else if((p_val[0]=='A' || p_val[0]=='a')
				&&(p_val[1]=='L' || p_val[1]=='l')
				&&(p_val[2]=='L' || p_val[2]=='l'))
		{
			sig_count=OAM_ZERO;
			if(nnsf_flag==OAM_FALSE)
			{
				sig_count=OAM_ONE;
			}
			return OAM_SUCCESS;
		}
		else
		{
			OAM_LOG(OAM, OAM_DETAILED,
					"Value of S1ConnectionMode is wrong and valid value is either ONE or ALL");
			return OAM_FAILURE;

		}

		return OAM_SUCCESS;
	}
	return OAM_FAILURE;
}



/******************************************************************************
 *   FUNCTION NAME: validate_start_stop_cell_identity
 *
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : cell_identity:parameter value
 *                 loop : loop value for future reference
 *  Output       : NONE
 *
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *
 ******************************************************************************/
oam_return_et
validate_start_stop_cell_identity
(
 UInt8 *cell_identity,
 int loop,
 UInt8* get_value
 )
{
	OAM_FUN_ENTRY_TRACE();
	/* SPR 20904 Fix +- */
	/* Parameter *get_value is NULL */
	SInt8 value ;
	UInt8 local_cell_identity[MAX_CELL_ID_SIZE];
	OAM_NULL_CHECK(OAM_NULL != cell_identity);
	value = oam_atoi((char *)cell_identity);
	local_cell_identity[OAM_THREE] = value % OAM_TEN;
	local_cell_identity[OAM_TWO] = (value/OAM_TEN) % OAM_TEN;
	local_cell_identity[OAM_ONE] = (value/ OAM_HUNDRED) % OAM_TEN;
	local_cell_identity[OAM_ZERO] = (value/OAM_THOUSAND);

	if(
			((UInt8 *)g_parameter_map_element[loop].param_base_addr)[OAM_ZERO]==local_cell_identity[OAM_ZERO]&&
			((UInt8 *)g_parameter_map_element[loop].param_base_addr)[OAM_ONE]==local_cell_identity[OAM_ONE]&&
			((UInt8 *)g_parameter_map_element[loop].param_base_addr)[OAM_TWO]==local_cell_identity[OAM_TWO]&&
			((UInt8 *)g_parameter_map_element[loop].param_base_addr)[OAM_THREE]==local_cell_identity[OAM_THREE]
	  )
	{
		OAM_LOG(OAM,OAM_DETAILED,"CORRECT value cell_identity::%d ",value);

		OAM_FUN_EXIT_TRACE();
		return OAM_SUCCESS;
	}
	else
	{
		OAM_LOG(OAM,OAM_WARNING,"INCORRECT value cell_identity:%d ",value);
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}
}

/* SPR_20467_FIX_START/END Code Removed */

/******************************************************************************
 *   FUNCTION NAME: send_reconfig_resp_to_mgmt_intf
 *
 *   DESCRIPTION:
 *      This function will send reconfig resp to mgmt intf
 *  Inputs       :p_src,ell_reconfig_response,cell_reconfig_fail_cause 
 *  Output       : NONE
 *
 *   RETURNS:   NONE 
 *
 ******************************************************************************/
void send_reconfig_resp_to_mgmt_intf(UInt8 *p_src,
		oam_rrm_cell_reconfig_resp_t *p_resp)
{

	/* Fetch entry from TCB and get trans_id/api_id detail */
	UInt32 bitmask = OAM_ZERO;
	UInt16 transaction_id = OAM_ZERO;
	UInt16 dest_id = OAM_ZERO;
	transaction_id = get_word_from_header(p_src);
        /* SPR_19279_START */
        UInt8 cell_index = *((U8 *)(p_src + 10));
        /* SPR_19279_END */
	UInt16 trans_id = OAM_ZERO;
	SInt8 idx = OAM_ZERO;
	/* coverity 41329 */
	oam_error_code_et error_code = NO_ERROR;
	UInt16  usr_resp = OAM_RESULT_SUCCESS;
	UInt16  usr_err_code = OAM_ZERO;
	Char8   *err_str = OAM_NULL;
	UInt8   err_str_size = OAM_ZERO;
	UInt8 cid = OAM_ZERO;
    /* Spr 17753 Changes Start */
    UInt32 loop = OAM_ZERO;
    /* Spr 17753 Changes End */

	oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
	oam_rrm_cell_plmnlist_data_t *p_cell_local_plmnlist_data = OAM_NULL;
	oam_return_et retVal = OAM_FAILURE;
	oam_return_et layer_resp = OAM_FAILURE;
	xmlNode *p_req_xml_parent = OAM_NULL;
	xmlNode *p_orig_xml_parent = OAM_NULL;
	xmlNode **p_p_xml_struct_addr = OAM_NULL;
	oam_bool_et tcb_found = OAM_FALSE;
	/* SPR 13024 FIX START */
	oam_cell_status_t *p_cell_status = OAM_NULL;

	cid = oam_extract_cid_from_eutran_cellidentity(
			p_resp->global_cell_id.cell_identity);
  /* Spr 17753 Changes Start */
    loop = oam_get_earfcn_pci_select_arr_idx(cid);
  /* Spr 17753 Changes End */


	p_cell_status = oam_get_cell_cntxt_status(cid);
	/* coverity warning 64251 changes start */
	if (!p_cell_status) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]", cid);
		return;
	}

	oam_tcb_update_bitmask(transaction_id, OAM_TRANS_RRM, &bitmask);
	if(bitmask == OAM_ZERO) {
		/* SPR-13074 Start*/
        /* SPR 20270 changes start */
		if ( (!(p_cell_status->cell_event & OAM_CELL_PCI_CONFLICT)) && (!(OAM_SON_CARRIER_FREQ_ONGOING & oam_prov_req.system_status.event_ongoing)) && 
             /* SPR_20467_FIX_START */
             (!(OAM_SON_RACH_OPT_PARAMETER_UPDATE_ONGOING & oam_prov_req.system_status.event_ongoing)) 
             && (!(OAM_CELL_PLMNLIST_RRM_RECONFIG_ONGOING & oam_prov_req.system_status.event_ongoing)) ) {
             /* SPR_20467_FIX_END */
        /* SPR 20270 changes end */
			/* SPR 13024 FIX END */
			retVal = oam_process_tcb_for_layer_resp_ext(p_src, &trans_id,
					&dest_id,
					&p_orig_xml_parent,
					&p_req_xml_parent,
					&p_p_xml_struct_addr);
		}
		else {
			oam_prov_req.system_status.event_ongoing &= ~OAM_SON_CARRIER_FREQ_ONGOING;
            /* SPR 20270 changes start */
            oam_prov_req.system_status.event_ongoing &= ~(OAM_SON_RACH_OPT_PARAMETER_UPDATE_ONGOING);
            /* SPR 20270 changes end */
            /* SPR_20467_FIX_START */
            oam_prov_req.system_status.event_ongoing &= ~(OAM_CELL_PLMNLIST_RRM_RECONFIG_ONGOING);
            /* SPR_20467_FIX_END */
			/* SPR-13074 End*/
			retVal = oam_process_tcb_for_layer_resp(p_src, &trans_id,
					&dest_id);
		}

		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"No TCB record found for user request");
		}
		else {
			tcb_found = OAM_TRUE;
		}
	}

	/* coverity warning 64251 changes end */

	/* Send delete object response */
	/* SPR 13024 FIX START */
	if (!(p_cell_status->cell_event & OAM_CELL_PCI_CONFLICT)) {
		/* SPR 13024 FIX END */
		if(oam_prov_req.system_status.event_ongoing &
				OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING) {
			if(RRM_SUCCESS == p_resp->response) {
				usr_resp = OAM_RESULT_SUCCESS;
				usr_err_code = OAM_ZERO;
				err_str_size = OAM_ZERO;
			}
			else {
				usr_resp = OAM_RESULT_FAILURE;
				usr_err_code = OAM_ERR_INTERNAL_ERROR;

				err_str = "Failure response received from RRM";
				err_str_size = oam_strlen(err_str) + 1;
			}


            /* SPR_20467_FIX_START/END Code Removed */
			oam_construct_n_send_deleteobject_resp_to_usr(usr_resp,
					usr_err_code,
					(UInt8*)err_str,
					err_str_size,
					OAM_VERSION_ID,
					OAM_MODULE_ID,
					dest_id,
					trans_id,
					OAM_ZERO,
					OAM_ZERO,
					&error_code);
            /* SPR_20467_FIX_START/END Code Removed */
		}
		else {
			if (RRM_SUCCESS == p_resp->response) {
				usr_resp = OAM_RESULT_SUCCESS;
				usr_err_code = OAM_ZERO;
				err_str_size = OAM_ZERO;
			}
			else {
				usr_resp = OAM_RESULT_FAILURE;
				usr_err_code = OAM_ERR_INTERNAL_ERROR;

				err_str = oam_rrm_resp_code_to_str(p_resp->fail_cause);

				if (!err_str) {
					err_str = "Cell Reconfig Fail";
				}

				err_str_size = oam_strlen(err_str) + 1;
			}

            /* SPR_20467_FIX_START/END Code Removed */
                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_err_code,
                        (UInt8*)err_str,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        /* SPR_20467_FIX_START/END */
                        dest_id,
                        tcb_transaction_id,
                        OAM_ZERO,
                        OAM_ZERO,
                        &error_code);
            }
            /* SPR_20467_FIX_START/END Code Removed */
	}
	/* SPR 13024 FIX START */
	/* Code removed */
	/* SPR 13024 FIX END */


	/*set the master dataset of parameters if the SET reqest is success*/
	/* COV CID: 64251 FIX START */
	if(RRM_SUCCESS == p_resp->response) {
		layer_resp = OAM_SUCCESS;
		/* COV CID: 64251 FIX END */
		for (idx = 0; idx < oam_prov_req.num_cells_configured; ++idx) {
			/* SPR_19279_START */
			OAM_LOG(OAM,OAM_DETAILED,"cell_ctxt_status[idx].cid = %u, cell_index =%u",
					oam_prov_req.cell_cntxt.cell_ctxt_status[idx].cid, cell_index);
			if (oam_prov_req.cell_cntxt.cell_ctxt_status[idx].cid == cell_index) {
	         	/* SPR_19279_END */
				oam_memcpy(&RRM_PROV_REQ.oam_rrm_cell_config_req[idx],
						&LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[idx],
						sizeof(oam_rrm_cell_config_req_t));
			}
		}


		/* SPR_19279_START */ 
		if(oam_prov_req.system_status.event_ongoing &
				OAM_CELL_PLMNLIST_CONFIG_ONGOING) {
         /* Code Deleted */
		/* SPR_19279_END */

			/* COV CID: 64242 FIX START */
			idx = oam_get_cell_plmnlist_data_idx(cid);
			if(OAM_ERROR_RETURN_VAL == idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]", cid);
				return;
			}

			p_cell_plmnlist_data =
				&RRM_PROV_REQ.plmnlist_data[idx];
			p_cell_local_plmnlist_data =
				&LOCAL_RRM_PROV_REQ.plmnlist_data[idx];
			/* COV CID: 64242 FIX END */


			/* PLMNList object is deleted, update current number of entries,
			 * and valid_bitmap
			 */
            /* SPR 19977 Fix START */
			if(!(oam_prov_req.system_status.event_ongoing &
					OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING)) {
          	/* SPR 19977 Fix End */

				oam_memcpy(p_cell_plmnlist_data->plmn_entries,
						p_cell_local_plmnlist_data->plmn_entries,
						sizeof(p_cell_plmnlist_data->plmn_entries));

				/* PLMNList object is added, update current number of entries,
				 * and valid_bitmap
				 */
				/* SPR_19279_START */
                /* Code Deleted */
					p_cell_plmnlist_data->is_valid_bitmap |=
					(1 << p_cell_local_plmnlist_data->plmnlist_query_idx);

				tcb_found = OAM_FALSE;    
                /* Code Deleted */
				/* SPR_19279_END */
			}
		}
		/* SPR 13024 FIX START */
		/* Code removed */
		/* SPR 13024 FIX END */

/* Spr 17753 Changes Start */
#ifdef OAM_SON_ENABLE
        /* CID 115523,115525,115526 + */
        if(OAM_ERROR_RETURN_VAL != loop)
        {    
            oam_memcpy(&oam_prov_req.oam_son_req.earfcn_pci_selection[loop].oam_son_pci_reselection_req,
                    &local_prov_req.oam_son_req.earfcn_pci_selection[loop].oam_son_pci_reselection_req,
                    sizeof(oam_son_pci_reselection_req_t));
        }
        else
        {
		   OAM_LOG(OAM, OAM_ERROR, "Invalid array index %d", loop);
        }
        /* CID 115523,115525,115526 - */
#endif
/* Spr 17753 Changes End */ 
}
	else {
		/* Reset any flags remained set */
        /* SPR_20467_FIX_START/END */
		oam_prov_req.system_status.event_ongoing &= ~OAM_ADD_OBJ_ONGOING;
	}

	/* SPR 13024 FIX START */
	if (tcb_found && !(p_cell_status->cell_event & OAM_CELL_PCI_CONFLICT)) {
		/* SPR 13024 FIX END */
		oam_update_xml_dom(layer_resp, p_orig_xml_parent,
				p_req_xml_parent,
				p_p_xml_struct_addr);
	}
	else {
		OAM_LOG(OAM, OAM_WARNING,
				"XML DOM can't be updated as TCB is not found");
	}
}
/******************************************************************************
 *   FUNCTION NAME:oam_agnt_intf_msg_handler 
 *   INPUT :  *p_api_buf,api_id,src_module_id,msg_len
 *   RETURN:  OAM_SUCCESS/OAM_FAILURE
 *   DESCRIPTION: this function used for interface handling between OAM and AGNT.
 ******************************************************************************/
oam_return_et oam_agnt_intf_msg_handler
(
 void *p_api_buf, 
 UInt16 api_id, 
 UInt16 src_module_id, 
 UInt16 msg_len
 )

{
    oam_return_et  ret_val = OAM_SUCCESS;
    UInt8          instance_id = OAM_ZERO;

    OAM_FUN_ENTRY_TRACE();

    api_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_EXT_API_ID_FROM_HEADER);
    instance_id  = *((UInt8*)(p_api_buf) + OAM_INTF_HDR_CELL_IDX_OFFSET);

    switch (api_id)
    {
        case AGENT_OAM_INIT_IND:
            {
                oam_trigger_agent_fsm(p_api_buf, OAM_AGENT_EVENT_IND, instance_id);
            }
            break;

        case AGENT_OAM_SPAWN_PROCESS_RESP:
            {
                oam_trigger_agent_fsm(p_api_buf, OAM_AGENT_EVENT_SPAWN_RESP, instance_id);
            }
            break;

        case AGENT_OAM_KILL_PROCESS_RESP:
            {
                oam_trigger_agent_fsm(p_api_buf, OAM_AGENT_EVENT_KILL_RESP, instance_id);
            }
            break;

        case AGENT_OAM_GET_LOGS_RESP:
            {
                oam_trigger_agent_fsm(p_api_buf, OAM_AGENT_EVENT_GET_LOGS_RESP, instance_id);
            }
            break;

        case AGENT_OAM_IM_OK_IND:
            {
                oam_trigger_agent_fsm(p_api_buf, OAM_AGENT_EVENT_IM_OK_IND, instance_id);
            }
            break;

        default:
            OAM_LOG(OAM, OAM_WARNING, "Invalid message api_id=%u instance %u",
                    api_id, instance_id);
            break; 
    }
    OAM_FUN_EXIT_TRACE();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME:oam_sdm_intf_msg_handler 
 *   INPUT :  *p_api_buf,api_id,src_module_id,msg_len
 *   RETURN:  OAM_SUCCESS/OAM_FAILURE
 *   DESCRIPTION: this function used for interface handling between OAM and SDM.
 ******************************************************************************/
oam_return_et oam_sdm_intf_msg_handler
(
 void *p_api_buf, 
 UInt16 api_id, 
 UInt16 src_module_id, 
 UInt16 msg_len
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM,OAM_DETAILEDALL, "unused parameter %d and %d", src_module_id, msg_len);
	switch(api_id)
	{
		case SDM_OAM_RESPONSE_UPGRADE_START:

			OAM_LOG(OAM,OAM_INFO,"Shutdown Command Received from SDM");

			if(OAM_SUCCESS == oam_handle_sdm_upgrade_start_response(p_api_buf))
			{
				OAM_LOG(OAM,OAM_INFO,"Shutdown Initiated succesfully"); 
			}  
			break;
		case SDM_OAM_POLLING_REQ:

			if(OAM_SUCCESS == oam_handle_sdm_polling_req(p_api_buf))
			{
				OAM_LOG(OAM,OAM_INFO,"Oam Handle Sdm Polling REQ succesfully");
			}
			break;
		default:

			OAM_LOG(OAM,OAM_WARNING,"Invalid api_id[%d] FOR SDM", api_id);
			OAM_FUN_EXIT_TRACE();
			return OAM_FAILURE;
	} 
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}

#ifdef OAM_SHARED_MEM_LOGGER
/****************************************************************************
* Function Name  : oam_logger_init
* Inputs         : p_oam_logger_init_data, initial data
* Outputs        : None
* Returns        : None
* Description    : Start the monitoring of the memory
****************************************************************************/
rrm_void_t
*oam_logger_init(	
		oam_void_t *p_oam_logger_init_data)
{
    QTIME                   time;
    QTIMER                  timer;
    if(OAM_TRUE == oam_prov_req.oam_igd_params.oam_shared_mem_conf.is_shared_mem_conf_present)
    {
        time.s = oam_prov_req.oam_igd_params.
            oam_shared_mem_conf.wait_interval;
    }
    else
    {
        time.s = SHM_LOG_INTERVAL;
    }
    time.us = RRM_ZERO;
    timer = qvTimerStart(&time, PNULL, OAM_TRUE);
    if(timer == PNULL) {
        OAM_LOG(OAM, OAM_WARNING, "Timer Start failed for TimerType"
                " LOGGER_TIMER");
    }
    else
    {
        OAM_LOG(OAM, OAM_BRIEF, "Timer Started: Timer [%p], TimerType"
                "LOGGER_TIMER, TimerDuration [%u]sec [%u]msec",
                timer, time.s, time.us/1000);
    }
    lgr_process_log_segments();

    return PNULL;
}

/****************************************************************************
* Function Name  : oam_logger_process_msg
* Inputs         : p_api_buf, p_gl_ctx
* Outputs        : None
* Returns        : RRM_ZERO
* Description    : Logger message handler function. All message for logger
*                  thread will be processed by this function
****************************************************************************/
S32
oam_logger_process_msg
(
 oam_void_t *p_api_buf/*pointer to api buffer*/,
 oam_void_t *p_gl_ctx/*pointer to global logger context*/)
{
    return OAM_SUCCESS;
}

/****************************************************************************
 * Function Name  : oam_logger_process_timer_msg
 * Inputs         : timer_id, p_buf, p_context
 * Outputs        : None
 * Returns        : None
 * Description    : Function for handling the timer expiry of the logger thread
 ****************************************************************************/

oam_void_t
oam_logger_process_timer_msg
(
 QTIMER timer_id,
 oam_void_t *p_buf,
 oam_void_t *p_context)
{

    OAM_LOG(OAM, OAM_BRIEF, "Timer Started: Timer [%p]",
            timer_id);
    lgr_process_log_segments();
    return;
}
#endif

/******************************************************************************
 *   FUNCTION NAME: oam_user_intf_process_msg
 *
 *   DESCRIPTION:
 *      It user intf thd handler function
 *
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE
 *
 ******************************************************************************/

oam_return_et 
oam_user_intf_process_msg
(
 void *p_api_buf
 )
{
	OAM_FUN_ENTRY_TRACE();
	UInt16           api_id   = OAM_ZERO;
	UInt16           msg_size = OAM_ZERO;
	UInt16           src_id   = OAM_ZERO;
	UInt16 trans_id = OAM_ZERO; 
	oam_return_et ret_val  = OAM_SUCCESS;

	if ( OAM_NULL == p_api_buf)
	{
		OAM_LOG(OAM,OAM_WARNING,
				"p_api_buff is NULL:");
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;

	}
	/* Get the src ID */
	src_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_TWO);
	trans_id = get_word_from_header((UInt8 *)p_api_buf);
	oam_error_code_et error_code = NO_ERROR;

	/* For TR069 Init Flow, Get/Sert is required before CM state gets active */
	/* Hence modifying the check for the same */
    /* SPR 16975 FIX START */
    if ((QCLI_MODULE_ID == src_id) && (p_cm_cntxt->state != OAM_CM_ST_ACTIVE))
    /* SPR 16975 FIX END */
	{

		oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
				OAM_ERR_INTERNAL_ERROR,
				(UInt8 *) "eNodeB in an Inactive state", oam_strlen("eNodeB in an Inactive state")+ OAM_ONE,
				OAM_VERSION_ID, OAM_MODULE_ID,
				src_id, trans_id, OAM_ZERO, OAM_ZERO,
				&error_code);

		OAM_LOG(OAM,OAM_WARNING, "Currently eNodeB is not in an Active state");
		return OAM_FAILURE;
	}
	/* Get the api ID */
	api_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_SIX);

	/*getting api_size*/
	msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);

    /*SPR 21478 Start*/
	if(src_id == TR069_MODULE_ID || src_id == OAM_SNMP_INTF_MODULE_ID)
		ret_val = oam_tr069_intf_msg_handler(p_api_buf, api_id,OAM_MODULE_ID, msg_size);
	else if(src_id == QCLI_MODULE_ID)        
		ret_val = oam_qcli_intf_msg_handler(p_api_buf, api_id,OAM_MODULE_ID, msg_size);
    /*SPR 21478 End*/

	OAM_FUN_EXIT_TRACE();
	return ret_val;
}


/******************************************************************************
 * Function Name  : oam_layer_intf_process_msg
 * Inputs         : p_api_buf
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : This is the message handling function of OAM.
 ******************************************************************************/
oam_return_et
oam_layer_intf_process_msg
(
 void *p_api_buf
 )
{
	UInt16         trans_id = OAM_ZERO;
	UInt16         src_id   = OAM_ZERO;
	/* SPR Fix 17928 start */
#ifdef OAM_SON_ENABLE
	UInt16         dst_id      = OAM_ZERO;
#endif
	/* SPR Fix 17928 start */
	UInt16         api_id   = OAM_ZERO;
	UInt16         msg_size = OAM_ZERO;
	oam_return_et ret_val  = OAM_SUCCESS;
	OAM_FUN_ENTRY_TRACE();
	/* Get the Source ID */
	trans_id = get_word_from_header((UInt8*)p_api_buf);
	src_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_HDR_SRC_ID_OFFSET);
	/* SPR Fix 17928 start */
	/* Code Deleted */
	/* SPR Fix 17928 end */
	api_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_EXT_API_ID_FROM_HEADER);
	msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_HDR_MSG_SIZE_OFFSET);

	switch (src_id)
	{
#ifdef OAM_SON_ENABLE
		case SON_MODULE_ID:
			/* SPR Fix 17928 start */
	                dst_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_HDR_DST_ID_OFFSET);
			/* SPR Fix 17928 end */
			ret_val = oam_son_intf_msg_handler(p_api_buf, api_id, dst_id, msg_size);
			break;
#endif
		case  RRM_MODULE_ID:
			ret_val = oam_rrm_intf_msg_handler(p_api_buf, api_id, msg_size);
			break;
		case  MAC_MODULE_ID :
            /*SPR 17777 fix*/
			ret_val = oam_mac_intf_msg_handler(p_api_buf, api_id,msg_size);
			break;
		case  RLC_MODULE_ID :
			ret_val = oam_rlc_intf_msg_handler(p_api_buf, msg_size,api_id);
			break;
		case PDCP_MODULE_ID:
			ret_val =oam_pdcp_intf_msg_handler(p_api_buf, api_id);
			break;
		case EGTPU_MODULE_ID:
			ret_val = oam_egtpu_intf_msg_handler(p_api_buf, api_id);
			break;
		case RRC_MODULE_ID :
			ret_val = oam_rrc_intf_msg_handler(p_api_buf, trans_id,api_id);
			break;

#ifdef OAM_RADIO_HEAD_SUPPORT
		case RCM_MODULE_ID:
			if(oam_prov_req.rrh_flag) {
				ret_val = oam_rrh_intf_msg_handler(p_api_buf, trans_id, api_id);
			}
			else {
				OAM_LOG(OAM, OAM_WARNING, "RRH module disabled");
				ret_val = OAM_FAILURE;
			}
			break;
#endif
		case OAM_SDM_MODULE_ID:
			ret_val=oam_sdm_intf_msg_handler(p_api_buf, api_id,OAM_MODULE_ID, msg_size);
			break; 

		case OAM_AGNT_MODULE_ID:
			ret_val=oam_agnt_intf_msg_handler(p_api_buf, api_id,OAM_MODULE_ID, msg_size);
			break; 

		default:
			OAM_LOG(OAM,OAM_WARNING,"Unrecognized src module id [%d]",src_id);
			ret_val = OAM_FAILURE;
			break;
	}
	OAM_FUN_EXIT_TRACE();
	return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME : oam_PM_intf_process_msg 
 *   Inputs        : p_api_buf
 *   DESCRIPTION   :
 *
 *   RETURNS       : OAM_SUCCESS/OAM_FAILURE
 *
 ******************************************************************************/
oam_return_et
oam_PM_intf_process_msg
(
 void *p_api_buf
 )
{
    /* SPR 17777 fix */
	OAM_LOG(OAM,OAM_DETAILEDALL, "Entering  = oam_PM_intf_process_msg, unused parameter %p", p_api_buf);
	return OAM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME :oam_copy_config_to_reconfig 
 *   Inputs        :p_cell_config_req,p_cell_reconfig_req  
 *   DESCRIPTION   :
 *
 *   RETURNS       : OAM_SUCCESS/OAM_FAILURE
 *
 ******************************************************************************/
oam_return_et
oam_copy_config_to_reconfig(
		oam_rrm_cell_config_req_t *p_cell_config_req, 
		oam_rrm_cell_reconfig_req_t *p_cell_reconfig_req)
{
	rrm_oam_ran_t                     *p_ran_info = OAM_NULL;
    /*SPR 15527 START*/
    UInt8 index = OAM_ZERO;
    UInt8 qci_reconfig_idx = OAM_ZERO;
    UInt8 drx_reconfig_idx = OAM_ZERO;
    /*SPR 15527 END*/
    /* SPR 19753 Fix Start */
    UInt8 bitmask = OAM_ZERO;
    /* SPR 19753 Fix End */

	UInt8              idx = OAM_ZERO,
			   new_idx = OAM_ZERO;
	SInt16             primary_idx = -1;
	UInt8              query_idx = OAM_ZERO;
	rrm_oam_plmn_access_info_t tmp_plmnlist;
	oam_rrm_cell_plmnlist_data_t *p_cell_local_plmnlist_data = OAM_NULL;
	oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
	oam_rrm_plmn_data_t        *p_plmn_entries = OAM_NULL;
	UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;
	SInt8 arr_idx = OAM_ZERO;
	OAM_FUN_ENTRY_TRACE();
    /* SPR 15527 START */
    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d], rrm_cell_config_idx=[%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid ,cell_config_idx);
        return OAM_FAILURE;
    }   
    /* SPR 15527 END */

	oam_memcpy(&p_cell_reconfig_req->global_cell_id,
			&p_cell_config_req->global_cell_info.eutran_global_cell_id, 
			sizeof(rrm_oam_eutran_global_cell_id_t));

	oam_memcpy(&p_cell_reconfig_req->cell_access_restriction_params,
			&p_cell_config_req->global_cell_info.cell_access_restriction_params,sizeof(rrm_oam_cell_access_restriction_params_t));

	if (p_cell_reconfig_req->bitmask & RRM_OAM_RAN_INFO_PRESENT)
	{
		p_ran_info = &(p_cell_reconfig_req->ran_info);
		OAM_NULL_CHECK(OAM_NULL != p_ran_info);

		/* RAN Info Changes Starts */
		if (p_ran_info->bitmask & RRM_OAM_PHY_LAYER_PARAMS_PRESENT)
		{
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_PDSCH_CONFIG_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_pdsch,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_pdsch, 
						sizeof(rrm_oam_pdsch_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT)
			{
				/* SPR 11105 FIX START */
				if(p_ran_info->physical_layer_params.physical_layer_param_srs.bitmask & RRM_OAM_SRS_MAX_UP_PTS_PRESENT)
				{
					p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_srs.bitmask |= RRM_OAM_SRS_MAX_UP_PTS_PRESENT;
				}
				/* SPR 11105 FIX END */
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_srs,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_srs, 
						sizeof(rrm_oam_srs_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_prach,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_prach, 
						sizeof(rrm_oam_prach_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_pucch,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_pucch, 
						sizeof(rrm_oam_pucch_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_pusch,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_pusch, 
						sizeof(rrm_oam_pusch_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_UL_REF_SIG_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_ul_reference_signal,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal, 
						sizeof(rrm_oam_ul_reference_signal_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_UL_POWER_CTRL_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_ul_power_control,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_ul_power_control, 
						sizeof(rrm_oam_uplink_power_control_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_prs,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_prs, 
						sizeof(rrm_oam_prs_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_ADDITIONAL_PHYSICAL_LAYER_PARAM_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.addl_physical_layer_params,
						&p_cell_config_req->ran_info.physical_layer_params.addl_physical_layer_params, 
						sizeof(rrm_oam_addl_phy_params_t));
			}
			if(p_ran_info->physical_layer_params.bitmask &
					RRM_OAM_PHYSICAL_LAYER_PARAM_TDD_FRAME_PRESENT)
			{
				oam_memcpy(&p_ran_info->physical_layer_params.physical_layer_param_tdd_frame_structure,
						&p_cell_config_req->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure, 
						sizeof(rrm_oam_tdd_frame_structure_t));
			}
#ifdef LTE_EMBMS_SUPPORTED
            if (p_ran_info->physical_layer_params.bitmask &
                    RRM_OAM_MBSFN_CONFIGURATION_INFO_PRESENT)
            {
                oam_memcpy(&p_ran_info->physical_layer_params.
                        mbsfn_subframe_config_list,
                        &p_cell_config_req->ran_info.physical_layer_params.
                        mbsfn_subframe_config_list,
                        sizeof(rrm_mbsfn_subframe_config_list_t));
            }
#endif
		}

		if (p_ran_info->bitmask & RRM_OAM_MAC_LAYER_PARAMS_PRESENT)
		{

			/* SPR 9209 Fix Start*/ 
			oam_memcpy(&p_ran_info->mac_layer_params.dl_num_harq_process,&p_cell_config_req->ran_info.mac_layer_params.dl_num_harq_process, sizeof(p_cell_config_req->ran_info.mac_layer_params.dl_num_harq_process));
			oam_memcpy(&p_ran_info->mac_layer_params.dynamic_pdcch,&p_cell_config_req->ran_info.mac_layer_params.dynamic_pdcch, sizeof(p_cell_config_req->ran_info.mac_layer_params.dynamic_pdcch));
			/*SPR 9209 Fix End */
                        /* SPR 20174 Fix Start */
			oam_memcpy(&p_ran_info->mac_layer_params.cfi_value,&p_cell_config_req->ran_info.mac_layer_params.cfi_value, sizeof(p_cell_config_req->ran_info.mac_layer_params.cfi_value));
			oam_memcpy(&p_ran_info->mac_layer_params.num_of_eul,&p_cell_config_req->ran_info.mac_layer_params.num_of_eul, sizeof(p_cell_config_req->ran_info.mac_layer_params.num_of_eul));
			oam_memcpy(&p_ran_info->mac_layer_params.size_of_eul,&p_cell_config_req->ran_info.mac_layer_params.size_of_eul, sizeof(p_cell_config_req->ran_info.mac_layer_params.size_of_eul));
            /* SPR 20653 Fix Start */
			oam_memcpy(&p_ran_info->mac_layer_params.mac_ecid_meas_start_sfn,&p_cell_config_req->ran_info.mac_layer_params.mac_ecid_meas_start_sfn, sizeof(p_cell_config_req->ran_info.mac_layer_params.mac_ecid_meas_start_sfn));
            /* SPR 20653 Fix End */
                        /* SPR 20174 Fix End */
			if(p_ran_info->mac_layer_params.bitmask & RRM_OAM_MAC_LAYER_PARAM_RACH_PRESENT)
			{
				oam_memcpy(&p_ran_info->mac_layer_params.mac_layer_param_rach ,&p_cell_config_req->ran_info.mac_layer_params.mac_layer_param_rach, sizeof(rrm_oam_rach_t));
			}
			if(p_ran_info->bitmask & RRM_OAM_MAC_LAYER_PARAM_DRX_PRESENT)
			{
				oam_memcpy(&p_ran_info->mac_layer_params.mac_layer_param_drx ,&p_cell_config_req->ran_info.mac_layer_params.mac_layer_param_drx, sizeof(rrm_oam_drx_t));
			}
			if(p_ran_info->bitmask & RRM_OAM_UL_SYNC_LOSS_TIMER_PRESENT)
			{
				oam_memcpy(&p_ran_info->mac_layer_params.ul_sync_loss_timer ,&p_cell_config_req->ran_info.mac_layer_params.ul_sync_loss_timer, sizeof(p_cell_config_req->ran_info.mac_layer_params.ul_sync_loss_timer));
			}
			if(p_ran_info->bitmask & RRM_OAM_N_GAP_PRESENT)
			{
				oam_memcpy(&p_ran_info->mac_layer_params.n_gap ,&p_cell_config_req->ran_info.mac_layer_params.n_gap, sizeof(p_cell_config_req->ran_info.mac_layer_params.n_gap));
			}
		}
		/* Cov CID 54865 */
		if (p_ran_info->bitmask & RRM_OAM_RLC_LAYER_PARAMS_PRESENT)
		{
			oam_memcpy(&p_ran_info->rlc_layer_params ,&p_cell_config_req->ran_info.rlc_layer_params, sizeof(rrm_oam_rlc_layer_params_t));
		}
		if (p_ran_info->bitmask & RRM_OAM_RRC_TIMERS_CONST_PARAMS_PRESENT)
		{
			if (p_ran_info->rrc_timers_and_constants.bitmask & RRM_OAM_RRC_TIMERS_PRESENT)
			{
				oam_memcpy(&p_ran_info->rrc_timers_and_constants.rrc_timers,&p_cell_config_req->ran_info.rrc_timers_and_constants.rrc_timers, sizeof(rrm_oam_rrc_timers_t));
			}
			if (p_ran_info->rrc_timers_and_constants.bitmask & RRM_OAM_RRC_CONSTANTS_PRESENT)
			{
				oam_memcpy(&p_ran_info->rrc_timers_and_constants.rrc_constants ,&p_cell_config_req->ran_info.rrc_timers_and_constants.rrc_constants, sizeof(rrm_oam_rrc_constants_t));
			}          

		}
		if (p_ran_info->bitmask & RRM_OAM_RF_PARAMS_PRESENT)
		{
			oam_memcpy(&p_ran_info->rf_params ,&p_cell_config_req->ran_info.rf_params, sizeof(rrm_oam_rf_params_t));
		}
		if (p_ran_info->bitmask & RRM_OAM_S1AP_PARAMS_PRESENT)
		{
			oam_memcpy(&p_ran_info->s1ap_params ,&p_cell_config_req->ran_info.s1ap_params, sizeof(rrm_oam_s1ap_params_t));
		}
		if (p_ran_info->bitmask & RRM_OAM_NCL_PARAMS_PRESENT)
		{
			oam_memcpy(&p_ran_info->ncl_params ,&p_cell_config_req->ran_info.ncl_params, sizeof(rrm_oam_ncl_params_t));
		}
		if (p_ran_info->bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT)
		{
			if (p_ran_info->connected_mode_mobility_params.bitmask & RRM_OAM_COMMON_PARAMS_FOR_EUTRA_PRESENT)
			{
				oam_memcpy(&p_ran_info->connected_mode_mobility_params.common_params_for_eutra ,&p_cell_config_req->ran_info.connected_mode_mobility_params.common_params_for_eutra, sizeof(rrm_oam_common_params_for_eutra_t));
			}
			if (p_ran_info->connected_mode_mobility_params.bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT)
			{
				oam_memcpy(&p_ran_info->connected_mode_mobility_params.irat, &p_cell_config_req->ran_info.connected_mode_mobility_params.irat, sizeof(rrm_oam_irat_t));
			}
		}
		if (p_ran_info->bitmask & RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT)
		{

			if(p_ran_info->mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT)
			{

				if (p_ran_info->mobility_params.idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_COMMON_PARAMS_PRESENT)
				{
					oam_memcpy(&p_ran_info->mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params,&p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params, sizeof(rrm_oam_common_params_t));
				}
				if (p_ran_info->mobility_params.idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_INTRA_FREQ_PRESENT)
				{
					oam_memcpy(&p_ran_info->mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params,&p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params, sizeof(rrm_oam_intra_freq_params_t));
					oam_memcpy(&p_ran_info->mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.p_max_sib_3, &p_ran_info->mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.p_max_sib_1, sizeof(S8));
				}             if (p_ran_info->mobility_params.idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_INTER_FREQ_PRESENT)
				{
					oam_memcpy(&p_ran_info->mobility_params.idle_mode_mobility_params.idle_mode_inter_freq_params_list,&p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_inter_freq_params_list, sizeof(rrm_oam_inter_frequency_params_list_t));
				} 
				/* GERAN PARAMS */
				if(p_ran_info->mobility_params.idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT)
				{

					oam_memcpy(&p_ran_info->mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params,&p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params, sizeof(rrm_oam_idle_mode_mobility_inter_rat_geran_params_t));
				}
                /*SPR_17980_Fix_Start*/
                if(p_ran_info->mobility_params.idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT)
                {

                    oam_memcpy(&p_ran_info->mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params,&p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params, sizeof(rrm_oam_idle_mode_mobility_inter_rat_utra_params_t));
                }
                if(p_ran_info->mobility_params.idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT)
                {

                    oam_memcpy(&p_ran_info->mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params,&p_cell_config_req->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params, sizeof(rrm_oam_idle_mode_mobility_inter_rat_cdma2000_params_t));
                }

                /*SPR_17980_Fix_End */
			}
		}

	}

	if (p_cell_reconfig_req->bitmask & RRM_OAM_EPC_INFO_PRESENT) {
		if(p_cell_reconfig_req->epc_info.epc_params.
				bitmask & RRM_OAM_GENERAL_EPC_PARAMS_PRESENT) {
			if(p_cell_reconfig_req->epc_info.epc_params.general_epc_params.
					bitmask & RRM_OAM_EMERGENCY_AREA_ID_PRESENT) {
				oam_memcpy(p_cell_reconfig_req->epc_info.epc_params.
						general_epc_params.eaid,
						p_cell_config_req->epc_info.epc_params.
						general_epc_params.eaid,
						RRM_OAM_MAX_NUM_EAID_OCTETS);
			}

			/* The population of PLMNList is done at the end */
			oam_memcpy(p_cell_reconfig_req->epc_info.epc_params.
					general_epc_params.tac,
					p_cell_config_req->epc_info.epc_params.
					general_epc_params.tac,
					RRM_OAM_MAX_NUM_TAC_OCTETS);
		}
        /* SPR 15527 START */
        if(oam_prov_req.system_status.event_ongoing & OAM_MODIFY_QOS_OBJ_ONGOING)
        {
            p_cell_reconfig_req->epc_info.epc_params.num_valid_qos_profiles =
                OAM_ZERO;
            
            for(index = OAM_ZERO;index<RRM_PROV_REQ.qos_data[cell_config_idx].max_qos_entries;index++)
            {
                if(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].qos_enable == OAM_TRUE)
                {
                    oam_memcpy((void *)&p_cell_reconfig_req->epc_info.epc_params.
                            qos_config_params[qci_reconfig_idx],
                            (void *)&LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].qos_qci_info,
                            sizeof(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].qos_qci_info));    
                    if(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_enabled == OAM_TRUE)
                    {
                        LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_per_qci_info.
                            num_applicable_qci = OAM_ONE;
                        LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_per_qci_info.
                            applicable_qci_list[OAM_ZERO] =
                            LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].qos_qci_info.qci;
                    oam_memcpy((void *)&p_cell_reconfig_req->ran_info.
                                mac_layer_params.mac_layer_param_drx.drx_config[drx_reconfig_idx],
                            (void *)&LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_per_qci_info,
                            sizeof(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_per_qci_info));   
                        drx_reconfig_idx++;
                    }
                    p_cell_reconfig_req->epc_info.epc_params.num_valid_qos_profiles++;
                    p_cell_reconfig_req->ran_info.mac_layer_params.
                        mac_layer_param_drx.num_valid_drx_profiles = drx_reconfig_idx;
                    qci_reconfig_idx++;
                }
            }
        }
        else
        {
            p_cell_reconfig_req->epc_info.epc_params.num_valid_qos_profiles =
                OAM_ZERO;

            for(index = OAM_ZERO;index<RRM_PROV_REQ.qos_data[cell_config_idx].max_qos_entries;index++)
            {
                if(RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].qos_enable == OAM_TRUE)
                {
                    oam_memcpy((void *)&p_cell_reconfig_req->epc_info.epc_params.
                            qos_config_params[qci_reconfig_idx],
                            (void *)&RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].qos_qci_info,
                            sizeof(RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].qos_qci_info));    
                    if(RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_enabled == OAM_TRUE)
                    {
                        RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_per_qci_info.
                            applicable_qci_list[OAM_ZERO] =
                            RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].qos_qci_info.qci;
                    oam_memcpy((void *)&p_cell_reconfig_req->ran_info.
                                mac_layer_params.mac_layer_param_drx.drx_config[drx_reconfig_idx],
                            (void *)&RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_per_qci_info,
                            sizeof(RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[index].drx_per_qci_info));  
                        drx_reconfig_idx++;
                    }
                    p_cell_reconfig_req->epc_info.epc_params.num_valid_qos_profiles++;
                    p_cell_reconfig_req->ran_info.mac_layer_params.
                        mac_layer_param_drx.num_valid_drx_profiles = drx_reconfig_idx;
                    qci_reconfig_idx++;
                }
            }

        }
        /* SPR 15527 END */

		p_cell_reconfig_req->epc_info.epc_params.num_valid_qos_profiles =
			p_cell_config_req->epc_info.epc_params.num_valid_qos_profiles;

		oam_memcpy(p_cell_reconfig_req->epc_info.epc_params.
				qos_config_params,
				p_cell_config_req->epc_info.epc_params.qos_config_params,
				RRM_OAM_MAX_NUM_QCI_CLASSES *
				sizeof(rrm_oam_qos_config_params_t));

		p_cell_reconfig_req->epc_info.epc_params.emergency_erab_arp =
			p_cell_config_req->epc_info.epc_params.emergency_erab_arp;
	}

	if (p_cell_reconfig_req->bitmask & RRM_OAM_OPERATOR_INFO_PRESENT)
	{
        /* SPR 13501 FIX START */
        if (p_cell_reconfig_req->operator_info.
                bitmask & RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT) 
        {
            if (p_cell_reconfig_req->operator_info.dynamic_icic_info.
                    bitmask & RRM_OAM_DL_RESOURCE_PARTITON_INFO_PRESENT) 
            {
                p_cell_reconfig_req->operator_info.dynamic_icic_info.
                    dl_resource_partition_info.num_of_cell_edge_region =
                    p_cell_config_req->operator_info.dynamic_icic_info.
                    dl_resource_partition_info.num_of_cell_edge_region;

                p_cell_reconfig_req->operator_info.dynamic_icic_info.
                    dl_resource_partition_info.num_of_cell_center_region =
                    p_cell_config_req->operator_info.dynamic_icic_info.
                    dl_resource_partition_info.num_of_cell_center_region;

                oam_memcpy(&p_cell_reconfig_req->operator_info.
                        dynamic_icic_info.dl_resource_partition_info.
                        cell_center_region,
                        &p_cell_config_req->operator_info.
                        dynamic_icic_info.dl_resource_partition_info.
                        cell_center_region,
                        sizeof(rrm_oam_resource_partition_t) * RRM_OAM_MAX_CC_REGION);

                if (p_cell_reconfig_req->operator_info.dynamic_icic_info.
                        dl_resource_partition_info.
                        bitmask & RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT) 
                {
                    oam_memcpy(&p_cell_reconfig_req->operator_info.
                            dynamic_icic_info.dl_resource_partition_info.
                            cell_edge_region,
                            &p_cell_config_req->operator_info.
                            dynamic_icic_info.dl_resource_partition_info.
                            cell_edge_region,
                            sizeof(rrm_oam_resource_partition_t));
                }
            }

            if (p_cell_reconfig_req->operator_info.dynamic_icic_info.
                    bitmask & RRM_OAM_UL_RESOURCE_PARTITION_INFO_PRESENT) 
            {
                p_cell_reconfig_req->operator_info.dynamic_icic_info.
                    ul_resource_partition_info.num_of_cell_edge_region =
                    p_cell_config_req->operator_info.dynamic_icic_info.
                    ul_resource_partition_info.num_of_cell_edge_region;

                p_cell_reconfig_req->operator_info.dynamic_icic_info.
                    ul_resource_partition_info.num_of_cell_center_region =
                    p_cell_config_req->operator_info.dynamic_icic_info.
                    ul_resource_partition_info.num_of_cell_center_region;

                oam_memcpy(&p_cell_reconfig_req->operator_info.
                        dynamic_icic_info.ul_resource_partition_info.
                        cell_center_region,
                        &p_cell_config_req->operator_info.
                        dynamic_icic_info.ul_resource_partition_info.
                        cell_center_region,
                        sizeof(rrm_oam_resource_partition_t) * RRM_OAM_MAX_CC_REGION);

                if (p_cell_reconfig_req->operator_info.dynamic_icic_info.
                        ul_resource_partition_info.
                        bitmask & RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT) 
                {
                    oam_memcpy(&p_cell_reconfig_req->operator_info.
                            dynamic_icic_info.ul_resource_partition_info.
                            cell_edge_region,
                            &p_cell_config_req->operator_info.
                            dynamic_icic_info.ul_resource_partition_info.
                            cell_edge_region,
                            sizeof(rrm_oam_resource_partition_t));
                }
            }
        }
        else {
		/* SPR 19753 Fix Start */
		 bitmask = p_cell_reconfig_req->operator_info.bitmask;
            oam_memcpy(&p_cell_reconfig_req->operator_info ,&p_cell_config_req->operator_info , sizeof(rrm_oam_operator_info_t));
		p_cell_reconfig_req->operator_info.bitmask |= bitmask;
		/* SPR 19753 Fix End */
        }
        /* SPR 13501 FIX END */
		/* SPR 12200 Fix Start */
		oam_copy_operator_info_parameter_to_reconfig(&p_cell_reconfig_req->operator_info , 
				&p_cell_config_req->operator_info);
		/* SPR 12200 Fix End*/
	}

	/* SPR 12901 FIX START*/
	if (p_cell_reconfig_req->bitmask &
			RRM_OAM_RRM_ACCESS_MGMT_PARAMS_PRESENT) {
		oam_memcpy(&p_cell_reconfig_req->access_mgmt_params,
				&p_cell_config_req->access_mgmt_params,
				sizeof(rrm_oam_access_mgmt_params_t));

		p_cell_reconfig_req->access_mgmt_params.hnb_name_size =
			oam_strlen((Char8*)p_cell_reconfig_req->access_mgmt_params.hnb_name);
	}
	/* SPR 12901 FIX END */

	/* To support add/delete object of plmn list, populate plmn list */
	/* Reset already populated plmn list */
	p_cell_reconfig_req->epc_info.epc_params.general_epc_params.
		num_valid_plmn = OAM_ZERO;

	arr_idx = oam_get_cell_plmnlist_data_idx(cid);
	if(OAM_ERROR_RETURN_VAL == arr_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]", cid);
		return OAM_FAILURE;
	}


	if (oam_prov_req.system_status.event_ongoing &
			OAM_CELL_PLMNLIST_CONFIG_ONGOING) {

		p_cell_local_plmnlist_data =
			&LOCAL_RRM_PROV_REQ.plmnlist_data[arr_idx];

		p_cell_plmnlist_data = &RRM_PROV_REQ.plmnlist_data[arr_idx];

		p_cell_reconfig_req->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
		p_cell_reconfig_req->epc_info.epc_params.
			bitmask |= RRM_OAM_GENERAL_EPC_PARAMS_PRESENT;


		p_plmn_entries = p_cell_local_plmnlist_data->plmn_entries;

		if (oam_prov_req.system_status.event_ongoing &
				OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING) {
			query_idx = p_cell_plmnlist_data->plmnlist_query_idx;

			if (p_plmn_entries[query_idx].is_primary) {
				for(idx = OAM_ZERO; idx < RRM_OAM_MAX_NUM_PLMNS; ++idx) {
					if(idx != query_idx) {
						p_plmn_entries[idx].is_primary = OAM_ZERO;
					}
					else {
						p_plmn_entries[idx].enable = 1;
					}
				}
			}
		}

		for(idx = OAM_ZERO; idx < RRM_OAM_MAX_NUM_PLMNS; ++idx) {
            /* SPR_20467_FIX_START/END */
			if(p_plmn_entries[idx].enable)
			{
				if(p_plmn_entries[idx].is_primary) {
					primary_idx = idx;
				}

				oam_memcpy(&(p_cell_reconfig_req->epc_info.epc_params.
							general_epc_params.plmn_list[new_idx].plmn_info),
						&(p_plmn_entries[idx].plmn_id),
						sizeof(rrm_oam_cell_plmn_info_t));

				/* coverity 41319  53557*/
				p_cell_reconfig_req->epc_info.epc_params.general_epc_params.
					plmn_list[new_idx].reserve_operator_use =
					p_plmn_entries[idx].reserve_operator_use;

				/* Update valid entries */
				++p_cell_reconfig_req->epc_info.epc_params.
					general_epc_params.num_valid_plmn;

				++new_idx;
			}
		}

		OAM_LOG(OAM, OAM_DETAILED, "Number of valid PLMNIDs: %d",
				p_cell_reconfig_req->epc_info.epc_params.
				general_epc_params.num_valid_plmn);


		if(primary_idx > OAM_ZERO) {
			oam_memcpy(&tmp_plmnlist,
					&p_cell_reconfig_req->epc_info.epc_params.
					general_epc_params.plmn_list[0],
					sizeof(rrm_oam_plmn_access_info_t));

			oam_memcpy(&p_cell_reconfig_req->epc_info.epc_params.
					general_epc_params.plmn_list[0].plmn_info,
					&p_plmn_entries[primary_idx].plmn_id,
					sizeof(rrm_oam_cell_plmn_info_t));

			p_cell_reconfig_req->epc_info.epc_params.general_epc_params.
				plmn_list[0].reserve_operator_use =
				p_plmn_entries[primary_idx].reserve_operator_use;


			oam_memcpy(&p_cell_reconfig_req->epc_info.epc_params.
					general_epc_params.plmn_list[primary_idx],
					&tmp_plmnlist,
					sizeof(rrm_oam_plmn_access_info_t));
		}
	}
	else if ((p_cell_reconfig_req->bitmask & RRM_OAM_EPC_INFO_PRESENT) &&
			(p_cell_reconfig_req->epc_info.epc_params.
			 bitmask & RRM_OAM_GENERAL_EPC_PARAMS_PRESENT)) {
		/* PLMNList is mandatory parameter if the above mask is set */

		oam_memcpy(p_cell_reconfig_req->epc_info.epc_params.
				general_epc_params.plmn_list,
				p_cell_config_req->epc_info.epc_params.
				general_epc_params.plmn_list,
				sizeof(p_cell_reconfig_req->epc_info.epc_params.
					general_epc_params.plmn_list));

		p_cell_reconfig_req->epc_info.epc_params.general_epc_params.
			num_valid_plmn = p_cell_config_req->epc_info.epc_params.
			general_epc_params.num_valid_plmn;
	}
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}

/****************************************************************************
 * Function Name : oam_construct_n_send_get_resp_to_usr 
 * Description   : This function prepares a OAM_GET_PARAMETER_VALUES_RESP and
 *                 sends it to user interface.
 * Inputs        : 1. Pointer to location for reading for parsing
 *                 2. Length of message left to be read
 *                 3. Pointer to message buffer 
 * Outputs       : 1. Error Code
 * Returns       : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
void oam_construct_n_send_get_resp_to_usr(UInt8 resp_status,
		UInt32 resp_error_code,
		UInt8 oam_version, UInt16 src_id, 
		UInt16 dst_id, UInt16 req_trans_id,
		UInt8 api_version,
		UInt8 api_hdr_resvd_byte,
		char *error_str,
		oam_error_code_et *p_err_code)
{
	OAM_FUN_ENTRY_TRACE();
	UInt8 *p_msg = OAM_NULL;
	UInt8 *p_buf = OAM_NULL; 
	UInt8 error_str_len = OAM_ZERO;
	error_str_len = oam_strlen((const char *)error_str);


	UInt16 msg_len = (OAM_CSPL_HDR_SIZE + OAM_MGMT_INTF_HEADER_SIZE) + (OAM_INTF_HDR_MSG_SIZE_OFFSET + error_str_len);
	p_msg = oam_msg_mem_get(msg_len);
	if(PNULL == p_msg) {
        OAM_LOG(OAM,OAM_ERROR, "Memory allocation to p_msg failed");
		*p_err_code = OAM_MALLOC_FAIL;
		OAM_FUN_EXIT_TRACE();
		return;
	}
	p_buf = p_msg;
	/* There will be exactly 8 + error_str_len Bytes in the response message payload */
	/* The structure of the payload will be as follows:
	 * |   1 BYTE   |  2 BYTES   | 4 BYTES  | 1 BYTE   | error_str_len BYTES |
	 * +---------------------------------------------------------------------+
	 * |    Status  |            | Reserved | Length of| Error String / Info |
	 * | 0=SUCCESS  | Error Code | (all 0s) |   error  |                     |
	 * | 1=FAILURE  |            |          | string(0)|                     |
	 * +------------+------------+----------+----------+---------------------+*/

	/* encode CSPL header in message*/
	oam_construct_api_header(p_msg, oam_version,
			src_id, dst_id, OAM_GET_PARAMETER_VALUES_RESP, msg_len);
	p_msg += OAM_CSPL_HDR_SIZE;

	/* encode API header in message*/
	oam_construct_mgmt_api_hdr(p_msg, req_trans_id, src_id, dst_id,
			OAM_GET_PARAMETER_VALUES_RESP, msg_len - OAM_CSPL_HDR_SIZE,
            /*SPR 17777 fix*/
			api_hdr_resvd_byte);
	p_msg += OAM_MGMT_INTF_HEADER_SIZE;

	encode_get_params_resp_ctrl_blk((char *)p_msg , resp_status,
			resp_error_code, OAM_ZERO, OAM_ZERO, error_str_len,
			error_str);

	/* Coverity CID 99046 Fix Start */
	if(OAM_FAILURE == oam_send_message(p_buf, dst_id, p_err_code))
	{
		OAM_LOG(OAM, OAM_ERROR,
            /*SPR 17777 fix*/
				"Error: Sendto failed with err_code %d; Unused %d", *p_err_code,api_version);
	}
	/* Coverity CID 99046 Fix End */
	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : oam_construct_n_send_set_resp_to_usr 
 * Description   : This function prepares a OAM_SET_PARAMETER_VALUES_RESP and
 *                 sends it to user interface.
 * Inputs        : 1. Result Code
 *                 2. Respponse Error Code
 *                 3. Error String
 4. OAM version
 5. Source ID
 6. Destination ID
 7. Transaction ID
 8. API verion
 9. API header reserved byte
 * Outputs       : 1. Error Code
 * Returns       : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
void oam_construct_n_send_set_resp_to_usr(UInt8 resp_result,
		UInt32 resp_error_code,
		UInt8 *err_string,
		UInt8 err_string_size,
		UInt8 oam_version, UInt16 src_id,
		UInt16 dst_id, UInt16 req_trans_id,
		UInt8 api_version,
		UInt8 api_hdr_resvd_byte,
		oam_error_code_et *p_err_code)
{
	OAM_FUN_ENTRY_TRACE();
	UInt16 msg_len = OAM_CSPL_HDR_SIZE + OAM_MGMT_INTF_HEADER_SIZE;
	UInt16 payload_len = OAM_ZERO;
	UInt8 *payload = OAM_NULL;
	UInt8 *p_msg = OAM_NULL;
	if(err_string && (OAM_ZERO==oam_strncmp((const char *)"NO_ERROR",(const char *)err_string,oam_strlen((const char *)"NO_ERROR"))))
	{
		err_string = OAM_NULL;
	}

	/*OAM_REVIEW_CHANGES*/
	if(OAM_NULL == err_string || OAM_RESULT_SUCCESS == resp_result) {
		/*OAM_REVIEW_CHANGES*/
		payload_len = OAM_RRH_SET_RESP_PAYLOAD_LEN;
	}
	else 
	{
        /* SPR 18130 FIXED START */
        payload_len = OAM_RRH_SET_RESP_PAYLOAD_LEN + err_string_size + 5 ;
        /* SPR 18130 FIXED START */

	}


	msg_len += payload_len;

	p_msg = oam_msg_mem_get(msg_len);
	payload = p_msg; 
	if(PNULL == p_msg || PNULL == payload) {
        OAM_LOG(OAM,OAM_ERROR, "Memory allocation to p_msg failed");
		*p_err_code = OAM_MALLOC_FAIL;
		OAM_FUN_EXIT_TRACE();
		return;
	}

	OAM_LOG(OAM, OAM_INFO, "Trans_id in SPV response:%d",req_trans_id);
	/* encode CSPL header in message*/
	oam_construct_api_header(payload, oam_version,
			src_id, dst_id, OAM_SET_PARAMETER_VALUES_RESP, msg_len);
	payload += OAM_CSPL_HDR_SIZE;

	/* encode API header in message*/
	oam_construct_mgmt_api_hdr(payload, req_trans_id, src_id, dst_id,
			OAM_SET_PARAMETER_VALUES_RESP, msg_len - OAM_CSPL_HDR_SIZE,
            /*SPR 17777 fix*/
			api_hdr_resvd_byte);
	payload += OAM_MGMT_INTF_HEADER_SIZE;


	/* There will be exactly 8 bytes in the response message payload */
	/* The structure of the payload will be as follows:
	 * |   1 BYTE   |  2 BYTES   | 4 BYTES  | 1 BYTE   |
	 * +-----------------------------------------------+
	 * |    Status  |            | Reserved | Length of|
	 * | 0=SUCCESS  | Error Code | (all 0s) |   error  |
	 * | 1=FAILURE  |            |          | string   |
	 * +------------+------------+----------+----------+ */


	/* fill the response code */
	*payload = resp_result;
	/*OAM_REVIEW_CHANGES*/
	if(OAM_RESULT_FAILURE == resp_result) {
		/*OAM_REVIEW_CHANGES*/
		*(payload + OAM_ONE) = (resp_error_code >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
		*(payload + OAM_TWO) =  resp_error_code  & OAM_ALL_8_BIT_SET;
		oam_memset(payload + OAM_THREE, OAM_ZERO, OAM_FOUR);
		payload +=OAM_SEVEN;
		if(OAM_NULL == err_string) {
			*payload++ = OAM_ZERO;
		}
		else {
			*payload++ = err_string_size;
			oam_memcpy(payload, err_string, err_string_size);

            /* SPR 18130 FIXED START */
            payload += (3 + err_string_size);
            *payload++ = 0;
            *payload++ = 0;
            /* SPR 18130 FIXED END */
		}
	}
	else {
		/* If SPV has not been applied as layers are not confiured yet 
		   Set a reserved bit to indicate the same */
		if(OAM_FALSE == oam_prov_req.system_status.cell_setup_complete)
		{
			UInt8  actual_status = OAM_SPV_COMMITTED_NOT_APPLIED;

			oam_memset(payload + OAM_ONE, OAM_ZERO, OAM_TWO);
			*(payload + OAM_THREE) = actual_status & OAM_ALL_8_BIT_SET;
			oam_memset(payload + OAM_FOUR, OAM_ZERO, OAM_FOUR);
			OAM_LOG(OAM, OAM_INFO,
					"Sending status in SPV response as OAM_SPV_COMMITTED_NOT_APPLIED");
		}
		else
		{
			oam_memset(payload, OAM_ZERO, OAM_SEVEN);
		}
		OAM_LOG(OAM, OAM_DETAILED, "Sending success SPV response");
	}

	/* Coverity CID 99045 Fix Start */
	if(OAM_FAILURE == oam_send_message(p_msg, dst_id, p_err_code))
	{
		OAM_LOG(OAM, OAM_ERROR,
				/*SPR 17777 fix*/
				"Sendto failed with err_code %d; Unused %d", *p_err_code,api_version);
	}
	/* Coverity CID 99045 Fix End */

	OAM_FUN_EXIT_TRACE();
}

/* SPR 17880 START */
oam_return_et oam_construct_n_send_set_parameter_ind
(
    oam_error_code_et       *p_error_code,
    UInt16                  transaction_id
)
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 *p_msg= OAM_NULL, *p_api_msg= OAM_NULL;
    UInt16 msg_length = OAM_ZERO;
    UInt8 no_of_params = OAM_ZERO;

    msg_length = oam_get_spv_ind_msg_length(p_error_code,&no_of_params);
    msg_length += OAM_CSPL_HDR_SIZE + OAM_TR069_INTF_HEADER_SIZE;
    OAM_LOG(OAM,OAM_DETAILED,"Entry %s, msg_length %d, no_of_params = %d",__FUNCTION__,msg_length,no_of_params);         

    if(OAM_FAILURE == oam_mem_alloc(msg_length, (void*)&p_msg, p_error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_msg failed"
                " with Error Code:%d",
                *p_error_code);
        return OAM_FAILURE;
    }

    oam_memset(p_msg, OAM_ZERO, msg_length);
    p_api_msg = p_msg;

    /* encode the CSPL header in the message */
    oam_construct_api_header(p_api_msg, 
            OAM_VERSION, 
            OAM_MODULE_ID,
            TR069_MODULE_ID,
            OAM_TR069_SET_PARAMETER_VALUE_INDICATION,
            msg_length);

    p_api_msg += OAM_CSPL_HDR_SIZE;

    /* encode API header in message*/
    oam_construct_mgmt_api_hdr((UInt8 *)p_api_msg,
            transaction_id,
            OAM_MODULE_ID,
            TR069_MODULE_ID,
            OAM_TR069_SET_PARAMETER_VALUE_INDICATION,
            msg_length - OAM_CSPL_HDR_SIZE,
            OAM_ZERO);

    p_api_msg = p_api_msg + OAM_TR069_INTF_HEADER_SIZE ;
    oam_tr069_compose_spv_ind_message(p_api_msg,no_of_params);

    if(OAM_FAILURE == oam_send_message(p_msg, TR069_MODULE_ID, p_error_code))
    {
        OAM_LOG(OAM,OAM_DETAILED,"Failed to send message : %d",*p_error_code);         
        OAM_FUN_EXIT_TRACE(); 
        return OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

oam_length_t
oam_get_spv_ind_msg_length(oam_error_code_et *p_error_code,
                           UInt8* no_of_params)
{
    OAM_FUN_ENTRY_TRACE();
    OAM_LOG(OAM,OAM_DETAILED,"*p_error_code %d",*p_error_code);
 
    /* SPR 17880 18JAN FIX START */
    UInt16 msg_length = OAM_ZERO;
    UInt8 temp_no_of_params = OAM_ZERO;
    msg_length += OAM_FOUR;    /* Length of General Information */
    /* SPR 17880 18JAN FIX END */

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & SERVING_HEMS_USERNAME_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"Username=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.Username);;
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }
   
    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & SERVING_HEMS_PASSWORD_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"Password=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.Password);;
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & ENABLE_CWMP_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"EnableCWMP=") + OAM_ONE;
        /* SPR 17880 18JAN FIX START */
        msg_length += OAM_FOUR;
        /* SPR 17880 18JAN FIX END */
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_ENABLE_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"PeriodicInformEnable=") + OAM_ONE;
        /* SPR 17880 18JAN FIX START */
        msg_length += OAM_FOUR;
        /* SPR 17880 18JAN FIX END */
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_INTERVAL_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"PeriodicInformInterval=") + OAM_ONE;
        /* SPR 17880 18JAN FIX START */
        msg_length += OAM_FOUR;
        /* SPR 17880 18JAN FIX START */
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_TIME_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"PeriodicInformTime=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime);
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CONNECTION_REQUEST_USERNAME_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"ConnectionRequestUsername=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername);
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CONNECTION_REQUEST_PASSWORD_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"ConnectionRequestPassword=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword);
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CWMP_RETRY_MINIMUM_WAIT_INTERVAL_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"CWMPRetryMinimumWaitInterval=") + OAM_ONE;
        /* SPR 17880 18JAN FIX START */
        msg_length += OAM_FOUR;
        /* SPR 17880 18JAN FIX END */
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CWMP_RETRY_INTERVAL_MULTIPLIER_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"CWMPRetryIntervalMultiplier=") + OAM_ONE;
        /* SPR 17880 18JAN FIX START */
        msg_length += OAM_FOUR;
        /* SPR 17880 18JAN FIX END */
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CON_REQ_URL_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"ConnectionRequestURL=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.ConReqURL);
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    } 
    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & INITIAL_HEMS_ADDRESS_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"X_VENDOR_IHEMS_URL=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.initial_hems_address);
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }
    /* SPR 17880 18JAN FIX START */
    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & USERNAME_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"Username=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.Username);
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }    
    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PASSWORD_PRESENT)
    {
        msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
        msg_length += strlen((char *)"Password=") + OAM_ONE;
        msg_length += strlen((char *)local_prov_req.oam_tr069_req.tr069_init_params.Password);
        msg_length += sizeof(UInt16) + sizeof(UInt16);
        temp_no_of_params++;
    }    
    /* SPR 17880 18JAN FIX END */

    *no_of_params = temp_no_of_params;

    OAM_FUN_EXIT_TRACE();
    return  msg_length;
}


void
oam_tr069_compose_spv_ind_message
(
 UInt8 *p_buffer,
 UInt8 no_of_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    UInt16 resvd1 = OAM_ZERO;
    UInt8  resvd7 = OAM_ZERO;
    UInt32 resvd2 = OAM_ZERO;
    UInt32 resvd3 = OAM_ZERO;
    UInt32 resvd4 = OAM_ZERO;
    UInt32 resvd5 = OAM_ZERO;
    UInt32 resvd6 = OAM_ZERO;
    Char8 string[STR_LEN_128]={OAM_ZERO};
// buff[OAM_TEN]={OAM_ZERO};
    UInt16 param_len = OAM_ZERO;
    UInt16 pack_param_len = OAM_ZERO;
    UInt32 curr_pos = OAM_ZERO;
    UInt8  buffer[32] = {OAM_ZERO};
    OAM_FUN_ENTRY_TRACE();


    buffer[0] = '\0';
    /*packing number of parameters*/
    *(p_buffer + curr_pos++) = no_of_params;
    /*packing reserved field*/    
    *(p_buffer + curr_pos++) = (resvd1 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd1 & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd7;

    /*packing length of parameters*/

    /*Coverity Fix */

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & ENABLE_CWMP_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,(char *)"EnableCWMP=");
        sprintf((char *)buffer, "%d", local_prov_req.oam_tr069_req.tr069_init_params.EnableCWMP);
        strncat(string, (char *)buffer, sizeof(string) - OAM_ONE);
        param_len = strlen((char*)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*Packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len != OAM_ZERO)
            oam_memcpy(p_buffer+curr_pos,string,param_len);
        curr_pos +=param_len;

        /*packing length of parameters*/
        param_len = OAM_ZERO;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_ENABLE_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,(char *)"PeriodicInformEnable=");
        sprintf((char *)buffer, "%d", local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformEnable);
        strncat(string,(char *)buffer, sizeof(string) - OAM_ONE);
        param_len = strlen((char*)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*Packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd3 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd3 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len != OAM_ZERO)
            oam_memcpy(p_buffer+curr_pos,string,param_len);
        curr_pos +=param_len;

        /*packing length of parameters*/
        param_len = OAM_ZERO;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_INTERVAL_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        /* SPR 17880 18JAN FIX START */
        oam_strcat((char *)string,(char *)"PeriodicInformInterval=");
        /* SPR 17880 18JAN FIX END */
        sprintf((char *)buffer, "%d", local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformInterval);
        strncat(string, (char *)buffer, sizeof(string) - OAM_ONE);
        param_len = strlen((char*)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*Packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd4 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd4 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len != OAM_ZERO)
            oam_memcpy(p_buffer+curr_pos,string,param_len);
        curr_pos +=param_len;

        /*packing length*/
        param_len = OAM_ZERO;
    }


    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_TIME_PRESENT)
    {
        oam_memset(string, OAM_ZERO, sizeof(string));
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,"PeriodicInformTime=");
        /*coverity 109012 fix start*/
        strncat((char *)string,(char *)local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime, 
                sizeof(string)- oam_strlen((char*)string));
        /*coverity 109012 fix end*/
        param_len = strlen((char *)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd5 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd5 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len!= OAM_ZERO)
            oam_memcpy(p_buffer + curr_pos,string,param_len);      
        curr_pos +=param_len;


        /*packing length*/
        param_len = OAM_ZERO;
    }


    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CONNECTION_REQUEST_USERNAME_PRESENT)
    {
        oam_memset(string, OAM_ZERO, sizeof(string));
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,"ConnectionRequestUsername=");
        /*coverity 109012 fix start*/
        strncat((char *)string,(char *)local_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername, 
                sizeof(string)- oam_strlen((char*)string));
        /*coverity 109012 fix end*/

        param_len = strlen((char *)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd5 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd5 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len!= OAM_ZERO)
            oam_memcpy(p_buffer + curr_pos,string,param_len);      
        curr_pos +=param_len;

        /*packing length*/
        param_len = OAM_ZERO;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CONNECTION_REQUEST_PASSWORD_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,"ConnectionRequestPassword=");
        strncat((char *)string,(char *)local_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword ,   
                sizeof(string) - OAM_ONE );

        param_len = strlen((char *)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len!= OAM_ZERO)
            oam_memcpy(p_buffer + curr_pos,string,param_len);      
        curr_pos +=param_len;

        /*packing length*/
        param_len = OAM_ZERO;
    }


    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CWMP_RETRY_MINIMUM_WAIT_INTERVAL_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,"CWMPRetryMinimumWaitInterval=");
        sprintf((char *)buffer, "%d", local_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryMinimumWaitInterval);
        oam_strcat((char *)string,(char *)buffer);
        param_len = strlen((char *)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len!= OAM_ZERO)
            oam_memcpy(p_buffer + curr_pos,string,param_len);      
        curr_pos +=param_len;

        /*packing length*/
        param_len = OAM_ZERO;
    }

    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CWMP_RETRY_INTERVAL_MULTIPLIER_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,"CWMPRetryIntervalMultiplier=");
        sprintf((char *)buffer, "%d", local_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryIntervalMultiplier);
        oam_strcat((char *)string,(char *)buffer);
        param_len = strlen((char *)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len!= OAM_ZERO)
            oam_memcpy(p_buffer + curr_pos,string,param_len);      
        curr_pos +=param_len;

        /*packing length*/
        param_len = OAM_ZERO;
    }

    /* SPR 17880 18JAN FIX START */
    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & USERNAME_PRESENT)
    {
        oam_memset(string, OAM_ZERO, sizeof(string));
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,"Username=");
        /*coverity 109012 fix start */
        strncat((char *)string,(char *)local_prov_req.oam_tr069_req.tr069_init_params.Username, 
                sizeof(string)- oam_strlen((char*)string));
        /*coverity 109012 fix end */

        param_len = strlen((char *)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd5 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd5 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len!= OAM_ZERO)
            oam_memcpy(p_buffer + curr_pos,string,param_len);      
        curr_pos +=param_len;

        /*packing length*/
        param_len = OAM_ZERO;
    }    
    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PASSWORD_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,"Password=");
        strncat((char *)string,(char *)local_prov_req.oam_tr069_req.tr069_init_params.Password,   
                sizeof(string) - OAM_ONE );

        param_len = strlen((char *)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len!= OAM_ZERO)
            oam_memcpy(p_buffer + curr_pos,string,param_len);      
        curr_pos +=param_len;

        /*packing length*/
        param_len = OAM_ZERO;
    }    
    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & INITIAL_HEMS_ADDRESS_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,(char *)"X_VENDOR_IHEMS_URL=");
        strncat((char *)string,(char *)local_prov_req.oam_tr069_req.tr069_init_params.Password,   
                sizeof(string) - OAM_ONE );

        param_len = strlen((char*)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*Packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd4 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd4 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len != OAM_ZERO)
            oam_memcpy(p_buffer+curr_pos,string,param_len);
        curr_pos +=param_len;

        /*packing length*/
        param_len = OAM_ZERO;
    }
    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CON_REQ_URL_PRESENT)
    {
        oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
        oam_strcat((char *)string,(char *)"ConnectionRequestURL=");
        strncat((char *)string,(char *)local_prov_req.oam_tr069_req.tr069_init_params.initial_hems_address,   
                sizeof(string) - OAM_ONE );

        param_len = strlen((char*)string);
        string[param_len] = OAM_ZERO;
        param_len += OAM_ONE; /* For NULL character */
        pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
        *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

        /*Packing reserved field*/
        *(p_buffer + curr_pos++) = (resvd4 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = resvd4 & OAM_ALL_8_BIT_SET;

        /*packing string*/
        if(param_len != OAM_ZERO)
            oam_memcpy(p_buffer+curr_pos,string,param_len);
        curr_pos +=param_len;
    }
    /* SPR 17880 18JAN FIX END */

    OAM_FUN_EXIT_TRACE();
    return;
}
/* SPR 17880 END */


#ifdef OAM_SON_ENABLE

/*************************************************************************
 * Function Name: oam_son_handle_init_nr_req
 * Description  : This function handles init-time nr add/update requests
 * Inputs       : None
 * Outputs      : None
 * Returns      : None
 **************************************************************************/
/* + SPR 17439 */
oam_return_et oam_son_handle_init_nr_req(void)
{
/* - SPR 17439 */
	OAM_FUN_ENTRY_TRACE();

	SInt8 cell_arr_idx = OAM_ZERO;
	oam_return_et  ret_val = OAM_SUCCESS;
	oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;
	oam_son_nr_add_req_t *p_req = OAM_NULL;


	cell_arr_idx =         
		oam_get_son_cell_nr_list_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

	if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
        oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	p_req = &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).oam_son_nr_add_req;

	UInt16 idx = LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).nr_list_query_idx;

	p_son_nr_add = &SON_NEIGHBORLIST_INFO(cell_arr_idx).oam_son_nr_add_req;

	if(p_req->nr_list.intra_rat_nr_list_size) {
		if(idx > p_son_nr_add->nr_list.intra_rat_nr_list_size - OAM_ONE) {
			/** Add request received **/
			OAM_LOG(OAM, OAM_DETAILED,
					"Adding a new intra-RAT neighbor at init-time");
		}
		else {
			OAM_LOG(OAM, OAM_DETAILED,
					"Updating a new intra-RAT neighbor at init-time");
		}

		oam_memcpy(&p_son_nr_add->nr_list.intra_rat_nr_list[idx],
				&p_req->nr_list.intra_rat_nr_list[idx],
				sizeof(son_intra_rat_neighbor_info_t));
        /* Spr 15438 Fix Start */
        /* SPR 18930  FIX START */
        oam_memcpy(&SON_NEIGHBORLIST_INFO(cell_arr_idx).eutran_nbr_ctxt[idx],
                   &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).eutran_nbr_ctxt[idx],
                   sizeof(oam_son_nbr_ctxt_t));
        /* SPR 18930  FIX END */
        /* Spr 15438 Fix End*/

	}
	else {
		if(idx > p_son_nr_add->nr_list.inter_rat_nr_list_size - OAM_ONE) {
			/** Add request received **/
			OAM_LOG(OAM, OAM_DETAILED,
					"Adding a new inter-RAT neighbor at init-time");
		}
		else {
			OAM_LOG(OAM, OAM_DETAILED,
					"Updating a new inter-RAT neighbor at init-time");
		}

		oam_memcpy(&p_son_nr_add->nr_list.inter_rat_nr_list[idx],
				&p_req->nr_list.inter_rat_nr_list[idx],
				sizeof(son_inter_rat_neighbor_info_t));
/* Spr 15612  Fix Start*/
        /* SPR 18930  FIX START */
        oam_memcpy(&SON_NEIGHBORLIST_INFO(cell_arr_idx).utran_nbr_ctxt[idx],
                   &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).utran_nbr_ctxt[idx],
                   sizeof(oam_son_nbr_ctxt_t));
        /* SPR 18930  FIX END */
/* Spr 15612  Fix End*/

	}


	OAM_FUN_EXIT_TRACE();

	return ret_val;
}


/****************************************************************************
 * Function Name : oam_son_nr_add_access_mode_handling 
 * Description   : This function first checks access mode, if access mode is 
 *                 SON_OPEN, csg_identity is not sent to SON.
 * Inputs        : nr_add api structure to be sent to SON
 * Outputs       : none
 * Returns       : void
 ****************************************************************************/
void oam_son_nr_add_access_mode_handling(son_neighbor_info_t* p_nbr_info)
{
	UInt16 nbr_count = OAM_ZERO;

	for(nbr_count = OAM_ZERO; nbr_count < p_nbr_info->intra_rat_nr_list_size;
			++nbr_count) {
		if((p_nbr_info->intra_rat_nr_list[nbr_count].bitmask &
					SON_ACCESS_MODE_PRESENT) &&    

		/*SPR 16372 fix start*/
				((p_nbr_info->intra_rat_nr_list[nbr_count].access_mode
				 == SON_OPEN)||
                 (p_nbr_info->intra_rat_nr_list[nbr_count].access_mode == SON_OPEN_FEMTO))) {
		/*SPR 16372 fix end*/
			OAM_LOG(OAM, OAM_DETAILED, "Access Mode is set, so not sending "
					"CSG Identity for Intra-Rat Neighbour %d", nbr_count);

			p_nbr_info->intra_rat_nr_list[nbr_count].bitmask &=
				~(SON_INTRA_CSG_ID_PRESENT);
			oam_memset(p_nbr_info->intra_rat_nr_list[nbr_count].csg_identity,
					OAM_ZERO, SON_CSG_ID_OCTET_SIZE);
		}
	}
	for(nbr_count = OAM_ZERO; nbr_count < p_nbr_info->inter_rat_nr_list_size;
			++nbr_count) {
		if(SON_INTER_UTRAN_NEIGHBOR &
				p_nbr_info->inter_rat_nr_list[nbr_count].bitmask) {
			if((p_nbr_info->inter_rat_nr_list[nbr_count].utran_neighbor.
						bitmask & SON_UTRAN_ACCESS_MODE_PRESENT) &&    
					(p_nbr_info->inter_rat_nr_list[nbr_count].utran_neighbor.
					 access_mode == SON_OPEN)) {
				OAM_LOG(OAM, OAM_DETAILED, "Access Mode is set, so not "
						"sending CSG Identity for Inter-RAT Neighbour %d",
						nbr_count);
				p_nbr_info->inter_rat_nr_list[nbr_count].utran_neighbor.
					bitmask &= ~(SON_UTRAN_CSG_ID_PRESENT);
				oam_memset(p_nbr_info->inter_rat_nr_list[nbr_count].
						utran_neighbor.csg_identity, OAM_ZERO,
						SON_CSG_ID_OCTET_SIZE);
			}
		}
	}
}



/****************************************************************************
 * Function Name : oam_validate_send_son_nr_add_upd_req
 * Description   : This function first validates the user request for neighbor
 add or update and then it sends the request to SON layer
 * Inputs        : 1. transaction ID to send the request for
 *                 
 * Outputs       : p_error_code : Error Code
 * Returns       : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
/* SPR-13586 START */
	oam_return_et
oam_validate_send_son_nr_add_upd_req(UInt8 *p_api_buf,
		UInt16 trans_id,
		oam_error_code_et *p_err_code,
        /* SPR 18930  FIX START */
		UInt64 api_index,
        oam_bool_et * is_dom_update_reqd)
        /* SPR 18930  FIX END */

{
    /* SPR-13586 END */
    OAM_FUN_ENTRY_TRACE();
#define  NOT_FOUND          -1
#define BITMAP_FULL         0xffffffff
    oam_return_et retVal = OAM_FAILURE;
    SInt8 cell_arr_idx = OAM_ZERO;
    SInt8 cell_arr_idx1 = OAM_ZERO;
    /* SPR 18930  FIX START */
    SInt8 cell_meas_config_idx = OAM_ZERO;
    SInt8 nliu_idx = OAM_ZERO;
    /* SPR 18930  FIX END */
    UInt32 usr_req = oam_prov_req.system_status.event_ongoing &
        OAM_SON_ADD_NR_ONGOING;
    oam_cell_neighbourlist_info_t *p_local_cell_neigh_info = OAM_NULL;
    oam_cell_neighbourlist_info_t *p_cell_neigh_info = OAM_NULL;
    oam_son_nr_add_req_t *p_req = OAM_NULL;
    oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;
    UInt16 idx = OAM_ZERO;
    UInt16 api_id = OAM_ZERO;
    /*SPR_16927_START*/
    UInt32 is_neigh_idx_occupied = OAM_ZERO;
    /*SPR_16927_END*/
    Char8 *err_string = OAM_NULL;
    /* SPR 17408 Fix Start */
    Char8 cmd_status[OAM_USR_INTF_ERR_STR_MAX_SIZE] = {OAM_ZERO};
    /* SPR 17408 Fix End */

    /* SPR 15238 START */
    oam_eutran_nbr_cell_type_et nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
    /* SPR 15238 END */
    /* Start: SPR 10567 */
    SInt16 neigh_idx = OAM_ZERO;
    /*End: SPR 10567 */

    /* Spr 15438 Fix Start */
    SInt16 arfcn_found = NOT_FOUND;
    oam_son_anr_meas_config_req_t *p_anr_meas_config_req = OAM_NULL;
    oam_son_anr_updated_nrt_info_t *p_son_nrt_info = OAM_NULL;
    UInt32 nr_bit = OAM_ONE;
    oam_error_code_et p_error_code = NO_ERROR;
    /* SPR 18930  FIX START */
    /* Code REMOVED */
    /* SPR 18930  FIX END */
    /* Spr 15438 Fix End*/

    /*BUG_FIXED_12591_START */
    SInt16 cgi_found = NOT_FOUND;
    oam_rrm_cell_config_req_t *p_rrm_cell_config =  OAM_NULL;
    oam_freq_type_et freq_found = OAM_FREQ_NOT_AVAILABLE;
    UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    /* RT SPR 9019 FIX START */
    if(!p_api_buf || !p_err_code) {
        OAM_LOG(OAM, OAM_WARNING, "NULL POINTER ERROR!!");

        /*Coverity Fix 67036*/
        if(p_err_code != OAM_NULL){
            *p_err_code = OAM_NULL_POINTER_ERR;
        }
        OAM_FUN_ENTRY_TRACE();
        return retVal;
    }
    /* RT SPR 9019 FIX END */

    trans_id = get_word_from_header(p_api_buf);

    cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
    cell_arr_idx1 = oam_get_son_cell_nr_list_idx(cid);
    /* SPR 18930  FIX START */
    cell_meas_config_idx = oam_get_son_inter_freq_carrier_idx(cid);
    nliu_idx = oam_get_son_neigh_list_in_use_idx(cid);
    /*Coverity Fix 67037*/
    if((OAM_ERROR_RETURN_VAL == cell_arr_idx) ||
            (OAM_ERROR_RETURN_VAL == cell_arr_idx1) ||
            (OAM_ERROR_RETURN_VAL == cell_meas_config_idx) ||
            (OAM_ERROR_RETURN_VAL == nliu_idx)) {

        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context"
                "[cid=%d , rrm_cell_config_idx=%d, son_cell_nr_list_idx=%d"
                " cell_meas_config_idx =%d, nliu_idx =%d]",
                cid, cell_arr_idx, cell_arr_idx1,cell_meas_config_idx,nliu_idx);

        *p_err_code = OAM_INVALID_CELL_CONTEXT;
        return retVal;
    }
    /* SPR 18930  FIX END */


    p_rrm_cell_config = &RRM_CELL_CONFIG(cell_arr_idx); 
    p_local_cell_neigh_info = &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx1);
    p_cell_neigh_info = &SON_NEIGHBORLIST_INFO(cell_arr_idx1);
    p_req = &p_local_cell_neigh_info->oam_son_nr_add_req;
    p_son_nr_add = &SON_NEIGHBORLIST_INFO(cell_arr_idx1).oam_son_nr_add_req;
    /* Spr 15438 Fix Start */
    /* SPR 18930  FIX START */
    p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_meas_config_idx);
    p_son_nrt_info = &NRT_INFO(nliu_idx);
    /* SPR 18930  FIX END */
    /* Spr 15438 Fix End */
    idx = p_local_cell_neigh_info->nr_list_query_idx;

    /* SPR 18930  FIX START */
    OAM_LOG(OAM, OAM_INFO, "Cell context"
            "[cid=%d , rrm_cell_config_idx=%d, son_cell_nr_list_idx=%d"
            " cell_meas_config_idx =%d, nliu_idx =%d query_idx=%d]",
            cid, cell_arr_idx, cell_arr_idx1,cell_meas_config_idx,nliu_idx,idx);
    /* SPR 18930  FIX END */
    if(!usr_req) {
        OAM_LOG(OAM, OAM_DETAILED, "Init time OAM-triggered "
                "SON_OAM_NR_ADD_REQ to SON.");
        /* The request is init time neighbor add request */
        api_id = SON_OAM_NR_ADD_REQ;
    }
    else { 
        if(p_req->nr_list.intra_rat_nr_list_size) {
            cgi_found = oam_cgi_search_in_neigh_list(
                    &p_req->nr_list.intra_rat_nr_list[idx].nbr_cgi,
                    p_son_nr_add->nr_list.intra_rat_nr_list,
                    p_son_nr_add->nr_list.intra_rat_nr_list_size,
                    &p_cell_neigh_info->intra_rat_nr_entry_bitmap,
                    OAM_SON_NEIGH_TYPE_INTRA_RAT);

            is_neigh_idx_occupied = p_cell_neigh_info->
                intra_rat_nr_entry_bitmap & (OAM_ONE << idx);

            /* SPR 15238 START */
            /* SPR 18930  FIX START */
            if(LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[idx].earfcn == 
                    p_rrm_cell_config->ran_info.
                    /* SPR 18930  FIX END */
                    rf_params.rf_configurations.dl_earfcn)   
            {
                OAM_LOG(OAM,OAM_DETAILED,"IntraFreq Nbr Cell Addition recieved ");
                nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
            }
            else
            {
                OAM_LOG(OAM,OAM_DETAILED,"InterFreq Nbr Cell Addition recieved ");
                nbr_cell_type = OAM_INTER_FREQ_NBR_CELL;
            }

            if (OAM_FAILURE == oam_dynamic_nbr_cell_access_mode_pci_validation(
                        nbr_cell_type, 
                        /* SPR 18930  FIX START */
                        LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[idx].earfcn,
                        /* Spr 15438 Fix Start */
                        &LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[idx],
                        cell_arr_idx1))
                /* SPR 18930  FIX END */
                /* Spr 15438 Fix End*/
            {
                OAM_LOG(OAM,OAM_DETAILED," Neighbor Cell Access Mode Validation could not continue");
            }
            /* SPR 15238 END */

            if (NOT_FOUND != cgi_found) {
                if((cgi_found == idx) && is_neigh_idx_occupied) {
                    api_id = SON_OAM_NR_UPDATE_REQ;
                    OAM_LOG(OAM, OAM_INFO,
                            "User trigger for SON_OAM_NR_UPDATE_REQ received"
                            " for EUTRAN neighbor");
                }
                else {
                    *p_err_code = OAM_ERR_DATA_EXISTS;
                    err_string = "Neighbor exists at other instance";

                    OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);

                    retVal = OAM_FAILURE;
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }
            }
            else {
                if ((BITMAP_FULL ==
                            p_cell_neigh_info->intra_rat_nr_entry_bitmap) ||
                        is_neigh_idx_occupied) {
                    if (BITMAP_FULL ==
                            p_cell_neigh_info->intra_rat_nr_entry_bitmap) {
                        *p_err_code = OAM_RESOURCE_EXCCEED;
                        err_string = "Neighbor list is full";
                    }
                    else if(is_neigh_idx_occupied) {
                        *p_err_code = OAM_ERR_DATA_EXISTS;
                        err_string = "Neighbour already exists for the "
                            "requested neighbour instance.";
                    }

                    OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);

                    /* SPR 15387 Start */
                    oam_prov_req.system_status.event_ongoing &=
                        ~OAM_SON_ADD_NR_ONGOING;
                    /* SPR 15387 End */

                    retVal = OAM_FAILURE;
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }
                else {
                    api_id = SON_OAM_NR_ADD_REQ;
                    /* BUG_FIXED_12591_START */

                    freq_found =
                        oam_find_arfcn_in_available_freqs(
                                p_req->nr_list.intra_rat_nr_list[idx].earfcn,
                                OAM_ARFCN_EUTRAN, p_rrm_cell_config);

                    if(OAM_FREQ_NOT_AVAILABLE == freq_found) {
                        *p_err_code = OAM_INVALID_ARFCN_VALUE;
                        OAM_LOG(OAM, OAM_WARNING, "Neighbor frequency is not"
                                "in measured frequency list, rejecting"
                                " request");

                        retVal = OAM_FAILURE;
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }
                }
            }
        }
        else {
            /* SPR-13586 START */
            if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER == api_index)
            {
                /* RT SPR 8627 FIX START */
                cgi_found = oam_cgi_search_in_neigh_list(
                        &p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.
                        nbr_cgi,
                        p_son_nr_add->nr_list.inter_rat_nr_list,
                        /* SPR 18930  FIX START */
                        p_son_nr_add->nr_list.inter_rat_nr_list_size,
                        /* SPR 18930  FIX END */
                        &p_cell_neigh_info->inter_rat_umts_entry_bitmap,
                        OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);
                /* RT SPR 8627 FIX END */
                is_neigh_idx_occupied = p_cell_neigh_info->
                    inter_rat_umts_entry_bitmap & (OAM_ONE << idx);

                /* BUG_FIXED_12591_START */
                if (NOT_FOUND != cgi_found) {
                    if((cgi_found == idx) && is_neigh_idx_occupied) {
                        api_id = SON_OAM_NR_UPDATE_REQ;
                        OAM_LOG(OAM, OAM_INFO,
                                "User trigger for SON_OAM_NR_UPDATE_REQ received"
                                " for UTRAN neighbor");
                        /* SPR-13586 END */
                    }
                    else {
                        err_string = "Neighbor exists at other instance";
                        *p_err_code = OAM_ERR_DATA_EXISTS;

                        OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);
                        /* SPR 15387 Start */
                        oam_prov_req.system_status.event_ongoing &=
                            ~OAM_SON_ADD_NR_ONGOING;
                        /* SPR 15387 End */

                        retVal = OAM_FAILURE;
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }
                }
                else {
                    /* SPR-13586 START */
                    if((BITMAP_FULL ==
                                p_cell_neigh_info->inter_rat_umts_entry_bitmap) ||
                            is_neigh_idx_occupied) {

                        if(BITMAP_FULL == p_cell_neigh_info->inter_rat_umts_entry_bitmap) {
                            /* SPR-13586 END */
                            err_string = "No more space for adding new UARFCN.";
                            *p_err_code = OAM_RESOURCE_EXCCEED;
                            /*  Coverity ID :   81781 Fix Start */
                            OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);
                            /*  Coverity ID :   81781 Fix End */

                        }
                        else if(is_neigh_idx_occupied) {
                            err_string =
                                "UARFCN modification not allowed as it is a key element";
                            *p_err_code = OAM_ERR_DATA_EXISTS;
                            /*  Coverity ID :   81781 Fix Start */
                            OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);
                            /*  Coverity ID :   81781 Fix End */
                        }
                    }
                    else {
                        api_id = SON_OAM_NR_ADD_REQ;
                        OAM_LOG(OAM, OAM_INFO,
                                "SON_OAM_NR_ADD_REQ Received");
                        freq_found =
                            oam_find_arfcn_in_available_freqs(
                                    p_req->nr_list.inter_rat_nr_list[idx].
                                    utran_neighbor.uarfcn,
                                    OAM_ARFCN_UTRAN, p_rrm_cell_config);

                        if(OAM_FREQ_NOT_AVAILABLE == freq_found) {
                            *p_err_code = OAM_INVALID_ARFCN_VALUE;
                            OAM_LOG(OAM, OAM_WARNING, "Neighbor frequency is not"
                                    "in measured frequency list, rejecting"
                                    " request");

                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }
                    }
                }
                /* SPR-13586 START */
            }
            else if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN == api_index)
            {
                cgi_found = oam_cgi_search_in_neigh_list(
                        &p_req->nr_list.inter_rat_nr_list[idx].geran_neighbor.
                        nbr_cgi,
                        p_son_nr_add->nr_list.inter_rat_nr_list,
                        /* SPR 18930  FIX START */
                        p_son_nr_add->nr_list.inter_rat_nr_list_size,
                        /* SPR 18930  FIX END */
                        &p_cell_neigh_info->inter_rat_gsm_entry_bitmap,
                        OAM_SON_NEIGH_TYPE_INTER_RAT_GERAN);
                /* RT SPR 8627 FIX END */
                is_neigh_idx_occupied = p_cell_neigh_info->
                    inter_rat_gsm_entry_bitmap & (OAM_ONE << idx);

                /* BUG_FIXED_12591_START */
                if (NOT_FOUND != cgi_found) {
                    if((cgi_found == idx) && is_neigh_idx_occupied) {
                        api_id = SON_OAM_NR_UPDATE_REQ;
                        OAM_LOG(OAM, OAM_INFO,
                                "User trigger for SON_OAM_NR_UPDATE_REQ received"
                                " for GERAN neighbor");
                    }
                    else {
                        err_string = "Neighbor exists at other instance";
                        *p_err_code = OAM_ERR_DATA_EXISTS;

                        OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);

                        retVal = OAM_FAILURE;
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }
                }
                else {
                    if((BITMAP_FULL ==
                                p_cell_neigh_info->inter_rat_gsm_entry_bitmap) ||
                            is_neigh_idx_occupied) {

                        if(BITMAP_FULL == p_cell_neigh_info->inter_rat_gsm_entry_bitmap) {
                            err_string = "No more space for adding new UARFCN.";
                            *p_err_code = OAM_RESOURCE_EXCCEED;
                            /*  Coverity ID :   81781 Fix Start */
                            OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);
                            /*  Coverity ID :   81781 Fix End */
                        }
                        else if(is_neigh_idx_occupied) {
                            err_string =
                                "ARFCN modification not allowed as it is a key element";
                            *p_err_code = OAM_ERR_DATA_EXISTS;
                            /*  Coverity ID :   81781 Fix Start */
                            OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);
                            /*  Coverity ID :   81781 Fix End */
                        }
                    }
                    else {
                        api_id = SON_OAM_NR_ADD_REQ;
                        OAM_LOG(OAM, OAM_INFO,
                                "SON_OAM_NR_ADD_REQ Received");
                        freq_found =
                            oam_find_arfcn_in_available_freqs(
                                    p_req->nr_list.inter_rat_nr_list[idx].
                                    geran_neighbor.arfcn,
                                    OAM_ARFCN_GERAN, p_rrm_cell_config);

                        if(OAM_FREQ_NOT_AVAILABLE == freq_found) {
                            *p_err_code = OAM_INVALID_ARFCN_VALUE;
                            OAM_LOG(OAM, OAM_WARNING, "Neighbor frequency is not"
                                    "in measured frequency list, rejecting"
                                    " request");

                            /* SPR 15387 Start */
                            oam_prov_req.system_status.event_ongoing &=
                                ~OAM_SON_ADD_NR_ONGOING;
                            /* SPR 15387 End */

                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }
                    }

                }
            }
            /* SPR 18930  FIX START */
            /* Code Removed */
            /* SPR 18930  FIX END */
        }
        /* SPR-13586 END */

    }    

    if(OAM_ONE == p_req->nr_list.intra_rat_nr_list_size) {
        oam_memcpy(&(p_req->nr_list.intra_rat_nr_list[OAM_ZERO]),
                &(p_req->nr_list.intra_rat_nr_list[idx]),
                sizeof(son_intra_rat_neighbor_info_t));
    }

    /* SPR-13586 START */ 
    else if(OAM_ONE == p_req->nr_list.inter_rat_nr_list_size) {
        if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER == api_index){
            oam_memcpy(&(p_req->nr_list.inter_rat_nr_list[OAM_ZERO].utran_neighbor),
                    &(p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor),
                    sizeof(son_utran_neighbor_info_t));
            p_req->nr_list.inter_rat_nr_list[OAM_ZERO].bitmask = SON_INTER_UTRAN_NEIGHBOR; 
        }
        else if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN == api_index){
            oam_memcpy(&(p_req->nr_list.inter_rat_nr_list[OAM_ZERO].geran_neighbor),
                    &(p_req->nr_list.inter_rat_nr_list[idx].geran_neighbor),
                    sizeof(son_geran_neighbor_info_t));
            p_req->nr_list.inter_rat_nr_list[OAM_ZERO].bitmask = SON_INTER_GERAN_NEIGHBOR; 

        }   
        /* SPR-13586 END */
    }

    oam_son_nr_add_access_mode_handling(&p_req->nr_list); 

    if(SON_OAM_NR_ADD_REQ == api_id) {
        /* Start: SPR 10567 */
        if(p_req->nr_list.intra_rat_nr_list_size)
        {
            neigh_idx = oam_cgi_search_in_neigh_list(
                    &p_req->nr_list.intra_rat_nr_list[idx].nbr_cgi,
                    /* SPR 18930  FIX START */
                    p_son_nrt_info->nr_list.intra_rat_nr_list,
                    p_son_nrt_info->nr_list.intra_rat_nr_list_size,
                    &SON_PROV_REQ.neigh_list_in_use[nliu_idx].intra_rat_neigh_valid_bitmap,
                    /* SPR 18930  FIX END */
                    OAM_SON_NEIGH_TYPE_INTRA_RAT);
        }
        else
        {
            /* SPR-13586 START */ 
            if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER == api_index){ 
                neigh_idx = oam_cgi_search_in_neigh_list(&p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.
                        nbr_cgi,
                        /* SPR 18930  FIX START */
                        p_son_nrt_info->nr_list.inter_rat_nr_list,
                        p_son_nrt_info->nr_list.inter_rat_nr_list_size,
                        /* SPR 18930  FIX END */
                        &SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_umts_neigh_valid_bitmap,
                        OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);
            }
            else if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN == api_index){ 
                neigh_idx = oam_cgi_search_in_neigh_list(&p_req->nr_list.inter_rat_nr_list[idx].geran_neighbor.
                        nbr_cgi,
                        /* SPR 18930  FIX START */
                        p_son_nrt_info->nr_list.inter_rat_nr_list,
                        p_son_nrt_info->nr_list.inter_rat_nr_list_size,
                        /* SPR 18930  FIX END */
                        &SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_gsm_neigh_valid_bitmap,
                        OAM_SON_NEIGH_TYPE_INTER_RAT_GERAN);
            }
            /* SPR-13586 END */
        }
        if (neigh_idx == NOT_FOUND)
        {
            /* Spr 15438 Fix Start */
            if(p_req->nr_list.intra_rat_nr_list_size)
            {       
                /* SPR 18930  FIX START */
                if((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable == OAM_FALSE)
                        ||(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include == OAM_FALSE))
                    /* SPR 18930  FIX END */
                {

                    oam_memcpy(
                            &p_son_nr_add->nr_list.intra_rat_nr_list[idx],
                            &p_req->nr_list.intra_rat_nr_list[idx],
                            sizeof(son_intra_rat_neighbor_info_t));

                    oam_memcpy(
                            /* SPR 18930  FIX START */
                            &p_cell_neigh_info->eutran_nbr_ctxt[idx],
                            &p_local_cell_neigh_info->eutran_nbr_ctxt[idx],
                            sizeof(oam_son_nbr_ctxt_t));

                    p_cell_neigh_info->intra_rat_nr_entry_bitmap |=
                        (nr_bit << idx);

                    *is_dom_update_reqd = OAM_TRUE; 

                    /*SPR_16951_START*/
                    /*Code Removed*/
                    /*SPR_16951_END*/
                    /* SPR 17678 changes start */
                    /* SPR 17678 changes end */
                    /* SPR 18930  FIX END */

                    OAM_LOG(OAM, OAM_DETAILED, "Neighbour Successfully Aded to NR List"
                            " No Need to send to SON for Addition as either Enable or MustInclude Is False");

                    UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);

                    trans_id = get_word_from_header(p_api_buf);

                    /* Resetting The Bitmask As neighbour added to NR List */
                    oam_prov_req.system_status.event_ongoing &= 
                        ~OAM_SON_ADD_NR_ONGOING;

                    OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL,
                            OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dst_id,
                            trans_id,
                            OAM_ZERO, OAM_ZERO,
                            p_err_code);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_SUCCESS;

                }
                /* SPR 14651 START */   
                else {

                    arfcn_found =
                        oam_arfcn_search_in_meas_config_list(
                                &p_req->nr_list.intra_rat_nr_list[idx].earfcn,
                                p_anr_meas_config_req->eutran_config_list,
                                p_anr_meas_config_req->eutran_config_list_size,
                                &SON_PROV_REQ.oam_son_inter_freq_carrier_params[idx].
                                eutran_meas_entry_bitmap,
                                OAM_SON_MEAS_CONFIG_TYPE_EUTRAN);

                    if((NOT_FOUND == arfcn_found)&&
                            (SON_NR_LOCKED == p_req->nr_list.
                             intra_rat_nr_list[idx].nr_status))

                    {
                        /* SPR 15847 START */
                        if (p_req->nr_list.intra_rat_nr_list[idx].earfcn !=
                                p_rrm_cell_config->ran_info.
                                rf_params.rf_configurations.dl_earfcn)
                        {
                            /* SPR 15847 END */
                            UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);
                            OAM_LOG(OAM,OAM_WARNING,"Error in  adding nbr as"
                                    " Earfcn not configured and nr status is locked");

                            /*coverity 109021 fix start */
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ERR_REQUEST_DENIED,
                                    (UInt8*)"Neighbour can not be added as Earfcn not configured and nr status is locked",
                                    oam_strlen("Neighbour can not be added as Earfcn not configured and nr status is locked") + OAM_ONE,
                                    OAM_VERSION_ID,
                                    OAM_MODULE_ID, dst_id,
                                    trans_id, OAM_ZERO,
                                    OAM_ZERO, &p_error_code);
                            /*coverity 109021 fix end */

                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE; 
                            /* SPR 15847 START */
                        }
                        /* SPR 15847 END */

                    }
                    /* SPR 17408 Fix Start */
                    if((p_req->nr_list.intra_rat_nr_list[idx].bitmask & SON_ACCESS_MODE_PRESENT) &&
                            ((p_req->nr_list.intra_rat_nr_list[idx].access_mode == SON_OPEN) ||
                             (p_req->nr_list.intra_rat_nr_list[idx].access_mode == SON_OPEN_FEMTO)) &&
                            (p_req->nr_list.intra_rat_nr_list[idx].bitmask & SON_INTRA_CSG_ID_PRESENT))  
                    {
                        UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);
                        OAM_LOG(OAM,OAM_WARNING,"Error in adding nbr as"
                                " CSG ID is present and Access Mode is Open/Open Femto");

                        oam_strncpy(cmd_status,
                                "Neighbour can not be added as CSG ID is present and Access Mode is Open/Open Femto."
                                "Either change access mode to Closed/Hybrid or Do not configure CSD ID",
                                sizeof(cmd_status));

                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_INVALID_PARAM_VALUE,
                                (UInt8*)cmd_status,
                                oam_strlen(cmd_status) + OAM_ONE,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID, dst_id,
                                trans_id, OAM_ZERO,
                                OAM_ZERO, &p_error_code);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE; 
                    }
                    if(!(p_req->nr_list.intra_rat_nr_list[idx].bitmask & SON_ACCESS_MODE_PRESENT) &&
                            (p_req->nr_list.intra_rat_nr_list[idx].bitmask & SON_INTRA_CSG_ID_PRESENT))  
                    {
                        UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);
                        OAM_LOG(OAM,OAM_WARNING,"Error in adding nbr as"
                                " CSG ID is present and Access Mode is not present");

                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_INVALID_PARAM_VALUE,
                                (UInt8*)"Access Mode(Closed/Hybrid) is mandatory if CSG ID is present",
                                oam_strlen("Access Mode(Closed/Hybrid) is mandatory if CSG ID is present") + OAM_ONE,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID, dst_id,
                                trans_id, OAM_ZERO,
                                OAM_ZERO, &p_error_code);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE; 
                    }
                    /* SPR 17408 Fix End */

                }
                /* SPR 14651 END */   
            }
            /* Spr 15612  Fix Start*/
            else if((p_req->nr_list.inter_rat_nr_list[idx].bitmask) & SON_INTER_UTRAN_NEIGHBOR)
            {

                /*SPR_18437_START*/
                if((SON_UTRAN_PCI_PRESENT &
                            p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.bitmask) &&
                        (OAM_ZERO == p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.pci.bitmask))
                {

                    UInt16 dst_id = OAM_ZERO;
                    OAM_LOG(OAM,OAM_DETAILED,"Utran PCI bitmask not set for FDD/TDD");
                    oam_freq_type_et freq_found = oam_find_arfcn_in_available_freqs(
                            p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.uarfcn,
                            OAM_ARFCN_UTRAN,p_rrm_cell_config);
                    if(OAM_UTRAN_FREQ_FDD == freq_found) {
                        p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.pci.
                            bitmask = SON_PCI_FDD_PRESENT;
                        p_req->nr_list.inter_rat_nr_list[OAM_ZERO].utran_neighbor.pci.
                            bitmask = SON_PCI_FDD_PRESENT;
                    }
                    else if (OAM_UTRAN_FREQ_TDD == freq_found){
                        p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.pci.
                            bitmask = SON_PCI_TDD_PRESENT;
                        p_req->nr_list.inter_rat_nr_list[OAM_ZERO].utran_neighbor.pci.
                            bitmask = SON_PCI_TDD_PRESENT;
                    }      
                    else
                    {
                        OAM_LOG(OAM, OAM_ERROR, "UARFCN for requested"
                                " neighbor is not available");
                        p_error_code = 
                            OAM_INVALID_UARFCN_VALUE; 

                        dst_id = get_word_from_header(p_api_buf + OAM_TWO);
                        OAM_LOG(OAM,OAM_ERROR,"Error in  adding nbr as"
                                " uarfcn is not configured ");

                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_REQUEST_DENIED,
                                (UInt8*)"Neighbour can not be added as uarfcn not configured ",
                                strlen("Neighbour can not be added as uarfcn not configured ") + OAM_ONE,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID, dst_id,
                                trans_id, OAM_ZERO,
                                OAM_ZERO, &p_error_code);

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }      
                }
                /* SPR 17408 Fix Start */
                /* CID 118464 Fix Start */
                if((p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.bitmask & SON_UTRAN_ACCESS_MODE_PRESENT) &&
                        ((p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.access_mode == SON_OPEN) ||
                         (p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.access_mode == SON_OPEN_FEMTO)) &&
                        (p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.bitmask & SON_UTRAN_CSG_ID_PRESENT))  
                {
                    UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);
                    OAM_LOG(OAM,OAM_WARNING,"Error in adding nbr as"
                            " CSG ID is present and Access Mode is Open/Open Femto");

                    oam_strncpy(cmd_status,
                            "Neighbour can not be added as CSG ID is present and Access Mode is Open/Open Femto."
                            "Either change access mode to Closed/Hybrid or Do not configure CSD ID",
                            sizeof(cmd_status));

                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INVALID_PARAM_VALUE,
                            (UInt8*)cmd_status,
                            oam_strlen(cmd_status) + OAM_ONE,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID, dst_id,
                            trans_id, OAM_ZERO,
                            OAM_ZERO, &p_error_code);

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE; 
                }
                if(!(p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.bitmask & SON_UTRAN_ACCESS_MODE_PRESENT) &&
                        (p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor.bitmask & SON_UTRAN_CSG_ID_PRESENT))  
                {
                    UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);
                    OAM_LOG(OAM,OAM_WARNING,"Error in adding nbr as"
                            " CSG ID is present and Access Mode is not present");

                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INVALID_PARAM_VALUE,
                            (UInt8*)"Access Mode(Closed/Hybrid) is mandatory if CSG ID is present",
                            oam_strlen("Access Mode(Closed/Hybrid) is mandatory if CSG ID is present") + OAM_ONE,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID, dst_id,
                            trans_id, OAM_ZERO,
                            OAM_ZERO, &p_error_code);

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE; 
                }
                /* CID 118464 Fix End */
                /* SPR 17408 Fix End */

                /*SPR_18437_END*/   

                /* SPR 18930  FIX START */
                if((p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable == OAM_FALSE)
                        ||(p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include == OAM_FALSE))
                {

                    oam_memcpy(
                            &p_son_nr_add->nr_list.inter_rat_nr_list[idx].utran_neighbor,
                            &p_req->nr_list.inter_rat_nr_list[idx].utran_neighbor,
                            sizeof(son_utran_neighbor_info_t));

                    oam_memcpy(
                            &p_cell_neigh_info->utran_nbr_ctxt[idx],
                            &p_local_cell_neigh_info->utran_nbr_ctxt[idx],
                            sizeof(oam_son_nbr_ctxt_t));


                    p_cell_neigh_info->inter_rat_umts_entry_bitmap |=
                        (nr_bit << idx);
                    /*SPR_16951_START*/
                    /*Code Removed*/
                    /*SPR_16951_END*/
                    p_son_nr_add->nr_list.inter_rat_nr_list[idx].bitmask |= SON_INTER_UTRAN_NEIGHBOR;

                    p_son_nr_add->nr_list.inter_rat_nr_list_size++; 
                    *is_dom_update_reqd = OAM_TRUE; 
                    /* SPR 18930  FIX END */

                    OAM_LOG(OAM, OAM_DETAILED, "UTRAN Neighbour Successfully Aded to NR List"
                            " No Need to send to SON for Addition as either Enable or MustInclude Is False");

                    UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);

                    trans_id = get_word_from_header(p_api_buf);

                    /* Resetting The Bitmask As neighbour added to NR List */
                    oam_prov_req.system_status.event_ongoing &= 
                        ~OAM_SON_ADD_NR_ONGOING;

                    OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL,
                            OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dst_id,
                            trans_id,
                            OAM_ZERO, OAM_ZERO,
                            p_err_code)
                        ;
                    OAM_FUN_EXIT_TRACE();
                    return OAM_SUCCESS;

                }

            } 
            /* Spr 15612  Fix End*/
            OAM_LOG(OAM, OAM_DETAILED,
                    "Sending SON_OAM_NR_ADD_REQ To SON ");
            /* Send Nr Add Req To SON for Addition in NLIU */  
            /* Spr 15438 Fix End */
            retVal = oam_son_send_son_oam_nr_add_req(p_req, OAM_MODULE_ID,
                    SON_MODULE_ID, trans_id,
                    oam_prov_req.cell_cntxt.curr_cell_cid);
            /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
            if(OAM_SUCCESS == retVal)
            {
                /* SPR 18930  FIX START */
                oam_save_nr_add_req_with_trans_id(p_req,trans_id,cell_arr_idx);
                /* SPR 18930  FIX END */
                /* SPR-13586 START */
                if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER == api_index){ 
                    oam_prov_req.system_status.event_ongoing |= OAM_SON_ADD_NR_UMTS_ONGOING;
                }
                else if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN == api_index){ 
                    oam_prov_req.system_status.event_ongoing |= OAM_SON_ADD_NR_GSM_ONGOING;
                }
                /* SPR-13586 END */
                UInt16 msg_len = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);    
                if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                            OAM_TRANS_SON,msg_len,p_api_buf))
                {
                    OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                    *p_err_code = OAM_INTERNAL_ERROR;
                    retVal = OAM_FAILURE;
                }
            }
            else {
                *p_err_code = OAM_SEND_FAIL;
            }
#endif
            /* SPR 9620 CHANGE END */
        }
        else {

            /* SPR 18930  FIX START */
            /* SPR 16340 FIX START */
            /* nbr Deltetion Required From SON NRT Enable = True , MI = FALSE*/
            if(((LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list_size)&&
                        ((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable == OAM_TRUE)&&
                         (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include == OAM_FALSE)))||
                    ((LOCAL_SON_NR_LIST(cell_arr_idx1).inter_rat_nr_list[idx].bitmask & SON_INTER_UTRAN_NEIGHBOR)&&
                     ((p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable  == OAM_TRUE)&& 
                      (p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include == OAM_FALSE))))
            {     
                *is_dom_update_reqd = OAM_TRUE; 
                OAM_LOG(OAM, OAM_DETAILED, "Adding Neigbour To NL."
                        " Sending NR Delete req As Enable = True MI = False");
                return oam_add_nbr_to_nl_and_send_delete_req_to_son(p_api_buf,cell_arr_idx1);
            }     
            else  
            {     
                /* SPR 16340 FIX END */
                /* SPR 15266 Fix Start */
                if (OAM_TRUE == oam_add_neighbour_to_NL_n_check_if_update_req_at_son_nrt(neigh_idx,cell_arr_idx1))
                    /* SPR 18930  FIX END */
                {
                    /* SPR 15266 Fix End */
                    if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER == api_index){ 
                        oam_prov_req.system_status.event_ongoing |= OAM_SON_UPD_NR_UMTS_ONGOING;
                    }
                    else if(SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN == api_index){ 
                        oam_prov_req.system_status.event_ongoing |= OAM_SON_UPD_NR_GSM_ONGOING;
                    }
                    /* SPR 15266 Fix Start */
                    OAM_LOG(OAM, OAM_DETAILED, "Neighbour Successfully Aded to NR List"
                            " Sending NR Update req for changed values");
                    /* SPR 18930  FIX START */
                    retVal = oam_son_send_son_oam_nr_update_req
                        ((son_oam_nr_update_req_t *)p_req,
                         OAM_MODULE_ID,
                         SON_MODULE_ID,
                         trans_id,
                         oam_prov_req.cell_cntxt.curr_cell_cid);

                    if(retVal == OAM_FAILURE)
                    {
                        *p_err_code = OAM_SEND_FAIL;
                    }
                    /* SPR 15266 Fix End */

                }    
                else{

                    *is_dom_update_reqd = OAM_TRUE; 
                    OAM_LOG(OAM, OAM_DETAILED, "Neighbour Successfully Aded to NR List"
                            " No Need to send to SON for Updation as Values are identical");
                    /* Spr 15438 Fix Start */
                    /* Only Update In NR List No Need to Send NR Update To SON */
                    if(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask
                            & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)
                    {
                        p_cell_neigh_info->eutran_nbr_ctxt[idx].enable = 
                            p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable;
                    }
                    if(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask
                            & OAM_SON_NEIGHBOUR_MI_PRESENT)
                    {
                        p_cell_neigh_info->eutran_nbr_ctxt[idx].must_include = 
                            p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include;
                    }
                    if(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask
                            & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)
                    {
                        p_cell_neigh_info->utran_nbr_ctxt[idx].enable = 
                            p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable;
                    }
                    if(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask
                            & OAM_SON_NEIGHBOUR_MI_PRESENT)
                    {
                        p_cell_neigh_info->utran_nbr_ctxt[idx].must_include = 
                            p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include;
                    }

                    /* Spr 15438 Fix End */
                    UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);

                    trans_id = get_word_from_header(p_api_buf);

                    OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL,
                            OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dst_id,
                            trans_id,
                            OAM_ZERO, OAM_ZERO,
                            p_err_code)
                        ;
                    /* Spr 15438 Fix Start */
                    /* Resetting The Bitmask As neighbour added to NR List */
                    oam_prov_req.system_status.event_ongoing &=
                        ~OAM_SON_ADD_NR_ONGOING;

                    /* Spr 15438 Fix End */
                    retVal = OAM_SUCCESS;
                }
            }
            /*End: SPR 10567 */
        }
    }
    /* SPR 18930  FIX END */

    /* SPR 17648 changes start */

    else
    {
        if(LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list_size)
        {
            neigh_idx = oam_cgi_search_in_neigh_list(
                    &LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[idx].nbr_cgi,
                    /* SPR 18930  FIX START */
                    p_son_nrt_info->nr_list.intra_rat_nr_list,
                    p_son_nrt_info->nr_list.intra_rat_nr_list_size,
                    &SON_PROV_REQ.neigh_list_in_use[nliu_idx].intra_rat_neigh_valid_bitmap,
                    OAM_SON_NEIGH_TYPE_INTRA_RAT);

            if((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)||
                    (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT))
            {
                if(neigh_idx != NOT_FOUND)
                {
                    if((((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT)&&
                                    (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include == OAM_FALSE))&&
                                ((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)&&
                                 (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable == OAM_TRUE)))||
                            (((!(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT))&&
                              (p_cell_neigh_info->eutran_nbr_ctxt[idx].must_include == OAM_FALSE))&&
                             ((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)&&
                              (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable == OAM_TRUE)))||
                            (((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT)&&
                              (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include == OAM_FALSE))&&
                             ((!(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT))&&
                              (p_cell_neigh_info->eutran_nbr_ctxt[idx].enable == OAM_TRUE))))
                        /* SPR 18930  FIX END */

                    {
                        /* Neighbour found in NLIU and Enable is true and MustInclude is false */
                        OAM_LOG(OAM, OAM_DETAILED,
                                "Sending NR Delete Req as Enable is True and MustInclude Is False");

                        local_prov_req.oam_son_req.nr_action = OAM_NR_NO_ACTION;
                        oam_son_nr_delete_req_t *oam_son_nr_delete_req = OAM_NULL;

                        if(OAM_FAILURE ==
                                oam_mem_alloc(sizeof(oam_son_nr_delete_req_t),
                                    (void**)&oam_son_nr_delete_req,
                                    &p_error_code))
                        {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Memory allocation to oam_son_nr_delete_req failed"
                                    " with Error Code:%d",
                                    p_error_code);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }

                        oam_memset(oam_son_nr_delete_req, OAM_ZERO,
                                sizeof(oam_son_nr_delete_req_t));

                        oam_son_nr_delete_req->src_cgi = LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).oam_son_nr_add_req.src_cgi;
                        oam_son_nr_delete_req->trgt_cgi_list_size = OAM_ONE;

                        TRGT_CGI_LIST.bitmask = OAM_SON_BIT_1;
                        TRGT_CGI_LIST.intra_rat_global_cell_id =
                            LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
                            nbr_cgi;


                        retVal =
                            oam_validate_send_son_nr_delete_req(p_api_buf,
                                    oam_son_nr_delete_req,
                                    OAM_MODULE_ID,
                                    trans_id,
                                    cid,
                                    &p_error_code);

                        /* Resetting The Bitmask As Sending NR Delete To SON */
                        oam_prov_req.system_status.event_ongoing &=
                            ~OAM_SON_ADD_NR_ONGOING;

                        SON_PROV_REQ.nr_action &= ~OAM_NR_ACTION_DELETE_EUTRAN;

                        if(OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Error in sending neighbor delete request"
                                    " with error code :%d", p_error_code);
                            /* Coverity CID 85228 Fix Start */
                            oam_mem_free(oam_son_nr_delete_req,&p_error_code);
                            /* Coverity CID 85228 Fix End */
                            return OAM_FAILURE;
                        }
                        else {
                            /* SPR 18930  FIX START */

                            SON_PROV_REQ.nr_action |= OAM_NLIU_ACTION_DELETE_EUTRAN;

                            /* Coverity CID 85228 Fix Start */
                            oam_mem_free(oam_son_nr_delete_req,&p_error_code);
                            /* Coverity CID 85228 Fix End */
                            return OAM_SUCCESS;
                        }

                    }
                    else
                    {
                        /* Neighbour found in NLIU and MustInclude is not false and Enable true/false  */
                        if(OAM_FALSE == oam_check_if_update_req_at_son_nrt(neigh_idx,cell_arr_idx1,nliu_idx))
                        {
                            OAM_LOG(OAM, OAM_DETAILED,
                                    "Updating NR List Only, Not Sending Update To SON"
                                    " as Values are identical");
                            *is_dom_update_reqd = OAM_TRUE; 

                            /* Only Update In NR List No Need to Send NR Update To SON */
                            if(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask
                                    & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)
                            {
                                p_cell_neigh_info->eutran_nbr_ctxt[idx].enable =
                                    p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable;
                            }
                            if(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask
                                    & OAM_SON_NEIGHBOUR_MI_PRESENT)
                            {
                                p_cell_neigh_info->eutran_nbr_ctxt[idx].must_include =
                                    p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include;
                            }
                            /* SPR 18930  FIX END */
                            UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);

                            trans_id = get_word_from_header(p_api_buf);

                            OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                    OAM_ZERO, OAM_NULL,
                                    OAM_ZERO,
                                    OAM_VERSION_ID,
                                    OAM_MODULE_ID,
                                    dst_id,
                                    trans_id,
                                    OAM_ZERO, OAM_ZERO,
                                    p_err_code);

                            /* Resetting The Bitmask As neighbour added to NR List */
                            oam_prov_req.system_status.event_ongoing &=
                                ~OAM_SON_ADD_NR_ONGOING;

                            return OAM_SUCCESS;

                        }

                    }

                }
                else
                {
                    /* SPR 18930  FIX START */
                    if((((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT) &&
                                    (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable == OAM_TRUE))&&
                                (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT) &&
                                (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include == OAM_TRUE)) ||
                            ((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT) &&
                             (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include == OAM_TRUE)&&
                             (!(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)) &&
                             (p_cell_neigh_info->eutran_nbr_ctxt[idx].enable == OAM_TRUE)) ||
                            ((p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT) &&
                             (p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable == OAM_TRUE)&&
                             (!(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT)) &&
                             (p_cell_neigh_info->eutran_nbr_ctxt[idx].must_include == OAM_TRUE)))
                    {
                        /* Neighbour not found in NLIU and enable and MustInclude are true */
                        /* Sending NR ADD Req to SON */
                        OAM_LOG(OAM, OAM_DETAILED,
                                "Sending NR ADD Req To SON as Enable and MustInclude made True");

                        /* SPR 14651 START */
                        if (LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[idx].earfcn !=
                                oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_arr_idx].ran_info.
                                rf_params.rf_configurations.dl_earfcn)
                        {
                            arfcn_found =
                                oam_arfcn_search_in_meas_config_list(
                                        &LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[idx].earfcn,
                                        p_anr_meas_config_req->eutran_config_list,
                                        p_anr_meas_config_req->eutran_config_list_size,
                                        /* SPR 18930  FIX END */
                                        &SON_PROV_REQ.oam_son_inter_freq_carrier_params[idx].
                                        eutran_meas_entry_bitmap,
                                        OAM_SON_MEAS_CONFIG_TYPE_EUTRAN);
                        }
                        else
                            arfcn_found = OAM_TRUE;


                        if((NOT_FOUND == arfcn_found)&&
                                (SON_NR_LOCKED == LOCAL_SON_NR_LIST(cell_arr_idx1).
                                 intra_rat_nr_list[idx].nr_status))

                        {
                            UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);
                            OAM_LOG(OAM,OAM_WARNING,"Error in  adding nbr as"
                                    " Earfcn not configured and nr status is locked");

                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ERR_REQUEST_DENIED,
                                    (UInt8*)"Neighbour can not be added as Earfcn not configured and nr status is locked",
                                    oam_strlen("Neighbour can not be added as Earfcn not configured and nr status is locked") + OAM_ONE,
                                    OAM_VERSION_ID,
                                    OAM_MODULE_ID, dst_id,
                                    trans_id, OAM_ZERO,
                                    OAM_ZERO, &p_error_code);

                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;

                        }

                        /* SPR 14651 END */
                        retVal = oam_son_send_son_oam_nr_add_req(p_req, OAM_MODULE_ID,
                                SON_MODULE_ID, trans_id,
                                oam_prov_req.cell_cntxt.curr_cell_cid);
                        /* SPR 18930  FIX START */
                        if(retVal == OAM_SUCCESS)
                        {
                            oam_save_nr_add_req_with_trans_id(p_req,trans_id,cell_arr_idx);
                        }

                        /*  coverity 83451 fix start */
                        return retVal;
                        /*  coverity 83451 fix end */
                    }   
                    else
                    {
                        /* Neighbour not found in NLIU and Either Enable or MustInclude Still False */
                        OAM_LOG(OAM, OAM_DETAILED,
                                "Updating NR List Only Not Sending Add To SON"
                                " as Either Enable or MustInclude Still False");
                        *is_dom_update_reqd = OAM_TRUE; 

                        /* Only Update In NR List No Need to Send NR Add To SON */
                        oam_memcpy(&SON_NEIGHBORLIST_INFO(cell_arr_idx1).oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx],
                                &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx],
                                sizeof(son_intra_rat_neighbor_info_t));

                        if(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask 
                                & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)    
                        {     
                            p_cell_neigh_info->eutran_nbr_ctxt[idx].enable =
                                p_local_cell_neigh_info->eutran_nbr_ctxt[idx].enable;
                        }     
                        if(p_local_cell_neigh_info->eutran_nbr_ctxt[idx].bitmask 
                                & OAM_SON_NEIGHBOUR_MI_PRESENT)    
                        {     
                            p_cell_neigh_info->eutran_nbr_ctxt[idx].must_include =
                                p_local_cell_neigh_info->eutran_nbr_ctxt[idx].must_include;
                        } 
                        /* SPR 18930  FIX END */

                        UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);

                        trans_id = get_word_from_header(p_api_buf);

                        /* Resetting The Bitmask As neighbour added to NR List */
                        oam_prov_req.system_status.event_ongoing &=
                            ~OAM_SON_ADD_NR_ONGOING;

                        OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                OAM_ZERO, OAM_NULL,
                                OAM_ZERO,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                dst_id,
                                trans_id,
                                OAM_ZERO, OAM_ZERO,
                                p_err_code)
                            ;
                        return OAM_SUCCESS;

                    }

                }
            }
            else
            {
                if(neigh_idx == NOT_FOUND)
                {
                    /* SPR 18930  FIX START */
                    *is_dom_update_reqd = OAM_TRUE; 
                    /* SPR 18930  FIX END */
                    /* Neighbour not found in NLIU and No change in Enable and MI*/
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Updating NR List Only, Not Sending Add To SON"
                            /* Spr 15612 Fix Start */
                            " as Enable or MustInclude Still False");
                    /* Spr 15612 Fix End */

                    /* Only Update In NR List No Need to Send NR Add To SON */
                    oam_memcpy(&SON_NEIGHBORLIST_INFO(cell_arr_idx1).oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx],
                            &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx],
                            sizeof(son_intra_rat_neighbor_info_t));

                    UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);

                    trans_id = get_word_from_header(p_api_buf);

                    /* Resetting The Bitmask As neighbour added to NR List */
                    oam_prov_req.system_status.event_ongoing &=
                        ~OAM_SON_ADD_NR_ONGOING;

                    OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL,
                            OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dst_id,
                            trans_id,
                            OAM_ZERO, OAM_ZERO,
                            p_err_code)
                        ;
                    return OAM_SUCCESS;
                }

            }
        }
        /* Spr 15438 Fix End */
        /* Spr 15612  Fix Start*/
        else if((LOCAL_SON_NR_LIST(cell_arr_idx1).inter_rat_nr_list[idx].bitmask) & SON_INTER_UTRAN_NEIGHBOR)
        {

            /* SPR 18930  FIX START */
            return oam_validate_and_send_utran_update_req(p_api_buf,(son_oam_nr_update_req_t *)p_req, cid,is_dom_update_reqd);
            /* SPR 18930  FIX END */

        }
        /* Spr 15612  Fix End*/
        /* SPR 14651 START */
        if(LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list_size)
        {

            if (LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[idx].earfcn !=
                    oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_arr_idx].ran_info.
                    rf_params.rf_configurations.dl_earfcn)
            {
                arfcn_found =
                    oam_arfcn_search_in_meas_config_list(
                            /* SPR 18930  FIX START */
                            &p_req->nr_list.intra_rat_nr_list[idx].earfcn,
                            p_anr_meas_config_req->eutran_config_list,
                            p_anr_meas_config_req->eutran_config_list_size,
                            &SON_INTER_FREQ_CARR_PARAMS(cell_meas_config_idx).
                            /* SPR 18930  FIX END */
                            eutran_meas_entry_bitmap,
                            OAM_SON_MEAS_CONFIG_TYPE_EUTRAN); 
            }
            else
                arfcn_found = OAM_TRUE;

            if((NOT_FOUND == arfcn_found)&&
                    (SON_NR_LOCKED == LOCAL_SON_NR_LIST(cell_arr_idx1).
                     intra_rat_nr_list[idx].nr_status))

            {
                UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);
                OAM_LOG(OAM,OAM_WARNING,"Error in  adding nbr as"
                        " Earfcn not configured and nr status is locked");

                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_REQUEST_DENIED,
                        (UInt8*)"Neighbour can not be added as Earfcn not configured and nr status is locked",
                        oam_strlen("Neighbour can not be added as Earfcn not configured and nr status is locked") + OAM_ONE,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID, dst_id,
                        trans_id, OAM_ZERO,
                        OAM_ZERO, &p_error_code);

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;

            }
        }
        /* SPR 14651 END */
        OAM_LOG(OAM, OAM_DETAILED,"Sending NR UPDATE To SON ");
        retVal = oam_son_send_son_oam_nr_update_req
            ((son_oam_nr_update_req_t *)p_req,
             OAM_MODULE_ID,
             SON_MODULE_ID,
             trans_id,
             oam_prov_req.cell_cntxt.curr_cell_cid);
    }


    /* code removed */
    /* SPR 17648 changes end */

    OAM_FUN_EXIT_TRACE();
    return retVal;
}



/****************************************************************************
 * Function Name : oam_validate_send_anr_meas_config_req
 * Description   : This function first validates the user request for meas
 *                 configuration then it sends the request to SON layer
 * Inputs        : 1. pointer to user Request buffer
 *                 2. transaction ID
 *                 
 * Outputs       : p_error_code : Error Code
 * Returns       : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
/* SPR 17777 fix */
	oam_return_et
oam_validate_send_anr_meas_config_req(
 /* SPR 14651 START */
        UInt8     *p_api_buf,
		UInt16 transaction_id,
		UInt8 cell_config_idx,
		oam_bool_et *p_is_dom_update_reqd,
/* SPR 14651 END */
		oam_error_code_et *p_error_code)
{
	OAM_FUN_ENTRY_TRACE();
	SInt16 arfcn_found = NOT_FOUND; 
	oam_return_et retVal = OAM_FAILURE;
	Char8 *err_string = OAM_NULL;
    /*SPR_16927_START*/ 
	UInt32 is_meas_idx_occupied = OAM_ZERO;
    /*SPR_16927_END*/
	UInt8 invalid_req = OAM_ZERO;
	/* RT SPR 8154 FIX START */
	oam_son_anr_meas_config_req_t *p_req = OAM_NULL;
	/* RT SPR 8154 FIX END */

	UInt8 curr_cell_id = oam_prov_req.cell_cntxt.curr_cell_cid;
	oam_son_anr_meas_config_req_t *p_local_anr_meas_config_req = OAM_NULL;
	oam_son_anr_meas_config_req_t *p_anr_meas_config_req = OAM_NULL;
	oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params = OAM_NULL;

 /* SPR 14651 START */
    rrm_oam_inter_frequency_params_list_t *p_rrm_cell_config_inter_freq_param = OAM_NULL; 
    oam_son_anr_meas_config_obj_remove_req_t *p_delete_req = OAM_NULL;

    SInt8 cell_config_idx_rrm = oam_get_rrm_cell_config_idx(curr_cell_id);
    UInt8 index = OAM_ZERO;
    UInt8 added_in_meas_record = OAM_ZERO;
	UInt32 meas_bit = 1;
    UInt8 meas_enable = OAM_FALSE; 
    UInt16 dest_id = get_word_from_header(p_api_buf + 2);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx_rrm)
    {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d], rrm_cell_config_idx=[%d]",
                curr_cell_id ,cell_config_idx_rrm);
        return OAM_FAILURE;
    }
/* SPR 14651 END */

	UInt8 idx = LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).query_index;

	p_son_inter_freq_carr_params = &SON_INTER_FREQ_CARR_PARAMS(cell_config_idx);


	p_local_anr_meas_config_req = 
		&LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_config_idx);
	p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_config_idx);

	if(OAM_NULL == p_error_code) {
		OAM_LOG(OAM, OAM_WARNING, "Null pointer passed.");
		/*Coverity Fix 66591, Line Deleted*/
		OAM_FUN_ENTRY_TRACE();
		return retVal;
	}

	/* RT SPR 8154 FIX START */
	retVal = oam_mem_alloc(sizeof(oam_son_anr_meas_config_req_t),
			(void**)&p_req, p_error_code);

	if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_req failed"
                " with Error Code:%d",
                *p_error_code);
		*p_error_code = OAM_MALLOC_FAIL;

		OAM_FUN_ENTRY_TRACE();
		return retVal;
	}

	oam_memset(p_req, 0, sizeof(oam_son_anr_meas_config_req_t));
	/* RT SPR 8154 FIX END */
 /* SPR 14651 START */
    retVal = oam_mem_alloc(
            sizeof(oam_son_anr_meas_config_obj_remove_req_t),
            (void**)&p_delete_req, p_error_code);

    if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_delete_req failed"
                " with Error Code:%d",
                *p_error_code);

	    oam_mem_free(p_req, p_error_code);
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }

    oam_memset(p_delete_req, OAM_ZERO,
            sizeof(oam_son_anr_meas_config_obj_remove_req_t));
/* SPR 14651 END */

	if (p_local_anr_meas_config_req->eutran_config_list_size) {
		arfcn_found =
			oam_arfcn_search_in_meas_config_list(
					/* RT SPR 8154 FIX START */
					&p_local_anr_meas_config_req->eutran_config_list[idx].earfcn,
					/* RT SPR 8154 FIX END */
					p_anr_meas_config_req->eutran_config_list,
					p_anr_meas_config_req->eutran_config_list_size,
					&p_son_inter_freq_carr_params->eutran_meas_entry_bitmap,
					OAM_SON_MEAS_CONFIG_TYPE_EUTRAN);

		is_meas_idx_occupied = 
			(p_son_inter_freq_carr_params->eutran_meas_entry_bitmap & (1 << idx));

		if (NOT_FOUND != arfcn_found) {
			if((arfcn_found == idx) && is_meas_idx_occupied) {
				OAM_LOG(OAM, OAM_INFO,
						"MEAS Config For EUTRAN Updation Received"); 
			}
			else {
				*p_error_code = OAM_ERR_DATA_EXISTS;
				err_string = "Neighbor exists at other instance";
				invalid_req = 1; 
			}
		}
		else {
			if((BITMAP_FULL == p_son_inter_freq_carr_params->
						eutran_meas_entry_bitmap) || is_meas_idx_occupied) {
				if(BITMAP_FULL == p_son_inter_freq_carr_params->
						eutran_meas_entry_bitmap) {
					*p_error_code = OAM_RESOURCE_EXCCEED;
					err_string = "No more space for adding new EARFCN.";
				}
				else if(is_meas_idx_occupied) {
					*p_error_code = OAM_ERR_DATA_EXISTS;
					err_string =
						"EARFCN modification not allowed as it is a key element";
				}

				invalid_req = 1; 
			}
			else {
				OAM_LOG(OAM, OAM_INFO,
						"MEAS Config For EUTRAN Addition Received");
			}       
		}

		/* RT SPR 8154 FIX START */
		p_req->eutran_config_list_size =
			p_local_anr_meas_config_req->eutran_config_list_size;

		oam_memcpy(&p_req->eutran_config_list[0],
				&p_local_anr_meas_config_req->eutran_config_list[idx],
				sizeof(son_meas_config_eutran_t));
		/* RT SPR 8154 FIX END */
	}
	else if (p_local_anr_meas_config_req->other_rat_config_list.
			utran_config_list.utran_fdd_list_size) {
		arfcn_found = oam_arfcn_search_in_meas_config_list(
				/* RT SPR 8154 FIX START */
				&p_local_anr_meas_config_req->other_rat_config_list.
				/* RT SPR 8154 FIX END */
				utran_config_list.utran_fdd_list[idx].uarfcn,
				p_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_fdd_list,
				p_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_fdd_list_size,
				&p_son_inter_freq_carr_params->
				utran_fdd_meas_entry_bitmap,
				OAM_SON_MEAS_CONFIG_TYPE_UTRAN_FDD);


		is_meas_idx_occupied = p_son_inter_freq_carr_params->
			utran_fdd_meas_entry_bitmap & (1 << idx);

		if (NOT_FOUND != arfcn_found) {
			if((arfcn_found == idx) && is_meas_idx_occupied) {
				OAM_LOG(OAM, OAM_INFO,
						"MEAS Config For UTRAN_FDD Updation Received");  
			}
			else {
				*p_error_code = OAM_ERR_DATA_EXISTS;
				err_string = "Neighbor exists at other instance";
				invalid_req = 1;
			}
		}
		else {
			if((BITMAP_FULL == p_son_inter_freq_carr_params->
						utran_fdd_meas_entry_bitmap) || is_meas_idx_occupied) {
				if (BITMAP_FULL == p_son_inter_freq_carr_params->
						utran_fdd_meas_entry_bitmap) {
					err_string = "No more space for adding new UARFCN.";
					*p_error_code = OAM_RESOURCE_EXCCEED;
				}
				else if (is_meas_idx_occupied) {
					err_string =
						"UARFCN modification not allowed as it is a key element ";
					*p_error_code = OAM_ERR_DATA_EXISTS;
				}

				invalid_req = 1;
			}
			else {
				OAM_LOG(OAM, OAM_INFO,
						"MEAS Config For UTRAN_FDD Addition Received");
			}
		}

		/* RT SPR 8154 FIX START */
		oam_memcpy(&p_req->other_rat_config_list.utran_config_list,
				&p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list,
				sizeof(son_meas_config_utran_t));

		oam_memcpy(&p_req->other_rat_config_list.utran_config_list.
				utran_fdd_list[0],
				&p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_fdd_list[idx],
				sizeof(son_meas_config_utran_fdd_t));
	}
	else if (p_local_anr_meas_config_req->other_rat_config_list.
			utran_config_list.utran_tdd_list_size) {
		arfcn_found = oam_arfcn_search_in_meas_config_list(
				&p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_tdd_list[idx].uarfcn,
				p_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_tdd_list,
				p_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_tdd_list_size,
				&p_son_inter_freq_carr_params->
				utran_tdd_meas_entry_bitmap,
				OAM_SON_MEAS_CONFIG_TYPE_UTRAN_TDD);


		is_meas_idx_occupied = p_son_inter_freq_carr_params->
			utran_tdd_meas_entry_bitmap & (1 << idx);

		if (NOT_FOUND != arfcn_found) {
			if ((arfcn_found == idx) && is_meas_idx_occupied) {
				OAM_LOG(OAM, OAM_INFO,
						"MEAS Config For UTRAN_TDD Updation Received");
			}
			else {
				*p_error_code = OAM_ERR_DATA_EXISTS;
				err_string = "Neighbor exists at other instance";
				invalid_req = 1;
			}
		}
		else {
			if((BITMAP_FULL == p_son_inter_freq_carr_params->
						utran_tdd_meas_entry_bitmap) || is_meas_idx_occupied) {
				if (BITMAP_FULL == p_son_inter_freq_carr_params->
						utran_tdd_meas_entry_bitmap) {
					err_string = "No more space for adding new UARFCN.";
					*p_error_code = OAM_RESOURCE_EXCCEED;
				}
				if(is_meas_idx_occupied) {
					err_string =
						"UARFCN modification not allowed as it is a key element ";
					*p_error_code = OAM_ERR_DATA_EXISTS;
				}

				invalid_req = 1;
			}
			else {
				OAM_LOG(OAM, OAM_INFO,
						"MEAS Config For UTRAN_TDD addition received");
			}
		}

		oam_memcpy(&p_req->other_rat_config_list.utran_config_list,
				&p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list,
				sizeof(son_meas_config_utran_t));

		oam_memcpy(&p_req->other_rat_config_list.utran_config_list.
				utran_tdd_list[0],
				&p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_tdd_list[idx],
				sizeof(son_meas_config_utran_tdd_t));
	}
	else if (p_local_anr_meas_config_req->other_rat_config_list.
			geran_config_list.geran_freq_info_list_size) {
		OAM_LOG(OAM, OAM_INFO, "MEAS_CONFIG_REQ for GERAN received");
		arfcn_found = oam_arfcn_search_in_meas_config_list(
				&p_local_anr_meas_config_req->other_rat_config_list.
				geran_config_list.geran_freq_info_list[idx].
				geran_car_freqs,
				p_anr_meas_config_req->other_rat_config_list.
				geran_config_list.geran_freq_info_list,
				p_anr_meas_config_req->other_rat_config_list.
				geran_config_list.geran_freq_info_list_size,
				&p_son_inter_freq_carr_params->
				geran_meas_entry_bitmap,
				OAM_SON_MEAS_CONFIG_TYPE_GERAN);


		is_meas_idx_occupied = p_son_inter_freq_carr_params->
			geran_meas_entry_bitmap & (1 << idx);

		if (NOT_FOUND != arfcn_found) {
			if ((arfcn_found == idx) && is_meas_idx_occupied) {
				OAM_LOG(OAM, OAM_INFO,
						"MEAS Config For GERAN Updation Received");  
			}
			else {
				*p_error_code = OAM_ERR_DATA_EXISTS;
				err_string = "Neighbor exists at other instance";
				invalid_req = 1;
			}
		}
		else {
			if((BITMAP_FULL == p_son_inter_freq_carr_params->
						geran_meas_entry_bitmap) || is_meas_idx_occupied) {
				if (BITMAP_FULL == p_son_inter_freq_carr_params->
						geran_meas_entry_bitmap) {
					err_string =
						"No more space for adding new GERANFreqGroup.";
					*p_error_code = OAM_RESOURCE_EXCCEED;
				}
				if(is_meas_idx_occupied) {
					err_string =
						"BCCHARFCN modification not allowed as it is a key element ";
					*p_error_code = OAM_ERR_DATA_EXISTS;
				}

				invalid_req = 1;
			}
			else {
				OAM_LOG(OAM, OAM_INFO,
						"MEAS Config For BCCHARFCN Addition Received");

				p_req->other_rat_config_list.geran_config_list.
					t_reselection =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.t_reselection;

				p_req->other_rat_config_list.geran_config_list.
					bitmask |= SON_MC_GERAN_RESELECTION_PRESENT;
			}
		}

		p_req->other_rat_config_list.geran_config_list.
			geran_freq_info_list_size =
			p_local_anr_meas_config_req->other_rat_config_list.
			geran_config_list.geran_freq_info_list_size;

		oam_memcpy(&p_req->other_rat_config_list.geran_config_list.
				geran_freq_info_list[0],
				&p_local_anr_meas_config_req->other_rat_config_list.
				geran_config_list.geran_freq_info_list[idx],
				sizeof(son_geran_carrier_freq_info_t));
	}
	else {
		oam_memcpy(p_req, p_local_anr_meas_config_req,
				sizeof(oam_son_anr_meas_config_req_t));
	}

	/* RT SPR 8154 FIX END */
	if(!invalid_req) {
		oam_memcpy(&p_req->src_cgi, &p_local_anr_meas_config_req->src_cgi,
				sizeof(son_intra_rat_global_cell_id_t));
 /* SPR 14651 START */
        if(arfcn_found == NOT_FOUND){
            if (p_local_anr_meas_config_req->eutran_config_list_size) {
                if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                        eutran_meas_enable[idx].enable == OAM_FALSE)
                {
                    /* New Carrier added at with Enable false */
                    OAM_LOG(OAM, OAM_DETAILED, "Adding a new Eutran meas config record at OAM."
                            "Not sending to SON for Addition as Enable Is False");

                    p_rrm_cell_config_inter_freq_param  = &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx_rrm].
                                 ran_info.mobility_params.idle_mode_mobility_params.idle_mode_inter_freq_params_list;

                    oam_memcpy(&p_anr_meas_config_req->eutran_config_list[idx],
                            &p_local_anr_meas_config_req->eutran_config_list[idx],
                            sizeof(son_meas_config_eutran_t));

                    ++p_anr_meas_config_req->eutran_config_list_size;
                    index = p_rrm_cell_config_inter_freq_param->num_valid_inter_freq_list;

                    p_rrm_cell_config_inter_freq_param->idle_mode_mobility_inter_freq_params[index].
                        eutra_carrier_arfcn =
                        p_local_anr_meas_config_req->eutran_config_list[idx].earfcn;

                    p_rrm_cell_config_inter_freq_param->num_valid_inter_freq_list++;
                    p_son_inter_freq_carr_params->
                        eutran_meas_entry_bitmap |= (meas_bit << idx);  

                    /* Updating Meas Enable Data */
                    if( LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            eutran_meas_enable[idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
                    {
                        p_son_inter_freq_carr_params->
                            eutran_meas_enable[idx].enable = 
                            LOCAL_SON_PROV_REQ.oam_son_inter_freq_carrier_params[cell_config_idx].
                            eutran_meas_enable[idx].enable;
                        p_son_inter_freq_carr_params-> 
                            eutran_meas_enable[idx].
                            bitmask |= OAM_SON_MEAS_ENABLE_PRESENT; 
                    }
                    added_in_meas_record++;
                }

            }
            else if (p_local_anr_meas_config_req->other_rat_config_list.
                    utran_config_list.utran_fdd_list_size) {

                if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                        utran_meas_enable[idx].enable == OAM_FALSE)
                {
                    /* New Carrier added at with Enable false */
                    OAM_LOG(OAM, OAM_DETAILED, "Adding a new Utran meas config record at OAM."
                            "Not sending to SON for Addition as Enable Is False");

                    oam_memcpy(&p_anr_meas_config_req->other_rat_config_list.
                            utran_config_list.utran_fdd_list[idx],
                            &p_local_anr_meas_config_req->other_rat_config_list.
                            utran_config_list.utran_fdd_list[idx],
                            sizeof(son_meas_config_utran_fdd_t));

                    ++p_anr_meas_config_req->other_rat_config_list.utran_config_list.
                        utran_fdd_list_size;
                    p_son_inter_freq_carr_params->
                        utran_fdd_meas_entry_bitmap |= (meas_bit << idx);  
                    index = (++RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx_rrm].ran_info.
                            mobility_params.idle_mode_mobility_params.
                            idle_mode_mobility_inter_rat_utra_params.
                            irat_eutran_to_utran_fdd_list.
                            num_irat_eutran_to_utran_fdd_carriers);

                    RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx_rrm].ran_info.
                        mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_utra_params.
                        irat_eutran_to_utran_fdd_list.
                        irat_eutran_to_utran_fdd_carriers[index - 1].
                        utra_carrier_arfcn =
                        p_local_anr_meas_config_req->other_rat_config_list.
                        utran_config_list.utran_fdd_list[idx].uarfcn;

                    /* Updating Meas Enable Data */
                    if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            utran_meas_enable[idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
                    {
                        p_son_inter_freq_carr_params->
                            utran_meas_enable[idx].enable = 
                            LOCAL_SON_PROV_REQ.oam_son_inter_freq_carrier_params[cell_config_idx].
                            utran_meas_enable[idx].enable;
                        p_son_inter_freq_carr_params-> 
                            utran_meas_enable[idx].
                            bitmask |= OAM_SON_MEAS_ENABLE_PRESENT; 
                    }
                    added_in_meas_record++;
                }
                else if (p_local_anr_meas_config_req->other_rat_config_list.
                        geran_config_list.geran_freq_info_list_size) {

                    oam_memcpy(&p_anr_meas_config_req->other_rat_config_list.
                            geran_config_list.geran_freq_info_list[idx],
                            &p_local_anr_meas_config_req->other_rat_config_list.
                            geran_config_list.geran_freq_info_list[idx],
                            sizeof(son_geran_carrier_freq_info_t));

                    ++p_anr_meas_config_req->other_rat_config_list.
                        geran_config_list.geran_freq_info_list_size;
                    p_son_inter_freq_carr_params->
                        geran_meas_entry_bitmap |= (meas_bit << idx);  

                    index = RRM_CELL_CONFIG(cell_config_idx_rrm).ran_info.
                        mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_geran_params.
                        carrier_freq_info_list.count_geran_carrier;

                    RRM_CELL_CONFIG(cell_config_idx_rrm).ran_info.
                        mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_geran_params.
                        carrier_freq_info_list.carrier_list[index].
                        carrier_freq.starting_arfcn =
                        p_local_anr_meas_config_req->other_rat_config_list.
                        geran_config_list.geran_freq_info_list[idx].
                        geran_car_freqs.starting_arfcn;

                    ++RRM_CELL_CONFIG(cell_config_idx_rrm).ran_info.
                        mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_inter_rat_geran_params.
                        carrier_freq_info_list.count_geran_carrier;

                    /* Updating Meas Enable Data */
                    if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            geran_meas_enable[idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
                    {
                        p_son_inter_freq_carr_params->
                            geran_meas_enable[idx].enable = 
                            LOCAL_SON_PROV_REQ.oam_son_inter_freq_carrier_params[cell_config_idx].
                            geran_meas_enable[idx].enable;
                        p_son_inter_freq_carr_params-> 
                            geran_meas_enable[idx].
                            bitmask |= OAM_SON_MEAS_ENABLE_PRESENT; 
                    }
                    added_in_meas_record++;  
                }
            }
        }
        else if (arfcn_found == idx)
        {

            if (p_local_anr_meas_config_req->eutran_config_list_size) {

                meas_enable = p_son_inter_freq_carr_params->eutran_meas_enable[idx].enable;
                if(meas_enable == OAM_TRUE)
                {
                    if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            eutran_meas_enable[idx].enable == OAM_FALSE)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Updating Eutran meas config record at OAM."
                                "sending Meas Delete to SON Enable Is Made False");

                        p_son_inter_freq_carr_params->query_index = idx;
                        p_son_inter_freq_carr_params->config_ongoing |=
                            OAM_ANR_ACTION_DELETE_INTER_FREQ_CARRIER_ONGOING_AT_SON;

                        oam_memcpy(&p_delete_req->src_cgi,
                                &p_local_anr_meas_config_req->src_cgi, 
                                sizeof(son_intra_rat_global_cell_id_t));

                        p_delete_req->earfcn_remove_list_size = 1;

                        p_delete_req->earfcn_remove_list[0] =
                            p_son_inter_freq_carr_params->oam_son_anr_meas_config_req.
                            eutran_config_list[idx].earfcn;

                        retVal =
                            oam_son_send_son_oam_anr_meas_config_obj_remove_req(p_delete_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    transaction_id,
                                    curr_cell_id);

                        if (OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR, "Failed to send request to lower layer");
                            *p_error_code = OAM_SEND_FAIL;
	                        oam_mem_free(p_req, p_error_code);
                            oam_mem_free(p_delete_req, p_error_code);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;

                        }
                        OAM_FUN_EXIT_TRACE();
	                    oam_mem_free(p_req, p_error_code);
                        oam_mem_free(p_delete_req, p_error_code);
                        return OAM_SUCCESS;
                    }
                }
                else
                {
                    /* Carrier Not added at SON and Enable is still false */
                    if((LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                                eutran_meas_enable[idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT) &&
                            (LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                             eutran_meas_enable[idx].enable == OAM_FALSE))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Updating Eutran meas config record at OAM."
                                "Not sending to SON for Addition as Enable Is Still False");

                        oam_memcpy(&p_anr_meas_config_req->eutran_config_list[idx],
                                &p_local_anr_meas_config_req->eutran_config_list[idx],
                                sizeof(son_meas_config_eutran_t));
                        added_in_meas_record++;  

                    }

                }  
            }
            else if (p_local_anr_meas_config_req->other_rat_config_list.
                    utran_config_list.utran_fdd_list_size) {

                meas_enable = p_son_inter_freq_carr_params->utran_meas_enable[idx].enable;
                if(meas_enable == OAM_TRUE)
                {
                    if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            utran_meas_enable[idx].enable == OAM_FALSE)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Updating Utran meas config record at OAM."
                                "sending Meas Delete to SON Enable Is Made False");

                        p_son_inter_freq_carr_params->query_index = idx;
                        p_son_inter_freq_carr_params->config_ongoing |=
                            OAM_ANR_ACTION_DELETE_UTRAN_FDD_CARRIER_ONGOING_AT_SON;

                        oam_memcpy(&p_delete_req->src_cgi,
                                &p_local_anr_meas_config_req->src_cgi, 
                                sizeof(son_intra_rat_global_cell_id_t));

                        p_delete_req->uarfcn_fdd_remove_list_size = 1;

                        p_delete_req->uarfcn_fdd_remove_list[0] =
                            p_son_inter_freq_carr_params->oam_son_anr_meas_config_req.
                            other_rat_config_list.utran_config_list.
                            utran_fdd_list[idx].uarfcn;

                        retVal =
                            oam_son_send_son_oam_anr_meas_config_obj_remove_req(p_delete_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    transaction_id,
                                    curr_cell_id);
                        if (OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR, "Failed to send request to lower layer");
                            *p_error_code = OAM_SEND_FAIL;
	                        oam_mem_free(p_req, p_error_code);
                            oam_mem_free(p_delete_req, p_error_code);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
	                    oam_mem_free(p_req, p_error_code);
                        oam_mem_free(p_delete_req, p_error_code);
                        OAM_FUN_EXIT_TRACE();
                        return OAM_SUCCESS;
                    }
                }
                else
                {
                    /* Carrier Not added at SON and Enable is still false */
                    if((LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                                utran_meas_enable[idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT) &&
                            (LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                             utran_meas_enable[idx].enable == OAM_FALSE))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Updating Utran meas config record at OAM."
                                "Not sending to SON for Addition as Enable Is Still False");
                        oam_memcpy(&p_anr_meas_config_req->other_rat_config_list.
                                utran_config_list.utran_fdd_list[idx],
                                &p_local_anr_meas_config_req->other_rat_config_list.
                                utran_config_list.utran_fdd_list[idx],
                                sizeof(son_meas_config_utran_fdd_t));
                        added_in_meas_record++;  
                    }
                }
            }
            else if (p_local_anr_meas_config_req->other_rat_config_list.
                    geran_config_list.geran_freq_info_list_size) {
                meas_enable = p_son_inter_freq_carr_params->geran_meas_enable[idx].enable;

                if(meas_enable == OAM_TRUE)
                {
                    if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            geran_meas_enable[idx].enable == OAM_FALSE)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Updating Geran meas config record at OAM."
                                "sending Meas Delete to SON Enable Is Made False");
                        p_son_inter_freq_carr_params->query_index = idx;
                        p_son_inter_freq_carr_params->config_ongoing |=
                            OAM_ANR_ACTION_DELETE_GERAN_FREQ_CARRIER_ONGOING_AT_SON;

                        oam_memcpy(&p_delete_req->src_cgi,
                                &p_local_anr_meas_config_req->src_cgi, 
                                sizeof(son_intra_rat_global_cell_id_t));

                        p_delete_req->geran_remove_list_size = 1;

                        oam_memcpy(&p_delete_req->geran_remove_list[0],
                                &p_anr_meas_config_req->other_rat_config_list.
                                geran_config_list.geran_freq_info_list[idx].
                                geran_car_freqs,
                                sizeof(son_geran_carrier_freqs_t));

                        retVal =
                            oam_son_send_son_oam_anr_meas_config_obj_remove_req(p_delete_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    transaction_id,
                                    curr_cell_id);

                        if (OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR, "Failed to send request to lower layer");
                            *p_error_code = OAM_SEND_FAIL;
	                        oam_mem_free(p_req, p_error_code);
                            oam_mem_free(p_delete_req, p_error_code);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
	                    oam_mem_free(p_req, p_error_code);
                        oam_mem_free(p_delete_req, p_error_code);
                        OAM_FUN_EXIT_TRACE();
                        return OAM_SUCCESS;
                    } 
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "Updating Geran meas config record at OAM."
                            "Not sending to SON for Addition as Enable Is Still False");

                    oam_memcpy(&p_req->other_rat_config_list.geran_config_list.
                            geran_freq_info_list[0],
                            &p_local_anr_meas_config_req->other_rat_config_list.
                            geran_config_list.geran_freq_info_list[idx],
                            sizeof(son_geran_carrier_freq_info_t));
                    added_in_meas_record++;  
                }
            }   
        }
        if(added_in_meas_record)
        {
		    transaction_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_ZERO);
            OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");

            oam_prov_req.system_status.event_ongoing &=
                                 ~USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;

            oam_construct_n_send_set_resp_to_usr(
                    OAM_RESULT_SUCCESS,
                    OAM_ZERO, OAM_NULL,
                    OAM_ZERO,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    transaction_id,
                    OAM_ZERO, OAM_ZERO,
                    p_error_code);

            *p_is_dom_update_reqd = OAM_TRUE; 
	        oam_mem_free(p_req, p_error_code);
            oam_mem_free(p_delete_req, p_error_code);
            OAM_FUN_EXIT_TRACE();
            return OAM_SUCCESS;
        }
 /* SPR 14651 END */
		retVal = oam_son_send_son_oam_anr_meas_config_req(p_req,
				OAM_MODULE_ID,
				SON_MODULE_ID,
				transaction_id,
				curr_cell_id);
		if (OAM_FAILURE == retVal) {
			*p_error_code = OAM_SEND_FAIL;
		}
	}
	else {
		retVal = OAM_FAILURE;
		OAM_LOG(OAM, OAM_WARNING, "error :%s", err_string);
	}

	oam_mem_free(p_req, p_error_code);
 /* SPR 14651 START */
    oam_mem_free(p_delete_req, p_error_code);
 /* SPR 14651 END */

	OAM_FUN_EXIT_TRACE();
	return retVal;
}
#endif
/* Coverity 69691 Fix Start */
/****************************************************************************
 * Function Name : oam_apply_carrier_freq_and_power_list
 * Description   : This function first validates the user request for meas
 *                 configuration then it sends the request to SON layer
 * Inputs        :  p_api_buf,
 *                  msg_len,p_cell_reconfig_req,p_error_code
 *
 * Outputs       : p_error_code : Error Code
 * Returns       : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
oam_return_et oam_apply_carrier_freq_and_power_list(
		UInt8                       *p_api_buf,
		UInt16                      msg_len,
		oam_rrm_cell_reconfig_req_t *p_cell_reconfig_req,
		oam_error_code_et           *p_error_code,
        /* SPR 19236 Fix + */
		xmlNode                     *p_orig_parent,
		xmlNode                     *p_req_parent,
		xmlNode                     **p_p_xml_struct_addr)
        /* SPR 19236 Fix - */
{
	OAM_FUN_ENTRY_TRACE();
	oam_return_et  ret_val = OAM_SUCCESS;

	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;


	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
				oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}



#ifdef OAM_SON_ENABLE
	SInt8 cell_config_idx1 = OAM_ERROR_RETURN_VAL;
	UInt32    earfcn_first_value = OAM_ZERO;
	SInt8     ref_power_first_value = OAM_ZERO,
		  p_max_power_first_value = OAM_ZERO;
	UInt16 counter1= OAM_ZERO, counter2 = OAM_ZERO, 
	       counter3 =OAM_ZERO;
	UInt8 *p_temp = OAM_NULL;
	UInt8 *value = OAM_NULL;
	/* CSR 58157 START */
	UInt8 loop_counter = OAM_ZERO;
	UInt8 *earfcn_list_temp_ul[100], counter = OAM_ZERO;
	/* CSR 58157 END */

    /* Coverity_86795 Fix Start */
	oam_son_carrier_freq_and_dl_tx_power_req_t    son_carrier_freq_and_dl_tx_power_req = {OAM_ZERO};
    /* Coverity_86795 Fix End */


	son_carrier_freq_and_dl_tx_power_req.meas_bandwidth = 
		SON_PROV_REQ.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.meas_bandwidth;

	/* Earfcn List is changed */
	if(paramter_app_map_tbl & OAM_EARFCN_DL_LIST_MASK)
	{
		p_temp= (UInt8 *)local_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcn_list;

		value = (UInt8 *)oam_strtok((char *)p_temp,",");
		while(OAM_NULL != value)
		{
			son_carrier_freq_and_dl_tx_power_req.earfcn_list[counter1] = oam_atoi((const char *)value);
			value = (UInt8 *)oam_strtok(OAM_NULL,",");
			counter1++;
		}/* End of while loop */   
		son_carrier_freq_and_dl_tx_power_req.earfcn_list_size=counter1;
		earfcn_first_value = son_carrier_freq_and_dl_tx_power_req.earfcn_list[OAM_ZERO];
		/* CSR 58157 START */
		oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcndl_list_size = counter1;
		for(loop_counter= OAM_ZERO;loop_counter<counter1;loop_counter++)
		{
			oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcn_list_dl[loop_counter] = son_carrier_freq_and_dl_tx_power_req.earfcn_list[loop_counter];
		}
		/* CSR 58157 END */
	}
	else {
		cell_config_idx1 = oam_get_son_serving_cell_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_config_idx1) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
					oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_FAILURE;
		}

		son_carrier_freq_and_dl_tx_power_req.earfcn_list_size = OAM_ONE;
		earfcn_first_value = 
			son_carrier_freq_and_dl_tx_power_req.earfcn_list[OAM_ZERO] = 
			SON_CELL_INFO_IND_SERVING_CELL(cell_config_idx1).
			choice_eutra_mode.fdd_info.dl_earfcn;
	}

	/* CSR 58157 START */
	if(paramter_app_map_tbl & OAM_EARFCN_UL_LIST_MASK)
	{
		p_temp= local_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcnul_list;
		earfcn_list_temp_ul[OAM_ZERO] = (UInt8 *)oam_strtok((char *)p_temp,",");
		while(OAM_NULL != earfcn_list_temp_ul[counter])
		{
			counter++;
			earfcn_list_temp_ul[counter]=(UInt8 *)oam_strtok(NULL,",");
		}/* End of while loop */

		for(loop_counter= OAM_ZERO;loop_counter<counter;loop_counter++)
		{
			oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcn_list_ul[loop_counter] = (UInt16)oam_atoi((char *)earfcn_list_temp_ul[loop_counter]);
		}
	}
	/* CSR 58157 END */

	/* Reference Signal Power List is changed */
	if(paramter_app_map_tbl & OAM_REF_SIG_POWER_LIST_MASK)
	{
		p_temp= local_prov_req.oam_params.cell_carrier_params[OAM_ZERO].reference_signal_power_list;

		value = (UInt8 *)oam_strtok((char *)p_temp,",");
		ref_power_first_value = oam_atoi((const char *)value);
		son_carrier_freq_and_dl_tx_power_req.p_tx_upp = oam_atoi((const char *)value);
		son_carrier_freq_and_dl_tx_power_req.p_tx_low = oam_atoi((const char *)value);
		while(OAM_NULL != value)
		{
			if(oam_atoi((const char *)value) >= MIN_REFERENCESIGNALPOWER
					&& oam_atoi((const char *)value) <= MAX_REFERENCESIGNALPOWER)
			{
				/* Populate maximum and minimum of values */
				if((oam_atoi((const char*)value)) > SON_PROV_REQ.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.p_tx_upp)
					son_carrier_freq_and_dl_tx_power_req.p_tx_upp = oam_atoi((const char *)value);
				if((oam_atoi((const char*)value)) < SON_PROV_REQ.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.p_tx_low)
					son_carrier_freq_and_dl_tx_power_req.p_tx_low = oam_atoi((const char *)value);
				value = (UInt8 *)oam_strtok(OAM_NULL,",");
				counter2++;
			}
			else
			{
				OAM_LOG(OAM, OAM_DETAILED,
						"Value of ReferenceSignalPower is %d and range is from %d to %d",
						oam_atoi((const char *)value),MIN_REFERENCESIGNALPOWER,MAX_REFERENCESIGNALPOWER);
				return OAM_FAILURE;
			}
		}/* End of while loop */   
	}
	else
	{
		ref_power_first_value = 
			son_carrier_freq_and_dl_tx_power_req.p_tx_upp = son_carrier_freq_and_dl_tx_power_req.p_tx_low = 
			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].ran_info.
			rf_params.rf_configurations.reference_signal_power;
	}

	/* UE Power List is changed */
	if(paramter_app_map_tbl & OAM_P_MAX_LIST_MASK)
	{
		p_temp= local_prov_req.oam_params.ue_trans_power_list;

		value = (UInt8 *)oam_strtok((char *)p_temp,",");
		p_max_power_first_value = oam_atoi((const char *)value);
		son_carrier_freq_and_dl_tx_power_req.p_ue_max = oam_atoi((const char *)value);
		son_carrier_freq_and_dl_tx_power_req.p_ue_min = oam_atoi((const char *)value);
		while(OAM_NULL != value)
		{
			if(oam_atoi((const char *)value) >= MIN_REFERENCESIGNALPOWER
					&& oam_atoi((const char *)value) <= MAX_REFERENCESIGNALPOWER)
			{
				/* Populate maximum and minimum of values */
				if((oam_atoi((const char*)value)) > SON_PROV_REQ.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.p_ue_max)
					son_carrier_freq_and_dl_tx_power_req.p_ue_max = oam_atoi((const char *)value);
				if((oam_atoi((const char*)value)) < SON_PROV_REQ.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.p_ue_min)
					son_carrier_freq_and_dl_tx_power_req.p_ue_min = oam_atoi((const char *)value);
				value = (UInt8 *)oam_strtok(OAM_NULL,",");
				counter3++;
			}
			else
			{
				OAM_LOG(OAM, OAM_DETAILED,
						"Value of ReferenceSignalPower is %d and range is from %d to %d",
						oam_atoi((const char *)value),MIN_REFERENCESIGNALPOWER,MAX_REFERENCESIGNALPOWER);
				return OAM_FAILURE;
			}
		}/* End of while loop */  
	}
	else
	{
		p_max_power_first_value = 
			son_carrier_freq_and_dl_tx_power_req.p_ue_max = son_carrier_freq_and_dl_tx_power_req.p_ue_min = 
			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].ran_info.
			mobility_params.idle_mode_mobility_params.
			idle_mode_mobility_intra_freq_params.p_max_sib_1;
	} 

	/* If any of the value conatins list, Trigger SON API to select single value */    
        /* SPR 19236 Fix + */
	if((OAM_ONE<counter1) || (OAM_ONE<counter2) || (OAM_ONE<counter3))
        /* SPR 19236 Fix - */
	{
		UInt16 tcb_transaction_id = oam_get_new_trans_id();
		/* Temporary save the transaction id */
		oam_prov_req.oam_params.temp_trans_id = tcb_transaction_id;
		if(OAM_SUCCESS == oam_son_send_son_oam_carrier_freq_and_dl_tx_power_req(
					&son_carrier_freq_and_dl_tx_power_req,
					OAM_MODULE_ID, SON_MODULE_ID, tcb_transaction_id,
					oam_prov_req.cell_cntxt.curr_cell_cid))
		{
			/* SPR-13074 Start */
			/* Coverity_99559 Fix Start */
			oam_maintain_tcb(tcb_transaction_id,OAM_TRANS_SON,msg_len,p_api_buf);
			/* Coverity_99559 Fix End */
			/* SPR-13074 End */
			OAM_LOG(OAM,OAM_DETAILED, "successfully sent SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_REQ msg");
			oam_prov_req.system_status.event_ongoing |= OAM_SON_CARRIER_FREQ_ONGOING;
			/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_SON,
						OAM_TRANS_SON,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
				ret_val = OAM_FAILURE;
			}
#endif
			/* SPR 9620 CHANGE END */

		}
	}
	else
	{
		/* Trigger cell reconfiguration at RRM */

		LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].ran_info.
			rf_params.rf_configurations.dl_earfcn = earfcn_first_value;
		LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].ran_info.rf_params.rf_configurations.reference_signal_power =
			ref_power_first_value;
		LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].ran_info.mobility_params.idle_mode_mobility_params.
			idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_P_MAX_SIB1_PRESENT;
		LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].ran_info.mobility_params.idle_mode_mobility_params.
			idle_mode_mobility_intra_freq_params.p_max_sib_1= p_max_power_first_value;
		/* Start: CSR 00058940 */            
		LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].ran_info.mobility_params.idle_mode_mobility_params.
			idle_mode_mobility_intra_freq_params.p_max_sib_3 = p_max_power_first_value;
		LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].ran_info.mobility_params.idle_mode_mobility_params.
			idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_P_MAX_SIB3_PRESENT;
		/*End: CSR 00058940 */            
#endif
	if(OAM_CM_ST_ACTIVE !=  p_cm_cntxt->state)
	{

		oam_memcpy(&RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx],
				&LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx],
				sizeof(oam_rrm_cell_reconfig_req_t));
	}
	else
	{
		OAM_LOG(OAM,OAM_DETAILED,"Sending Cell Reconfiguration");

		oam_copy_config_to_reconfig((oam_rrm_cell_config_req_t *)(&(LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx])), p_cell_reconfig_req);
        
        /* SPR 19236 Fix + */
		oam_maintain_tcb_ext(tcb_transaction_id, OAM_TRANS_RRM, msg_len, p_api_buf, p_orig_parent, p_req_parent, p_p_xml_struct_addr);
        /* SPR 19236 Fix + */
		ret_val =
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_cell_reconfig_req,
					OAM_MODULE_ID,
					RRM_MODULE_ID,
					tcb_transaction_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
		if (OAM_FAILURE == ret_val)
		{
			OAM_LOG(OAM,OAM_WARNING,
					"Error in function oam_rrm_send_rrm_oam_cell_reconfig_req:"
					" error code :%d",
					*p_error_code);

		}
	}/* End of else */
#ifdef OAM_SON_ENABLE
	}/* End of else of if(OAM_ONE!=counter1 || OAM_ONE!=counter2 || OAM_ONE!=counter3) */
#endif

	OAM_FUN_EXIT_TRACE();
	return ret_val;
}
/* Coverity 69691 Fix End */

/* SPR_20467_FIX_START */
/****************************************************************************
 * Function Name  : oam_tcb_insert_for_ecu
 * Inputs         : trans_id :transaction identifier
 *                  timer_id :timer id
 *                  trans_type :transcation type
 *                  msg_len :message length
 *                  p_msg :Pointer to message
 *                  procedure_specific_buf_len :
 *                         procedure specific msg length
 *                  p_procedure_specific_data : 
 *                         Pointer to procedure specific data
 * Outputs        : None.
 * Returns        : void*
 * Variables      : None.
 * Description    : insert item in tcb
 ****************************************************************************/
void*
oam_tcb_insert_for_ecu
(
    UInt32 trans_id,
    QTIMER timer_id,
    oam_trans_type_et trans_type,
    UInt16 msg_len,
    void *p_msg,
    UInt8 procedure_specific_buf_len,
    void *p_procedure_specific_data,
    UInt8 old_ecu_sent_flag
)
{
    oam_s1ap_ecu_resp_data_t* p_ecu_resp_data = OAM_NULL;
    oam_error_code_et   error_code;
    oam_node_t          *p_oam_node;
    UInt32 bitmask    =  OAM_ZERO;
    OAM_FUN_ENTRY_TRACE();
    error_code = NO_ERROR;
    void *ptr = OAM_NULL;
    if(OAM_PNULL == p_msg)
    {
        OAM_LOG(OAM, OAM_WARNING,
                "Received argument is NULL");
        OAM_FUN_EXIT_TRACE();
        return ptr;
    }
    if(trans_type == OAM_TRANS_SON)
    {
        bitmask = TCB_BITMASK_SON;
    }
    else if(trans_type == OAM_TRANS_RRC_MAC_PDCP_RRM)
    {
        bitmask = TCB_BITMASK_RRC_MAC_PDCP_RRM;
    }
    else if(trans_type == OAM_TRANS_RRM)
    {
        bitmask = TCB_BITMASK_RRM;
    }
    else if(trans_type == OAM_TRANS_MAC)
    {
        bitmask = TCB_BITMASK_MAC;
    }
    else if(trans_type == OAM_TRANS_RLC)
    {
        bitmask = TCB_BITMASK_RLC;
    }
    else if(trans_type == OAM_TRANS_PDCP)
    {
        bitmask = TCB_BITMASK_PDCP;
    }
    else if(trans_type == OAM_TRANS_EGTPU)
    {
        bitmask = TCB_BITMASK_EGTPU;
    }
    else if(trans_type == OAM_TRANS_RRC)
    {
        bitmask = TCB_BITMASK_RRC;
    }
    else if(trans_type == OAM_TRANS_S1AP)
    {
        bitmask = TCB_BITMASK_S1AP;
    }
    else if(trans_type == OAM_TRANS_X2AP)
    {
        bitmask = TCB_BITMASK_X2AP;
    }
    else if(trans_type == OAM_TRANS_L2ALL)
    {
        bitmask = TCB_BITMASK_L2ALL;
    }
    else if(trans_type == OAM_TRANS_L3ALL)
    {
        bitmask = TCB_BITMASK_L3ALL;
    }
    else if(trans_type == OAM_TRANS_ALL)
    {
        bitmask = TCB_BITMASK_ALL;
    }
#ifdef OAM_RADIO_HEAD_SUPPORT
    else if(OAM_TRANS_RRH == trans_type) {
        bitmask = TCB_BITMASK_RRH;
    }
#endif
    else if(trans_type == OAM_TRANS_FM)
    {
        bitmask = TCB_BITMASK_FM;
    }   
    else if(trans_type == OAM_TRANS_PM)
    {
        bitmask = TCB_BITMASK_PM;
    }
    else if(trans_type == OAM_TRANS_SM)
    {
        bitmask = TCB_BITMASK_SM;
    }
    else if(trans_type == OAM_TRANS_SYSTEM_LOG)
    {
        bitmask = TCB_BITMASK_SYS;
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING,
                "INVALID TRANSACTION TYPE[%d]", trans_type);
        OAM_FUN_EXIT_TRACE();
        return ptr;
    }
    if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_node_t),
                (void *)&p_oam_node,
                &error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_oam_node failed"
                " with Error Code:%d",
                error_code);
        OAM_FUN_EXIT_TRACE();
        return ptr;
    }

    p_oam_node->oam_struct.transaction_id=trans_id;
    p_oam_node->oam_struct.timer_id=timer_id;
    p_oam_node->oam_struct.bitmask = bitmask;

    if(OAM_FAILURE == oam_mem_alloc(msg_len,
                (void *)&p_oam_node->oam_struct.oam_tcb_context,
                &error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_oam_node->oam_struct.oam_tcb_context failed"
                " with Error Code:%d",
                error_code);
        oam_mem_free(p_oam_node, &error_code);	
        OAM_FUN_EXIT_TRACE();
        return ptr;
    }
    if(OAM_FAILURE == oam_mem_alloc(procedure_specific_buf_len,
                (void *)&p_oam_node->oam_struct.oam_procedure_specific_context,
                &error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to "
                "p_oam_node->oam_struct.oam_procedure_specific_context failed"
                " with Error Code:%d",
                error_code);
        oam_mem_free(p_oam_node->oam_struct.oam_tcb_context, &error_code);
        oam_mem_free(p_oam_node, &error_code);	
        OAM_FUN_EXIT_TRACE();
        return ptr;
    }
    oam_memcpy(p_oam_node->oam_struct.oam_tcb_context,p_msg,msg_len);
    p_ecu_resp_data = (oam_s1ap_ecu_resp_data_t*)p_oam_node->oam_struct.oam_procedure_specific_context;
    if(OAM_NULL != p_procedure_specific_data)
    {
        oam_memcpy(p_oam_node->oam_struct.oam_procedure_specific_context,p_procedure_specific_data,procedure_specific_buf_len);
        p_ecu_resp_data->old_ecu_sent_flag = old_ecu_sent_flag;
    }
    else
    {
        p_ecu_resp_data->mme_id_response_cnt = OAM_ZERO;
        p_ecu_resp_data->ecu_success_resp_received = OAM_FALSE;
        p_ecu_resp_data->old_ecu_sent_flag = old_ecu_sent_flag;
        oam_memset(&(p_ecu_resp_data->ecu_resp_received),OAM_RESP_NOT_RECEIVED,MAX_NUM_MME); 
    }    
    ptr = p_oam_node->oam_struct.oam_tcb_context;
    if(OAM_FAILURE == oam_hash_insert(&p_oam_node->anchor))
    {
        OAM_LOG(OAM, OAM_INFO,
                "Insertion of Hash Node Fails");
        oam_mem_free(p_oam_node->oam_struct.oam_tcb_context, &error_code);
        oam_mem_free(p_oam_node->oam_struct.oam_procedure_specific_context, &error_code);
        oam_mem_free(p_oam_node, &error_code);	
        OAM_FUN_EXIT_TRACE();
        return ptr;

    }
    OAM_LOG(OAM, OAM_DETAILED,
            "Insertion of Hash Node successful");
    OAM_FUN_EXIT_TRACE();
    return ptr;
}

/******************************************************************************
 *   FUNCTION NAME   : oam_maintain_tcb_for_ecu
 *   DESCRIPTION     : It is responsible to maintaining tcb entries and starting 
 *                     Module timmer for Qcli command
 *   INPUT           : trans_id :transaction identifier
 *                     trans_type :transaction type
 *                     msg_size :size of message
 *                     p_api_buf :Pointer to Buffer 
 *                     procedure_specific_buf_len :
 *                         procedure specific msg length
 *                     p_procedure_specific_data :
 *                         Pointer to procedure specific data
 *   OUTPUT          : NONE
 *   RETURNS         : void*
 ******************************************************************************/
void * 
oam_maintain_tcb_for_ecu
(
 UInt16 trans_id,
 oam_trans_type_et trans_type,
 UInt16 msg_size,
 void *p_api_buf,
 UInt8 procedure_specific_buf_len,
 void *p_procedure_specific_data,
 UInt8 old_ecu_sent_flag
 )
{
    OAM_FUN_ENTRY_TRACE();
    char *p_temp = OAM_NULL;
    void *ptr = OAM_NULL;
    oam_error_code_et error_code;
    UInt32 timer_s = OAM_LAYER_INTF_RESP_TIMEOUT_S; /* Timer value in seconds */
    QTIMER timer_id = OAM_ZERO;
    UInt16 timer_type = OAM_GUARD_TIMER_TYPE;
    /* For calling any TCB related functions, trans_id must be of 4 bytes */
    UInt32 trans_id_new = trans_id;
    oam_return_et retVal = OAM_FAILURE;

    retVal = oam_mem_alloc(OAM_TCB_TEMP_DATA_LEN, (void**)&p_temp,
            &error_code);
    if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_temp failed"
                " with Error Code:%d",
                error_code);
        OAM_FUN_EXIT_TRACE();
        return ptr;
    }


    snprintf(p_temp, OAM_ONE + OAM_FIFTEEN, "ID-%d", trans_id); 

#ifdef OAM_RADIO_HEAD_SUPPORT
    if(OAM_TRANS_RRH == trans_type) {
        OAM_LOG(OAM, OAM_DETAILED, "Setting request timer value: %d s",
                oam_prov_req.oam_rcm_req.rrh_timer);
        timer_s = oam_prov_req.oam_rcm_req.rrh_timer;
    }
#endif

    if(OAM_TRANS_RRM == trans_type &&
            (oam_prov_req.system_status.event_ongoing &
             OAM_SET_ADMIN_STATE_RESP_PENDING) &&
            (oam_prov_req.system_status.event_ongoing &
             OAM_RRM_CELL_BLOCK_REQ_MASK)) {
        timer_type = OAM_CELL_BLOCK_TIMER_TYPE;
    }
    if(OAM_ONE == oam_sys_log)
    {
        timer_type = OAM_SYSTEM_LOG_TIMER_TYPE;
        OAM_LOG(OAM, OAM_DETAILED, "OAM_SYSTEM_LOG_TIMER_TYPE called");
        oam_sys_log = OAM_ZERO;
    }
    timer_id = oam_start_new_timer(OAM_SUB_MODULE_MIH,
            OAM_MODULE_ID,
            timer_type,
            (timer_s * 1000), /* Timer value in ms */
            p_temp, OAM_TCB_TEMP_DATA_LEN,
            OAM_FALSE);
    OAM_LOG(OAM, OAM_DETAILED, "trans_id Saved is: %d", trans_id_new);
    ptr = oam_tcb_insert_for_ecu(trans_id_new, timer_id, trans_type,
            msg_size,p_api_buf,procedure_specific_buf_len,p_procedure_specific_data,old_ecu_sent_flag);
    if(OAM_NULL == ptr) {
        OAM_LOG(OAM, OAM_ERROR,
                "Unable to Maintain Transaction Details in TCB");
    }
    OAM_FUN_EXIT_TRACE();
    return ptr;
}
/* SPR_20467_FIX_END */

/****************************************************************************
 * Function Name: oam_send_message_to_lower_layers
 * Description  : This function is responsible for sending created message to 
 *                lower layers
 * Inputs       : 
 *                 src_module_id: Source module identifier
 *                 msg_len      : Interface transaction identifier
 *                 p_api_buf    : buffer message received from user
 *                                       management interface
 *                 p_local_req  : the pointer to structure containing updated
 *                                values of parameters request by operator
 *                 p_orig_parent: pointer to xmlNode for parent of the 
 *                                requested parameters in the DOM
 *                 p_req_parent : pointer to xmlNode represetation of a copy
 *                                of the parent of the parameres in the DOM
 *                                having updated value requested by operator
 *                 
 * Outputs      :  p_error_code : pointer to error code returned, if any
 * Returns/      : OAM_SUCCESS/OAM_FAILURE
 ***************************************************************************/
	oam_return_et
oam_send_message_to_lower_layers(UInt16 src_module_id,
		UInt16 msg_len,
		UInt8 *p_api_buf,
		void *p_local_req,
		xmlNode *p_orig_parent,
		xmlNode *p_req_parent,
		xmlNode **p_p_xml_struct_addr,
		oam_error_code_et *p_error_code)
{
    /* SPR 17123 FIX : code removed */
    /* SPR 17018/17050 FIX : code removed */
    oam_counter_t loop = OAM_ZERO;
    /* spr_21013_fix_start */
     UInt8 oam_startup_required = OAM_FALSE;
    /* spr_21013_fix_end */
    UInt64 api_index = OAM_ZERO;
    UInt64 temp_api_mask = OAM_ZERO;
    Char8 cmd_status[OAM_USR_INTF_ERR_STR_MAX_SIZE] = {OAM_ZERO};
    UInt8 cmd_status_size = OAM_ZERO;
    /* SPR_19619 start*/
    U16 cell_counter = 0;
    oam_son_peer_cell_activation_req_t *p_son_cell_activation_req = OAM_NULL;
    /* SPR_19619 stop*/
    /* SPR 15527 START */
    UInt8 qci_idx = OAM_ZERO;
    UInt8 drx_idx = OAM_ZERO;
    /* SPR 15527 END */
    UInt8 Index = OAM_ZERO;

    oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
    oam_rrm_cell_plmnlist_data_t *p_cell_local_plmnlist_data = OAM_NULL;
    UInt8 curr_cid = oam_prov_req.cell_cntxt.curr_cell_cid;
#ifdef OAM_SON_ENABLE
    UInt8 tran_id = OAM_ZERO;
    oam_son_anr_disable_req_t *p_son_anr_disable_req = OAM_NULL;
    oam_son_anr_enable_req_t *p_son_anr_enable_req = OAM_NULL;
    UInt16 temp_earfcn_array[OAM_EUTRA_CARRIER_ARFCN_DL_LIST_MAX_LEN] = {0};
    /* SPR 11156 FIX START */
    /* CODE DELETED */
    /* SPR 11156 FIX END */
    UInt16 temp_val_index = OAM_ZERO;
    oam_son_nr_add_req_t *p_local_son_nr_add = OAM_NULL;
    oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;

    oam_son_inter_freq_carrier_t
        *p_son_inter_freq_carr_params = OAM_NULL;
    oam_son_inter_freq_carrier_t
        *p_local_son_inter_freq_carr_params = OAM_NULL;
    /* SPR 11156 FIX START */
    oam_son_nr_delete_from_remove_list_req_t
        *p_son_nr_del_from_remlist = OAM_NULL;
    /* SPR 11156 FIX END */
    /*SPR 12001 FIX START*/
    Char8 *saveptr1, *str1;
    Char8  csv_list[OAM_PHY_CELL_ID_STR_MAX_LEN] = {OAM_ZERO};
    Char8 *csv_list_1 = OAM_NULL;
    /*SPR 12001 FIX END*/
    /* SPR 13024 FIX START */
    oam_son_pci_reselection_req_t *p_pci_reselection_req = OAM_NULL;
    /* SPR 13024 FIX END */
#endif
    /* Coverity FIX 54197 */
    UInt8 resp_result = OAM_ZERO;
    UInt8 flag_found = OAM_ZERO;
    /* coverity 41295 */
    /*SPR 13518: Code removed */

    /* SPR 13501 FIX START  */
    UInt16 count = 0;
    char *token=OAM_NULL;
    UInt32 var = OAM_ZERO;
    UInt32 total_rbs = OAM_ZERO;
    /* SPR 13501 FIX END  */
    oam_return_et  ret_val = OAM_SUCCESS;
    UInt8 cnt = OAM_ZERO;
    UInt8 query_idx = OAM_ZERO;
    UInt16 usr_err_code = OAM_ZERO;
    /* SPR 11001 FIX START */
    UInt16 usr_resp = OAM_ZERO;
    Char8 *err_string = OAM_NULL;
    UInt8 err_str_size = OAM_ZERO;
    /* SPR 11001 FIX END */
    char* temp_ip = OAM_NULL;
    Char8 TempValue[1000]={0};
    OAM_FUN_ENTRY_TRACE();

    UInt16 trans_id = get_word_from_header((UInt8 *)p_api_buf);

    UInt16 dest_id = get_word_from_header((UInt8 *)p_api_buf +OAM_TWO);

    /* SPR 16334 Fix Start */
    SInt16 x2_get_idx_from_nbr_enb_add_list(oam_x2ap_add_enb_req_t *x2ap_info ,x2_enb_comm_info_t  *tnl_addr);
    /* SPR 16334 Fix End */


    /* SPR 18930  FIX START */
    oam_bool_et is_dom_update_reqd = OAM_FALSE;
    /* SPR 18930  FIX END */


    /* SPR 13024 FIX START */
#ifdef OAM_SON_ENABLE
    SInt8 cell_arr_idx = OAM_ERROR_RETURN_VAL;
    /* SPR 13024 FIX END */
#endif
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    oam_rrm_cell_config_req_t  *p_rrm_cell_config = OAM_NULL;

    oam_rrm_cell_config_req_t  *p_local_cell_config = OAM_NULL;

    /* SPR 11001 FIX START */
    oam_rrm_load_config_req_t *p_load_config_req = OAM_NULL;
    /* SPR 11001 FIX END */

    oam_cell_status_t *p_cell_status = OAM_NULL;
    /* Spr 10926 Fix Start */
    UInt8 loop_counter = OAM_ZERO;    
    UInt8 cid = OAM_ZERO; 
    resp_destination_id = dest_id;
    /* Spr 10926 Fix End */
    tcb_transaction_id = trans_id;
    destination_id=src_module_id;
    /*Sending messages to lower layer modules who ever requires changed 
      prov_request structure */ 
    /*In case to add more switch cases OAM_MAX_API_TO_LOWER_LAYER 
      should be incremented*/

    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    oam_m2ap_set_log_level_req_t *p_m2ap_log_level_req = OAM_NULL;
#endif
    /* EMBMS Changes End */

    for(loop = OAM_ZERO;loop < OAM_MAX_API_TO_LOWER_LAYER && !flag_found;loop++)
    {
        temp_api_mask = (UInt64)((UInt64)OAM_ONE <<loop);
        api_index = (paramter_app_map_tbl & temp_api_mask);
        /* Coverity 109468 + */
        /* SPR_19279_START */
        UInt8 idx = 0;
        UInt8 primary_plmn_idx = OAM_ZERO;
        /* SPR_20467_FIX_START */
        bc_plmn_list_t tmp_plmnlist = {OAM_ZERO};
        /* SPR_20467_FIX_END */
        /* SPR_19279_END */
        /* Coverity 109468 - */

        switch (api_index) {
#ifdef OAM_SON_ENABLE
            case OAM_SON_MLB_MODIFY_ATTRIBUTE_REQ_MASK:
                ret_val= oam_son_send_son_oam_mlb_modify_attributes_req(
                        p_local_req,
                        OAM_MODULE_ID, SON_MODULE_ID,
                        trans_id,
                        curr_cid);

                if (OAM_FAILURE == ret_val) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Error in sending MLB_MODIFY_ATTR_PARAM request");
                }
                else {
                    OAM_LOG(OAM, OAM_INFO,
                            "MLB_MODIFY_ATTR_PARAM request sent successfully "
                            "to lower layer");
                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                                OAM_TRANS_SON,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }
                flag_found = OAM_ONE;
                break;



            case OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK:
                ret_val= oam_son_send_son_oam_mro_modify_config_params_req(
                        p_local_req,
                        OAM_MODULE_ID, SON_MODULE_ID,
                        trans_id,
                        curr_cid);

                if (OAM_FAILURE == ret_val) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Error in sending MRO_MODIFY_CONFIG_PARAM request");
                }
                else {
                    OAM_LOG(OAM, OAM_INFO,
                            "MRO_MODIFY_CONFIG_PARAM request sent successfully "
                            "to lower layer");
                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                                OAM_TRANS_SON,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }

                flag_found = OAM_ONE;
                break;
#endif

            case RRM_OAM_CELL_CONFIG_REQ_MASK :
                cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);

                    /* Free all the used up memory */
                    /*SPR 18504 FIX START*/
                    /*code deleted*/
                    /*SPR 18504 FIX END*/
                    ret_val = OAM_FAILURE;
                    flag_found = OAM_ONE;
                    break;
                }


                p_rrm_cell_config = &RRM_CELL_CONFIG(cell_config_idx);
                p_local_cell_config =
                    &LOCAL_RRM_CELL_CONFIG(cell_config_idx);

				cell_config_idx = oam_get_cell_plmnlist_data_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);

                    /* Free all the used up memory */
                    /*SPR 18504 FIX START*/
                    /*code deleted*/
                    /*SPR 18504 FIX END*/
                    ret_val = OAM_FAILURE;
                    flag_found = OAM_ONE;
                    break;
                }
                /* SPR 13501 FIX START */
                if (p_rrm_cell_config != NULL){
                    if(p_rrm_cell_config->operator_info.dynamic_icic_info.
                            bitmask & RRM_OAM_DL_RESOURCE_PARTITON_INFO_PRESENT) {
                        p_local_cell_config->operator_info.
                            bitmask |= RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT;
                        local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                            operator_info.dynamic_icic_info.
                            bitmask |= RRM_OAM_DL_RESOURCE_PARTITON_INFO_PRESENT;
                        token = strtok(temp_string, ",");

                        while (OAM_NULL != token) {
                            if (count < OAM_MAX_NUM_CC_REGION) {
                                /* Coverity_88724 Fix Start */    
                                if(sscanf( token, "%d", &var ) != 1){
                                    /* SPR 19078: CID 107858 Fix Start */
                                    return OAM_FAILURE;
                                }
                                /* SPR 19078: CID 107858 Fix End */
                                /* Coverity_88724 Fix End */    
                                local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                    operator_info.dynamic_icic_info.
                                    dl_resource_partition_info.
                                    cell_center_region[count].start_rb = var;
                                ++count;
                            }

                            token = strtok(OAM_NULL, ",");
                        }

                        token = strtok(temp_string_1, ",");
                        count = 0;

                        while (OAM_NULL != token) {
                            if (count < OAM_MAX_NUM_CC_REGION) {
                                /* Coverity_88724 Fix Start */    
                                if(sscanf( token, "%d", &var ) != 1){
                                    /* SPR 19078: CID 107858 Fix Start */
                                    return OAM_FAILURE;
                                }
                                /* SPR 19078: CID 107858 Fix End */
                                /* Coverity_88724 Fix End */    
                                local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                    operator_info.dynamic_icic_info.
                                    dl_resource_partition_info.
                                    cell_center_region[count].num_of_rb = var;

                                total_rbs += var;
                                ++count;
                            }

                            token = strtok(OAM_NULL, ",");
                        }

                        if(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                operator_info.dynamic_icic_info.
                                dl_resource_partition_info.
                                num_of_cell_edge_region > OAM_ZERO) {
                            local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                operator_info.dynamic_icic_info.
                                dl_resource_partition_info.bitmask |=
                                RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT;

                            total_rbs += local_prov_req.oam_rrm_req.
                                oam_rrm_cell_config_req[OAM_ZERO].operator_info.
                                dynamic_icic_info.
                                dl_resource_partition_info.
                                cell_edge_region.num_of_rb;
                        }
                        else {
                            local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                operator_info.dynamic_icic_info.
                                dl_resource_partition_info.bitmask = OAM_ZERO;

                            total_rbs += oam_prov_req.oam_rrm_req.
                                oam_rrm_cell_config_req[OAM_ZERO].operator_info.
                                dynamic_icic_info.
                                dl_resource_partition_info.
                                cell_edge_region.num_of_rb;
                        }

                        if (total_rbs > OAM_MAX_NUM_RBS) {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Total number of DL RBs[%d] "
                                    "excceed the max allowed value[%d]",
                                    total_rbs, OAM_MAX_NUM_RBS);

                            ret_val = OAM_FAILURE;
                            flag_found = 1;
                            *p_error_code = OAM_INVALID_REQ;
                            break;
                        }
                    }

                    if (p_rrm_cell_config->operator_info.dynamic_icic_info.
                            bitmask & RRM_OAM_UL_RESOURCE_PARTITION_INFO_PRESENT) {
                        total_rbs = OAM_ZERO;

                        local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                            operator_info.
                            bitmask |= RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT;
                        local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                            operator_info.dynamic_icic_info.
                            bitmask |= RRM_OAM_UL_RESOURCE_PARTITION_INFO_PRESENT; 
                        count = 0;
                        token = strtok(temp_string_2, ",");

                        while (OAM_NULL != token) {
                            if (count < OAM_MAX_NUM_CC_REGION) {
                                /* Coverity_88724 Fix Start */    
                                if(sscanf( token, "%d", &var ) != 1){
                                    /* SPR 19078: CID 107858 Fix Start */
                                    return OAM_FAILURE;
                                }
                                /* SPR 19078: CID 107858 Fix End */
                                /* Coverity_88724 Fix End */    
                                local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                    operator_info.dynamic_icic_info.
                                    ul_resource_partition_info.
                                    cell_center_region[count].start_rb = var;
                                ++count;
                            }

                            token = strtok(OAM_NULL, ",");
                        }
                        count = 0;
                        token = strtok(temp_string_3, ",");

                        while (OAM_NULL != token) {
                            if (count < OAM_MAX_NUM_CC_REGION) {
                                /* Coverity_88724 Fix Start */    
                                if(sscanf( token, "%d", &var ) != 1){
                                    /* SPR 19078: CID 107858 Fix Start */
                                    return OAM_FAILURE;
                                }
                                /* SPR 19078: CID 107858 Fix End */
                                /* Coverity_88724 Fix End */    
                                local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                    operator_info.dynamic_icic_info.
                                    ul_resource_partition_info.
                                    cell_center_region[count].num_of_rb = var;

                                total_rbs += var;
                                ++count;
                            }

                            token = strtok(OAM_NULL, ",");
                        }

                        if(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                operator_info.dynamic_icic_info.
                                ul_resource_partition_info.
                                num_of_cell_edge_region > OAM_ZERO) {
                            local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                operator_info.dynamic_icic_info.
                                ul_resource_partition_info.bitmask |=
                                RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT;

                            total_rbs += local_prov_req.oam_rrm_req.
                                oam_rrm_cell_config_req[OAM_ZERO].operator_info.
                                dynamic_icic_info.
                                ul_resource_partition_info.
                                cell_edge_region.num_of_rb;
                        }
                        else {
                            local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].
                                operator_info.dynamic_icic_info.
                                ul_resource_partition_info.bitmask = OAM_ZERO;

                            total_rbs += oam_prov_req.oam_rrm_req.
                                oam_rrm_cell_config_req[OAM_ZERO].operator_info.
                                dynamic_icic_info.
                                ul_resource_partition_info.
                                cell_edge_region.num_of_rb;
                        }

                        if (total_rbs > OAM_MAX_NUM_RBS) {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Total number of UL RBs[%d] "
                                    "excceed the max allowed value[%d]",
                                    total_rbs, OAM_MAX_NUM_RBS);

                            ret_val = OAM_FAILURE;
                            flag_found = 1;
                            *p_error_code = OAM_INVALID_REQ;
                            break;
                        }
                    }
                } 
                /* SPR 13501 FIX END */

                p_cell_local_plmnlist_data =
                    &LOCAL_RRM_PROV_REQ.plmnlist_data[cell_config_idx];

                p_cell_plmnlist_data =
                    &RRM_PROV_REQ.plmnlist_data[cell_config_idx];

                /* If state is not active, don't send message to lower layer,
                   just update the actual provisioning structure */
                if (OAM_CM_ST_ACTIVE !=  p_cm_cntxt->state) {
                    oam_memcpy(p_rrm_cell_config, p_local_cell_config,
                            sizeof(oam_rrm_cell_config_req_t));

                    /* SPR_19279_START */  //Moving to case RRM_OAM_PLMNLIST_CONFIG_REQ_MASK 
                    /* Code Deleted */
                    /* SPR_19279_END */

                    /* SPR 15527 START */
                    if(oam_prov_req.system_status.event_ongoing & 
                            OAM_MODIFY_QOS_OBJ_ONGOING)
                    {
                      /* Copy SPV Data to RRM Cell Config Structure */
                      for(Index = OAM_ZERO;Index<LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].num_qos_entries;Index++)
                      {
                        if(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].qos_enable == OAM_TRUE)
                        {
                          oam_memcpy((void *)&p_rrm_cell_config->
                              epc_info.epc_params.qos_config_params[qci_idx],
                              (void *)&LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].qos_qci_info,
                              sizeof(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].qos_qci_info));

                          if(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].drx_enabled == OAM_TRUE)
                          {
                            LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].drx_per_qci_info.
                              num_applicable_qci = OAM_ONE;
                            LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].drx_per_qci_info.
                              applicable_qci_list[OAM_ZERO] =
                              LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].qos_qci_info.qci;
                            oam_memcpy((void *)&p_rrm_cell_config->
                                ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_idx],
                                (void *)&LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].drx_per_qci_info,
                                sizeof(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list[Index].drx_per_qci_info));   
                            drx_idx++;
                          }
                          qci_idx++;
                        }
                      }/* End of For loop */
                      p_rrm_cell_config->
                        epc_info.epc_params.num_valid_qos_profiles = qci_idx;
                      p_rrm_cell_config->ran_info.mac_layer_params.
                        mac_layer_param_drx.num_valid_drx_profiles = drx_idx;

                    oam_memcpy(&oam_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list,
                            &local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list,
                            OAM_MAX_QOSLIST_OBJECTS*sizeof(oam_rrm_plmn_data_t));
                      /* Reset the flag as SPV has been committed */
                      oam_prov_req.system_status.event_ongoing &= 
                        ~OAM_MODIFY_QOS_OBJ_ONGOING;
                    }
                    /* SPR 15527 END */

                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Case RRM_OAM_CELL_CONFIG_REQ_MASK selected for api "
                            "RRM_OAM_CELL_RECONFIG_REQ");

                    /* SPR_19279_START */  //Moving to case RRM_OAM_PLMNLIST_CONFIG_REQ_MASK
                    /* Code Deleted */
                    /* SPR_19279_END */

                    oam_copy_config_to_reconfig(p_local_cell_config,
                            p_local_req); 

                    ret_val = oam_rrm_send_rrm_oam_cell_reconfig_req(
                            p_local_req,
                            src_module_id,
                            RRM_MODULE_ID,
                            tcb_transaction_id,
                            curr_cid);
                    if (OAM_FAILURE == ret_val) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Failed to send RRM_OAM_CELL_RECONFIG_REQ message to RRM");
                    }
                    else {
#ifndef OAM_UT_FRAMEWORK
                        oam_maintain_tcb_ext(tcb_transaction_id,
                                OAM_TRANS_RRM, msg_len,
                                p_api_buf, p_orig_parent,
                                p_req_parent,
                                p_p_xml_struct_addr);
#endif
                    }
                }/* End of else */

                flag_found = OAM_ONE;

                /* Free all the used up memory */
                /*SPR 18504 FIX START*/
                /*code deleted*/
                /*SPR 18504 FIX END*/
                break;

            case RRM_OAM_CELL_START_REQ_MASK:
                OAM_LOG(OAM, OAM_INFO, "Cell start requested for cell context: %d "
                        "from user interface", curr_cid);

                /* SPR Fix 21412 Start_Stop Start */
                cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
                /* SPR Fix 21412 Start_Stop End */

                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);

                    ret_val = OAM_FAILURE;
                    flag_found = 1;
                    break;
                }


                p_rrm_cell_config = &RRM_CELL_CONFIG(cell_config_idx);

                /*BUG 1248 FIX START*/
                p_cell_status = oam_get_cell_cntxt_status(curr_cid);
                if (p_cell_status == OAM_NULL) /* Cov 63647 Fix*/ 
                {
					OAM_LOG(OAM, OAM_WARNING, "No cell found for cell context[cid=%d]",
                            curr_cid);

                    ret_val = OAM_FAILURE;
                    flag_found = 1;
                    break;
                }



                if(!(p_cell_status->cell_state & OAM_CELL_ACTIVE))
                {
                    /*BUG 1248 FIX END*/
                    ret_val =
                        oam_rrm_send_rrm_oam_cell_start_req(
                                (rrm_oam_cell_start_req_t*)&OWN_CELL_CGI(cell_config_idx),
                                src_module_id,
                                RRM_MODULE_ID,
                                tcb_transaction_id,
                                curr_cid);


                    if (OAM_FAILURE == ret_val) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Error in sending RRM_OAM_CELL_START_REQ to RRM");

                    }
                    /* SPR 11243 Fix Start */
                    if((cell_to_be_started_by_operator == RRM_FALSE)&&
                            (!(p_cell_status->cell_event & OAM_USER_TRIGGERED_STOP)))
                    {
                        p_cell_status->send_initialization_req = OAM_TRUE;
                    }
                    /* SPR 11243 Fix End */

#ifndef OAM_UT_FRAMEWORK
                    oam_maintain_tcb(trans_id, OAM_TRANS_RRM,
                            msg_len, p_api_buf);
#endif
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "CELL cannot be started as Cell already in active mode");

                    resp_result = OAM_RESULT_FAILURE;
                    usr_err_code = OAM_ERR_REQUEST_DENIED;
                    oam_strncpy(cmd_status,"Cell is already in active State",
                            sizeof(cmd_status));
                    cmd_status_size = oam_strlen(cmd_status) + 1;
                    oam_construct_n_send_set_resp_to_usr(resp_result,
                            usr_err_code,
                            (UInt8*)cmd_status,
                            cmd_status_size,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dest_id,
                            trans_id,
                            OAM_ZERO,
                            OAM_ZERO,
                            p_error_code);
                }

                flag_found = OAM_ONE;
                break;

            case RRM_OAM_CELL_STOP_REQ_MASK:
                OAM_LOG(OAM, OAM_INFO, "Cell stop requested for cell context: %d "
                        "from user interface", curr_cid);
                /* SPR Fix 21412 Start_Stop Start */
                cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
                /* SPR Fix 21412 Start_Stop End */

                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }


                p_cell_status = oam_get_cell_cntxt_status(curr_cid);
                /* Coverity 63647 Fix Start */
                if (OAM_NULL == p_cell_status) 
                {
					OAM_LOG(OAM, OAM_WARNING, "No cell found for cell context: %d", curr_cid);
                    ret_val = OAM_FAILURE;
                    flag_found = OAM_ONE;
                    break;
                }
                /* Coverity 63647 Fix End */
                if(p_cell_status->cell_state & OAM_CELL_ACTIVE)
                {
                    ret_val =
                        oam_rrm_send_rrm_oam_cell_stop_req(
                                (rrm_oam_cell_stop_req_t*)(&OWN_CELL_CGI(cell_config_idx)),
                                src_module_id,
                                RRM_MODULE_ID,
                                tcb_transaction_id,
                                curr_cid);

                    if (OAM_FAILURE == ret_val) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Error in sending RRM_OAM_CELL_STOP_REQ to RRM");
                    }
                    else {
                        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_RRM,
                                    OAM_TRANS_RRM,msg_len,p_api_buf))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                            ret_val = OAM_FAILURE;
                        }
#endif
                        /* SPR 9620 CHANGE END */
                    }

                }
                else
                {
                    resp_result = OAM_RESULT_FAILURE;
                    usr_err_code = OAM_ERR_REQUEST_DENIED;
                    oam_strncpy(cmd_status,"Cell is already in Stop State", sizeof(cmd_status));
                    cmd_status_size = oam_strlen(cmd_status) + 1;
                    oam_construct_n_send_set_resp_to_usr(resp_result,
                            usr_err_code,
                            (UInt8*)cmd_status,
                            cmd_status_size,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dest_id,
                            trans_id,
                            OAM_ZERO,
                            OAM_ZERO,
                            p_error_code);

                } 

                flag_found = OAM_ONE;
                break; 

            case  RRM_OAM_RAC_ENABLE_REQ_MASK:

                OAM_LOG(OAM,OAM_DETAILED,
						"Case RRM_OAM_RAC_ENABLE_REQ_MASK selected for api "
						"RRM_OAM_RAC_ENABLE_REQ ");

                oam_rrm_rac_enable_disable_req_t oam_rrc_enable_disable_req;
                oam_memset(&oam_rrc_enable_disable_req, OAM_ZERO, sizeof(oam_rrm_rac_enable_disable_req_t));

                oam_rrc_enable_disable_req.bitmask = OAM_ZERO;
                oam_rrc_enable_disable_req.request_type = RRM_OAM_RAC_ENABLE;
                ret_val = oam_rrm_send_rrm_oam_rac_enable_disable_req(
                        &oam_rrc_enable_disable_req,
                        src_module_id,
                        RRM_MODULE_ID,
                        tcb_transaction_id,
                        curr_cid);

                if (OAM_FAILURE == ret_val)
                {
                    OAM_LOG(OAM,OAM_ERROR,
                            "Error in function oam_send_cell_start_req for RRM_OAM_RAC_ENABLE_DISABLE_REQ"
                            ", error code :%d",
                            *p_error_code);

                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_RAC_ENABLE_DISABLE_REQ Successfully sent");
                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_RRM,
                                OAM_TRANS_RRM,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }
                flag_found = OAM_ONE;

                break;


            case  RRM_OAM_RAC_DISABLE_REQ_MASK:

                OAM_LOG(OAM,OAM_DETAILED,
						"Case RRM_OAM_RAC_DISABLE_REQ_MASK selected for api "
						"RRM_OAM_RAC_DISABLE_REQ ");
                oam_memset(&oam_rrc_enable_disable_req, OAM_ZERO, sizeof(oam_rrm_rac_enable_disable_req_t));
                /*CSR:00057534_CHANGE_START*/                 
                oam_rrc_enable_disable_req.bitmask = OAM_ZERO;
                oam_rrc_enable_disable_req.request_type = RRM_OAM_RAC_DISABLE;
                /*CSR:00057534_CHANGE_END*/
                ret_val = oam_rrm_send_rrm_oam_rac_enable_disable_req(
                        &oam_rrc_enable_disable_req,
                        src_module_id,
                        RRM_MODULE_ID,
                        tcb_transaction_id,
                        curr_cid);

                if (OAM_FAILURE == ret_val)
                {     
                    OAM_LOG(OAM,OAM_ERROR,
                            "Error in function oam_send_cell_start_req for RRM_OAM_RAC_ENABLE_DISABLE_REQ"
                            ", error code :%d",
                            *p_error_code);

                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_RAC_ENABLE_DISABLE_REQ Successfully sent");
                    /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_RRM,
                                OAM_TRANS_RRM,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }

                flag_found = OAM_ONE;

                break;


			case RRM_OAM_CELL_DELETE_REQ_MASK:
				OAM_LOG(OAM, OAM_INFO, "Cell delete requested for cell context: %d "
						"from user interface", curr_cid);
                    		/*SPR 21369 Start*/
                rrm_oam_cell_delete_req_t  rrm_oam_cell_delete_req;          
				/* SPR 21478 Start */
                p_cell_status = oam_get_cell_cntxt_status(curr_cid);
				/* SPR 21478 End */
				/* Coverity 63647 Fix Start */
				if (OAM_NULL == p_cell_status) 
				{
					OAM_LOG(OAM, OAM_WARNING, "No cell found for cell context = %d", curr_cid);
					ret_val = OAM_FAILURE;
					flag_found = OAM_ONE;
					break;
				}
                                /* Coverity 63647 Fix End */
				if((!oam_prov_req.system_status.cell_setup_complete)&& 
						!(p_cell_status->cell_state & OAM_CELL_ACTIVE)){
					resp_result = OAM_RESULT_FAILURE;
					usr_err_code = OAM_ERR_REQUEST_DENIED;
					oam_strncpy(cmd_status,
							"Cell is not UP/configured yet, "
							"wait for cell setup to complete...",
							sizeof(cmd_status));
					cmd_status_size = oam_strlen(cmd_status) + 1;

					oam_construct_n_send_set_resp_to_usr(resp_result,
							usr_err_code,
							(UInt8*)cmd_status,
							cmd_status_size,
							OAM_VERSION_ID,
							OAM_MODULE_ID,
							dest_id,
							trans_id,
							OAM_ZERO,
							OAM_ZERO,
							p_error_code);
				}
                else {
                    /* SPR 21412 Fix Start */
                    cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
                    /* SPR 21412 Fix End */
                    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
						OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                curr_cid);
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                    /*SPR 21369 Start*/
                    oam_memcpy(&(rrm_oam_cell_delete_req.global_cell_id),&OWN_CELL_CGI(cell_config_idx),
                            sizeof(rrm_oam_eutran_global_cell_id_t));
                    /* SPR 22131 Fix Start */
                    rrm_oam_cell_delete_req.bitmask = OAM_ZERO;
                    /* SPR 22131 Fix End */
                    ret_val = oam_rrm_send_rrm_oam_cell_delete_req(
                            &rrm_oam_cell_delete_req,
                            src_module_id,
                            RRM_MODULE_ID,
                            tcb_transaction_id,
                            curr_cid);
                    /*SPR 21369 End*/
					if (OAM_FAILURE == ret_val) {
						OAM_LOG(OAM, OAM_ERROR,
								"Error sending RRM_OAM_CELL_DELETE_REQ to RRM");
					}
					else {
						OAM_LOG(OAM, OAM_INFO, "Sent RRM_OAM_CELL_DELETE_REQ to RRM");
						/* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_RRM,
                                    OAM_TRANS_RRM,msg_len,p_api_buf))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                            ret_val = OAM_FAILURE;
                        }
#endif
                        /* SPR 9620 CHANGE END */
                    }
                }

                flag_found = OAM_ONE;
                break;

            case OAM_RRM_CELL_BLOCK_REQ_MASK:
                p_cell_status = oam_get_cell_cntxt_status(curr_cid);
                /* Coverity 63647 Fix Start */
                if (OAM_NULL == p_cell_status) 
                {
					OAM_LOG(OAM, OAM_WARNING, "No cell found for cell context = %d", curr_cid);
                    ret_val = OAM_FAILURE;
                    flag_found = OAM_ONE;
                    break;
                }
                /* Coverity 63647 Fix End */

                OAM_LOG(OAM, OAM_INFO, "Cell block requested for cell context: %d "
                        "from user interface", curr_cid);

                cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                /*SPR 13518 START*/
                oam_memcpy(&(oam_prov_req.oam_rrm_req.rrm_cell_block_req.global_cell_id),
                        &(OWN_CELL_CGI(cell_config_idx)),
                        sizeof(rrm_oam_eutran_global_cell_id_t));

                oam_memcpy(&(oam_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_priority),
                        &(local_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_priority),
                        sizeof(rrm_oam_cell_block_priority_et));

                oam_memcpy(&(oam_prov_req.oam_rrm_req.rrm_cell_block_req.bitmask),
                        &(local_prov_req.oam_rrm_req.rrm_cell_block_req.bitmask),
                        sizeof(rrm_bitmask_t));

                /* SPR 20050 Fix Start */
                /* SPR 17955 Fix Start */
                if(0 != oam_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_priority)
                    /* SPR 20050 Fix End */
                {    
                    oam_prov_req.oam_rrm_req.rrm_cell_block_req.bitmask |= RRM_OAM_CELL_BLOCK_WAIT_TIMER_PRESENT; 
                    /* SPR 20050 Fix Start */
                } 
                /* SPR 20050 Fix End */
                /* SPR 17955 Fix End */

                oam_memcpy(&(oam_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_resource_cleanup_timer),
                        &(local_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_resource_cleanup_timer),
                        sizeof(SInt16));

                /*SPR 13518 END*/

                if(p_cell_status->cell_state & OAM_CELL_ACTIVE)
                {
                    ret_val =
                        /*SPR 13518 START*/
                        oam_rrm_send_rrm_oam_cell_block_req(
                                &oam_prov_req.oam_rrm_req.rrm_cell_block_req,
                                /*SPR 13518 END*/
                                src_module_id,
                                RRM_MODULE_ID,
                                tcb_transaction_id,
                                curr_cid);

                    if(OAM_FAILURE == ret_val) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Failed to send RRM_OAM_CELL_BLOCK_REQ message to lower layer.");

                        resp_result = OAM_RESULT_FAILURE;
                        usr_err_code = OAM_ERR_INTERNAL_ERROR;
                        oam_strncpy(cmd_status,
                                "Message sending to lower layer failed",
                                sizeof(cmd_status));
                        cmd_status_size = oam_strlen(cmd_status);

                        oam_construct_n_send_set_resp_to_usr(resp_result,
                                usr_err_code,
                                (UInt8*)cmd_status,
                                cmd_status_size,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                dest_id,
                                trans_id,
                                OAM_ZERO,
                                OAM_ZERO,
                                p_error_code);
                    }
                    else {
                        OAM_LOG(OAM, OAM_INFO,
                                "RRM_OAM_CELL_BLOCK_REQ Message sent to lower layer successfully");
                        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_RRM,
                                    OAM_TRANS_RRM,msg_len,p_api_buf))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                            ret_val = OAM_FAILURE;
                        }
#endif
                        /* SPR 9620 CHANGE END */
                    }
                }
                else {
                    resp_result = OAM_RESULT_FAILURE;
                    usr_err_code = OAM_ERR_REQUEST_DENIED;
                    oam_strncpy(cmd_status, "Cell Is already Blocked!!",
                            sizeof(cmd_status));
                    cmd_status_size = oam_strlen(cmd_status);

                    oam_construct_n_send_set_resp_to_usr(resp_result,
                            usr_err_code,
                            (UInt8*)cmd_status,
                            cmd_status_size,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dest_id,
                            trans_id,
                            OAM_ZERO,
                            OAM_ZERO,
                            p_error_code);
                }  

                flag_found = 1;
                break;

            case OAM_RRM_CELL_UNBLOCK_REQ_MASK :
                OAM_LOG(OAM, OAM_INFO, "Cell unblock requested for cell context: %d "
                        "from user interface", curr_cid);
                p_cell_status = oam_get_cell_cntxt_status(curr_cid);
                /* SPR 14413 Fix Start */

                oam_prov_req.system_status.op_state = ENODEB_OP_STATE_ENABLED;
                oam_prov_req.system_status.rftx_status= OAM_TRUE;
                if(OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode)
                {
                    oam_inform_value_change_event(OAM_ZERO,OAM_MODULE_ID,TR069_MODULE_ID);
                }

                /* SPR 14413 Fix End */
                /* Coverity 63647 Fix Start */
                if (OAM_NULL == p_cell_status) 
                {
					OAM_LOG(OAM, OAM_WARNING, "No cell found for cell context = %d", curr_cid);
                    ret_val = OAM_FAILURE;
                    flag_found = OAM_ONE;
                    break;
                }
                /* Coverity 63647 Fix End */

                if(OAM_SUCCESS == ret_val) {
                    cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
                    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
						OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                curr_cid);
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }

                    if(!(p_cell_status->cell_state & OAM_CELL_ACTIVE)) {
                        ret_val =
                            oam_rrm_send_rrm_oam_cell_unblock_cmd(
                                    (oam_rrm_cell_unblock_cmd_t*)
                                    (&(OWN_CELL_CGI(cell_config_idx))),
                                    src_module_id,
                                    RRM_MODULE_ID,
                                    tcb_transaction_id,
                                    curr_cid);

                        if(OAM_FAILURE == ret_val) {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Failed to send RRM_OAM_CELL_UNBLOCK_CMD");
                            oam_strncpy(cmd_status,
                                    "Message sending to lower layer failed",
                                    sizeof(cmd_status)); 
                            usr_err_code = OAM_ERR_RESOURCES_EXCEEDED;


                            resp_result = OAM_RESULT_FAILURE;
                        }
                        else {

                            p_cell_status->cell_event &= ~OAM_USER_TRIGGERED_STOP; 
                            p_cell_status->cell_state |= OAM_CELL_ACTIVE;
                            p_cell_status->cell_state &= ~OAM_CELL_IDLE;
                            p_cell_status->cell_state &= ~OAM_CELL_STOP;

                        /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
                        ret_val = oam_m2ap_cell_change_state_ind(curr_cid,
                                CELL_UNBLOCK);

                        if (OAM_SUCCESS == ret_val) 
                        {
                            OAM_LOG(OAM, OAM_DETAILED,
                                    "Successfully sent cell state "
                                    "Change Ind to M2AP");
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Failed to send cell state "
                                    "Change Ind to M2AP");
                        }
#endif
                        /* EMBMS Changes End */

                            resp_result = OAM_RESULT_SUCCESS;
                            OAM_LOG(OAM, OAM_INFO, "cell state = %s",
                                    (char *)oam_get_cell_state_string(p_cell_status->cell_state));

                        }
                    }
                    else 
                    {
						OAM_LOG(OAM, OAM_WARNING,
                                "CELL cannot be Unblock as Cell already in active mode");

                        resp_result = OAM_RESULT_FAILURE;
                        usr_err_code = OAM_ERR_REQUEST_DENIED;
                        oam_strncpy(cmd_status,"Cell is already in active State", sizeof(cmd_status));
                        cmd_status_size = oam_strlen(cmd_status) + 1;
                    }

                }
                else {
                    resp_result = OAM_RESULT_FAILURE;
                    usr_err_code = OAM_ERR_REQUEST_DENIED;
                }

                cmd_status_size = oam_strlen(cmd_status);

                oam_construct_n_send_set_resp_to_usr(resp_result,
                        usr_err_code,
                        (UInt8*)cmd_status,
                        cmd_status_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id,
                        OAM_ZERO,
                        OAM_ZERO,
                        p_error_code);

                flag_found = 1;
                break;

                /* SPR_19279_START */
            case RRM_OAM_PLMNLIST_CONFIG_REQ_MASK :
                cell_config_idx = oam_get_cell_plmnlist_data_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);

                    ret_val = OAM_FAILURE;
                    flag_found = OAM_ONE;
                    break;
                }

                /* Coverity 109468 + - Code Removed */
                p_cell_local_plmnlist_data =
                    &LOCAL_RRM_PROV_REQ.plmnlist_data[cell_config_idx];

                p_cell_plmnlist_data =
                    &RRM_PROV_REQ.plmnlist_data[cell_config_idx];

                /* validation to be done here */
                /* SPR 19977 Fix Start*/
                query_idx =p_cell_local_plmnlist_data->plmnlist_query_idx;
                OAM_LOG(OAM,OAM_DETAILED,"query_idx=%d",query_idx);
                if(OAM_FAILURE==validate_plmnlist_enable(&p_cell_local_plmnlist_data->plmn_entries[query_idx].enable,OAM_ZERO,OAM_NULL))
                {
                			OAM_LOG(OAM,OAM_WARNING,"Validation of plmnlist_enable FAIL");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;

                } 
                if(OAM_FAILURE==validate_plmnlist_isprimary(&p_cell_local_plmnlist_data->plmn_entries[query_idx].is_primary,OAM_ZERO,OAM_NULL))
                {
                			OAM_LOG(OAM,OAM_WARNING,"Validation of plmnlist_isprimary FAIL");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;

                }
                if(OAM_FAILURE==validate_plmnlist_plmnid(&p_cell_local_plmnlist_data->plmn_entries[query_idx].plmn_id,OAM_ZERO,OAM_NULL))
                {
                			OAM_LOG(OAM,OAM_WARNING,"Validation of plmnlist_plmnid FAIL");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;

                }
                /* SPR 19977 Fix End*/
                /* If state is not active, don't send message to lower layer,
                   just update the actual provisioning structure */
                if (OAM_CM_ST_ACTIVE !=  p_cm_cntxt->state) 
                {
                    /* Required for add/delete support */ 
                    if (oam_prov_req.system_status.event_ongoing &
                            OAM_CELL_PLMNLIST_CONFIG_ONGOING) {
                        oam_prov_req.system_status.event_ongoing &=
                            ~OAM_CELL_PLMNLIST_CONFIG_ONGOING;

                        oam_memcpy(&p_cell_plmnlist_data->plmn_entries,
                                &p_cell_local_plmnlist_data->plmn_entries,
                                sizeof(p_cell_plmnlist_data->plmn_entries));
                    }
                }
                else
                {    

                    OAM_LOG(OAM, OAM_DETAILED,
                            "Case RRM_OAM_PLMNLIST_CONFIG_REQ_MASK selected for api "
                            "RRM_OAM_PLMNLIST_CONFIG_REQ, Event %0x",oam_prov_req.system_status.event_ongoing);

                    if (oam_prov_req.system_status.event_ongoing &
                            OAM_CELL_PLMNLIST_CONFIG_ONGOING) 
                    {
                        query_idx = p_cell_local_plmnlist_data->plmnlist_query_idx;

                        /* Fill Primary PLMN for RRM  */
                        /* Populate Primary PLMNID (ECGI) */
                        for(idx = OAM_ZERO; idx < RRM_OAM_MAX_NUM_PLMNS; ++idx) 
                        {
                            if( (p_cell_plmnlist_data->is_valid_bitmap & (1 << idx)) &&
                                    (OAM_TRUE == (oam_bool_et)p_cell_plmnlist_data->plmn_entries[idx].enable) )
                            {
                                if(OAM_TRUE == (oam_bool_et)p_cell_plmnlist_data->plmn_entries[idx].is_primary)
                                {
                                    primary_plmn_idx = idx;
                                    oam_memcpy((void *)&(local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
                                                eutran_global_cell_id.primary_plmn_id),
                                            (void *)&p_cell_local_plmnlist_data->plmn_entries[primary_plmn_idx].plmn_id,
                                            sizeof(rrm_oam_cell_plmn_info_t));
                                }
                            }
                        }

                        /* SPR 19977 Fix Start*/
                        if( ((p_cell_plmnlist_data->plmn_entries[query_idx].is_primary) !=
                                    (p_cell_local_plmnlist_data->plmn_entries[query_idx].is_primary)) ||
                                ((p_cell_plmnlist_data->plmn_entries[query_idx].enable) !=
                                 (p_cell_local_plmnlist_data->plmn_entries[query_idx].enable)) ||
                                (OAM_ZERO != 
                                 (oam_memcmp((void *)&p_cell_local_plmnlist_data->plmn_entries[query_idx].plmn_id,  
                                             (void *)&p_cell_plmnlist_data->plmn_entries[query_idx].plmn_id,
                                             sizeof(p_cell_plmnlist_data->plmn_entries[query_idx].plmn_id)))) )  
                            /* SPR 19977 Fix End*/
                        {   

                            if (oam_prov_req.system_status.event_ongoing &
                                    OAM_CELL_PLMNLIST_CONFIG_ONGOING) {
                                UInt8 new_idx = 0;
                                /* SPR_20467_FIX_START */
                                SInt16 primary_idx = OAM_NEG_ONE;
                                /* SPR_20467_FIX_END */
                                oam_rrm_plmn_data_t *p_plmn_entries = OAM_NULL;
                                p_plmn_entries = p_cell_local_plmnlist_data->plmn_entries;

                                if (oam_prov_req.system_status.event_ongoing &
                                        OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING) {
                                    query_idx = p_cell_plmnlist_data->plmnlist_query_idx;

                                    if (p_plmn_entries[query_idx].is_primary) {
                                        for(idx = OAM_ZERO; idx < RRM_OAM_MAX_NUM_PLMNS; ++idx) {
                                            if(idx != query_idx) {
                                                p_plmn_entries[idx].is_primary = OAM_ZERO;
                                            }
                                            else {
                                                p_plmn_entries[idx].enable = 1;
                                            }
                                        }
                                    }
                                }

                                oam_memset(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                        supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity,
                                        OAM_ZERO,sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.
                                            enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity));

                                local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask = OAM_ZERO;

                                local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |= S1AP_OAM_ENB_CONFIG_UPDATE_TA_LIST_PRESENT;

                                for(idx = OAM_ZERO; idx < RRM_OAM_MAX_NUM_PLMNS; ++idx) {
                                    if( (p_cell_plmnlist_data->is_valid_bitmap & (1 << idx)) &&
                                            (p_plmn_entries[idx].enable) )
                                    {
                                        /* SPR_20467_FIX_START */
                                        if(p_plmn_entries[idx].is_primary) {
                                            primary_idx = idx;
                                        }
                                        /* SPR_20467_FIX_END */
                                        oam_update_plmnlist_from_mcc_mnc(
                                                &p_plmn_entries[idx].plmn_id,
                                                new_idx,&(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                                    supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list));


                                        ++new_idx;

                                        local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                            supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.num_bplmn = 
                                            new_idx;
                                    }
                                }
                                /*SPR 19977 Fix Start*/
                                if(p_plmn_entries[query_idx].enable && !(p_cell_plmnlist_data->is_valid_bitmap & (1 << query_idx)))
                                {
                                    oam_update_plmnlist_from_mcc_mnc(
                                            &p_plmn_entries[query_idx].plmn_id,
                                            new_idx,&(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                                supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list));


                                    ++new_idx;

                                    local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                        supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.num_bplmn = 
                                        new_idx;
                                }
                                /*SPR 19977 Fix End*/
                                OAM_LOG(OAM, OAM_DETAILED, "In %s, Number of valid PLMNIDs LOCAL BPLMN : %d",
                                        __FUNCTION__,local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                        supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.num_bplmn);


                                /* SPR_20467_FIX_START */
                                if(primary_idx > OAM_ZERO) {
                                    oam_memcpy(&tmp_plmnlist,
                                            &(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                                supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity[0].plmn_id),
                                            sizeof(bc_plmn_list_t));

                                    oam_memcpy(&(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                                supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity[0].plmn_id),
                                            &p_plmn_entries[primary_idx].plmn_id,
                                            sizeof(bc_plmn_list_t));


                                    oam_memcpy(&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.
                                            supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity[primary_idx].plmn_id,
                                            &tmp_plmnlist,
                                            sizeof(bc_plmn_list_t));
                                } 
                                /* SPR_20467_FIX_END */
                            }

                            OAM_LOG(OAM, OAM_DETAILED, "Sending s1ap_enb_config_update to L3, as PLMNID or Enable or IsPrimary has been changed");
                            oam_update_enb_config_info_from_current_mme_list();
                            /* SPR_20467_FIX_START/END */
                            UInt16 transaction_id = oam_get_new_trans_id();
                            ret_val = oam_s1ap_il_send_s1ap_oam_enb_config_update(
                                    &local_prov_req.oam_l3_req.
                                    oam_s1ap_req.enb_config_update,
                                    OAM_MODULE_ID,
                                    RRC_MODULE_ID,
                                    /* SPR_20467_FIX_START/END */
                                    transaction_id,
                                    curr_cid);

                            if (OAM_SUCCESS != ret_val)
                            {
                                OAM_LOG(OAM, OAM_WARNING, "Failed to send enb config update");
                            }
                            else
                            {
                                /* SPR_20467_FIX_START */
                                void *p_temp = OAM_NULL;
                                p_temp = oam_maintain_tcb_for_ecu(transaction_id, OAM_TRANS_X2AP,
                                        msg_len,p_api_buf,sizeof(oam_s1ap_ecu_resp_data_t),OAM_NULL,OAM_FALSE);

                                if (OAM_NULL == p_temp) {
                                    OAM_LOG(OAM, OAM_WARNING, "Failed to maintain TCB ");
                                    break;
                                }
                                oam_prov_req.system_status.timer_id = oam_start_guard_timer(transaction_id,OAM_SUB_MODULE_MIH,
                                        OAM_MODULE_ID,
                                        OAM_ENB_CONFIG_UPDATE_TIMER,
                                        OAM_USER_INTF_RESP_TIMEOUT_S * OAM_THOUSAND,
                                        (UInt8 *)p_temp,
                                        msg_len,
                                        OAM_FALSE);

                                ret_val = oam_maintain_tcb_ext(trans_id, OAM_TRANS_SON,
                                        msg_len, p_api_buf,p_orig_parent,p_req_parent,
                                        p_p_xml_struct_addr);

                                if (OAM_FAILURE == ret_val) {
                                    OAM_LOG(OAM, OAM_WARNING, "Failed to maintain TCB ");
                                    break;
                                }
                                /* SPR_20467_FIX_END */
                            }
                        }
                        else
                        {
                            p_cell_plmnlist_data->plmnlist_cache_idx =
                                query_idx + 1;
                            oam_memcpy(&p_cell_plmnlist_data->plmnlist_cache,
                                    &p_cell_local_plmnlist_data->
                                    plmn_entries[query_idx],
                                    sizeof(oam_rrm_plmn_data_t));

                            OAM_LOG(OAM, OAM_DETAILED,"SEND oam_construct_n_send_set_resp_to_usr");
                            oam_construct_n_send_set_resp_to_usr(
                                    OAM_RESULT_SUCCESS,
                                    OAM_ZERO, OAM_NULL,
                                    OAM_ZERO,
                                    OAM_VERSION_ID,
                                    OAM_MODULE_ID,
                                    dest_id,
                                    trans_id,
                                    OAM_ZERO, OAM_ZERO,
                                    p_error_code);

                            /* SPR_20467_FIX_START */
                            oam_prov_req.system_status.event_ongoing &=
                                ~OAM_CELL_PLMNLIST_CONFIG_ONGOING;

                            oam_prov_req.system_status.event_ongoing &=
                                ~OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING;

                            oam_prov_req.system_status.event_ongoing &= ~OAM_ADD_OBJ_ONGOING;
                            /* SPR_20467_FIX_END */
                            ret_val = OAM_SUCCESS;
                        }    
                    }
                }
                flag_found = OAM_ONE;
                break;
                /* SPR_19279_END */

#ifdef OAM_SON_ENABLE
            case OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK:

                /* BUG_FIXED_11744_START */ 
                OAM_LOG(OAM, OAM_DETAILED, "case OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK"
                        "for api SON_POAM_RACH_OPT_MODIFY_CONFIG_PARAMS_REQ");
                cell_config_idx = oam_get_son_serving_cell_idx(
                        oam_prov_req.cell_cntxt.curr_cell_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            oam_prov_req.cell_cntxt.curr_cell_cid);
                    return OAM_FAILURE;
                }



                ret_val = oam_son_send_son_oam_rach_opt_modify_config_params_req(
                        p_local_req,
                        OAM_MODULE_ID,
                        SON_MODULE_ID,
                        tcb_transaction_id,
                        curr_cid);

                if (OAM_FAILURE == ret_val) {
                    OAM_LOG(OAM,OAM_ERROR,
                            "Error in sending SON_OAM_RACH_OPT_MODIFY_CONFIG_PARAMS_REQ to lower layer");
                }
                else {
#ifndef OAM_UT_FRAMEWORK
                    oam_maintain_tcb(tcb_transaction_id,
                            OAM_TRANS_SON,
                            msg_len,
                            p_api_buf);
#endif
                    OAM_LOG(OAM, OAM_DETAILED,
                            "SON_OAM_RACH_OPT_MODIFY_CONFIG_PARAMS_REQ message "
                            "sent to lower layery successfully");
                }

                flag_found = OAM_ONE;

                /* BUG_FIXED_11744_END */               

                break;

                /* BUG_1171_START */
            case SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_MASK:
                {
                    OAM_LOG(OAM, OAM_DETAILED, "case SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_MASK for api SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_REQ");
                    ret_val = oam_son_send_son_oam_pci_conflict_enable_disable_req(
                            &LOCAL_SON_PROV_REQ.oam_son_pci_conflict_enable_disable_req,
                            OAM_MODULE_ID, SON_MODULE_ID, tcb_transaction_id,
                            curr_cid);
                    if (OAM_FAILURE == ret_val) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Sending SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_REQ failed");
                    }
                    else {
#ifndef OAM_UT_FRAMEWORK
                        oam_maintain_tcb(tcb_transaction_id,
                                OAM_TRANS_SON,
                                msg_len,
                                p_api_buf);
#endif
                        OAM_LOG(OAM, OAM_INFO,
                                "SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_REQ sent successfully");
                    }
                    flag_found = OAM_ONE;
                }
                break;
                /* BUG_1171_END */

            case OAM_SON_ANR_MODIFY_UE_COUNT_MASK:
                OAM_LOG(OAM, OAM_INFO,
                        "Request to modify ANR UE count received from user");
                ret_val = oam_son_send_son_oam_anr_modify_ue_count_req(
                        p_local_req,
                        OAM_MODULE_ID,
                        SON_MODULE_ID,
                        tcb_transaction_id,
                        curr_cid);

                if (OAM_FAILURE == ret_val) {     
                    OAM_LOG(OAM, OAM_ERROR,
                            "Sending SON_OAM_ANR_MODIFY_UE_COUNT_REQ to lower layer failed");
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Sending SON_OAM_ANR_MODIFY_UE_COUNT_REQ to lower layer successful");
                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_SON,
                                OAM_TRANS_SON,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }
                break; 

            case OAM_SON_ANR_MODIFY_MEAS_REPORTING_INTERVAL_MASK:
                ret_val =
                    oam_son_send_son_oam_anr_modify_meas_reporting_interval_req(
                            p_local_req, 
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            tcb_transaction_id,
                            curr_cid);

                if (OAM_FAILURE == ret_val) {     
                    OAM_LOG(OAM, OAM_ERROR,
                            "Sending SON_OAM_ANR_MODIFY_MEAS_REPORTING_INTERVAL_REQ message to lower layer failed");
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Sending SON_OAM_ANR_MODIFY_MEAS_REPORTING_INTERVAL_REQ message to lower layer success");

                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_SON,
                                OAM_TRANS_SON,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }
                break; 

            case OAM_SON_ANR_MODIFY_REMOVAL_ATTRIBUTES_MASK:
                ret_val =
                    oam_son_send_son_oam_anr_modify_removal_attributes_req(
                            p_local_req, 
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            tcb_transaction_id,
                            curr_cid);

                if (OAM_FAILURE == ret_val) {     
                    OAM_LOG(OAM, OAM_ERROR,
                            "Sending SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_REQ  message to lower layer failed");
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Sending SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_REQ message to lower layer success");
                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_SON,
                                OAM_TRANS_SON,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }
                break; 



            case OAM_SON_ANR_MODIFY_PCI_CONFUSION_CFG_MASK:
                cell_config_idx = oam_get_son_serving_cell_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                    OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                            curr_cid);
                    return OAM_FAILURE;
                }

                ret_val =
                    oam_son_send_son_oam_anr_modify_pci_confusion_cfg_req(
                            p_local_req, 
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            tcb_transaction_id,
                            curr_cid);

                if (OAM_FAILURE == ret_val)
                {     
					OAM_LOG(OAM, OAM_WARNING,
                            "Sending SON_OAM_ANR_MODIFY_PCI_CONFUSION_CFG_REQ message to lower layer failed");
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Sending SON_OAM_ANR_MODIFY_PCI_CONFUSION_CFG_REQ message to lower layer success");
                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_SON,
                                OAM_TRANS_SON,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }
                break; 

            case OAM_SON_ANR_MEAS_CONFIG_MASK:
                cell_config_idx = oam_get_son_inter_freq_carrier_idx(curr_cid);

                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);
                    flag_found = 1;
                    ret_val = OAM_FAILURE;
                    break;
                }

                p_son_inter_freq_carr_params =
                    &SON_INTER_FREQ_CARR_PARAMS(cell_config_idx);
                p_local_son_inter_freq_carr_params =
                    &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx);

                if(p_cm_cntxt->state != OAM_CM_ST_ACTIVE) {
                    /* SPR 14651 START */
                    oam_prov_req.system_status.event_ongoing &=
                        ~USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;

                    UInt8 idx = p_local_son_inter_freq_carr_params->query_index;

                    /* SPR 14651 END */
                    oam_memcpy(&p_son_inter_freq_carr_params->
                            oam_son_anr_meas_config_req,
                            &p_local_son_inter_freq_carr_params->
                            oam_son_anr_meas_config_req,
                            sizeof(oam_son_anr_meas_config_req_t));

                    /* SPR 14651 START */
                    if(LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_config_idx).eutran_config_list_size)
                    {
                        oam_memcpy(&p_son_inter_freq_carr_params->eutran_meas_enable[idx],
                                &p_local_son_inter_freq_carr_params->eutran_meas_enable[idx],
                                sizeof(oam_son_meas_obj_enable_t));
                    }
                    else if(LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_config_idx).other_rat_config_list.
                            utran_config_list.utran_fdd_list_size)
                    {
                        oam_memcpy(&p_son_inter_freq_carr_params->utran_meas_enable[idx],
                                &p_local_son_inter_freq_carr_params->utran_meas_enable[idx],
                                sizeof(oam_son_meas_obj_enable_t));
                    }
                    else if(LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_config_idx).other_rat_config_list.
                            geran_config_list.geran_freq_info_list_size) {

                        oam_memcpy(&p_son_inter_freq_carr_params->geran_meas_enable[idx],
                                &p_local_son_inter_freq_carr_params->geran_meas_enable[idx],
                                sizeof(oam_son_meas_obj_enable_t));
                    }
                    /* SPR 14651 END */

                    ret_val = OAM_SUCCESS;
                    flag_found = OAM_ONE;
                    break;
                }


                /* This function implicitly uses the global:
                   LOCAL_SON_PROV_REQ.
                   oam_son_inter_freq_carrier_params.
                   oam_son_anr_meas_config_req, no need to pass it as
                   parameter
                   */

                trans_id = oam_get_new_trans_id();
                /* SPR 17777 fix */
                ret_val = oam_validate_send_anr_meas_config_req(
                        /* SPR 14651 START */
                        p_api_buf,
                        trans_id,
                        cell_config_idx,
                        &is_dom_update_reqd,
                        p_error_code);


                if((OAM_FAILURE == ret_val)||
                        ((OAM_SUCCESS == ret_val)&&
                         (OAM_TRUE == is_dom_update_reqd)))

                {
                    if(OAM_FAILURE == ret_val)
                    {
                        OAM_LOG(OAM, OAM_ERROR,
                                "SON_OAM_ANR_MEAS_CONFIG_REQ API sending failed"
                                " with error code: %d", *p_error_code);
                    }
                    /* SPR 14651 END */
                    oam_update_xml_dom(ret_val,
                            p_orig_parent, p_req_parent,
                            p_p_xml_struct_addr);

                    oam_prov_req.system_status.
                        event_ongoing &= ~OAM_ADD_OBJ_ONGOING;
                }
                else {
#ifndef OAM_UT_FRAMEWORK
                    oam_maintain_tcb_ext(trans_id, OAM_TRANS_SON,
                            msg_len, p_api_buf,
                            p_orig_parent, p_req_parent,
                            p_p_xml_struct_addr);
#endif
                }

                flag_found = OAM_ONE;
                break;

                /**** DROP 4 CODE ****/
                /* SPR-13586 START */
            case SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN:
                /* SPR-13586 END */
            case SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER:
            case SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK:
                cell_config_idx = oam_get_son_cell_nr_list_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);
                    flag_found = 1;
                    ret_val = OAM_FAILURE;
                    break;
                }

                p_local_son_nr_add = &LOCAL_SON_NR_ADD_REQ(cell_config_idx);
                p_son_nr_add = &SON_NR_ADD_REQ(cell_config_idx);

                /* Populate Source CGI */
                oam_memcpy(&p_local_son_nr_add->src_cgi,
                        &p_son_nr_add->src_cgi,
                        sizeof(son_intra_rat_global_cell_id_t));

                if(p_cm_cntxt->state != OAM_CM_ST_ACTIVE) {
                    oam_son_handle_init_nr_req();
                    ret_val = OAM_SUCCESS;
                    flag_found = OAM_ONE;
                    break;
                }


                /* Single list element shall be added for now */
                /* SPR-13586 START */ 
                if((SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER == api_index) || 
                        (SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER_GERAN == api_index))
                {
                    /* SPR-13586 END */
                    p_local_son_nr_add->nr_list.inter_rat_nr_list_size = OAM_ONE;
                    p_local_son_nr_add->nr_list.intra_rat_nr_list_size = OAM_ZERO;
                }
                else {
                    p_local_son_nr_add->nr_list.inter_rat_nr_list_size = OAM_ZERO;
                    p_local_son_nr_add->nr_list.intra_rat_nr_list_size = OAM_ONE;
                }

                /* This function implicitly uses the global
                 * oam_son_nr_add_req 
                 */
                /* SPR-13586 START */
                ret_val =
                    oam_validate_send_son_nr_add_upd_req(p_api_buf,
                            tcb_transaction_id,
                            p_error_code,
                            /* SPR 18930  FIX START */
                            api_index,
                            &is_dom_update_reqd);
                /* SPR 18930  FIX END */

                /* SPR-13586 END */
                /* SPR 18930  FIX START */
                if((OAM_FAILURE == ret_val) ||
                        ((OAM_TRUE == is_dom_update_reqd) &&
                         (OAM_SUCCESS == ret_val))){

                    OAM_LOG(OAM, OAM_INFO, "is_dom_update_reqd = %d ",is_dom_update_reqd);
                    if(OAM_FAILURE == ret_val)
                    {
                        OAM_LOG(OAM, OAM_ERROR, "Error in sending "
                                "SON_OAM_NR_ADD_REQ message: error code :%d", *p_error_code);
                    }
                    /* SPR 18930  FIX END */
                    oam_update_xml_dom(ret_val,
                            p_orig_parent, p_req_parent,
                            p_p_xml_struct_addr);

                    oam_prov_req.system_status.
                        event_ongoing &= ~OAM_ADD_OBJ_ONGOING;
                }
                else {
#ifndef OAM_UT_FRAMEWORK      
                    oam_maintain_tcb_ext(tcb_transaction_id, OAM_TRANS_SON,
                            msg_len, p_api_buf,
                            p_orig_parent, p_req_parent,
                            p_p_xml_struct_addr);
#endif
                }

                flag_found = OAM_ONE;
                break;
                /* SPR 17880 START */
            case OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK:
                {
                    OAM_LOG(OAM, OAM_DETAILED, "case OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK for api OAM_TR059_MANAGEMENT_SERVER_PARAM_MASK");
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & ENABLE_CWMP_PRESENT)
                    {
                        oam_prov_req.oam_tr069_req.tr069_init_params.EnableCWMP = 
                            local_prov_req.oam_tr069_req.tr069_init_params.EnableCWMP;
                        //                        local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~ENABLE_CWMP_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_ENABLE_PRESENT)
                    {
                        oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformEnable= 
                            local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformEnable;
                        //                      local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~PERIODIC_INFORM_ENABLE_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_INTERVAL_PRESENT)
                    {
                        oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformInterval= 
                            local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformInterval;
                        //                    local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~PERIODIC_INFORM_INTERVAL_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PERIODIC_INFORM_TIME_PRESENT)
                    {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime,
                                &local_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime,
                                sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime));
                        //                  local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~PERIODIC_INFORM_TIME_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CONNECTION_REQUEST_USERNAME_PRESENT)
                    {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername,
                                &local_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername,
                                sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername));
                        //                local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~CONNECTION_REQUEST_USERNAME_PRESENT;
                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CONNECTION_REQUEST_PASSWORD_PRESENT)
                    {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword,
                                &local_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword,
                                sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword));
                        //              local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~CONNECTION_REQUEST_PASSWORD_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CWMP_RETRY_MINIMUM_WAIT_INTERVAL_PRESENT)
                    {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryMinimumWaitInterval,
                                &local_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryMinimumWaitInterval,
                                sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryMinimumWaitInterval));
                        //            local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~CWMP_RETRY_MINIMUM_WAIT_INTERVAL_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CWMP_RETRY_INTERVAL_MULTIPLIER_PRESENT)
                    {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryIntervalMultiplier,
                                &local_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryIntervalMultiplier,
                                sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryIntervalMultiplier));
                        //                        local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~CWMP_RETRY_MINIMUM_WAIT_INTERVAL_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & CON_REQ_URL_PRESENT)
                    {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.ConReqURL,
                                // &local_prov_req.oam_tr069_req.tr069_init_params.ConReqURL,
                                &local_prov_req.oam_igd_params.management_server_params.ConReqURL,
                                sizeof(local_prov_req.oam_igd_params.management_server_params.ConReqURL));
                        //                      local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~CON_REQ_URL_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & SERVING_HEMS_ADDRESS_PRESENT)
                    {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.serving_hems_address,
                                &local_prov_req.oam_tr069_req.tr069_init_params.serving_hems_address,
                                sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.serving_hems_address));
                        //                        local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~SERVING_HEMS_ADDRESS_PRESENT;

                    } 
                    if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & INITIAL_HEMS_ADDRESS_PRESENT)
                    {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.initial_hems_address,
                                &local_prov_req.oam_tr069_req.tr069_init_params.initial_hems_address,
                                        sizeof(oam_prov_req.oam_tr069_req.tr069_init_params.initial_hems_address));
  //                      local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~INITIAL_HEMS_ADDRESS_PRESENT;

                   }

                   if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & USERNAME_PRESENT)
                   {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.Username,
                                        &local_prov_req.oam_tr069_req.tr069_init_params.Username,
                                        sizeof(local_prov_req.oam_tr069_req.tr069_init_params.Username));
  //                      local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~INITIAL_HEMS_ADDRESS_PRESENT;

                }

                   if (local_prov_req.oam_tr069_req.tr069_init_params.bitmask & PASSWORD_PRESENT )
                   {
                        oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params.Password,
                                        &local_prov_req.oam_tr069_req.tr069_init_params.Password,
                                        sizeof(local_prov_req.oam_tr069_req.tr069_init_params.Password));
  //                      local_prov_req.oam_tr069_req.tr069_init_params.bitmask |= ~INITIAL_HEMS_ADDRESS_PRESENT;

                   }
                    /* trigger the new API constructed */
                    if (oam_construct_n_send_set_parameter_ind(p_error_code, trans_id) == OAM_FAILURE)
                    {
                        OAM_LOG(OAM, OAM_WARNING,"Error sending set_parameter_indication" ,dest_id);

                }

                    /* send the SPV response  */
                    oam_construct_n_send_set_resp_to_usr(
                            OAM_RESULT_SUCCESS,
                            OAM_ZERO,
                            OAM_NULL, OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dest_id, trans_id,
                            OAM_ZERO, OAM_ZERO,
                            p_error_code);

                    oam_memset(&local_prov_req.oam_tr069_req.tr069_init_params, OAM_ZERO, 
                            sizeof(local_prov_req.oam_tr069_req.tr069_init_params));
                    flag_found = OAM_ONE;

                    break;
                }
            /* SPR 17880 END */
			case OAM_LOCAL_PARAMS_MASK:
			case OAM_FTP_PARAMS_MASK:
			case OAM_TR069_PARAMS_MASK:

				/* Spr 13010 Fix Start */
				/* These parameters are saved locally at OAM, so
				 * no wating for layer response, just update the XML DOM
				 */
				oam_update_xml_dom(OAM_SUCCESS,
						p_orig_parent, p_req_parent,
						p_p_xml_struct_addr);
				/* Spr 13010 Fix End */

				if(OAM_LOCAL_PARAMS_MASK == api_index) {
					oam_memcpy(&oam_prov_req.oam_igd_params,
							&local_prov_req.oam_igd_params,
							sizeof(oam_igd_params_t));
					/* Spr 13010 Fix :removed Code */

                    }
				else if(OAM_FTP_PARAMS_MASK == api_index)
				{
					oam_memcpy(&oam_prov_req.oam_nms_ftp_server_params,
							&local_prov_req.oam_nms_ftp_server_params,
							sizeof(oam_nms_ftp_server_params_t));

                    }
                    else {
					oam_memcpy(&oam_prov_req.oam_tr069_req.tr069_init_params,
							&local_prov_req.oam_tr069_req.tr069_init_params,
							sizeof(oam_init_tr069_params_t));

					cell_config_idx = oam_get_cell_plmnlist_data_idx(curr_cid);
					if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
						OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                    curr_cid);
						flag_found = 1;
						ret_val = OAM_FAILURE;
						break;
                        }

					p_cell_local_plmnlist_data =
						&LOCAL_RRM_PROV_REQ.plmnlist_data[cell_config_idx];

					p_cell_plmnlist_data =
						&RRM_PROV_REQ.plmnlist_data[cell_config_idx];

					p_cell_plmnlist_data->plmn_entries[OAM_ZERO].
						is_primary = p_cell_local_plmnlist_data->
						plmn_entries[OAM_ZERO].is_primary;
				}

				oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
						OAM_ZERO,
						OAM_NULL, OAM_ZERO,
						OAM_VERSION_ID,
						OAM_MODULE_ID,
						dest_id, trans_id,
						OAM_ZERO, OAM_ZERO,
						p_error_code);

				flag_found = OAM_ONE;
				break;

			case OAM_SON_NR_ENB_REQ_MASK:

				OAM_LOG(OAM,OAM_DETAILED,
						"Case OAM_SON_NR_ENB_REQ_MASK selected");
#ifndef OAM_UT_FRAMEWORK
				oam_maintain_tcb(tcb_transaction_id,OAM_TRANS_SON,msg_len,p_api_buf);
#endif
				/*IPv6 Start */
				for (Index = OAM_ZERO; Index <= OAM_ONE; Index++)
				{
					if ('\0' != local_prov_req.son_enb_tnl_ip_address[Index][OAM_ZERO])
					{
						LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.
							nbr_enb_list[OAM_ZERO].bitmask |= SON_ANR_ENB_TNL_ADD_LIST_PRESENT;
						/* SPR 11553 FIX START */
						if(oam_isValidIp4((UInt8 *)local_prov_req.son_enb_tnl_ip_address[Index])==OAM_ONE)                                                           {
							change_address_format(local_prov_req.son_enb_tnl_ip_address[Index],
									LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.
									nbr_enb_list[OAM_ZERO].enb_tnl_address_list[Index].ipv4_add);
							LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.
								nbr_enb_list[OAM_ZERO].enb_tnl_address_list[Index].bitmask |= IPV4_ADD_PRESENT;
							LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.
								nbr_enb_list[OAM_ZERO].enb_tnl_address_list_size +=OAM_ONE;
							/* SPR 11553 FIX END */
						}else if(oam_isValidIp6((UInt8 *)local_prov_req.son_enb_tnl_ip_address[Index])==OAM_ONE)
						{
							OAM_INET_PTON(AF_INET6,(char *)local_prov_req.son_enb_tnl_ip_address[Index],LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].enb_tnl_address_list[Index].ipv6_add);
							LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.
								nbr_enb_list[OAM_ZERO].enb_tnl_address_list[Index].bitmask |= IPV6_ADD_PRESENT;
							LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.
								nbr_enb_list[OAM_ZERO].enb_tnl_address_list_size+= OAM_ONE;
						}
					}
					local_prov_req.son_enb_tnl_ip_address[Index][OAM_ZERO]='\0';
				}
				/*IPv6 End */
				if (OAM_NR_ENB_ACTION_ADD == LOCAL_SON_PROV_REQ.nr_enb_action)
				{
					LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.nbr_enb_list_size = OAM_ONE;

					ret_val = oam_son_send_son_oam_nr_enb_add_req(
							((oam_son_nr_enb_add_req_t *)
							 (&(LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req))),
							src_module_id, SON_MODULE_ID, tcb_transaction_id,
							curr_cid);

					if (OAM_FAILURE == ret_val)
					{
						OAM_LOG(OAM,OAM_ERROR,
								"Error in function "
								"oam_son_send_son_oam_nr_enb_add_req"
								": error code :%d",
								*p_error_code);

					}   
					oam_prov_req.system_status.event_ongoing |= OAM_SON_ADD_NR_ENB_ONGOING;
				}
				else if (OAM_NR_ENB_ACTION_UPDATE == LOCAL_SON_PROV_REQ.nr_enb_action)
				{
					LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.nbr_enb_list_size = OAM_ONE;

					ret_val = oam_son_send_son_oam_nr_enb_update_req(
							((oam_son_nr_enb_update_req_t *)
							 (&(LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req))),
							src_module_id, SON_MODULE_ID,
							tcb_transaction_id,
							curr_cid);

					if (OAM_FAILURE == ret_val)
					{
						OAM_LOG(OAM,OAM_ERROR,
								"Error in function oam_son_send_son_oam_nr_enb_update_req:"
								" error code :%d",
								*p_error_code);

					}   
				}
				else if (OAM_NR_ENB_ACTION_DELETE == LOCAL_SON_PROV_REQ.nr_enb_action)
				{

					oam_son_nr_enb_delete_req_t    oam_son_nr_enb_delete_req;

					oam_son_nr_enb_delete_req.nbr_enb_id_list_size = OAM_ONE;

					oam_son_nr_enb_delete_req.nbr_enb_id_list[OAM_ZERO] = LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].enb_id;

					ret_val = oam_son_send_son_oam_nr_enb_delete_req(
							(&oam_son_nr_enb_delete_req),
							src_module_id, SON_MODULE_ID,
							tcb_transaction_id,
							curr_cid);

					if (OAM_FAILURE == ret_val)
					{
						OAM_LOG(OAM,OAM_ERROR,
								"Error in function oam_son_send_son_oam_nr_enb_delete_req:"
								" error code :%d",
								*p_error_code);

					}   
				}

				flag_found = OAM_ONE;
				break;

			case SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_REQ_MASK:
				cell_config_idx = oam_get_son_serving_cell_idx(curr_cid);
				if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                                curr_cid);
					return OAM_FAILURE;
				}

				oam_memcpy(
						&(LOCAL_SON_PROV_REQ.oam_son_es_modify_ue_count_interval_req.
							srv_cgi),
						&(SON_CELL_INFO_IND_SERVING_CELL(cell_config_idx).src_cgi),
						sizeof(son_intra_rat_global_cell_id_t));

				ret_val = oam_son_send_son_oam_es_modify_ue_count_interval_req(
						&(LOCAL_SON_PROV_REQ.oam_son_es_modify_ue_count_interval_req),
						OAM_MODULE_ID,
						SON_MODULE_ID,
						tcb_transaction_id,
						curr_cid);

				if (OAM_FAILURE == ret_val)
				{
					OAM_LOG(OAM, OAM_ERROR,
							"Error in sending SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_REQ");
				}
				else {
					OAM_LOG(OAM, OAM_DETAILED, "Successfully sent "
							"SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_REQ");
#ifndef OAM_UT_FRAMEWORK      
					oam_maintain_tcb(tcb_transaction_id,
							OAM_TRANS_SON,
							msg_len,
							p_api_buf);
#endif
				}

				flag_found = OAM_ONE;
				break;

			case SON_OAM_ES_AUTONOMOUS_CELL_SWITCH_OFF_REQ_MASK:
				cell_config_idx = oam_get_son_serving_cell_idx(curr_cid);
				if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                                curr_cid);
					return OAM_FAILURE;
				}

				LOCAL_SON_PROV_REQ.autonomous_switch_off_config_req.
					src_cgi_list_size = OAM_ONE;

				oam_memcpy(&(LOCAL_SON_PROV_REQ.autonomous_switch_off_config_req.
							cell_id[0]),
						&(SON_CELL_INFO_IND_SERVING_CELL(cell_config_idx).
							src_cgi),
						sizeof(son_intra_rat_global_cell_id_t));

				ret_val =
					oam_son_send_son_oam_es_autonomous_switch_off_config_req(
							p_local_req,
							OAM_MODULE_ID,
							SON_MODULE_ID,
							tcb_transaction_id,
							curr_cid);

				if(OAM_FAILURE == ret_val) {
					OAM_LOG(OAM, OAM_ERROR, "Error in sending: "
							"SON_OAM_ES_AUTONOMOUS_SWITCH_OFF_CONFIG_REQ, cell context = %d",
                                                        curr_cid);
				}
#ifndef OAM_UT_FRAMEWORK 
				else {
					OAM_LOG(OAM, OAM_INFO, "Successfully sent "
							"SON_OAM_ES_AUTONOMOUS_SWITCH_OFF_CONFIG_REQ, cell context = %d",
							curr_cid);

					oam_maintain_tcb(tcb_transaction_id,
							OAM_TRANS_SON,
							msg_len,
							p_api_buf);
				}
#endif
				flag_found = OAM_ONE;

				break;

			case  SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_REQ_MASK:
				cell_config_idx = oam_get_son_serving_cell_idx(curr_cid);
				if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                                curr_cid);
					return OAM_FAILURE;
				}

				oam_memcpy(
						&(LOCAL_SON_PROV_REQ.oam_son_es_modify_ue_count_threshold_req.
							srv_cgi),
						&(SON_CELL_INFO_IND_SERVING_CELL(cell_config_idx).
							src_cgi),
						sizeof(son_intra_rat_global_cell_id_t));

				ret_val = oam_son_send_son_oam_es_modify_ue_count_threshold_req(
						&(LOCAL_SON_PROV_REQ.oam_son_es_modify_ue_count_threshold_req),
						OAM_MODULE_ID,
						SON_MODULE_ID,
						tcb_transaction_id,
						curr_cid);

				if (OAM_FAILURE == ret_val) {
					OAM_LOG(OAM, OAM_ERROR,
							"Error in sending SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_REQ, cell context = %d", curr_cid);
				}
				else {
					OAM_LOG(OAM, OAM_DETAILED, "Successfully sent "
							"SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_REQ");
#ifndef OAM_UT_FRAMEWORK      
					oam_maintain_tcb(tcb_transaction_id, OAM_TRANS_SON,
							msg_len, p_api_buf);
#endif
				}

				flag_found = OAM_ONE;
				break;

			case OAM_SON_ANR_ENABLE_MASK:
				cell_config_idx = oam_get_son_serving_cell_idx(curr_cid);
				if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                                curr_cid);
					OAM_FUN_EXIT_TRACE();
					return OAM_FAILURE;
				}
				/* SPR 22453 Fix Start */
				ret_val = oam_son_send_son_oam_anr_enable_req(p_local_req,
						OAM_MODULE_ID,
						SON_MODULE_ID,
						trans_id,
						curr_cid);
				/* SPR 22453 Fix End */
				if (OAM_FAILURE == ret_val) {
					OAM_LOG(OAM, OAM_ERROR,
							"Error in sending SON_OAM_ANR_ENABLE_REQ message to lower layer");
				}
				else {
					OAM_LOG(OAM, OAM_INFO,
							"SON_OAM_ANR_ENABLE_REQ sent to lower layer successfully");
					/* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
					if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
								OAM_TRANS_SON,msg_len,p_api_buf))
					{
						OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
						ret_val = OAM_FAILURE;
					}
#endif
					/* SPR 9620 CHANGE END */
					flag_found = OAM_ONE;
				}

                /* Coverity 86859 Fix Start */
                oam_mem_free(p_son_anr_enable_req, p_error_code);
                /* Coverity 86859 Fix End */

				break;

			case OAM_SON_ANR_DISABLE_MASK:
				cell_config_idx = oam_get_son_serving_cell_idx(curr_cid);
				if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                                curr_cid);
					OAM_FUN_EXIT_TRACE();
					return OAM_FAILURE;
				}

				ret_val = oam_mem_alloc(sizeof(oam_son_anr_disable_req_t),
						(void**)&p_son_anr_disable_req, p_error_code);
				if (OAM_FAILURE == ret_val) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to p_son_anr_disable_req failed"
							" with Error Code:%d",
							*p_error_code);
					OAM_FUN_EXIT_TRACE();
					return ret_val;
				}

				oam_memset(p_son_anr_disable_req, OAM_ZERO,
						sizeof(oam_son_anr_disable_req_t));


				oam_memcpy(&p_son_anr_disable_req->src_cgi,
						&(SON_CELL_INFO_IND_SERVING_CELL(cell_config_idx).src_cgi),
						sizeof(oam_son_intra_rat_global_cell_id_t));

				p_son_anr_disable_req->bitmask |= SON_ANR_DISABLE_SRC_CGI_PRESENT;
				p_son_anr_disable_req->src_cgi_list_size = 1;


				ret_val = oam_son_send_son_oam_anr_disable_req(p_son_anr_disable_req,
						OAM_MODULE_ID,
						SON_MODULE_ID,
						trans_id,
						curr_cid);
				if (OAM_FAILURE == ret_val) {
					OAM_LOG(OAM, OAM_ERROR,
							"Error in sending SON_OAM_ANR_DISABLE_REQ message to lower layer");
				}
				else {
					OAM_LOG(OAM, OAM_INFO,
							"SON_OAM_ANR_DISABLE_REQ sent to lower layer successfully");
					/* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
					if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
								OAM_TRANS_SON,msg_len,p_api_buf))
					{
						OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
						ret_val = OAM_FAILURE;
					}
#endif
					/* SPR 9620 CHANGE END */
					flag_found = OAM_ONE;
				}

                /* Coverity 86857 Fix Start */
                oam_mem_free(p_son_anr_disable_req, p_error_code);
                /* Coverity 86857 Fix End */


				break;


			case OAM_SON_X2_ENABLE_MASK:
			case OAM_SON_X2_DISABLE_MASK:
				/* coverity 41292 */
				LOCAL_SON_PROV_REQ.x2_enable_disable.x2_enabled = 
					(OAM_SON_X2_ENABLE_MASK == api_index)?SON_TRUE:SON_FALSE;
				ret_val = oam_son_send_son_oam_enable_disable_x2_req(
						&(LOCAL_SON_PROV_REQ.x2_enable_disable),
						OAM_MODULE_ID, SON_MODULE_ID,
						tcb_transaction_id,
						curr_cid);
				if (OAM_FAILURE == ret_val)
				{     
					OAM_LOG(OAM, OAM_ERROR,
							"Sending OAM_SON_SEND_SON_OAM_ENABLE_DISABLE_X2_REQ failed");
				}
				else
				{
					/* SPR 9620 CHANGE START */  
					OAM_LOG(OAM, OAM_DETAILED, "Successfully sent OAM_SON_SEND_SON_OAM_ENABLE_DISABLE_X2_REQ");
#ifndef OAM_UT_FRAMEWORK
					if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_SON,
								OAM_TRANS_SON,msg_len,p_api_buf))
					{
						OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
						ret_val = OAM_FAILURE;
					}
#endif
				}
				/* SPR 9620 CHANGE END */

				flag_found = OAM_ONE;
				break;

			case OAM_SON_NW_SCAN_EUTRAN_MASK:
				/* coverity 41292 */
				if (LOCAL_SON_PROV_REQ.nw_scan.start_intra_rat_scan_req.bitmask &  
						SON_MEAS_BANDWINDTH_PER_EARFCN_PRESENT)   
				{
					if (LOCAL_SON_PROV_REQ.temp_values.
							temp_bitmask & OAM_TEMP_EARFCN_LIST_PRESENT) {
						OAM_LOG(OAM, OAM_DETAILED,
								"EUTRACarrierARFCNDLList is present");
						temp_val_index =
							oam_tokenize_string_to_u16(
									LOCAL_SON_PROV_REQ.temp_values.nw_scan_earfcn_list,
									",",
									OAM_EUTRA_CARRIER_ARFCN_DL_LIST_MAX_LEN,
									temp_earfcn_array);

						for (loop = OAM_ZERO; loop < temp_val_index; ++loop) {
							LOCAL_SON_PROV_REQ.nw_scan.start_intra_rat_scan_req.
								meas_bandwidth_per_earfcn.
								meas_bandwidth_per_earfcn[loop].
								earfcn = temp_earfcn_array[loop];

							LOCAL_SON_PROV_REQ.nw_scan.start_intra_rat_scan_req.
								meas_bandwidth_per_earfcn.
								meas_bandwidth_per_earfcn[loop].
								meas_bandwidth_for_earfcn =
								OAM_SON_NW_SCAN_MEAS_BW_VALUE;
						}

						LOCAL_SON_PROV_REQ.nw_scan.start_intra_rat_scan_req.
							meas_bandwidth_per_earfcn.
							num_earfcn = temp_val_index;
						/*SPR 12001 FIX START*/
						if (LOCAL_SON_PROV_REQ.temp_values.
								temp_bitmask & OAM_TEMP_PCI_LIST_PRESENT) {
							oam_strncpy(csv_list,
									LOCAL_SON_PROV_REQ.temp_values.
									nw_scan_pci_list,
									OAM_PHY_CELL_ID_STR_MAX_LEN);

							for (cnt = 0, str1 = csv_list; ;
									++cnt, str1 = OAM_NULL) {
								csv_list_1 = strtok_r(str1, ":", &saveptr1);

								if (!csv_list_1) {
									break;
								}

								LOCAL_SON_PROV_REQ.nw_scan.
									start_intra_rat_scan_req.
									meas_bandwidth_per_earfcn.
									meas_bandwidth_per_earfcn[cnt].
									num_pci = oam_tokenize_string_to_u16(
											csv_list_1,
											",",
											SON_MAX_NO_CELLS_PER_EARFCN,
											LOCAL_SON_PROV_REQ.nw_scan.
											start_intra_rat_scan_req.
											meas_bandwidth_per_earfcn.
											meas_bandwidth_per_earfcn[cnt].
											pci);

								OAM_LOG(OAM, OAM_DETAILED, "value of num_pci:%d for earfcn %d+1",
										LOCAL_SON_PROV_REQ.nw_scan.start_intra_rat_scan_req.
										meas_bandwidth_per_earfcn.meas_bandwidth_per_earfcn[cnt].num_pci,
										cnt);
							}
						}
					}
					/*SPR 12001 FIX END*/
				}

				if (LOCAL_SON_PROV_REQ.nw_scan.start_intra_rat_scan_req.
						bitmask & SON_NW_SCAN_PLMN_ID_PRESENT) {
					temp_val_index = OAM_ZERO;
					Char8* p_temp_str_tok = OAM_NULL;
					Char8 temp_str[STR_LEN_32];
					p_temp_str_tok = oam_strtok(LOCAL_SON_PROV_REQ.temp_values.
							nw_scan_plmn_list, ",");
					if (OAM_NULL != p_temp_str_tok) {
						oam_trim_spaces(p_temp_str_tok, temp_str);
						++temp_val_index;
						while(SON_MAX_NUM_PLMN > temp_val_index) {
							p_temp_str_tok = oam_strtok(OAM_NULL, ",");

							if (OAM_NULL == p_temp_str_tok)
							{
								break;
							}

							oam_trim_spaces(p_temp_str_tok, temp_str);
							oam_generate_plmnid((Char8*)temp_str,
									(&LOCAL_SON_PROV_REQ.nw_scan.
									 start_intra_rat_scan_req.
									 plmn_id[temp_val_index]));
							++temp_val_index;
						}

						LOCAL_SON_PROV_REQ.nw_scan.start_intra_rat_scan_req.
							num_plmn_id = temp_val_index;
					}
				}

				if(p_cm_cntxt->state == OAM_CM_ST_ACTIVE) {
					if(LOCAL_SON_PROV_REQ.periodic_nw_scan.
							scan_on_off != OAM_ALL_8_BIT_SET) {
						if((LOCAL_SON_PROV_REQ.periodic_nw_scan.
									scan_on_off != OAM_ZERO) &&
								(LOCAL_SON_PROV_REQ.periodic_nw_scan.
								 scan_time_interval != OAM_ZERO))
						{
							LOCAL_SON_PROV_REQ.periodic_nw_scan.bitmask |=
								SON_INTRA_RAT_PERIODIC_NW_SCAN_REQ_PRESENT;
						}

						oam_memcpy(&(LOCAL_SON_PROV_REQ.periodic_nw_scan.
									start_intra_rat_periodic_scan_req),
								&(LOCAL_SON_PROV_REQ.nw_scan.
									start_intra_rat_scan_req),
								sizeof(son_start_intra_rat_scan_req_t));
						OAM_LOG(OAM,OAM_DETAILED,"Sending SON_OAM_PERIODIC_NW_SCAN_REQ to SON");

						ret_val =
							oam_son_send_son_oam_periodic_nw_scan_req(
									&(LOCAL_SON_PROV_REQ.periodic_nw_scan),
									OAM_MODULE_ID, SON_MODULE_ID,
									tcb_transaction_id,
									curr_cid);

						if (OAM_SUCCESS == ret_val &&
								LOCAL_SON_PROV_REQ.periodic_nw_scan.scan_on_off) {
							oam_prov_req.system_status.
								event_ongoing |= OAM_SON_NMM_PERIODIC_SCAN_ONGOING;
						}
						else {
							OAM_LOG(OAM, OAM_ERROR,
									"Failed to send SON_OAM_PERIODIC_NW_SCAN_REQ");
							oam_prov_req.system_status.
								event_ongoing &= ~OAM_SON_NMM_PERIODIC_SCAN_ONGOING;
						}
					}
					else {
						LOCAL_SON_PROV_REQ.nw_scan.bitmask |=
							SON_INTRA_RAT_NW_SCAN_REQ_PRESENT; 
						ret_val = oam_son_send_son_oam_nw_scan_req(
							&(oam_prov_req.oam_son_req.nw_scan),
							OAM_MODULE_ID,
							SON_MODULE_ID,
							tran_id,
							oam_prov_req.cell_cntxt.curr_cell_cid);

#ifndef OAM_UT_FRAMEWORK
						if (OAM_SUCCESS == ret_val) {
							oam_maintain_tcb_ext(trans_id,
									OAM_TRANS_SON,
									msg_len,
									p_api_buf,
									p_orig_parent,
									p_req_parent,
									p_p_xml_struct_addr);
						}
#endif
					}
				}
				else {
					ret_val = OAM_SUCCESS;
					oam_update_xml_dom(ret_val, p_orig_parent,
							p_req_parent, p_p_xml_struct_addr);
				}

				if (OAM_FAILURE == ret_val)
				{     
					oam_memset(&(oam_prov_req.oam_igd_params.nw_scan_status),OAM_ZERO,sizeof(oam_nw_scan_status_t));
					oam_memcpy(&(oam_prov_req.oam_igd_params.nw_scan_status.scan_status),oam_nw_scan_status[OAM_ZERO],STR_LEN_32);
					oam_memcpy(&(local_prov_req.oam_igd_params.nw_scan_status),&(oam_prov_req.oam_igd_params.nw_scan_status),sizeof(oam_nw_scan_status_t)); 
					OAM_LOG(OAM,OAM_ERROR,
							"Sending request SON_OAM_NW_SCAN_REQ"
							"/SON_OAM_PERIODIC_NW_SCAN_REQ failed");
				}
				else
				{
					/*OAM_REVIEW_CHANGES*/
					oam_memcpy(&(oam_prov_req.oam_igd_params.nw_scan_status.scan_status),oam_nw_scan_status[OAM_ONE],STR_LEN_32);
					/*OAM_REVIEW_CHANGES*/
					oam_memcpy(&(SON_PROV_REQ.temp_values),&(LOCAL_SON_PROV_REQ.temp_values),sizeof(oam_son_nw_scan_params_t));
					oam_memcpy(&(SON_PROV_REQ.nw_scan),&(LOCAL_SON_PROV_REQ.nw_scan),sizeof(oam_son_nw_scan_req_t));
					oam_memcpy(&(local_prov_req.oam_igd_params.nw_scan_status),&(oam_prov_req.oam_igd_params.nw_scan_status),sizeof(oam_nw_scan_status_t));
					oam_construct_n_send_set_resp_to_usr(
							OAM_RESULT_SUCCESS,
							OAM_ZERO,
							OAM_NULL, OAM_ZERO, 
							OAM_VERSION_ID,
							OAM_MODULE_ID,
							dest_id, trans_id,
							OAM_ZERO, OAM_ZERO,
							p_error_code);
				}
				flag_found = OAM_ONE;
				break;

			case SON_OAM_NR_DELETE_FROM_REM_LIST_MASK:
				/* SPR 11156 FIX START */
				cell_config_idx = oam_get_son_cell_nr_list_idx(
						curr_cid);

				if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                                curr_cid);

					*p_error_code = OAM_INVALID_CELL_CONTEXT;
					ret_val = OAM_FAILURE;
					flag_found = OAM_ONE;
					break;
				}

				p_son_nr_del_from_remlist = p_local_req;
                /*  coverity 83684 fix start */
                if(p_son_nr_del_from_remlist != NULL)
                {
                /*  coverity 83684 fix end */
				oam_memcpy(&(p_son_nr_del_from_remlist->src_cgi),
						&(SON_NR_ADD_REQ(cell_config_idx).src_cgi),
						sizeof(son_intra_rat_global_cell_id_t));

				p_son_nr_del_from_remlist->trgt_cgi_list_size = OAM_ONE;

				ret_val = oam_son_send_son_oam_nr_delete_from_remove_list_req(
						p_son_nr_del_from_remlist,
						OAM_MODULE_ID,
						SON_MODULE_ID,
						tcb_transaction_id,
						curr_cid);

				if (OAM_FAILURE == ret_val) {     
					*p_error_code = OAM_SEND_FAIL;
					OAM_LOG(OAM, OAM_ERROR,
							"Failed to send SON_OAM_NR_DELETE_FROM_REMOVE_LIST_REQ user request to lower layer");
				}
				else {
					/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
					if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_SON,
								OAM_TRANS_SON,msg_len,p_api_buf))
					{
						OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
						ret_val = OAM_FAILURE;
					}
#endif
					/* SPR 9620 CHANGE END */

				}

                /*  coverity 83684 fix start */
                }
                /*  coverity 83684 fix end */

				/* SPR 11156 FIX END */
				flag_found = OAM_ONE;
				break;
#endif

				/* OAM-RCM interface handling */
#ifdef OAM_RADIO_HEAD_SUPPORT
			case RRH_OAM_ATTRIBUTES_MASK:
			case RRH_OAM_RECONFIG_REQ_MASK:
			case OAM_RCM_RRH_SW_DWNLD_REQ_MASK:
			case OAM_RCM_UNIT_RESET_REQ_MASK:
				OAM_LOG(OAM, OAM_DETAILED, "RRH set parameter request received");
				if(oam_prov_req.rrh_flag) {
#ifndef OAM_UT_FRAMEWORK
					oam_maintain_tcb(tcb_transaction_id,OAM_TRANS_RRH,msg_len,p_api_buf);
#endif
					ret_val = oam_rrh_process_user_req(p_api_buf,
							msg_len,
							api_index,
							tcb_transaction_id,
							src_module_id,
							p_error_code);
				}
				else {
					*p_error_code = OAM_MODULE_DISABLED;
					OAM_LOG(OAM, OAM_WARNING, "RRH module is disabled.");
					ret_val = OAM_FAILURE;
				}
				flag_found = OAM_ONE;
				break;
#endif


				/*TR-069 ADMIN/OP State changes*/
			case OAM_ADMIN_STATE_CHANGED_MASK:
				/*AdminState Value changes from 1 to 0 , send Cell block Request*/
				cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
				if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                                curr_cid);
					flag_found = 1;
					ret_val = OAM_FAILURE;
					break;
					return OAM_FAILURE;
				}
				/* Spr 10926 Fix Start */  
#ifndef OAM_UT_FRAMEWORK
				ret_val = oam_maintain_tcb(tcb_transaction_id,
						OAM_TRANS_RRM,
						msg_len, p_api_buf);
#endif
				if(ENODEB_ADMIN_STATE_UNLOCKED == oam_prov_req.system_status.admin_state && 
						ENODEB_ADMIN_STATE_LOCKED == local_prov_req.system_status.admin_state)
				{
					OAM_LOG(OAM, OAM_INFO, "Admin State Changed from Unlocked to Locked");

					for(loop_counter = OAM_ZERO;
							loop_counter < oam_prov_req.num_cells_configured;
							++loop_counter) {
						p_rrm_cell_config =
							&RRM_CELL_CONFIG(loop_counter);

						cid =
							oam_extract_cid_from_eutran_cellidentity(
									p_rrm_cell_config->global_cell_info.
									eutran_global_cell_id.cell_identity);
						p_cell_status = oam_get_cell_cntxt_status(cid);

						if(p_cell_status == OAM_NULL) 
							continue;

						if ((p_cell_status->cell_state & OAM_CELL_ACTIVE))
						{
							OAM_LOG(OAM, OAM_INFO,
									"Sending cell stop for CID: %d to rrm",
									cid);
							ret_val =
								oam_rrm_send_rrm_oam_cell_stop_req(
										((rrm_oam_cell_stop_req_t *)
										 &(p_rrm_cell_config->global_cell_info.
											 eutran_global_cell_id)),
										OAM_MODULE_ID, RRM_MODULE_ID,
										tcb_transaction_id, cid);
							if (OAM_FAILURE == ret_val)
							{
								OAM_LOG(OAM, OAM_ERROR,
										"Sending RRM_OAM_CELL_STOP_REQ request to layer failed, cell context = %d", cid);
								flag_found = 1;
								break;
							}
                                /*SPR 14423  FIX START */ 
							else{
                                OAM_LOG(OAM, OAM_INFO, "RRM_OAM_CELL_STOP_REQ Sent");
                                oam_prov_req.system_status.event_ongoing |= OAM_SET_ADMIN_STATE_RESP_PENDING; 

                                usr_intf_flag = OAM_TRUE;
                                /*SPR 14423  FIX END */ 

								/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
								if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,
											OAM_SUB_MODULE_RRM,OAM_TRANS_RRM,msg_len,p_api_buf))
								{
									OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
									ret_val = OAM_FAILURE;
								}
#endif
								/* SPR 9620 CHANGE END */
                                /*SPR 14423  FIX START */ 
                                else {
                                    OAM_LOG(OAM, OAM_INFO,
                                            "Cell Stop Timer started successfully"); 
                                }
                                /*SPR 14423  FIX END */ 

							}

							cell_stop_sent_to_lock_admin_state++;
							user_trigger_admin_state_lock_unlock_flag = OAM_TRUE;
						}
						else
						{
							OAM_LOG(OAM,OAM_DETAILED,
									"Cell Stop for cell indentity %d Cannot be triggerd as CELL is not active",cid);
						}
					}

				}
				/* Spr 10926 Fix End */  
				/*AdminState Value changes from 0 to 1 , send Cell Unblock Request*/
				else if ((ENODEB_ADMIN_STATE_LOCKED == oam_prov_req.system_status.admin_state &&
							ENODEB_ADMIN_STATE_UNLOCKED == local_prov_req.system_status.admin_state) ||
						((OAM_ONE == init_time_startup)&&
						 (ENODEB_ADMIN_STATE_UNLOCKED == oam_prov_req.system_status.admin_state) &&
						 (ENODEB_ADMIN_STATE_UNLOCKED == local_prov_req.system_status.admin_state)&&
						 (OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode))) /* Software Download changes */
				{
					OAM_LOG(OAM, OAM_INFO, "Admin State Changed from Locked to Unlocked");

					if(OAM_FALSE == oam_prov_req.system_status.cell_setup_complete)
					{
						OAM_LOG(OAM,OAM_INFO,"Cell not configured yet"); 

                        /* SPR_19279_START */
                        if(OAM_TRUE == g_is_Primary_PLMN_present)
                        {
                            oam_populate_PLMNList();
                        }
                        else
                        {
                            ret_val = OAM_FAILURE;
                        }
                        if(OAM_FAILURE == ret_val)
                        {
                            OAM_LOG(OAM, OAM_WARNING, "Initial Admin State Unlocked Failed "
                                    "Invalid PLMNList Configuration");
                            /* Send set parameters response from here only */
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR,
                                    (UInt8 *) "OAM Internal Error", strlen("OAM Internal Error")+ OAM_ONE,
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                                    p_error_code);
                            break;
                        }
                        /* SPR_19279_END */

						UInt16    gen_trans_id = OAM_ZERO;
						UInt8 cell_cnt = OAM_ZERO;
						for (cell_cnt = OAM_ZERO;cell_cnt < oam_prov_req.num_cells_configured; ++cell_cnt) {
							p_rrm_cell_config = &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_cnt];
                            /* spr_21013_fix_start */
							ret_val = oam_handle_initial_admin_state_unlocked(/* SPR 22248 MBMS Changes Start */ /*Code commented */&oam_startup_required, /* SPR 22248 MBMS Changes Stop */
                            /* spr_21013_fix_end */
									p_rrm_cell_config,
									&gen_trans_id);
							if(init_time_startup== OAM_ONE)
							{

								oam_prov_req.system_status.admin_state = local_prov_req.system_status.admin_state;

								OAM_LOG(OAM,OAM_DETAILED,"Event marked as OAM_SET_ADMIN_STATE_RESP_PENDING");
								oam_prov_req.system_status.event_ongoing |= OAM_SET_ADMIN_STATE_RESP_PENDING;
								oam_prov_req.system_status.p_api_buf = p_api_buf;
								oam_prov_req.system_status.trans_id = gen_trans_id;
								UInt16 trans_id = get_word_from_header((UInt8*)(oam_prov_req.system_status.p_api_buf) + OAM_ZERO);
								OAM_LOG(OAM,OAM_INFO,"Trans_id Saved: %d",trans_id);

								if(OAM_NULL != (oam_prov_req.system_status.timer_id = oam_start_new_timer(OAM_SUB_MODULE_MIH, OAM_MODULE_ID,
												OAM_LAYERS_CONFIG_TIMER_TYPE, OAM_LAYERS_CONFIG_TIMEOUT_DURATION * OAM_TWO_THOUSAND,
												OAM_NULL, OAM_ZERO, OAM_FALSE)))
								{
									OAM_LOG(OAM,OAM_INFO,"Layers Config Timer started successfully");
									g_admin_state_timer = oam_prov_req.system_status.timer_id;
									g_admin_state_trans_id = trans_id;
								}
								else
								{       
									OAM_LOG(OAM,OAM_WARNING,"Failed to start Layers Config Timer");
								}
							}   

							if(OAM_SUCCESS != ret_val)
							{
								OAM_LOG(OAM, OAM_WARNING, "Initial Admin State Unlocked Failed");
								/* Send set parameters response from here only */
								oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
										OAM_ERR_INTERNAL_ERROR,
										(UInt8 *) "OAM Internal Error", oam_strlen("OAM Internal Error")+ OAM_ONE, 
										OAM_VERSION_ID, OAM_MODULE_ID,
										dest_id, trans_id, OAM_ZERO, OAM_ZERO,
										p_error_code);

							}
						}
					} 
					else
					{
						OAM_LOG(OAM,OAM_INFO,"Cell already configured"); 
						/* Handle admin state unlocked for startup flow */
						ret_val = oam_handle_admin_state_unlocked(p_api_buf);
						/* No need to add entry in TCB as no response expected 
						   from lower layers for this scenario */
					}  
				}
				else
				{
					/* Send success set response */
					OAM_LOG(OAM, OAM_INFO, "Admin State same as previous, Nothing to do");
					/* Send set parameters response from here only */
					oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
							OAM_ZERO,(UInt8 *) OAM_NULL,OAM_ZERO,
							OAM_VERSION_ID, OAM_MODULE_ID,
							dest_id, trans_id, OAM_ZERO, OAM_ZERO,
							p_error_code);
				}   

				flag_found = OAM_ONE;
				break;

			case RRM_OAM_CELL_SETUP_REQ_MASK:
				OAM_LOG(OAM, OAM_INFO, "Cell setup requested for cell context: %d "
						"from user interface", curr_cid);
				/* SPR 11002 Fix Start */
				p_cell_status = oam_get_cell_cntxt_status(curr_cid);
				if (p_cell_status == OAM_NULL) /* Cov 63647 Fix*/
				{
					OAM_LOG(OAM, OAM_WARNING,
							"No cell found for cell context = %d", curr_cid);
					OAM_FUN_EXIT_TRACE();
					return OAM_FAILURE;

				}

				if (p_cell_status->cell_state & OAM_CELL_IDLE) {
					/* SPR 11002 Fix End */
                    /* SPR 21412 Fix Start*/
					cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
                    /* SPR 21412 Fix End */
					if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
						OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                                    curr_cid);
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}

					p_rrm_cell_config = &RRM_CELL_CONFIG(cell_config_idx);
                    /* Coverity 86858 Fix Start */
					ret_val = oam_validate_tr196_schema(
							&oam_prov_req.system_status.p_xml_doc);

                    if (OAM_SUCCESS == ret_val) {
					oam_prov_req.system_status.
						event_ongoing |= OAM_CELL_SETUP_MASK; 

					send_config_update_flag = OAM_ONE;

					/* SPR 11002 Fix Start */
#ifndef OAM_UT_FRAMEWORK
					oam_maintain_tcb(tcb_transaction_id,
							OAM_TRANS_RRM,
							msg_len,
							p_api_buf);
#endif
                        /* SPR 11002 Fix End */
                        ret_val = oam_rrm_send_rrm_oam_cell_config_req(
                                p_rrm_cell_config,
                                src_module_id,
                                RRM_MODULE_ID,
                                tcb_transaction_id,
                                curr_cid);

                        if(OAM_FAILURE == ret_val) {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Sending RRM_OAM_CELL_CONFIG_REQ Failed, cell context = %d", curr_cid);
                            /* Reset Event */
                            oam_prov_req.system_status.
                                event_ongoing &= ~OAM_CELL_SETUP_MASK;
                        }
                        /* SPR 20939 Changes Start */
                        else
                        {
                            /* Start timer to wait response from lower layer */
                            oam_prov_req.system_status.timer_id =
                                oam_start_new_timer(OAM_SUB_MODULE_MIH, OAM_MODULE_ID,
                                        OAM_CELL_SETUP_TIMER_TYPE,
                                        OAM_CELL_OPERATION_TIMEOUT_DURATION*OAM_MSEC_IN_ONE_SEC,
                                        OAM_NULL, OAM_ZERO, OAM_FALSE);

                            if(oam_prov_req.system_status.timer_id) {
                                OAM_LOG(OAM,OAM_INFO,"Cell Setup Timer started successfully for duration:[%u] with ID:[%u]",
                                        OAM_CELL_OPERATION_TIMEOUT_DURATION*OAM_MSEC_IN_ONE_SEC,oam_prov_req.system_status.timer_id); 
                            }
                            else {
                                OAM_LOG(OAM, OAM_ERROR, "Failed to start Cell Setup Timer"); 
                                ret_val = OAM_FAILURE;
                            }
                        }
                        /* SPR 20939 Changes End */
                    }
                    else {
                        OAM_LOG(OAM, OAM_ERROR, "XML schema validation failed");
                    }
				                    /* Coverity 86858 Fix End */
                }
				else {
#ifndef OAM_UT_FRAMEWORK
#endif
					/* SPR 11002 Fix changes code removed */
					OAM_LOG(OAM, OAM_WARNING, "Cell already configured, "
							"Request for cell setup Rejected");

					resp_result = OAM_RESULT_FAILURE;
					usr_err_code = OAM_ERR_REQUEST_DENIED;
					oam_strncpy(cmd_status,
							"Cell already configured, Request Rejected",
							sizeof(cmd_status));
					cmd_status_size = oam_strlen(cmd_status);

					oam_construct_n_send_set_resp_to_usr(resp_result,
							usr_err_code,
							(UInt8*)cmd_status,
							cmd_status_size,
							OAM_VERSION_ID,
							OAM_MODULE_ID,
							dest_id,
							trans_id,
							OAM_ZERO,
							OAM_ZERO,
							p_error_code);
				}

				flag_found = OAM_ONE;
				break;

			case S1AP_OAM_PROVISION_REQ_MASK:
				oam_memcpy(&OAM_S1AP_INFO, &LOCAL_OAM_S1AP_INFO,
						sizeof(s1apInfo_t));

				oam_prov_req.system_status.event_ongoing |=
					OAM_FSM_INIT_TIME_USR_REQ_ONGOING;
#ifndef OAM_UT_FRAMEWORK
				oam_maintain_tcb_ext(trans_id,
						OAM_TRANS_S1AP,
						msg_len,
						p_api_buf,
						p_orig_parent,
						p_req_parent,
						p_p_xml_struct_addr);
#endif

				flag_found = OAM_ONE;
				break;

            /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
            case M2AP_OAM_PROVISION_REQ_MASK:
            cell_config_idx = oam_get_m2ap_cell_config_idx(curr_cid);
            if (OAM_ERROR_RETURN_VAL == cell_config_idx) 
            {
                OAM_LOG(OAM, OAM_ERROR, "Invalid cell context");

                /* Free all the used up memory */
                //oam_mem_free(p_local_req, p_error_code);
                ret_val = OAM_FAILURE;
				flag_found = OAM_ONE;
				break;
            }

            oam_copy_m2ap_config_to_reconfig(&LOCAL_M2AP_PROV_REQ,
                    p_local_req);

            trans_id = oam_get_new_trans_id();

            ret_val = oam_m2ap_il_send_oam_m2ap_config_update_req(
                    p_local_req,
                    src_module_id,
                    RRC_MODULE_ID,
                    trans_id,
                    curr_cid);
            if (OAM_SUCCESS == ret_val)
            {
                OAM_LOG(OAM, OAM_INFO,
                        "OAM_M2AP_CONFIG_UPDATE_REQ sent Successfully");
#ifndef OAM_UT_FRAMEWORK
                oam_maintain_tcb_ext(trans_id,
                        OAM_TRANS_M2AP,
                        msg_len,
                        p_api_buf,
                        p_orig_parent,
                        p_req_parent,
                        p_p_xml_struct_addr);
#endif
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR, "Failed to send the message "
                        "OAM_M2AP_CONFIG_UPDATE_REQ");
            }

            flag_found = OAM_ONE;
            /* Free all the used up memory */
            //oam_mem_free(p_local_req, p_error_code);
            break;

            case M2AP_OAM_SET_LOG_LEVEL_REQ_MASK:
            ret_val = oam_mem_alloc(sizeof(oam_m2ap_set_log_level_req_t),
                    (void**)&p_m2ap_log_level_req,
                    p_error_code);
            if (OAM_FAILURE == ret_val) {
                OAM_LOG(OAM, OAM_ERROR, "Error in memory allocation");

                OAM_FUN_EXIT_TRACE();
                return ret_val;
            }

            p_m2ap_log_level_req->log_level =
                LOCAL_M2AP_PROV_REQ.log_level;

            trans_id = oam_get_new_trans_id();

            ret_val = oam_m2ap_il_send_oam_m2ap_set_log_level_req(
                    p_m2ap_log_level_req,
                    src_module_id,
                    RRC_MODULE_ID,
                    trans_id,
                    curr_cid);
            if (OAM_SUCCESS == ret_val)
            {
                OAM_LOG(OAM, OAM_INFO,
                        "OAM_M2AP_SET_LOG_LEVEL_REQ sent Successfully");
#ifndef OAM_UT_FRAMEWORK
                oam_maintain_tcb(trans_id,
                        OAM_TRANS_M2AP,
                        msg_len,
                        p_api_buf);
#endif
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR, "Failed to send the message "
                        "OAM_M2AP_SET_LOG_LEVEL_REQ");
            }

            flag_found = OAM_ONE;
            oam_mem_free(p_m2ap_log_level_req, p_error_code);
            break;

#endif
            /* EMBMS Changes End */

            case OAM_REF_SIG_POWER_LIST_MASK:
            case OAM_EARFCN_DL_LIST_MASK:
                /* CSR 58157 START */
            case OAM_EARFCN_UL_LIST_MASK:
                /* CSR 58157 END */
            case OAM_P_MAX_LIST_MASK:
                /* Apply carrier frequency and power list to lower layers */
                ret_val = oam_apply_carrier_freq_and_power_list(
                        p_api_buf,msg_len,p_local_req,p_error_code,
                        /* SPR 19236 Fix + */
                        p_orig_parent,p_req_parent,p_p_xml_struct_addr);
                /* SPR 19236 Fix - */
                flag_found = OAM_ONE;
                break;

                /* Spr 17753 Changes Start */
                /* Code Deleted */
                /* Spr 17753 Changes End */ 

            case OAM_PHY_CELL_ID_MASK:
                /* CSR 58157 FIX START*/
                /* SPR 13024 FIX START */
                cell_config_idx = oam_get_rrm_cell_config_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);

                    /*SPR 18504 FIX START*/
                    /*code deleted*/
                    /*SPR 18504 FIX END*/

                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                p_rrm_cell_config = &RRM_CELL_CONFIG(cell_config_idx);
                p_local_cell_config = &LOCAL_RRM_CELL_CONFIG(cell_config_idx);

                cell_arr_idx = oam_get_earfcn_pci_select_arr_idx(curr_cid);

                if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
					OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);

                    /*SPR 18504 FIX START*/
                    /*code deleted*/
                    /*SPR 18504 FIX END*/
                    ret_val = OAM_FAILURE;
                    /* Coverity ID 85871 Fix Start*/
                    flag_found = OAM_ONE;
                    /* Coverity ID 85871 Fix End*/
                    break;
                }


                p_pci_reselection_req =
                    &LOCAL_SON_PROV_REQ.earfcn_pci_selection[cell_arr_idx].
                    oam_son_pci_reselection_req;

                trans_id = oam_get_new_trans_id();

                if ((1 == p_pci_reselection_req->pci_list_size) ||
                        (oam_prov_req.num_cells_configured > 1)) {

                    if ((oam_prov_req.num_cells_configured > 1) &&
                            (p_pci_reselection_req->pci_list_size > 1)) {
                        OAM_LOG(OAM, OAM_WARNING,
                                "Assuming the first PCI value[%d] as the "
                                "preferred value in the PhyCellID list for "
                                "cell configuration",
                                p_pci_reselection_req->pci_list[0]);
                    }

                    p_local_cell_config->ran_info.rf_params.rf_configurations.
                        phy_cell_id = p_pci_reselection_req->pci_list[0];

                    if (OAM_CM_ST_ACTIVE != p_cm_cntxt->state) {
                        oam_memcpy(p_rrm_cell_config, p_local_cell_config,
                                sizeof(oam_rrm_cell_config_req_t));
                    }
                    else {
                        oam_copy_config_to_reconfig(p_local_cell_config,
                                p_local_req);

                        ret_val =
                            oam_rrm_send_rrm_oam_cell_reconfig_req(p_local_req,
                                    src_module_id,
                                    RRM_MODULE_ID,
                                    trans_id,
                                    curr_cid);
                        if (OAM_FAILURE == ret_val) {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Failed to send RRM_OAM_CELL_RECONFIG_REQ, cell context = %d",curr_cid );
                        }
                        else {
                            OAM_LOG(OAM, OAM_INFO,
                                    "Successfully sent RRM_OAM_CELL_RECONFIG_REQ");
#ifndef OAM_UT_FRAMEWORK
                            /* SPR 13033 Fix Start*/
                            oam_maintain_tcb_ext(trans_id, OAM_TRANS_RRM,
                                    msg_len, p_api_buf,
                                    p_orig_parent, p_req_parent,
                                    p_p_xml_struct_addr);
                            /* SPR 13033 Fix End*/
#endif
                        }
                    }/* End of else */
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED, "Multiple value of PCI received");
                    p_pci_reselection_req->earfcn = p_rrm_cell_config->ran_info.
                        rf_params.rf_configurations.
                        dl_earfcn;
                    cell_arr_idx = oam_get_son_serving_cell_idx(curr_cid);
                    if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
						OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                curr_cid);

                        /*SPR 18504 FIX START*/
                        /*code deleted*/
                        /*SPR 18504 FIX END*/

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }

                    oam_memcpy(&p_pci_reselection_req->src_cgi,
                            &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                            sizeof(son_intra_rat_global_cell_id_t));


                    ret_val = oam_son_send_son_oam_pci_reselection_req(
                            p_pci_reselection_req,
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            trans_id,
                            curr_cid);
                    if (OAM_SUCCESS == ret_val) {
                        OAM_LOG(OAM, OAM_INFO,
                                "SON_OAM_PCI_RESELECTION_REQ sent Successfully!!");
                        /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                        ret_val = oam_maintain_tcb_ext(trans_id, OAM_TRANS_SON,
                                msg_len, p_api_buf,
                                p_orig_parent, p_req_parent,
                                p_p_xml_struct_addr);

                        if (OAM_FAILURE == ret_val) {
							OAM_LOG(OAM, OAM_WARNING, "Failed to maintain TCB ");
                            ret_val = OAM_FAILURE;
                        }
#endif
                        /* SPR 9620 CHANGE END */
                    }
                    else {
                        OAM_LOG(OAM, OAM_DETAILED,
                                "Failed to send SON_OAM_PCI_RESELECTION_REQ, cell context = %d", curr_cid);
                        *p_error_code = OAM_SEND_FAIL;
                    }
                }

                /*SPR 18504 FIX START*/
                /*code deleted*/
                /*SPR 18504 FIX END*/
                /* SPR 13024 FIX END */

                flag_found = OAM_ONE;
                break;
			
                /* Spr 17753 Changes Start */
                /* Code Removed */
                /* Spr 17753 Changes End */ 

            case RRC_OAM_PROVISION_REQ_MASK:
                for(cnt = OAM_ZERO; cnt < RRC_PROV_REQ.sector_info_list.count;
                        ++cnt) {
                    if (RRC_PROV_REQ.sector_info_list.sector_info[cnt].
                            cell_index == curr_cid) {
                        oam_memcpy(&RRC_PROV_REQ.sector_info_list.
                                sector_info[cnt].supported_security_algorithms,
                                &LOCAL_RRC_PROV_REQ.sector_info_list.
                                sector_info[cnt].supported_security_algorithms,
                                sizeof(rrc_oam_supported_security_algorithms_t));
                        break;
                    }
                }

                if (cnt == RRC_PROV_REQ.sector_info_list.count) {
					OAM_LOG(OAM, OAM_WARNING, "Cell context not found");
                    ret_val = OAM_FAILURE;
                    break;
                }

#ifndef OAM_UT_FRAMEWORK
                oam_maintain_tcb_ext(tcb_transaction_id,
                        OAM_TRANS_RRC,
                        msg_len,
                        p_api_buf,
                        p_orig_parent,
                        p_req_parent,
                        p_p_xml_struct_addr);
#endif

                oam_prov_req.system_status.event_ongoing |=
                    OAM_FSM_INIT_TIME_USR_REQ_ONGOING;
                flag_found = OAM_ONE;
                break;

            case RRM_OAM_LOAD_CONFIG_REQ_MASK:
                /* SPR 11001 FIX START */
                p_load_config_req = p_local_req;
                if (OAM_CM_ST_ACTIVE !=  p_cm_cntxt->state) {
                    /*  coverity 83684 fix start */
                    if(p_load_config_req != NULL)
                    {
                        oam_commit_local_load_config_data(p_load_config_req);
                        flag_found = 1;
                        break;
                    }
                    else
                    {
                        ret_val = OAM_FAILURE;
                    }
                    /*  coverity 83684 fix end */
                }
                else {
                    /* Coverity 83684 fix start */
                    if (p_load_config_req != NULL)
                    {
                        if (oam_verify_load_cfg_req_from_rrm(
                                    &p_load_config_req->serv_enb_cell_info[0]))
                        {
                            ret_val = oam_rrm_send_rrm_oam_load_config_req(
                                    p_load_config_req,
                                    src_module_id,
                                    RRM_MODULE_ID,
                                    tcb_transaction_id,
                                    curr_cid);

                            if(OAM_SUCCESS == ret_val) {
                                OAM_LOG(OAM, OAM_DETAILED,"RRM_OAM_LOAD_CONFIG_REQ Send Successfully");
                                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                                if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_RRM,
                                            OAM_TRANS_RRM,msg_len,p_api_buf))
                                {
                                    OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                                    ret_val = OAM_FAILURE;
                                }
#endif
                                /* SPR 9620 CHANGE END */

                            }
                            else {
                                OAM_LOG(OAM, OAM_ERROR,
                                        "Failed to send RRM_OAM_LOAD_CONFIG_REQ, cell context = %d", curr_cid);
                                *p_error_code = OAM_SEND_FAIL;
                            }

                            flag_found = 1;
                            break;
                        }
                        else {
                            *p_error_code = OAM_SET_PARAMETER_INPUT_INCORRECT;
                            oam_get_err_string_n_err_code(*p_error_code,
                                    &usr_err_code,
                                    &err_string);

                            err_string = "Overload/Highload/Midload Should be "
                                "in descending order";
                            err_str_size = oam_strlen(err_string) + 1;
                            usr_resp = OAM_RESULT_FAILURE;
                        }

                        oam_construct_n_send_set_resp_to_usr(usr_resp,
                                usr_err_code,
                                (UInt8*)err_string,
                                err_str_size,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                dest_id,
                                trans_id,
                                OAM_ZERO,
                                OAM_ZERO,
                                p_error_code);
                        usr_intf_flag = OAM_FALSE;
                        /* SPR 11001 FIX END */
                    }
                    else
                    {
                        ret_val = OAM_FAILURE;
                    }
                    /* Coverity 83684 fix end */
                }
                break;

                /* CSR 00051709 Change Start*/
            case OAM_S1AP_ADD_MME_REQ_MASK:
                if (OAM_TRUE == oam_prov_req.system_status.cell_setup_complete)
                {
                    trans_id = get_word_from_header((UInt8 *)p_api_buf); 
#ifndef OAM_UT_FRAMEWORK
                    oam_maintain_tcb(trans_id, OAM_TRANS_RRC, msg_len, p_api_buf);
#endif
                    /* SPR 11090 Change Start*/
                    if(g_S1ConnectionMode_flag == OAM_TRUE)
                    {
                        oam_memcpy(oam_prov_req.oam_igd_params.fap_control_params.S1ConnectionMode,
                                local_prov_req.oam_igd_params.fap_control_params.S1ConnectionMode,
                                OAM_S1CONNMODE_MAX_LEN);
                        /* SPR 12274 FIX START */
                        g_S1ConnectionMode_flag = OAM_FALSE;
                        /* SPR 12274 FIX END */
                    }
                    else
                    {
                        oam_memcpy(oam_prov_req.oam_igd_params.fap_control_params.S1ConnectionMode,"ONE",oam_strlen("ONE")+OAM_ONE);
                    }

                    /*SPR 11090 Final FIX Start*/	
                    oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.mme_comm_info[OAM_ZERO].port = 
                        local_prov_req.oam_igd_params.fap_control_params.S1SigLinkPort;
                    /*SPR 11090 Final FIX End*/
                    /* SPR 11090 Change End*/
                    oam_s1SigLinkServerList_t oam_s1ap_add_mme_req; 
                    oam_s1SigLinkServerList_t oam_s1ap_close_mme_req;
                    oam_s1SigLinkServerList_t oam_s1ap_reestablish_mme_req;
                    oam_memset((void *)&oam_s1ap_add_mme_req,0,sizeof(oam_s1SigLinkServerList_t));
                    oam_memset((void *)&oam_s1ap_close_mme_req,0,sizeof(oam_s1SigLinkServerList_t));
                    oam_memset((void *)&oam_s1ap_reestablish_mme_req,0,sizeof(oam_s1SigLinkServerList_t));
					OAM_LOG(OAM, OAM_DETAILED, "S1AP_ADD_MME_REQ is received analyzing the IP ADDRESS");
                    /* SPR 11090 Change Start*/
                    if(!oam_memcmp(oam_prov_req.oam_igd_params.fap_control_params.S1ConnectionMode,"ONE",oam_strlen("ONE")))
                    {
                        oam_strcpy((char *)TempValue,((char *)local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList));
						OAM_LOG(OAM, OAM_DETAILED, "IP RECEIVED : %s",local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList);
                        temp_ip = oam_strtok((char *)TempValue,",");
						OAM_LOG(OAM, OAM_DETAILED, "First tokenised ip : %s",temp_ip);
                        /* Coverity 86860 Fix Start */
                        //oam_strcpy((char *)TempValue,temp_ip);
                        if(OAM_NULL != temp_ip)
                        {
			    OAM_LOG(OAM, OAM_DETAILED, "FirstTEMPIP tokenised ip : %s",temp_ip);
                            oam_memset((void *)(local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList),0,OAM_MAX_MME_LIST_LEN);
                            oam_strcpy((char *)local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,temp_ip);
						OAM_LOG(OAM, OAM_DETAILED, "First local tokenised ip : %s",local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList);
                        }
                        else
                        {
							OAM_LOG(OAM,OAM_WARNING,"Invalid Input For MME IP");
                        }
                        /* Coverity 86860 Fix End */
                    }
                    /* SPR 11090 Change End*/ 

                    oam_mme_ip_analysis(&oam_s1ap_add_mme_req,&oam_s1ap_close_mme_req,&oam_s1ap_reestablish_mme_req);
                    if(OAM_ZERO < oam_s1ap_add_mme_req.num_ip_addr)
                    {
                        oam_handle_add_mme_req(&oam_s1ap_add_mme_req,trans_id,msg_len,p_api_buf);
                    } 
                    if(OAM_ZERO < oam_s1ap_close_mme_req.num_ip_addr)
                    {
                        oam_handle_close_mme_req(&oam_s1ap_close_mme_req);
                    }    
                    if(OAM_ZERO < oam_s1ap_reestablish_mme_req.num_ip_addr)
                    {
                        oam_handle_reestablish_mme_conn_req(&oam_s1ap_reestablish_mme_req);
                    }   
                    if(g_flag_add_mme_sent == OAM_FALSE)
                    {
                        if((oam_s1ap_close_mme_req.num_ip_addr == OAM_ZERO)&&
                                (oam_s1ap_reestablish_mme_req.num_ip_addr == OAM_ZERO)&&(oam_s1ap_add_mme_req.num_ip_addr== OAM_ZERO))
                        {

                            OAM_LOG(OAM,OAM_DETAILED,"Sending Failure Resp To User, Mme Contain in SPV Already Added");
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR,
                                    (UInt8 *) "Mme Already Added",oam_strlen("Mme Already Added")+1,
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    TR069_MODULE_ID, trans_id, OAM_ZERO, OAM_ZERO,
                                    p_error_code);
                        }
                        else
                        {

                            oam_memcpy(&oam_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,
                                    &local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,OAM_MAX_MME_LIST_LEN);

                            /*SPR 11090 Final FIX Start*/	
                            oam_prov_req.oam_igd_params.fap_control_params.S1SigLinkPort =
                                local_prov_req.oam_igd_params.fap_control_params.S1SigLinkPort;
                            /*SPR 11090 Final FIX End*/	
                            OAM_LOG(OAM,OAM_DETAILED,"Sending Success Resp To User");
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                    OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    TR069_MODULE_ID, trans_id, OAM_ZERO, OAM_ZERO,
                                    p_error_code);
                        }
                    }
                } /* SPR 13186 Fix Start */
                else
                {
                    /* Spv Received at Init Time Updating prov structure Only */
                    oam_prov_req.oam_igd_params.fap_control_params.S1SigLinkPort =
                        local_prov_req.oam_igd_params.fap_control_params.S1SigLinkPort;

                    oam_update_xml_dom(OAM_SUCCESS,
                            p_orig_parent, p_req_parent,
                            p_p_xml_struct_addr);

                    oam_memcpy((void *)&oam_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,
                            (void *)&local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,OAM_MAX_MME_LIST_LEN);


                    /* spr_21013_fix_start */
                    oam_persist_one_parameter(xml_struct_tr196_g.FAPService[OAM_ZERO].Gateway,
                            /* spr_21013_fix_end */
                            "S1SigLinkServerList",(UInt8 *)oam_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList);

                    OAM_LOG(OAM,OAM_DETAILED,"Sending Success Resp To User");
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                            p_error_code);
                }/* SPR 13186 Fix End */   
                flag_found = 1;
                break;

                /* CSR 00051709 Change End*/
            case OAM_FM_SUPP_ALARM_REP_MECH_SET_REQ_MASK:
                query_idx = LOCAL_FM_CNTXT.fm_query_idx;
                for(loop = OAM_ZERO; loop <= DISABLED_ALARM; ++loop) {
                    if(!oam_strcmp((Char8*)LOCAL_FM_CNTXT.supported_alarm_list[query_idx].
                                reporting_mechanism_str,
                                oam_table_alarm_report_mechanism[loop].
                                report_type)) {
                        oam_memset(FM_CNTXT.supported_alarm_list[query_idx].
                                reporting_mechanism_str, OAM_ZERO,
                                sizeof(FM_CNTXT.supported_alarm_list[query_idx].
                                    reporting_mechanism_str));

                        oam_strncpy((Char8*)FM_CNTXT.supported_alarm_list[query_idx].
                                reporting_mechanism_str,
                                (Char8*)LOCAL_FM_CNTXT.supported_alarm_list[query_idx].
                                reporting_mechanism_str,
                                sizeof(FM_CNTXT.supported_alarm_list[query_idx].
                                    reporting_mechanism_str));
                        /* Coverity FIX 54278 */
                        FM_CNTXT.supported_alarm_list[query_idx].reporting_mechanism
                            = (alarm_report_mechanism_et)oam_table_alarm_report_mechanism[loop].report_id;
                        break;
                    }
                }

                /* Send set parameters response from here only */
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                        OAM_ZERO, OAM_NULL,
                        OAM_ZERO,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id, trans_id,
                        OAM_ZERO, OAM_ZERO,
                        p_error_code);

                flag_found = 1;
                break;

            case OAM_FM_CLEAN_HISTORY_REQ_MASK:
                oam_fm_clear_history();

                /* Send set parameters response from here only */
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                        OAM_ZERO, OAM_NULL,
                        OAM_ZERO,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id, trans_id,
                        OAM_ZERO, OAM_ZERO,
                        p_error_code);
                flag_found = 1;
                break;

            case OAM_FM_CLEAN_ALARM_LIST_REQ_MASK:
                oam_fm_clear_current_alarm_list();

                /* Send set parameters response from here only */
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                        OAM_ZERO, OAM_NULL,
                        OAM_ZERO,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id, trans_id,
                        OAM_ZERO, OAM_ZERO,
                        p_error_code);
                flag_found = 1;
                break;

                /*eICIC_PHASE_1_2_CHANGES_START*/

#ifndef OAM_SON_ENABLE
                /* SPR-16334 START */
            case X2AP_OAM_ENB_ADD_UPDATE_DELETE_REQ_MASK:
                {
                    SInt16  idx = OAM_MINUS_ONE;
                    trans_id = get_word_from_header((UInt8 *)p_api_buf); 
                    oam_memset(&local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req,
                            OAM_ZERO,
                            sizeof(oam_x2ap_add_enb_req_t));
                    local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.num_peer_enb =
                        OAM_ONE;

                    if(X2_ENB_COMM_INFO_IPV6_IP_ADDR_PRESENT &
                            local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[OAM_ZERO].bitmask)
                    {
                        local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[OAM_ZERO].bitmask |= 
                            X2_ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT;
                        local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[OAM_ZERO].num_ipv6_addr = OAM_ONE;
                        idx = x2_get_idx_from_nbr_enb_add_list(
                                &oam_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req,
                                &local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[OAM_ZERO]);
                    }
                    else
                    {    
                        local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[OAM_ZERO].num_ip_addr = OAM_ONE;
                        idx = x2_get_idx_from_nbr_enb_add_list(
                                &oam_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req,
                                &local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[OAM_ZERO]);
                    }          
                    if((OAM_MINUS_ONE != idx) && local_prov_req.oam_l3_req.oam_x2ap_req.action == 1)
                    {
                        /*coverity 109021 fix start*/
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_INTERNAL_ERROR, (UInt8 *) "Neighbor Exists, Cannot Add New", 
                                oam_strlen("Neighbor Exists, Cannot Add New")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id,OAM_ZERO,
                                OAM_ZERO,p_error_code);
                        /*coverity 109021 fix end*/
                        flag_found = 1;
                        break;

                    }
                    if((OAM_MINUS_ONE == idx) && local_prov_req.oam_l3_req.oam_x2ap_req.action == 2)
                    {
                        /*coverity 109021 fix start*/
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_INTERNAL_ERROR, (UInt8 *) "Neighbor Do Not Exists, Cannot Modify", 
                                oam_strlen("Neighbor Do Not Exists, Cannot Modify")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id,OAM_ZERO,
                                OAM_ZERO,p_error_code);
                        /*coverity 109021 fix end*/
                        flag_found = 1;
                        break;

                    }
                    if((local_prov_req.oam_l3_req.oam_x2ap_req.action == 1) ||
                            (local_prov_req.oam_l3_req.oam_x2ap_req.action == 2)) 
                    { 
                        oam_prov_req.system_status.event_ongoing |= OAM_X2AP_ENB_ADD_ONGOING;
                        oam_maintain_tcb(trans_id, OAM_TRANS_RRC, msg_len, p_api_buf);

                        oam_memcpy(&local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.enb_info[OAM_ZERO],
                                &local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[OAM_ZERO],
                                sizeof(x2_enb_comm_info_t));

                        if(OAM_SUCCESS == oam_add_x2ap_enb_req(&local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req, trans_id))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Successfully sent X2AP_ADD_ENB_REQ");
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_ERROR, "Failed to send X2AP_ADD_ENB_REQ");
                            /*coverity 109021 fix start*/
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR, (UInt8 *) "X2AP_ADD_ENB_REQ Fail", 
                                    oam_strlen("X2AP_ADD_ENB_REQ Fail")+ OAM_ONE,
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    dest_id, trans_id,OAM_ZERO,
                                    OAM_ZERO,p_error_code);
                            /*coverity 109021 fix end*/
                        }
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Request for X2AP_DEL_ENB_REQ received");
                        oam_x2ap_delete_enb_req_t oam_x2ap_delete_enb_req;
                        oam_memcpy(&oam_x2ap_delete_enb_req.gb_enb_id, &local_prov_req.oam_l3_req.peer_enb_data.
                                eNB_id[OAM_ZERO], sizeof(x2_gb_enb_id_t) ); 
                        oam_maintain_tcb(trans_id, OAM_TRANS_RRC, msg_len, p_api_buf);

                        /* send enb_add_req to x2ap */
                        /* BCOM Compiltaion Fix */
                        if (OAM_FAILURE == oam_x2apCommon_send_x2ap_delete_enb_req(
                                    &oam_x2ap_delete_enb_req,
                                    OAM_MODULE_ID,
                                    RRC_MODULE_ID,
                                    trans_id,
                                    oam_prov_req.cell_cntxt.curr_cell_cid))
                            /* BCOM Compiltaion Fix */
                        {               
                            OAM_LOG(OAM, OAM_WARNING,
                                    "delete eNB request with transaction id = %u could not be "
                                    "sent to RRC", trans_id);
                        }   
                        else
                        {
                            oam_prov_req.system_status.event_ongoing  |= OAM_X2AP_ENB_DEL_ONGOING;
                            OAM_LOG(OAM, OAM_INFO,
                                    "delete eNB request with transaction id = %u sent "
                                    "from %u to %u", trans_id,
                                    OAM_MODULE_ID, RRC_MODULE_ID);
                        }

                    }
                    flag_found = 1;
                }
                break;
#endif
                /* SPR-16334 END */


#ifdef OAM_SON_ENABLE
			case OAM_SON_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ_MASK :
            /*SPR 21284 FIXED START */    
				OAM_LOG(OAM, OAM_INFO,
						"Request to modify ANR_NEIGHBOUR_DEFUALT_CONFIG received");
				ret_val= oam_son_send_son_oam_anr_neighbor_default_config_req(
						p_local_req,
						OAM_MODULE_ID, SON_MODULE_ID,
						trans_id,
						curr_cid);
				if (OAM_FAILURE == ret_val) {
					OAM_LOG(OAM, OAM_ERROR,
							"Error in sending SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ, cell context = %d", curr_cid);
				}
				else 
				{

                /* SPR 21154 Fixed Start */
                     usr_intf_flag = OAM_TRUE;
                /* SPR 21154 Fixed End */
					OAM_LOG(OAM, OAM_INFO,
							"SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ request sent successfully "
							"to lower layer");

                    
					OAM_LOG(OAM, OAM_DETAILED, "OAM  maintain TCB %d", trans_id);

                /* SPR 21154 Fixed Start */
	                 ret_val =  oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
								OAM_TRANS_SON,msg_len,p_api_buf);
					
                /* SPR 21154 Fixed End */
					if (OAM_FAILURE == ret_val) {
						OAM_LOG(OAM, OAM_WARNING, "Failed to maintain TCB ");
						ret_val = OAM_FAILURE;
					}
                }

                flag_found = OAM_ONE;
                break;
                /*SPR 21284 FIXED END */
                /*SPR 14554 start*/
            case OAM_SON_INFO_IND_MASK:

                OAM_LOG(OAM, OAM_INFO,
                        "Request to modify OAM_SON_INFO_IND received");
                        /*SPR 21702 Start*/
				if (local_prov_req.oam_son_req.oam_son_cell_info_ind[curr_cid].serving_cell[OAM_ZERO].
                        abs_usage_threshold.max_abs_usage_threshold <
						local_prov_req.oam_son_req.oam_son_cell_info_ind[curr_cid].serving_cell[OAM_ZERO].
                        abs_usage_threshold.min_abs_usage_threshold
                        /*SPR 21702 End*/
                   )
                {
                    *p_error_code = OAM_INVALID_REQ;
					OAM_LOG(OAM, OAM_WARNING,
                            "Unable to send SON_OAM_CELL_INFO_IND as max_abs_usage_threshold is less than min_abs_usage_threshold");
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ZERO, OAM_NULL,
                            OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dest_id, trans_id,
                            OAM_ZERO, OAM_ZERO,
                            p_error_code);

                    flag_found = OAM_ONE;
                }
                else
                {
                    ret_val= oam_son_send_son_oam_cell_info_ind(
                            p_local_req,
                            OAM_MODULE_ID, 
                            SON_MODULE_ID,
                            trans_id,
                            curr_cid);
                    if (OAM_FAILURE == ret_val) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Error in sending SON_OAM_CELL_INFO_IND");
                    }
                    else 
                    {
                        OAM_LOG(OAM, OAM_INFO,
                                "SON_OAM_CELL_INFO_IND sent successfully "
                                "to lower layer");
                        ret_val = oam_maintain_tcb_ext(trans_id, OAM_TRANS_SON,
                                msg_len, p_api_buf,
                                p_orig_parent, p_req_parent,
                                p_p_xml_struct_addr);

                        if (OAM_FAILURE == ret_val) {
							OAM_LOG(OAM, OAM_WARNING, "Failed to maintain TCB ");
                            ret_val = OAM_FAILURE;
                        }

                    }

                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL,
                            OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dest_id, trans_id,
                            OAM_ZERO, OAM_ZERO,
                            p_error_code);

                    flag_found = OAM_ONE;
                }
                break;

                /*SPR 14554 end*/
                /*eICIC_PHASE_1_2_CHANGES_END*/

                /* SPR_19619 start*/
                /* CID : 63601 Fix Start */

            case OAM_SON_CELL_ACTIVATION_INFO_MASK:


                /*SPR 21587 +-*/

                OAM_LOG(OAM, OAM_DETAILED,
                        "Request for Peer Cell Activation received ");

                cell_config_idx = oam_get_son_serving_cell_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                    OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);
                    return OAM_FAILURE;
                }


                ret_val = oam_mem_alloc(sizeof(oam_son_peer_cell_activation_req_t),
                        (void**)&p_son_cell_activation_req, p_error_code);
                if (OAM_FAILURE == ret_val) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to p_son_cell_activation_req failed"
                            " with Error Code:%d",
                            *p_error_code);
                    OAM_FUN_EXIT_TRACE();
                    return ret_val;
                }

                oam_memset(p_son_cell_activation_req, OAM_ZERO,
                        sizeof(oam_son_peer_cell_activation_req_t));

                p_son_cell_activation_req->bitmask |= SON_PEER_CELL_ACTIVATION_PRESENT;

                /*SPR 21587 Start*/
                p_son_cell_activation_req->num_served_cell = OAM_ONE;
                /*SPR 21587 End*/

                for (cell_counter = 0; cell_counter < p_son_cell_activation_req->num_served_cell; cell_counter++)
                {  

                    oam_memcpy(&p_son_cell_activation_req->served_cell_list[cell_counter],
                            &local_prov_req.oam_son_req.oam_son_peer_cell_activation_req.served_cell_list[cell_counter],
                            sizeof(son_intra_rat_global_cell_id_t));

                }
                OAM_LOG(OAM, OAM_INFO,"value of transid [%d] cellid [%d]",
                    trans_id, curr_cid);


                ret_val= oam_son_send_son_oam_peer_cell_activation_req(
                        p_son_cell_activation_req,
                        OAM_MODULE_ID, 
                        SON_MODULE_ID,
                        trans_id,
                        curr_cid);

                if (OAM_FAILURE == ret_val) {
                    OAM_LOG(OAM, OAM_WARNING,
                            "Error in sending SON_OAM_PEER_CELL_ACTIVATION_REQ");
                    return OAM_FAILURE;
                }
                else 
                {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_PEER_CELL_ACTIVATION_REQ sent successfully "
                            "to lower layer");

                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                                OAM_TRANS_SON,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
                }

                oam_mem_free(p_son_cell_activation_req, p_error_code);
                break;

                /* CID : 63601 Fix End */
                /* SPR_19619 stop*/
#endif
                /*eICIC_PHASE_1_2_CHANGES_END*/
                /* SPR 20653 Fix Start */
            case OAM_SON_ANR_MODIFY_ATTRIBUTE_MASK:
                cell_config_idx = oam_get_son_serving_cell_idx(curr_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                    OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            curr_cid);
                    return OAM_FAILURE;
                }

                ret_val = oam_son_send_son_oam_anr_modify_attribute_req(
                        p_local_req,
                        OAM_MODULE_ID,
                        SON_MODULE_ID,
                        tcb_transaction_id,
                        curr_cid);

                if (OAM_FAILURE == ret_val) {     
                    OAM_LOG(OAM, OAM_ERROR,
                            "Sending SON_OAM_ANR_MODIFY_ATTRIBUTE_REQ to lower layer failed");
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Sending SON_OAM_ANR_MODIFY_ATTRIBUTE_REQ to lower layer successful");
                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(tcb_transaction_id,OAM_SUB_MODULE_SON,
                                OAM_TRANS_SON,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                }
                break; 

                /* SPR 20653 Fix End */

        }
        /*  Coverity ID : 85871 Fix Start */
        if (flag_found){
            break;
        }
        /*  Coverity ID : 85871 Fix End */
    }
    if(!flag_found) {
        OAM_LOG(OAM, OAM_DETAILED, "Invalid request is received");
    }

    /* If state is not active, don't send message to lower layer,
       just update the actual provisioning structure */

    if((OAM_CM_ST_ACTIVE !=  p_cm_cntxt->state) &&
            !(OAM_SET_ADMIN_STATE_RESP_PENDING & oam_prov_req.system_status.event_ongoing))
    {

        /* Send set parameters response from here only */
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                OAM_ZERO,(UInt8 *) OAM_NULL, OAM_ZERO,
                OAM_VERSION_ID, OAM_MODULE_ID,
                dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                p_error_code);
    }

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}

/******************************************************************************
 * Function Name: oam_search_string_to_integer
 * Description  : This function search the user entered string from array and return
 *                correspondence int value
 * Inputs       :  parmeter_value: parameter value
 *                 parmeter_table_address :parameter table address
 * Outputs      : parmeter_value   : Message buffer
 * Returns      : OAM_SUCCESS/OAM_FAILURE
 ********************************************************************************/
/* Coverity 69695 Fix Start */
oam_return_et oam_search_string_to_integer
(
 char * parmeter_value,
 enumerated_string_fields_mapping_tbl_t *par_table_address,
 oam_counter_t count
 )
{
	UInt16 counter = OAM_ZERO;
	oam_return_et retStatus = OAM_SUCCESS;
	/* Coverity 69695 Fix End */
	for (counter = OAM_ZERO ; counter < count; counter++)
	{
		if(oam_strncasecmp(par_table_address[counter].display_string,(char *) parmeter_value, oam_strlen(par_table_address[counter].display_string)) == OAM_ZERO)
		{
			oam_sprintf (parmeter_value , "%d" , par_table_address[counter].internal_value);
			break;
		} 
	}
	return retStatus;
}

/******************************************************************************
 * * Function Name: oam_search_string_to_integer_for_get
 * * Description  : This function search the user entered string from array and return
 * *                correspondence int value
 * * Inputs       :  parmeter_value: parameter value
 * *                 parmeter_table_address :parameter table address
 * * Outputs      : parmeter_value   : Message buffer
 * * Returns      : OAM_SUCCESS/OAM_FAILURE
 * ********************************************************************************/
/* Coverity 69696 Fix Start */
oam_return_et oam_search_string_to_integer_for_get
(
 char * parmeter_value,
 enumerated_string_fields_mapping_tbl_t *par_table_address,
 oam_counter_t count
 )
{
	UInt16 counter = OAM_ZERO;
	oam_return_et retStatus = OAM_SUCCESS;
	/* Coverity 69696 Fix End */
	for (counter = OAM_ZERO ; counter < count; counter++)
	{   
		if(par_table_address[counter].internal_value == oam_atoi((char *)parmeter_value)) 
		{    
			oam_sprintf (parmeter_value , "%s" , par_table_address[counter].display_string);
			break;
		}    
	}    
	return retStatus;
}


/******************************************************************************
 * Function Name: oam_search_integer_to_integer
 * Description  : This function search the user entered int value into array and return
 *                correspondence int value
 * Inputs       :  parmeter_value: parameter value
 *                 parmeter_table_address :parameter table address
 * Outputs      : parmeter_value   : Message buffer
 * Returns      : OAM_SUCCESS/OAM_FAILURE
 ********************************************************************************/
/* coverity 53563 53562 */
oam_return_et oam_search_integer_to_interger
(
 char * parmeter_value,
 int   * par_table_address,
 oam_counter_t count
 )
{
	OAM_FUN_ENTRY_TRACE();
	UInt8 counter = OAM_ZERO;
	oam_return_et retStatus = OAM_FAILURE;
	for (counter = OAM_ZERO ; counter < count; counter++)
	{
		if(*(par_table_address+ counter) == oam_atoi((char *)parmeter_value))
		{
			/*Coverity Fixes*/
			/*Coverity CID 62512 Fix */
			/* OAM_SPR 11677 Fix Start */
			oam_snprintf (parmeter_value ,oam_strlen(parmeter_value) + OAM_TWO, "%d" , *(par_table_address + count + counter));
			/* OAM_SPR 11677 Fix End */
			retStatus = OAM_SUCCESS;
			break;
		} 
	}

	OAM_FUN_EXIT_TRACE();
	return retStatus;
}

/******************************************************************************
 * * Function Name: oam_search_integer_to_integer_for_get
 * * Description  : This function search the user entered int value into array and return
 * *                correspondence int value
 * * Inputs       :  parmeter_value: parameter value
 * *                 parmeter_table_address :parameter table address
 * * Outputs      : parmeter_value   : Message buffer
 * * Returns      : OAM_SUCCESS/OAM_FAILURE
 * ********************************************************************************/
/* coverity 52806 */
oam_return_et oam_search_integer_to_interger_for_get
(
 char * parmeter_value,
 int   * par_table_address,
 oam_counter_t count
 )
{
	OAM_FUN_ENTRY_TRACE();
	UInt8 counter = OAM_ZERO;
	oam_return_et retStatus = OAM_FAILURE;
	for (counter = OAM_ZERO ; counter < count; counter++)
	{
		if(*(par_table_address + count + counter ) == oam_atoi((char *)parmeter_value))
		{

			/*Coverity Fixes*/


			oam_sprintf (parmeter_value,  "%d" , *(par_table_address + counter));
			retStatus = OAM_SUCCESS;
			break;
		}
	}

	OAM_FUN_EXIT_TRACE();
	return retStatus;
}

/******************************************************************************
 * Function Name: oam_update_enum_values
 * Description  : This function match from the enum and return the correspondence value
 * Inputs       :  parmeter_name: parameter Name
 *                 parmeter_value :parameter value
 * Outputs      : parmeter_value   : Message buffer
 * Returns      : OAM_SUCCESS/OAM_FAILURE
 ********************************************************************************/
oam_return_et oam_update_enum_values
(
 char * parmeter_name, 
 char * parmeter_value
 )
{
	OAM_FUN_ENTRY_TRACE();
	enumerated_string_fields_mapping_tbl_t *par_table_address = OAM_NULL;
	/* coverity 35899 */    
	oam_return_et retStatus = OAM_SUCCESS;
	if (oam_strncasecmp("LoadReporting.Action_For_Load", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)                         
	{                                             
		par_table_address = &Action_load[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_ELEVEN);

	}
    /* spr_21013_fix_start */
	if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RF.DLBandwidth", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &DLBandwidth[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_SIX);
	}
    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    /* SPR 18472 Fix Start */
    else if (!oam_strcmp("InternetGatewayDevice.Services.FAPService."
                "CellConfig.LTE.RAN.PHY.MBSFN."
                "SFConfigList.RadioFrameAllocationPeriod", parmeter_name))
    {
        par_table_address = &radioframeAllocOffset_tbl[OAM_ZERO];
        oam_search_full_string_to_integer(parmeter_value,
                par_table_address,
                ARRSIZE(radioframeAllocOffset_tbl));
    }
    /* SPR 18472 Fix End */
    /* 7.0 OAM_SSI Fix Start */
    else if (!oam_strcmp("eNodeBParams.stack_config.L3Params.M2AP.M2AP_LOG_LEVEL",
                parmeter_name))
        /* 7.0 OAM_SSI Fix End */
    {
        par_table_address = &m2ap_log_level[OAM_ZERO];
        oam_search_string_to_integer(parmeter_value,
                par_table_address,
                ARRSIZE(m2ap_log_level));
    }
    /* EMBMS Changes End */
#endif

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.SRSBandwidthConfig", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &srsBandwidthConfig[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_NINE);

	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.HoppingMode", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &hoppingMode[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_THREE);

	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RF.ULBandwidth", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &UlBandwidth[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_SIX);

	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.Type", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &Type[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_THREE);

	}
    /* SPR 15527 START */
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DISCARD_TIMER", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        enumerated_string_fields_mapping_tbl_t *par_table_address = &qosDiscardTimer[OAM_ZERO];
        oam_search_string_to_integer(parmeter_value,par_table_address, RRM_OAM_PDCP_DISCARD_TIMER_COUNT);

    }
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DSR_MAX_TRANSMISSIONS", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        enumerated_string_fields_mapping_tbl_t *par_table_address = &qosSrMaxTransmission[OAM_ZERO];
        oam_search_string_to_integer(parmeter_value,par_table_address, RRM_OAM_SR_MAX_TRANSMISSION_COUNT);

    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_SUPPORTED_RAT", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
      UInt8 bit_set = OAM_ZERO;
      Char8 *temp_str = OAM_NULL;
      Char8 *rat_str = OAM_NULL;
      rat_str = (Char8*)parmeter_value;
      OAM_LOG(OAM, OAM_DETAILED, "Value of X_VENDOR_SUPPORTED_RAT is %s", rat_str);
      temp_str = strtok(rat_str, ",");
      while(temp_str) {
        int temp_value = oam_xml_search_string_to_integer(temp_str,
            SupportedRat_MAP,
            MAX_SUPPORTED_RAT);

        if(temp_value == OAM_INVALID_RETURN) {
          OAM_LOG(OAM, OAM_WARNING,
              "Skipping Unsupported RAT Type: %s",temp_str);
          temp_str = strtok(OAM_NULL , ",");
          continue;
        }

        if(OAM_ZERO != temp_value)
        {
          bit_set |= OAM_ONE << ((UInt8)temp_value - OAM_ONE);
        }

        temp_str = strtok(OAM_NULL , ",");
      }
      oam_sprintf (parmeter_value , "%d" , bit_set);
    }

    /* SPR 15527 END */

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE.AccessMode", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &access_mode_str_enum_tbl[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUCCH.DeltaPUCCHShift", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &DeltaPUCCHShift[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.TriggerQuantity", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &TriggerQuantity[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_THREE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportQuantity", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &ReportQuantity[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_THREE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.MeasQuantityUTRAFDD", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &MeasQuantityUTRAFDD[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_THREE);
	}
	/* SPR 12920 START */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_OPEN_PHY_CELLID_RANGE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &PhyCellidRange[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, SON_OAM_PHY_CELLID_RANGE_COUNT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_CSG_PHY_CELLID_RANGE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &PhyCellidRange[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, SON_OAM_PHY_CELLID_RANGE_COUNT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_HYBRID_PHY_CELLID_RANGE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &PhyCellidRange[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, SON_OAM_PHY_CELLID_RANGE_COUNT);
	}
	/* SPR 12920 END */

	/*Integer - Integer*/
	/* SPR 21737 Start */
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.Alpha", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_PHY_ULPowerControl_Alpha[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_PHY_ULPowerControl_Alpha[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PRS.NumConsecutivePRSSubframes", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_PHY_PRS_NumConsecutivePRSSubfames[OAM_ZERO],OAM_GET_SIZEOF_ARRAY(RAN_PHY_PRS_NumConsecutivePRSSubfames[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.NumberOfRaPreambles", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value, RAN_MAC_RACH_NumberOfRaPreambles[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_NumberOfRaPreambles[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.SizeOfRaGroupA", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_RACH_sizeOfRaGroupA[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_sizeOfRaGroupA[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.MessageSizeGroupA", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_RACH_messageSizeGroupA[OAM_ZERO] ,OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_messageSizeGroupA[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.MessagePowerOffsetGroupB", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_RACH_messagePowerOffsetGroupB[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_messagePowerOffsetGroupB[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.PowerRampingStep", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_RACH_powerRampingStep[OAM_ZERO] ,OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_powerRampingStep[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.PreambleInitialReceivedTargetPower", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_RACH_preambleInitialReceivedTargetPower[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_preambleInitialReceivedTargetPower[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.PreambleTransMax", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_RACH_preambleTransMax[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_preambleTransMax[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.ResponseWindowSize", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_RACH_ResponseWindowSize[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_ResponseWindowSize[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.ContentionResolutionTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_RACH_ContentionResolutionTimer[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_MAC_RACH_ContentionResolutionTimer[OAM_ZERO]));
	}
    
/* SPR 21643 changes start */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.OnDurationTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_OnDurationTimer[OAM_ZERO] , OAM_SEVENTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.DRXInactivityTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO] , OAM_TWENTY_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.DRXRetransmissionTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO] , OAM_NINE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.LongDRXCycle", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_longDRXCycle[OAM_ZERO] , OAM_SEVENTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.ShortDRXCycle", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_shortDRXCycle[OAM_ZERO] , OAM_SEVENTEEN);
	}

    /* SPR 21643 changes end */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.TPollRetransmit", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.PollPDU", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_pollPDU[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_pollPDU[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.PollByte", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_pollByte[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_pollByte[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.MaxRetxThreshold", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_MaxRetxThreshold[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_MaxRetxThreshold[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.TReordering", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TReordering[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_TReordering[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.TStatusProhibit", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.MeasQuantityCDMA2000", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &RAN_Mobility_ConnMode_IRAT_MeasQuantityCDMA2000[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address, OAM_TWO);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.TPollRetransmit", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.PollPDU", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_pollPDU[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_pollPDU[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.PollByte", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_pollByte[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_pollByte[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.MaxRetxThreshold", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_MaxRetxThreshold[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_MaxRetxThreshold[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.TReordering", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TReordering[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_TReordering[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.TStatusProhibit", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO]));
	}
#ifdef OAM_SON_ENABLE
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.InterFreq."
				"Carrier.X_VENDOR_CM_OFFSET_FREQ")) {
		retStatus = oam_search_integer_to_interger(parmeter_value,
				carrier_qoffset_freq_tbl[OAM_ZERO],
				INTERFREQ_CARRIER_QOFFSETFREQ_COUNT);
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.InterFreq."
				"Carrier.QOffsetFreq")) {
		retStatus = oam_search_integer_to_interger(parmeter_value,
				carrier_qoffset_freq_tbl[OAM_ZERO],
				INTERFREQ_CARRIER_QOFFSETFREQ_COUNT);
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.InterFreq."
				"Carrier.TReselectionEUTRASFMedium")) {
		retStatus =
			oam_search_integer_to_interger(parmeter_value,
					RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO],
					OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO]));
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.InterFreq."
				"Carrier.TReselectionEUTRASFHigh")) {
		retStatus =
			oam_search_integer_to_interger(parmeter_value,
					RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO],
					OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO]));
	}
#endif
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.TReselectionEUTRASFMedium", parmeter_name, oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.TReselectionEUTRASFMedium")) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO]));
	}
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.TReselectionEUTRASFHigh", parmeter_name, oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.TReselectionEUTRASFHigh")) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T300", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_T300[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_T300[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T301", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_T301[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_T301[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T302", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_T302[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_T302[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T304EUTRA", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_T304EUTRA[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_T304EUTRA[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T304IRAT", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_T304IRAT[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_T304IRAT[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T310", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_T310[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_T310[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T311", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_T311[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_T311[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T320", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_T320[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_T320[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.N310", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_N310[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_N310[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.N311", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_RRCTimers_N311[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_RRCTimers_N311[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.PacketDelayBudget", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,EPC_QoS_PacketDelayBudget[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(EPC_QoS_PacketDelayBudget[OAM_ZERO]));
	}
/*SPR 15527 START*/
    else if (oam_strncasecmp(
                "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_PACKETERRORLOSSRATE",
                parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,packetErrorLossRate[OAM_ZERO] ,PCKT_ERR_LOSS_RATE_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DDL_PARAM_T_STATUES_PROHIBIT", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO] , TSTATUSPROHIBIT_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DDL_PARAM_T_POLL_PDU", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_pollPDU[OAM_ZERO] , POLLPDU_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DDL_PARAM_T_POLL_RETRANSMIT", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO] , TPOLLRETRANSMIT_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DL_PARAM_T_REORDERING_AM", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TReordering[OAM_ZERO] , TREORDERING_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DL_PARAM_T_REORDERING_UM", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_TReordering[OAM_ZERO] , TREORDERING_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_UL_AM_POLL_BYTE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_RLC_SRB1_pollByte[OAM_ZERO] , POLLBYTE_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_MAX_RETX_THRESHOLD", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,EPC_MAX_RETX_THRESHOLD[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(EPC_MAX_RETX_THRESHOLD[OAM_ZERO]));
    }
    /* SPR 21411 changes start */
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DRX_ON_DURATION_TIMER", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_OnDurationTimer[OAM_ZERO] , ONDURATIONTIMER_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DRX_INACTIVITY_TIMER", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO] , DRXINACTIVITYTIMER_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DRX_RETRANSMISSION_TIMER", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO] , DRXRETRANSMISSIONTIMER_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_LONG_DRX_CYCLE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_longDRXCycle[OAM_ZERO] , LONGDRXCYCLE_COUNT);
    }
#ifdef ENDC_ENABLED
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_LONG_DRX_CYCLE_R15", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_longDRXCycleR15[OAM_ZERO] , LONGDRXCYCLE_COUNT_R15);
    }
#endif
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_SHORT_DRX_CYCLE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RAN_MAC_DRX_shortDRXCycle[OAM_ZERO] , DRXSHORTCYCLE_COUNT);
    }

    /* SPR 21411 changes end */
/*SPR 15527 END*/
    /* SPR 20653 Fix Start */
    else if (oam_strncasecmp(
                "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_BUCKET_SIZE_DURATION",
                parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,Qos_BucketSizeDuration[OAM_ZERO] ,BUCKET_SIZE_DURATION_COUNT);
    }
    else if (oam_strncasecmp(
                "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_PRIORITIZED_BIT_RATE",
                parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,Qos_PrioritizedBitRate[OAM_ZERO] ,PRIORITIZED_BIT_RATE_COUNT);
    }
    /* SPR 20653 Fix End */

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.QHyst", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_IdleMode_Common_QHyst[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_Common_QHyst[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.QHystSFMedium", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_IdleMode_Common_QHystSFMedium[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_Common_QHystSFMedium[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.QHystSFHigh", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_IdleMode_Common_QHystSFHigh[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_Common_QHystSFHigh[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PDSCH.Pa", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_PHY_PDSCH_PA[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_PHY_PDSCH_PA[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.TEvaluation", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_IdleMode_Common_TEvaluation[OAM_ZERO] ,OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_Common_TEvaluation[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.THystNormal", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_IdleMode_Common_THystNormal[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_Common_THystNormal[OAM_ZERO]));
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.FilterCoefficientRSRP", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.FilterCoefficientRSRQ", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_ZERO] , OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.TimeToTrigger", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_EUTRA_TimeToTrigger[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_EUTRA_TimeToTrigger[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportInterval", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_EUTRA_ReportInterval[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_EUTRA_ReportInterval[OAM_ZERO]));
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportAmount", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_EUTRA_ReportAmount[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_EUTRA_ReportAmount[OAM_ZERO]));
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.FilterCoefficientUTRA", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_IRAT_FilterCoefficientUTRA[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_IRAT_FilterCoefficientUTRA[OAM_ZERO]));
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.FilterCoefficientGERAN", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_IRAT_FilterCoefficientGERAN[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_IRAT_FilterCoefficientGERAN[OAM_ZERO]));
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.TimeToTrigger", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_IRAT_TimeToTrigger[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_IRAT_TimeToTrigger[OAM_ZERO]));
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.ReportInterval", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_IRAT_ReportInterval[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_IRAT_ReportInterval[OAM_ZERO]));
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.ReportAmount", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    /* spr_21013_fix_end */
	{
		oam_search_integer_to_interger(parmeter_value,RAN_Mobility_ConnMode_IRAT_ReportAmount[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(RAN_Mobility_ConnMode_IRAT_ReportAmount[OAM_ZERO]));
	}
#ifdef OAM_SON_ENABLE
	else if(oam_strstr(parmeter_name,
/* SPR 18930  FIX START */
				"LTECell.Blacklisted"))
/* SPR 18930  FIX END */
	{
		retStatus = oam_search_integer_to_interger(parmeter_value,
				NR_Blacklisted[OAM_ZERO],
				OAM_GET_SIZEOF_ARRAY(NR_Blacklisted[OAM_ZERO]));
	}
	/* SPR-11757 removed code */ 
	else if(oam_strstr(parmeter_name,
				"LTE.RAN.NeighborList.LTECell.QOffset"))
	{
		retStatus = oam_search_integer_to_interger(parmeter_value,
				RAN_NeighborList_LTECell_QOffset[OAM_ZERO],
				OAM_GET_SIZEOF_ARRAY(RAN_NeighborList_LTECell_QOffset[OAM_ZERO]));
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.NeighborList.LTECell.CIO")) {
		retStatus = oam_search_integer_to_interger(parmeter_value,
				RAN_NeighborList_LTECell_CIO[OAM_ZERO],
				OAM_GET_SIZEOF_ARRAY(RAN_NeighborList_LTECell_CIO[OAM_ZERO]));
	}
	else if(oam_strstr(parmeter_name,
				"Mobility.IdleMode.InterFreq.Carrier.TReselectionEUTRASFMedium"))
	{
		retStatus = oam_search_integer_to_interger(parmeter_value,
				RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO],
				OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO]));

	}
	else if(oam_strstr(parmeter_name,
				"Mobility.IdleMode.InterFreq.Carrier.TReselectionEUTRASFHigh"))
	{
		retStatus = oam_search_integer_to_interger(parmeter_value,
				RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO],
				OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO]));
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.IRAT.UTRA."
				"TReselectionUTRASFMedium")) {
		retStatus = oam_search_integer_to_interger(parmeter_value,
				RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO],
				OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO]));
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.IRAT.UTRA."
				"TReselectionUTRASFHigh")) {
		retStatus = oam_search_integer_to_interger(parmeter_value,
				RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO],
				OAM_GET_SIZEOF_ARRAY(RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO]));
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.IRAT.GERAN."
				"TReselectionGERANSFMedium")) {
		retStatus =
			oam_search_integer_to_interger(parmeter_value,
					/* CSR 00070293 FIX START */
					RRM_CELL_TRESELECTIONSF[OAM_ZERO],
					/* CSR 00070293 FIX END */
					OAM_GET_SIZEOF_ARRAY(RRM_CELL_TRESELECTIONSF[OAM_ZERO]));
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.IRAT.GERAN."
				"TReselectionGERANSFHigh")) {
		retStatus =
			oam_search_integer_to_interger(parmeter_value,
					/* CSR 00070293 FIX START */
					RRM_CELL_TRESELECTIONSF[OAM_ZERO],
					/* CSR 00070293 FIX END */
					OAM_GET_SIZEOF_ARRAY(RRM_CELL_TRESELECTIONSF[OAM_ZERO]));
	}
#endif
	/* SPR 21737 End */
	/* SPR_6719 */
    /* spr_21013_fix_start */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.GERAN.TReselectionGERANSF", parmeter_name, oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.GERAN.TReselectionGERANSF")) == OAM_ZERO)
    /* spr_21013_fix_end */
	{
		/* CSR 00070293 FIX START */
		oam_search_integer_to_interger(parmeter_value,RRM_CELL_TRESELECTIONSF[OAM_ZERO],TRESELECTIONSF_COUNT);
		/* CSR 00070293 FIX END */
	}
#ifdef OAM_SON_ENABLE
	else if (oam_strstr(parmeter_name, "GERANFreqGroup.BandIndicator")) {
		par_table_address = &SON_GSM_BANDINDICATOR[OAM_ZERO];

		retStatus = oam_search_string_to_integer(parmeter_value,
				par_table_address,
				OAM_SON_GSM_BANDINDICATOR_TBL_NUM_ROWS);
	}
	/* SPR-13586 START */
	else if (oam_strstr(parmeter_name, "GSM.BandIndicator")) {
		par_table_address = &SON_GSM_BANDINDICATOR[OAM_ZERO];

		retStatus = oam_search_string_to_integer(parmeter_value,
				par_table_address,
				OAM_SON_GSM_BANDINDICATOR_TBL_NUM_ROWS);
	}
	/* SPR-13586 END */
#endif

	/*SPR_6719*/
            /* SPR 14295 FIX START */
            /* spr_21013_fix_start */
            else if (!oam_strcmp("InternetGatewayDevice.Services.FAPService."
                        "CellConfig.X_VENDOR_CARRIER_AGGREGATION_PARAMS."
                        "ScellDeactTimer", parmeter_name)) {
                par_table_address = &scell_deact_timer_map[OAM_ZERO];
                oam_search_string_to_integer(parmeter_value,
                        par_table_address,
                        OAM_SCELL_DEACT_TIMER_MAP_MAX_LEN);
            }
            /* SPR 14295 FIX END */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_CARRIER_AGGREGATION_PARAMS.ScellDeactTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    /* spr_21013_fix_end */
	{
		par_table_address = &scell_deact_timer_map[OAM_ZERO];
		oam_search_string_to_integer(parmeter_value,par_table_address,OAM_SCELL_DEACT_TIMER_MAP_MAX_LEN);
	}
	else if(oam_strstr(parmeter_name,"FAPControl.LTE.Gateway.S1ConnectionMode"))
	{
		if(sig_count==OAM_ONE)
		{
			oam_strcpy(parmeter_value, "ONE");
		} 
	}
	else if (oam_strstr(parmeter_name,
				"X_VENDOR_MEAS_BANDWIDTH_FOR_EARFCN")) {
		par_table_address = &MeasBandwidth[OAM_ZERO];
		retStatus = oam_search_string_to_integer(parmeter_value,
				par_table_address,
				RRM_OAM_BW_MEAS_COUNT);
	}

	/* SPR 16407 START */
	else if (OAM_ZERO == (oam_strncasecmp(
                    /* spr_21013_fix_start */
					"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
                    /* spr_21013_fix_end */
					"CellRestriction.CellBarred",parmeter_name, oam_strlen(parmeter_name))))
	{
		oam_search_integer_to_interger_for_get(parmeter_value,CELL_BARRED[OAM_ZERO],OAM_TWO);
	}
	/* SPR 16407 END */
	/* OAM BCOM Code Comment Changes Start */
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Invalid Parameter.");
    }
	/* OAM BCOM Code Comment Changes End */

	OAM_FUN_EXIT_TRACE();
	return retStatus;
}
/******************************************************************************
 * Function Name: oam_fetch_enum_values
 * Description  : This function match from the enum and return the correspondence value
 * Inputs       :  parmeter_name: parameter Name
 *                 parmeter_value :parameter value
 * Outputs      : parmeter_value   : Message buffer
 * Returns      : OAM_SUCCESS/OAM_FAILURE
 ********************************************************************************/
oam_return_et oam_fetch_enum_values
(
 char * parmeter_name, 
 char * parmeter_value
 )
{
	/* coverity 35899 */
	oam_return_et retStatus = OAM_SUCCESS;
	enumerated_string_fields_mapping_tbl_t *par_table_address = OAM_NULL;

	if (oam_strncasecmp("LoadReporting.Action_For_Load", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)                              {
		par_table_address = &Action_load[OAM_ZERO];                
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_ELEVEN);

	}
    /* spr_21013_fix_start */
	if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RF.DLBandwidth", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &DLBandwidth[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_SIX);
	}
    /* SPR 20653 Fix Start */
    else if (oam_strncasecmp(
                "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_RB_SIZE",
                parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RBSize[OAM_ZERO] ,RB_SIZE_COUNT);
    }
    /* SPR 20653 Fix End */
	/* SPR-10640 FIX Start */
	if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.Capabilities.SupportedSystems", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		enumerated_string_fields_mapping_tbl_t *par_table_address = &SUPPORTED_SYS[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_FOUR);
	}
	/* SPR-10640 FIX End */
#ifdef OAM_SON_ENABLE
	else if(oam_strstr(parmeter_name, "LTE.RAN.NeighborList.LTECell.CIO")) {
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				RAN_NeighborList_LTECell_CIO[OAM_ZERO],
				OAM_THIRTY_ONE);
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.NeighborList.LTECell.QOffset")) {
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				RAN_NeighborList_LTECell_QOffset[OAM_ZERO],
				OAM_THIRTY_ONE);
	}
	/* SPR 13179 FIX START */
	/* Code removed */
	/* SPR 13179 FIX END */
	else if(oam_strstr(parmeter_name,
				"LTE.RAN.NeighborList.LTECell.Blacklisted")) {
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				NR_Blacklisted[OAM_ZERO],
				OAM_TWO);
	}
#endif
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.SRS.SRSBandwidthConfig", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &srsBandwidthConfig[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_EIGHT);

	}
    /* SPR 20653 Fix Start */
    else if (oam_strncasecmp(
                "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_RB_SIZE",
                parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,RBSize[OAM_ZERO] ,RB_SIZE_COUNT);
    }
    /* SPR 20653 Fix End */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUSCH.HoppingMode", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &hoppingMode[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_TWO);

	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RF.ULBandwidth", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &UlBandwidth[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_SIX);

	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.Type", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &Type[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_TWO);

	}
    /* SPR 15527 START */
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DISCARD_TIMER", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        enumerated_string_fields_mapping_tbl_t *par_table_address = &qosDiscardTimer[OAM_ZERO];
        oam_search_string_to_integer_for_get(parmeter_value,par_table_address, RRM_OAM_PDCP_DISCARD_TIMER_COUNT);

    }
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DSR_MAX_TRANSMISSIONS", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        enumerated_string_fields_mapping_tbl_t *par_table_address = &qosSrMaxTransmission[OAM_ZERO];
        oam_search_string_to_integer_for_get(parmeter_value,par_table_address, RRM_OAM_SR_MAX_TRANSMISSION_COUNT);

    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_SUPPORTED_RAT", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
      enumerated_string_fields_mapping_tbl_t *par_table_address = &SupportedRat_MAP[OAM_ZERO];
      /* Coverity CID 85429 Fix Start */ 
      UInt8 temp_str[STR_LEN_64] = {OAM_ZERO};
      /* Coverity CID 85429 Fix End */ 
      UInt8 rat_idx = OAM_ZERO;
      UInt8 counter = OAM_ZERO;
      UInt8 supported_rat = oam_atoi((char *) parmeter_value);
      for(rat_idx = OAM_ONE;rat_idx<= MAX_SUPPORTED_RAT; rat_idx++)
      {
        if((supported_rat) & (OAM_ONE << (rat_idx-OAM_ONE)))
        {
          for (counter = OAM_ZERO ; counter < MAX_SUPPORTED_RAT; counter++)
          {   
            if(par_table_address[counter].internal_value == rat_idx) 
            {    
              oam_strcat (temp_str , par_table_address[counter].display_string);
              oam_strcat (temp_str , ",");
              break;
            }    
          }
        }
      }
      UInt16 str_len = oam_strlen((const char *)temp_str);
      if(str_len > OAM_ZERO)
      {
        temp_str[str_len-OAM_ONE] = '\0';
      }
      oam_sprintf (parmeter_value , "%s" , temp_str);

    }
    /* SPR 15527 END */

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE.AccessMode", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &access_mode_str_enum_tbl[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address,OAM_THREE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PUCCH.DeltaPUCCHShift", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &DeltaPUCCHShift[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address,OAM_THREE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.TriggerQuantity", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &TriggerQuantity[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_TWO);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportQuantity", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &ReportQuantity[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_TWO);
	}
	/* SPR 12920 START */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_OPEN_PHY_CELLID_RANGE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &PhyCellidRange[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address,SON_OAM_PHY_CELLID_RANGE_COUNT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_CSG_PHY_CELLID_RANGE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &PhyCellidRange[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address,SON_OAM_PHY_CELLID_RANGE_COUNT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
				"Mobility.IdleMode.InterFreq.Carrier.X_VENDOR_HYBRID_PHY_CELLID_RANGE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &PhyCellidRange[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address,SON_OAM_PHY_CELLID_RANGE_COUNT);
	}
	/* SPR 12920 END */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.MeasQuantityUTRAFDD", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &MeasQuantityUTRAFDD[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address,OAM_TWO);
	}
	/*Integer - Integer*/
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.Alpha", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_PHY_ULPowerControl_Alpha[OAM_ZERO], OAM_EIGHT);
	}
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.DeltaFPUCCHFormat1", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,delta_f_pucch_format_1[OAM_ZERO], OAM_THREE);
	}
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.DeltaFPUCCHFormat1b", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,delta_f_pucch_format_1b[OAM_ZERO], OAM_THREE);
	}
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.DeltaFPUCCHFormat2", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,delta_f_pucch_format_2[OAM_ZERO], OAM_FOUR);
	}
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.DeltaFPUCCHFormat2a", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,delta_f_pucch_format_2a[OAM_ZERO], OAM_THREE);
	}
	else if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.ULPowerControl.DeltaFPUCCHFormat2b", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,delta_f_pucch_format_2b[OAM_ZERO], OAM_THREE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PRS.NumConsecutivePRSSubframes", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_PHY_PRS_NumConsecutivePRSSubfames[OAM_ZERO],OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.NumberOfRaPreambles", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value, RAN_MAC_RACH_NumberOfRaPreambles[OAM_ZERO], OAM_SIXTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.SizeOfRaGroupA", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_sizeOfRaGroupA[OAM_ZERO] , OAM_FIFTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.MessageSizeGroupA", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_messageSizeGroupA[OAM_ZERO] ,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.MessagePowerOffsetGroupB", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_messagePowerOffsetGroupB[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.PowerRampingStep", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_powerRampingStep[OAM_ZERO] ,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.PreambleInitialReceivedTargetPower", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_preambleInitialReceivedTargetPower[OAM_ZERO] , OAM_SIXTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.preambleTransMax", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_preambleTransMax[OAM_ZERO] ,OAM_ELEVEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.preambleTransMax", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_preambleTransMax[OAM_ZERO] ,OAM_ELEVEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.ResponseWindowSize", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_ResponseWindowSize[OAM_ZERO] ,OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.RACH.ContentionResolutionTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_RACH_ContentionResolutionTimer[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.OnDurationTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_OnDurationTimer[OAM_ZERO] , OAM_SEVENTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.DRXInactivityTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO] , OAM_TWENTY_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.DRXRetransmissionTimer", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO] , OAM_NINE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.LongDRXCycle", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_longDRXCycle[OAM_ZERO] , OAM_SEVENTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.MAC.DRX.ShortDRXCycle", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_shortDRXCycle[OAM_ZERO] , OAM_SEVENTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.TPollRetransmit", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO] , OAM_FIFTY_FIVE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.PollPDU", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_pollPDU[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.PollByte", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_pollByte[OAM_ZERO] , OAM_FIFTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.MaxRetxThreshold", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_MaxRetxThreshold[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.TReordering", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TReordering[OAM_ZERO] ,OAM_THIRTY_ONE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB1.TStatusProhibit", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO] ,OAM_FIFTY_SIX);
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.TPollRetransmit", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO] , OAM_FIFTY_FIVE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.PollPDU", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_pollPDU[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.PollByte", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_pollByte[OAM_ZERO] , OAM_FIFTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.MaxRetxThreshold", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_MaxRetxThreshold[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.TReordering", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TReordering[OAM_ZERO] ,OAM_THIRTY_ONE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RLC.SRB2.TStatusProhibit", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO] ,OAM_FIFTY_SIX);
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.MeasQuantityCDMA2000", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		par_table_address = &RAN_Mobility_ConnMode_IRAT_MeasQuantityCDMA2000[OAM_ZERO];
		oam_search_string_to_integer_for_get(parmeter_value,par_table_address, OAM_TWO);
	}
#ifdef OAM_SON_ENABLE
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.InterFreq."
				"Carrier.QOffsetFreq")) {
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				carrier_qoffset_freq_tbl[OAM_ZERO],
				INTERFREQ_CARRIER_QOFFSETFREQ_COUNT);
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.InterFreq."
				"Carrier.X_VENDOR_CM_OFFSET_FREQ")) {
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				carrier_qoffset_freq_tbl[OAM_ZERO],
				INTERFREQ_CARRIER_QOFFSETFREQ_COUNT);
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.InterFreq."
				"Carrier.TReselectionEUTRASFMedium")) {
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO],
				OAM_FOUR);
	}
	else if(oam_strstr(parmeter_name, "LTE.RAN.Mobility.IdleMode.InterFreq."
				"Carrier.TReselectionEUTRASFHigh")) { 
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO],
				OAM_FOUR);
	}
	else if(oam_strstr(parmeter_name,
				"Mobility.IdleMode.IRAT.UTRA.TReselectionUTRASFMedium"))
	{
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO],
				OAM_FOUR);
	}
	else if(oam_strstr(parmeter_name,
				"Mobility.IdleMode.IRAT.UTRA.TReselectionUTRASFHigh"))
	{
		retStatus = oam_search_integer_to_interger_for_get(parmeter_value,
				RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO],
				OAM_FOUR);
	}
#endif
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.TReselectionEUTRASFMedium", parmeter_name, oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.TReselectionEUTRASFMedium")) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFMedium[OAM_ZERO] ,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.TReselectionEUTRASFHigh", parmeter_name, oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IntraFreq.TReselectionEUTRASFHigh")) == OAM_ZERO)
	{ 
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_IdleMode_IntraFreq_TReselectionEUTRASFHigh[OAM_ZERO] ,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T300", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_T300[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T301", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_T301[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T302", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_T302[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T304EUTRA", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_T304EUTRA[OAM_ZERO] , OAM_SEVEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T304IRAT", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_T304IRAT[OAM_ZERO] , OAM_SEVEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T310", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_T310[OAM_ZERO] , OAM_SEVEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T311", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_T311[OAM_ZERO] , OAM_SEVEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.T320", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_T320[OAM_ZERO] , OAM_SEVEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.N310", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_N310[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RRCTimers.N311", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_RRCTimers_N311[OAM_ZERO] , OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.PacketDelayBudget", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,EPC_QoS_PacketDelayBudget[OAM_ZERO] , OAM_FOURTEEN);
	}
/*SPR 15527 START*/
    else if (oam_strncasecmp(
                "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC."
                "QoS.X_VENDOR_PACKETERRORLOSSRATE",
                parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,packetErrorLossRate[OAM_ZERO] ,PCKT_ERR_LOSS_RATE_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DDL_PARAM_T_STATUES_PROHIBIT", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TStatusProhibit[OAM_ZERO] , TSTATUSPROHIBIT_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DDL_PARAM_T_POLL_PDU", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_pollPDU[OAM_ZERO] , POLLPDU_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DDL_PARAM_T_POLL_RETRANSMIT", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TPollRetransmit[OAM_ZERO] , TPOLLRETRANSMIT_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DL_PARAM_T_REORDERING_AM", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TReordering[OAM_ZERO] , TREORDERING_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DL_PARAM_T_REORDERING_UM", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_TReordering[OAM_ZERO] , TREORDERING_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_UL_AM_POLL_BYTE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_RLC_SRB1_pollByte[OAM_ZERO] , POLLBYTE_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_MAX_RETX_THRESHOLD", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,EPC_MAX_RETX_THRESHOLD[OAM_ZERO] , OAM_EIGHT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DRX_ON_DURATION_TIMER", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_OnDurationTimer[OAM_ZERO] , ONDURATIONTIMER_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DRX_INACTIVITY_TIMER", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_drxInactivityTimer[OAM_ZERO] , DRXINACTIVITYTIMER_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_DRX_RETRANSMISSION_TIMER", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_drxRetransmissionTimer[OAM_ZERO] , DRXRETRANSMISSIONTIMER_COUNT);
    }
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_LONG_DRX_CYCLE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_longDRXCycle[OAM_ZERO] , LONGDRXCYCLE_COUNT);
    }
#ifdef ENDC_ENABLED
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_LONG_DRX_CYCLE_R15", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_longDRXCycleR15[OAM_ZERO] , LONGDRXCYCLE_COUNT_R15);
    }
#endif
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_SHORT_DRX_CYCLE", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger_for_get(parmeter_value,RAN_MAC_DRX_shortDRXCycle[OAM_ZERO] , DRXSHORTCYCLE_COUNT);
    }
/*SPR 15527 END*/
    /* SPR 20653 Fix Start */
    else if (oam_strncasecmp(
                "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_BUCKET_SIZE_DURATION",
                parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,Qos_BucketSizeDuration[OAM_ZERO] ,BUCKET_SIZE_DURATION_COUNT);
    }
    else if (oam_strncasecmp(
                "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS.X_VENDOR_PRIORITIZED_BIT_RATE",
                parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
    {
        oam_search_integer_to_interger(parmeter_value,Qos_PrioritizedBitRate[OAM_ZERO] ,PRIORITIZED_BIT_RATE_COUNT);
    }
    /* SPR 20653 Fix End */

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PRS.NumConsecutivePRSSubframes", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_PHY_PRS_NumConsecutivePRSSubfames[OAM_ZERO] ,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.Qhyst", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_IdleMode_Common_QHyst[OAM_ZERO] , OAM_SIXTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.QHystSFMedium", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_IdleMode_Common_QHystSFMedium[OAM_ZERO] ,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.QHystSFHigh", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_IdleMode_Common_QHystSFHigh[OAM_ZERO] ,OAM_FOUR);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.TEvaluation", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_IdleMode_Common_TEvaluation[OAM_ZERO] ,OAM_FIVE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.Common.THystNormal", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_IdleMode_Common_THystNormal[OAM_ZERO] ,OAM_FIVE);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.PDSCH.Pa", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_PHY_PDSCH_PA[OAM_ZERO] , OAM_EIGHT);
	}

	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.FilterCoefficientRSRP", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_ZERO] , OAM_FIFTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.FilterCoefficientRSRQ", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_EUTRA_FilterCoefficientRSRQ[OAM_ZERO] , OAM_FIFTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.TimeToTrigger", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_EUTRA_TimeToTrigger[OAM_ZERO], OAM_SIXTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportInterval", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_EUTRA_ReportInterval[OAM_ZERO], OAM_THIRTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.EUTRA.ReportAmount", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_EUTRA_ReportAmount[OAM_ZERO], OAM_EIGHT);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.FilterCoefficientUTRA", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_IRAT_FilterCoefficientUTRA[OAM_ZERO], OAM_FIFTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.FilterCoefficientGERAN", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_IRAT_FilterCoefficientGERAN[OAM_ZERO], OAM_FIFTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.TimeToTrigger", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_IRAT_TimeToTrigger[OAM_ZERO], OAM_SIXTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.ReportInterval", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_IRAT_ReportInterval[OAM_ZERO], OAM_THIRTEEN);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.ConnMode.IRAT.ReportAmount", parmeter_name, oam_strlen(parmeter_name)) == OAM_ZERO)
	{
		oam_search_integer_to_interger_for_get(parmeter_value,RAN_Mobility_ConnMode_IRAT_ReportAmount[OAM_ZERO], OAM_EIGHT);
	}
	/* SPR_6719 */
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.GERAN.TReselectionGERANSF", parmeter_name, oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.GERAN.TReselectionGERANSF")) == OAM_ZERO)
	{
		/* CSR 00070293 FIX START */
		oam_search_integer_to_interger_for_get(parmeter_value,RRM_CELL_TRESELECTIONSF[OAM_ZERO],TRESELECTIONSF_COUNT);
		/* CSR 00070293 FIX END */
	}
#ifdef OAM_SON_ENABLE
	else if (oam_strstr(parmeter_name, "GERANFreqGroup.BandIndicator")) {
		par_table_address = &SON_GSM_BANDINDICATOR[OAM_ZERO];

		retStatus = oam_search_string_to_integer_for_get(parmeter_value,
				par_table_address,
				OAM_SON_GSM_BANDINDICATOR_TBL_NUM_ROWS);
	}
	/* SPR-13586 START */
	else if (oam_strstr(parmeter_name, "GSM.BandIndicator")) {
		par_table_address = &SON_GSM_BANDINDICATOR[OAM_ZERO];

		retStatus = oam_search_string_to_integer_for_get(parmeter_value,
				par_table_address,
				OAM_SON_GSM_BANDINDICATOR_TBL_NUM_ROWS);
	}
	/* SPR-13586 END */
#endif
	/* SPR_6719 */
            /* SPR 14295 FIX START */
            else if (!oam_strcmp("InternetGatewayDevice.Services.FAPService."
                        "CellConfig.X_VENDOR_CARRIER_AGGREGATION_PARAMS."
                        "ScellDeactTimer", parmeter_name)) {
                par_table_address = &scell_deact_timer_map[OAM_ZERO];
                oam_search_string_to_integer_for_get(parmeter_value,
                        par_table_address,
                        OAM_SCELL_DEACT_TIMER_MAP_MAX_LEN);
            }
            /* SPR 14295 FIX END */
	else if (oam_strstr(parmeter_name,
				"X_VENDOR_MEAS_BANDWIDTH_FOR_EARFCN")) {
		par_table_address = &MeasBandwidth[OAM_ZERO];

		retStatus = oam_search_string_to_integer_for_get(parmeter_value,
				par_table_address,
				RRM_OAM_BW_MEAS_COUNT);
	}
	/* SPR 16407 START */
	else if (OAM_ZERO == (oam_strncasecmp(
					"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN."
    /* spr_21013_fix_end */
					"CellRestriction.CellBarred",parmeter_name, oam_strlen(parmeter_name))))
	{
		oam_search_integer_to_interger(parmeter_value,CELL_BARRED[OAM_ZERO], OAM_GET_SIZEOF_ARRAY(CELL_BARRED[OAM_ZERO]));
	}
	/* SPR 16407 END */
    /* OAM BCOM Code Comment Changes Start */
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Invalid Parameter.");
    }
	/* OAM BCOM Code Comment Changes End*/

	return retStatus;
}
/******************************************************************************
 * Function Name: oam_check_exception_message
 * Description  : This function match from the enum and return the correspondence value
 * Inputs       :  param_name: param Name
 * Outputs      :  NONE 
 * Returns      : OAM_SUCCESS/OAM_FAILURE
 ********************************************************************************/
	oam_return_et
oam_check_exception_message(Char8 *param_name)
{
    /* spr_21013_fix_start */
	oam_return_et ret = OAM_SUCCESS;
	if (oam_strstr(param_name,"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].BCCH.DLBandwidth"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].RF.PhyCellID"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.Enable"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.IsPrimary"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.PLMNID"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.CellReservedForOperatorUse"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.FAP.Tunnel.IKESA.[1].PeerAddress"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.FAP.Tunnel.VirtualInterface.[1].CryptoProfile"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.DLBandwidth"))
	{
		ret = OAM_FAILURE; 
	}
	if (oam_strstr(param_name,"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF.PhyCellID"))
    /* spr_21013_fix_end */
	{
		ret = OAM_FAILURE; 
	}
	return ret;
}
/****************************************************************************
 * Function Name: oam_calc_param_addr
 * Description  : This function calculates the actual value of the pointer to
 *                the value of an unindexed parameter.
 * Inputs       : table index of the paramter.
 * Outputs      : NONE
 * Returns      : a void pointer pointing to the calculated address.
 ****************************************************************************/
/* SPR 18930  FIX START */
void* oam_calc_param_addr(UInt16 tab_idx, UInt8 curr_cell_id)
{
/* SPR 18930  FIX END */
	void *p_cell_spec_base_addr =
		g_parameter_map_element[tab_idx].cell_spec_base_addr;
	SInt8 cell_arr_idx = OAM_ZERO;
	SInt32 offset = OAM_ZERO;
	void* param_addr = OAM_NULL;
/* SPR 18930  FIX END */

	if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			RRM_OAM_CELL_CONFIG_REQ_MASK) {
		cell_arr_idx =
			oam_get_rrm_cell_config_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr = (oam_rrm_cell_config_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
	/* SPR 11001 FIX START */

    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    else if ((g_parameter_map_element[tab_idx].
                lower_layer_bitmask & M2AP_OAM_PROVISION_REQ_MASK) &&
            g_parameter_map_element[tab_idx].
            parameter_mode & OAM_IS_CELL_SPEC_PARAM)
    {
        cell_arr_idx = oam_get_m2ap_cell_config_idx(curr_cell_id);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
            OAM_LOG(OAM, OAM_ERROR, "Invalid cell context");
            return OAM_NULL;
        }

        p_cell_spec_base_addr = (m2ap_cell_specific_parameters_t*)
            g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
    }
    /* EMBMS Changes End */
#endif

	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			RRM_OAM_LOAD_CONFIG_REQ_MASK) {
		if (!oam_strstr(g_parameter_map_element[tab_idx].parameter_name,
					"serving_cell") &&
				!oam_strstr(g_parameter_map_element[tab_idx].parameter_name,
					"neighbor_cell"))
		{
			cell_arr_idx = oam_get_rrm_cell_config_idx(curr_cell_id);

			if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
				return OAM_NULL;
			}

			p_cell_spec_base_addr = (rrm_oam_serving_enb_cell_info_t*)
				g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
		}
	}
	/* SPR 11001 FIX END */
#ifdef OAM_SON_ENABLE
	else if((g_parameter_map_element[tab_idx].lower_layer_bitmask &
				SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK) ||
			(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			 SON_OAM_NR_ADD_UPDATE_DELETE_REQ_MASK_INTER)) {
		cell_arr_idx = oam_get_son_cell_nr_list_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr = (oam_cell_neighbourlist_info_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_ANR_MEAS_CONFIG_MASK) {
		cell_arr_idx = oam_get_son_inter_freq_carrier_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr = (oam_son_inter_freq_carrier_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_MRO_MODIFY_CONFIG_PARAM_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr = (oam_son_mro_modify_config_params_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_MLB_MODIFY_ATTRIBUTE_REQ_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr = (son_oam_mlb_modify_attributes_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
	/*bug_13878_start*/
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}
		p_cell_spec_base_addr = (oam_son_anr_neighbor_default_config_req_t *)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
	/*bug_13878_end*/
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_ANR_MODIFY_UE_COUNT_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr = (oam_son_anr_modify_ue_count_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_ANR_MODIFY_REMOVAL_ATTRIBUTES_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr =
			(oam_son_anr_modify_removal_attributes_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}  
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_ANR_MODIFY_PCI_CONFUSION_CFG_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr =
			(oam_son_anr_modify_pci_confusion_cfg_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
    /* SPR 20653 Fix Start */
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_ANR_MODIFY_ATTRIBUTE_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr =
			(oam_son_anr_modify_attribute_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
    /* SPR 20653 Fix End */
	/* BUG_FIXED_11744_START */
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_SON_RACH_OPT_CONFIG_PARAMS_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}
		/* BUG_FIXED_11744_END */   

		p_cell_spec_base_addr =
			(oam_son_rach_opt_modify_config_params_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;

	}
	/* SPR 13024 FIX START */
	else if (g_parameter_map_element[tab_idx].lower_layer_bitmask &
			OAM_PHY_CELL_ID_MASK) {
		cell_arr_idx = oam_get_earfcn_pci_select_arr_idx(curr_cell_id);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context: %d", curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr =
			(oam_son_earfcn_pci_selection_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;
	}
	/* SPR 22453 Fix Start */
	else if(g_parameter_map_element[tab_idx].lower_layer_bitmask &
		     OAM_SON_ANR_ENABLE_MASK) {
		cell_arr_idx = oam_get_son_serving_cell_idx(curr_cell_id);

		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         curr_cell_id);
			return OAM_NULL;
		}

		p_cell_spec_base_addr =
			(oam_son_anr_enable_req_t*)
			g_parameter_map_element[tab_idx].cell_spec_base_addr + cell_arr_idx;

	}
	/* SPR 22453 Fix End */
	/* SPR 13024 FIX END */
#endif

	offset = (UInt8*)g_parameter_map_element[tab_idx].param_base_addr
		- (UInt8*)g_parameter_map_element[tab_idx].cell_spec_base_addr;

	param_addr = (UInt8*)p_cell_spec_base_addr + offset;

	return param_addr;
}

/****************************************************************************
 * Function Name: oam_find_multi_inst_param_addr
 * Description  : This function calculates the actual value of the pointer to
 *                the value of an indexed parameter.
 * Inputs       : 1. Parameter name
 *              : 2. API request type
 *              : 3. Index VALUE in the base array.
 *                4. pointer to parameter table.
 *                5. table index of the paramter.
 * Outputs      : NONE
 * Returns      : a void pointer pointing to the calculated address.
 ****************************************************************************/
void* oam_find_multi_inst_param_addr(Char8 *param_name,
		UInt16 api_type,
		UInt8 base_arr_index,
		parameter_map_element_t *param_tab,
		UInt16 tab_idx)
{
	SInt32 offset = OAM_ZERO;
	void* param_addr = OAM_NULL;
	void* multi_obj_base_addr = OAM_NULL;
	UInt8 invalid_index = OAM_ZERO;
	void* p_cell_spec_base_addr = OAM_NULL;
	oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
	/* SPR 11878 FIX START */
	oam_rrm_cell_plmnlist_data_t *p_local_cell_plmnlist_data = OAM_NULL;
	/* SPR 11878 FIX END */
	OAM_FUN_ENTRY_TRACE();

	SInt8 cell_arr_idx = OAM_ERROR_RETURN_VAL;

#ifdef OAM_SON_ENABLE
	oam_son_nr_add_req_t *p_local_son_nr_add = OAM_NULL;
	oam_cell_neighbourlist_info_t *p_local_cell_neigh_info = OAM_NULL;
	oam_cell_neighbourlist_info_t *p_cell_neigh_info = OAM_NULL;
	/* Cov CID 63598 Fix */
	oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params = OAM_NULL;

	oam_son_inter_freq_carrier_t *p_local_son_inter_freq_carr_params = OAM_NULL;
	/* Cov CID 63598 Fix */

#endif


#ifdef OAM_SON_ENABLE
    /* SPR 21370 changes start */
    /* SPR 21421 changes start */
	if(oam_strstr(param_name, "InternetGatewayDevice.Services.FAPService"
				".CellConfig.LTE.RAN.NeighborList.LTECell")) 
    /* SPR 21421 changes end */
    /* SPR 21370 changes end */
	{
		cell_arr_idx = oam_get_son_cell_nr_list_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}

		p_local_cell_neigh_info = &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx);
		p_local_son_nr_add = &p_local_cell_neigh_info->oam_son_nr_add_req;
		p_cell_neigh_info = &SON_NEIGHBORLIST_INFO(cell_arr_idx);

		if(!(p_cell_neigh_info->intra_rat_nr_entry_bitmap &
					(1 << base_arr_index))) {
			invalid_index = 1;
		}
    /* Spr 15438 Fix Start */
        if((strstr(param_name, "Enable"))||(strstr(param_name, "MustInclude"))) {
            multi_obj_base_addr =
                /* SPR 18930  FIX START */
                &(p_local_cell_neigh_info->eutran_nbr_ctxt[OAM_ZERO]);
            /* SPR 18930  FIX END */
            param_addr = (oam_son_nbr_ctxt_t*)multi_obj_base_addr +
                base_arr_index;
            p_local_cell_neigh_info->nr_list_query_idx = base_arr_index;
        }
        else
        {
            /* Spr 15438 Fix End */
		multi_obj_base_addr =
			&(p_local_son_nr_add->nr_list.intra_rat_nr_list[OAM_ZERO]);
		param_addr = (son_intra_rat_neighbor_info_t*)multi_obj_base_addr
			+ base_arr_index;
		p_local_cell_neigh_info->nr_list_query_idx = base_arr_index;
            /* Spr 15438 Fix Start */

/* SPR 18930  FIX START */
        OAM_LOG(OAM,OAM_DETAILED,"finding query idx =%d",p_local_cell_neigh_info->nr_list_query_idx);
            /* SPR 18930  FIX END */

        }
    /* Spr 15438 Fix End */

	}
	/* SPR-13586 START */
	else if(oam_strstr(param_name, "InternetGatewayDevice.Services."
                /* spr_21013_fix_start */
				"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell")) 
                /* spr_21013_fix_end */
		/* SPR-13586 END */
	{
		cell_arr_idx = oam_get_son_cell_nr_list_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}

		p_local_son_nr_add = &LOCAL_SON_NR_ADD_REQ(cell_arr_idx);
		p_cell_neigh_info = &SON_NEIGHBORLIST_INFO(cell_arr_idx);
		p_local_cell_neigh_info = &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx);

		/* SPR-13586 START */ 
		if(oam_strstr(param_name, "NeighborList.InterRATCell.UMTS")) {
			if(!(p_cell_neigh_info->inter_rat_umts_entry_bitmap &
						/* SPR-13586 END */
						(1 << base_arr_index))) {
				invalid_index = 1;
			}
/* Spr 15612  Fix Start*/
        if((strstr(param_name, "Enable"))||(strstr(param_name, "MustInclude"))) {
            multi_obj_base_addr =
/* SPR 18930  FIX START */
                &(p_local_cell_neigh_info->utran_nbr_ctxt[OAM_ZERO]);
            /* SPR 18930  FIX END */
            param_addr = (oam_son_nbr_ctxt_t*)multi_obj_base_addr +
                base_arr_index;
            p_local_cell_neigh_info->nr_list_query_idx = base_arr_index;
        }
        else
        {
/* Spr 15612  Fix End*/


			multi_obj_base_addr =
				&(p_local_son_nr_add->nr_list.inter_rat_nr_list[OAM_ZERO]);
			param_addr = (son_inter_rat_neighbor_info_t*)multi_obj_base_addr
				+ base_arr_index;
			p_local_cell_neigh_info->nr_list_query_idx = base_arr_index;
			p_local_son_nr_add->nr_list.inter_rat_nr_list[base_arr_index].bitmask |=
				SON_INTER_UTRAN_NEIGHBOR;
			p_local_son_nr_add->nr_list.inter_rat_nr_list[base_arr_index].utran_neighbor.
				nbr_cgi.rat_type = SON_UTRAN_CELL;
/* Spr 15612  Fix Start*/
        }
/* Spr 15612  Fix End*/
		}
		/* SPR-13586 START */ 
		if(oam_strstr(param_name, "NeighborList.InterRATCell.GSM")) {
			if(!(p_cell_neigh_info->inter_rat_gsm_entry_bitmap &
						(1 << base_arr_index))) {
				invalid_index = 1;
			}

			multi_obj_base_addr =
				&(p_local_son_nr_add->nr_list.inter_rat_nr_list[OAM_ZERO]);
			param_addr = (son_inter_rat_neighbor_info_t*)multi_obj_base_addr
				+ base_arr_index;
			p_local_cell_neigh_info->nr_list_query_idx = base_arr_index;
			p_local_son_nr_add->nr_list.inter_rat_nr_list[base_arr_index].bitmask |=
				SON_INTER_GERAN_NEIGHBOR;
			p_local_son_nr_add->nr_list.inter_rat_nr_list[base_arr_index].geran_neighbor.
				nbr_cgi.rat_type = SON_GERAN_CELL;
		}
	}
	/* SPR-13586 END */
	else if(oam_strstr(param_name, "InternetGatewayDevice.Services."
                /* spr_21013_fix_start */
				"FAPService.CellConfig.LTE.RAN.NeighborListInUse.LTECell")) {
                /* spr_21013_fix_end */

		cell_arr_idx = oam_get_son_neigh_list_in_use_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}

		if(!(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].intra_rat_neigh_valid_bitmap &
					(1 << base_arr_index))) {
			invalid_index = 1;
		}
        /* SPR 21903 FIXED START */
        /*SPR 21672 FIXED START */
		multi_obj_base_addr = 
			&(NRT_INFO(cell_arr_idx).nr_list.
					intra_rat_nr_list[OAM_ZERO]);
        /*SPR 21672 FIXED END */   
        /* SPR 21903 FIXED END */
		param_addr = (son_intra_rat_neighbor_info_t*)multi_obj_base_addr +
			base_arr_index;
		LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
			nr_list_query_idx = base_arr_index;
	}
	else if(oam_strstr(param_name,
                /* spr_21013_fix_start */
				"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
				"RAN.NeighborListInUse.InterRATCell.UMTS")) {
		cell_arr_idx = oam_get_son_neigh_list_in_use_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}
		/* SPR-13586 START */
		if(!(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_umts_neigh_valid_bitmap &
					(1 << base_arr_index))) {
			/* SPR-13586 END */
			invalid_index = 1;
		}
        /* SPR 21903 FIXED START */
        /* SPR 21672 FIXED START */
		multi_obj_base_addr = 
			&(NRT_INFO(cell_arr_idx).nr_list.
					inter_rat_nr_list[OAM_ZERO]);
        /* SPR 21672 FIXED END */  
        /* SPR 21903 FIXED END */
		param_addr = (son_inter_rat_neighbor_info_t*)multi_obj_base_addr +
			base_arr_index;
		LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
			nr_list_query_idx = base_arr_index;
	}
	/* SPR-13586 START */
	else if(oam_strstr(param_name,
				"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
				"RAN.NeighborListInUse.InterRATCell.GSM")) {
		cell_arr_idx = oam_get_son_neigh_list_in_use_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}
		/* SPR-13586 START */
		if(!(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_gsm_neigh_valid_bitmap &
					(1 << base_arr_index))) {
			/* SPR-13586 END */
			invalid_index = 1;
		}
		multi_obj_base_addr = 
			&(LOCAL_NRT_INFO(cell_arr_idx).nr_list.
					inter_rat_nr_list[OAM_ZERO]);
		param_addr = (son_inter_rat_neighbor_info_t*)multi_obj_base_addr +
			base_arr_index;
		LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
			nr_list_query_idx = base_arr_index;
	}
	/* SPR-13586 START */
	else if(oam_strstr(param_name,
				"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
				"RAN.Mobility.IdleMode.InterFreq.Carrier")) {
		cell_arr_idx = oam_get_son_inter_freq_carrier_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}

		p_son_inter_freq_carr_params =
			&SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

		p_local_son_inter_freq_carr_params = 
			&LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

		if (!(p_son_inter_freq_carr_params->
					eutran_meas_entry_bitmap & (1 << base_arr_index))) {
			invalid_index = 1;
		}

        /* SPR 14651 START */
        if(strstr(param_name, "Enable")){
            multi_obj_base_addr =
                &(p_local_son_inter_freq_carr_params->
                        eutran_meas_enable[OAM_ZERO]);
            param_addr = (oam_son_meas_obj_enable_t *)multi_obj_base_addr +
                base_arr_index;

		   LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
			                 nr_list_query_idx = base_arr_index;
        }
        else
        {
        /* SPR 14651 END */
            multi_obj_base_addr =
                &(p_local_son_inter_freq_carr_params->oam_son_anr_meas_config_req.
                        eutran_config_list[OAM_ZERO]);
            param_addr = (son_meas_config_eutran_t*)multi_obj_base_addr +
                base_arr_index;

            p_local_son_inter_freq_carr_params->query_index = base_arr_index;
        /* SPR 14651 START */
        }

        p_local_son_inter_freq_carr_params->
           eutran_meas_enable[base_arr_index].bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
        /* SPR 14651 END */
	}
	else if(oam_strstr(param_name,
				"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
				"RAN.Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq")) {
		cell_arr_idx = oam_get_son_inter_freq_carrier_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}

		p_son_inter_freq_carr_params =
			&SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

		p_local_son_inter_freq_carr_params = 
			&LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

		OAM_LOG(OAM, OAM_DETAILED, "SON table for UTRA.UTRANFDDFreq selected");
		if(!(p_son_inter_freq_carr_params->
					utran_fdd_meas_entry_bitmap & (1 << base_arr_index))) {
			invalid_index = 1;
		}

        /* SPR 14651 START */
        if(strstr(param_name, "Enable")){
            multi_obj_base_addr =
                &(p_local_son_inter_freq_carr_params->
                        utran_meas_enable[OAM_ZERO]);
            param_addr = (oam_son_nbr_ctxt_t*)multi_obj_base_addr +
                base_arr_index;

            p_local_son_inter_freq_carr_params->query_index
                = base_arr_index;
        }
        else {
        /* SPR 14651 END */
		multi_obj_base_addr =
			&(p_local_son_inter_freq_carr_params->oam_son_anr_meas_config_req.
					other_rat_config_list.utran_config_list.utran_fdd_list[OAM_ZERO]);

		param_addr = (son_meas_config_utran_fdd_t*)multi_obj_base_addr +
			base_arr_index;

		p_local_son_inter_freq_carr_params->query_index = base_arr_index;
        /* SPR 14651 START */
        }
        p_local_son_inter_freq_carr_params->
           utran_meas_enable[base_arr_index].bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
        /* SPR 14651 END */
	}
	/* RT SPR 9019 FIX START */   /*SPR 13944 START*/
	else if(oam_strstr(param_name,
				"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
				"RAN.Mobility.IdleMode.IRAT.UTRA."
				"IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS")) {
		OAM_LOG(OAM, OAM_DETAILED,
            "SON table for UTRA.IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS selected"); /*SPR 13944 END*/

		cell_arr_idx = oam_get_son_inter_freq_carrier_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}

		p_son_inter_freq_carr_params =
			&SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

		p_local_son_inter_freq_carr_params = 
			&LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

		if(!(p_son_inter_freq_carr_params->
					utran_tdd_meas_entry_bitmap & (1 << base_arr_index))) {
			invalid_index = 1;
		}

		multi_obj_base_addr =
			&(p_local_son_inter_freq_carr_params->oam_son_anr_meas_config_req.
					other_rat_config_list.utran_config_list.utran_tdd_list[0]);

		param_addr = (son_meas_config_utran_tdd_t*)multi_obj_base_addr +
			base_arr_index;

		p_local_son_inter_freq_carr_params->query_index = base_arr_index;
	}
	/* RT SPR 9019 FIX END */
	else if((param_tab == g_parameter_son_nw_scan_results_rf)||(param_tab == g_parameter_son_nw_scan_results_bcch))
	{
		multi_obj_base_addr = 
			&(LOCAL_SON_PROV_REQ.oam_nw_scan_result.oam_cell_discover[OAM_ZERO]);
		param_addr = (oam_cell_discover_t *)multi_obj_base_addr +
			base_arr_index;
	}
	/* RT SPR 8154 FIX START */
	else if(oam_strstr(param_name,
				"InternetGatewayDevice.Services.FAPService.CellConfig.LTE."
				"RAN.Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup")) {
		cell_arr_idx = oam_get_son_inter_freq_carrier_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
			return OAM_NULL;
		}

		p_son_inter_freq_carr_params =
			&SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

		p_local_son_inter_freq_carr_params = 
			&LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

		if(!(p_son_inter_freq_carr_params->
					geran_meas_entry_bitmap & (1 << base_arr_index))) {
			invalid_index = 1;
		}

        /* SPR 14651 START */
        if(strstr(param_name, "Enable")){
            multi_obj_base_addr =
                &(p_local_son_inter_freq_carr_params->
                        geran_meas_enable[OAM_ZERO]);
            param_addr = (oam_son_nbr_ctxt_t*)multi_obj_base_addr +
                base_arr_index;

		    LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
			nr_list_query_idx = base_arr_index;
        }
        else {
        /* SPR 14651 END */
		multi_obj_base_addr =
			&(p_local_son_inter_freq_carr_params->oam_son_anr_meas_config_req.
					other_rat_config_list.geran_config_list.geran_freq_info_list[0]);

		param_addr = (son_geran_carrier_freq_info_t*)multi_obj_base_addr
			+ base_arr_index;

		p_local_son_inter_freq_carr_params->query_index = base_arr_index;
        /* SPR 14651 START */
        }
        p_local_son_inter_freq_carr_params->
           geran_meas_enable[base_arr_index].bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
        /* SPR 14651 END */
	}
	/* RT SPR 8154 FIX END */
	else 
#endif
		if(oam_strstr((Char8*)param_name,
					"InternetGatewayDevice.Services.FAPService."
                    /* spr_21013_fix_start */
					"CellConfig.LTE.EPC.PLMNList")) {
			cell_arr_idx = oam_get_cell_plmnlist_data_idx(
					oam_prov_req.cell_cntxt.curr_cell_cid);
			if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
				return OAM_FAILURE;
			}

			p_cell_plmnlist_data = &RRM_PROV_REQ.plmnlist_data[cell_arr_idx];
			/* SPR 11878 FIX START */
			p_local_cell_plmnlist_data = &local_prov_req.oam_rrm_req.plmnlist_data[cell_arr_idx];
			/* SPR 11878 FIX END */

			if(!(p_cell_plmnlist_data->is_valid_bitmap &
						(1 << base_arr_index))) {
				invalid_index = 1;
			}

            /*SPR 16554 Fix start*/
            if((base_arr_index > RRM_OAM_MAX_NUM_PLMNS) || ((base_arr_index + OAM_ONE) > RRM_PROV_REQ.plmnlist_data[cell_arr_idx].curr_plmn_entries )){
                invalid_index = 1;
                OAM_LOG(OAM, OAM_DETAILED, "In if condition - PLMN List val at index %p = ",  param_addr );
            }
            else{
                offset = (UInt8*)param_tab[tab_idx].multi_inst_param_base_addr
                    - (UInt8*)param_tab[tab_idx].cell_spec_base_addr;

                multi_obj_base_addr = (UInt8*)p_local_cell_plmnlist_data + offset;

                param_addr = (oam_rrm_plmn_data_t*)multi_obj_base_addr +
                    base_arr_index;

                p_local_cell_plmnlist_data->plmnlist_query_idx = base_arr_index;
                OAM_LOG(OAM, OAM_DETAILED, "In else - PLMN List val at index %p = ",  param_addr);
            }
            /*SPR 16554 Fix End*/
			offset = (UInt8*)param_tab[tab_idx].multi_inst_param_base_addr
				- (UInt8*)param_tab[tab_idx].cell_spec_base_addr;

			multi_obj_base_addr = (UInt8*)p_local_cell_plmnlist_data + offset;

			param_addr = (oam_rrm_plmn_data_t*)multi_obj_base_addr +
				base_arr_index;

			p_local_cell_plmnlist_data->plmnlist_query_idx = base_arr_index;
		}
		else if(param_tab[tab_idx].lower_layer_bitmask &
				RRM_OAM_CELL_CONFIG_REQ_MASK) {
			cell_arr_idx =
				oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

			if(OAM_ERROR_RETURN_VAL == cell_arr_idx) { /* Cov CID 63599 fix */
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
				return OAM_NULL;
			}

			p_cell_spec_base_addr =
				(oam_rrm_qos_data_t*)param_tab[tab_idx].cell_spec_base_addr
				+ cell_arr_idx;

			offset = (UInt8*)param_tab[tab_idx].multi_inst_param_base_addr
				- (UInt8*)param_tab[tab_idx].cell_spec_base_addr;

			multi_obj_base_addr = (UInt8*)p_cell_spec_base_addr + offset;

			if(oam_strstr((Char8*)param_name, "InternetGatewayDevice.Services."
                         /* spr_21013_fix_start */
						"FAPService.CellConfig.LTE.EPC.QoS")) {
                         /* spr_21013_fix_end */
				if(RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx].epc_info.
						epc_params.num_valid_qos_profiles <= base_arr_index) {
					invalid_index = 1;
				}

				param_addr = (oam_qos_config_params_t*)multi_obj_base_addr +
					base_arr_index;
			}
            /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
            else if (oam_strstr(param_name,
                        "InternetGatewayDevice.Services.FAPService.[1]."
                        "CellConfig.LTE.RAN.PHY.MBSFN.SFConfigList"))
            {
                cell_arr_idx =
                    oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

                if(OAM_ERROR_RETURN_VAL == cell_arr_idx) { /* Cov CID 63599 fix */
                    OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                            oam_prov_req.cell_cntxt.curr_cell_cid);
                    return OAM_NULL;
                }

                p_cell_spec_base_addr =
                    (oam_rrm_cell_config_req_t*)param_tab[tab_idx].cell_spec_base_addr
                    + cell_arr_idx;

                offset = (UInt8*)param_tab[tab_idx].multi_inst_param_base_addr
                    - (UInt8*)param_tab[tab_idx].cell_spec_base_addr;

                multi_obj_base_addr = (UInt8*)p_cell_spec_base_addr + offset;
                if (base_arr_index >= (RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                            physical_layer_params.
                            mbsfn_subframe_config_list.count)) {
                    invalid_index = 1;
                }
                else
                {
                    param_addr = (rrm_mbsfn_config_info_t*)multi_obj_base_addr +
                        base_arr_index;
                }
            }
#endif
            /* EMBMS Changes End */

		}
		else if((param_tab->lower_layer_bitmask & RRM_OAM_CELL_CONFIG_REQ_MASK ) && (oam_check_exception_message(param_name) == OAM_SUCCESS)) 
		{
			multi_obj_base_addr = &(oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO]);
			cell_arr_idx =
				oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

			if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
				return OAM_NULL;
			}

			base_arr_index = cell_arr_idx;
			param_addr = (oam_rrm_cell_config_req_t*)multi_obj_base_addr + base_arr_index;
		}
		else if(oam_strstr(param_name, "InternetGatewayDevice.FaultMgmt.SupportedAlarm")) 
		{
			if(base_arr_index >=
					oam_prov_req.fm_cntxt.SupportedAlarmNumberOfEntries) {
				invalid_index = 1;
			}
			multi_obj_base_addr = &(local_prov_req.fm_cntxt.supported_alarm_list[OAM_ZERO]);
			param_addr = (oam_supported_alarm_info_t*)multi_obj_base_addr + base_arr_index;
			local_prov_req.fm_cntxt.fm_query_idx = base_arr_index;
		}
		else if(oam_strstr((Char8*)param_name, "InternetGatewayDevice.FaultMgmt.HistoryEvent")) {
			if((!oam_prov_req.fm_cntxt.isHistoryRolled && base_arr_index >=
						oam_prov_req.fm_cntxt.History_List_Index) ||
					(base_arr_index >=
					 oam_prov_req.fm_cntxt.HistoryEventNumberOfEntries)) {
				invalid_index = 1;
			}
			multi_obj_base_addr = &(local_prov_req.fm_cntxt.history_alarm_list[OAM_ZERO]);
			param_addr = (oam_history_alarm_info_t*)multi_obj_base_addr + base_arr_index;
		}
		else if(oam_strstr((Char8*)param_name, "InternetGatewayDevice.FaultMgmt.CurrentAlarm")) {
			if(base_arr_index >=
					oam_prov_req.fm_cntxt.CurrentAlarmNumberOfEntries) {
				invalid_index = 1;
			}
			multi_obj_base_addr = &(local_prov_req.fm_cntxt.current_alarm_list[OAM_ZERO]);
			param_addr = (oam_current_alarm_info_t*)multi_obj_base_addr + base_arr_index;
		}
		else if(oam_strstr((Char8*)param_name, "InternetGatewayDevice.FaultMgmt.ExpeditedEvent")) {
			if((!oam_prov_req.fm_cntxt.isExpeditedRolled && base_arr_index >=
						oam_prov_req.fm_cntxt.Expedited_List_Index) ||
					(base_arr_index >=
					 oam_prov_req.fm_cntxt.ExpeditedEventNumberOfEntries)) {
				invalid_index = 1;
			}
			multi_obj_base_addr = &(local_prov_req.fm_cntxt.expedited_alarm_list[OAM_ZERO]);
			param_addr = (oam_expedited_alarm_info_t *)multi_obj_base_addr + base_arr_index;
		}
		else if(oam_strstr((Char8*)param_name, "InternetGatewayDevice.FaultMgmt.QueuedEvent")) {
			if((!oam_prov_req.fm_cntxt.isQueuedRolled && base_arr_index >=
						oam_prov_req.fm_cntxt.Queued_List_Index) ||
					(base_arr_index >=
					 oam_prov_req.fm_cntxt.QueuedEventNumberOfEntries)) {
				invalid_index = 1;
			}
			multi_obj_base_addr = &(local_prov_req.fm_cntxt.queued_alarm_list[OAM_ZERO]);
			param_addr = (oam_queued_alarm_info_t *)multi_obj_base_addr + base_arr_index;
		}
		else if(param_tab == g_parameter_tunnel_crypto_profile) {
			multi_obj_base_addr =
				&(local_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile);
			param_addr = (oam_crypto_profile_t*)multi_obj_base_addr +
				base_arr_index;
		}
        /* OAM BCOM Code Comment Changes Start */
        else if(param_tab == g_parameter_tunnel_ikesa) {
            multi_obj_base_addr = &(local_prov_req.oam_igd_params.tunnel_params.oam_ikesa);
            param_addr = (oam_ikesa_t*)multi_obj_base_addr +
              base_arr_index;
        }
        /* OAM BCOM Code Comment Changes End */
		else if(param_tab == g_parameter_tunnel_virtualInterface) {
			multi_obj_base_addr = &(local_prov_req.oam_igd_params.tunnel_params.virtual_interface_params);
			param_addr = (oam_tunnel_virtual_inter_t*)multi_obj_base_addr +
				base_arr_index;
		}
		else if(param_tab == g_parameter_lte_rem) {
			multi_obj_base_addr = &(local_prov_req.oam_igd_params.rem_lte_params);
			param_addr = (oam_tunnel_virtual_inter_t*)multi_obj_base_addr +
				base_arr_index;
		}
#ifdef OAM_SON_ENABLE
	/* SPR 13065 CHANGE START */    
	/* SPR 13065 CHANGE END */    
		else if(param_tab == g_parameter_son_pci_reselction) {
			multi_obj_base_addr = &(LOCAL_SON_PROV_REQ.earfcn_pci_selection[OAM_ZERO].oam_son_pci_reselection_req);
			param_addr = (oam_son_pci_reselection_req_t*)multi_obj_base_addr +
				base_arr_index;
		}
#endif
	/* Fix for multi-instance  */
	/* SPR 14357 FIX Start */
		else if(param_tab == g_parameter_lte_l3_Assoc_list)
		{
			/* Base index search for no of s1ap connections or x2ap connections*/
			multi_obj_base_addr = &(local_prov_req.oam_l3_req.sctp_params.sctp_assoc_params);
			param_addr = (oam_sctp_assoc_params_t*)multi_obj_base_addr +
				base_arr_index;

		}/* End of else if of SCTP table */
	/* SPR 14357 FIX End */

    /*SPR 16554 Fix start*/
    if(invalid_index && ((api_type == OAM_GET_PARAMETER_VALUES))) {
    /*SPR 16554 Fix End*/
		OAM_LOG(OAM, OAM_WARNING, "Requested instance number is not valid");
		param_addr = OAM_NULL;
	}
	else {
		offset = (UInt8*)param_tab[tab_idx].param_base_addr
			- (UInt8*)param_tab[tab_idx].multi_inst_param_base_addr;
		param_addr = (UInt8*)param_addr + offset;
	}

	OAM_FUN_EXIT_TRACE();
	return param_addr;
}

/****************************************************************************
 * Function Name: oam_normalize_indexed_param
 * Description  : This function accepts a fully qualified parameter  name  and
 *                normalizes the parameter name by removing  any  index  value
 *                present just before the actual parameter  name,  or  returns
 *                the parameter name unmodified if no index is found.
 *                Fully qualified parameter name could be any of the types:
 *                -- parent_name.actual_paramter_name
 *                -- parent_name.[index].actual_paramter_name
 * Inputs       : 1. pointer to indexed(or without indexed) parmeter name
 *
 * Outputs      : 1. pointer to a  Char8  pointer  to  stored  the  normalized
 *                parameter name. The user of this  function  is  required  to
 *                free  the  memory  allocated  to  normalized_param   by  the
 *                function.
 * Returns      : Index value found in the indexed parameter, OAM_ZERO otherwise.
 ****************************************************************************/
UInt8 oam_normalize_indexed_param(Char8 *indexed_param,
		Char8 **normalized_param)
{
	Char8 *pos1 = OAM_NULL;
	Char8 *pos2 = OAM_NULL;
	Char8 index_str[OAM_OBJ_INSTANCE_NUM_STR_MAX_SIZE] = {0};
	UInt16 pos2_len = {RRM_ZERO};
	UInt8 index = OAM_ZERO;
	OAM_FUN_ENTRY_TRACE();


	/* Fully qualified query parameter name could be of type:
	   parent.[index].parameter
	   But the parameter name in search table will always be of type:
	   parent.parameter
	   we need to make query parameter name to the same form as
	   table parameter name as follows:
	 */

	/* duplicate the query parameter name */
	*normalized_param = OAM_STRDUP(indexed_param);

	/* Search the last occurrence of the character '[',
	   we can extract the parent name just before this character */
	if (*normalized_param != OAM_NULL)
		pos1 = OAM_STRRCHR(*normalized_param, '[');

	if(pos1 != OAM_NULL) {
		/* The parameter could be of ...FAPService.[i]...[j].param, that is
		   multi-instance or of type ...FAPService.[i]...param, that is
		   normal parameter
		   Search the first occurrence of the character '[',
		   we can extract the parent name just before this character */
		pos2 = OAM_STRCHR(*normalized_param, '[');
		if(pos1 != pos2 && *(pos1 - OAM_ONE) == '.') {
			/* The parameter could be of multi-instance type */
			/* Search the last occurrence of the character '.',
			   we can extract the parameter name just after this character */
			pos2 = OAM_STRRCHR(*normalized_param, ']');
			/* pos2'll now point to the string just after the last character
			   ']'
			 */
			if (pos2 != OAM_NULL)
			{
				++pos2;

				/* overwrite the index characters in the fully-qualified query
				   parameter name with the parameter name, after this
				   "normalized_param" will have the string of the type:
				   parent.parameter
				 */
				pos2_len = oam_strlen(pos2 + OAM_ONE) + OAM_ONE;
				OAM_MEMMOVE(pos1, pos2 + OAM_ONE, pos2_len);    
			}

			/* Now extract the index of the instance of the parameter */
			pos1 = OAM_STRRCHR(indexed_param, '[');
			/* KLOCWORK warning fix start */
			oam_strncpy((char*)index_str, (const char *)pos1 + 1,
					sizeof(index_str));
			/* KLOCWORK warning fix end */
			index = oam_atoi(index_str);
		}
		else if (pos1 == pos2 && 
				((oam_strncasecmp(indexed_param, "InternetGatewayDevice.FaultMgmt", oam_strlen("InternetGatewayDevice.FaultMgmt")) 
				  == OAM_ZERO))) 
		{
			pos2= OAM_STRRCHR(*normalized_param, ']');
			if(pos2!=OAM_NULL)
			{
				++pos2;
				pos2_len = oam_strlen(pos2 + OAM_ONE) + OAM_ONE;
				OAM_MEMMOVE(pos1, pos2 + OAM_ONE, pos2_len);
			}
			pos1 = OAM_STRRCHR(indexed_param, '[');
			pos2 = OAM_STRRCHR(indexed_param, ']');
			oam_strncpy(index_str, pos1 + OAM_ONE,
					(pos2 - pos1 - OAM_ONE) / sizeof(Char8));
			index = oam_atoi(index_str);
		}

	}

	OAM_FUN_EXIT_TRACE();
	return index;
}

/* spr_21013_fix_start */
/*******************************************************************************
 * Function Name: oam_find_fap_index
 * Description  : This function store the FAPService index and remove the
 *                FAPService index from input string 
 * Inputs       : p_parent_name
 *                p_fap_index_value
 * Outputs      : NONE
 * Returns      : NONE 
 ********************************************************************************/
void oam_find_fap_index(Char8 *p_parent_name, UInt8 *p_fap_index_value)
{
    Char8 temp_string[MAX_PARAMETER_NAME_LENGTH_VALUE] = {OAM_ZERO};
    Char8 fap_index[OAM_MAX_CMD_LENGTH_NAME] = {OAM_ZERO};
    Char8 *temp1 = NULL;
    /* SPR 21232 FIXED START */
    Char8 temp_p[MAX_PARAMETER_NAME_LENGTH_VALUE] = {OAM_ZERO};
    Char8 *temp2 = NULL;
    UInt8 Parent_Lenght = OAM_ZERO;         
    oam_strcpy(temp_string,p_parent_name);

    temp1 = oam_strtok(temp_string,"[");
    /* SPR 21232 FIXED END */
    if(OAM_NULL != temp1)
    {
        oam_strcpy(temp_p,temp1);
        temp1 = oam_strtok(NULL,"]");   

        if(OAM_NULL != temp1)
        {
            oam_strcpy(fap_index,temp1);
            *p_fap_index_value = oam_atoi(fap_index);
        }
        else
        {
            OAM_LOG(OAM, OAM_INFO, "temp1 is NULL, not able to find ']' in parent name OR parameter is not multi instance %s",p_parent_name);
        }
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO, "temp1 is NULL, not able to find '[' in parent name OR parameter is not multi instance %s",p_parent_name);
    }

    temp2 = OAM_STRCHR(p_parent_name,']');
    if(OAM_NULL != temp2)
    {
        temp2++;
    /* SPR 21232 FIXED START */
        if('\0' == *temp2)
        {
           Parent_Lenght =  oam_strlen(temp_p); 
           temp_p[ Parent_Lenght-1 ] = '\0';
         
        oam_memcpy(p_parent_name, temp_p, oam_strlen(temp_p)+1);

       }
        else{    
        temp2++;
        oam_strcat(temp_string,temp2);
        oam_memcpy(p_parent_name, temp_string, oam_strlen(temp_string)+1);
    }
    /* SPR 21232 FIXED END */
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO, "temp2 is NULL, not able to find ']' in parent name OR parameter is not multi instance %s",p_parent_name);
    }
}
/* spr_21013_fix_end */
#ifndef LTE_EMBMS_SUPPORTED
#define ONE_FRAME_ALLOC                                                    0
#define FOUR_FRAME_ALLOC                                                   1
#endif
/****************************************************************************
 * Function Name: oam_update_set_parameter
 * Description  : This function updates parameter with new value and vaidates 
 *                the same
 * Inputs       :  parmeter_name: parameter Name
 *                 parmeter_value: parameter value
 * Outputs      : p_p_orig_parent: current parent-child relationship of the 
 *                                 parameters requested by user representated
 *                                 in xmlNode
 *              : p_p_req_parent: parent-child relationship of the parameters
 *                                 of user request representated in xmlNode
 *              : p_p_p_xml_struct_addr: This is the pointer to the field
 *                parameter_parent in the parameter table in question
 * Returns      : OAM_SUCCESS/OAM_FAILURE
 ***************************************************************************/
	oam_return_et
oam_update_set_parameter(Char8 *parmeter_name,
		Char8 *parmeter_value,
        /* SPR 17509/17456 changes start */
		rrm_oam_cell_reconfig_req_t *p_local_req,
        /* SPR 17509/17456 changes end */
		xmlNode **p_p_orig_parent,
		xmlNode **p_p_req_parent,
		xmlNode ***p_p_p_xml_struct_addr,
        /* SPR 17777 fix code removed */
/* SPR 18930  FIX START */
		oam_error_code_et *p_error_code,
        UInt8 cell_config_idx)
/* SPR 18930  FIX END */
{
	OAM_FUN_ENTRY_TRACE();
	oam_counter_t loop=OAM_ZERO;
	UInt16 max_element = oam_find_global_table_size(g_parameter_map_element);
	Char8 *dup_param_name = OAM_NULL;
	UInt8 index = OAM_ONE;
	oam_return_et retVal = OAM_FAILURE;
	void* param_addr = OAM_NULL;
	void* voip_addr = OAM_NULL;
	UInt8 ps_ho_val = OAM_ZERO;
	UInt8 voip_val = OAM_ZERO;
	UInt32 max_tokens = 0;
	UInt8 *p_bitmap_arr = OAM_NULL;
    /* SPR 17880 18JAN FIX START */
	void* p_cell_spec_base_addr = OAM_NULL;
    /* SPR 17880 18JAN FIX END */
    /* SPR Fix 18741 Start */ 
    SInt8 cell_arr_idx = OAM_ZERO;
	SInt32 offset = OAM_ZERO;
     /* SPR Fix 18741 End */
#ifdef OAM_SON_ENABLE
	/* SPR 13024 FIX START */
/* SPR 18930  FIX START */
	UInt8 curr_cell_id = oam_prov_req.cell_cntxt.cell_ctxt_status[cell_config_idx].cid;
/* SPR 18930  FIX END */
	/* SPR 13024 FIX END */
	oam_rrm_cell_config_req_t *p_rrm_cell_config = OAM_NULL;  
	//UInt8 temp3[SON_ENB_ID_OCTET_SIZE] = {OAM_ZERO};
	 /* SPR Fix 18741 Start */
     //Code Deleted
      /* SPR Fix 18741 End */
	SInt8 cell_arr_idx1 = OAM_ZERO;
	son_utran_physical_cell_id_t *p_pci = OAM_NULL;
	UInt16 uarfcn = 0;
	oam_freq_type_et freq_found = OAM_FREQ_NOT_AVAILABLE;

	oam_son_nr_add_req_t *p_local_son_nr_add = OAM_NULL;

	oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;
	/* SPR 13024 FIX START */
	oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req = OAM_NULL;
	oam_son_pci_reselection_req_t *p_son_pci_reselect_params = OAM_NULL;
	/* SPR 13024 FIX END */
	/* SPR-13586 START */
	UInt8 *p_cellidentity = OAM_NULL;
	SInt32 value = OAM_ZERO;
	 /* SPR Fix 18741 Start */
     //Code Deleted
      /* SPR Fix 18741 End */
	son_geran_physical_cell_id_t *p_gsm_pci = OAM_NULL;
	/* SPR-13586 END */
#endif

	Char8 temp_plmnid[OAM_SEVEN] = {0};
	/* SPR 18930  FIX START */
	OAM_LOG(OAM, OAM_DETAILED, " cell_config_idx = %u, cid = %u",cell_config_idx,curr_cell_id);
	/* SPR 18930  FIX END */
    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    UInt8 sf_alloc_choice = OAM_ZERO;
    UInt8 DuplexMode[OAM_MAX_STR_LEN] = {OAM_ZERO};
    oam_m2ap_provision_req_t *p_m2ap_prov_req_params = OAM_NULL;
#endif
    /* EMBMS Changes End */

    /* spr_21013_fix_start */
    if ( (oam_strncasecmp((char *)parmeter_name, "InternetGatewayDevice.Services.FAPService.CellConfig", 
				           oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig")) == OAM_ZERO) )
    {
        oam_find_fap_index(parmeter_name, &index);
    }
    else
    {    
        index = oam_normalize_indexed_param(parmeter_name, &dup_param_name);

        /* oam_normalize_indexed_param can be return 0, that's why it should be reset with 1 */
        if(index == OAM_ZERO) 
        {
            index = OAM_ONE;
        }
        parmeter_name = dup_param_name;
    }
    /* spr_21013_fix_end */

	/*Loop through the parameter database */
	for(loop = OAM_ZERO; loop < max_element; ++loop)
	{
		/*Comparison between given parameter name and database stored names */
		if(!oam_strncmp(parmeter_name,
					(Char8*)g_parameter_map_element[loop].parameter_name, oam_strlen(parmeter_name))) {
			/* SPR 14158 FIX START */
			OAM_LOG(OAM, OAM_DETAILED, "Parameter found in table");

			if(g_parameter_map_element[loop].parameter_mode & OAM_WRITE_ONLY) {
				if(g_parameter_map_element[loop].parameter_mode &
						MULTI_INSTANCE_PARAM) {
					param_addr = oam_find_multi_inst_param_addr(parmeter_name,
							OAM_SET_PARAMETER_VALUES,
							index - OAM_ONE,
							g_parameter_map_element,
							loop);
                    /*SPR 16554 Fix start*/
                    if(param_addr == OAM_NULL){

                        OAM_LOG(OAM, OAM_DETAILED, "param_addr Parameter found in table %p",param_addr);
                        retVal = OAM_FAILURE;
                        break;
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "param_addr Parameter found in table %p",param_addr);
                    }
                    /*SPR 16554 Fix End*/
				}
                /* SPR 17880 18JAN FIX START */
	            else if ( (oam_strncasecmp((char *)parmeter_name, "InternetGatewayDevice.ManagementServer", 
				           oam_strlen("InternetGatewayDevice.ManagementServer")) == OAM_ZERO) )
                {
                    p_cell_spec_base_addr =
                        g_parameter_map_element[loop].cell_spec_base_addr + cell_arr_idx;

                    offset = (UInt8*)g_parameter_map_element[loop].param_base_addr
                        - (UInt8*)g_parameter_map_element[loop].cell_spec_base_addr;

                    param_addr = (UInt8*)p_cell_spec_base_addr + offset;
                    /*SPR 16554 Fix start*/
                    if(param_addr == OAM_NULL){

                        OAM_LOG(OAM, OAM_DETAILED, "param_addr Parameter found in table %p",param_addr);
                        retVal = OAM_FAILURE;
                        break;
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "param_addr Parameter found in table %p",param_addr);
                    }
                    /*SPR 16554 Fix End*/
                }    
                /* SPR 17880 18JAN FIX END */
				else {
					/* SPR 18930  FIX START */
					param_addr = oam_calc_param_addr(loop, curr_cell_id);
					/* SPR 18930  FIX END */
				}
				/*Coverity CID 63602 FIX*/  
				if(param_addr == OAM_NULL) {
					OAM_LOG(OAM, OAM_WARNING, "param_addr is NULL !!!!");

					retVal = OAM_FAILURE;                  
					break;
				}

				if (OAM_NULL == g_parameter_map_element[loop].validate) {
					OAM_LOG(OAM, OAM_DETAILED, "Executing schema parameter "
							"validation as parameter validate function is NULL");
					if(!(g_parameter_map_element[loop].parameter_mode
								& OAM_IGNORE_VALIDATION)) {
						retVal =
							oam_validate_one_element(loop,
									(UInt8*)parmeter_value,
									p_p_orig_parent,
									p_p_req_parent,
									p_p_p_xml_struct_addr,
									/* SPR 18930  FIX START */
									index,
									curr_cell_id);
						/* SPR 18930  FIX END */
					}
					else {
						OAM_LOG(OAM, OAM_DETAILED,
								"Skipping validation of the parameter value");
						retVal = OAM_SUCCESS;
					}
				}
				else {
					OAM_LOG(OAM, OAM_DETAILED,
							"Executing parameter validate function.");
                    /* SPR_19279_START */  
	                if ( (oam_strncasecmp((char *)parmeter_name, 
                    /* spr_21013_fix_start */
                        "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.CellReservedForOperatorUse", 
				           oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.CellReservedForOperatorUse")) 
                    /* spr_21013_fix_end */
                                == OAM_ZERO) )
                    {
                        retVal = OAM_SUCCESS;
                    }
                    else
                    {    
                    /* SPR_19279_END */
					retVal = g_parameter_map_element[loop].validate(
							(UInt8*)parmeter_value, loop, OAM_NULL);
                    /* SPR_19279_START */
                    }
                    /* SPR_19279_END */
				}

				/* oam 1.0 enum to enum mapping functions*/
				oam_update_enum_values(parmeter_name, parmeter_value);  
				/*code ended for enum related work*/

#ifndef OAM_SON_ENABLE
				/* SPR-16334 START */
				oam_set_x2_ecu_required(parmeter_name);
				/* SPR-16334 END */
#endif

				if(OAM_SUCCESS == retVal) {
					/* SPR 14158 FIX END */
					if(UINT8_TYPE == g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of UInt8 type.");
						/*value changed from string to UInt8 type and 
						  stored in required location */
                        /* SPR 18725 Fix Start */
                        if(oam_strstr(parmeter_name,
                                    "MBSFN.SFConfigList.RadioframeAllocationSize"))
                        {
                            UInt8 value = oam_atoi(parmeter_value);
                            if (OAM_ONE == value)
                            {
                                *((UInt8 *)param_addr) = ONE_FRAME_ALLOC;
                            }
                            else
                            {
                                *((UInt8 *)param_addr) = FOUR_FRAME_ALLOC;
                            }
                        }
                        else
                        {
						UInt8 value = oam_atoi(parmeter_value);
						*((UInt8 *)param_addr) = value;
                        }
                        /* SPR 18725 Fix End */

					}
					else if (UINT16_TYPE == g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of UInt16 type.");
						/*value changed from string to UInt16 type and
						  stored in required location*/
						UInt16 value = oam_atoi(parmeter_value);
						*((S16 *)param_addr) = value;
					}
					else if (SINT16_TYPE == g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of SInt16 type.");
						/*value changed from string to UInt16 type and
						  stored in required location*/
						SInt16 value = oam_atoi(parmeter_value);
						*((S16 *)param_addr) = value;
					}
					else if (UINT16_TYPE_2 == g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of UInt16_2 type.");
						/*value changed from string to UInt16 type and
						  stored in required location*/
						UInt16 value = oam_atoi(parmeter_value);
						*((U16 *)param_addr) = value;

					}

					else if (UINT32_TYPE == g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of UInt32 type.");
						/*value changed from string to UInt32 type and
						  stored in required location */
						UInt32 value = OAM_STRTOUL(parmeter_value , NULL , OAM_ZERO);
						*((U32 *)param_addr) = value;

					}
					else if (UINT64_TYPE == g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of UInt64 type.");
						/*value changed from string to UInt64 type and
						 *                           stored in required location*/
						UInt64 value = oam_atoll(parmeter_value);
						*((U64 *)param_addr) = value;

					}
					else if(STRING_TYPE == 
							g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of String type.");
						/*Value stored at specified location*/
						if(!oam_strncasecmp(g_parameter_map_element[loop].parameter_name, "RRH",OAM_THREE)) 
						{
							/*COVERITY FIX 61352*/
							if (param_addr != OAM_NULL)
								oam_strcpy(param_addr, parmeter_value);
							/*COVERITY FIX 61352*/
						}
						else 
						{
							UInt16 string_length = oam_strlen(parmeter_value);
							UInt16 string_value = oam_atoi(parmeter_value);
							SInt16 counter = OAM_ZERO;
							for (counter = string_length- OAM_ONE ; counter >= OAM_ZERO ; counter-- )
							{     
								((UInt8 *) param_addr)[counter] = (string_value % OAM_TEN);
								string_value = string_value / OAM_TEN; 
							}     
						}

					}
					else if(ASCII_STRING_TYPE ==
							g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of Ascii String type.");

						/* eICIC_PHASE_1_2_CHANGES_START */
						/*SPR 14180 start*/
						/*SPR 14433 start*/
						if ((oam_strstr(parmeter_name,"AbsPattern") != OAM_NULL)
								||(oam_strstr(parmeter_name,"abs_pattern") != OAM_NULL)
								|| (oam_strstr(parmeter_name,"VictimMeasSubset") != OAM_NULL))
						{
							/*SPR 14222 start*/
							oam_conversion_abs_pattern_byte_string_to_bitstring((char *)parmeter_value,(UInt8 *)param_addr); 
							/*SPR 14222 end*/
						}
						/*SPR 14433 start*/
						/*SPR 14180 end*/
						/* eICIC_PHASE_1_2_CHANGES_END */
                        /* Spr 15596 Fix Start */
                        else if(((strstr(parmeter_name,"Username"))||
									(strstr(parmeter_name,"Password"))||
									(strstr(parmeter_name,"FTPServerUserName"))||
									(strstr(parmeter_name,"FTPServerpassword"))||
									(strstr(parmeter_name,"SecGWServer")))
								&&(parmeter_value == OAM_NULL))
						{
							oam_memset(param_addr, OAM_ZERO ,strlen(param_addr)+1);
						}
						else
						{
							if (param_addr != OAM_NULL)
							{
								oam_strcpy(param_addr, parmeter_value);
							}
						}
                        /* Spr 15596 Fix End */
					}
					else if(PLMN_TYPE ==
							g_parameter_map_element[loop].parameter_type) {
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of PLMN type.");
						/* Update PLMN ID */
						oam_convert_plmnid(temp_plmnid,parmeter_value);
						/* BUG_FIXED_12753 */
						retVal = oam_populate_plmnid(temp_plmnid,
								param_addr);
						/* BUG_FIXED_12753 */
					}
					else if(IPADDR_TYPE ==
							g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of IP Address type.");

						if (param_addr != OAM_NULL)
						{
							change_address_format((UInt8*)parmeter_value,param_addr);
						}
					}
					else if (SINT8_TYPE == g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of SInt8 type.");
						/*value changed from string to SInt8 type and 
						  stored in required location */
						SInt8 value = oam_atoi(parmeter_value);
						*((SInt8 *)param_addr) = value;
					}
					/*CSR:00053605_CHANGE_START*/
					else if (OAM_ENUM_TYPE == g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of SInt8 type.");
						/*value changed from string to SInt8 type and 
						 *                           stored in required location */
						SInt32 value = oam_atoi(parmeter_value);
						*((SInt32 *)param_addr) = value;

					}
					/*CSR:00053605_CHANGE_END*/

					else if(TWO_BYTE_TYPE ==
							g_parameter_map_element[loop].parameter_type)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Paramter is of Two Bytes type.");
                        /* SPR_12455_FIX code deleted */
                        /*SPR 22398 Fix Start*/
                        oam_conversion_bitstring_short_to_byte_string(param_addr,(UInt32)oam_atoi(parmeter_value));
                        /*SPR 22398 Fix End*/
					}
					else if(THREE_BYTE_TYPE ==
							g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of Three Bytes type.");
						oam_convert_3byte_int_to_byte_string(param_addr,(UInt32)oam_atoi(parmeter_value));
					}
					else if(FOUR_BYTE_TYPE ==
							g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED, "Paramter is of Four Bytes type.");
						/* RT SPR 8627 FIX START */
#ifdef OAM_SON_ENABLE
						if(oam_strstr(parmeter_name,
									"NeighborList.InterRATCell.UMTS") ||
								oam_strstr(parmeter_name,
									"NeighborListInUse.InterRATCell.UMTS") ||
								oam_strstr(parmeter_name,
									"SON_NR_DELETE_FROM_REMOVE_LIST_INTER_RAT_UTRAN")) {
							if(oam_strstr(parmeter_name, ".RNCID")) 
							{
								oam_encode_rncid_to_utran_cell_identity(
										param_addr,
										oam_atoi(parmeter_value));
							}
							else if(oam_strstr(parmeter_name, ".CID")) 
							{
								oam_encode_cid_to_utran_cell_identity(
										param_addr,
										oam_atoi(parmeter_value));
							}
							/* RT SPR 11318 FIX START */ 
							else if(oam_strstr(parmeter_name, ".X_VENDOR_CSGID"))
							{
								/* BITSTRING FIX START */
								oam_conversion_from_int_to_byte_string(param_addr,
										(UInt32)oam_atoi(parmeter_value),OAM_CSG_ID_BITSTRING_SIZE);
								/* BITSTRING FIX END */
							}
							/* RT SPR 11318 FIX END */ 

						}
						/* BITSTRING FIX START */
						else if(oam_strstr(parmeter_name, "CSGID"))
						{
							oam_conversion_from_int_to_byte_string(param_addr,
									(UInt32)oam_atoi(parmeter_value),OAM_CSG_ID_BITSTRING_SIZE);
						}
						/* BITSTRING FIX END */



						/*BUG_FIXED_11271*/
						else if(oam_strstr(parmeter_name,
									"eNodeBParams.oam_son_req.oam_son_nr_enb_add_req.nbr_enb_list[255].enb_id")){

							UInt32 temp  = (UInt32)oam_atoi(parmeter_value );

							if(SON_MACRO_ENB == LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].enb_id.enb_type)
							{
								oam_conversion_from_macro_enb_to_byte_string(param_addr,temp, OAM_TWELVE);
							}
							if(SON_HOME_ENB ==  LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.nbr_enb_list[OAM_ZERO].enb_id.enb_type)
							{
								oam_conversion_from_int_to_byte_string(param_addr,temp,OAM_HOME_ENB_ID_BITSTRING_SIZE);
							}
						}
                        else if(oam_strstr(parmeter_name,
                                    /* SPR 15604 START */
                                    "NeighborList.LTECell") || strstr(parmeter_name,"NeighborListInUse.LTECell"))
                            /* SPR 15604 END */
                        {
                            /*SPR 11650 Fix*/
                            if(strstr(parmeter_name, ".CID")) {
                                oam_conversion_from_int_to_byte_string(param_addr,
                                        (UInt32)oam_atoi(parmeter_value),OAM_HOME_ENB_ID_BITSTRING_SIZE);

                            }
                            else if(strstr(parmeter_name, "CSGID"))
                            {
                                oam_conversion_from_int_to_byte_string(param_addr,
                                        (UInt32)oam_atoi(parmeter_value),OAM_CSG_ID_BITSTRING_SIZE);
                            }
                            else
                            {
                                oam_convert_int_to_byte_string(param_addr,(UInt32)oam_atoi(parmeter_value));
                            }
                        }
                        /* SPR 15604 END */

						/*BUG_FIXED_11271*/
						else
#endif
						{
							oam_convert_int_to_byte_string(param_addr,
									(UInt32)oam_atoi(parmeter_value));
						}
						/* RT SPR 8627 FIX END */
					}
					else if(OAM_UINT16_TOKENIZED_LIST_TYPE ==
							g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED,
								"Paramter is of UInt16 tokenized list type.");
#ifdef OAM_SON_ENABLE
						/* SPR 13024 FIX START */
						if(oam_strstr(parmeter_name,
									"GERANFreqGroup.X_VENDOR_EXPLICIT_ARFCN_LIST")) {
							cell_arr_idx =
								oam_get_son_inter_freq_carrier_idx(curr_cell_id);

							if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
								OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                             curr_cell_id);
								retVal = OAM_FAILURE;
								break;
							}

							p_son_anr_meas_config_req =
								&LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

							max_tokens = SON_MAX_GERAN_EXP_ARFCN_LIST_SIZE;
							p_son_anr_meas_config_req->other_rat_config_list.
								geran_config_list.
								geran_freq_info_list[index - 1].
								geran_car_freqs.following_arfcns.
								exp_arfcn_list_size =
								oam_tokenize_string_to_u16(parmeter_value,
										",",
										max_tokens,
										param_addr);
						}
						else if (oam_strstr(parmeter_name,
									"RAN.RF.PhyCellID")) {
							cell_arr_idx = oam_get_earfcn_pci_select_arr_idx(
									curr_cell_id);

							if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
								OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                             curr_cell_id);
								retVal = OAM_FAILURE;
								break;
							}

							p_son_pci_reselect_params =
								&LOCAL_SON_PROV_REQ.
								earfcn_pci_selection[cell_arr_idx].
								oam_son_pci_reselection_req;

							max_tokens = SON_MAX_PCI;
							p_son_pci_reselect_params->pci_list_size =
								oam_tokenize_string_to_u16_ext(parmeter_value,
										",", "..",
										param_addr,
										max_tokens,
										p_error_code);
						}
						/* SPR 13024 FIX END */
#endif
                        /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
                         if (oam_strstr(parmeter_name, "RAN.PHY.MBSFN."
                                    /* SPR 18155 FIX Start */
                                    "MBSFN_SERVICE_AREA_CONFIG."
                                    /* SPR 18155 FIX End */
                                    "X_VENDOR_MBMS_SERVICE_AREA_ID"))
                        {
                            cell_arr_idx =
                                oam_get_m2ap_cell_config_idx(curr_cell_id);
                            if (OAM_ERROR_RETURN_VAL == cell_arr_idx) 
                            {
                                OAM_LOG(OAM, OAM_ERROR,
                                        "Invalid cell context");
                                retVal = OAM_FAILURE;
                                break;
                            }

                            p_m2ap_prov_req_params = &LOCAL_M2AP_PROV_REQ;
                            max_tokens = MAX_SERVICE_AREA_ID_OCTET_SIZE;

                            p_m2ap_prov_req_params->
                                m2ap_cell_specific_parameters[cell_arr_idx].
                                num_service_area_code = 
                                oam_tokenize_string_to_u16(parmeter_value,
                                        ",",
                                        max_tokens,
                                        param_addr);

                        }
#endif
                        /* EMBMS Changes End */
					}
					else if(OAM_BITMAP_TOKENIZED_LIST_TYPE ==
							g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED,
								"Paramter is of octet bitmap tokenized list type");
#ifdef OAM_SON_ENABLE
						if(oam_strstr(parmeter_name,
									"GERANFreqGroup.X_VENDOR_ARFCN_BITMAP")) 
						{
							max_tokens = SON_MAX_NUM_OF_OCTETS_IN_VAR_BITMAP;
							p_bitmap_arr = LOCAL_SON_PROV_REQ.oam_son_inter_freq_carrier_params[OAM_ZERO].oam_son_anr_meas_config_req.
								other_rat_config_list.
								geran_config_list.
								geran_freq_info_list[index - 1].
								geran_car_freqs.following_arfcns.
								arfcn_bmp_list;
						}
#endif

						*(UInt8*)param_addr = oam_tokenize_string_to_bitmap_array(parmeter_value,
								",",
								max_tokens,
								p_bitmap_arr);
					}

                    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
                    else if (OAM_BIT_STRING_TOKENIZE_TO_UINT8_ARRAY_TYPE ==
                            g_parameter_map_element[loop].parameter_type)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Paramter is of bit string "
                                "type tokenize to UInt array");
                        if(oam_strstr(parmeter_name,
                                    "MBSFN.SFConfigList.SubFrameAllocations"))
                        {
                            cell_arr_idx =
                                oam_get_rrm_cell_config_idx(curr_cell_id);
                            if(OAM_ERROR_RETURN_VAL == cell_arr_idx) 
                            {
                                OAM_LOG(OAM, OAM_ERROR, "Invalid cell context");
                                retVal = OAM_FAILURE;
                                break;
                            }
                            sf_alloc_choice = 
                                *(&LOCAL_RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                                        physical_layer_params.
                                        mbsfn_subframe_config_list.
                                        mbsfn_subframe_config_info[index - 1].
                                        subframe_allocation.sf_alloc_choice);

                            if ((sf_alloc_choice == ONE_FRAME_ALLOC) &&
                                    (oam_strlen(parmeter_value) !=
                                     SUB_FRAME_ALLOC_STR_MIN_LEN))
                            {
                                OAM_LOG(OAM, OAM_ERROR,
                                        "Invalid value passed for"
                                        "\n SubFrameAllocation. "
                                        "For RadioFrameAllocationSize %d "
                                        "minimum no. of comma separated bits "
                                        "should be 6",sf_alloc_choice);
                                retVal = OAM_FAILURE;
                                break;
                            }
                            else if ((sf_alloc_choice ==
                                        FOUR_FRAME_ALLOC) &&
                                    (oam_strlen(parmeter_value) !=
                                     SUB_FRAME_ALLOC_STR_MAX_LEN))
                            {
                                OAM_LOG(OAM, OAM_ERROR,
                                        "Invalid value passed for"
                                        "\n SubFrameAllocation. "
                                        "For RadioFrameAllocationSize %d "
                                        "minimum no. of comma separated bits "
                                        "should be 11",sf_alloc_choice);
                                retVal = OAM_FAILURE;
                                break;
                            }

                            max_tokens = oam_bit_string_to_uint8_array(
                                    parmeter_value,
                                    ",", 
                                    SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE,
                                    param_addr);
                            /* TDD_Changes Start */
                            /* In Case of TDDMode,
                             * **Reset 6th bit in case of One-Frame config 
                             * **Reset 20th, 21st, 22nd and 23rd bit in caseof Four-Frame
                             * config */
                            oam_memcpy(DuplexMode, oam_prov_req.oam_tr069_req.
                                    tr069_init_params.DuplexMode,
                                    OAM_MAX_STR_LEN);
                            if (!(oam_strcmp("TDDMode", (char*)DuplexMode)))
                            {
                                if (sf_alloc_choice == ONE_FRAME_ALLOC) 
                                {
                                    ((UInt8 *)param_addr)[0] = (((UInt8 *)param_addr)[0] &
                                        ~(TDD_BITMASK_FOR_ONE_FRAME));
                                }
                                else if (sf_alloc_choice == FOUR_FRAME_ALLOC)
                                {
                                    ((UInt8 *)param_addr)[2] = (((UInt8 *)param_addr)[2] &
                                        ~(TDD_BITMASK_FOR_FOUR_FRAME));
                                }
                            }
                            /* TDD_Changes End */
                            if (!max_tokens)
                            {
                                OAM_LOG(OAM, OAM_ERROR, "Invalid value passed for"
                                        " SubFrameAllocation");
                                break;
                            }
                        }
                    }
#endif
                    /* EMBMS Changes End */

					/* RT SPR 9019 FIX START */
					else if(STRUCTURE_TYPE ==
							g_parameter_map_element[loop].parameter_type)
					{
						OAM_LOG(OAM, OAM_DETAILED,
								"Paramter is of structure-type");
#ifdef OAM_SON_ENABLE
						if (oam_strstr(parmeter_name,
									"InterRATCell.UMTS.PCPICHScramblingCode")) {
							/* SPR 13024 FIX START */
							cell_arr_idx =
								oam_get_son_cell_nr_list_idx(curr_cell_id);
							/* SPR 13024 FIX END */

							if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
								OAM_LOG(OAM, OAM_WARNING,
										"Invalid cell context[cid=%d]",
                                             curr_cell_id);
                                /* spr_21013_fix_start */
                                if(dup_param_name)
                                {    
                                /* spr_21013_fix_end */
								oam_free(dup_param_name); /* Cov Fix 63714 */
					                dup_param_name = OAM_NULL;
                                /* spr_21013_fix_start */
                                }
                                /* spr_21013_fix_end */
								return OAM_FAILURE;
							}

							/* SPR-13586 START */
							if(SON_NEIGHBORLIST_INFO(cell_arr_idx).
									inter_rat_umts_entry_bitmap & (1 << (index - 1)))
								/* SPR-13586 END */
							{
								p_son_nr_add = &SON_NR_ADD_REQ(cell_arr_idx);
								uarfcn = p_son_nr_add->nr_list.inter_rat_nr_list[index - 1].
									utran_neighbor.uarfcn;
							}
							else {
								p_local_son_nr_add =
									&LOCAL_SON_NR_ADD_REQ(cell_arr_idx);
								uarfcn = p_local_son_nr_add->nr_list.inter_rat_nr_list[index - 1].
									utran_neighbor.uarfcn;
							}
							p_pci = param_addr;

							/* SPR 13024 FIX START */
							cell_arr_idx1 =
								oam_get_rrm_cell_config_idx(curr_cell_id);
							/* SPR 13024 FIX END */
							if(OAM_ERROR_RETURN_VAL == cell_arr_idx1) {
								OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                             curr_cell_id);
                                /* spr_21013_fix_start */
                                if(dup_param_name)
                                {    
                                /* spr_21013_fix_end */
								    /*COV_FIXED_12 */ 
                                    oam_free(dup_param_name);
					                dup_param_name = OAM_NULL;
                                    /*COV_FIXED_12 */
                                /* spr_21013_fix_start */
                                }
                                /* spr_21013_fix_end */
								return OAM_FAILURE;
							}

							p_rrm_cell_config = &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx1];

							freq_found = oam_find_arfcn_in_available_freqs(
									uarfcn,
									OAM_ARFCN_UTRAN, p_rrm_cell_config);


							if(OAM_UTRAN_FREQ_FDD == freq_found) 
							{
								p_pci->pci_fdd = oam_atoi(parmeter_value);
							}
							else if(OAM_UTRAN_FREQ_TDD == freq_found) 
							{
								p_pci->pci_tdd = oam_atoi(parmeter_value);
							}
							else {
								OAM_LOG(OAM, OAM_WARNING, "UARFCN for requested"
										" neighbor is not available");
                                /*SPR_18437_START*/
                                p_pci->pci_fdd = oam_atoi(parmeter_value);
                                p_pci->pci_tdd = oam_atoi(parmeter_value);
                                /*SPR_18437_END*/
								//retVal = OAM_FAILURE;
								//*p_error_code = OAM_INVALID_ARFCN_VALUE;
								//break;
							}
						}
						/* SPR-13586 START */
						else if(oam_strstr(parmeter_name, "InterRATCell.GSM.LAC") ||
								oam_strstr(parmeter_name, "InterRATCell.GSM.CI")) {

							if(oam_strstr(parmeter_name, "InterRATCell.GSM.LAC")) {
                                /*SPR 22398 Fix Start*/
                                oam_conversion_bitstring_short_to_byte_string(param_addr,(UInt32)oam_atoi(parmeter_value));
                                /*SPR 22398 Fix End*/
							}
							else {
								offset = OAM_GSM_CELL_IDENTITY_CI_START_OFFSET;

							p_cellidentity = param_addr + offset;


							value = oam_atoi(parmeter_value);

							*p_cellidentity = value & 0x000000FF;

							value >>= OAM_BYTE_SIZE_IN_BITS;
							++p_cellidentity;

							*p_cellidentity = value & 0x000000FF;
                            /*SPR 22398 Fix Start*/
							}
                            /*SPR 22398 Fix End*/
						}
						else if(oam_strstr(parmeter_name,
									"InterRATCell.GSM.BSIC")) {
							p_gsm_pci = param_addr;

							value = oam_atoi(parmeter_value);

							p_gsm_pci->bscc =
								(value & OAM_GSM_CELL_BSIC_BSCC_MASK);

							p_gsm_pci->ncc =
								((value >> OAM_GSM_CELL_BSIC_NUM_BSCC_BITS) & OAM_GSM_CELL_BSIC_BSCC_MASK);
						}

						/* SPR-13586 END */
#endif
					} /* RT SPR 9019 FIX END */
					else if (EUTRAN_CELL_IDENTITY_TYPE ==
							g_parameter_map_element[loop].parameter_type) {
						retVal =
							oam_encode_eutran_cellidentity_into_bit_stream(
									param_addr,
									(UInt32)oam_atoi(parmeter_value));

						if(OAM_FAILURE == retVal) {
							OAM_LOG(OAM, OAM_WARNING,
									"Failed to convert LTECell CID to bitstream");
							break;
						}
					}

					/*Bitmask set for API whose parametr is being set */
					/*Bitmask set for API whose parametr is being set */
					paramter_app_map_tbl |= 
						g_parameter_map_element[loop].lower_layer_bitmask;
					/*Addition of Bitmask required to be set for the specific parameter */
					if (g_parameter_map_element[loop].parameter_bitmask &&
							p_local_req)
					{
						g_parameter_map_element[loop].parameter_bitmask(loop,
								p_local_req);
					}

					if(oam_strstr(parmeter_name, "SON NR ADD UTRAN") || oam_strstr(parmeter_name, "SON NR UPDATE UTRAN")) {
						if(oam_strstr(parmeter_name, "X_VENDOR_PS_HO_SUPPORTED")) {
							ps_ho_val  =  oam_atoi(parmeter_value);
							if((ps_ho_val == OAM_ZERO) && (g_srvcc_check_flag == OAM_ZERO)){
								g_srvcc_check_flag = OAM_ONE;
							}
							else if((ps_ho_val == OAM_ZERO) && (g_srvcc_check_flag == OAM_ONE)){
								g_srvcc_check_flag = OAM_TWO;
							}
						}
						if(oam_strstr(parmeter_name, "X_VENDOR_VOIP_CAPABLE")) {
							voip_addr = param_addr;
							voip_val  =  oam_atoi(parmeter_value);
							if((voip_val == OAM_ONE) && (g_srvcc_check_flag == OAM_ZERO)){
								g_srvcc_check_flag = OAM_ONE;
							}
							else if((voip_val == OAM_ONE) && (g_srvcc_check_flag == OAM_ONE)){
								g_srvcc_check_flag = OAM_TWO;
							}
						}
						if(g_srvcc_check_flag == OAM_TWO){
							/* coverity 61064 */
							if(voip_addr != OAM_NULL){
								*(UInt8 *)voip_addr = OAM_ZERO;
							}
							g_srvcc_check_flag = OAM_ZERO;
						}
					}
					OAM_LOG(OAM,OAM_INFO,"parameter found in database");
					break;

				}
				else 
				{ /* In case validation failed*/
					OAM_LOG(OAM, OAM_WARNING, "Error:parmeters Validation failed");
                    /* SPR 17453 changes start */
#ifdef OAM_SON_ENABLE
                    oam_prov_req.oam_son_req.cell_neighbourlist_info[0].intra_rat_last_added_instance_id --;
                    /* SPR 17453 changes end */
#endif
					*p_error_code = OAM_SET_PARAMETER_INPUT_INCORRECT; 
					retVal = OAM_FAILURE;
					break;
				}
			}
			else 
			{
				OAM_LOG(OAM, OAM_WARNING, "Error:parmeter MODE mismatch");
				retVal = OAM_FAILURE;
				*p_error_code = OAM_SET_PARAMETER_MODE_MISMATCH;
				break;
			}
		}
	}
	/*When entire databse is searched but no matching parameter could be found*/

	if(loop ==  max_element) 
	{  
		*p_error_code = OAM_PARAMETER_NOT_FOUND; 
		OAM_LOG(OAM, OAM_WARNING,
				"Error: Invalid parmeters recevied : No match found ");
		retVal = OAM_FAILURE;
	}
	/* Freeing memory allocated by strdup in oam_normalize_indexed_param */
    /* spr_21013_fix_start */
    if(dup_param_name)
    {    
    /* spr_21013_fix_end */
        oam_free(dup_param_name); 
        dup_param_name = OAM_NULL;
    /* spr_21013_fix_start */
    }
    /* spr_21013_fix_end */
	OAM_FUN_EXIT_TRACE();
	return retVal;
}


/* CA_UT_INIT */
/******************************************************************************
 *   FUNCTION NAME: oam_get_string_parameter
 *
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : p_mcc :pointer to location where changes are required to do.
 *                 loop : loop for mapping the database location
 *  Output       : ascii_str = array to string conversion
 *
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *
 ******************************************************************************/
oam_return_et
oam_get_string_parameter
(
 UInt8 * p_element_loc,
 int database_loop,
 char * ascii_str    
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17375 START*/
    UInt16 counter = OAM_ZERO;
    /* SPR 17375 END*/
	UInt32 value= OAM_ZERO;
	SInt8 cell_config_idx  = OAM_ERROR_RETURN_VAL;
	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	OAM_NULL_CHECK(OAM_NULL != p_element_loc);
	OAM_NULL_CHECK(OAM_NULL != ascii_str);

    /* spr_21013_fix_start */
	if(oam_strncasecmp("InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE.CSGID",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))
			== OAM_ZERO)
	{    
		/* BITSTRING FIX START */
		oam_cmn_convert_csgid_to_integer(p_element_loc,OAM_FOUR,&value);
		/* BITSTRING FIX START */
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN,"%d",value);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.EAID",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))
			== OAM_ZERO)
	{
		oam_cmn_convert_bytes_to_integer(p_element_loc,OAM_THREE,&value);
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN,"%d",value);
	}
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS.LAC",
				g_parameter_map_element[database_loop].parameter_name))
	{
        /*SPR 22398 Fix Start*/
		oam_cmn_convert_bytes_to_integer_for_LAC(p_element_loc, &value);
        /*SPR 22398 Fix End*/
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%u", value);
	}
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborList.LTECell.X_VENDOR_TAC",
				g_parameter_map_element[database_loop].parameter_name))
	{
		/*SPR 11315 start*/
		oam_cmn_convert_byte_string_to_short(p_element_loc,&value, OAM_MAX_SHORT_INT_BITSTRING_SIZE - OAM_TAC_BIT_STRING_SIZE);
		/*SPR 11315 start*/
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);
	}
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.UMTS.LAC",
				g_parameter_map_element[database_loop].parameter_name))
	{
        /*SPR 22398 Fix Start*/
		oam_cmn_convert_bytes_to_integer_for_LAC(p_element_loc, &value);
        /*SPR 22398 Fix End*/
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);
	}
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborListInUse.LTECell.X_VENDOR_TAC",
				g_parameter_map_element[database_loop].parameter_name))
	{
		/*SPR 11315 start*/
		oam_cmn_convert_byte_string_to_short(p_element_loc, &value, OAM_MAX_SHORT_INT_BITSTRING_SIZE - OAM_TAC_BIT_STRING_SIZE); 
		/*SPR 11315 start*/
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.TAC",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))
			== OAM_ZERO)
	{
		/*SPR 11315 start*/
		oam_cmn_convert_byte_string_to_short(p_element_loc, &value, OAM_MAX_SHORT_INT_BITSTRING_SIZE - OAM_TAC_BIT_STRING_SIZE);
		/*SPR 11315 end*/
		oam_snprintf((char *)ascii_str,PARAM_VAL_PAIR_MAX_LEN,"%d",value);
	}
	else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Common.CellIdentity",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))
			== OAM_ZERO)
	{
		oam_cmn_convert_bytes_to_integer(p_element_loc,OAM_FOUR,&value);
		oam_snprintf((char *)ascii_str,PARAM_VAL_PAIR_MAX_LEN,"%d",value);

	}
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS.X_VENDOR_CSGID" ,
				g_parameter_map_element[database_loop].parameter_name))
	{
		/* BITSTRING FIX START */
		oam_cmn_convert_csgid_to_integer(p_element_loc,OAM_FOUR, &value);
		/* BITSTRING FIX START */
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);

	}
	/* RT SPR 8627 FIX START */
	/* LINES DELETED */
	/* RT SPR 8627 FIX END */
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborList.LTECell.X_VENDOR_CSGID" ,
				g_parameter_map_element[database_loop].parameter_name))
	{
		/* BITSTRING FIX START */
		oam_cmn_convert_csgid_to_integer(p_element_loc,OAM_FOUR, &value);
		/* BITSTRING FIX START */
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);

	}
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborList.LTECell.CID" ,
				g_parameter_map_element[database_loop].parameter_name))
	{
		oam_cmn_convert_bytes_to_integer(p_element_loc,OAM_FOUR, &value);
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);

	}
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.UMTS.X_VENDOR_CSGID" ,
				g_parameter_map_element[database_loop].parameter_name))
	{
		/* BITSTRING FIX START */
		oam_cmn_convert_csgid_to_integer(p_element_loc,OAM_FOUR, &value);
		/* BITSTRING FIX START */
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);
	}
	/* RT SPR 8627 FIX START */
	/* LINES DELETED */
	/* RT SPR 8627 FIX END */
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborListInUse.LTECell.X_VENDOR_CSGID" ,
				g_parameter_map_element[database_loop].parameter_name))
	{
		/* BITSTRING FIX START */
		oam_cmn_convert_csgid_to_integer(p_element_loc,OAM_FOUR, &value);
		/* BITSTRING FIX START */
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);

	}
	else if(!oam_strcmp("InternetGatewayDevice.Services.FAPService."
				"CellConfig.LTE.RAN.NeighborListInUse.LTECell.CID" ,
				g_parameter_map_element[database_loop].parameter_name))
	{
		oam_cmn_convert_bytes_to_integer(p_element_loc,OAM_FOUR, &value);
		oam_snprintf(ascii_str,PARAM_VAL_PAIR_MAX_LEN, "%d", value);

	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.Capabilities.SupportedSystems",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.Capabilities.LTE.BandsSupported",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.SecGWServer1",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.SecGWServer2",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.SecGWServer3",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.RF.PhyCellID",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.[1].PLMNID",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.REM.LTE.REMBandList",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.REM.LTE.EUTRACarrierARFCNDLList",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.REM.LTE.REMPLMNList",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	else if(!oam_strncasecmp("InternetGatewayDevice.ManagementServer.URL",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name))) 
	{
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	/* Fault Management changes */
	else if(!oam_strncmp("InternetGatewayDevice.FaultMgmt.",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen("InternetGatewayDevice.FaultMgmt."))) {
		oam_strcpy(ascii_str, (const char*)p_element_loc);
	}
	/*CSR:00053605_CHANGE_START*/ 
	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.AllowedCipheringAlgorithmList",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name)))
	{
		UInt8 i=OAM_ZERO;
		oam_strcpy(ascii_str,"");
		for(i=OAM_ZERO;i<LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].supported_security_algorithms.ciphering_algorithms.num_algorithms;i++) 
		{
			if(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].supported_security_algorithms.ciphering_algorithms.algorithms[i]==OAM_ZERO)
			{
				oam_strcat(ascii_str,AllowedCipheringAlgorithmList[OAM_ZERO].display_string);
				oam_strcat(ascii_str," ");
			}
			else if(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].supported_security_algorithms.ciphering_algorithms.algorithms[i]==OAM_ONE)
			{
				oam_strcat(ascii_str,AllowedCipheringAlgorithmList[OAM_ONE].display_string);
				oam_strcat(ascii_str," ");
			}
			else if(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].supported_security_algorithms.ciphering_algorithms.algorithms[i]==OAM_TWO)
			{
				oam_strcat(ascii_str,AllowedCipheringAlgorithmList[OAM_TWO].display_string);
				oam_strcat(ascii_str," ");
			}


		}
	}

	else if(!oam_strncasecmp("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.AllowedIntegrityProtectionAlgorithmList",
				g_parameter_map_element[database_loop].parameter_name,
				oam_strlen(g_parameter_map_element[database_loop].parameter_name)))
	{
		UInt8 i=OAM_ZERO;
		oam_strcpy(ascii_str,"");
		for(i=OAM_ZERO;i<LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].supported_security_algorithms.integrity_algorithms.num_algorithms;i++)  
		{
			if(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].supported_security_algorithms.integrity_algorithms.algorithms[i]==OAM_ZERO) 
			{
				oam_strcat(ascii_str,AllowedIntegrityProtectionAlgorithmList[OAM_ZERO].display_string);
				oam_strcat(ascii_str," ");
			}
			else if(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].supported_security_algorithms.integrity_algorithms.algorithms[i]==OAM_ONE)
			{
				oam_strcat(ascii_str,AllowedIntegrityProtectionAlgorithmList[OAM_ONE].display_string);
				oam_strcat(ascii_str," ");
			}
			else if(LOCAL_RRC_PROV_REQ.sector_info_list.sector_info[0].supported_security_algorithms.integrity_algorithms.algorithms[i]==OAM_TWO)
			{
				oam_strcat(ascii_str,AllowedIntegrityProtectionAlgorithmList[OAM_TWO].display_string);
				oam_strcat(ascii_str," ");
			}

		}
	}
	/*CSR:00053605_CHANGE_END*/
	/* SPR 17375 START*/
    else if (oam_strncasecmp("InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE.HNBName",
    /* spr_21013_fix_end */
                g_parameter_map_element[database_loop].parameter_name,
                oam_strlen(g_parameter_map_element[database_loop].parameter_name))
            == OAM_ZERO)
    {
        for(counter = OAM_ZERO;
                counter < (local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].access_mgmt_params.hnb_name_size);
                ++counter)
            oam_sprintf(&ascii_str[counter], "%u", p_element_loc[counter]);

        ascii_str[counter] = OAM_ZERO;

    }
	/* SPR 17375 END*/

#ifdef OAM_RADIO_HEAD_SUPPORT
#ifdef OAM_RRH_TYPE_1_SUPPORT 
	else
	{ 
		oam_get_string_rrh_param_value(g_parameter_map_element[database_loop].parameter_name,
				database_loop, ascii_str, p_element_loc); 
	}
#endif
#endif
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}


/******************************************************************************
 * Function Name  : oam_get_param_value
 * Inputs         : full_param_name
 *                : param_val  
 * Outputs        : none
 * Returns        : parameter_type/OAM_ZERO 
 * Description    : 
 *******************************************************************************/
/* coverity 53564 53558 53554 41320*/
/* Coverity CID: 56677, 56678; Proj: 18_NOV_OAM_2.4.1 */
UInt8
oam_get_param_value
(
 char *full_param_name, 
 char *param_val,
 oam_error_code_et *p_error_code
 )
{
	OAM_FUN_ENTRY_TRACE();
	oam_counter_t loop_cntr = OAM_ZERO;
	UInt8 *p_master_param_addr, *p_local_param_addr;
	UInt32 struct_offset = OAM_ZERO;
	char* param_name = OAM_NULL;
	UInt32 param_name_len = OAM_ZERO;
	UInt32 curr_pos = OAM_ZERO;
	UInt8 *p_master_dataset = (UInt8*)&oam_prov_req; 
	UInt8 *p_local_dataset = (UInt8*)&local_prov_req;
	UInt8 retVal = OAM_ZERO;
	char ascii_str[PARAM_VAL_PAIR_MAX_LEN] = {OAM_ZERO};
    /* spr_21013_fix_start */
	UInt8 index = OAM_ONE;
    /* spr_21013_fix_end */
	Char8 *normalized_param = OAM_NULL;
	UInt16 value = OAM_ZERO;
	/* SPR 13024 FIX START */
	UInt32 cid = oam_prov_req.cell_cntxt.curr_cell_cid;
	SInt8 cell_arr_idx = OAM_ZERO;
	/* SPR 13024 FIX END */
	oam_return_et retVal2 = OAM_SUCCESS;
	UInt8 arr_size = 0;
	UInt8* p_bitmap_arr = OAM_NULL;
	UInt32 max_size = 0;

	/* RT SPR 9019 FIX START */
#if defined(OAM_SON_ENABLE) || defined(LTE_EMBMS_SUPPORTED)
	UInt16* p_u16_arr = OAM_NULL;
#endif
#ifdef OAM_SON_ENABLE
	son_utran_physical_cell_id_t *p_pci = OAM_NULL;
	/* SPR 13024 FIX START */
	oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req = OAM_NULL;
	/* SPR 13024 FIX END */
	/* SPR-13586 START */
	SInt32 offset = OAM_ZERO;
	UInt8 *p_cellidentity = OAM_NULL;
	son_geran_physical_cell_id_t *p_gsm_pci = OAM_NULL;
	/* SPR-13586 END */
#endif
	/* RT SPR 9019 FIX END */


    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    UInt8 num_service_area = OAM_ZERO;
    UInt8 sf_alloc_choice = OAM_ZERO;
#endif
    /* EMBMS Changes End */
	param_name = (char *)OAM_STRRCHR(full_param_name, '.');
	if(param_name != OAM_NULL)
	{
		++param_name;
		param_name_len = oam_strlen(param_name);
		oam_memcpy(param_val, param_name, param_name_len);
	}
	curr_pos += param_name_len;
	*(param_val + curr_pos++) = '=';

	/* !!!!!NOTE!!!! */
	/* Special case for FaultMgmt parameters requested by SNMP interface */
	if(oam_strstr(full_param_name, "X_VENDOR_EXPEDITEDEVENT_NUM_VALID_ENTRIES") ||
			oam_strstr(full_param_name, "X_VENDOR_QUEUEDEVENT_NUM_VALID_ENTRIES") ||
			oam_strstr(full_param_name, "X_VENDOR_HISTORYEVENT_NUM_VALID_ENTRIES")) {
		if(oam_strstr(full_param_name,
					"X_VENDOR_EXPEDITEDEVENT_NUM_VALID_ENTRIES")) {
			value = oam_prov_req.fm_cntxt.isExpeditedRolled ?
				OAM_EXPEDITED_ALARM_MAX :
				oam_prov_req.fm_cntxt.Expedited_List_Index;
		}
		else if(oam_strstr(full_param_name,
					"X_VENDOR_QUEUEDEVENT_NUM_VALID_ENTRIES")) {
			value = oam_prov_req.fm_cntxt.isQueuedRolled ?
				OAM_QUEUED_ALARM_MAX :
				oam_prov_req.fm_cntxt.Queued_List_Index;
		}
		else {
			value = oam_prov_req.fm_cntxt.isHistoryRolled ?
				OAM_HISTORY_ALARM_MAX :
				oam_prov_req.fm_cntxt.History_List_Index;
		}
		OAM_LOG(OAM, OAM_DETAILED, "Parameter is of UInt16 type");
		/* the %h denotes that the following conversion specifier
		   is a signed short or an unsigned short, hence interprets
		   it as a 2-Byte integer */
		oam_sprintf(param_val + curr_pos, "%u", value);
		retVal = UINT16_TYPE;
		OAM_FUN_EXIT_TRACE();
		/* Coverity FIX 54279 */
		return retVal;
	}
	/*  Special case ends */



	/*searching in global database*/
	UInt16 max_element = oam_find_global_table_size(g_parameter_map_element);
	OAM_LOG(OAM, OAM_DETAILED, "Size of parsing table: %d", max_element);

    /* spr_21013_fix_start */
    if((oam_strncasecmp((char *)full_param_name, "InternetGatewayDevice.Services.FAPService.CellConfig", 
				           oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig")) == OAM_ZERO) )
    {
        oam_find_fap_index(full_param_name, &index);
    }
    else
    {    
        index = oam_normalize_indexed_param(full_param_name, &normalized_param);

        OAM_LOG(OAM, OAM_DETAILED, "Index: %d, Normalized parameter name: %s",
                index, normalized_param);

        /* oam_normalize_indexed_param can be return 0, that's why it should be reset with 1 */
        if(index == OAM_ZERO)
        {
            index = OAM_ONE; 
        }

        full_param_name = normalized_param;
    }
    /* spr_21013_fix_end */


	for(loop_cntr = OAM_ZERO; loop_cntr < max_element; ++loop_cntr) {
		if((!oam_strcmp(full_param_name,
						g_parameter_map_element[loop_cntr].parameter_name))) {
			retVal = g_parameter_map_element[loop_cntr].parameter_type;
			if(g_parameter_map_element[loop_cntr].parameter_mode &
					MULTI_INSTANCE_PARAM) {
				OAM_LOG(OAM, OAM_INFO,
						"Parameter is multi-object-instance type");
				p_local_param_addr =
					oam_find_multi_inst_param_addr(full_param_name,
							OAM_GET_PARAMETER_VALUES,
							index - OAM_ONE,
							g_parameter_map_element,
							loop_cntr);
				if(!p_local_param_addr) {
					retVal = OAM_ZERO;
					*p_error_code = OAM_PARAMETER_NOT_FOUND;
                    /* spr_21013_fix_start */
                    if(normalized_param) 
                    {
                    /* spr_21013_fix_end */
					    oam_free(normalized_param);   /*COVERITY FIX 54198*/
			            normalized_param = OAM_NULL;
                    /* spr_21013_fix_start */
                    }
                    /* spr_21013_fix_end */
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}
			}
			else {
/* SPR 18930  FIX START */
				p_local_param_addr = oam_calc_param_addr(loop_cntr, oam_prov_req.cell_cntxt.curr_cell_cid);
/* SPR 18930  FIX END */
			}
			struct_offset = p_local_param_addr - p_local_dataset;
			p_master_param_addr = p_master_dataset + struct_offset; 

			switch(retVal) {
				case UINT8_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of UInt8 type");
					/* the %hh denotes that the following conversion specifier
					   is a signed char or an unsigned char, hence interprets
					   it as a 1-Byte integer */
					oam_sprintf(param_val + curr_pos,
							"%u", *((UInt8 *)p_master_param_addr));
					break; 
				case UINT16_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of UInt16 type");
					/* the %h denotes that the following conversion specifier
					   is a signed short or an unsigned short, hence interprets
					   it as a 2-Byte integer */
					oam_sprintf(param_val + curr_pos, "%u",
							*((UInt16 *)p_master_param_addr));
					break;

				case UINT32_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of UInt32 type");
					oam_sprintf(param_val + curr_pos, "%u", *((UInt32*)p_master_param_addr));
					break;

				case UINT16_TYPE_2:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of UINT16_TYPE_2 type");
					oam_sprintf(param_val + curr_pos, "%u",
							*((UInt16*)p_master_param_addr));
					break;
				case UINT64_TYPE:
					OAM_LOG(OAM, OAM_DETAILED, "Paramter is of UInt64 type.");
					oam_sprintf(param_val + curr_pos, "%llu",
							*((UInt64*)p_master_param_addr));
					break;

				case SINT16_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of SINT16_TYPE type");
					oam_sprintf(param_val + curr_pos, "%d",
							*((SInt16*)p_master_param_addr));
					break;

				case STRING_TYPE:
				case TWO_BYTE_TYPE:
				case THREE_BYTE_TYPE:
				case FOUR_BYTE_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of char-array type");
					/* RT SPR 8627 FIX START */
#ifdef OAM_SON_ENABLE
					if(oam_strstr(full_param_name,
								"NeighborList.InterRATCell.UMTS") ||
							oam_strstr(full_param_name,
								"NeighborListInUse.InterRATCell.UMTS") ||
							oam_strstr(full_param_name,
								"SON_NR_DELETE_FROM_REMOVE_LIST_INTER_RAT_UTRAN")) {

						if(oam_strstr(full_param_name, ".RNCID")) {
							oam_extract_rncid_from_utran_cell_identity(&value,
									p_master_param_addr);
						}
						else if(oam_strstr(full_param_name, ".CID")) {
							oam_extract_cid_from_utran_cell_identity(&value,
									p_master_param_addr);
						}
						oam_snprintf(ascii_str,sizeof(ascii_str), "%d",
								value);
					}
					else
#endif
					{
						oam_get_string_parameter(p_master_param_addr,
								loop_cntr, ascii_str);
					}
					/* RT SPR 8627 FIX END */

					oam_memcpy(param_val + curr_pos, ascii_str,
							oam_strlen(ascii_str) + OAM_ONE);
					break;

				case ASCII_STRING_TYPE:

					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of ascii-string type");

                    /* Spr 17753 Changes Start */
                    if (oam_strstr(full_param_name, "LTE.RAN.RF.PhyCellID"))
                    {
                        cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
                        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
                            OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                                    cid);
                            retVal = OAM_FAILURE;
                            break;
                        }

                        oam_snprintf(param_val + curr_pos, OAM_FOUR, "%d",
                                RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                                rf_params.rf_configurations.
                                phy_cell_id);

                    }

                    /* Spr 17753 Changes End */ 
					/* eICIC_PHASE_1_2_CHANGES_START */
					/*bug_13969_start */
					/*SPR 14180 start*/
					if( (oam_strstr(full_param_name,"AbsPattern")) || ((oam_strstr(full_param_name,"abs_pattern")))
							||(oam_strstr(full_param_name,"VictimMeasSubset")))
					{
						oam_conversion_abs_pattern_bit_string_to_bytestring
							(param_val + curr_pos , p_master_param_addr);
					}
					/*SPR 14180 end*/
					/*bug_13969_end */
					/* eICIC_PHASE_1_2_CHANGES_END */
					else
					{
						oam_memcpy(param_val + curr_pos, p_master_param_addr,
								oam_strlen((Char8*)p_master_param_addr) + OAM_ONE);
					}
					break;
				case SINT8_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of SINT8_TYPE type");
					oam_sprintf(param_val + curr_pos, "%d", *((SInt8 *)p_master_param_addr));
					break;
					/*CSR:00053605_CHANGE_START*/
				case OAM_ENUM_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of ENUM_TYPE type");
					oam_sprintf(param_val + curr_pos, "%d", *((SInt32 *)p_master_param_addr));

					break;
					/*CSR:00053605_CHANGE_END*/   
				case PLMN_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of PLMN_TYPE type");
					oam_generate_plmnid((Char8*)(param_val + curr_pos),
							p_master_param_addr);
					break;

					/*BUG_FIX_ID : 743*/
				case TIMESTAMP_TYPE:
					oam_fetch_convert_seconds_to_timestamp((time_t)p_master_param_addr,(Char8*)(param_val + curr_pos));
					break;

					/* RT SPR 8154 FIX START */
				case OAM_UINT16_TOKENIZED_LIST_TYPE:
					/*CID:67039 start*/
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of UInt16 tokenized list type");
					max_size = MAX_PARAMETER_NAME_LENGTH - curr_pos;

					/* SPR 13024 FIX START */
					if (!oam_strcmp(param_name, "PhyCellID")) {
						cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
						/*Coverity Fix 66976*/
						if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
							OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                         cid);
							retVal = OAM_FAILURE;
							break;
						}

						oam_snprintf(param_val + curr_pos, max_size, "%d",
								RRM_CELL_CONFIG(cell_arr_idx).ran_info.
								rf_params.rf_configurations.
								phy_cell_id);
					}

#ifdef OAM_SON_ENABLE
					else if (!oam_strcmp(param_name,
								"X_VENDOR_EXPLICIT_ARFCN_LIST")) {
						cell_arr_idx = oam_get_son_inter_freq_carrier_idx(cid);

						if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
							OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                         cid);
							retVal = OAM_FAILURE;
							break;
						}

						p_son_anr_meas_config_req =
							&SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);
						arr_size =
							p_son_anr_meas_config_req->other_rat_config_list.
							geran_config_list.
							geran_freq_info_list[index - 1].
							geran_car_freqs.following_arfcns.
							exp_arfcn_list_size;

						p_u16_arr = (UInt16*)p_master_param_addr;
						retVal2 =
							oam_convert_u16_arr_to_delimited_string(p_u16_arr,
									arr_size,
									',',
									ascii_str,
									max_size);
						if(OAM_FAILURE == retVal2) {
							OAM_LOG(OAM, OAM_WARNING, "Error in conversion");
							OAM_FUN_EXIT_TRACE();
                            /* spr_21013_fix_start */
                            if(normalized_param) 
                            {
                            /* spr_21013_fix_end */
							    oam_free(normalized_param);/*COVERITY FIX 54198*/
			                    normalized_param = OAM_NULL;
                            /* spr_21013_fix_start */
                            }
                            /* spr_21013_fix_end */
							return OAM_FAILURE;
						}

						oam_snprintf(param_val + curr_pos, max_size, "%s",
								ascii_str);
					}
#endif
					/* SPR 13024 FIX END */
                /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
                else if (!oam_strcmp(param_name, "X_VENDOR_MBMS_SERVICE_AREA_ID")) 
                {
                    cell_arr_idx = oam_get_m2ap_cell_config_idx(cid);
                    if(OAM_ERROR_RETURN_VAL == cell_arr_idx) 
                    {
                        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context");
                        retVal = OAM_FAILURE;
                        break;
                    }
                    num_service_area = M2AP_CELL_SPEC_PARAMS(cell_arr_idx).
                        num_service_area_code;
                    p_u16_arr = (UInt16*)p_master_param_addr;
                    retVal =
                        oam_convert_u16_arr_to_delimited_string(p_u16_arr,
                                num_service_area,
                                ',',
                                ascii_str,
                                max_size);
                    if(OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_ERROR, "Error in conversion");
                        break;
                    }

                    oam_snprintf(param_val + curr_pos, max_size, "%s",
                            ascii_str);
                }
#endif
                /* EMBMS Changes End */
					break; 
					/*CID:67039 end*/

				case OAM_BITMAP_TOKENIZED_LIST_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of octet-bitmap tokenized list type");

					max_size = MAX_PARAMETER_NAME_LENGTH - curr_pos;
					arr_size = *(UInt8*)p_master_param_addr;
					p_bitmap_arr = (UInt8*)p_master_param_addr + 1;
					retVal2 = oam_convert_bitmap_arr_to_delimited_string(
							p_bitmap_arr,
							arr_size,
							',',
							ascii_str,
							max_size);
					if(OAM_FAILURE == retVal2) {
						OAM_LOG(OAM, OAM_WARNING, "Error in conversion");
						OAM_FUN_EXIT_TRACE();
                        /* spr_21013_fix_start */
                        if(normalized_param) 
                        {
                        /* spr_21013_fix_end */
						oam_free(normalized_param);   /*COVERITY FIX 54198*/
			            normalized_param = OAM_NULL;
                        /* spr_21013_fix_start */
                        }
                        /* spr_21013_fix_end */
						return OAM_FAILURE;
					}
					oam_sprintf(param_val + curr_pos, "%s", ascii_str);
					break; 

                /* EMBMS Changes Start */
                case OAM_BIT_STRING_TOKENIZE_TO_UINT8_ARRAY_TYPE:
                OAM_LOG(OAM, OAM_DETAILED,
                        "Paramter is of bit string type tokenize to"
                        " UInt array");
#ifdef LTE_EMBMS_SUPPORTED
                if (oam_strstr(full_param_name,
                            "MBSFN.SFConfigList.SubFrameAllocations"))
                {
                    cell_arr_idx = oam_get_rrm_cell_config_idx(cid);

                    if (OAM_ERROR_RETURN_VAL == cell_arr_idx)
                    {
                        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context");
                        retVal = OAM_FAILURE;
                        break;
                    }
                    sf_alloc_choice = 
                        *(&RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                                physical_layer_params.
                                mbsfn_subframe_config_list.
                                mbsfn_subframe_config_info[index - 1].
                                subframe_allocation.sf_alloc_choice);
                    OAM_LOG(OAM, OAM_INFO, "sf_alloc_choice GPV %d",
                            sf_alloc_choice);

                    if (sf_alloc_choice == ONE_FRAME_ALLOC)
                    {
                        arr_size = SUB_FRAME_ALLOC_ONE_FRAME_OCTET_SIZE;
                        max_size = SUB_FRAME_ALLOC_STR_MIN_LEN + 1;
                    }
                    else if (sf_alloc_choice == FOUR_FRAME_ALLOC)

                    {
                        arr_size = SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE;
                        max_size = SUB_FRAME_ALLOC_STR_MAX_LEN + 1;
                    }

                    p_bitmap_arr = p_master_param_addr;
                    retVal = oam_uint8_array_to_bit_string(p_bitmap_arr,
                            arr_size,
                            param_val + curr_pos,
                            max_size);
                    if(OAM_ZERO == retVal) {
                        OAM_LOG(OAM, OAM_ERROR, "Error in conversion");
                    }
                }
                break; 
#endif
                /* EMBMS Changes End */

				case STRUCTURE_TYPE:
					OAM_LOG(OAM, OAM_DETAILED,
							"Parameter is of structure type");

#ifdef OAM_SON_ENABLE
					if(oam_strstr(full_param_name,
								"InterRATCell.UMTS.PCPICHScramblingCode")) {
						p_pci =
							(son_utran_physical_cell_id_t*)p_master_param_addr;
						value = (p_pci->bitmask & SON_PCI_FDD_PRESENT) ?
							p_pci->pci_fdd : p_pci->pci_tdd;
					}
					/* SPR-13586 START */
					else if(oam_strstr(full_param_name, "InterRATCell.GSM.LAC") ||
							oam_strstr(full_param_name, "InterRATCell.GSM.CI")) {
						p_cellidentity = p_master_param_addr;

						if(oam_strstr(full_param_name, "InterRATCell.GSM.LAC")) {
                            /*SPR 22398 Fix Start*/
                            oam_conversion_bitstring_short_to_byte_string(p_cellidentity,(UInt32)value);
                            /*SPR 22398 Fix End*/
						}
						else {
							offset = OAM_GSM_CELL_IDENTITY_CI_START_OFFSET;

						value = 0;
						value = *(p_cellidentity + (offset + 1));

						value <<= OAM_BYTE_SIZE_IN_BITS;
						value |= *(p_cellidentity + offset);
                        /*SPR 22398 Fix Start*/
						}
                        /*SPR 22398 Fix End*/
					}
					else if(oam_strstr(full_param_name,
								"InterRATCell.GSM.BSIC")) {
						p_gsm_pci = (son_geran_physical_cell_id_t *)p_master_param_addr;

						value = 0;
						value  = p_gsm_pci->ncc;
						value <<= OAM_GSM_CELL_BSIC_NUM_NCC_BITS;
						value |= p_gsm_pci->bscc;
					}

					/* SPR-13586 END */
#endif
					oam_sprintf(param_val + curr_pos, "%u", value);
					break;

				case EUTRAN_CELL_IDENTITY_TYPE:

					retVal2 = oam_decode_bit_stream_into_eutran_cellidentity(
							p_master_param_addr, &cid); 
					/*  Coverity Id : 81826 Fix Start */
					if(OAM_FAILURE == retVal2) {
						OAM_LOG(OAM, OAM_WARNING, "Error in Decoding");
						OAM_FUN_EXIT_TRACE();
                        /* spr_21013_fix_start */
                        if(normalized_param) 
                        {
                        /* spr_21013_fix_end */
						oam_free(normalized_param);   /*COVERITY FIX 54198*/
			            normalized_param = OAM_NULL;
                        /* spr_21013_fix_start */
                        }
                        /* spr_21013_fix_end */
						return OAM_FAILURE;
					}
					/*  Coverity Id : 81826 Fix End */

					oam_sprintf(param_val + curr_pos, "%d", cid);
			}
			/* RT SPR 8154 FIX END */

			/* oam 1.0 enum to enum mapping functions*/
			oam_fetch_enum_values(full_param_name,(param_val + curr_pos));
			/*code ended for enum related work*/

			OAM_LOG(OAM, OAM_DETAILED,
					"Parameter-Value pair: %s", param_val);
			break;
		}
	}
	if(max_element == loop_cntr) {
		OAM_LOG(OAM, OAM_WARNING,
				"Invalid parmeters recevied");
		/* coverity 35887 */
		*p_error_code = OAM_GET_PARAMETER_INPUT_INCORRECT;
		retVal = OAM_ZERO;
	}

	/* Freeing memory allocated by strdup in oam_normalize_indexed_param */
    /* spr_21013_fix_start */
    if(normalized_param)
    {    
    /* spr_21013_fix_end */
        oam_free(normalized_param);   /*COVERITY FIX 25may*/
        normalized_param = OAM_NULL;
    /* spr_21013_fix_start */
    }
    /* spr_21013_fix_end */

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/******************************************************************************
 * Function Name  : encode_get_params_resp_ctrl_blk 
 * Inputs         : p_ctrl_blk
 *                : resp_status
 *                : err_code
 *                : resvd1
 *                : resvd2
 *                : err_str_len
 *                : err_str  
 * Outputs        : none
 * Returns        : Nothing
 * Description    : 
 *******************************************************************************/

void 
encode_get_params_resp_ctrl_blk
(
 char *p_ctrl_blk,
 char resp_status,
 UInt16 err_code,
 UInt8 resvd1, 
 UInt32 resvd2,
 UInt8 err_str_len,
 char *err_str
 )
{
	OAM_FUN_ENTRY_TRACE();
	UInt32 curr_pos = OAM_ZERO;
	*(p_ctrl_blk + curr_pos++) = resp_status;/*packing response status*/
	/*packing error code*/
	*(p_ctrl_blk + curr_pos++) = (err_code & OAM_UPPER_EIGHT_BITS_SET) >> OAM_EIGHT;
	*(p_ctrl_blk + curr_pos++) = err_code & OAM_ALL_8_BIT_SET; 
	/*packing reserved field*/
	*(p_ctrl_blk + curr_pos++) = resvd1; 
	*(p_ctrl_blk + curr_pos++) = (resvd2 & 0xff0000) >> OAM_SIXTEEN; 
	*(p_ctrl_blk + curr_pos++) = (resvd2 & OAM_UPPER_EIGHT_BITS_SET) >> OAM_EIGHT; 
	*(p_ctrl_blk + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;
	/*packing error string length*/
	*(p_ctrl_blk + curr_pos++) = err_str_len;

	/* Encode error string only when there is failure */
	if(err_str_len != OAM_ZERO)
		oam_memcpy(p_ctrl_blk + curr_pos, err_str, err_str_len);
	OAM_FUN_EXIT_TRACE();
}
/* CA_UT_INIT */
#ifdef OAM_SON_ENABLE /* FLAG_CHANGES */
/******************************************************************************
 * Function Name  : oam_populate_son_nr_retrieve_req 
 * Inputs         : p_api_buf
 *                : p_error_code 
 * Outputs        : 
 * Returns        : 
 * Description    : 
 *******************************************************************************/
oam_return_et
oam_populate_son_nr_retrieve_req
(
 void                *p_api_buf,
 oam_error_code_et  *p_error_code
 )
{
	OAM_FUN_ENTRY_TRACE();

	oam_return_et                      ret_val = OAM_SUCCESS;
	oam_son_nr_retrieve_req_t          oam_son_nr_retreive_req={OAM_ZERO};
	UInt16                     trans_id = oam_get_new_trans_id();
	UInt16 usr_req_trans_id = get_word_from_header(p_api_buf);
	UInt16 usr_src_id = get_word_from_header(p_api_buf +OAM_TWO);
	UInt16 msg_len = get_word_from_header(p_api_buf + OAM_EIGHT);
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	/* Populate Source CGI */
	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}
	oam_memcpy(&(oam_son_nr_retreive_req.src_cgi.plmn_id),
			&(RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.primary_plmn_id),
			sizeof(son_cell_plmn_info_t));

	oam_memcpy(&(oam_son_nr_retreive_req.src_cgi.cell_identity),
			&(RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.cell_identity),
			sizeof(SON_CELL_ID_OCTET_SIZE));

	ret_val = oam_son_send_son_oam_nr_retrieve_req(&oam_son_nr_retreive_req,
			OAM_MODULE_ID,
			SON_MODULE_ID,
			trans_id,
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_SUCCESS == ret_val)
	{
		OAM_LOG(OAM, OAM_DETAILED, "Send SON_OAM_NR_RETRIEVE_REQ success");
#ifndef OAM_UT_FRAMEWORK
		oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);
#endif

	}
	else
	{
		OAM_LOG(OAM,OAM_ERROR,"Send SON_OAM_NR_RETRIEVE_REQ failure");
		oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
				OAM_ZERO, OAM_VERSION,
				OAM_MODULE_ID, usr_src_id,
				usr_req_trans_id, OAM_ZERO,
				OAM_ZERO,
				"Sendto layer failed",
				p_error_code); 
	}

	OAM_FUN_EXIT_TRACE();
	return ret_val;
}

/******************************************************************************
 * Function Name  : oam_populate_son_nr_enb_retrieve_req 
 * Inputs         : p_api_buf
 *                : p_error_code 
 * Outputs        : 
 * Returns        : 
 * Description    : 
 *******************************************************************************/
oam_return_et
oam_populate_son_nr_enb_retrieve_req
(
 void                *p_api_buf
            /*SPR 17777 fix*/
 )
{
	OAM_FUN_ENTRY_TRACE();

	oam_return_et                      ret_val = OAM_SUCCESS;
	oam_son_nr_enb_retrieve_req_t      oam_son_nr_enb_retreive_req={OAM_ZERO};
	UInt16                     trans_id = oam_get_new_trans_id(),
				   msg_len = OAM_ZERO;

	/* Entire list need to be fetched, No bitmask set */
	oam_son_nr_enb_retreive_req.bitmask = OAM_ZERO;

	/*getting api_size*/
	msg_len = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
	oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);

	if(OAM_SUCCESS == oam_son_send_son_oam_nr_enb_retrieve_req(
				&oam_son_nr_enb_retreive_req,
				OAM_MODULE_ID,
				SON_MODULE_ID,
				trans_id,
				oam_prov_req.cell_cntxt.curr_cell_cid))
	{
		OAM_LOG(OAM,OAM_DETAILED,"Send SON_OAM_NR_RETRIEVE_REQ success");
		/* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
		if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
					OAM_TRANS_SON,msg_len,p_api_buf))
		{
			OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
			ret_val = OAM_FAILURE;
		}
#endif
		/* SPR 9620 CHANGE END */    
	}
	else
	{
		OAM_LOG(OAM,OAM_WARNING,"Send SON_OAM_NR_RETRIEVE_REQ failure");
	}

	OAM_FUN_EXIT_TRACE();
	return ret_val;
}

/***************************************************************************
 * Function Name  : oam_send_son_cell_switched_off_info_req 
 * Inputs         : NONE
 * Outputs        :
 * Returns        :
 * Description    : Function to send SON_OAM_ES_SWITCHED_OFF_CELL_INFO_REQ to
 *                  SON layer
 ****************************************************************************/
	void
oam_send_son_cell_switched_off_info_req(void *p_api_buf, UInt16 msg_len)
{
	OAM_FUN_ENTRY_TRACE();
	UInt8 *p_msg = OAM_NULL;
	UInt8 *p_msg_offset = OAM_NULL;
	oam_error_code_et err = NO_ERROR;
	oam_return_et retVal = OAM_FAILURE;
	UInt16 msg_length = OAM_CSPL_HDR_SIZE +
		LOWER_LAYER_INTERFACE_HEADER_SIZE;
	UInt16 trans_id = oam_get_new_trans_id();

	retVal = oam_mem_alloc(msg_length, (void**)&p_msg, &err);

	if(OAM_FAILURE == retVal) {
		OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_msg failed"
                " with Error Code:%d",
                err);
		OAM_FUN_EXIT_TRACE(); 
		return;
	}

	p_msg_offset = p_msg;
	oam_construct_api_header(p_msg_offset, OAM_VERSION_ID,
			OAM_MODULE_ID, SON_MODULE_ID,
			SON_OAM_ES_SWITCHED_OFF_CELL_INFO_REQ,
			msg_length);

	/* Fill interface header */
	p_msg_offset += OAM_CSPL_HDR_SIZE;
	oam_construct_interface_api_header(p_msg_offset, trans_id,
			OAM_MODULE_ID, SON_MODULE_ID,
			SON_OAM_ES_SWITCHED_OFF_CELL_INFO_REQ,
			msg_length - OAM_CSPL_HDR_SIZE,
			oam_prov_req.cell_cntxt.curr_cell_cid);

	/* Coverity CID 99048 Fix Start */
	if(OAM_FAILURE == oam_send_message(p_msg, SON_MODULE_ID, &err))
	{
		OAM_LOG(OAM, OAM_ERROR, "Error in sending SON_OAM_ES_SWITCHED_OFF_CELL_INFO_REQ message to SON module "
				" with error code: %d", err);
		OAM_FUN_EXIT_TRACE();
		return;
	}
	/* Coverity CID 99048 Fix End */

	oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);

	OAM_FUN_EXIT_TRACE();
	return;
}

    /* SPR_19619 start*/

/***************************************************************************
 * Function Name  : oam_send_son_peer_cell_activation_req 
 * Inputs         : NONE
 * Outputs        :
 * Returns        :
 * Description    : Function to send SON_OAM_PEER_CELL_ACTIVATION_REQ to
 *                  SON layer
 ****************************************************************************/
void
oam_send_son_peer_cell_activation_req(void *p_api_buf, UInt16 msg_len)
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 *p_msg = OAM_NULL;
    UInt8 *p_msg_offset = OAM_NULL;
    oam_error_code_et err = NO_ERROR;
    oam_return_et retVal = OAM_FAILURE;
    UInt16 msg_length = OAM_CSPL_HDR_SIZE +
        LOWER_LAYER_INTERFACE_HEADER_SIZE;
    UInt16 trans_id = oam_get_new_trans_id();

    retVal = oam_mem_alloc(msg_length, (void**)&p_msg, &err);

    if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_msg failed"
                " with Error Code:%d",
                err);
        OAM_FUN_EXIT_TRACE(); 
        return;
    }

    p_msg_offset = p_msg;
    oam_construct_api_header(p_msg_offset, OAM_VERSION_ID,
            OAM_MODULE_ID, SON_MODULE_ID,
            SON_OAM_PEER_CELL_ACTIVATION_REQ,
            msg_length);

    /* Fill interface header */
    p_msg_offset += OAM_CSPL_HDR_SIZE;
    oam_construct_interface_api_header(p_msg_offset, trans_id,
            OAM_MODULE_ID, SON_MODULE_ID,
            SON_OAM_PEER_CELL_ACTIVATION_REQ,
            msg_length - OAM_CSPL_HDR_SIZE,
	    oam_prov_req.cell_cntxt.curr_cell_cid);

    /* Coverity CID 115208 Fix Start */
    if(OAM_FAILURE == oam_send_message(p_msg, SON_MODULE_ID, &err))
    {
	    OAM_LOG(OAM, OAM_ERROR, "Error in sending SON_OAM_PEER_CELL_ACTIVATION_REQ message to SON module "
			    " with error code: %d", err);
	    OAM_FUN_EXIT_TRACE();
	    return;
    }
    /* Coverity CID 115208 Fix End */

    oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);

    OAM_FUN_EXIT_TRACE();
    return;
}
    /* SPR_19619 stop*/

/***************************************************************************
 * Function Name  : oam_send_son_es_switched_of_cell_info_to_usr 
 * Inputs         : NONE
 * Outputs        : 
 * Returns        : 
 * Description    : Function to handle SON_OAM_ES_SWITCHED_OFF_CELL_INFO_RESP
 *                  to SON layer
 ****************************************************************************/
void oam_send_son_es_switched_of_cell_info_to_usr
(
 son_oam_es_switched_off_cell_info_resp_t *p_resp,
 UInt16                                   dst_id,
 UInt16                                   resp_trans_id
 )
{

	OAM_FUN_ENTRY_TRACE();
	UInt8 cid = OAM_ZERO; 
	Char8 parent_name[] = {"SON.ES.Retrieve.Switched_off_cells"};
	UInt8 start_index = OAM_ZERO; 
	UInt8 end_index = OAM_ZERO;
	UInt16 num_params = OAM_ZERO;
	UInt16 count = OAM_ZERO;
	UInt16 param_cnt = OAM_ZERO;
	Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
	Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	oam_error_code_et err = NO_ERROR;
	oam_return_et retVal = OAM_FAILURE;

	if(SON_FAILURE == p_resp->result) {
		OAM_LOG(OAM, OAM_INFO, "Failure response received from layer");
		OAM_FUN_EXIT_TRACE();
		oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
				OAM_ERR_INTERNAL_ERROR,
				OAM_VERSION_ID,
				OAM_MODULE_ID,
				dst_id, resp_trans_id,
				OAM_ZERO, OAM_ZERO,
				"Failure response received from lower layer",
				&err);
		return;
	}

	OAM_LOG(OAM, OAM_INFO, "Success response received from layer");

	num_params = p_resp->num_switched_off_cells;
	OAM_LOG(OAM, OAM_DETAILED, "Number of switched-off cells: %d", num_params);


	for(count = OAM_ZERO; count < 2 * num_params; ++count) {
		retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
				(void**)&param_list[count], &err);

		if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
                    "Memory allocation to param_list failed"
                    " with Error Code:%d",
                    err);
			OAM_FUN_EXIT_TRACE(); 
			return;
		}

		oam_memset(param_list[count], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
	}

	for(count = OAM_ZERO; count < num_params; ++count) {
		/* Populate PLMN-ID */
		oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
		oam_generate_plmnid(temp_param,
				&(p_resp->switched_off_cell_info_list[count].plmn_id));
		oam_snprintf(param_list[param_cnt],MAX_PARAMETER_NAME_LENGTH, 
				"PLMNID[%d]=%s", count, temp_param); 
		OAM_LOG(OAM, OAM_DETAILED, "PLMNID of cell[%d]: %s", count + OAM_ONE,
				temp_param);
		param_cnt++;
		/* Populate Cell-Identity */
		cid = oam_extract_cid_from_eutran_cellidentity(
				p_resp->switched_off_cell_info_list[count].cell_identity
				);

		oam_snprintf(param_list[param_cnt],MAX_PARAMETER_NAME_LENGTH,
				"CID[%d]=%d", count,cid);
		param_cnt++;
		OAM_LOG(OAM, OAM_DETAILED, "CID of cell[%d]: %d", count + OAM_ONE,
				cid);
	}


	retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
			(UInt8**)param_list,
			param_cnt, resp_trans_id,
			&err, dst_id,
			start_index, end_index);
	if(OAM_FAILURE == retVal) {
		OAM_LOG(OAM, OAM_ERROR,
				"Error in sending response to user with error code: %d",
				err);
	}

	for(count = OAM_ZERO; count < 2 * num_params; ++count) {
		retVal = oam_mem_free(param_list[count], &err);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"Error in memory free with error code: %d", err);

		}
	}

	OAM_FUN_EXIT_TRACE();
	return;
}
#endif

/******************************************************************************
 * Function Name  : oam_get_parameter_api_handler
 * Inputs         : p_api_buf
 *                : msg_len
 *                : src id
 *       : error_code
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : this function handles the GET param command 
 *******************************************************************************/
oam_return_et
oam_get_parameter_api_handler
(
 void *p_api_buf,
 UInt16 msg_len,
 UInt16 src_module_id,
 oam_error_code_et *p_error_code 
 )
{
	/*CID:64759 start*/
	OAM_FUN_ENTRY_TRACE();
	/* SPR 12698 FIX START */
	UInt8 temp_ptr[TEMP_PTR_BUFFER_SIZE] = {OAM_ZERO};
	/* SPR 12698 FIX END */
	UInt8 config_flag = OAM_ZERO;
	UInt8 *p_temp_buf = p_api_buf;
	UInt16 resp_payload_len = OAM_ZERO;
        /* SPR 15527 START */
        /*Coverity 98825 Fix Start */  
 	UInt16 num_params = OAM_ZERO;
        /*Coverity 98825 Fix End */  
        /* SPR 15527 END */
	char par_name[MAX_PARENT_NAME_LENGTH];
	UInt16 par_name_len = OAM_ZERO;
	UInt8  loop = OAM_ZERO;
	UInt16 param_node_len = OAM_ZERO;
	UInt8 param_name_len = OAM_ZERO;
	Char8 par_dot_param[MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH];
	Char8 param_val_pair[PARAM_VAL_PAIR_MAX_LEN];
	Char8 param_name[MAX_PARAMETER_NAME_LENGTH];
	Char8 *temp_payload;
	UInt16  param_val_pair_len = OAM_ZERO;
	UInt16 trans_id = OAM_ZERO;
	UInt16 curr_pos = OAM_ZERO;
	/* Coverity CID: 56677, 56678; Proj: 18_NOV_OAM_2.4.1 */
	oam_return_et retVal = OAM_SUCCESS;
	UInt8 ret_datatype = 0;
	UInt16 param_info_len = OAM_ZERO;/* Coverity Fix: Vivek */
	char error_str[STR_LEN_80];
	UInt8  err_len;
	/* cover 41291 */
	UInt16 usr_error_code = OAM_ZERO;
	UInt8 resp_status = OAM_ZERO;
	UInt8 ctrl_blk_len = OAM_ZERO;
	UInt16 dst_module_id = OAM_ZERO;

	UInt8 start_index = OAM_ZERO;
	UInt8 end_index = OAM_ZERO;
	UInt8 multi_obj_cnt = OAM_ZERO;
	UInt8 max_multi_obj_cnt = OAM_ZERO;
	oam_bool_et partial_parent_flag = OAM_FALSE;
	UInt8 inst_num = OAM_ZERO;
	Char8 *parameter_token = OAM_NULL;
	UInt8 bit_num = OAM_ZERO;
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	UInt8 **temp_arr = OAM_NULL;
	UInt8 str_count = OAM_ZERO;
	UInt8 loop_counter = 0;
	UInt8 temp_str_cli[OAM_HUNDRED];
	UInt8 size_x = OAM_HUNDRED;
	UInt8 size_y = OAM_HUNDRED;
	oam_bool_et partial_path_flag = OAM_FALSE;
#ifdef LTE_EMBMS_SUPPORTED
    oam_m2ap_get_stat_req_t oam_m2ap_get_stats_req = {OAM_ZERO};
#endif
    /* spr_21013_fix_start */
    UInt8 fap_index_value = OAM_ZERO;
    UInt8 current_cid = OAM_ZERO;
	oam_cell_status_t *p_cell_status = OAM_NULL;
    /* spr_21013_fix_end */

	/* pointer to get params response message to be prepared */
	UInt8 *oam_get_params_resp = OAM_NULL;

	/* total length of response message */
	UInt16 resp_len = OAM_CSPL_HDR_SIZE + OAM_MGMT_INTF_HEADER_SIZE;

	if(OAM_NULL == p_api_buf) 
	{
		OAM_LOG(OAM, OAM_WARNING, "NULL pointer error, returning...");
		/* coverity 35886 */
        /* spr 21390 fix start */
		*p_error_code = OAM_NULL_POINTER_ERR;
        /* spr 21390 fix end */
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}

	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
        /* SPR 21390 fix start */
		*p_error_code = OAM_INVALID_CELL_CONTEXT ;
		OAM_FUN_EXIT_TRACE();
        /* SPR 21390 fix end */

		return OAM_FAILURE;
	}


	trans_id = get_word_from_header((UInt8 *)p_temp_buf);
	/* Source-ID of the incoming message will be the destination ID of
	 * the outgoing message */
	/*src id of incoming buffer is going to be the destination id of outgoing msg*/
	dst_module_id = get_word_from_header((UInt8 *)p_temp_buf +OAM_TWO);

	p_temp_buf += OAM_MGMT_INTF_HEADER_SIZE;

	num_params = *(p_temp_buf +OAM_TWO); /*total number of parameters*/

	/* start index */
	start_index = *(p_temp_buf +OAM_THREE); /*increase buf pointer to point to start index*/

	/* end index */
	end_index = *(p_temp_buf +OAM_FOUR); /*increase buf pointer to point to end index */

	OAM_LOG(OAM,OAM_INFO,"GPV request: Trans_id[%u] module-id[%u] num_params[%u]"
        " start_index[%u] end_index[%u]",
        trans_id, dst_module_id, num_params, start_index, end_index);

	if(( end_index - start_index ) > OAM_MAX_GPV_INSTANCES) /* Max 20 instances are supported in single gpv */
	{
		OAM_LOG(OAM, OAM_WARNING,
				"Invalid range[%u] for object instances max 20 instances "
				"supported , returning...", end_index - start_index);
		/* coverity 35888 */
		*p_error_code = OAM_INTERNAL_ERROR;
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}

	/*fetching parent name len from buffer*/
	par_name_len = get_word_from_header((UInt8 *)(p_temp_buf + OAM_SIX));

	p_temp_buf += OAM_EIGHT; /*increase buf pointer to point to parent name*/
	oam_memset(par_name, OAM_ZERO, MAX_PARENT_NAME_LENGTH);
	oam_memcpy(par_name, p_temp_buf, par_name_len);/*extract parent name*/

	if (oam_strlen(par_name) == OAM_ZERO) {
		OAM_LOG(OAM, OAM_WARNING, "Empty parent name received, returning...");
		*p_error_code = OAM_GET_PARAMETER_INPUT_INCORRECT;
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}
	OAM_LOG(OAM, OAM_DETAILED, "Parent Name: %s", par_name);

    /* spr_21013_fix_start */
	if(oam_strstr(par_name, "InternetGatewayDevice.Services.FAPService.["))
    {
        oam_find_fap_index(par_name,&fap_index_value);

        if((!fap_index_value) || (fap_index_value > oam_prov_req.num_cells_configured))
        {    
            OAM_LOG(OAM, OAM_WARNING, "FAPService INDEX [%d] is either ZERO OR greater num_cells_configured [%d], which is incorrect",
                    fap_index_value,oam_prov_req.num_cells_configured);
            /* SPR 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT ;
            /* SPR 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        current_cid = oam_prov_req.cell_cntxt.cell_ctxt_status[fap_index_value - 1].cid; 

        p_cell_status = oam_get_cell_cntxt_status(current_cid);
        if (p_cell_status) 
        {
            oam_prov_req.cell_cntxt.curr_cell_cid = current_cid;
            cell_config_idx = oam_get_rrm_cell_config_idx(
                    oam_prov_req.cell_cntxt.curr_cell_cid);
            if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        oam_prov_req.cell_cntxt.curr_cell_cid);
                /* SPR 21390 fix start */
                *p_error_code = OAM_INVALID_CELL_CONTEXT ;
                OAM_FUN_EXIT_TRACE();
                /* SPR 21390 fix end */
                return OAM_FAILURE;
            }
            OAM_LOG(OAM, OAM_INFO,"Cell Context Changed to CID: %d, par_name %s, fap_index_value %d", 
             current_cid,par_name,fap_index_value);
        }
        else {
            OAM_LOG(OAM, OAM_WARNING,"Invalid Cell ID: %d Cell Context not changed, par_name %s, fap_index_value %d",
                                            current_cid,par_name,fap_index_value);
            /* SPR 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT ;
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
            /* SPR 21390 fix end */
        }    
    }
    /* spr_21013_fix_end */

	p_temp_buf += par_name_len;/* increase bufpointer to point to first
				      parameter */
	g_parameter_map_element = g_parameter_TR_element;

	/* Status req */
	/* coverity 54908 */
	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);

    /* spr_21013_fix_start */
	if(!oam_strcmp(par_name, "InternetGatewayDevice.Services.FAPService."
    /* spr_21013_fix_end */
				"CellConfig.LTE.EPC.PLMNList.")) {
		/* Partial path support for Plmnlist  */
		partial_parent_flag = OAM_TRUE;

		retVal = oam_partial_path_plmnlist_fill_params((UInt8 *)&num_params,
				&max_multi_obj_cnt);
		if(OAM_FAILURE == retVal) {
			Char8 error_str[] =
				"Too many parameters in response. Please retry!";

			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ERR_REQUEST_DENIED,
					OAM_VERSION, OAM_MODULE_ID,
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					error_str, p_error_code);

			OAM_FUN_EXIT_TRACE();
			return OAM_SUCCESS;
		}
	}
    /* SPR 15527 START */
    /* spr_21013_fix_start */
    else if(!strcmp(par_name, "InternetGatewayDevice.Services.FAPService."
    /* spr_21013_fix_end */
               "CellConfig.LTE.EPC.QoS.")) {
        /* Partial path support for QoS  */
        partial_parent_flag = OAM_TRUE;

        retVal = oam_partial_path_qos_fill_params((UInt8 *)&num_params,
                                                        &max_multi_obj_cnt);
       if(OAM_FAILURE == retVal) {
           Char8 error_str[] =
               "Too many parameters in response. Please retry!";

           oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
                   OAM_ERR_REQUEST_DENIED,
                   OAM_VERSION, OAM_MODULE_ID,
                   dst_module_id, trans_id,
                   OAM_ZERO, OAM_ZERO,
                   error_str, p_error_code);

           OAM_FUN_EXIT_TRACE();
           return OAM_SUCCESS;
       }
   }
    /* SPR 15527 END */

	/**** FM Partial Path Changes ****/ 
	else if(!oam_strcmp(par_name,
				"InternetGatewayDevice.FaultMgmt.QueuedEvent.")) {
		/* This is a special case in GPV request when only the parent is
		 * is present in the GPV request message, and no specific  set of
		 * parameter is requested, in this case all the parameter values
		 * for all the possible parents(in case of multi-object instances)
		 * should be fetched
		 */
		partial_parent_flag = OAM_TRUE;
		num_params = ARRSIZE(g_parameter_multi_instanse_FM_QUED_GET_SET);

		if(OAM_ONE == oam_prov_req.fm_cntxt.isQueuedRolled) {
			max_multi_obj_cnt = OAM_QUEUED_ALARM_MAX;
		}
		else {
			max_multi_obj_cnt = oam_prov_req.fm_cntxt.Queued_List_Index;
		}

		OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
				"FaultMgmt.QueuedEvent.");
	}
	else if(!oam_strcmp(par_name,
				"InternetGatewayDevice.FaultMgmt.ExpeditedEvent.")) {
		/* This is a special case in GPV request when only the parent is
		 * is present in the GPV request message, and no specific  set of
		 * parameter is requested, in this case all the parameter values
		 * for all the possible parents(in case of multi-object instances)
		 * should be fetched
		 */
		partial_parent_flag = OAM_TRUE;
		num_params = ARRSIZE(g_parameter_multi_instanse_FM_EXPD_GET_SET);

		if(OAM_ONE == oam_prov_req.fm_cntxt.isExpeditedRolled) {
			max_multi_obj_cnt = OAM_EXPEDITED_ALARM_MAX;
		}
		else {
			max_multi_obj_cnt = oam_prov_req.fm_cntxt.Expedited_List_Index;
		}

		OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
				"FaultMgmt.ExpeditedEvent.");
	}
	else if(!oam_strcmp(par_name,
				"InternetGatewayDevice.FaultMgmt.HistoryEvent.")) {
		/* This is a special case in GPV request when only the parent is
		 * is present in the GPV request message, and no specific  set of
		 * parameter is requested, in this case all the parameter values
		 * for all the possible parents(in case of multi-object instances)
		 * should be fetched
		 */
		partial_parent_flag = OAM_TRUE;
		num_params = ARRSIZE(g_parameter_multi_instanse_FM_HIST_GET_SET);

		if(OAM_ONE == oam_prov_req.fm_cntxt.isHistoryRolled) {
			max_multi_obj_cnt = OAM_HISTORY_ALARM_MAX;
		}
		else {
			max_multi_obj_cnt = oam_prov_req.fm_cntxt.History_List_Index;
		}

		OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
				"FaultMgmt.HistoryEvent.");
	}
	else if(!oam_strcmp(par_name,
				"InternetGatewayDevice.FaultMgmt.SupportedAlarm.")) {
		/* This is a special case in GPV request when only the parent is
		 * is present in the GPV request message, and no specific  set of
		 * parameter is requested, in this case all the parameter values
		 * for all the possible parents(in case of multi-object instances)
		 * should be fetched
		 */
		partial_parent_flag = OAM_TRUE;
		num_params = ARRSIZE(g_parameter_multi_instanse_FM_SUPP_GET_SET);

		max_multi_obj_cnt =
			oam_prov_req.fm_cntxt.SupportedAlarmNumberOfEntries;

		OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
				"FaultMgmt.SupportedAlarm.");
	}
	else if(!oam_strcmp(par_name,
				"InternetGatewayDevice.FaultMgmt.CurrentAlarm.")) {
		/* This is a special case in GPV request when only the parent is
		 * is present in the GPV request message, and no specific  set of
		 * parameter is requested, in this case all the parameter values
		 * for all the possible parents(in case of multi-object instances)
		 * should be fetched
		 */
		partial_parent_flag = OAM_TRUE;
		num_params = ARRSIZE(g_parameter_multi_instanse_FM_CURR_GET_SET);

		if(OAM_ONE == oam_prov_req.fm_cntxt.isCurrentRolled) {
			max_multi_obj_cnt = OAM_CURRENT_ALARM_MAX;
		}
		else {
			max_multi_obj_cnt = oam_prov_req.fm_cntxt.Current_List_Index;
		}

		OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
				"FaultMgmt.CurrentAlarm.");
	}
#ifdef OAM_SON_ENABLE
    /* spr_21013_fix_start */
	if(!oam_strcmp(par_name, "InternetGatewayDevice.Services.FAPService."
    /* spr_21013_fix_end */
				"CellConfig.LTE.RAN.NeighborListInUse.LTECell.")) {
		/* This is a special case in GPV request when only the parent is
		 * is present in the GPV request message, and no specific  set of
		 * parameter is requested, in this case all the parameter values
		 * for all the possible parents(in case of multi-object instances)
		 * should be fetched
		 */
		g_parameter_map_element = g_param_intra_rat_neigh_list_in_use;

		partial_parent_flag = OAM_TRUE;
		num_params = ARRSIZE(g_param_intra_rat_neigh_list_in_use);
		max_multi_obj_cnt = NRT_INFO(cell_config_idx).nr_list.
			intra_rat_nr_list_size;

		OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
				"intra-RAT NeighborListInUse.");
	}
	/* SPR-13586 START */
    /* spr_21013_fix_start */
	else if(oam_strstr(par_name, "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.")){
    /* spr_21013_fix_end */
		/* This is a special case in GPV request when only the parent is
		 * is present in the GPV request message, and no specific  set of
		 * parameter is requested, in this case all the parameter values
		 * for all the possible parents(in case of multi-object instances)
		 * should be fetched
		 */
		cell_config_idx = oam_get_son_neigh_list_in_use_idx(
				oam_prov_req.cell_cntxt.curr_cell_cid);
		if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
            /* SPR 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT ;
            OAM_FUN_EXIT_TRACE();
            /* SPR 21390 fix end */
            return OAM_FAILURE;
        }
		if(oam_strstr(par_name, "NeighborListInUse.InterRATCell.UMTS.")) {
			g_parameter_map_element = g_param_inter_rat_neigh_list_in_use;

			num_params = ARRSIZE(g_param_inter_rat_neigh_list_in_use);
			max_multi_obj_cnt = SON_PROV_REQ.neigh_list_in_use[cell_config_idx].inter_rat_umts_neigh_size;
			partial_parent_flag = OAM_TRUE;
			OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
					"inter-RAT UMTS NeighborListInUse.");
		}
		else if(oam_strstr(par_name, "NeighborListInUse.InterRATCell.GSM.")) {
			g_parameter_map_element = g_parameter_lte_inter_rat_geran_neighbor_list_in_use;

			num_params = ARRSIZE(g_parameter_lte_inter_rat_geran_neighbor_list_in_use);
            /*SPR 22442 Fix Start*/
			max_multi_obj_cnt = SON_PROV_REQ.neigh_list_in_use[cell_config_idx].inter_rat_gsm_neigh_size;
            /*SPR 22442 Fix End*/
			partial_parent_flag = OAM_TRUE;
			OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
					"inter-RAT GSM NeighborListInUse.");
		}
	}

	/* SPR-13586 END */
#endif

	if(partial_parent_flag) {
		if((num_params * max_multi_obj_cnt > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)) {
			OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
					"response are greater than the maximum limit allowed, "
					"sending an error response.");
			Char8 error_str[] =
				"Too many parameters in response. Please retry!";

			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
                    /*SPR 16795 Fixed Start*/
                    OAM_ERR_RESOURCES_EXCEEDED,
                    /*SPR 16795 Fixed End */
					OAM_VERSION, OAM_MODULE_ID, 
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					error_str, p_error_code);

			OAM_FUN_EXIT_TRACE();
			return OAM_SUCCESS;
		}
		else if(!max_multi_obj_cnt) {
			OAM_LOG(OAM, OAM_DETAILED, "The requested table is empty");
			return oam_construct_n_send_gpv_response((UInt8*)par_name,
					OAM_NULL,
					OAM_ZERO, trans_id,
					p_error_code,
					dst_module_id,
					OAM_ZERO, OAM_ZERO);
		}
	}
	/* SPR 14019 FIX Start */
#ifdef PERF_STATS
	/* SPR 14019 FIX End */
	if(oam_strncasecmp(par_name, "Show.PerfStats.PDCP", oam_strlen("Show.PerfStats.PDCP")) == OAM_ZERO)
	{
		if(Config_Flag == OAM_ONE)
		{
			oam_maintain_tcb(trans_id,OAM_TRANS_PDCP,msg_len,p_api_buf);
			if(OAM_FAILURE == oam_send_pdcp_get_perf_stats_req(OAM_MODULE_ID, trans_id, p_error_code))
			{
				OAM_LOG(OAM, OAM_DETAILED, "Sending PDCP_GET_PERF_STATS_REQ failed, error = %p", p_error_code);
				OAM_FUN_ENTRY_TRACE();
				return OAM_FAILURE;
			}
		}
		else
		{
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ERR_REQUEST_DENIED,
					OAM_VERSION, OAM_MODULE_ID,
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					"Layers not configured", p_error_code);
		}

		return OAM_SUCCESS;
	}
	/* SPR 14019 FIX Start */
#endif
	/* SPR 14019 FIX End */

	if(oam_strncasecmp(par_name, "Show.CellStatus.RRC", oam_strlen("Show.CellStatus.RRC")) == OAM_ZERO)
	{
		oam_rrc_get_cell_status_req_t rrc_oam_get_cell_status_req;
		oam_memset(&rrc_oam_get_cell_status_req, OAM_ZERO, sizeof(rrc_oam_get_cell_status_req));
		rrc_oam_get_cell_status_req.cell_index = oam_prov_req.cell_cntxt.curr_cell_cid;

		if (OAM_SUCCESS == oam_rrc_il_send_rrc_oam_get_cell_status_req(&rrc_oam_get_cell_status_req,
					OAM_MODULE_ID,RRC_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid))
		{
			OAM_LOG(OAM,OAM_DETAILED,
					"oam_rrc_il_send_rrc_oam_get_cell_status_req returned success");
			/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
						OAM_TRANS_RRC,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                /* SPR 21390 fix start */
                *p_error_code = OAM_INTERNAL_ERROR ;
                OAM_FUN_EXIT_TRACE();
                /* SPR 21390 fix end */
                return OAM_FAILURE;
            }
#endif
			/* SPR 9620 CHANGE END */    
		}
		else
		{
			OAM_LOG(OAM,OAM_ERROR,"Send RRC_OAM_GET_CELL_STATUS_REQ failure");
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ZERO, OAM_VERSION,
					OAM_MODULE_ID, dst_module_id,
					trans_id, OAM_ZERO,
					OAM_ZERO,
					"Sendto layer failed",
					p_error_code);
		}
		return OAM_SUCCESS;
	}

	if(oam_strncasecmp(par_name, "Show.UeStatus.RRC", oam_strlen("Show.UeStatus.RRC")) == OAM_ZERO)
	{
		oam_return_et                      ret_val = OAM_SUCCESS;
		rrc_oam_get_ue_status_req_t        rrc_oam_get_ue_status_req;
		oam_memset(&rrc_oam_get_ue_status_req, OAM_ZERO, sizeof(rrc_oam_get_ue_status_req));
		rrc_oam_get_ue_status_req.cell_index = oam_prov_req.cell_cntxt.curr_cell_cid;
		ret_val = oam_rrc_il_send_rrc_oam_get_ue_status_req(&rrc_oam_get_ue_status_req,
				OAM_MODULE_ID,RRC_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid);/*Composer_Parser Changes*/

		if (OAM_SUCCESS == ret_val)
		{
			OAM_LOG(OAM,OAM_DETAILED,
					"oam_rrc_il_send_rrc_oam_get_ue_status_req returned success");
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
						OAM_TRANS_RRC,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                /* SPR 21390 fix start */
                *p_error_code = OAM_INTERNAL_ERROR ;
                OAM_FUN_EXIT_TRACE();
                /* SPR 21390 fix end */
                return OAM_FAILURE;
            }
#endif
		}
		else
		{
			OAM_LOG(OAM,OAM_ERROR,"Send RRC_OAM_GET_UE_STATUS_REQ failure");
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ZERO, OAM_VERSION,
					OAM_MODULE_ID, dst_module_id,
					trans_id, OAM_ZERO,
					OAM_ZERO,
					"Sendto layer failed",
					p_error_code);
		}
		return OAM_SUCCESS;
	}

	if(oam_strncasecmp(par_name, "Show.UeSINR.MAC", oam_strlen("Show.UeSINR.MAC")) == OAM_ZERO)
	{
		oam_length_t parameter_length = OAM_ZERO;
		UInt16 parameter_name_length = OAM_ZERO;
		UInt8 Parameter_Name[MAX_PARAMETER_NAME_LENGTH]  ;
		char *temp = OAM_NULL;
		void *p_api_buf_temp = p_api_buf;
		UInt16 values = OAM_ZERO;
		UInt16 total_len = OAM_ZERO;
		char Parent_Name[MAX_PARENT_NAME_LENGTH] ;
		oam_return_et send_return_status = OAM_SUCCESS;
		oam_length_t Parent_length = OAM_ZERO;

		UInt16 trans_id = get_word_from_header((UInt8*)(p_api_buf_temp) +OAM_ZERO);
		p_api_buf_temp += OAM_MGMT_INTF_HEADER_SIZE;
		total_len = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
		Parent_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_SIX);
		OAM_LOG(OAM,OAM_DETAILED,"Total set_parameter_values length  :: %d",
				total_len);

		oam_memset(&Parent_Name, OAM_ZERO, MAX_PARENT_NAME_LENGTH);
		oam_memcpy(&Parent_Name,(p_api_buf_temp + OAM_EIGHT),Parent_length);
		OAM_LOG(OAM, OAM_DETAILED, "Parent Name: %s", Parent_Name);

		p_api_buf_temp += (Parent_length + OAM_EIGHT);

		parameter_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
		OAM_LOG(OAM,OAM_DETAILED,"parameter length  ::%d",
				parameter_length);
		parameter_name_length = parameter_length -OAM_FOUR;
		OAM_LOG(OAM,OAM_DETAILED,"parameter name length  :: %d",
				parameter_name_length);

		oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH);
		oam_memcpy(&Parameter_Name,(p_api_buf_temp +OAM_FOUR),parameter_name_length);

		temp = (char *)Parameter_Name;
		OAM_LOG(OAM, OAM_DETAILED, "parameter_name temp : %s",temp );
		values=oam_atoi(temp);
		send_return_status = oam_mac_send_mac_ue_sinr_ta_req(values,
				src_module_id,
				trans_id,
				p_error_code);

		if (OAM_FAILURE == send_return_status)
		{
			OAM_LOG(OAM,OAM_ERROR,
					"Error in function :oam_mac_send_mac_ue_sinr_ta_req"
					" error code :%d",*p_error_code);
			return OAM_FAILURE;
		}
		else{
			/* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_MAC,
						OAM_TRANS_MAC,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                /* SPR 21390 fix start */
                *p_error_code = OAM_INTERNAL_ERROR ;
                OAM_FUN_EXIT_TRACE();
                /* SPR 21390 fix end */
                return OAM_FAILURE; 
            }
#endif
			/* SPR 9620 CHANGE END */
		}
		return OAM_SUCCESS;
	}
	if(oam_strncasecmp(par_name, "UeStatus.MAC", oam_strlen("UeStatus.MAC")) == OAM_ZERO)
	{
		oam_length_t parameter_length = OAM_ZERO;
		UInt16 parameter_name_length = OAM_ZERO;
		UInt8 Parameter_Name[MAX_PARAMETER_NAME_LENGTH]  ;
		char *temp = OAM_NULL;
		void *p_api_buf_temp = p_api_buf;
		char values;
		UInt16 total_len = OAM_ZERO;
		char Parent_Name[MAX_PARENT_NAME_LENGTH] ;
		oam_return_et send_return_status = OAM_SUCCESS;;
		oam_length_t Parent_length = OAM_ZERO;
		UInt16 trans_id = get_word_from_header((UInt8*)(p_api_buf_temp) +OAM_ZERO);
		p_api_buf_temp += OAM_MGMT_INTF_HEADER_SIZE;
		total_len = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
		Parent_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_SIX);
		OAM_LOG(OAM,OAM_DETAILED,"Total set_parameter_values length  :: %d",total_len);
		oam_memset(&Parent_Name, OAM_ZERO, MAX_PARENT_NAME_LENGTH);
		oam_memcpy(&Parent_Name,(p_api_buf_temp + OAM_EIGHT),Parent_length);
		OAM_LOG(OAM, OAM_DETAILED, "Parent Name: %s", Parent_Name);

		oam_mac_ue_status_req_t mac_ue_status_req;

		p_api_buf_temp += (Parent_length + OAM_EIGHT);

		parameter_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
		OAM_LOG(OAM,OAM_DETAILED,"parameter length  ::%d",
				parameter_length);
		parameter_name_length = parameter_length -OAM_FOUR;
		OAM_LOG(OAM,OAM_DETAILED,"parameter name length  :: %d",
				parameter_name_length);

		oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH);
		oam_memcpy(&Parameter_Name,(p_api_buf_temp +OAM_FOUR),parameter_name_length);

		/*Coverity fix Comments*/
		temp = (char *)Parameter_Name;
		OAM_LOG(OAM, OAM_DETAILED, "Parameter_Name temp : %s",temp );
		values=oam_atoi(temp);

		mac_ue_status_req.isUeIdPresent = OAM_TRUE; /* SPR_11057_FIX */
		mac_ue_status_req.ueId = values;

		OAM_LOG(OAM,OAM_DETAILED, "MAC_OAM_GET_UE_STATUS_REQ: length %u", trans_id);

		send_return_status = oam_mac_get_ue_status_req(&mac_ue_status_req,
				src_module_id,
				trans_id,
				p_error_code);


		if (OAM_FAILURE == send_return_status)
		{
			OAM_LOG(OAM,OAM_ERROR,
					"Error in function :oam_mac_send_ue_status_req"
					" error code :%d",*p_error_code);
			return OAM_FAILURE;
		}
		return OAM_SUCCESS;
	}



	else if(oam_strncasecmp(par_name, "InternetGatewayDevice.FAP.PerfMgmt.Config", oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config")) == OAM_ZERO)
	{
		oam_config.config_param_trans_id = trans_id;
		oam_config.config_param_bit_mask = OAM_ZERO;  
		/*Bug Fix */
		oam_config.config_des_module_id = dst_module_id ;  
		config_flag = OAM_ONE; 

	}
	else if(oam_strncasecmp(par_name, "InternetGatewayDevice.FAP.PerfMgmt", oam_strlen("InternetGatewayDevice.FAP.PerfMgmt")) == OAM_ZERO)
	{

		return oam_send_ConfigNumberOfEntries_gpv_resp(trans_id,dst_module_id); 
	} 

	/*Code addition for stats/KPI */
	else if(oam_strncasecmp(par_name, "Show.Stats.L2.MAC", oam_strlen("Show.Stats.L2.MAC")) == OAM_ZERO)
	{
		OAM_LOG(OAM,OAM_DETAILED,"SHOW_STATS_L2_MAC");
#ifndef OAM_UT_FRAMEWORK
		oam_maintain_tcb(trans_id,OAM_TRANS_MAC,msg_len,p_api_buf);
#endif
		oam_send_mac_get_stats_req(src_module_id,trans_id,p_error_code);
		return OAM_SUCCESS;

	}
	else if (oam_strncasecmp(par_name, "Show.Stats.L2.RLC", oam_strlen("Show.Stats.L2.RLC")) == OAM_ZERO)
	{
		OAM_LOG(OAM,OAM_DETAILED,"OAM_GET_L2_RLC_STATS_REQ");
#ifndef OAM_UT_FRAMEWORK
		oam_maintain_tcb(trans_id,OAM_TRANS_RLC,msg_len,p_api_buf);
#endif
		oam_send_get_rlc_stats_req(src_module_id,trans_id,p_error_code);
		return OAM_SUCCESS;
	}
	else if (oam_strncasecmp(par_name, "Show.Stats.L3.S1AP", oam_strlen("Show.Stats.L3.S1AP")) == OAM_ZERO)
	{
#ifndef OAM_UT_FRAMEWORK      
		oam_maintain_tcb(trans_id,OAM_TRANS_S1AP,msg_len,p_api_buf);
#endif
		oam_s1ap_send_stats_ind(src_module_id,trans_id,p_error_code);
		OAM_LOG(OAM,OAM_DETAILED,"SHOW_STATS_L3_S1AP");
		return OAM_SUCCESS;
	}
/* LWA changes end*/

	else if (oam_strncasecmp(par_name, "Show.Stats.L2.EGTPU", oam_strlen("Show.Stats.L2.EGTPU")) == OAM_ZERO)
	{
		OAM_LOG(OAM,OAM_DETAILED,"EGTPU");
	}


	else if (oam_strncasecmp(par_name, "Show.Stats.L2.PDCP", oam_strlen("Show.Stats.L2.PDCP")) == OAM_ZERO)
	{
		OAM_LOG(OAM,OAM_DETAILED,"SHOW_STATS_L2_PDCP");
#ifndef OAM_UT_FRAMEWORK
		oam_maintain_tcb(trans_id,OAM_TRANS_PDCP,msg_len,p_api_buf);
#endif
		oam_send_get_pdcp_stats_req(src_module_id,trans_id,p_error_code);
		return OAM_SUCCESS;

	}

	else if (oam_strncasecmp(par_name, "Show.KPI.MAC", oam_strlen("Show.KPI.MAC")) == OAM_ZERO)
	{
		oam_mac_get_KPI_stats_req_t mac_get_kpi_stats_req;
		mac_get_kpi_stats_req.resetStats = OAM_ZERO;
		mac_get_kpi_stats_req.kpiToReportBitMap = g_mac_kpi_stats_ind_params_name.bitmask;/* SPR 17949 */
		if(Config_Flag == OAM_ONE)
		{
			if(OAM_FAILURE == oam_mac_get_kpi_stats_req(
						&mac_get_kpi_stats_req,OAM_MODULE_ID, trans_id, p_error_code))
			{
				OAM_LOG(OAM,OAM_ERROR,"Error in oam_mac_get_kpi_stats_req function with error code %d",
						*p_error_code);
				return OAM_FAILURE;

			}
			else{
#ifndef OAM_UT_FRAMEWORK
				if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_MAC,
							OAM_TRANS_MAC,msg_len,p_api_buf))
				{
					OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                    /* SPR 21390 fix start */
                    *p_error_code = OAM_INTERNAL_ERROR ;
                    OAM_FUN_EXIT_TRACE();
                    /* SPR 21390 fix end */
                    return OAM_FAILURE;
                }
#endif
			} 
		}
		else
		{
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ERR_REQUEST_DENIED,
					OAM_VERSION, OAM_MODULE_ID,
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					"Layers not configured", p_error_code);
		}
		return OAM_SUCCESS;

	}
	else if (oam_strncasecmp(par_name, "Show.KPI.PDCP", oam_strlen("Show.KPI.PDCP")) == OAM_ZERO)
	{
		oam_pdcp_get_KPI_stats_req_t pdcp_get_kpi_stats_req;

		pdcp_get_kpi_stats_req.kpiToGetBitMap = OAM_PDCP_KPIBITMAP; 
		pdcp_get_kpi_stats_req.resetStats = OAM_ZERO; 
		/* Calling PDCP Get KPI Stats Function Call */
		if(Config_Flag == OAM_ONE)
		{

			if (OAM_FAILURE == oam_pdcp_get_kpi_stats_req(
						&pdcp_get_kpi_stats_req, OAM_MODULE_ID, trans_id, p_error_code))
			{
				OAM_LOG(OAM,OAM_ERROR,"Error in oam_pdcp_get_kpi_stats_req function with error code %d",
						*p_error_code);
				return OAM_FAILURE;
			}
			else{
#ifndef OAM_UT_FRAMEWORK
				if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_PDCP,
							OAM_TRANS_PDCP,msg_len,p_api_buf))
				{
					OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                    /* SPR 21390 fix start */
		            *p_error_code = OAM_INTERNAL_ERROR ;
		            OAM_FUN_EXIT_TRACE();
                    /* SPR 21390 fix end */
					return OAM_FAILURE;
				}
#endif
			}    
		}
		else
		{
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ERR_REQUEST_DENIED,
					OAM_VERSION, OAM_MODULE_ID,
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					"Layers not configured", p_error_code);
		}
		return OAM_SUCCESS;
	}
	else if (oam_strncasecmp(par_name, "Show.KPI.RRC", oam_strlen("Show.KPI.RRC")) == OAM_ZERO)
	{
		cli_flag = OAM_TRUE;
		oam_rrc_get_cell_stats_req_t oam_rrc_get_cell_stats_req;

		/* SPR_12955_FIXES */

		oam_memset(&oam_rrc_get_cell_stats_req,OAM_ZERO,sizeof(oam_rrc_get_cell_stats_req_t));
		oam_rrc_get_cell_stats_req.cell_index = oam_prov_req.cell_cntxt.curr_cell_cid  ;  
		oam_rrc_get_cell_stats_req.reset_stats = OAM_ZERO;  

		oam_rrc_get_cell_stats_req.bitmask = OAM_ZERO;
		oam_rrc_get_cell_stats_req.bitmask = oam_rrc_get_cell_stats_req.bitmask | RRC_OAM_STATISTICS_ALL_STATS_PRESENT; 

		if(Config_Flag == OAM_ONE)
		{
			/* SPR_12955_FIXES */
			OAM_LOG(OAM, OAM_DETAILED, "Trans_id = %d for RRC_OAM_GET_CELL_STATUS_REQ", trans_id);	
			if (OAM_FAILURE == oam_rrc_il_send_rrc_oam_get_cell_stats_req(
						&oam_rrc_get_cell_stats_req,
						src_module_id, RRC_MODULE_ID,
						trans_id,
						oam_prov_req.cell_cntxt.curr_cell_cid))
			{
				OAM_LOG(OAM,OAM_ERROR,"Error in oam_rrc_il_send_rrc_oam_get_cell_stats_req function with error code %d",
						*p_error_code);
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			else{
				/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
				if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
							OAM_TRANS_RRC,msg_len,p_api_buf))
				{
					OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
                    /* SPR 21390 fix start */
                    *p_error_code = OAM_INTERNAL_ERROR ;
                    OAM_FUN_EXIT_TRACE();
                    /* SPR 21390 fix end */
                    return OAM_FAILURE;
                }
#endif
				/* SPR 9620 CHANGE END */
			} 
			pm_rrc_reset.flag = OAM_ZERO;
		}
		else
		{
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ERR_REQUEST_DENIED,
					OAM_VERSION, OAM_MODULE_ID,
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					"Layers not configured", p_error_code);


		}
		return OAM_SUCCESS;


	}
	else if (oam_strncasecmp(par_name, "Show.KPI.RRM", oam_strlen("Show.KPI.RRM")) == OAM_ZERO)
	{
		rrm_oam_get_kpi_req_t rrm_oam_get_kpi_req;
		UInt8 kpi_count = OAM_ZERO;
		oam_memset(&rrm_oam_get_kpi_req,OAM_ZERO,sizeof(rrm_oam_get_kpi_req_t));

		/*Filling rrm_oam_get_kpi_req_t KPI Sturcture */
		/*Bitmask is for future purpose and all params are mandatory so filling one*/
		rrm_oam_get_kpi_req.bitmask = OAM_ONE;

		/* Filling cell id */
		oam_memcpy(&rrm_oam_get_kpi_req.cell_id,&RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id,
				sizeof(rrm_oam_eutran_global_cell_id_t));

		/*Filling reset value*/
		rrm_oam_get_kpi_req.reset = OAM_FALSE;

		/* Enabling all 32 KPI out of 64 KPI at present */
		for( kpi_count= OAM_ZERO; kpi_count < RRM_MAX_KPI - RRM_FOUR; kpi_count++)
		{ 
			rrm_oam_get_kpi_req.kpi_to_report.bitmap[kpi_count] = OAM_ALL_8_BIT_SET;
		}
		/*SPR 11426 FIX Start*/
		rrm_oam_get_kpi_req.kpi_to_report.bitmap[kpi_count] = OAM_THREE;
		/*SPR 11426 FIX End*/
		/* BUG 8940 FIX START*/
		if(Config_Flag == OAM_ONE)
		{
#ifndef OAM_UT_FRAMEWORK
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
#endif
			if(OAM_FAILURE == oam_rrm_send_rrm_oam_get_kpi_req(&rrm_oam_get_kpi_req,
						src_module_id, 
						RRM_MODULE_ID,
						trans_id,
						oam_prov_req.cell_cntxt.curr_cell_cid))/*Composer_Parser Changes*/
			{       
				OAM_LOG(OAM,OAM_ERROR,"Error in sending RRM_OAM_GET_KPI_REQ, cell context = %d",
                        oam_prov_req.cell_cntxt.curr_cell_cid);
                /* SPR 21390 fix start */
                *p_error_code = OAM_INTERNAL_ERROR ;
                /* SPR 21390 fix end */
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}       
		}
		else
		{
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ERR_REQUEST_DENIED,
					OAM_VERSION, OAM_MODULE_ID,
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					"Layers not configured", p_error_code);


		}
		/* BUG 8940 FIX END*/
		pm_rrm_reset.flag = OAM_ZERO;
		return OAM_SUCCESS;
	}
    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    else if (!oam_strcmp(par_name,
                "MBMS.Show.SessionList"))
    {
        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
        {
            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mce_link_status)
        {
            *p_error_code = OAM_M2AP_MCE_LINK_DOWN;
            OAM_LOG(OAM, OAM_ERROR, "M2AP-MCE link is down");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        OAM_LOG(OAM, OAM_DETAILED, "M2AP Session Detail Req.");
        retVal = oam_m2ap_send_session_details_req(OAM_MODULE_ID,
                trans_id,
                p_error_code);
        if (OAM_SUCCESS == retVal)
        {
            OAM_LOG(OAM, OAM_DETAILED, "Successfully sent Session Detail Req");
#ifndef OAM_UT_FRAMEWORK
            oam_maintain_tcb(trans_id, OAM_TRANS_M2AP, msg_len, p_api_buf);
#endif
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR, "Failed to send Session Detail Req with"
                    " err code:%d", p_error_code);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        OAM_FUN_EXIT_TRACE();
        return retVal;

    }
    else if (!oam_strcmp(par_name, "Show.Stats.L3.M2AP"))
    {
        oam_m2ap_get_stats_req.cell_index =
            oam_prov_req.cell_cntxt.curr_cell_cid;

        /* SPR 18056 FIX Start */
        retVal = oam_m2ap_il_send_oam_m2ap_get_stat_req(
                &oam_m2ap_get_stats_req,
                src_module_id, RRC_MODULE_ID,
                trans_id,
                oam_prov_req.cell_cntxt.curr_cell_cid);

        if (OAM_FAILURE == retVal)
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Error in sending OAM_M2AP_GET_STAT_REQ");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else
        {
#ifndef OAM_UT_FRAMEWORK
            retVal = oam_maintain_tcb(trans_id,
                    OAM_TRANS_M2AP,
                    msg_len,
                    p_api_buf);
            if (OAM_FAILURE == retVal)
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
#endif
        }
        /* SPR 18056 FIX End */

        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;
    }
    else if (!oam_strcmp(par_name,
                "Show.Log.Level"))
    {
        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
        {
            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mce_link_status)
        {
            *p_error_code = OAM_M2AP_MCE_LINK_DOWN;
            OAM_LOG(OAM, OAM_ERROR, "M2AP-MCE link is down");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        OAM_LOG(OAM, OAM_DETAILED, "M2AP Get LogLevel Req.");
        retVal = oam_m2ap_send_get_log_level_req(OAM_MODULE_ID,
                trans_id,
                p_error_code);
        if (OAM_SUCCESS == retVal)
        {
            OAM_LOG(OAM, OAM_DETAILED, "Successfully sent M2AP Get LogLevel Req");
#ifndef OAM_UT_FRAMEWORK
            oam_maintain_tcb(trans_id, OAM_TRANS_M2AP, msg_len, p_api_buf);
#endif
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR, "Failed to send M2AP Get LogLevel Req with"
                    " err code:%d", p_error_code);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        OAM_FUN_EXIT_TRACE();
        return retVal;

    }
#endif
    /* EMBMS Changes End */

	/*SPR 10451 start*/ 
	else if(oam_strncasecmp((char *)par_name,
				"InternetGatewayDevice.FaultMgmt.CurrentAlarm",
				oam_strlen("InternetGatewayDevice.FaultMgmt.CurrentAlarm"))
			== OAM_ZERO)
	{
		g_parameter_map_element = g_parameter_multi_instanse_FM_CURR_GET_SET;
		OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt CurrentAlarm Table selected.");
	}
	else if(oam_strncasecmp((char *)par_name,
				"InternetGatewayDevice.FaultMgmt.ExpeditedEvent",
				oam_strlen("InternetGatewayDevice.FaultMgmt.ExpeditedEvent"))
			== OAM_ZERO)
	{

		g_parameter_map_element = g_parameter_multi_instanse_FM_EXPD_GET_SET;
		OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt ExpeditedEvent Table selected.");
	}

	else if(oam_strncasecmp((char *)par_name,
				"InternetGatewayDevice.FaultMgmt.QueuedEvent",
				oam_strlen("InternetGatewayDevice.FaultMgmt.QueuedEvent"))
			== OAM_ZERO)
	{
		g_parameter_map_element = g_parameter_multi_instanse_FM_QUED_GET_SET;
		OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt QueuedEvent Table selected.");
	}

	else if(oam_strncasecmp((char *)par_name,
				"InternetGatewayDevice.FaultMgmt.HistoryEvent",
				oam_strlen("InternetGatewayDevice.FaultMgmt.HistoryEvent"))
			== OAM_ZERO)
	{
		g_parameter_map_element = g_parameter_multi_instanse_FM_HIST_GET_SET;
		OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt HistoryEvent Table selected.");
	}

	else if(oam_strncasecmp((char *)par_name,
				"InternetGatewayDevice.FaultMgmt.SupportedAlarm",
				oam_strlen("InternetGatewayDevice.FaultMgmt.SupportedAlarm"))
			== OAM_ZERO)
	{
		g_parameter_map_element = g_parameter_multi_instanse_FM_SUPP_GET_SET;
		OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt SupportedAlarm Table selected.");
	}

	/*SPR 10451 end*/


	/* increase the size of response message by parent node length */
    /*SPR 15363 START */ //CSR #102101
    if (!max_multi_obj_cnt)
    { 
        max_multi_obj_cnt = 1;
    } 
    /*SPR 15363 END */
    resp_len += par_name_len + OAM_EIGHT;
    resp_payload_len = par_name_len + OAM_EIGHT;
	temp_payload = oam_msg_mem_get(resp_payload_len +
    /* SPR 14630 Fix Start */ 
            ((num_params * (OAM_FOUR + PARAM_VAL_PAIR_MAX_LEN)) * max_multi_obj_cnt));
    /* SPR 14630 Fix End */ 
	if(OAM_NULL == temp_payload) 
	{
        OAM_LOG(OAM,OAM_ERROR, "Memory allocation to temp_payload failed");
		*p_error_code = OAM_MALLOC_FAIL;
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}

    /* SPR 14630 Fix Start */ 
    oam_memset(temp_payload, OAM_ZERO ,(resp_payload_len +
            (num_params * (OAM_FOUR + PARAM_VAL_PAIR_MAX_LEN))*max_multi_obj_cnt)); 
    /* SPR 14630 Fix End */ 
	/*encode the parent info in payload. Note that the message length
	  field in parent info is not correct for the response message here
	  and will be encoded later. */
	oam_memcpy(temp_payload, p_api_buf + OAM_MGMT_INTF_HEADER_SIZE,
			par_name_len + OAM_EIGHT);

	if (oam_strncasecmp(par_name, "Show.Stats.L2.EGTPU", oam_strlen("Show.Stats.L2.EGTPU")) == OAM_ZERO)
	{
		oam_length_t parameter_length = OAM_ZERO;
		UInt8 Number_of_parameters = OAM_TWO; /* coverity_fix */
		UInt16 parameter_name_length = OAM_ZERO;
		UInt8 Parameter_Name[2][MAX_PARAMETER_NAME_LENGTH]  ;
        /* SPR 21030 Fix Start */
        g_egtpu_trans_id = trans_id;
        /* SPR 21030 Fix End */

		OAM_LOG(OAM,OAM_DETAILED,"Number of parameters to set  :: %d",Number_of_parameters);

		for(loop=OAM_ZERO; loop < Number_of_parameters ; loop++) /* coverity_fix */
		{
			parameter_length = get_word_from_header((UInt8*)(p_temp_buf)) ;
			p_temp_buf= p_temp_buf + OAM_TWO + OAM_TWO;
			OAM_LOG(OAM,OAM_DETAILED," parameter length  ::%d",
					parameter_length);
			parameter_name_length = parameter_length - OAM_TWO - OAM_TWO - OAM_ONE ;
			OAM_LOG(OAM,OAM_DETAILED," parameter name length  :: %d",
					parameter_name_length);

			oam_memset(&Parameter_Name[loop],OAM_ZERO,MAX_PARAMETER_NAME_LENGTH);
			oam_memcpy(&Parameter_Name[loop],(p_temp_buf),parameter_name_length);

			p_temp_buf = p_temp_buf + parameter_name_length + OAM_ONE ;

		}


		oam_maintain_tcb(trans_id,OAM_TRANS_EGTPU,msg_len,p_api_buf);
		oam_mem_free(temp_payload, p_error_code);
		return  oam_get_egtpustats((char *)Parameter_Name[0],(char *)Parameter_Name[1],g_egtpu_trans_id);
	} 

    /* SPR 24015 changes start */
    /* SPR 24015 changes end */
    /*spr 22474 start*/
	if((oam_strncasecmp(par_name, "Debug.Get.L2.MAC", oam_strlen("Debug.Get.L2.MAC")) == OAM_ZERO) ||
	   (oam_strncasecmp(par_name, "Debug.Get.L2.RLC", oam_strlen("Debug.Get.L2.RLC")) == OAM_ZERO) ||
	   (oam_strncasecmp(par_name, "Debug.Get.L2.PDCP", oam_strlen("Debug.Get.L2.PDCP")) == OAM_ZERO) ||
	   (oam_strncasecmp(par_name, "Debug.Get.L2.EGTPU", oam_strlen("Debug.Get.L2.EGTPU")) == OAM_ZERO) ||
       (oam_strncasecmp(par_name, "Debug.Get.L3.S1AP", oam_strlen("Debug.Get.L3.S1AP")) == OAM_ZERO) ||
       (oam_strncasecmp(par_name, "Debug.Get.L3.X2AP", oam_strlen("Debug.Get.L3.X2AP")) == OAM_ZERO) ||
       (oam_strncasecmp(par_name, "Debug.Get.L3.RRC", oam_strlen("Debug.Get.L3.RRC")) == OAM_ZERO) ||
       (oam_strncasecmp(par_name, "Debug.Get.RRM", oam_strlen("Debug.Get.RRM")) == OAM_ZERO) ||
       (oam_strncasecmp(par_name, "Debug.Get.SON", oam_strlen("Debug.Get.SON")) == OAM_ZERO) ||
       (oam_strncasecmp(par_name, "Debug.Get.OAM.OAM", oam_strlen("Debug.Get.OAM.OAM")) == OAM_ZERO) ||
       (oam_strncasecmp(par_name, "Debug.Get.OAM.TR069", oam_strlen("Debug.Get.OAM.TR069")) == OAM_ZERO))
	{
		oam_length_t parameter_length = OAM_ZERO;
		UInt16 parameter_name_length = OAM_ZERO;
		UInt8 Parameter_Name[MAX_PARAMETER_NAME_LENGTH]  ;

		parameter_length = get_word_from_header((UInt8*)(p_temp_buf)) ;
		p_temp_buf = p_temp_buf + OAM_TWO + OAM_TWO;
		parameter_name_length = parameter_length - OAM_TWO - OAM_TWO - OAM_ONE ;

		oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH);
		oam_memcpy(&Parameter_Name,(p_temp_buf),parameter_name_length);
        UInt16 debugType = oam_atoi((const char *) Parameter_Name);
		p_temp_buf = p_temp_buf + parameter_name_length + OAM_ONE;

		oam_maintain_tcb(trans_id, OAM_TRANS_MAC, msg_len, p_api_buf);
		oam_mem_free(temp_payload, p_error_code);

	    if (oam_strncasecmp(par_name, "Debug.Get.L2.MAC", oam_strlen("Debug.Get.L2.MAC")) == OAM_ZERO)
        {
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET L2 MAC parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);

	    	return oam_send_mac_get_debug_info_req(debugType, src_module_id, trans_id);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.L2.RLC", oam_strlen("Debug.Get.L2.RLC")) == OAM_ZERO)
        {
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET L2 RLC parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);

	    	return oam_send_rlc_get_debug_info_req(debugType, src_module_id, trans_id);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.L2.PDCP", oam_strlen("Debug.Get.L2.PDCP")) == OAM_ZERO)
        {
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET L2 PDCP parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);

	    	return oam_send_pdcp_get_debug_info_req(debugType, src_module_id, trans_id);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.L2.EGTPU", oam_strlen("Debug.Get.L2.EGTPU")) == OAM_ZERO)
        {
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET L2 EGTPU parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);

	    	return oam_send_egtpu_get_debug_info_req(debugType, src_module_id, trans_id);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.L3.S1AP", oam_strlen("Debug.Get.L3.S1AP")) == OAM_ZERO)
        {
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET L3 S1AP parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);

/*to be generated using pup tool*/
//	    	return oam_send_s1ap_get_debug_info_req(debugType, src_module_id, trans_id);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.L3.X2AP", oam_strlen("Debug.Get.L3.X2AP")) == OAM_ZERO)
        {
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET L3 X2AP parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);

/*to be generated using pup tool*/
	    	//return oam_send_x2ap_get_debug_info_req(debugType, src_module_id, trans_id);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.L3.RRC", oam_strlen("Debug.Get.L3.RRC")) == OAM_ZERO)
        {
            rrc_oam_get_debug_info_req_t rrc_oam_get_debug_info_req;
            oam_memset(&rrc_oam_get_debug_info_req,0,sizeof(rrc_oam_get_debug_info_req_t));
            rrc_oam_get_debug_info_req.debug_type = debugType;
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET L3 RRC parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);
        	rrc_oam_get_debug_info_req.debug_type = debugType;
	    	return oam_rrc_il_send_rrc_oam_get_debug_info_req(&rrc_oam_get_debug_info_req, src_module_id, RRC_MODULE_ID, trans_id, cell_config_idx);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.RRM", oam_strlen("Debug.Get.RRM")) == OAM_ZERO)
        {
            rrm_oam_get_debug_info_req_t rrm_oam_get_debug_info_req;
            oam_memset(&rrm_oam_get_debug_info_req,0,sizeof(rrm_oam_get_debug_info_req_t));
            rrm_oam_get_debug_info_req.debug_type = debugType;
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET RRM parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);

/*to be generated using pup tool*/
	    	return oam_rrm_send_rrm_oam_get_debug_info_req(&rrm_oam_get_debug_info_req, src_module_id, RRM_MODULE_ID, trans_id, cell_config_idx);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.SON", oam_strlen("Debug.Get.SON")) == OAM_ZERO)
        {
            son_oam_get_debug_info_req_t son_oam_get_debug_info_req;
            oam_memset(&son_oam_get_debug_info_req,0,sizeof(son_oam_get_debug_info_req_t));
            son_oam_get_debug_info_req.debug_type = debugType;
		    OAM_LOG(OAM,OAM_DETAILED,"DEBUG GET SON parameter length:%d parameter name:%s length:%d debugType:%u",
					parameter_length, Parameter_Name, parameter_name_length, debugType);

	    	return oam_son_send_son_oam_get_debug_info_req(&son_oam_get_debug_info_req, src_module_id, SON_MODULE_ID, trans_id, cell_config_idx);
        }
	    else if (oam_strncasecmp(par_name, "Debug.Get.OAM", oam_strlen("Debug.Get.OAM")) == OAM_ZERO)
        {
            oam_get_debug_info_req_t oam_get_debug_info_req;
            oam_get_debug_info_resp_t oam_get_debug_info_resp;
            UInt8 **str_arr = OAM_NULL;/* stores the strings[line][text] to be printed */
            UInt8 size_x_1 = OAM_ZERO; /* Counts the number of strings to be printed */
            oam_MemPoolStats oam_csplMemPoolStats;
            oam_memset(&oam_get_debug_info_req,0,sizeof(oam_get_debug_info_req_t));
            oam_memset(&oam_get_debug_info_resp,0,sizeof(oam_get_debug_info_resp_t));
            oam_memset(&oam_csplMemPoolStats,0,sizeof(oam_MemPoolStats));
            oam_get_debug_info_req.debug_type = debugType;
            if(debugType == GET_MEM_POOL_STATS)
            {
                UInt32 allocBufMemPool = 0, nbufMemPool = 0, peakBufMemPool = 0;
                UInt32 poolIndex = 0, bufSize = 0, validPool = 0;
                oam_get_debug_info_resp.bitmask |= OAM_DEBUG_GET_MEM_POOL_PRESENT;
                oam_get_debug_info_resp.response = OAM_SUCCESS;
                /* Get the mempool stats */
                for( poolIndex = 0,bufSize = MINBUF; poolIndex < NVARMEMPOOL; poolIndex++, bufSize *= 2)
                {
                    allocBufMemPool = nbufMemPool = peakBufMemPool = 0;
                    nbufMemPool = getMemPoolStatsInShm(poolIndex, &allocBufMemPool, &peakBufMemPool );
                    /* Send only pools which has non zero total buffers */
                    if (nbufMemPool)
                    {
                        oam_csplMemPoolStats.stats[validPool].bufSize = bufSize;
                        oam_csplMemPoolStats.stats[validPool].numOfBuf = nbufMemPool;
                        oam_csplMemPoolStats.stats[validPool].numOfAllocBuf = allocBufMemPool;
                        oam_csplMemPoolStats.stats[validPool].numOfPeakBuf = peakBufMemPool;
                        validPool++;
                    }
                }
                /* Set the end marker as bufSize to 0 so that OAM is aware where the status ends in array */
                if (validPool < NVARMEMPOOL)
                {
                    oam_csplMemPoolStats.stats[validPool].bufSize = 0;
                }
                oam_memcpy(&oam_get_debug_info_resp.csplMemPoolStats,&oam_csplMemPoolStats,sizeof(oam_MemPoolStats));
                size_x_1 = oam_get_oam_debug_info_prints(&oam_get_debug_info_resp,&str_arr);


                if (size_x_1)
                {
		            *p_error_code = NO_ERROR;
                    oam_construct_n_send_gpv_response((UInt8 *)"Debug.Get.OAM.OAM", str_arr, size_x_1,
                            trans_id, p_error_code, dst_module_id, OAM_ZERO, OAM_ZERO);
			        OAM_FUN_EXIT_TRACE();
			        return OAM_SUCCESS;
                }
                else
                {
                    OAM_LOG(OAM,OAM_ERROR,"Received error in response from OAM in OAM_GET_DEBUG_INFO_RESP %u %u",
                            oam_get_debug_info_resp.response, size_x_1);

                    oam_get_debug_info_resp.bitmask |= OAM_GET_DEBUG_INFO_FAILURE_CAUSE_PRESENT;
		            *p_error_code = OAM_INTERNAL_ERROR;
                    oam_construct_n_send_get_resp_to_usr(
                            OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR,
                            OAM_VERSION,
                            OAM_MODULE_ID,dst_module_id,
                            trans_id,
                            OAM_ZERO,OAM_ZERO,"OAM LAYER FAILURE RESPONSE",
                            p_error_code
                            );
			        OAM_FUN_EXIT_TRACE();
			        return OAM_FAILURE;
                }


            }
            else
            {
                    OAM_LOG(OAM,OAM_ERROR,"Received incorrect debug_type %d in OAM_GET_DEBUG_INFO_REQ ",debugType);
		            *p_error_code = OAM_INTERNAL_ERROR;
                    oam_construct_n_send_get_resp_to_usr(
                            OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR,
                            OAM_VERSION,
                            OAM_MODULE_ID,dst_module_id,
                            trans_id,
                            OAM_ZERO,OAM_ZERO,"OAM LAYER FAILURE RESPONSE",
                            p_error_code
                            );
			        OAM_FUN_EXIT_TRACE();
			        return OAM_FAILURE;
            }
        }
	}
    /*spr 22474 end*/
    /* SPR 24015 changes start */
    /* SPR 24015 changes end */
	curr_pos = par_name_len + OAM_EIGHT;

#ifdef OAM_SON_ENABLE
    /* spr_21013_fix_start */
	if((oam_strncasecmp(par_name,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.", oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.")) == OAM_ZERO) && ( oam_strlen(par_name) == oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.")))
    /* spr_21013_fix_end */
	{
		UInt16  num_parameters = OAM_ZERO;
		if(OAM_FAILURE == oam_partial_path_neighborlist_inuse(temp_payload ,(UInt8 *)p_temp_buf, curr_pos , &resp_len , &num_parameters))
		{
			Char8 error_str[] =
				" Failure in oam partial neighbor in use !";
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ERR_REQUEST_DENIED,
					OAM_VERSION, OAM_MODULE_ID,
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					error_str, p_error_code);
			/* Coverity ID 72195 Fix Start*/
			oam_mem_free(temp_payload, p_error_code);
			/* Coverity ID 72195 Fix End*/

			OAM_FUN_EXIT_TRACE();
			return OAM_SUCCESS;
		}

		partial_path_flag = OAM_TRUE;
		num_params = num_parameters;
	}
    /* spr_21013_fix_start */
	else if((oam_strncasecmp(par_name,"InternetGatewayDevice.Services.FAPService.REM.LTE.", oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.")) == OAM_ZERO)  && (oam_strlen(par_name) == oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.")))
    /* spr_21013_fix_end */
	{
		UInt16  num_parameters = OAM_ZERO;
		if(OAM_FAILURE == oam_partial_path_rem_lte(temp_payload ,(UInt8 *)p_temp_buf, curr_pos , &resp_len , &num_parameters))
		{
			Char8 error_str[] =
				" Failure in oam partial neighbor in use !";
			oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
					OAM_ERR_REQUEST_DENIED,
					OAM_VERSION, OAM_MODULE_ID,
					dst_module_id, trans_id,
					OAM_ZERO, OAM_ZERO,
					error_str, p_error_code);
			/* Coverity ID 72195 Fix Start*/
			oam_mem_free(temp_payload, p_error_code);
			/* Coverity ID 72195 Fix End*/
			OAM_FUN_EXIT_TRACE();
			return OAM_SUCCESS;
		}

		partial_path_flag = OAM_TRUE;
		num_params = num_parameters;
	}
#endif


	if(!partial_path_flag)
	{
		/**** Get Parameter's Info ****/ 
		do {
			if(partial_parent_flag) {
				/* Determine the instance number for the parent.
				 * Code should be added here for evaluation instance number
				 * of the parent */
#ifdef OAM_SON_ENABLE
				if(oam_strstr(par_name, "NeighborListInUse.LTECell.")) {

					cell_config_idx = oam_get_son_neigh_list_in_use_idx(
							oam_prov_req.cell_cntxt.curr_cell_cid);
					if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
						OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                     oam_prov_req.cell_cntxt.curr_cell_cid);
						/* Coverity ID 72195 Fix Start*/
						oam_mem_free(temp_payload, p_error_code);
						/* Coverity ID 72195 Fix End*/
						return OAM_FAILURE;
					}
/*SPR 22442 Fix Start*/
					for(bit_num = inst_num; bit_num < SON_MAX_NO_INTRA_RAT_NEIGHBOUR_CELLS;
/*SPR 22442 Fix End*/
							++bit_num) {
						if(SON_PROV_REQ.neigh_list_in_use[cell_config_idx].
								intra_rat_neigh_valid_bitmap & (OAM_ONE << bit_num)) {
							inst_num = bit_num + 1;
							break;
						}
					}
				}
				else if(oam_strstr(par_name,
							"NeighborListInUse.InterRATCell.UMTS.")) {

					cell_config_idx = oam_get_son_neigh_list_in_use_idx(
							oam_prov_req.cell_cntxt.curr_cell_cid);
					if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
						OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                     oam_prov_req.cell_cntxt.curr_cell_cid);
						/* Coverity ID 72195 Fix Start*/
						oam_mem_free(temp_payload, p_error_code);
						/* Coverity ID 72195 Fix End*/
						return OAM_FAILURE;
					}

/*SPR 22442 Fix Start*/
					for(bit_num = inst_num; bit_num < SON_MAX_NO_UMTS_NEIGHBOUR_CELLS;
/*SPR 22442 Fix End*/
							++bit_num) {
						/* SPR-13586 START */
						if(SON_PROV_REQ.neigh_list_in_use[cell_config_idx].
								inter_rat_umts_neigh_valid_bitmap & (OAM_ONE << bit_num)) {
							/* SPR-13586 END */
							inst_num = bit_num + 1;
							break;
						}
					}
				}
				/* SPR-13586 START */
				else if(oam_strstr(par_name,
							"NeighborListInUse.InterRATCell.GSM.")) {

					cell_config_idx = oam_get_son_neigh_list_in_use_idx(
							oam_prov_req.cell_cntxt.curr_cell_cid);
					if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
						OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                     oam_prov_req.cell_cntxt.curr_cell_cid);
						/* Coverity ID 72195 Fix Start*/
						oam_mem_free(temp_payload, p_error_code);
						/* Coverity ID 72195 Fix End*/
						return OAM_FAILURE;
					}

/*SPR 22442 Fix Start*/
					for(bit_num = inst_num; bit_num < SON_MAX_NO_GERAN_NEIGHBOUR_CELLS;
/*SPR 22442 Fix End*/
							++bit_num) {
						/* SPR-13586 START */
						if(SON_PROV_REQ.neigh_list_in_use[cell_config_idx].
								inter_rat_gsm_neigh_valid_bitmap & (OAM_ONE << bit_num)) {
							/* SPR-13586 END */
							inst_num = bit_num + 1;
							break;
						}
					}
				}
				/* SPR-13586 END */
				else
#endif
					if(oam_strstr(par_name, "PLMNList.")) {
						cell_config_idx = oam_get_cell_plmnlist_data_idx(
								oam_prov_req.cell_cntxt.curr_cell_cid);
						if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
							OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                         oam_prov_req.cell_cntxt.curr_cell_cid);
							/* Coverity ID 72195 Fix Start*/
							oam_mem_free(temp_payload, p_error_code);
							/* Coverity ID 72195 Fix End*/
							return OAM_FAILURE;
						}

						for(bit_num = inst_num; bit_num < RRM_OAM_MAX_NUM_PLMNS;
								++bit_num) {
							/* coverity 53567 53539 53537*/
							if(RRM_OAM_MAX_NUM_PLMNS >= bit_num) {
								if(RRM_PROV_REQ.plmnlist_data[cell_config_idx].
										is_valid_bitmap & (1 << bit_num)){
									inst_num = bit_num + OAM_ONE;
									break;
								}
							}
						}
					}
                    /* SPR 15527 START */
                    else if(strstr(par_name, "QoS.")) {
                        for(bit_num = inst_num; bit_num < OAM_MAX_QOSLIST_OBJECTS;
                                ++bit_num) {
                            if(OAM_MAX_QOSLIST_OBJECTS >= bit_num){
                                if(OAM_TRUE ==  oam_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[bit_num].is_valid_entry ){
                                    inst_num = bit_num + OAM_ONE;
                                    break;
                                }
                            }
                        }
                    }
                    /* SPR 15527 END */ 
					else if(oam_strstr(par_name, "SupportedAlarm.") ||
							oam_strstr(par_name, "CurrentAlarm.") ||
							oam_strstr(par_name, "HistoryEvent.") ||
							oam_strstr(par_name, "ExpeditedEvent.") ||
							oam_strstr(par_name, "QueuedEvent.")) {
						++inst_num;
					}
			}

			for(loop = OAM_ZERO; loop < num_params; ++loop) {
				oam_memset(par_dot_param, OAM_ZERO,
						(MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH));

				if(!partial_parent_flag) {
					param_node_len = get_word_from_header((UInt8 *)(p_temp_buf + OAM_ZERO));
					param_name_len = param_node_len - OAM_FOUR;
					/* increase the buf pointer to point to parameter name*/
					p_temp_buf += OAM_FOUR;
					oam_memset(param_name, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
					oam_memcpy(param_name, p_temp_buf, param_name_len);
					OAM_LOG(OAM, OAM_DETAILED, "Parameter Name: %s", param_name);

					/* coverity 41290 */
					usr_error_code = OAM_ERR_INVALID_PARAM_NAME;
					oam_strcat(par_dot_param, par_name);/*concatinating string*/    

					oam_strcat(par_dot_param,".");/*concatinating string*/

					/* Coverity Fix: Deleted block:  */

					oam_strcat(par_dot_param, param_name);/*concatinating string*/
					OAM_LOG(OAM, OAM_DETAILED, "Parent.Parameter: %s", par_dot_param);

					retVal = oam_check_param_input_validity(par_dot_param);

					if (OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_WARNING,
								"Parameter is not supported");
						*p_error_code = OAM_GET_PARAMETER_INPUT_INCORRECT;
						/* Coverity ID 72195 Fix Start*/
						oam_mem_free(temp_payload, p_error_code);
						/* Coverity ID 72195 Fix End*/

						OAM_FUN_EXIT_TRACE();
						return retVal;
					}
					/* get parameter value from OAM database */
					oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);

					/*Code add to add the parameter in the multiple table*/

					/* SPR 11249 FIX START */
					/* Changed from ActiveCellIndex to CurrentCellIndex */
					if(oam_strncasecmp(par_dot_param, "Cell_Context.Context.CurrentCellIndex", oam_strlen("Cell_Context.Context.CurrentCellIndex")) == OAM_ZERO){
						g_parameter_map_element = &g_parameter_cell_context[0];

						/* SPR 11249 FIX END */

					}
					else if(oam_strncasecmp(par_dot_param, "Cell_Context.Context.CellIndexList", oam_strlen("Cell_Context.Context.CellIndexList")) == OAM_ZERO){
						/* Coverity ID 72195 Fix Start*/
						oam_mem_free(temp_payload, p_error_code);
						/* Coverity ID 72195 Fix End*/
						temp_payload = param_val_pair;
						oam_memset(param_val_pair, OAM_ZERO, sizeof(param_val_pair));
						if (OAM_FAILURE == oam_mem_alloc((size_x * sizeof(UInt8 *)),(void *)&temp_arr,p_error_code))
						{
							OAM_LOG(OAM, OAM_ERROR,
									"Memory allocation to temp_arr failed"
									" with Error Code:%d",
									*p_error_code);
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}

						for (loop_counter = OAM_ZERO; loop_counter < size_x; loop_counter++)
						{
							if(OAM_FAILURE == oam_mem_alloc((size_y * sizeof(UInt8)),(void *)&temp_arr[loop_counter],p_error_code))
							{
								OAM_LOG(OAM, OAM_ERROR,
										"Memory allocation to temp_arr failed"
										" with Error Code:%d",
										*p_error_code);
                                /* SPR 22157 FIX START */
                                for (loop_counter = OAM_ZERO; loop_counter < size_x; loop_counter++)
                                {
                                    oam_mem_free(temp_arr[loop_counter], p_error_code);
                                }   
                                oam_mem_free(temp_arr, p_error_code);
                                /* SPR 22157 FIX END  */
								OAM_FUN_EXIT_TRACE();
								return OAM_FAILURE;
							}
							oam_memset(temp_arr[loop_counter], 0x00, (size_y * sizeof(UInt8)));
						}
						for(loop = 0; loop < oam_prov_req.num_cells_configured; ++loop) {
							oam_sprintf(temp_payload, "CellID[%d]",
									loop);

							oam_strcpy((char *)temp_str_cli,(char *)temp_payload);
							oam_sprintf((char *)temp_arr[str_count++],"%s=%d",
									temp_str_cli,oam_prov_req.cell_cntxt.cell_ctxt_status[loop].cid);

							temp_payload += oam_strlen(temp_payload);
						}

						oam_construct_n_send_gpv_response((UInt8 *)"CellContext",
								temp_arr,
								str_count, trans_id,
								p_error_code,
								dst_module_id,
								OAM_ZERO, OAM_ZERO);
                        /* SPR 22157 FIX START */
                        for (loop_counter = OAM_ZERO; loop_counter < size_x; loop_counter++)
                        {
                            oam_mem_free(temp_arr[loop_counter], p_error_code);
                        }    
                        /* SPR 22157 FIX END   */
						oam_mem_free(temp_arr, p_error_code);
						OAM_LOG(OAM,OAM_DETAILED,"Show Context Commend received");
						return OAM_SUCCESS;
					}

                    /* spr_21013_fix_start */
					if(oam_strncasecmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.FAPControl.LTE", oam_strlen("InternetGatewayDevice.Services.FAPService.FAPControl.LTE")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
					}
					else if(oam_strncasecmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc", oam_strlen("InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_lte_l3_Assoc_list[OAM_ZERO];
					}
					else if(oam_strncasecmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.Transport.SCTP", oam_strlen("InternetGatewayDevice.Services.FAPService.Transport.SCTP")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_lte_l3_sctp_list[OAM_ZERO];
					}

					else if(oam_strncasecmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoSNum", oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoSNum")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
					}
					/* FM DEVLOPEMENT */
					/*SPR 10451 start*/ 
					else if(oam_strstr(par_name,
								"InternetGatewayDevice.FaultMgmt.CurrentAlarm"))
					{
						g_parameter_map_element = g_parameter_multi_instanse_FM_CURR_GET_SET;
						OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt CurrentAlarm Table selected.");
					}
					else if(oam_strncasecmp((char *)par_name,
								"InternetGatewayDevice.FaultMgmt.ExpeditedEvent",
								oam_strlen("InternetGatewayDevice.FaultMgmt.ExpeditedEvent"))
							== OAM_ZERO)
					{

						g_parameter_map_element = g_parameter_multi_instanse_FM_EXPD_GET_SET;
						OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt ExpeditedEvent Table selected.");
					}

					else if(oam_strncasecmp((char *)par_name,
								"InternetGatewayDevice.FaultMgmt.QueuedEvent",
								oam_strlen("InternetGatewayDevice.FaultMgmt.QueuedEvent"))
							== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_multi_instanse_FM_QUED_GET_SET;
						OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt QueuedEvent Table selected.");
					}

					else if(oam_strncasecmp((char *)par_name,
								"InternetGatewayDevice.FaultMgmt.HistoryEvent",
								oam_strlen("InternetGatewayDevice.FaultMgmt.HistoryEvent"))
							== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_multi_instanse_FM_HIST_GET_SET;
						OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt HistoryEvent Table selected.");
					}
					else if(oam_strncasecmp((char *)par_name,
								"InternetGatewayDevice.FaultMgmt.SupportedAlarm",
								oam_strlen("InternetGatewayDevice.FaultMgmt.SupportedAlarm"))
							== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_multi_instanse_FM_SUPP_GET_SET;
						OAM_LOG(OAM, OAM_DETAILED, "FaultMgmt SupportedAlarm Table selected.");
					}

					/*SPR 10451 end*/
					else if(NULL != oam_strstr(par_dot_param,"Enable") && (NULL != oam_strstr(par_dot_param,"Perf"))) 
					{
						fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"Enable",loop);
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_ENABLE_BIT;
					}
					else if( oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.AntennaInfo",
								oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.PHY.AntennaInfo")) == OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_TR_element;
					}
#ifdef OAM_SON_ENABLE
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.InServiceHandling",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.InServiceHandling"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanOnBoot",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.ScanOnBoot"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanPeriodically",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.ScanPeriodically"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.PeriodicInterval",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.PeriodicInterval"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.PeriodicTime",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.PeriodicTime"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.EUTRACarrierARFCNDLList",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.EUTRACarrierARFCNDLList"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanTimeout",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.ScanTimeout"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.REMBandList",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.REMBandList"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.REMPLMNList",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.REMPLMNList"))== OAM_ZERO)
					{
						g_parameter_map_element = g_parameter_son_nw_scan_req;
					}
					else if(!oam_strncmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.REM.LTE.Cell",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.Cell")))
					{
						if(oam_strstr(par_dot_param, "RF"))
							g_parameter_map_element = &g_parameter_son_nw_scan_results_rf[OAM_ZERO];
						else if(oam_strstr(par_dot_param, "BCCH"))
							g_parameter_map_element = &g_parameter_son_nw_scan_results_bcch[OAM_ZERO];
					}
					else if(oam_strncasecmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].BCCH.PLMNList",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].BCCH.PLMNList")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_son_nw_scan_results_bcch_plmnlist[OAM_ZERO];
					}
					else if(oam_strncasecmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.REM.LTE",
								oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE")) == OAM_ZERO)
					{
						if(OAM_ZERO == oam_strncasecmp((char *)par_dot_param, "InternetGatewayDevice.Services.FAPService.REM.LTE.CarrierMeas", oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.CarrierMeas")))
                        /* spr_21013_fix_end */
						{
							g_parameter_map_element = &(g_parameter_son_rem_lte_carrierMeas[OAM_ZERO]);

						}else
							g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO]; 
					}
#endif
					/* SPR 11001 FIX START */
					else if(oam_strstr(par_name, "LoadReporting")) {
						g_parameter_map_element = g_parameter_TR_element;
					}
					/* SPR 11001 FIX END */
					else if(!oam_strncmp(par_dot_param,"InternetGatewayDevice.FAP.PerfMgmt.Config.PeriodicUploadTime",
								oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config.PeriodicUploadTime")))
					{
						fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"PeriodicUploadTime",loop);
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_PERIODIC_UPLOAD_TIME_BIT;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.FAP.PerfMgmt.Config.X_VENDOR_FileWriteTimer",
								oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config.X_VENDOR_FileWriteTimer"))== OAM_ZERO)
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_FILE_WRITE_TIMER_BIT;
					}

					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.FAP.PerfMgmt.Config.PeriodicUploadInterval",
								oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config.PeriodicUploadInterval"))== OAM_ZERO)
					{
						fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"PeriodicUploadInterval",loop);
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_PERIODIC_UPLOAD_INTERVAL_BIT;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.FAP.PerfMgmt.Config.URL",
								oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config.URL"))== OAM_ZERO)
					{
						fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"URL",loop);
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_URL_BIT;
					}
					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.FAP.PerfMgmt.Config.Username",
								oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config.Username"))== OAM_ZERO)
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_USERNAME_BIT;
						fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"Username",loop);

					}


					else if(oam_strncasecmp(par_dot_param,"InternetGatewayDevice.FAP.PerfMgmt.Config.Password",
								oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config.Password"))== OAM_ZERO)
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_PASSWORD_BIT;

					}

                    /* spr_21013_fix_start */
					else if(oam_strncasecmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS", oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.QoS")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_TR_QOS_element[OAM_ZERO];
                        /* SPR 15527 START */
                        oam_memcpy(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list, RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list,
                                sizeof(RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list));
                        oam_prov_req.system_status.event_ongoing |= OAM_MODIFY_QOS_OBJ_ONGOING;
                        /*SPR 15527 END*/
					}
					else if (oam_strncasecmp(par_dot_param, "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.",
								oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList.")) == OAM_ZERO)
					{
                        /* SPR_19279_START */
                        if(QCLI_MODULE_ID != dst_module_id) {
                            g_parameter_map_element =
                                &g_parameter_TR_PLMNList_element[OAM_ZERO];
                        }
                        else {
                            /* The GPV request has come from QCLI and should be passed
                             * to lower layer.
                             */
                            retVal = oam_handle_plmnlist_retrieve_req(dst_module_id, trans_id);
                            if(OAM_FAILURE == retVal) {
                                oam_construct_n_send_gpv_response(
                                        (UInt8*)"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS",
                                        OAM_NULL, OAM_ZERO,
                                        trans_id,
                                        p_error_code, dst_module_id,
                                        start_index, end_index);
                            }
                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }
                        /* SPR_19279_END */
					}
#ifdef OAM_SON_ENABLE
					else if(oam_strstr(par_dot_param,
								"InternetGatewayDevice.Services.FAPService.CellConfig"
								".LTE.RAN.Mobility.IdleMode.InterFreq.Carrier.")) {
						OAM_LOG(OAM, OAM_DETAILED,
								"Table for InterFreq.Carrier selected.");
						g_parameter_map_element =
							g_parameter_TR_InterFreq_Carrier_element;
					}
					else if(oam_strstr(par_dot_param,
								"InternetGatewayDevice.Services.FAPService.CellConfig"
								".LTE.RAN.Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq.")){
						OAM_LOG(OAM, OAM_DETAILED,
								"Table for InterFreq.UTRA.UTRANFDDFreq selected.");
						g_parameter_map_element =
							g_parameter_TR_UTRA_FDD_element;
					}
					/* RT SPR 9019 FIX START */
                    /*SPR 13944 start */
					else if(oam_strstr(par_dot_param,
								"InternetGatewayDevice.Services.FAPService."
                         "CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.UTRA.UTRANTDDFreq.")) {
						OAM_LOG(OAM, OAM_DETAILED, "Table for InterFreq."
                         "UTRA..UTRANTDDFreq selected.");
                    /*SPR 13944 End */
						g_parameter_map_element = g_parameter_UTRA_TDD_element;
					}
					else if(oam_strstr(par_dot_param,
								"InternetGatewayDevice.Services.FAPService."
								"CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.UTRA.")) {
						OAM_LOG(OAM, OAM_DETAILED,
								"Table for InterFreq.UTRA. selected.");
						g_parameter_map_element =
							g_parameter_TR_UTRA_element;
					}
					/* RT SPR 9019 FIX END */
					/* RT SPR 8154 FIX START */
					else if(oam_strstr(par_dot_param,
								"InternetGatewayDevice.Services.FAPService.CellConfig"
								".LTE.RAN.Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup.")){
						OAM_LOG(OAM, OAM_DETAILED,
								"Table for GERAN.GERANFreqGroup selected.");
						g_parameter_map_element =
							g_parameter_son_anr_GERANFreqGroup_params;
					}
					else if(oam_strstr(par_dot_param,
								"InternetGatewayDevice.Services.FAPService."
								"CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.GERAN.")) {
						OAM_LOG(OAM, OAM_DETAILED,
								"Table for InterFreq.GERAN. selected.");
						g_parameter_map_element =
							g_parameter_son_anr_geran_params;
					}
					/* RT SPR 8154 FIX END */
					else if(oam_strstr(par_dot_param,
								"InternetGatewayDevice.Services.FAPService."
								"CellConfig.LTE.RAN.NeighborList.")) {
						if(oam_strstr(par_dot_param, "InterRATCell.UMTS.")) {
							OAM_LOG(OAM, OAM_DETAILED,
									"Table for inter-RAT NeighborList selected.");
							/* Check if the GPV request has come from TR-069 agent,
							 * no need to pass the GPV request to lower layer, the
							 * parameter values will be fetched from local structures */
							if(QCLI_MODULE_ID != dst_module_id) {
								g_parameter_map_element =
									g_parameter_lte_inter_rat_neighbor_list;
							}
							else {
								/* The GPV request has come from QCLI and should be passed
								 * to lower layer.
								 */
								/* Start: SPR 10567 */
								retVal = oam_handle_son_nr_retrieve_utran(dst_module_id, trans_id, p_error_code);
								if(OAM_FAILURE == retVal) {
									oam_construct_n_send_gpv_response(
											(UInt8*)"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS",
											OAM_NULL, OAM_ZERO,
											trans_id,
											p_error_code, dst_module_id,
											start_index, end_index);
								}
								/*End: SPR 10567 */
								OAM_FUN_EXIT_TRACE();
								return retVal;
							}
						}
						/* SPR-13586 START */
						else if(oam_strstr(par_dot_param, "InterRATCell.GSM.")) {
							OAM_LOG(OAM, OAM_DETAILED,
									"Table for inter-RAT NeighborList selected.");
							/* Check if the GPV request has come from TR-069 agent,
							 * no need to pass the GPV request to lower layer, the
							 * parameter values will be fetched from local structures */
							if(QCLI_MODULE_ID != dst_module_id) {
								g_parameter_map_element =
									g_parameter_lte_inter_rat_geran_neighbor_list;
							}
							else {
								/* The GPV request has come from QCLI and should be passed
								 * to lower layer.
								 */
								/* Start: SPR 10567 */

								retVal = oam_handle_son_nr_retrieve_geran(dst_module_id, trans_id, p_error_code);
								if(OAM_FAILURE == retVal) {
									oam_construct_n_send_gpv_response(
											(UInt8*)"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.GSM",
											OAM_NULL, OAM_ZERO,
											trans_id,
											p_error_code, dst_module_id,
											start_index, end_index);
								}
								/*End: SPR 10567 */
								OAM_FUN_EXIT_TRACE();
								return retVal;
							}
						}
						/* SPR-13586 END */
						else if(oam_strstr(par_dot_param, "LTECell.")) {
							OAM_LOG(OAM, OAM_DETAILED,
									"Table for intra-RAT NeighborList selected.");
							/* Check if the GPV request has come from TR-069 agent,
							 * no need to pass the GPV request to lower layer, the
							 * parameter values will be fetched from local structures */
							if(QCLI_MODULE_ID != dst_module_id) {
								g_parameter_map_element =
									g_parameter_lte_intra_rat_neighbor_list;
							}
							else {
								/* The GPV request has come from QCLI and should be passed
								 * to lower layer.
								 */
								/* Start: SPR 10567 */
								retVal = oam_handle_son_nr_retrieve_eutran(dst_module_id, trans_id, p_error_code);
								if(OAM_FAILURE == retVal) {
									oam_construct_n_send_gpv_response(
											(UInt8*)"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborList.LTECell",
											OAM_NULL, OAM_ZERO,
											trans_id,
											p_error_code, dst_module_id,
											start_index, end_index);
								}
								/*End: SPR 10567 */
								OAM_FUN_EXIT_TRACE();
								return retVal;
							}
						}
					}
					/* Start: SPR 10567 */
					else if(oam_strstr(par_dot_param,
								"InternetGatewayDevice.Services.FAPService."
								"CellConfig.LTE.RAN.NeighborListInUse.")) {

						if(oam_strstr(par_dot_param, "InterRATCell.UMTS.")) {
							OAM_LOG(OAM, OAM_DETAILED,
									"Table for inter-RAT NeighborListInUse selected.");
							/* Check if the GPV request has come from TR-069 agent,
							 * no need to pass the GPV request to lower layer, the
							 * parameter values will be fetched from local structures */
							if(QCLI_MODULE_ID != dst_module_id) {
								g_parameter_map_element =
									g_param_inter_rat_neigh_list_in_use;
							}
							else {
								/* The GPV request has come from QCLI and should be passed
								 * to lower layer.
								 */
								retVal = oam_handle_son_nliu_retrieve_utran(dst_module_id, trans_id, p_error_code);
								if(OAM_FAILURE == retVal) {
									oam_construct_n_send_gpv_response(
											(UInt8*)"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.UMTS",
											OAM_NULL, OAM_ZERO,
											trans_id,
											p_error_code, dst_module_id,
											start_index, end_index);
								}
								OAM_FUN_EXIT_TRACE();
								return retVal;
							}
						}
						/* SPR-13586 START */ 
						else if(oam_strstr(par_dot_param, "InterRATCell.GSM.")) {
							OAM_LOG(OAM, OAM_DETAILED,
									"Table for inter-RAT NeighborListInUse selected.");
							/* Check if the GPV request has come from TR-069 agent,
							 * no need to pass the GPV request to lower layer, the
							 * parameter values will be fetched from local structures */
							if(QCLI_MODULE_ID != dst_module_id) {
								g_parameter_map_element =
									g_parameter_lte_inter_rat_geran_neighbor_list_in_use;
							}
							else {
								/* The GPV request has come from QCLI and should be passed
								 * to lower layer.
								 */
								retVal = oam_handle_son_nliu_retrieve_geran(dst_module_id, trans_id, p_error_code);
								if(OAM_FAILURE == retVal) {
									oam_construct_n_send_gpv_response(
											(UInt8*)"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.GSM",
											OAM_NULL, OAM_ZERO,
											trans_id,
											p_error_code, dst_module_id,
											start_index, end_index);
								}
								OAM_FUN_EXIT_TRACE();
								return retVal;
							}

						}
						/* SPR-13586 END */
						else if(oam_strstr(par_dot_param, "LTECell.")){
							OAM_LOG(OAM, OAM_DETAILED,
									"Table for intra-RAT NeighborListInUse selected.");
							/* Check if the GPV request has come from TR-069 agent,
							 * no need to pass the GPV request to lower layer, the
							 * parameter values will be fetched from local structures */
							if(QCLI_MODULE_ID != dst_module_id) {
								g_parameter_map_element =
									g_param_intra_rat_neigh_list_in_use;
							}
							else {
								/* The GPV request has come from QCLI and should be passed
								 * to lower layer.
								 */
								retVal = oam_handle_son_nliu_retrieve_eutran(dst_module_id, trans_id, p_error_code);
								if(OAM_FAILURE == retVal) {
									oam_construct_n_send_gpv_response(
											(UInt8*)"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.LTECell",
											OAM_NULL, OAM_ZERO,
											trans_id,
											p_error_code, dst_module_id,
											start_index, end_index);
								}
								OAM_FUN_EXIT_TRACE();
								return retVal;
							}
						}
					}
					/*End: SPR 10567 */
#endif
                    else if ((oam_strncasecmp(par_dot_param, "eNodeBParams", oam_strlen("eNodeBParams")) == OAM_ZERO) &&
                            (oam_strcmp(par_name, "eNodeBParams.stack_config.L3Params.M2AP") != OAM_ZERO))
					{
#ifdef OAM_SON_ENABLE
						if (oam_strncasecmp(par_dot_param, "eNodeBParams.oam_son_req.nbr_enb_list", 
									oam_strlen("eNodeBParams.oam_son_req.nbr_enb_list")) == OAM_ZERO)
						{
                            /*SPR 17777 fix*/
							retVal = oam_populate_son_nr_enb_retrieve_req(p_api_buf);
							return retVal;
						}
#endif
						g_parameter_map_element = &g_parameter_NONTR_element[OAM_ZERO];
					}
					else if (oam_strncasecmp(par_dot_param, "Show.Version", oam_strlen("Show.Version")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_NONTR_element[OAM_ZERO]; 
					}
					else if (oam_strncasecmp(par_dot_param, "FM.Alarm", oam_strlen("FM.Alarm")) == OAM_ZERO)
					{
						return oam_fm_intf_process_msg(p_api_buf);
					}
					else if (oam_strncasecmp(par_dot_param, "InternetGatewayDevice.WANDevice.[1].WANEthernetInterfaceConfig",
								oam_strlen("InternetGatewayDevice.WANDevice.[1].WANEthernetInterfaceConfig")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
					}
					else if (oam_strncasecmp(par_dot_param, "InternetGatewayDevice.FAP.Tunnel.VirtualInterfaceNum",
								oam_strlen("InternetGatewayDevice.FAP.Tunnel.VirtualInterfaceNum")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
					}
					else if (oam_strncasecmp(par_dot_param, "InternetGatewayDevice.FAP.Tunnel.VirtualInterface.[1]",
								oam_strlen("InternetGatewayDevice.FAP.Tunnel.VirtualInterface.[1]")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_tunnel_virtualInterface[OAM_ZERO];
					}
                    /* OAM BCOM Code Comment Changes Start */
                    else if (oam_strncasecmp(par_dot_param, "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1]",
                                oam_strlen("InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1]")) == OAM_ZERO)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
                        g_parameter_map_element = &g_parameter_tunnel_crypto_profile[OAM_ZERO];
                    }
                    else if (oam_strncasecmp(par_dot_param, "InternetGatewayDevice.FAP.Tunnel.IKESA.[1]",
                                oam_strlen("InternetGatewayDevice.FAP.Tunnel.IKESA.[1]")) == OAM_ZERO)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
                        g_parameter_map_element = &g_parameter_tunnel_ikesa[OAM_ZERO];
                    }
                    /* OAM BCOM Code Comment Changes End */
					else if (oam_strncasecmp(par_dot_param, "InternetGatewayDevice.FAP",
								oam_strlen("InternetGatewayDevice.FAP")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
					}

					/* LTE_OAM_CA_PARAMETER_SUPPORT */
                            /* SPR 14295 FIX START */
                            else if (oam_strstr(par_dot_param,
                                        "InternetGatewayDevice.Services."
                                         /* spr_21013_fix_start */
                                        "FAPService.CellConfig."
                                        /* spr_21013_fix_end */
                                        "X_VENDOR_CARRIER_AGGREGATION_PARAMS."
                                        "MACSchedParams")) {
                                OAM_LOG(OAM, OAM_DETAILED,
                                        "Table for CA MACSchedParams selected.");
                                g_parameter_map_element =
                                    g_parameter_ca_mac_sched_params;
                            }
                            else if (oam_strstr(par_dot_param,
                                        "InternetGatewayDevice.Services."
                                         /* spr_21013_fix_start */
                                        "FAPService.CellConfig."
                                        /* spr_21013_fix_end */
                                        "X_VENDOR_CARRIER_AGGREGATION_PARAMS")) {
                                OAM_LOG(OAM, OAM_DETAILED,
                                        "Table for CA general params selected.");
                                g_parameter_map_element = g_parameter_ca_general_params;
                            }
                            /* SPR 14295 FIX END */
					/*LTE_OAM_CA_PARAMETER_SUPPORT */

					/* eICIC_PHASE_1_2_CHANGES_START */
					else if(oam_strncasecmp((char *)par_dot_param,
								"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS",
								oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS")) == OAM_ZERO)
                    /* spr_21013_fix_end */
					{
						g_parameter_map_element = &g_parameter_x_vendor_eicic_params[OAM_ZERO];
					}
					/* eICIC_PHASE_1_2_CHANGES_END */

#ifdef OAM_SON_ENABLE /* FLAG_CHANGES */
					/*eICIC_PHASE_1_2_CHANGES_START*/
					else if(OAM_ZERO == oam_strncasecmp((char *)par_dot_param, "SON.ANR.NEIGHBOR-DEFAULT-CONFIG.RETREIVE", 
								oam_strlen("NEIGHBOR-DEFAULT-CONFIG")))
					{
						OAM_LOG(OAM, OAM_INFO,
								"NEIGHBOR-DEFAULT-CONFIG request received ");

						g_parameter_map_element = &(g_parameter_son_anr_neighbor_default_config_req[OAM_ZERO]);

					}
					/*eICIC_PHASE_1_2_CHANGES_END*/


					else if(oam_strstr(par_dot_param,
								"ES.Retrieve.Switched_off_cells")) {
						oam_send_son_cell_switched_off_info_req(p_api_buf,
								msg_len);
						SON_PROV_REQ.retreive_ongoing |=
							OAM_SON_ES_CELL_SWITCHED_OFF_INFO_RETREIVE_ONGOING;
						return OAM_SUCCESS;
					}
                    /* SPR_19619 start*/

                    else if (oam_strncasecmp(par_name, "SON.PEER_CELL_ACTIVATION", oam_strlen("SON.PEER_CELL_ACTIVATION")) == OAM_ZERO)
                    {	
                        oam_send_son_peer_cell_activation_req(p_api_buf,
                                msg_len);
                        return OAM_SUCCESS;
                    }
                    /* SPR_19619 stop*/

#endif
#ifdef OAM_RADIO_HEAD_SUPPORT
#ifdef OAM_RRH_TYPE_1_SUPPORT
					else if(oam_strncasecmp(par_dot_param, "RRH", oam_strlen("RRH")) == OAM_ZERO) 
					{
						/*--------If ALARM ID is set for OAM_RCM_ALARM_RRH_MSG_QUEUE_FULL, sending failure response to QCLI-------*/
						if(OAM_RCM_ALARM_RRH_MSG_QUEUE_FULL == alarm_id_set)
						{
							resp_status = OAM_ONE; /* here, 1 means failure */
							oam_memset(error_str, OAM_ZERO, STR_LEN_80);
							oam_sprintf(error_str, "\nAlarm for RRH Message Queue Full\n");

							oam_construct_n_send_get_resp_to_usr(OAM_ONE, OAM_ZERO, OAM_VERSION,
									OAM_MODULE_ID, dst_module_id,
									trans_id,OAM_ZERO,OAM_ZERO, 
									error_str,p_error_code); 
							OAM_FUN_EXIT_TRACE();
							return OAM_SUCCESS;
						}
						g_parameter_map_element = &g_parameter_RRH_element[OAM_ZERO];

						/** Special case for get requests for capabilities
						 * or attributes, these requests must be forwarded to lower
						 * layer to get the latest parameter values **/
						if(oam_strncasecmp(par_dot_param, "RRH.Capabilities",
									oam_strlen("RRH.Capabilities")) == OAM_ZERO) {
							paramter_app_map_tbl |= RRH_OAM_CAPABILITIES_MASK; 
							retVal = oam_send_message_to_lower_layers(
									OAM_MODULE_ID,
									msg_len,
									p_api_buf,
									OAM_NULL,
									OAM_NULL,
									OAM_NULL,
									OAM_NULL,
									p_error_code);
							if (OAM_FAILURE == retVal) {
								OAM_LOG(OAM, OAM_ERROR,
										"Message sending to lower failed");
								OAM_FUN_EXIT_TRACE();
								return OAM_FAILURE;
							}
							return OAM_SUCCESS;
						}
						else if(oam_strncasecmp(par_dot_param, "RRH.Attributes",
									oam_strlen("RRH.Attributes")) == OAM_ZERO) {
							paramter_app_map_tbl |= RRH_OAM_ATTRIBUTES_MASK; 
							retVal = oam_send_message_to_lower_layers(
									OAM_MODULE_ID,
									msg_len,
									p_api_buf,
									OAM_NULL,
									OAM_NULL,
									OAM_NULL,
									OAM_NULL,
									p_error_code);
							if (OAM_FAILURE == retVal) {
								OAM_LOG(OAM, OAM_ERROR,
										"Message sending to lower failed ");
								OAM_FUN_EXIT_TRACE();
								return OAM_FAILURE;
							}
							return OAM_SUCCESS;
						}
					}
#endif
#endif
                    /* Spr 15596 Fix Start */
                    else if((oam_strncasecmp((char *)par_name, 
                           "InternetGatewayDevice.FTPParams", 
                           oam_strlen("InternetGatewayDevice.FTPParams")) == OAM_ZERO) &&
                            (oam_strncmp(par_name,
                                         "InternetGatewayDevice.Services."
                                         "FAPService.[1].CellConfig.LTE.RAN."
                                         "PHY.MBSFN",
                                         oam_strlen("InternetGatewayDevice."
                                             "Services.FAPService.[1].CellConfig."
                                             "LTE.RAN.PHY.MBSFN")) != OAM_ZERO))
                    {
                        g_parameter_map_element = &g_parameter_FTP_Params[OAM_ZERO];
                        OAM_LOG(OAM, OAM_DETAILED, "FTP Params Table selected.");
                    }    
                    /* Spr 15596 Fix End */
					else if (oam_strncasecmp(par_dot_param, "InternetGatewayDevice",
								oam_strlen("InternetGatewayDevice")) == OAM_ZERO)
					{
						g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
					}
					/* SPR 11249 FIX START */
					/* Changed from ActiveCellIndex to CurrentCellIndex */
					else if (oam_strncasecmp(par_dot_param, "Cell_Context.Context.CurrentCellIndex",
								oam_strlen("Cell_Context.Context.CurrentCellIndex")) == OAM_ZERO)

						/* SPR 11249 FIX END */
					{
						g_parameter_map_element = &g_parameter_cell_context[OAM_ZERO];
					}
                    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
                    else if (!oam_strcmp(par_name, "eNodeBParams.stack_config.L3Params.M2AP"))
                    {
                        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
                        {
                            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
                            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
                            retVal = OAM_FAILURE;

                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }
                        /* SPR 18344 Fix +- */

                        g_parameter_map_element = g_parameter_mbsfn_non_tr196_params;
                        OAM_LOG(OAM, OAM_DETAILED, "M2AP non-tr params table selected.");
                    }
                    else if (!oam_strncmp(par_name, "InternetGatewayDevice."
                                "Services.FAPService.[1].CellConfig.LTE.RAN."
                                "PHY.MBSFN.SFConfigList", 
                                oam_strlen("InternetGatewayDevice.Services."
                                    "FAPService.[1].CellConfig.LTE.RAN.PHY."
                                    "MBSFN.SFConfigList"))
                            )
                    {
                        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
                        {
                            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
                            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
                            retVal = OAM_FAILURE;

                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }
                        /* SPR 18344 Fix +- */

                        g_parameter_map_element = g_parameter_sfconfig_list_params;
                        OAM_LOG(OAM, OAM_DETAILED, "MBSFN SFConfigList table selected .");
                    }
                    else if (!oam_strcmp(par_name, "InternetGatewayDevice.Services."
                                "FAPService.[1].CellConfig.LTE.RAN.PHY.MBSFN."
                                "MBSFN_SERVICE_AREA_CONFIG"))
                    {
                        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
                        {
                            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
                            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
                            retVal = OAM_FAILURE;

                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }
                        /* SPR 18344 Fix +- */

                        g_parameter_map_element = g_parameter_mbsfn_l3_params;
                        OAM_LOG(OAM, OAM_DETAILED, "MBSFN L3 params table selected .");
                    }
                    else if (!oam_strcmp(par_name, "InternetGatewayDevice.Services."
                                "FAPService.[1].CellConfig.LTE.RAN.PHY.MBSFN"))
                    {
                        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
                        {
                            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
                            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
                            retVal = OAM_FAILURE;

                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }
                        /* SPR 18344 Fix +- */

                        g_parameter_map_element = g_parameter_mbsfn_rrm_params;
                        OAM_LOG(OAM, OAM_DETAILED, "MBSFN RRM params table selected .");
                    }
#endif
                    /* EMBMS Changes End */
					else
					{
						g_parameter_map_element = &g_parameter_CONTROL_COMMAND_element[OAM_ZERO];
					}

					if(NULL != oam_strstr(par_dot_param,"X_VENDOR_SamplingInterval"))
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_SAMPLING_TIMER_BIT;
					}
					if(NULL != oam_strstr(par_dot_param,"PeriodicUploadTime"))
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_PERIODIC_UPLOAD_TIME_BIT;

					}
					if(NULL != oam_strstr(par_dot_param,"X_VENDOR_FileWriteTimer"))
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_FILE_WRITE_TIMER_BIT;

					}
					if(NULL != oam_strstr(par_dot_param,"PeriodicUploadInterval"))
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_PERIODIC_UPLOAD_INTERVAL_BIT;

					}
					if(NULL != oam_strstr(par_dot_param,"URL"))
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_URL_BIT;

					}
					if(NULL != oam_strstr(par_dot_param,"Username"))
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_USERNAME_BIT;

					}

					if(NULL != oam_strstr(par_dot_param,"Password"))
					{
						oam_config.config_param_bit_mask = oam_config.config_param_bit_mask | OAM_CONFIG_PASSWORD_BIT;

					}
					/*Code ended to add the parameter in the multiple table*/
				}
				else {
					/* Actual handling for partial parent GPV */
					oam_strncpy(par_dot_param, par_name, oam_strlen(par_name));

					oam_snprintf(par_dot_param + oam_strlen(par_name), 
							sizeof(par_dot_param) + oam_strlen(par_name),"[%d]", inst_num);
					parameter_token =
						OAM_STRRCHR(g_parameter_map_element[loop].
								parameter_name, '.');
					if(parameter_token) {
						oam_memcpy(par_dot_param + oam_strlen(par_dot_param),
								parameter_token, oam_strlen(parameter_token));
					}
				}

				if(OAM_ZERO == config_flag )
				{   
					ret_datatype = oam_get_param_value(par_dot_param,
							param_val_pair,
							p_error_code);
					if(OAM_ZERO == ret_datatype) {
						resp_status = OAM_ONE; /* here, 1 means failure */
						oam_memset(error_str, OAM_ZERO, STR_LEN_80);
						/* coverity 41291 */
						usr_error_code =OAM_ERR_INVALID_PARAM_NAME; 

						if(param_name_len > MAX_PARAMETER_NAME_LENGTH) 
						{
							oam_sprintf(error_str, "Parameter name too large");
						}
						else 
						{
							oam_sprintf(error_str, "Parameter: %s not found", param_name);
						}

						err_len = oam_strlen(error_str) + OAM_ONE;

						encode_get_params_resp_ctrl_blk(temp_payload, resp_status,
								usr_error_code, OAM_ZERO, OAM_ZERO, err_len,
								error_str);
						ctrl_blk_len = OAM_EIGHT + err_len;
						resp_len = OAM_CSPL_HDR_SIZE + OAM_MGMT_INTF_HEADER_SIZE +
							ctrl_blk_len;

						OAM_LOG(OAM, OAM_WARNING,
								"requesting invalid parameter, par_dot_param, "
								"Skipping...");
						retVal = OAM_FAILURE;
						break;
					}
				}
				p_temp_buf += param_name_len;
				/* The first field in the parameter info is the 2 byte length of
				   parameter info field. The response message will contain the
				   "parameter=value" field, 1 is added to include the full OAM_NULL
				   terminated string. 4 is added for other 4 bytes in the parameter
				   node in the msg(2-byte length field + 2-e reserved field) */
				param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
				param_info_len = param_val_pair_len + OAM_FOUR;
				/* encoding parameter info length */
				/* Coverity Fix: Vivek */
				*(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
				*(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
				*(temp_payload + curr_pos++) = OAM_ZERO;
				*(temp_payload + curr_pos++) = OAM_ZERO;
				/* encoding param=value field */
				oam_memcpy((temp_payload + curr_pos),
						param_val_pair, param_val_pair_len);
				resp_len += param_info_len;
				curr_pos += param_val_pair_len;
			}
		} while(++multi_obj_cnt < max_multi_obj_cnt);
	}
	if(OAM_ONE == config_flag )
	{
		oam_send_config_gpv_resp();
		/* Coverity ID 72195 Fix Start*/
		oam_mem_free(temp_payload, p_error_code);
		/* Coverity ID 72195 Fix End*/
		OAM_FUN_EXIT_TRACE();
		return OAM_SUCCESS;
	} 

	if(resp_status != OAM_RESULT_FAILURE) 
	{
		OAM_LOG(OAM, OAM_DETAILED, "All parameters found successfully.");
		/* All parameters found successfully */
		ctrl_blk_len = OAM_EIGHT;
		resp_len += ctrl_blk_len;
	}

	resp_payload_len = resp_len -
		(OAM_CSPL_HDR_SIZE + OAM_MGMT_INTF_HEADER_SIZE);

	/* allocate enough memory for response message */
	oam_get_params_resp = oam_msg_mem_get(resp_len);
	if(OAM_NULL == oam_get_params_resp) 
	{
		OAM_LOG(OAM,OAM_ERROR, "Memory allocation to "
				"oam_get_params_resp failed");
		*p_error_code = OAM_MALLOC_FAIL;
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}

	oam_memset(oam_get_params_resp, OAM_ZERO, resp_len);
	/* reset the temp buffer pointer to point to allocated response buffer */
	p_temp_buf = oam_get_params_resp; 

	/* encode the CSPL header in the message */
	oam_construct_api_header((UInt8 *)p_temp_buf, OAM_VERSION_ID,
			OAM_MODULE_ID, dst_module_id,
			OAM_GET_PARAMETER_VALUES_RESP,
			resp_len);    
	p_temp_buf += OAM_CSPL_HDR_SIZE;

	/* encode API header in message*/
	oam_construct_mgmt_api_hdr((UInt8 *)p_temp_buf,
			trans_id,
			OAM_MODULE_ID,
			dst_module_id,
			OAM_GET_PARAMETER_VALUES_RESP,
			resp_len - OAM_CSPL_HDR_SIZE,
            /*SPR 17777 fix*/
			OAM_ZERO);
	p_temp_buf += OAM_MGMT_INTF_HEADER_SIZE;

	/* append the payload so far prepared */
	if(OAM_RESULT_FAILURE == resp_status)
	{  /* Failure case */
		OAM_LOG(OAM, OAM_DETAILED, "Parameter searching failed.");
		oam_memcpy(p_temp_buf, temp_payload, resp_payload_len); 
	}
	else {
		encode_get_params_resp_ctrl_blk((char *)p_temp_buf, resp_status,
				OAM_ZERO, OAM_ZERO, OAM_ZERO, OAM_ZERO,
				OAM_NULL);
		p_temp_buf += ctrl_blk_len;
		resp_payload_len -= ctrl_blk_len;
		oam_memcpy(p_temp_buf, temp_payload, resp_payload_len); 

		/* re-encode the message length in parent info with actual size */
		*(p_temp_buf + OAM_ZERO) = (resp_payload_len & 0xff00) >> OAM_EIGHT;
		*(p_temp_buf + OAM_ONE) = (resp_payload_len & OAM_ALL_8_BIT_SET);

		/* Re-encode the start-index, end-index and num_params  fields in  the
		 * parent info block if the GPV request was partial parent GPV request
		 */
		if(partial_parent_flag) {
			/* New value of number of parameters in ParentInfo block will be
			 * number of instances times number of parameters per instance
			 */
            /* SPR 15527 START */
            UInt16 temp_num_par = num_params * (UInt16)multi_obj_cnt;
			*(p_temp_buf + OAM_TWO) = (temp_num_par & OAM_ALL_8_BIT_SET);
            /* SPR 15527 END */
			*(p_temp_buf + OAM_THREE) = OAM_ONE;
			*(p_temp_buf + OAM_FOUR) = multi_obj_cnt;
            /* SPR 15527 START */
            *(p_temp_buf + OAM_FIVE) = (temp_num_par & 0xff00) >> OAM_EIGHT;
            /* SPR 15527 END */
		}
		if(partial_path_flag) {
			/* New value of number of parameters in ParentInfo block will be
			 * number of instances times number of parameters per instance
			 */
           /* SPR 15527 START */
			*(p_temp_buf + OAM_TWO) =  (num_params & OAM_ALL_8_BIT_SET);
            /* SPR 15527 END */
			*(p_temp_buf + OAM_THREE) = OAM_ZERO;
			*(p_temp_buf + OAM_FOUR) = OAM_ZERO;
            /* SPR 15527 START */
               *(p_temp_buf + OAM_FIVE) = (num_params & 0xff00) >> OAM_EIGHT;
            /* SPR 15527 END */
		}
	}

	/* send the response message */
	oam_send_message(oam_get_params_resp, dst_module_id, p_error_code);
	if(*p_error_code != NO_ERROR) 
	{
		OAM_LOG(OAM, OAM_ERROR,
				"Error in Sending message with error code %d", *p_error_code);
		/* Coverity ID : 79012 Fix Start */
		/*  retVal = OAM_FAILURE;   */
		return OAM_FAILURE;
		/* Coverity ID : 79012 Fix End */
	}

    /* SPR 14630 Fix Start */
    oam_mem_free(temp_payload,p_error_code);
    /* SPR 14630 Fix End */
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
	/*CID:64759 end*/
}
/******************************************************************************
 * Function Name  : oam_fill_rrm_oam_ue_release_req
 * Inputs         : p_rrm_oam_ue_release_req 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : this function handles the GET param command
 *******************************************************************************/
oam_return_et
oam_fill_rrm_oam_ue_release_req
(
 oam_rrm_ue_release_req_t  *p_rrm_oam_ue_release_req           /* Pointer to API specific information. */
 )
{
	oam_counter_t loop_counter = OAM_ZERO;  
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	for(loop_counter= OAM_ZERO;loop_counter<MAX_MCC_DIGITS; loop_counter++)
	{
		p_rrm_oam_ue_release_req->global_cell_id.primary_plmn_id.mcc[loop_counter]  =
			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.primary_plmn_id.mcc[loop_counter]; 
	}
	p_rrm_oam_ue_release_req->global_cell_id.primary_plmn_id.num_mnc_digit  =
		RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.primary_plmn_id.num_mnc_digit;
	for(loop_counter= OAM_ZERO;loop_counter<MAX_MNC_DIGITS; loop_counter++)
	{
		p_rrm_oam_ue_release_req->global_cell_id.primary_plmn_id.mnc[loop_counter]  =
			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.primary_plmn_id.mnc[loop_counter];
	}
	for(loop_counter= OAM_ZERO;loop_counter< OAM_FOUR; loop_counter++)
	{
		p_rrm_oam_ue_release_req->global_cell_id.cell_identity[loop_counter] =
			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.cell_identity[loop_counter];
	}
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}

/*CSR 00051094 start*/
/******************************************************************************
 * Function Name  : oam_get_egtpustats
 * Inputs         : stats_type,reset,trans_id
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : this function handles the GET param command
 *******************************************************************************/
oam_return_et oam_get_egtpustats(char *stats_type , char *reset, UInt16 trans_id)
{

	relayGtpuGetStatsReq oam_egtpu_stats_req;
	oam_error_code_et p_error_code;

	if(oam_strcmp(stats_type,"EGTPU_STATS_PROTO_MSG") ==0 )
	{
		oam_egtpu_stats_req.statsType=0;
	}else 
		if(oam_strcmp(stats_type,"EGTPU_STATS_API") ==0 )
		{
			oam_egtpu_stats_req.statsType=1;
		}else 
			if(oam_strcmp(stats_type,"EGTPU_STATS_ERROR") ==0 )
			{
				oam_egtpu_stats_req.statsType=2;
			}else 
				if(oam_strcmp(stats_type,"EGTPU_STATS_INTERNAL") ==0 )
				{
					oam_egtpu_stats_req.statsType=3;
				}else 
					if(oam_strcmp(stats_type,"EGTPU_STATS_ERR_PROTO_MSG") ==0 )
					{
						oam_egtpu_stats_req.statsType=4;
					}

				if(oam_strcmp(reset,"RESET") ==0 )
				{
					oam_egtpu_stats_req.resetFlag=0;
				}else
					if(oam_strcmp(reset,"NOT_RESET") ==0 )
					{
						oam_egtpu_stats_req.resetFlag=1;
					}

				if(OAM_FAILURE==oam_send_egtpu_stats_req(&oam_egtpu_stats_req,OAM_MODULE_ID,trans_id,&p_error_code))
				{
					OAM_LOG(OAM,OAM_ERROR,"Failed to send egtpu stats reqest, statsType = %d ", oam_egtpu_stats_req.statsType );
					return OAM_FAILURE;
				}

				return OAM_SUCCESS;
}
/*CSR 00051094 start*/

/******************************************************************************
 * Function Name  : oam_ecn_init
 * Inputs         : none
 * Outputs        : none
 * Returns        : none
 * Description    : this function handles the ecn init
 *******************************************************************************/
/* + SPR 17439 */
	void 
oam_ecn_init(void)
{
/* - SPR 17439 */
	oam_ul_dl_qci_cli_input.qci = OAM_ZERO;
	oam_ul_dl_qci_cli_input.max_bitrate_ul = OAM_ZERO;
	oam_ul_dl_qci_cli_input.min_bitrate_ul = OAM_ZERO;
	oam_ul_dl_qci_cli_input.max_bitrate_dl = OAM_ZERO;
	oam_ul_dl_qci_cli_input.min_bitrate_dl = OAM_ZERO;
	oam_ul_dl_qci_cli_input.num_of_ue = OAM_ZERO ;
	oam_ul_dl_qci_cli_input.bitmask = OAM_ZERO ;

}

/*******************************************************************************
 * * Function Name: oam_rrm_config_capacity_enc_handling
 * * Description  : This function takes in buffer and sets parameter value 
 * *                corresponding to string in oam_prov_req_t structure
 * *                oam_rrm_module_init_config_t
 * * Inputs       : p_api_buf : pointer to input buffer
 * *                msg_len : length of parameter set command
 * *                src_module_id :
 * * Outputs      : NONE
 * * Returns      : OAM_SUCCESS\OAM_FAILURE 
 * ********************************************************************************/
oam_return_et
oam_rrm_config_capacity_enc_handling
(
 char *parent_parameter_name,
 oam_ul_dl_qci_cli_input_t *oam_ul_dl_qci_cli_inp,
 char *value 

 )
{
	if(oam_strncasecmp(parent_parameter_name,"Enable.RRM.ECNCapacityEnhancement.UL_Bitrate_Max",
				oam_strlen("Enable.RRM.ECNCapacityEnhancement.UL_Bitrate_Max"))== OAM_ZERO)
	{
		oam_ul_dl_qci_cli_inp->max_bitrate_ul = (UInt64)(oam_atoi(value)); 
		oam_ul_dl_qci_cli_inp->bitmask = oam_ul_dl_qci_cli_inp->bitmask | OAM_RRM_ECN_UL_MAX;
	}
	else if(oam_strncasecmp(parent_parameter_name,"Enable.RRM.ECNCapacityEnhancement.UL_Bitrate_Min",
				oam_strlen("Enable.RRM.ECNCapacityEnhancement.UL_Bitrate_Min"))== OAM_ZERO)
	{
		oam_ul_dl_qci_cli_inp->min_bitrate_ul = (UInt64)(oam_atoi(value));
		oam_ul_dl_qci_cli_inp->bitmask = oam_ul_dl_qci_cli_inp->bitmask | OAM_RRM_ECN_UL_MIN;

	}
	else if(oam_strncasecmp(parent_parameter_name,"Enable.RRM.ECNCapacityEnhancement.QCI_Number",
				oam_strlen("Enable.RRM.ECNCapacityEnhancement.QCI_Number"))== OAM_ZERO)
	{
		oam_ul_dl_qci_cli_inp->qci = (UInt8)(oam_atoi(value));
		RRM_PROV_REQ.oam_ecn_req.ecn_cells[OAM_ZERO].bitrate.bitrate_for_qci[OAM_ZERO].qci = (UInt8)(oam_atoi(value));
	}
	else if(oam_strncasecmp(parent_parameter_name,"Enable.RRM.ECNCapacityEnhancement.DL_Bitrate_Max",
				oam_strlen("Enable.RRM.ECNCapacityEnhancement.DL_Bitrate_Max"))== OAM_ZERO)
	{
		oam_ul_dl_qci_cli_inp->max_bitrate_dl = (UInt64)(oam_atoi(value));
		oam_ul_dl_qci_cli_inp->bitmask = oam_ul_dl_qci_cli_inp->bitmask | OAM_RRM_ECN_DL_MAX;
	}
	else if(oam_strncasecmp(parent_parameter_name,"Enable.RRM.ECNCapacityEnhancement.DL_Bitrate_Min",
				oam_strlen("Enable.RRM.ECNCapacityEnhancement.DL_Bitrate_Min"))== OAM_ZERO)
	{
		oam_ul_dl_qci_cli_inp->min_bitrate_dl = (UInt64)(oam_atoi(value));
		oam_ul_dl_qci_cli_inp->bitmask = oam_ul_dl_qci_cli_inp->bitmask | OAM_RRM_ECN_DL_MIN;
	}
	else if(oam_strncasecmp(parent_parameter_name,"Enable.RRM.ECNCapacityEnhancement.NumberOfUe",
				oam_strlen("Enable.RRM.ECNCapacityEnhancement.NumberOfUe"))== OAM_ZERO)
	{
		oam_ul_dl_qci_cli_inp->num_of_ue = (UInt8)(oam_atoi(value));
	}


	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;

}

/*******************************************************************************
 * Function Name: oam_fill_ecn_cells
 * Description  : 
 * Inputs       : qci : 
 *                ul_max_bitrate : 
 *                ul_min_bitrate : 
 *                dl_max_bitrate :
 *                dl_min_bitrate :
 *                ue_num_count :    
 * Outputs      : p_oam_rrm_cell_ecn_capacity_enhance_req : pointer to output structure
 * Returns      : OAM_SUCCESS\OAM_FAILURE 
 ********************************************************************************/
oam_return_et
oam_fill_ecn_cells
(
 rrm_oam_cell_ecn_capacity_enhance_req_t *p_oam_rrm_cell_ecn_capacity_enhance_req,
 oam_ul_dl_qci_cli_input_t oam_ul_dl_qci_cli_inp,
 SInt8 ue_num_count)
{
	UInt8    index =  OAM_ZERO;
	UInt8    index_bitrate_qci = OAM_ZERO ;
	oam_return_et ret_val = OAM_SUCCESS;
	oam_counter_t loop_counter = OAM_ZERO;

	OAM_FUN_ENTRY_TRACE();

	if((ue_num_count < -1) || (ue_num_count >100))

	{
		OAM_FUN_EXIT_TRACE(); /*Coverity FIX 36186 */
		return OAM_FAILURE;
	}


	p_oam_rrm_cell_ecn_capacity_enhance_req->count  =  OAM_ONE;
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	index = OAM_ZERO ; 
	for(loop_counter=OAM_ZERO;loop_counter<MAX_MCC_DIGITS; loop_counter++)

	{
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].global_cell_id.primary_plmn_id.mcc[loop_counter] =
			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
			eutran_global_cell_id.primary_plmn_id.mcc[loop_counter];
	}
	p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].global_cell_id.primary_plmn_id.num_mnc_digit  =
		RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
		eutran_global_cell_id.primary_plmn_id.num_mnc_digit;

	for(loop_counter=0;loop_counter<MAX_MNC_DIGITS; loop_counter++)
	{
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].global_cell_id.primary_plmn_id.mnc[loop_counter]  =
			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
			eutran_global_cell_id.primary_plmn_id.mnc[loop_counter];
	}
	for(loop_counter=0;loop_counter< OAM_FOUR; loop_counter++)
	{
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].global_cell_id.cell_identity[loop_counter] =
			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.cell_identity[loop_counter];
	}


	p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].num_of_ue = ue_num_count;
	p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.count = OAM_ONE ;

	index_bitrate_qci =  OAM_ZERO;


	if(OAM_TRUE == Config_CapacityEnc_dis_flag)
	{
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].bitmask = OAM_ZERO;
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].qci  = OAM_ONE;
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].ul_bitrate.max_bitrate = OAM_ZERO;
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].ul_bitrate.min_bitrate = OAM_ZERO;
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].dl_bitrate.max_bitrate = OAM_ZERO;
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].dl_bitrate.min_bitrate = OAM_ZERO;    
	}
	else
	{
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].bitmask = OAM_ZERO;
		p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].qci  = oam_ul_dl_qci_cli_inp.qci;
		if(oam_ul_dl_qci_cli_inp.bitmask & OAM_RRM_ECN_UL_MAX){
			p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].ul_bitrate.max_bitrate = oam_ul_dl_qci_cli_inp.max_bitrate_ul;
			p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].bitmask |= RRM_OAM_ECN_UL_BITRATE_PRESENT;
		}
		if(oam_ul_dl_qci_cli_inp.bitmask & OAM_RRM_ECN_UL_MIN){
			p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].ul_bitrate.min_bitrate = oam_ul_dl_qci_cli_inp.min_bitrate_ul;
			p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].bitmask |= RRM_OAM_ECN_UL_BITRATE_PRESENT;
		}
		if(oam_ul_dl_qci_cli_inp.bitmask & OAM_RRM_ECN_DL_MAX){
			p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].dl_bitrate.max_bitrate = oam_ul_dl_qci_cli_inp.max_bitrate_dl;
			p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].bitmask |= RRM_OAM_ECN_DL_BITRATE_PRESENT;
		}
		if(oam_ul_dl_qci_cli_inp.bitmask & OAM_RRM_ECN_DL_MIN){
			p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].dl_bitrate.min_bitrate = oam_ul_dl_qci_cli_inp.min_bitrate_dl;
			p_oam_rrm_cell_ecn_capacity_enhance_req->ecn_cells[index].bitrate.bitrate_for_qci[index_bitrate_qci].bitmask |= RRM_OAM_ECN_DL_BITRATE_PRESENT;
		}
	}

	OAM_FUN_EXIT_TRACE();
	return ret_val;
}
/*******************************************************************************
 * Function Name: oam_persist_one_parameter
 * Description  :
 * Inputs       : parent,tag_name,p_value
 * Outputs      : None
 * Returns      : None
 ********************************************************************************/
void oam_persist_one_parameter(xmlNode  *parent,
		Char8    *tag_name,
		UInt8    *p_value)
{
	xmlNode *p_xml_node = OAM_NULL;
	/*finding pointer to node*/
	p_xml_node = oam_xml_find_tag(parent->children,
			(xmlChar*)tag_name);
	/* Enabling this code for parameter persistence */
	/*setting content of the node*/
	xmlNodeSetContent(p_xml_node, p_value);

	return;
}

/* SPR 14498 START */
/*******************************************************************************
 * Function Name: oam_persist_one_multi_instance_parameter
 * Description  : This function persists one parameter of a multi instance object.
 * Inputs       : parent: pointer to the parent node of xml object
 *                tag_name : Parameter tag Name
 *                p_value : Value of the Parameter
 *                index : Instance ID
 * Outputs      : NONE
 * Returns      : NONE
 ********************************************************************************/
void oam_persist_one_multi_instance_parameter(xmlNode  *parent,
        Char8    *tag_name,
        UInt8    *p_value,
        UInt8     index)
{
    xmlNode *p_xml_node = OAM_NULL;
    UInt8 inst_id_val = OAM_ZERO;
    xmlNode *temp = parent;
    /*finding pointer to node*/

    while(OAM_NULL != temp) {
        p_xml_node = oam_xml_find_tag(temp->children,
                (xmlChar*)"X_VENDOR_INSTANCE_ID");
        if(p_xml_node != OAM_NULL)
        {
            inst_id_val = oam_atoi((Char8*)xmlNodeGetContent(p_xml_node));
            OAM_LOG(OAM, OAM_INFO, "Object instance id in xml %d", inst_id_val);
            if (inst_id_val == index)
            {
                /* Instance found for which the parameter nedds to be updated */
                p_xml_node = oam_xml_find_tag(temp->children,
                        (xmlChar*)tag_name);
                if(p_xml_node != OAM_NULL)
                {
                    /*setting content of the node*/
                    xmlNodeSetContent(p_xml_node, p_value);
                }
                else
                    OAM_LOG(OAM, OAM_WARNING, "Tag %s not found in the %d Instance of the Object",tag_name, inst_id_val);

                break;
            }
        }
        /* Move to next instance of object */
        temp = (temp)->next;
    }
    if(OAM_NULL == temp)
        OAM_LOG(OAM, OAM_WARNING, "%d Instance of the Object not found in the dom",inst_id_val);

    return;
}
/* SPR 14498 END */


/******************************************************************************
 *  FUNCTION NAME: oam_handle_software_upgrade_from_cli_or_snmp
 *  DESCRIPTION  : This function sends upgrade request to SDM when
 *  trigger point is SNMP or CLI.
 *      
 *  Inputs       : filename 
 *  Output       : 
 *  RETURNS: OAM_TRUE/OAM_FALSE
 ******************************************************************************/
	static oam_return_et
oam_handle_software_upgrade_from_cli_or_snmp(UInt8 *file_name_from_interface,
		UInt8 *p_api_buf)
{

	UInt32 file_size = OAM_ZERO;
	UInt16 file_name_length = OAM_ZERO,file_des_len = OAM_ZERO;
	UInt8 file_des[STR_LEN_64]="Firmware Upgrade Image";
	UInt16 transaction_id =OAM_ZERO;
	UInt16 msg_len = OAM_ZERO;
	UInt8 *p_temp_buf= OAM_NULL;
	UInt16 result = OAM_ZERO;
	UInt16 dest_id = OAM_ZERO;
	oam_error_code_et error_code = NO_ERROR; 
	UInt8 file_name[STR_LEN_256]={0};
	oam_memset(file_name, 0x00, STR_LEN_256);

	/* Spr 12880 Fix Start*/
	UInt8 CellId = OAM_INVALID_CELL_ID; 
	/* Spr 12880 Fix Start*/
	/*Append Path In front of the Image Name*/
	oam_strncpy((char*)file_name, (char *)local_prov_req.oam_nms_ftp_server_params.local_download_upload_path,
			oam_strlen((char *)local_prov_req.oam_nms_ftp_server_params.local_download_upload_path));
	oam_strncat((char*)file_name, (char*)file_name_from_interface, oam_strlen((char*)file_name_from_interface));
	/*Integerity Check for Downloaded file */
	result = oam_check_file_integerity(file_name);

	transaction_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_ZERO);
	dest_id  = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_HDR_SRC_ID_OFFSET); /*Src ID is Now Destination ID*/

	/* Integrity check Successful */
	if(OAM_SUCCESS == result)
	{
		file_name_length = oam_strlen((char *)file_name);
		file_des_len = oam_strlen((char *)file_des);
		msg_len = OAM_CSPL_HDR_SIZE+OAM_MGMT_INTF_HEADER_SIZE;
		msg_len += 4 * sizeof(UInt32);
		msg_len += file_name_length +1;
		msg_len += sizeof(UInt16);
		msg_len += sizeof(UInt32) +file_des_len +1;

		p_temp_buf = (UInt8 *)oam_construct_sdm_start_upgrade_req(file_size,OAM_ONE /*Firmware Upgrade*/,
				file_des_len,file_name_length,file_name,file_des,&msg_len);

		g_upgrade_req_retry_counter= OAM_ZERO;
		if(OAM_NULL != p_temp_buf)
        {
            if (OAM_FAILURE == oam_send_sdm_start_upgrade_req(p_temp_buf))
            {
                /*coverity_85518 ++*/
                /*  coverity 94916 fix start */
                /* code removed */
                /*  coverity 94916 fix end */
                /*coverity_85518 --*/
                OAM_LOG(OAM,OAM_DETAILED,"Failure In Sending Message to SDM");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
			/* SPR 19444 FIXED START */
			OAM_LOG(OAM,OAM_DETAILED,"Message Sent to SDM ....");
			/* SPR 19444 FIXED END */
        }
		oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
				OAM_ZERO,OAM_NULL,OAM_ZERO,
				OAM_VERSION_ID, OAM_MODULE_ID,
				dest_id, transaction_id, OAM_ZERO, OAM_ZERO,
				&error_code);

		OAM_LOG(OAM,OAM_DETAILED,"Waiting For Shutdown ACK from SDM");

		OAM_FUN_EXIT_TRACE();
		return OAM_SUCCESS;
	}
	else
	{
		oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
				OAM_ERR_FILE_ACCESS_FAILURE,(UInt8 *)"File Integrity Check Failure",
				sizeof("File Integrity Check Failure"),
				OAM_VERSION_ID, OAM_MODULE_ID,
				dest_id, transaction_id, OAM_ZERO, OAM_ZERO,
				&error_code);
		OAM_ALARM(OAM_PKG_INTEGRITY_CHECK_FAILURE_ALARM_ID,MINOR,NOTIFY_NEW_ALARM,
				INTEGRITY_VIOLATION, SOFTWARE_PROGRAM_ERROR,
				EXPEDITED_ALARM,"File Integrity Check Failure",
				/* Spr 12880 Fix Start*/
				OAM_NULL,CellId); 
		/* Spr 12880 Fix End*/

		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}
}

/******************************************************************************
 *  FUNCTION NAME: oam_validate_pm_params
 *  DESCRIPTION  : This function oam validate PM param
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : parent_parameter_name,value
 *  Output       : None
 *  RETURNS: OAM_TRUE/OAM_FALSE
 ******************************************************************************/
	LOCAL oam_return_et
oam_validate_pm_params(char* parent_parameter_name, UInt32 value)
{
	oam_return_et retval = OAM_SUCCESS;

	if(NULL != oam_strstr(parent_parameter_name,"PeriodicUploadInterval"))
	{
		if ((value != OAM_PERIODIC_INTERVAL_FOR_HOUR) && 
				(value != OAM_PERIODIC_INTERVAL_FOR_DAY))
		{
			retval = OAM_FAILURE;
		}
	}
	if(NULL != oam_strstr(parent_parameter_name,"sampling_interval_timer"))
	{
		if ((value < OAM_MIN_SAMPLING_INTERVAL) ||
				(value > OAM_MAX_SAMPLING_INTERVAL))
		{
			retval = OAM_FAILURE;
            /*SPR 20171 Start */
            OAM_LOG(OAM, OAM_DETAILED, "returning Failure Value %d",value);
            /*SPR 20171 End */

		}
	}
	if(NULL != oam_strstr(parent_parameter_name,"file_write_timer"))
	{
		if ((value < OAM_MIN_FILE_WRITE_INTERVAL) ||
				(value > OAM_MAX_FILE_WRITE_INTERVAL))
		{
			retval = OAM_FAILURE;
		}
	}

	return retval;
}

/******************************************************************************
 *  FUNCTION NAME: oam_validate_upload_time
 *  DESCRIPTION  : This function oam validate upload time
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : None
 *  Output       : None
 *  RETURNS: OAM_TRUE/OAM_FALSE
 ******************************************************************************/
	LOCAL oam_return_et
oam_validate_upload_time(char* upload_time)
{
	UInt8 count = OAM_ZERO;
	UInt8 len= oam_strlen(upload_time);
	UInt8 value[25];
	struct tm time_struct;
	time_t now = OAM_TIME(NULL);
	time_t uploadTime = OAM_TIME(NULL);
	UInt16 scanresult = 0;
	OAM_GMTIME(&now); 
	char a, b;
	/*Coverity Fix 55195*/
	oam_memset(&value, 0x00, 25);
	/*Coverity Fix 55195*/
	OAM_LOG(OAM,OAM_DETAILED,"current time::%s", OAM_CTIME(&now));
	scanresult =  snscanf( upload_time, sizeof(time_struct.tm_year)+sizeof(time_struct.tm_mon)+
			sizeof(time_struct.tm_mday)+sizeof(a)+sizeof(time_struct.tm_hour)+
			sizeof(time_struct.tm_min)+sizeof(time_struct.tm_sec)+sizeof(b)+OAM_FIVE,
			"%d-%d-%d%c%d:%d:%d%c",
			&time_struct.tm_year,
			&time_struct.tm_mon,
			&time_struct.tm_mday,&a,
			&time_struct.tm_hour,
			&time_struct.tm_min,
			&time_struct.tm_sec,&b);

	time_struct.tm_year -= 1900;
	/* CSR00070207 FIX*/
	time_struct.tm_mon -= 1;
	/* CSR00070207 FIX*/
	time_struct.tm_isdst= 0;
	uploadTime = OAM_MKTIME(&time_struct);
	if(uploadTime == -1)
	{
		OAM_LOG(OAM,OAM_WARNING,"Upload Time Entered is in invalid");
		return OAM_FAILURE;
	}
	OAM_LOG(OAM,OAM_DETAILED,"UploadTime read after parsing the string entered::%s %d",
			OAM_CTIME(&uploadTime), scanresult);
	OAM_LOG(OAM,OAM_DETAILED,"Current Time of the system::%s",
			OAM_CTIME(&now));

	if (now > uploadTime)
	{
		OAM_LOG(OAM,OAM_INFO,"Periodic Time Entered is in Past");
		return OAM_FAILURE;
	}
	oam_strncpy((char *)value, (const char *)upload_time, len);
	if (len < 19)
	{
		return OAM_FAILURE;
	}
	for(count = 0; count<len; count++)
	{
		if ((count==4)||(count==7))
		{
			if(value[count]!='-')
			{
				return OAM_FAILURE;
			}
		}
		else if(count==10)
		{
			if (value[count]!='T')
			{
				return OAM_FAILURE;
			}
		}
		else if((count== 13)||(count== 16))
		{
			if (value[count]!=':')
			{
				return OAM_FAILURE;
			}
		}
		else if(count==19)
		{
			if (value[count]!='Z')
			{
				return OAM_FAILURE;
			}
		}
		else
		{
			if((value[count]>=48) && (value[count]<=57))
			{
				continue;
			}
			else
			{
				return OAM_FAILURE;
			}
		}
	}
	return OAM_SUCCESS;
}

/*******************************************************************************
 * Function Name: oam_set_parameter_values_api_handler
 * Description  : This function takes in buffer and sets parameter value 
 *                corresponding to string in oam_prov_req_t structure
 *                oam_rrm_module_init_config_t
 * Inputs       : p_api_buf : pointer to input buffer
 *                msg_len : length of parameter set command
 *                src_module_id :
 * Outputs      : NONE
 * Returns      : OAM_SUCCESS\OAM_FAILURE 
 ********************************************************************************/
oam_return_et
oam_set_parameter_values_api_handler
(
 void *p_api_buf, 
 UInt16 msg_len, 
 UInt16 src_module_id,
 oam_error_code_et *p_error_code
 )
{
    OAM_FUN_ENTRY_TRACE();

    UInt16 sampling_timer_val = OAM_ZERO;
    UInt16 new_sampling_timer_val = OAM_ZERO;

    SInt8 temp_ue_var = OAM_ZERO;
    /* SPR 12698 FIX START */
    UInt8 temp_ptr[TEMP_PTR_BUFFER_SIZE] = {OAM_ZERO};
    /* SPR 12698 FIX END */
    rrm_oam_cell_ecn_capacity_enhance_req_t  p_oam_rrm_cell_ecn_capacity_enhance_req;         
    UInt8 ue_Release_flag = OAM_FALSE;

    rrm_oam_ue_release_req_t  p_rrm_oam_ue_release_req;           /* Pointer to API specific information. */

    oam_rrc_add_lgw_req_t oam_rrc_add_lgw_req = {OAM_ZERO}; 
    oam_rrc_delete_lgw_req_t oam_rrc_delete_lgw_req = {OAM_ZERO};   
    UInt8 value_flag = OAM_ZERO; 
    UInt8 config_number_of_entries_flag = OAM_ZERO;

    UInt8  Modify_MacQos_flag = OAM_ZERO;
    UInt16 Modify_MacQos_flag_bitmask = OAM_ZERO;  
    oam_set_config_req.flag = OAM_FALSE;
    oam_ul_dl_qci_cli_input.bitmask = OAM_ZERO;
    oam_cell_status_t *p_cell_status = OAM_NULL;

    UInt8 *p_api_buf_temp = p_api_buf;
    UInt8 Number_of_parameters = OAM_ZERO;
    oam_length_t Parent_length = OAM_ZERO;
    oam_length_t parameter_length = OAM_ZERO;
    Char8 Parent_Name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
    oam_bool_et spv_for_pm_xml_params = OAM_FALSE;
    oam_length_t loop = OAM_ZERO;
    UInt16 parameter_name_length = OAM_ZERO;
    Char8* name = OAM_NULL;
    Char8 *value = OAM_NULL;
    Char8 err_str[OAM_USR_INTF_ERR_STR_MAX_SIZE] = {OAM_ZERO};
    UInt8 err_str_len = OAM_ZERO;
    UInt8 usr_resp_code = OAM_ZERO;
    UInt16 usr_resp_err_code = OAM_ZERO;
    void *p_local_req = OAM_NULL;
    oam_bool_et p_local_req_memfree_flag = OAM_FALSE; 

    /*SPR 16151 Fixed Start*/
    Char8 Parameter_Name[MAX_PARAMETER_NAME_LENGTH_VALUE] = {OAM_ZERO};
    char parent_parameter_name[MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH_VALUE];
    /*SPR 16151 Fixed End*/

    UInt16 trans_id = get_word_from_header(p_api_buf_temp);
    /* sender of the msg will be receiver of the response */
    UInt8 dest_id =
        get_word_from_header(p_api_buf_temp + OAM_INTF_HDR_SRC_ID_OFFSET);
    resp_destination_id = dest_id;
    oam_bool_et control_command_flag = OAM_FALSE;
    /*SPR 14451 START*/
    oam_bool_et cell_block_flag = OAM_FALSE;
    /*SPR 14451 END*/
    oam_return_et retVal = OAM_FAILURE;
    SInt8 cell_arr_idx = OAM_ERROR_RETURN_VAL;
    UInt8 recvd_cid = OAM_ZERO;
    oam_bool_et spv_persist_for_pm_xml_params = OAM_FALSE;
    oam_rrm_cell_plmnlist_data_t *p_cell_local_plmnlist_data = OAM_NULL;
    oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
    UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    xmlNode *p_orig_parent = OAM_NULL;
    xmlNode *p_req_parent = OAM_NULL;
    xmlNode **p_p_xml_struct_addr = OAM_NULL;

#ifdef OAM_SON_ENABLE
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    oam_son_rach_opt_enable_req_t *p_son_rach_opt_enable_req = OAM_NULL;
    son_oam_rach_opt_disable_req_t *p_son_rach_opt_disable_req = OAM_NULL;
    oam_son_mro_enable_req_t *p_son_mro_enable_req = OAM_NULL;
    oam_son_mlb_enable_req_t *p_son_mlb_enable_req = OAM_NULL;
    oam_son_mro_disable_req_t *p_son_mro_disable_req = OAM_NULL;
    oam_son_mlb_disable_req_t *p_son_mlb_disable_req = OAM_NULL;
    oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL; 
    oam_son_nr_add_req_t *p_local_son_nr_add = OAM_NULL;
    oam_cell_neighbourlist_info_t *p_local_nr_info = OAM_NULL;
    oam_son_inter_freq_carrier_t
        *p_local_son_inter_freq_carr_params = OAM_NULL;
    oam_son_anr_meas_config_req_t *p_local_anr_meas_config_req = OAM_NULL;
    oam_son_anr_meas_config_req_t *p_anr_meas_config_req = OAM_NULL;
    UInt8 offset = OAM_ZERO;
#endif
    /* spr_21013_fix_start */
    UInt8 fap_index_value = OAM_ZERO;
    UInt8 current_cid = OAM_ZERO;
    /* spr_21013_fix_end */

    /* Spr 12880 Fix Start*/
    UInt8 CellId = OAM_INVALID_CELL_ID; 
    /* Spr 12880 Fix End*/
#ifdef LTE_EMBMS_SUPPORTED
    oam_m2ap_reset_req_t m2ap_reset_req = {OAM_ZERO};
    /* TDD Changes */
    UInt8 sf_alloc_choice = OAM_ZERO;
    UInt8 DuplexMode[OAM_MAX_STR_LEN] = {OAM_ZERO};
    UInt8 tdd_config = OAM_ZERO;
    UInt8 sf_alloc_dec_value[SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE] = {OAM_ZERO};
    UInt8 sf_config_list_count = OAM_ZERO;
    UInt8 max_tokens = OAM_ZERO;
    UInt8 loop_counter = OAM_ZERO;
    UInt8 count = OAM_ZERO;
    UInt8 temp_radio_fr_alloc_period = OAM_ZERO;
    UInt8 temp_sf_alloc_choice = OAM_ZERO;
    UInt8 neigh_cell_config_sib3 = OAM_ZERO;
    UInt8 neigh_cell_config_sib5 = OAM_ZERO;
    UInt8 eutran_meas_cnt = OAM_ZERO;
#endif
    /*SPR 15491 START */
    char num_buffer[100] = {OAM_ZERO};
    /*SPR 15491 END */

    p_api_buf_temp += OAM_MGMT_INTF_HEADER_SIZE;

    paramter_app_map_tbl = OAM_ZERO;


    cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
    if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                cid);
        /* SPR 21390 fix start */
        *p_error_code = OAM_INVALID_CELL_CONTEXT ;
        OAM_FUN_EXIT_TRACE();
        /* SPR 21390 fix end */
        return OAM_FAILURE;
    }

    OAM_LOG(OAM, OAM_DETAILED,
            "Trans_id received in SPV request : %d", trans_id);

    p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE;

    Number_of_parameters = *p_api_buf_temp; 
    ++p_api_buf_temp;
    OAM_LOG(OAM, OAM_DETAILED, "Number of parameters to set:: %d",
            Number_of_parameters);
    ++p_api_buf_temp; /* Reserved byte */
    p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE; /* Reserved word */

    Parent_length = get_word_from_header(p_api_buf_temp);
    p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE;

    oam_memset(&Parent_Name, OAM_ZERO, MAX_PARENT_NAME_LENGTH);
    oam_memcpy(Parent_Name, p_api_buf_temp, Parent_length);
    OAM_LOG(OAM, OAM_DETAILED, "Parent Name: %s", Parent_Name);

    /* spr_21013_fix_start */
    if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services.FAPService.["))
    {
        oam_find_fap_index(Parent_Name,&fap_index_value);

        if((!fap_index_value) || (fap_index_value > oam_prov_req.num_cells_configured))
        {    
            OAM_LOG(OAM, OAM_WARNING, "FAPService INDEX [%d] is either ZERO OR greater num_cells_configured [%d], which is incorrect",
                    fap_index_value,oam_prov_req.num_cells_configured);

            /* SPR 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* SPR 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        current_cid = oam_prov_req.cell_cntxt.cell_ctxt_status[fap_index_value - 1].cid; 

        p_cell_status = oam_get_cell_cntxt_status(current_cid);
        if (p_cell_status) 
        {
            oam_prov_req.cell_cntxt.curr_cell_cid = current_cid;
            cid = oam_prov_req.cell_cntxt.curr_cell_cid;
            cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
            if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
                OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        cid);
                /* SPR 21390 fix start */
                *p_error_code = OAM_INVALID_CELL_CONTEXT;
                OAM_FUN_EXIT_TRACE();
                /* SPR 21390 fix end */
                return OAM_FAILURE;
            }
            usr_resp_code = OAM_RESULT_SUCCESS;
            usr_resp_err_code = OAM_ZERO;
            err_str_len = OAM_ZERO;

            OAM_LOG(OAM, OAM_INFO,"Cell Context Changed to CID: %d, Parent_Name %s, fap_index_value %d", 
                    current_cid,Parent_Name,fap_index_value);

            retVal = OAM_SUCCESS;
        }
        else {
            /* SPR 21390 fix start */
            OAM_LOG(OAM, OAM_WARNING,"Invalid Cell ID: %d Cell Context not changed, Parent_Name %s, fap_index_value %d",
                    current_cid,Parent_Name,fap_index_value);
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
            /* SPR 21390 fix end */
        }    
    }

    p_api_buf_temp += Parent_length;

    /*Code add to add the parameter in the multiple table*/
    if (!oam_strcmp(Parent_Name, "Cell_Context.Context")) {
        g_parameter_map_element = g_parameter_cell_context;
        parameter_length = get_word_from_header(p_api_buf_temp);
        /* Two bytes for parent info block length */
        p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE; 
        /* Two reserved bytes */
        p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE;
        parameter_name_length = parameter_length
            - (OAM_WORD_SIZE_IN_BYTE + OAM_WORD_SIZE_IN_BYTE);
        /*SPR 16151 Fixed Start*/
        if((parameter_length != 0) &&(OAM_ZERO != Number_of_parameters))
        {
            oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH_VALUE);
            oam_memcpy(Parameter_Name, p_api_buf_temp, parameter_name_length);
            oam_memset(&parent_parameter_name, OAM_ZERO,
                    MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH_VALUE);
        } 
        /*SPR 16151 Fixed End*/
        p_api_buf_temp += parameter_length;

        name = oam_strtok(Parameter_Name, "=");
        OAM_NULL_CHECK(OAM_NULL != name);/* Coverity FIX 35436-7 */
        OAM_LOG(OAM, OAM_DETAILED, "Parameter Name: %s", Parameter_Name);

        value = oam_strtok(OAM_NULL, "=");
        OAM_NULL_CHECK(OAM_NULL != value);
        recvd_cid = oam_atoi(value);/* Coverity FIX 35436-8 */

        p_cell_status = oam_get_cell_cntxt_status(recvd_cid);
        if (p_cell_status) {
            oam_prov_req.cell_cntxt.curr_cell_cid = recvd_cid;
            usr_resp_code = OAM_RESULT_SUCCESS;
            usr_resp_err_code = OAM_ZERO;
            err_str_len = OAM_ZERO;

            OAM_LOG(OAM, OAM_INFO,
                    "Cell Context Changed to CID: %d", recvd_cid);
            retVal = OAM_SUCCESS;
            /* SPR 21390 fix start */
            oam_construct_n_send_set_resp_to_usr(usr_resp_code,
                    usr_resp_err_code,
                    (UInt8*)err_str,
                    err_str_len,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id, trans_id,
                    OAM_ZERO, OAM_ZERO,
                    p_error_code);
        }
  /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    else if (!oam_strcmp(Parent_Name,
                "MBMS.Reset.Session"))
    {
        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
        {
            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mce_link_status)
        {
            *p_error_code = OAM_M2AP_MCE_LINK_DOWN;
            OAM_LOG(OAM, OAM_ERROR, "M2AP-MCE link is down");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        /* 7.0 OAM_SSI Fix Start */
        oam_memset(&m2ap_reset_req, 0, sizeof(oam_m2ap_reset_req_t));

        if (Number_of_parameters)
        {
            parameter_length = get_word_from_header(p_api_buf_temp);
            /* Two bytes for parent info block length */
            p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE; 
            /* Two reserved bytes */
            p_api_buf_temp += OAM_WORD_SIZE_IN_BYTE;
            parameter_name_length = parameter_length
                - (OAM_WORD_SIZE_IN_BYTE + OAM_WORD_SIZE_IN_BYTE);
            oam_memset(Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH);
            oam_memcpy(Parameter_Name, p_api_buf_temp, parameter_name_length);
            p_api_buf_temp += parameter_length;

            name = oam_strtok(Parameter_Name, "=");
            OAM_LOG(OAM, OAM_DETAILED, "Parameter Name: %s", Parameter_Name);

            value = oam_strtok(OAM_NULL, "=");

            m2ap_reset_req.bitmask |= RESET_PARTIAL_PRESENT;
            m2ap_reset_req.num_sessions = oam_tokenize_string_to_u16(
                    value,
                    ",",
                    MAX_NUM_SESSIONS,
                    m2ap_reset_req.session_id);
        }
        else
        {
            m2ap_reset_req.bitmask |= RESET_ALL_PRESENT;
        }
        retVal = oam_m2ap_il_send_oam_m2ap_reset_req(&m2ap_reset_req,
                src_module_id,
                RRC_MODULE_ID,
                trans_id,
                oam_prov_req.cell_cntxt.curr_cell_cid);
        /* 7.0 OAM_SSI Fix End */
        if (OAM_FAILURE == retVal)
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Error in sending OAM_M2AP_RESET_REQ");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else
        {
            OAM_LOG(OAM, OAM_DETAILED,
                    "Successfully sent OAM_M2AP_RESET_REQ");
#ifndef OAM_UT_FRAMEWORK
            retVal = oam_maintain_tcb(trans_id,
                    OAM_TRANS_M2AP,
                    msg_len,
                    p_api_buf);
            if (OAM_FAILURE == retVal)
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
#endif
        }
        OAM_FUN_EXIT_TRACE();
        return retVal;

    }
    else if (!oam_strcmp(Parent_Name,
                "eNodeBParams.stack_config.L3Params.M2AP"))
    {
        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
        {
            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mce_link_status)
        {
            *p_error_code = OAM_M2AP_MCE_LINK_DOWN;
            OAM_LOG(OAM, OAM_ERROR, "M2AP-MCE link is down");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        g_parameter_map_element = g_parameter_mbsfn_non_tr196_params;
        p_local_req = &LOCAL_M2AP_PROV_REQ;
        oam_memcpy(p_local_req, &M2AP_PROV_REQ,
                sizeof(oam_m2ap_provision_req_t));
    }
    else if (!oam_strncmp(Parent_Name, "InternetGatewayDevice.Services."
                "FAPService.[1].CellConfig.LTE.RAN.PHY.MBSFN.SFConfigList", 
                oam_strlen("InternetGatewayDevice.Services.FAPService.[1]."
                    "CellConfig.LTE.RAN.PHY.MBSFN.SFConfigList"))
            )
    {
        cell_arr_idx = oam_get_m2ap_cell_config_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) 
        {
            OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                    cid);
            *p_error_code = OAM_NULL_POINTER_ERR;

            OAM_FUN_ENTRY_TRACE();
            return OAM_FAILURE;
        }
        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
        {
            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mce_link_status)
        {
            *p_error_code = OAM_M2AP_MCE_LINK_DOWN;
            OAM_LOG(OAM, OAM_ERROR, "M2AP-MCE link is down");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else if (!(oam_prov_req.oam_l3_req.oam_m2ap_req.mbsfn_cell_data[
                    cell_arr_idx].oam_is_sib2_embms_enable))
        {

            *p_error_code = OAM_MBMS_SIB2_IS_DISABLED;
            OAM_LOG(OAM, OAM_ERROR, "\n Cannot reconfigure sib2 params,"
                    " as sib2 is disabled at init time");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else if (OAM_FAILURE == oam_validate_sib2_params(
                    p_api_buf,
                    Number_of_parameters)
                )
        {
            *p_error_code = OAM_MBMS_SIB2_IS_DISABLED;
            OAM_LOG(OAM, OAM_ERROR, "\nOperator can't reconfigure "
                    "SIB2 Params with UL Subframes in SubframeAllocation"
                    " param in TDDMode");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        g_parameter_map_element = g_parameter_sfconfig_list_params;
        cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
            OAM_LOG(OAM, OAM_ERROR, "Invalid cell context");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        oam_memcpy(&LOCAL_RRM_CELL_CONFIG(cell_arr_idx),
                &RRM_CELL_CONFIG(cell_arr_idx),
                sizeof(rrm_oam_cell_config_req_t));

        retVal = oam_mem_alloc(sizeof(rrm_oam_cell_reconfig_req_t),
                &p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR, "Error in memory allocation");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        p_local_req_memfree_flag = OAM_TRUE;
        oam_memset(p_local_req, 0, sizeof(rrm_oam_cell_reconfig_req_t));
    }
    else if (!oam_strcmp(Parent_Name, "InternetGatewayDevice.Services."
                "FAPService.[1].CellConfig.LTE.RAN.PHY."
                "MBSFN.MBSFN_SERVICE_AREA_CONFIG"))
    {
        cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) 
        {
            OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                    cid);
            *p_error_code = OAM_NULL_POINTER_ERR;

            OAM_FUN_ENTRY_TRACE();
            return OAM_FAILURE;
        }
        /* 7.0 OAM_SSI Fix +- */

        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
        {
            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        /* 7.0 OAM_SSI Fix +- */
        /* SPR 18653 Fix Start */ 
        sf_config_list_count = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).ran_info.
            physical_layer_params.
            mbsfn_subframe_config_list.count;

        while (count < sf_config_list_count)
        {
            temp_radio_fr_alloc_period = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                physical_layer_params.mbsfn_subframe_config_list.
                mbsfn_subframe_config_info[count].radio_frame_allocation_period;

            temp_sf_alloc_choice = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                physical_layer_params.mbsfn_subframe_config_list.
                mbsfn_subframe_config_info[count].
                subframe_allocation.sf_alloc_choice;

            if (((RRM_OAM_FRAME_ALLOCATION_PERIOD_N1 == 
                            temp_radio_fr_alloc_period) ||
                        (RRM_OAM_FRAME_ALLOCATION_PERIOD_N2 ==
                         temp_radio_fr_alloc_period)) &&
                    (FOUR_FRAME_ALLOC == temp_sf_alloc_choice))
        {
            *p_error_code = OAM_MBMS_SIB2_IS_DISABLED;
            OAM_LOG(OAM, OAM_ERROR, "\nOperator can't configure EMBMS as"
                    " RadioFrameAllocationPeriod %d and"
                    " RadioframeAllocationSize %d is a wrong config",
                    temp_radio_fr_alloc_period,
                    temp_sf_alloc_choice);
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
            }

            count++;
        }
        /* SPR 18653 Fix End */ 
        /* TDD Changes Start*/
        oam_memcpy(DuplexMode, oam_prov_req.oam_tr069_req.tr069_init_params.DuplexMode,
                OAM_MAX_STR_LEN);
        if (!(oam_strcmp("TDDMode", (char*)DuplexMode)))
        {
            tdd_config = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                physical_layer_params.physical_layer_param_tdd_frame_structure.
                sub_frame_assignment;
            if(OAM_ZERO == tdd_config)
            {
                *p_error_code = OAM_MBMS_DISABLED_WRONG_TDD_CONFIG;
                OAM_LOG(OAM, OAM_ERROR, "\nOperator can't configure EMBMS with"
                        " TDD Config: %d", tdd_config);
                retVal = OAM_FAILURE;

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            else if(tdd_config)
            {
                sf_alloc_choice =
                    LOCAL_RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                    physical_layer_params.
                    mbsfn_subframe_config_list.
                    mbsfn_subframe_config_info[cell_arr_idx].
                    subframe_allocation.sf_alloc_choice;

                OAM_LOG(OAM, OAM_ERROR, "sf_alloc_choice is %d \n", sf_alloc_choice);
                if (sf_alloc_choice == ONE_FRAME_ALLOC)
                {
                    max_tokens = SUB_FRAME_ALLOC_ONE_FRAME_OCTET_SIZE;
                }
                else if (sf_alloc_choice == FOUR_FRAME_ALLOC)

                {
                    max_tokens = SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE;
                }

                OAM_LOG(OAM, OAM_ERROR, "max_tokens is %d \n", max_tokens);

                /*OAM_LOG(OAM, OAM_CRITICAL, "\n DEEPIKA local structure value %d",
                  LOCAL_RRM_CELL_CONFIG(cell_arr_idx).
                  ran_info.physical_layer_params.mbsfn_subframe_config_list.
                  mbsfn_subframe_config_info[0].subframe_allocation.
                  subframe_allocation[0]);*/
                sf_config_list_count = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                    physical_layer_params.
                    mbsfn_subframe_config_list.count;
                OAM_LOG(OAM, OAM_ERROR, "sf_config_list_count is %d \n", sf_config_list_count);
                count = OAM_ZERO;
                while (count < sf_config_list_count)
                {
                    for (loop_counter = OAM_ZERO; loop_counter < max_tokens;
                            ++loop_counter)
                    {
                        sf_alloc_dec_value[loop_counter] = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).
                            ran_info.physical_layer_params.
                            mbsfn_subframe_config_list.
                            mbsfn_subframe_config_info[count].
                            subframe_allocation.
                            subframe_allocation[loop_counter]; 
                    }
                    if (OAM_FAILURE == oam_validate_sf_alloc_dec_for_tdd(
                                sf_alloc_dec_value, tdd_config))
                    {
                        *p_error_code = OAM_MBMS_DISABLED_WRONG_TDD_CONFIG;
                        OAM_LOG(OAM, OAM_ERROR, "\nOperator can't configure "
                                "EMBMS with UL Subframes in SubframeAllocation"
                                " param in TDDMode");
                        retVal = OAM_FAILURE;

                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }
                    count++;
                }
            }
        }
        else
        {
            neigh_cell_config_sib3 = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).
                ran_info.mobility_params.idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params.neigh_cell_config;

            if (OAM_THREE == neigh_cell_config_sib3)
            {
                *p_error_code = OAM_MBMS_DISABLED_WRONG_NEIGHCELLCONFIG;
                OAM_LOG(OAM, OAM_ERROR, "\nOperator can't configure "
                        "EMBMS with neigh_cell_config 3 for intra cell");
                retVal = OAM_FAILURE;

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            eutran_meas_cnt = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).ran_info.
                mobility_params.idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.num_valid_inter_freq_list;
            for(count = OAM_ZERO; count < eutran_meas_cnt; ++count)
            {
                neigh_cell_config_sib5 = LOCAL_RRM_CELL_CONFIG(cell_arr_idx).
                    ran_info.mobility_params.idle_mode_mobility_params.
                    idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[count].
                    neigh_cell_config;
                if (OAM_THREE == neigh_cell_config_sib5)
                {
                    *p_error_code = OAM_MBMS_DISABLED_WRONG_NEIGHCELLCONFIG;
                    OAM_LOG(OAM, OAM_ERROR, "\nOperator can't configure "
                            "EMBMS with neigh_cell_config 3 for inter cell");
                    retVal = OAM_FAILURE;

                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }
            }
        }
        g_parameter_map_element = g_parameter_mbsfn_l3_params;
        retVal = oam_mem_alloc(sizeof(m2ap_config_update_req_t),
                &p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR, "Error in memory allocation");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        p_local_req_memfree_flag = OAM_TRUE;
        oam_memset(p_local_req, 0, sizeof(m2ap_config_update_req_t));
    }
    else if (!oam_strcmp(Parent_Name, "InternetGatewayDevice.Services."
                "FAPService.[1].CellConfig.LTE.RAN.PHY.MBSFN"))
    {
        if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mbms_system_support)
        {
            *p_error_code = OAM_FEATURE_NOT_SUPPORTED;
            OAM_LOG(OAM, OAM_ERROR, "eMBMS feature is not supported");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else if (!oam_prov_req.oam_l3_req.oam_m2ap_req.mce_link_status)
        {
            *p_error_code = OAM_M2AP_MCE_LINK_DOWN;
            OAM_LOG(OAM, OAM_ERROR, "M2AP-MCE link is down");
            retVal = OAM_FAILURE;

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        g_parameter_map_element = g_parameter_mbsfn_rrm_params;
        retVal = oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
                (void**)&p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR, "Error in memory allocation");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        p_local_req_memfree_flag = OAM_TRUE;
        oam_memset(p_local_req, 0, sizeof(oam_rrm_cell_reconfig_req_t));
    }
#endif
    /* EMBMS Changes End */

        else {
			OAM_LOG(OAM, OAM_WARNING,
                    "Invalid Cell ID: %d Cell Context not changed", recvd_cid);
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            retVal = OAM_FAILURE;
            /* SPR 21390 fix end */
        }

        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    else if (oam_strncasecmp(Parent_Name, "InternetGatewayDevice.FAP.PerfMgmt.Config.Stop", oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config.Stop")) == OAM_ZERO)
    {
        g_cli_kpi_config_flag = OAM_TRUE; 
        oam_set_config_req.src_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_SRC_ID_LOC);
        spv_for_pm_xml_params = OAM_TRUE;
        if (g_pm_xml_params.pm_xml_file_reporting != OAM_ZERO)
        {
            g_pm_xml_params.pm_xml_file_reporting = OAM_ZERO;
            g_pm_rrm_xml_params.rrm_periodic_reporting_ongoing = (oam_bool_et)OAM_ZERO;
            g_pm_xml_params.spv_bitmask |= PM_XML_SPV_PM_REPORT_EN_DISABLE;
        }
        spv_for_pm_xml_params = OAM_TRUE;
        /* SPR_12955_FIXES */
        OAM_LOG(OAM, OAM_DETAILED, "Trans_id : periodic stop: %d", trans_id);	
        oam_prov_req.oam_igd_params.perf_mgmt_params.Enable = OAM_ZERO;
        g_resp_sent_user_interface = OAM_ONE;  /* BUG 8940 FIX */ 
    }
    else if (oam_strncasecmp(Parent_Name, "InternetGatewayDevice.FAP.PerfMgmt.Config.Start", oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config.Start")) == OAM_ZERO)
    {
        g_cli_kpi_config_flag = OAM_TRUE; 
        oam_set_config_req.src_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_SRC_ID_LOC);
        OAM_LOG(OAM, OAM_DETAILED, "Trans_id : periodic start: %d", trans_id);	
        /* SPR_12955_FIXES */
        if (g_pm_xml_params.pm_xml_file_reporting != OAM_ONE)
        {
            g_pm_xml_params.pm_xml_file_reporting = OAM_ONE;
            g_pm_xml_params.spv_bitmask |= PM_XML_SPV_PM_REPORT_EN_DISABLE; /* SPR 8944 FIX */
        }

        oam_prov_req.oam_igd_params.perf_mgmt_params.Enable = OAM_ONE;
        spv_for_pm_xml_params = OAM_TRUE;
        g_parameter_map_element = &g_parameter_pm_gpv_spv_param[OAM_ZERO];
        /* CSR No 00055803 Start */
        g_resp_sent_user_interface = OAM_ONE;
        /* CSR No 00055803 End */
    }
    else if (oam_strncasecmp(Parent_Name, "InternetGatewayDevice.FAP.PerfMgmt.Config", oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Config")) == OAM_ZERO)
    {
        g_cli_kpi_config_flag = OAM_TRUE; 
        oam_set_config_req.src_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_SRC_ID_LOC);
        OAM_LOG(OAM, OAM_DETAILED, "Trans_id : config: %d", trans_id);	
        /* SPR_12955_FIXES */
        g_parameter_map_element = &g_parameter_pm_gpv_spv_param[OAM_ZERO];
        /* CSR No 00055803 Start */
        /* SPR_12955_FIXES */
        g_resp_sent_user_interface = OAM_ONE;
        /* CSR No 00055803 End */
        /* SPR 15491 START */
        spv_for_pm_xml_params = OAM_TRUE;
        g_pm_xml_params.spv_bitmask |= PM_XML_SPV_PM_REPORT_EN_DISABLE;
        g_resp_sent_user_interface = OAM_ONE;
        /* SPR 15491 END */
    }
    else if (oam_strncasecmp(Parent_Name, "InternetGatewayDevice.FAP.PerfMgmt.Ondemand", oam_strlen("InternetGatewayDevice.FAP.PerfMgmt.Ondemand")) == OAM_ZERO)
    {
        g_cli_kpi_config_flag = OAM_TRUE; 
        oam_set_config_req.src_id   = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_SRC_ID_LOC);
        OAM_LOG(OAM, OAM_DETAILED, "Trans_id : config: %d", trans_id);	
        /* SPR_12955_FIXES */
        g_pm_xml_params.pm_xml_file_reporting = OAM_ZERO;
        /* coverity 53559 */
        g_pm_rrm_xml_params.rrm_periodic_reporting_ongoing = (oam_bool_et)OAM_ZERO;
        g_pm_xml_params.spv_bitmask |= PM_XML_SPV_PM_REPORT_EN_DISABLE;
        oam_prov_req.oam_igd_params.perf_mgmt_params.Enable = OAM_ZERO;
        g_pm_xml_params.pm_xml_sampling_interval_timer = oam_prov_req.oam_igd_params.perf_mgmt_params.sampling_interval_timer * 60;
        g_pm_xml_params.pm_xml_upload_interval_timer = oam_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadInterval;
        spv_for_pm_xml_params = OAM_TRUE;
        g_resp_sent_user_interface = OAM_ONE;  /* BUG 8940 FIX */ 
    }
    else if (oam_strncasecmp(Parent_Name, "InternetGatewayDevice.FAP.PerfMgmt", oam_strlen("InternetGatewayDevice.FAP.PerfMgmt")) == OAM_ZERO)
    {
        g_parameter_map_element = &g_parameter_pm_gpv_spv_param[OAM_ZERO];

    }
    /* SPR 13024 FIX START */
    /* Code removed */
    /* SPR 13024 FIX END */
    else if (oam_strncasecmp(Parent_Name, "Modify.MacQosParams", oam_strlen("Modify.MacQosParams")) == OAM_ZERO)
    {
        OAM_LOG(OAM, OAM_DETAILED, "Parent Name: %s", Parent_Name);
        paramter_app_map_tbl = OAM_MAC_MODIFY_REQ_MASK;

        Modify_MacQos_flag = OAM_ONE;

		oam_memset(&(local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req),
                OAM_ZERO,sizeof(oam_mac_modify_req_params_t));
    }
    else if (oam_strncasecmp(Parent_Name, "Enable.RRM.ECNCapacityEnhancement", oam_strlen("Enable.RRM.ECNCapacityEnhancement")) == OAM_ZERO)
    {
        Config_CapacityEnc_flag = OAM_TRUE;
    }
    else if (oam_strncasecmp(Parent_Name, "Disable.RRM.ECNCapacityEnhancement", oam_strlen("Disable.RRM.ECNCapacityEnhancement")) == OAM_ZERO)
    {
        if(Config_CapacityEnc_dis_flag == OAM_FALSE)
        {
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                    OAM_ZERO,(UInt8 *)"ECN Capacity Enhancement Is Not Enabled",oam_strlen("ECN Capacity Enhancement Is Not Enabled") + 1,
                    OAM_VERSION_ID, OAM_MODULE_ID,
                    /* Bug 51606 Fix */ dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                    p_error_code);
            return OAM_SUCCESS;
        }   
    }
    else if (oam_strncasecmp(Parent_Name, "RRM.UE.RELEASE", oam_strlen("RRM.UE.RELEASE")) == OAM_ZERO)
    {
        ue_Release_flag = OAM_TRUE; 
        oam_fill_rrm_oam_ue_release_req(&p_rrm_oam_ue_release_req);
    }
    else if (oam_strncasecmp(Parent_Name, "Reset.KPI.L3.RRC", oam_strlen("Reset.KPI.L3.RRC")) == OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_INFO,"Received Reset RRC Request");
        if(Config_Flag == OAM_ONE)
        {
            cli_flag = OAM_TRUE;
            /* SPR_12955_FIXES */	
            retVal = oam_send_rrc_reset_config_request(p_api_buf,
                    p_error_code);
            if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM,OAM_WARNING,"received damaged Reset RRC KPI message");
                /* coverity 62586 */
                *p_error_code = OAM_INTERNAL_ERROR;
                /*SPR 21390 Fix Start */
                OAM_FUN_EXIT_TRACE();
                /*SPR 21390 Fix End */
                return OAM_FAILURE;
            }
            oam_maintain_tcb(trans_id,OAM_TRANS_RRC,msg_len,p_api_buf);
            OAM_FUN_EXIT_TRACE();
            return OAM_SUCCESS;
        }
        else
        {
			OAM_LOG(OAM,OAM_WARNING,"Layer Not Configured");
            /*SPR 21390 Fix Start */
            *p_error_code = OAM_INTERNAL_ERROR;
            /*SPR 21390 Fix End */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else if (oam_strncasecmp(Parent_Name, "Reset.KPI.L2.PDCP", oam_strlen("Reset.KPI.L2.PDCP")) == OAM_ZERO)
    {
        if(Config_Flag == OAM_ONE)
        {
            cli_reset_flag.pdcp_reset_flag = OAM_ONE;
            oam_pdcp_get_KPI_stats_req_t pdcp_get_kpi_stats_req;
            pdcp_get_kpi_stats_req.kpiToGetBitMap =OAM_THIRTY_ONE; 

            pdcp_get_kpi_stats_req.resetStats = OAM_ONE;
            /* Calling PDCP Get KPI Stats Function Call */
            if (OAM_FAILURE == oam_pdcp_get_kpi_stats_req(
                        &pdcp_get_kpi_stats_req, OAM_MODULE_ID, trans_id, p_error_code))
            {
				OAM_LOG(OAM,OAM_ERROR,"Error in oam_pdcp_get_kpi_stats_req function with error code %d",
                        *p_error_code);
                return OAM_FAILURE;
            }
            else{
                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_PDCP,
                            OAM_TRANS_PDCP,msg_len,p_api_buf))
                {
                    /*SPR 21390 Fix Start */
                    *p_error_code = OAM_INTERNAL_ERROR;
                    /*SPR 21390 Fix End */
                    OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                    return OAM_FAILURE;
                }
#endif
                /* SPR 9620 CHANGE END */
            }
            OAM_FUN_EXIT_TRACE();
            return OAM_SUCCESS;
        }
        else {
			OAM_LOG(OAM,OAM_WARNING,"Layer Not Configured");
            *p_error_code = OAM_INTERNAL_ERROR; /* Cov CID 64651 Fix */
            /*SPR 21390 Fix Start/End Code Removed */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else if (oam_strncasecmp(Parent_Name, "Reset.KPI.L2.MAC", oam_strlen("Reset.KPI.L2.MAC")) == OAM_ZERO)
    {
        if(Config_Flag == OAM_ONE) {
            cli_reset_flag.mac_reset_flag = OAM_ONE; 
            oam_mac_get_KPI_stats_req_t mac_get_kpi_stats_req;
            mac_get_kpi_stats_req.resetStats = OAM_ONE;
            mac_get_kpi_stats_req.kpiToReportBitMap = OAM_ZERO;
            oam_maintain_tcb(trans_id,OAM_TRANS_MAC,msg_len,p_api_buf);
            if(OAM_FAILURE == oam_mac_get_kpi_stats_req(
                        &mac_get_kpi_stats_req,OAM_MODULE_ID, trans_id, p_error_code))
            {
				OAM_LOG(OAM,OAM_ERROR,"Error in oam_mac_get_kpi_stats_req function with error code %d",
                        *p_error_code);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;

            }
            else{
                /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_MAC,
                            OAM_TRANS_MAC,msg_len,p_api_buf))
                {
                    /*SPR 21390 Fix Start */
                    *p_error_code = OAM_INTERNAL_ERROR;
                    /*SPR 21390 Fix End */
                    OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                }
#endif
                /* SPR 9620 CHANGE END */
            }
            return OAM_SUCCESS;
        }
        else {
			OAM_LOG(OAM,OAM_WARNING,"Layer Not Configured");
            *p_error_code = OAM_INTERNAL_ERROR; /* cov cid 63650 Fix */
            /*SPR 21390 Fix Start/End Code Removed */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else if (oam_strncasecmp(Parent_Name, "Reset.KPI.RRM.All", oam_strlen("Reset.KPI.RRM.All")) == OAM_ZERO)
    {
        if(Config_Flag == OAM_ONE)
        {
            rrm_oam_get_kpi_req_t rrm_oam_get_kpi_req;
            UInt8 kpi_count = OAM_ZERO;
            oam_memset(&rrm_oam_get_kpi_req,OAM_ZERO,sizeof(rrm_oam_get_kpi_req_t));

            /*Filling rrm_oam_get_kpi_req_t KPI Sturcture */
            /*Bitmask is for future purpose and all params are mandatory so filling one */
            rrm_oam_get_kpi_req.bitmask = OAM_ONE;

            /* Filling cell id */
            oam_memcpy(&rrm_oam_get_kpi_req.cell_id,&RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx].global_cell_info.eutran_global_cell_id,
                    sizeof(rrm_oam_eutran_global_cell_id_t));

            /*Filling reset value*/
            rrm_oam_get_kpi_req.reset = OAM_TRUE;

            /* Enabling all 32 KPI out of 64 KPI at present */
            for( kpi_count= OAM_ZERO; kpi_count < RRM_MAX_KPI - RRM_FOUR; kpi_count++)
            {
                rrm_oam_get_kpi_req.kpi_to_report.bitmap[kpi_count] = OAM_ALL_8_BIT_SET;
            }
            /*SPR 11426 FIX Start*/
            rrm_oam_get_kpi_req.kpi_to_report.bitmap[kpi_count] = OAM_ONE;
            /*SPR 11426 FIX End*/

            oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
            if(OAM_FAILURE == oam_rrm_send_rrm_oam_get_kpi_req(
                        &rrm_oam_get_kpi_req,
                        src_module_id,
                        RRM_MODULE_ID,
                        trans_id,
                        cid))
            {
                /* spr 21390 fix start */
                *p_error_code = OAM_INTERNAL_ERROR;
                /* spr 21390 fix end */
                OAM_LOG(OAM,OAM_ERROR,"Error in sending RRM_OAM_GET_KPI_REQ, cell context = %d", cid);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            pm_rrm_reset.flag = OAM_ONE;
            return OAM_SUCCESS;
        }
		else
        {
			OAM_LOG(OAM,OAM_WARNING,"Layer Not Configured");
            *p_error_code = OAM_INTERNAL_ERROR; /*Cov Cid 63651 fix */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else if(oam_strncasecmp((char *)Parent_Name, "Reset.stats.L2.MAC", oam_strlen("Reset.stats.L2.MAC")) == OAM_ZERO)
    {
        if(Config_Flag == OAM_ONE)
        {
            OAM_LOG(OAM,OAM_DETAILED,"RESET_STATS_L2_MAC");
            oam_send_mac_reset_stats_req(src_module_id,trans_id,p_error_code);
            /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_MAC,
                        OAM_TRANS_MAC,msg_len,p_api_buf))
            {
                /*SPR 21390 Fix Start */
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                *p_error_code = OAM_INTERNAL_ERROR;
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
                /* spr 21390 fix end */
            }
#endif
			/* SPR 9620 CHANGE END */
			return OAM_SUCCESS;
		}
		else
		{
			OAM_LOG(OAM,OAM_WARNING,"Layer Not Configured");
			*p_error_code = OAM_INTERNAL_ERROR; /*Cov Cid 63652 fix */
			OAM_FUN_EXIT_TRACE();
			return OAM_FAILURE;
		}
    }
    else if(oam_strncasecmp((char *)Parent_Name, "Reset.stats.L2.PDCP", oam_strlen("Reset.stats.L2.PDCP")) == OAM_ZERO)
    {
        if(Config_Flag == OAM_ONE)
        {
            OAM_LOG(OAM,OAM_DETAILED,"RESET_STATS_L2_PDCP");
            oam_send_pdcp_reset_stats_req(src_module_id,trans_id,p_error_code);
            /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_PDCP,
                        OAM_TRANS_PDCP,msg_len,p_api_buf))
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                /* spr 21390 fix start */
                *p_error_code = OAM_INTERNAL_ERROR;
                OAM_FUN_EXIT_TRACE();
                /* spr 21390 fix end */
                return OAM_FAILURE;
            }
#endif
			/* SPR 9620 CHANGE END */
			return OAM_SUCCESS;
		}
		else
		{
			OAM_LOG(OAM,OAM_WARNING,"Layer Not Configured");
			*p_error_code = OAM_INTERNAL_ERROR; /*Cov Cid 63653 fix */
			OAM_FUN_EXIT_TRACE();
			return OAM_FAILURE;
		}
    }
    else if(oam_strncasecmp((char *)Parent_Name, "Reset.stats.L2.RLC", oam_strlen("Reset.stats.L2.RLC")) == OAM_ZERO)
    {
        if(Config_Flag == OAM_ONE)
        {
            OAM_LOG(OAM,OAM_DETAILED,"RESET_STATS_L2_RLC");
            oam_send_rlc_reset_stats_req(src_module_id,trans_id,p_error_code);
            /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RLC,
                        OAM_TRANS_RLC,msg_len,p_api_buf))
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                /*SPR 21390 Fix Start */
                *p_error_code = OAM_INTERNAL_ERROR;
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
                /*SPR 21390 Fix End */
            }
#endif
			/* SPR 9620 CHANGE END */
			return OAM_SUCCESS;
		}
		else
		{
			OAM_LOG(OAM,OAM_WARNING,"Layer Not Configured");
			*p_error_code = OAM_INTERNAL_ERROR; /*Cov cid 63650 Fix*/
			OAM_FUN_EXIT_TRACE();
			return OAM_FAILURE;
		}
	}
	else if(oam_strncasecmp(Parent_Name, "LGW", oam_strlen("LGW")) == OAM_ZERO)
	{
		OAM_LOG(OAM, OAM_DETAILED, "LGW Request received from CLI (ADD/ DELETE  LGW)");

        if(NULL != oam_strstr(Parent_Name, "Delete"))
        {
            if(OAM_TRUE == oam_rrc_lgw_enable)
            {
                oam_rrc_delete_lgw_req.bitmask |= OAM_ZERO;
                oam_maintain_tcb(trans_id,OAM_TRANS_RRC,msg_len,p_api_buf);

                oam_send_rrc_delete_lgw_req(&oam_rrc_delete_lgw_req, OAM_MODULE_ID, trans_id,p_api_buf,msg_len );
            }
            else
            {
                /* SPR 9709 FIX START */
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_REQUEST_DENIED,
                        (UInt8 *)"No LGW Available for Deletion",
                        oam_strlen("No LGW Available for Deletion") + 1,
                        OAM_VERSION_ID, OAM_MODULE_ID,
                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                        p_error_code);
                /* SPR 9709 FIX END */

            }
        }
    }
    /* spr_21013_fix_start */
    else   if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc", oam_strlen("InternetGatewayDevice.Services.FAPService.Transport.SCTP.Assoc")) == OAM_ZERO)
    {
        g_parameter_map_element = &g_parameter_lte_l3_Assoc_list[OAM_ZERO];
    }
    else   if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.Services.FAPService.Transport.SCTP", oam_strlen("InternetGatewayDevice.Services.FAPService.Transport.SCTP")) == OAM_ZERO)
        /* spr_21013_fix_end */
    {
        g_parameter_map_element = &g_parameter_lte_l3_sctp_list[OAM_ZERO];
    }
    /* SPR 10528 fix start */
    /* SPR 13024 FIX START */
    else if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services."
                /* spr_21013_fix_start */
                "FAPService.CellConfig.LTE.EPC.PLMNList.")) {
        /* spr_21013_fix_end */
        /* SPR 13024 FIX END */
        /* SPR 10528 fix end */
        g_parameter_map_element = g_parameter_TR_PLMNList_element;

        cell_arr_idx = oam_get_cell_plmnlist_data_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }

        p_cell_local_plmnlist_data =
            &LOCAL_RRM_PROV_REQ.plmnlist_data[cell_arr_idx];

        p_cell_plmnlist_data = &RRM_PROV_REQ.plmnlist_data[cell_arr_idx];

        oam_memset(p_cell_local_plmnlist_data->plmn_entries,
                0, sizeof(oam_rrm_plmn_data_t) * RRM_OAM_MAX_NUM_PLMNS);

        oam_memcpy(p_cell_local_plmnlist_data->plmn_entries,
                p_cell_plmnlist_data->plmn_entries,
                sizeof(oam_rrm_plmn_data_t) * RRM_OAM_MAX_NUM_PLMNS);

        if(p_cell_plmnlist_data->plmnlist_cache_idx) {
            oam_memcpy(&p_cell_local_plmnlist_data->
                    plmn_entries[p_cell_plmnlist_data->plmnlist_cache_idx - 1],
                    &p_cell_plmnlist_data->plmnlist_cache,
                    sizeof(oam_rrm_plmn_data_t));

            p_cell_plmnlist_data->plmnlist_cache_idx = OAM_ZERO;
        }

        oam_prov_req.system_status.event_ongoing |=
            OAM_CELL_PLMNLIST_CONFIG_ONGOING;

        retVal = oam_mem_alloc(sizeof(rrm_oam_cell_reconfig_req_t),
                &p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to p_local_req failed"
					" with Error Code:%d",
					*p_error_code);
            return retVal;
        }
        /* SPR 16603 Fix Start */
        /* Coverity 85867 fix start */
        //p_local_req_memfree_flag = OAM_TRUE;
        /* Coverity 85867 fix end */
    /* SPR 16603 Fix End */
		oam_memset(p_local_req, 0, sizeof(rrm_oam_cell_reconfig_req_t));
	}
    /* SPR 15527 START */
	else if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services."
				"FAPService.CellConfig.LTE.EPC.QoS.")) 
    {
        g_parameter_map_element = g_parameter_TR_QOS_element;
        retVal = oam_mem_alloc(sizeof(rrm_oam_cell_reconfig_req_t),
                &p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR, "Error in memory allocation");
            return retVal;
        }
        oam_memset(p_local_req, 0, sizeof(rrm_oam_cell_reconfig_req_t));
    }                    
    /* SPR 15527 END */
    /* spr_21013_fix_start */
    else if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.Services.FAPService.FAPControl", oam_strlen("InternetGatewayDevice.Services.FAPService.FAPControl")) == OAM_ZERO)
    {
        /* spr_21013_fix_end */
        g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
    }

    /* BUG_1171_START*/
#ifdef OAM_SON_ENABLE
    /* SPR 11467 START */
    else if(oam_strncasecmp((char *)Parent_Name, "SON.PCI-CONFLICT.PCI-MODE", oam_strlen("SON.PCI-CONFLICT.PCI-MODE")) == OAM_ZERO)
    {
        g_parameter_map_element =  &g_parameter_son_pci_conflit_enable[OAM_ZERO];
    }
    /* SPR 11467 END */

    /*eICIC_PHASE_1_2_CHANGES_START*/
    else if(OAM_ZERO == oam_strncasecmp((char *)Parent_Name, "SON.ANR.NEIGHBOR-DEFAULT-CONFIG.SET", oam_strlen("NEIGHBOR-DEFAULT-CONFIG")))
    {
        OAM_LOG(OAM, OAM_INFO,
                "NEIGHBOR-DEFAULT-CONFIG request received ");

        g_parameter_map_element = &(g_parameter_son_anr_neighbor_default_config_req[OAM_ZERO]);

        p_local_req= &(local_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req);

    }
    /*SPR 14554 start*/
    else if(OAM_ZERO == oam_strncasecmp((char *)Parent_Name, "SON.CELL-INFO_eICICParams", oam_strlen("CELL-INFO_eICICParams")))
    {
        OAM_LOG(OAM, OAM_INFO,
                "CELL-INFO_eICICParams request received ");

        g_parameter_map_element = &(g_parameter_son_cell_info_eicic_params[OAM_ZERO]);

        p_local_req= &(local_prov_req.oam_son_req.oam_son_cell_info_ind);

    }

    /*SPR 14554 end*/
    /*eICIC_PHASE_1_2_CHANGES_END*/
    /* SPR_19619 start*/

    else if(OAM_ZERO == oam_strncasecmp((char *)Parent_Name, "SON.PEER_CELL_ACTIVATION", oam_strlen("PEER_CELL_ACTIVATION")))
    {
        OAM_LOG(OAM, OAM_INFO,
                "Peer Cell-Activation request received");

        g_parameter_map_element = &(g_parameter_son_cell_activation_params[OAM_ZERO]);

        p_local_req= &(local_prov_req.oam_son_req.oam_son_peer_cell_activation_req);

    }
    /* SPR_19619 stop*/



#endif
    /* BUG_1171_END */
    else if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.FTPParams", oam_strlen("InternetGatewayDevice.FTPParams")) == OAM_ZERO)
    {
        g_parameter_map_element = &g_parameter_FTP_Params[OAM_ZERO];

    }
#ifdef OAM_SON_ENABLE
    /**** DROP 4 CODE ****/
    else if(oam_strstr(Parent_Name, "Mobility.IdleMode.InterFreq.Carrier")) {
        cell_arr_idx = oam_get_son_inter_freq_carrier_idx(cid);

        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        p_local_anr_meas_config_req =
            &LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);
        p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);
        /* SPR FIX 11266 + */
        g_parameter_map_element = g_parameter_TR_InterFreq_Carrier_element;
        p_local_req = &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);
        /* SPR FIX 11266 - */
        oam_memset(p_local_anr_meas_config_req, OAM_ZERO,
                sizeof(oam_son_anr_meas_config_req_t));

        oam_memcpy(&p_local_anr_meas_config_req->src_cgi,
                &p_anr_meas_config_req->src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));

        p_local_anr_meas_config_req->eutran_config_list_size = OAM_ONE;
        /* RT SPR 8154 FIX START */
        oam_prov_req.system_status.event_ongoing |= 
            USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
        /* RT SPR 8154 FIX END */

        /* SPR 14181 START */
        LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).other_rat_config_list.
            utran_config_list.utran_tdd_list_size = OAM_ZERO;
        LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).other_rat_config_list.
            geran_config_list.geran_freq_info_list_size = OAM_ZERO;
        /* SPR 14181 END */

    }
    else if (oam_strstr(Parent_Name,
                "Mobility.IdleMode.IRAT.UTRA.UTRANFDDFreq")) {
        g_parameter_map_element = g_parameter_TR_UTRA_FDD_element;

        cell_arr_idx = oam_get_son_inter_freq_carrier_idx(cid);

        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        /* SPR FIX 11266 + */
        p_local_req = &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);
        /* SPR FIX 11266 - */

        p_local_son_inter_freq_carr_params =
            &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);
        p_local_anr_meas_config_req =
            &LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);
        p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

        if (!p_local_son_inter_freq_carr_params->multi_parent_req) {
            oam_memset(p_local_anr_meas_config_req, OAM_ZERO,
                    sizeof(oam_son_anr_meas_config_req_t));

            oam_memcpy(&p_local_anr_meas_config_req->src_cgi,
                    &p_anr_meas_config_req->src_cgi,
                    sizeof(son_intra_rat_global_cell_id_t));

            p_local_anr_meas_config_req->other_rat_config_list.
                utran_config_list.utran_fdd_list_size = OAM_ONE;
            /* RT SPR 8154 FIX START */
            oam_prov_req.system_status.event_ongoing |= 
                USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
            /* RT SPR 8154 FIX END */
        }
        else {
            /* All we need is to reset the multi_parent_req flag, as the
               structure was already memset and the list sizes were already
               set to required value: see next if-else block
               */
            p_local_son_inter_freq_carr_params->multi_parent_req = OAM_ZERO;
            /* SPR 14181 START */
            LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).other_rat_config_list.
                utran_config_list.utran_tdd_list_size = OAM_ZERO;
            LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).other_rat_config_list.
                geran_config_list.geran_freq_info_list_size = OAM_ZERO;
            /* SPR 14181 END */

        }
    }
    /* RT SPR 9019 FIX START */  /*SPR 13944 START*/
    else if(strstr(Parent_Name,
                "Mobility.IdleMode.IRAT.UTRA.IRAT_EUTRAN_TO_UTRAN_TDD_CARRIERS")) {
        g_parameter_map_element = g_parameter_UTRA_TDD_element;  /*SPR 13944 END*/
        cell_arr_idx =
            oam_get_son_inter_freq_carrier_idx(cid);
        /*coverity 64256 fix start*/
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        /*coverity 64256 fix end*/
        /* SPR 14181 START */
        LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).other_rat_config_list.
            geran_config_list.geran_freq_info_list_size = OAM_ZERO;
        /* SPR 14181 END */

        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);


            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        /* SPR FIX 11266 + */
        p_local_req = &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);
        /* SPR FIX 11266 - */

        p_local_anr_meas_config_req =
            &LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

        p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);
        p_local_son_inter_freq_carr_params =
            &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

        if(!p_local_son_inter_freq_carr_params->multi_parent_req) {
            oam_memset(p_local_anr_meas_config_req, OAM_ZERO,
                    sizeof(oam_son_anr_meas_config_req_t));

            oam_memcpy(&p_local_anr_meas_config_req->src_cgi,
                    &p_anr_meas_config_req->src_cgi,
                    sizeof(son_intra_rat_global_cell_id_t));

            p_local_anr_meas_config_req->other_rat_config_list.
                utran_config_list.utran_tdd_list_size = 1;
            /* RT SPR 9019 FIX END */
            /* RT SPR 8154 FIX START */
            oam_prov_req.system_status.event_ongoing |=
                USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
            /* RT SPR 8154 FIX END */
        }
        else {
            /* All we need is to reset the multi_parent_req flag, as the
             * structure was already memset and the list sizes were already
             * set to required value: see next if-else block
             */
            p_local_son_inter_freq_carr_params->multi_parent_req = OAM_ZERO;
        }
    }
    else if(oam_strstr(Parent_Name, "Mobility.IdleMode.IRAT.UTRA")) {
        g_parameter_map_element = g_parameter_TR_UTRA_element;
        cell_arr_idx = oam_get_son_inter_freq_carrier_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        /* Coverity 64256 */
        /* SPR FIX 11266 + */
        p_local_req = &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);
        /* SPR FIX 11266 - */

        p_local_anr_meas_config_req =
            &LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

        p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

        p_local_son_inter_freq_carr_params =
            &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

        oam_memset(p_local_anr_meas_config_req, OAM_ZERO,
                sizeof(oam_son_anr_meas_config_req_t));

        oam_memcpy(&p_local_anr_meas_config_req->src_cgi,
                &p_anr_meas_config_req->src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));
        /* This SPV request is not complete in its entirety, so just set a
           flag and wait for another relevant SPV with the parent matching
           the previous if-else block
           */
        p_local_son_inter_freq_carr_params->multi_parent_req = OAM_ONE;
        oam_prov_req.system_status.event_ongoing |= 
            USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
    }
    /* RT SPR 8154 FIX START */
    else if(oam_strstr(Parent_Name,
                "Mobility.IdleMode.IRAT.GERAN.GERANFreqGroup")) {
        g_parameter_map_element = g_parameter_son_anr_GERANFreqGroup_params;

        cell_arr_idx = oam_get_son_inter_freq_carrier_idx(cid);

        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }

        p_local_son_inter_freq_carr_params =
            &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);
        p_local_anr_meas_config_req =
            &LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

        p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

        /* SPR 11820 Fix Start*/
        p_local_req = &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);
        /* SPR 11820 Fix Start*/

        oam_memset(p_local_anr_meas_config_req, OAM_ZERO,
                sizeof(oam_son_anr_meas_config_req_t));

        oam_memcpy(&p_local_anr_meas_config_req->src_cgi,
                &p_anr_meas_config_req->src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));

        p_local_anr_meas_config_req->other_rat_config_list.geran_config_list.
            t_reselection = p_anr_meas_config_req->other_rat_config_list.
            geran_config_list.t_reselection;

        p_local_anr_meas_config_req->other_rat_config_list.
            geran_config_list.geran_freq_info_list_size = 1;
        oam_prov_req.system_status.event_ongoing |= 
            USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
    }
    else if(oam_strstr(Parent_Name, "Mobility.IdleMode.IRAT.GERAN")) {
        g_parameter_map_element = g_parameter_son_anr_geran_params;
        cell_arr_idx =
            oam_get_son_inter_freq_carrier_idx(cid);

        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }
        p_local_son_inter_freq_carr_params =
            &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);
        p_local_anr_meas_config_req =
            &LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

        /* SPR 11119 Fix Start*/
        p_local_req = p_local_son_inter_freq_carr_params;
        /* SPR 11119 Fix Start*/

        p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx);

        oam_memset(p_local_anr_meas_config_req, OAM_ZERO,
                sizeof(oam_son_anr_meas_config_req_t));

        oam_memcpy(&p_local_anr_meas_config_req->src_cgi,
                &p_anr_meas_config_req->src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));

		oam_prov_req.system_status.event_ongoing |= 
			USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
	}
    /* spr_21013_fix_start */
    else if(oam_strncasecmp((char *)Parent_Name,
                "InternetGatewayDevice.Services.FAPService.Capabilities.LTE",
                oam_strlen("InternetGatewayDevice.Services.FAPService.Capabilities.LTE"))
            == OAM_ZERO)
    {

        g_parameter_map_element = g_parameter_TR_element;
    }
	else if(oam_strncasecmp((char *)Parent_Name,
				"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborList.LTECell.RSTxPower",
				oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborList.LTECell.RSTxPower"))
			== OAM_ZERO)
	{
		g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
	}

    else if(oam_strncasecmp((char *)Parent_Name,"InternetGatewayDevice.Services.FAPService.REM.LTE.CarrierMeasNumberOfEntries",
                oam_strlen("InternetGatewayDevice.Services.FAPService.REM.LTE.CarrierMeasNumberOfEntries"))== OAM_ZERO)
        /* spr_21013_fix_end */
    {
        g_parameter_map_element =  g_parameter_son_nw_scan_status;
    }
#ifdef OAM_SON_ENABLE
    else if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services."
                /* spr_21013_fix_start */
                "FAPService.CellConfig.LTE.RAN.NeighborList.LTECell."))
        /* spr_21013_fix_end */
    {
        cell_arr_idx = oam_get_son_cell_nr_list_idx(cid);

        if(OAM_ERROR_RETURN_VAL == cell_arr_idx ) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        p_local_nr_info = &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx);
        p_local_son_nr_add = &LOCAL_SON_NR_ADD_REQ(cell_arr_idx);
        p_son_nr_add = &SON_NR_ADD_REQ(cell_arr_idx);
        p_local_req = p_local_nr_info;

        g_parameter_map_element = g_parameter_lte_intra_rat_neighbor_list;

        /* Spr 15438 Fix Start */
        /* SPR 18930  FIX START */
        oam_memset(&(p_local_nr_info->eutran_nbr_ctxt), OAM_ZERO,
                sizeof(oam_son_nbr_ctxt_t) * OAM_SON_MAX_EUTRAN_NEIGHBORS);
        /* SPR 18930  FIX END */
        /* Spr 15438 Fix End */

        oam_memset(&(p_local_son_nr_add->nr_list), OAM_ZERO,
                sizeof(oam_son_neighbor_info_t));

        oam_memcpy(p_local_son_nr_add->nr_list.intra_rat_nr_list,
                p_son_nr_add->nr_list.intra_rat_nr_list,
                sizeof(p_son_nr_add->nr_list.intra_rat_nr_list));

        p_local_son_nr_add->nr_list.intra_rat_nr_list_size = OAM_ONE;

        oam_prov_req.system_status.event_ongoing |= OAM_SON_ADD_NR_ONGOING;
    }
    /* RT SPR 9019 FIX START */
    /* LINES DELETED */
    /* RT SPR 9019 FIX END */
    /* SPR-13586 START */
    else if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services."
                /* spr_21013_fix_start */
                "FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell"))
        /* spr_21013_fix_end */
        /* SPR-13586 END */
    {
        cell_arr_idx =
            oam_get_son_cell_nr_list_idx(cid);

        if(OAM_ERROR_RETURN_VAL == cell_arr_idx ){
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }

        p_local_nr_info = &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx);
        p_local_son_nr_add = &LOCAL_SON_NR_ADD_REQ(cell_arr_idx);
        p_son_nr_add = &SON_NR_ADD_REQ(cell_arr_idx);
        p_local_req = p_local_nr_info;

        /* SPR-13586 START */
        if(oam_strstr(Parent_Name, "NeighborList.InterRATCell.UMTS."))
        {
            g_parameter_map_element = g_parameter_lte_inter_rat_neighbor_list;
            /* Spr 15612  Fix Start*/
            oam_memset(&(p_local_nr_info->utran_nbr_ctxt), OAM_ZERO,
                    sizeof(oam_son_nbr_ctxt_t) * OAM_SON_MAX_UTRAN_NEIGHBORS);
            /* Spr 15612  Fix End*/
        }
        else if(oam_strstr(Parent_Name, "NeighborList.InterRATCell.GSM."))
        {
            g_parameter_map_element = g_parameter_lte_inter_rat_geran_neighbor_list;
        }
        oam_memset(&(p_local_son_nr_add->nr_list), OAM_ZERO,
                sizeof(oam_son_neighbor_info_t));
        /* SPR-13586 END */

        oam_memcpy(p_local_son_nr_add->nr_list.inter_rat_nr_list,
                p_son_nr_add->nr_list.inter_rat_nr_list,
                sizeof(p_local_son_nr_add->nr_list.inter_rat_nr_list));

        p_local_son_nr_add->nr_list.inter_rat_nr_list_size = 1;

        oam_prov_req.system_status.event_ongoing |= OAM_SON_ADD_NR_ONGOING;
    }
#endif
    else if(OAM_ZERO == oam_strncasecmp((char *)Parent_Name, "SON_ANR_ENABLE", oam_strlen("SON_ANR_ENABLE")))
    {
        OAM_LOG(OAM, OAM_INFO,
                "Cell ANR parameter configuration request received "
                "from user for CID: %d", cid);

        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_memset(
                &LOCAL_SON_PROV_REQ.anr_enable[cell_arr_idx],
                OAM_ZERO,
                sizeof(oam_son_anr_enable_req_t));

		/* SPR 22453 Fix +- */
        oam_memcpy(
                &LOCAL_SON_PROV_REQ.anr_enable[cell_arr_idx].
                src_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

		/* SPR 22453 Fix Start */
		LOCAL_SON_PROV_REQ.anr_enable[cell_arr_idx].src_cgi_list_size = 1;
		LOCAL_SON_PROV_REQ.anr_enable[cell_arr_idx].bitmask |= SON_SRC_CGI_PRESENT ;
		p_local_req =
			&LOCAL_SON_PROV_REQ.anr_enable[cell_arr_idx];
		/* SPR 22453 Fix End */

        g_parameter_map_element = &(g_parameter_son_anr_enable_req[OAM_ZERO]);

    }
    /******************9854 bug fix******************/
    else if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services."
                "FAPService.REM.LTE.CarrierMeas")) {
        g_parameter_map_element = g_parameter_son_rem_lte_carrierMeas;
    }
    /***************9854 bug fix******************/
    else if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services."
                "FAPService.REM.LTE")) {
        if (!oam_prov_req.system_status.is_nmm_enabled) {
            *p_error_code = OAM_MODULE_DISABLED;

			OAM_LOG(OAM, OAM_WARNING, "NMM Feature Disabled");

            OAM_FUN_EXIT_TRACE();
            retVal = OAM_FAILURE;
            return retVal;
        }

        parameter_length = get_word_from_header(p_api_buf_temp);
        offset = (OAM_WORD_SIZE_IN_BYTE + OAM_WORD_SIZE_IN_BYTE);
        parameter_name_length = parameter_length - offset;

        if (MAX_PARAMETER_NAME_LENGTH > parameter_name_length) {
            oam_memcpy(Parameter_Name, (p_api_buf_temp + offset),
                    parameter_name_length);
        }

        if (oam_strstr(Parameter_Name, "X_VENDOR_FORCEFUL_SCAN_FLAG") ||
                oam_strstr(Parameter_Name, "X_VENDOR_SCAN_DATA_TIMEOUT")) {
            retVal = oam_validata_send_nw_scan_config_cmd(p_api_buf_temp,
                    Number_of_parameters,
                    p_error_code);

            if (OAM_SUCCESS == retVal) {
                usr_resp_code = OAM_RESULT_SUCCESS;
                usr_resp_err_code = OAM_ZERO;
                err_str_len = OAM_ZERO;

                oam_construct_n_send_set_resp_to_usr(usr_resp_code,
                        usr_resp_err_code,
                        OAM_NULL,
                        err_str_len,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id, trans_id,
                        OAM_ZERO, OAM_ZERO,
                        p_error_code);
            }

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else {
            oam_memset(&(LOCAL_SON_PROV_REQ.nw_scan), OAM_ZERO,
                    sizeof(oam_son_nw_scan_req_t));
            oam_memset(&(LOCAL_SON_PROV_REQ.periodic_nw_scan), OAM_ZERO,
                    sizeof(oam_son_periodic_nw_scan_req_t));

            LOCAL_SON_PROV_REQ.periodic_nw_scan.scan_on_off = 0xFF;
            oam_memset(&(LOCAL_SON_PROV_REQ.temp_values), OAM_ZERO,
                    sizeof(oam_son_nw_scan_params_t));
            /*SPR 12001 FIX START*/
            p_local_req =
                &LOCAL_SON_PROV_REQ.nw_scan.start_intra_rat_scan_req;
            /*SPR 12001 FIX END*/
        }

        g_parameter_map_element = g_parameter_son_nw_scan_req;
    }
    /* SPR 11156 FIX START */
    else if(oam_strstr(Parent_Name,
                "SON_NR_DELETE_FROM_REMOVE_LIST_INTRA_RAT")) {
        OAM_LOG(OAM, OAM_INFO,
                "SON_NR_DELETE_FROM_REMOVE_LIST_INTRA_RAT received from"
                " user for serving cid: %d", cid);

        g_parameter_map_element = g_parameter_nr_delete_from_rem_list;

        oam_memset(&(LOCAL_SON_PROV_REQ.nr_delete_from_remove_list), OAM_ZERO,
                sizeof(oam_son_nr_delete_from_remove_list_req_t));
        p_local_req = &LOCAL_SON_PROV_REQ.nr_delete_from_remove_list;
    }
    else if(oam_strstr(Parent_Name,
                "SON_NR_DELETE_FROM_REMOVE_LIST_INTER_RAT_UTRAN")) {
        OAM_LOG(OAM, OAM_INFO,
                "SON_NR_DELETE_FROM_REMOVE_LIST_INTER_RAT_UTRAN received "
                "from user for serving cid: %d", cid);

        g_parameter_map_element = g_parameter_nr_delete_from_rem_list_utran;

        oam_memset(&(LOCAL_SON_PROV_REQ.nr_delete_from_remove_list), OAM_ZERO, 
                sizeof(oam_son_nr_delete_from_remove_list_req_t));
        p_local_req = &LOCAL_SON_PROV_REQ.nr_delete_from_remove_list;
    }
    /* SPR 11156 FIX END */
    else if(OAM_ZERO == oam_strncasecmp((char *)Parent_Name, "SON_ANR_DISABLE", oam_strlen("SON_ANR_DISABLE")))
    {
        OAM_LOG(OAM, OAM_DETAILED, "SON_ANR_DISABLE Triggered from CLI");
        paramter_app_map_tbl = OAM_SON_ANR_DISABLE_MASK;
        retVal = oam_send_message_to_lower_layers(OAM_MODULE_ID, msg_len,
                p_api_buf, OAM_NULL,
                OAM_NULL, OAM_NULL,
                OAM_NULL,
                p_error_code);
        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR, "Message sending to lower failed");
        }

        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    else if(OAM_ZERO == oam_strncasecmp((char *)Parent_Name, "SON_NR_CONFIG_X2_ENABLE", oam_strlen("SON_NR_CONFIG_X2_ENABLE")))
    {
        paramter_app_map_tbl = OAM_SON_X2_ENABLE_MASK;
        retVal = oam_send_message_to_lower_layers(OAM_MODULE_ID, msg_len,
                p_api_buf, OAM_NULL,
                OAM_NULL, OAM_NULL,
                OAM_NULL,
                p_error_code);
        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR, "Message sending to lower failed");
        }

        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    else if(OAM_ZERO == oam_strncasecmp((char *)Parent_Name, "SON_NR_CONFIG_X2_DISABLE", oam_strlen("SON_NR_CONFIG_X2_DISABLE")))
    {
        paramter_app_map_tbl = OAM_SON_X2_DISABLE_MASK;
        retVal = oam_send_message_to_lower_layers(OAM_MODULE_ID, msg_len,
                p_api_buf, OAM_NULL,
                OAM_NULL, OAM_NULL,
                OAM_NULL,
                p_error_code);
        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR, "Message sending to lower failed");
        }

        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
#endif
    /* OAM BCOM Code Comment Changes Start */
    else if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1]",
                oam_strlen("InternetGatewayDevice.FAP.Tunnel.CryptoProfile.[1]")) == OAM_ZERO)
    {
        OAM_LOG(OAM, OAM_DETAILED, "Parent_Name = %s", Parent_Name);
        /*Bug Fix 1111*/
        g_parameter_map_element = &g_parameter_tunnel_crypto_profile[OAM_ZERO];
    }
    else if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.FAP.Tunnel.IKESA.[1]",
                oam_strlen("InternetGatewayDevice.FAP.Tunnel.IKESA.[1]")) == OAM_ZERO)
    {
        OAM_LOG(OAM, OAM_DETAILED, "Parent_Name = %s", Parent_Name);
        g_parameter_map_element = &g_parameter_tunnel_ikesa[OAM_ZERO];
    }
    /* OAM BCOM Code Comment Changes End */
    else if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.FAP.Tunnel.VirtualInterface.[1]", 
                oam_strlen("InternetGatewayDevice.FAP.Tunnel.VirtualInterface.[1]")) == OAM_ZERO)
    {
        OAM_LOG(OAM, OAM_DETAILED, "Parent_Name = %s", Parent_Name);
        g_parameter_map_element = &g_parameter_tunnel_virtualInterface[OAM_ZERO];
    }
    /* SPR 13024 FIX START */
    /* Code removed */
    /* SPR 13024 FIX END */
    else if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.FAP.Tunnel", oam_strlen("InternetGatewayDevice.FAP.Tunnel")) == OAM_ZERO)
    {
        g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
    }

    /* SPR-16334 START */
    else if(oam_strncasecmp((char *)Parent_Name, "L3Params.X2AP.peer_eNB_CommInfo", oam_strlen("L3Params.X2AP.peer_eNB_CommInfo")) == OAM_ZERO)
    {
        g_parameter_map_element = &g_parameter_x2ap_nr_enb_params[OAM_ZERO];
    }
    else if(oam_strncasecmp((char *)Parent_Name, "L3Params.X2AP.ENB_Delete", oam_strlen("L3Params.X2AP.ENB_Delete")) == OAM_ZERO)
    {
        g_parameter_map_element = &g_parameter_x2ap_nr_enb_del[OAM_ZERO];
    }
    /* SPR-16334 END */


    /* LTE_OAM_CA_PARAMETER_SUPPORT */
    /* SPR 14295 FIX START */
    else if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services."
                /* spr_21013_fix_start */
                "FAPService.CellConfig."
                /* spr_21013_fix_end */
                "X_VENDOR_CARRIER_AGGREGATION_PARAMS."
                "MACSchedParams")) {
        g_parameter_map_element = g_parameter_ca_mac_sched_params;

        retVal = oam_mem_alloc(sizeof(rrm_oam_cell_reconfig_req_t),
                &p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to p_local_req failed"
					" with Error Code:%d",
					*p_error_code);

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        //p_local_req_memfree_flag = OAM_TRUE;

        oam_memset(p_local_req, 0, sizeof(rrm_oam_cell_reconfig_req_t));
    }
    else if(oam_strstr(Parent_Name, "InternetGatewayDevice.Services."
                /* spr_21013_fix_start */
                "FAPService.CellConfig."
                /* spr_21013_fix_end */
                "X_VENDOR_CARRIER_AGGREGATION_PARAMS"))
    {
        g_parameter_map_element = g_parameter_ca_general_params;

        retVal = oam_mem_alloc(sizeof(rrm_oam_cell_reconfig_req_t),
                &p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to p_local_req failed"
                            " with Error Code:%d",
                            *p_error_code);

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        /*SPR 18504 FIX START*/
        p_local_req_memfree_flag = OAM_TRUE;
        /*SPR 18504 FIX END*/


        oam_memset(p_local_req, 0, sizeof(rrm_oam_cell_reconfig_req_t));
    }
    /* SPR 14295 FIX END */
    /*LTE_OAM_CA_PARAMETER_SUPPORT */

    /* eICIC_PHASE_1_2_CHANGES_START */
    /*SPR 15028 start*/
    else if((oam_strncasecmp((char *)Parent_Name,
                    /* spr_21013_fix_start */
                    "InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICParams", 
                    oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICParams")) == OAM_ZERO) 
            || (oam_strncasecmp((char *)Parent_Name,"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICTimers",oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.eICICTimers")) == OAM_ZERO) || (oam_strncasecmp((char *)Parent_Name,"InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.AbsInfoParams",oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig.X_VENDOR_eICIC_PARAMS.AbsInfoParams")) == OAM_ZERO))
        /* spr_21013_fix_end */
    {
        OAM_LOG(OAM, OAM_DETAILED, "Parent_Name = %s", Parent_Name);
        g_parameter_map_element =
            g_parameter_x_vendor_eicic_params;

        retVal = oam_mem_alloc(sizeof(rrm_oam_cell_reconfig_req_t),
                &p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) 
        {
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to p_local_req failed"
					" with Error Code:%d",
					*p_error_code);
            return retVal;
        }
        //p_local_req_memfree_flag = OAM_TRUE;

        oam_memset(p_local_req, 0, sizeof(rrm_oam_cell_reconfig_req_t));
    }
    /*SPR 15028 end*/
    /* eICIC_PHASE_1_2_CHANGES_END */

    else if (oam_strstr(Parent_Name, "eNodeBParams.")) {
        g_parameter_map_element = &g_parameter_NONTR_element[OAM_ZERO];

#ifdef OAM_SON_ENABLE
        if (oam_strstr(Parent_Name, "oam_son_nr_enb_add_req")) {
            oam_memset(&LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req, OAM_ZERO,
                    sizeof(oam_son_nr_enb_add_req_t));

            p_local_req = &LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req.
                nbr_enb_list[OAM_ZERO];
        }
        else if (oam_strstr(Parent_Name,
                    "cellConfig.operator_info.measurement_configuration")) {
            cell_arr_idx = oam_get_son_inter_freq_carrier_idx(cid);

            if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        cid);
                /* spr 21390 fix start */
                *p_error_code = OAM_INVALID_CELL_CONTEXT;
                /* spr 21390 fix end */
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            p_local_son_inter_freq_carr_params =
                &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_arr_idx);

            oam_memset(&p_local_son_inter_freq_carr_params->
                    oam_son_anr_meas_config_req,
                    OAM_ZERO,
                    sizeof(son_oam_anr_meas_config_req_t));
        }
        else 
#endif
        {
            retVal = oam_mem_alloc(sizeof(rrm_oam_cell_reconfig_req_t),
                    &p_local_req,
                    p_error_code);

            if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to p_local_req failed"
						" with Error Code:%d",
						*p_error_code);

				OAM_FUN_EXIT_TRACE();
				return retVal;
			}
			oam_memset(p_local_req, 0, sizeof(rrm_oam_cell_reconfig_req_t));
		}

        /* Request for gap config received */
    }
#ifdef OAM_SON_ENABLE
    else if (oam_strncasecmp(Parent_Name, "SON_RACH-OPT_Config", oam_strlen("SON_RACH-OPT_Config")) == OAM_ZERO)
    {
        /*BUG_FIXED_11744_START */ 
        cell_config_idx = oam_get_son_serving_cell_idx(
                oam_prov_req.cell_cntxt.curr_cell_cid);
        if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    oam_prov_req.cell_cntxt.curr_cell_cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }


        oam_memset(
                &LOCAL_SON_PROV_REQ.rach_opt_modify_config_params[cell_arr_idx],
                OAM_ZERO,
                sizeof(oam_son_rach_opt_modify_config_params_req_t));
        p_local_req =
            &LOCAL_SON_PROV_REQ.rach_opt_modify_config_params[cell_arr_idx];

        oam_memcpy(
                &LOCAL_SON_PROV_REQ.rach_opt_modify_config_params[cell_arr_idx].
                srv_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

        g_parameter_map_element = &g_parameter_rach_opt_config_params[OAM_ZERO];
        /*BUG_FIXED_11744_END */
    }
#endif
    else if(oam_strstr(Parent_Name,
                "InternetGatewayDevice.FaultMgmt.SupportedAlarm.")) {
        g_parameter_map_element = g_parameter_multi_instanse_FM_SUPP_GET_SET;
        OAM_LOG(OAM, OAM_DETAILED,
                "FaultMgmt SupportedAlarm Table selected.");
    }
    else if(oam_strstr(Parent_Name, "Clean")) {
        g_parameter_map_element = g_parameter_CONTROL_COMMAND_element;
        OAM_LOG(OAM, OAM_DETAILED, "Control command Table selected.");
    }
    else if(oam_strstr(Parent_Name,
                /* spr_21013_fix_start */
                "InternetGatewayDevice.Services.FAPService")) {
        /* spr_21013_fix_end */
        g_parameter_map_element = g_parameter_TR_element;

        retVal = oam_mem_alloc(sizeof(rrm_oam_cell_reconfig_req_t),
                &p_local_req,
                p_error_code);

        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to p_local_req failed"
					" with Error Code:%d",
					*p_error_code);

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        //p_local_req_memfree_flag = OAM_TRUE;

        oam_memset(p_local_req, 0, sizeof(rrm_oam_cell_reconfig_req_t));
    }
#ifdef OAM_RADIO_HEAD_SUPPORT
#ifdef OAM_RRH_TYPE_1_SUPPORT
    else if((oam_strncmp(Parent_Name, "RRH", oam_strlen("RRH")) == OAM_ZERO)) {
        if(!oam_prov_req.rrh_flag || !oam_prov_req.rcm_flag) {
            oam_construct_n_send_set_resp_to_usr(OAM_ONE, OAM_ZERO,
                    (UInt8 *)"RRH IS DISABLED!",
                    oam_strlen("RRH IS DISABLED") + OAM_ONE,
                    OAM_ZERO, OAM_MODULE_ID,
                    dest_id, trans_id,
                    OAM_ZERO, OAM_ZERO, p_error_code);
            OAM_LOG(OAM, OAM_DETAILED,
                    "User request received for RRH, but RRH is disabled.");
            return OAM_SUCCESS;
        }

        if(OAM_RCM_ALARM_RRH_MSG_QUEUE_FULL == alarm_id_set)
        {
            trans_id = get_word_from_header((UInt8 *)p_api_buf);/*COVERITY_FIX_1.0*/
            oam_construct_n_send_set_resp_to_usr(OAM_ONE,
                    OAM_ZERO, OAM_NULL, OAM_ZERO,
                    (UInt8 *) OAM_VERSION_ID, OAM_MODULE_ID,
                    dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                    p_error_code);

        }

        g_parameter_map_element = &parameter_RRH_element[OAM_ZERO];
        OAM_LOG(OAM, OAM_DETAILED, "User request for RRH Parameters received.");
    }
#endif
#endif
    else if (oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice.ManagementServer", 
                oam_strlen("InternetGatewayDevice.ManagementServer")) == OAM_ZERO)
    {
        g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
        /* SPR 17880 18JAN FIX START */
        p_local_req = &local_prov_req.oam_tr069_req.tr069_init_params;
        /* SPR 17880 18JAN FIX END */
    }
    else if(oam_strncasecmp((char *)Parent_Name, "InternetGatewayDevice", oam_strlen("InternetGatewayDevice")) == OAM_ZERO)
    {
        g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
    }
    /* SPR 11001 FIX START */
    else if(oam_strstr(Parent_Name, "LoadReporting")) {
        g_parameter_map_element = g_parameter_TR_element;

        oam_memset(&local_prov_req.oam_rrm_req.oam_load_config_req,
                OAM_ZERO,
                sizeof(oam_rrm_load_config_req_t));

        p_local_req = &local_prov_req.oam_rrm_req.oam_load_config_req;

        usr_intf_flag = OAM_TRUE;

        if (!oam_strstr(Parent_Name, "serving_cell") &&
                !oam_strstr(Parent_Name, "neighbor_cell")) {
            cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
            if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        cid);
                /* spr 21390 fix start */
                *p_error_code = OAM_INVALID_CELL_CONTEXT;
                OAM_FUN_EXIT_TRACE();
                /* spr 21390 fix end */
                return OAM_FAILURE;
            }

            oam_memset(&local_prov_req.oam_rrm_req.oam_load_config_req,
                    OAM_ZERO,
                    sizeof(oam_rrm_load_config_req_t));

            oam_memcpy(&LOCAL_RRM_PROV_REQ.oam_load_config_req.
                    serv_enb_cell_info[0],
                    &RRM_PROV_REQ.oam_load_config_req.
                    serv_enb_cell_info[cell_arr_idx],
                    sizeof(rrm_oam_serving_enb_cell_info_t));
            local_prov_req.oam_rrm_req.oam_load_config_req.num_enb_cells = 1;
        }
    }
    /* SPR 11001 FIX END */
#ifdef OAM_SON_ENABLE
    /*SON_ENERGY_SAVING*/
    else if(oam_strstr(Parent_Name, "Set.SON.ES.Enable")) {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }

        OAM_LOG(OAM, OAM_INFO, "Cell ES enable request received from user "
                "for CID: %d", cid);
        char values[OAM_FOUR] = {0,0,0,0};
        char *temp = OAM_NULL;
        if(SON_PROV_REQ.oam_energy_saving_config[cell_arr_idx].es_enable_disable == OAM_ZERO)     
        { 
            for(loop=OAM_ZERO; loop < Number_of_parameters; loop++)
            {
                parameter_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
                OAM_LOG(OAM,OAM_DETAILED," parameter length  ::%d",
                        parameter_length);
                parameter_name_length = parameter_length -OAM_FOUR;
                OAM_LOG(OAM,OAM_DETAILED,"parameter name length  :: %d",
                        parameter_name_length);

                /*SPR 16151 Fixed Start*/
                oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH_VALUE);
                /*SPR 16151 Fixed End*/
                oam_memcpy(Parameter_Name,(p_api_buf_temp +OAM_FOUR),parameter_name_length);

                /*Coverity fix Comments*/
                temp = oam_strtok(Parameter_Name,"=");
                OAM_NULL_CHECK(NULL != temp);/* Coverity FIX 35436-7 */
                OAM_LOG(OAM, OAM_DETAILED, "Parameter_Name temp : %s",temp );
                temp = oam_strtok(NULL,"=");
                values[loop]=oam_atoi(temp);/* Coverity FIX 35436-8 */
                p_api_buf_temp = p_api_buf_temp + parameter_length;
            }

            usr_intf_flag = OAM_TRUE;
            return oam_send_es_enable_req(cell_arr_idx,
                    values[OAM_ZERO], /* EnergySavingControl */
                    values[OAM_ONE], /* ActiveUECountIntervalSecond */
                    values[OAM_TWO], /* ActiveUECountThreshold) */
                   p_api_buf,
                   msg_len);
        }
        else                                                          
        {
            OAM_LOG(OAM, OAM_DETAILED, "SON Energy Saving feature already enabled");
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                    9002,(UInt8 *)"ES already enabled", oam_strlen("ES already enabled")+ OAM_ONE,
                    OAM_VERSION_ID, OAM_MODULE_ID,
                    dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                    p_error_code);
            return OAM_SUCCESS;
        }
    }
    else if(oam_strstr(Parent_Name, "Set.SON.ES.Disable")) {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }

        OAM_LOG(OAM, OAM_INFO, "Cell ES disable request received from user "
                "for CID: %d", cid);
        char values[OAM_FOUR] = {0,0,0,0};
        char *temp = OAM_NULL;
        if(SON_PROV_REQ.oam_energy_saving_config[cell_arr_idx].es_enable_disable == OAM_ONE)
        {
            for(loop=OAM_ZERO; loop < Number_of_parameters; loop++)
            {
                parameter_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
                parameter_name_length = parameter_length -OAM_FOUR;

                /*SPR 16151 Fixed Start*/
                oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH_VALUE);
                /*SPR 16151 Fixed End*/
                oam_memcpy(Parameter_Name,(p_api_buf_temp +OAM_FOUR),parameter_name_length);
                temp = oam_strtok(Parameter_Name,"=");
                OAM_NULL_CHECK(NULL != temp);/* Coverity FIX 35436-5 */
                /*Coverity fix Comments*/
                temp = oam_strtok(NULL,"=");
                values[loop]=oam_atoi(temp);/* Coverity FIX 35436-6 */
                p_api_buf_temp = p_api_buf_temp + parameter_length;
            }

            usr_intf_flag = OAM_TRUE;
            return oam_send_es_disable_req(cell_arr_idx, values[OAM_ZERO],
                    p_api_buf, msg_len);
        }
        else                                                          
        {
            OAM_LOG(OAM, OAM_DETAILED, "SON Energy Saving feature already disabled");  
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                    9002,(UInt8 *)"ES already disabled", oam_strlen("ES already disabled")+ OAM_ONE,
                    OAM_VERSION_ID, OAM_MODULE_ID,
                    dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                    p_error_code);
            return OAM_SUCCESS;
        }
    }
    else if(oam_strstr(Parent_Name, "Set.SON.ES.Modify.UE_Count_interval")) {
        g_parameter_map_element = g_parameter_lte_son_es_list;
    }
    else if(oam_strstr(Parent_Name, "Set.SON.ES.Modify.UE_Count_threshold")) {
        g_parameter_map_element = g_parameter_lte_son_es_list;
    }
    else if(oam_strstr(Parent_Name, "Set.SON.ES.Cell.Autonomous_SwitchOff"))
    {
        g_parameter_map_element = g_parameter_lte_son_es_list;
        oam_memset(&LOCAL_SON_PROV_REQ.autonomous_switch_off_config_req,
                OAM_ZERO,
                sizeof(oam_son_oam_es_autonomous_switch_off_config_req_t));
        p_local_req = &LOCAL_SON_PROV_REQ.autonomous_switch_off_config_req;
    }
    else if(oam_strncasecmp((char *)Parent_Name, "Set.SON.ES.Cell.SwitchOn",
                oam_strlen("Set.SON.ES.Cell.SwitchOn")) == OAM_ZERO)
    {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }

        OAM_LOG(OAM, OAM_INFO,
                "Cell ES cell switch-on request received from user "
                "for CID: %d", cid);
        char values[OAM_FOUR] = {0,0,0,0};
        for(loop=OAM_ZERO; loop < Number_of_parameters; loop++)
        {                     
            char *temp = OAM_NULL;
            parameter_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
            OAM_LOG(OAM,OAM_DETAILED," parameter length  ::%d",
                    parameter_length);
            parameter_name_length = parameter_length -OAM_FOUR;
            OAM_LOG(OAM,OAM_DETAILED," parameter name length  :: %d",
                    parameter_name_length);

            /*SPR 16151 Fixed Start*/
            oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH_VALUE);
            /*SPR 16151 Fixed End*/
            oam_memcpy(Parameter_Name,(p_api_buf_temp +OAM_FOUR),parameter_name_length);
            /*Coverty fix*/
            temp = oam_strtok(Parameter_Name,"=");
            OAM_NULL_CHECK(NULL != temp);/* Coverity FIX 35436-1 */
            OAM_LOG(OAM,OAM_DETAILED,"Parameter_Name temp  ::%s ", temp);
            temp = oam_strtok(NULL,"=");

            values[loop]=oam_atoi(temp);/* Coverity FIX 35436-2 */
            OAM_LOG(OAM, OAM_DETAILED, "Parameter-Value Pair: %s", Parameter_Name);
            p_api_buf_temp = p_api_buf_temp + parameter_length;
        }

        return oam_send_es_cell_switch_on_req(cell_arr_idx,
                values[OAM_ZERO], /*(CellSwitchStatus)*/
                p_api_buf,
                msg_len);
    } 
    else if(oam_strncasecmp((char *)Parent_Name, "Set.SON.ES.Cell.SwitchOff",
                oam_strlen("Set.SON.ES.Cell.SwitchOff")) == OAM_ZERO)
    {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            OAM_FUN_EXIT_TRACE();
            /* spr 21390 fix end */
            return OAM_FAILURE;
        }

        OAM_LOG(OAM, OAM_INFO,
                "Cell ES cell switch-off request received from user "
                "for CID: %d", cid);
        char values[OAM_FOUR] = {0,0,0,0};
        char  *temp = OAM_NULL;
        for(loop=OAM_ZERO; loop < Number_of_parameters; loop++)
        {                     
            parameter_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
            OAM_LOG(OAM,OAM_DETAILED," parameter length  ::%d",
                    parameter_length);
            parameter_name_length = parameter_length -OAM_FOUR;
            OAM_LOG(OAM,OAM_DETAILED," parameter name length  :: %d",
                    parameter_name_length);

            /*SPR 16151 Fixed Start*/
            oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH_VALUE);
            /*SPR 16151 Fixed End*/
            oam_memcpy(Parameter_Name,(p_api_buf_temp +OAM_FOUR),parameter_name_length);
            /*Coverty fix*/
            temp = oam_strtok(Parameter_Name,"=");
            OAM_NULL_CHECK(NULL != temp);/* Coverity FIX 35436-3 */
            OAM_LOG(OAM,OAM_DETAILED,"Parameter_Name temp  ::%s ", temp);    
            temp = oam_strtok(NULL,"=");
            values[loop]=oam_atoi(temp);/* Coverity FIX 35436-4 */
            OAM_LOG(OAM, OAM_DETAILED, "Parameter-Value Pair: %s", Parameter_Name);
            p_api_buf_temp = p_api_buf_temp + parameter_length;
        }

        return oam_send_es_cell_switch_off_req(cell_arr_idx,
                values[OAM_ZERO], /* CellSwitchStatus */
                values[OAM_ONE], /* CellSwitchOffMode */
                p_api_buf,
                msg_len);
    }
    else if((oam_strncasecmp((char *)Parent_Name, "SON_RACH-OPT_MODIFY_MODE", oam_strlen("SON_RACH-OPT_MODIFY_MODE")))== OAM_ZERO)        {
        oam_maintain_tcb(trans_id,OAM_TRANS_SON,msg_len,p_api_buf);
        char values[OAM_FOUR] = {0,0,0,0};
        char  *temp = OAM_NULL;
        for(loop=OAM_ZERO; loop < Number_of_parameters; loop++)
        {
            parameter_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
            OAM_LOG(OAM,OAM_DETAILED," parameter length  ::%d",
                    parameter_length);
            parameter_name_length = parameter_length -OAM_FOUR;
            OAM_LOG(OAM,OAM_DETAILED," parameter name length  :: %d",
                    parameter_name_length);

            /*SPR 16151 Fixed Start*/
            oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH_VALUE);
            /*SPR 16151 Fixed End*/
            oam_memcpy(Parameter_Name,(p_api_buf_temp +OAM_FOUR),parameter_name_length);
            /*Coverty fix*/
            temp = oam_strtok(Parameter_Name,"=");
            OAM_LOG(OAM,OAM_DETAILED,"Parameter_Name temp  ::%s ", temp);
            temp = oam_strtok(NULL,"=");
            values[loop]=oam_atoi(temp);
            OAM_LOG(OAM, OAM_DETAILED, "Parameter-Value Pair: %s", Parameter_Name);
            p_api_buf_temp = p_api_buf_temp + parameter_length;
        }

        if(OAM_FAILURE == oam_send_rach_opt_modify_req(values[OAM_ZERO],trans_id))
        {
            OAM_LOG(OAM, OAM_ERROR, "sending SON_OAM_RACH_OPT_MODIFY_RACH_OPTMODE_REQ failed");
        }
        return OAM_SUCCESS;        

    }
    else if((oam_strncasecmp((char *)Parent_Name, "SON_RACH-OPT",oam_strlen("SON_RACH-OPT")) == OAM_ZERO)
            &&( (NULL != oam_strstr(Parent_Name, "ENABLE"))
                || (NULL != oam_strstr(Parent_Name, "DISABLE") ) ))
    {
        if(NULL != oam_strstr(Parent_Name, "ENABLE"))
        {


            OAM_LOG(OAM, OAM_INFO,
                    "RACH  ENABLE REQ received from user for CID: %d", cid);
            cell_arr_idx = oam_get_son_serving_cell_idx(cid);
            if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        cid);
                /* spr 21390 fix start */
                *p_error_code = OAM_INVALID_CELL_CONTEXT;
                /* spr 21390 fix end */
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            retVal = oam_mem_alloc(sizeof(oam_son_rach_opt_enable_req_t),
                    (void**)&p_son_rach_opt_enable_req, p_error_code);
            if (OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to p_son_rach_opt_enable_req failed"
						" with Error Code:%d",
						*p_error_code);
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }

            oam_memset(p_son_rach_opt_enable_req, OAM_ZERO,
                    sizeof(oam_son_rach_opt_enable_req_t));

            oam_memcpy(&p_son_rach_opt_enable_req->srv_cgi,
                    &SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi,
                    sizeof(son_intra_rat_global_cell_id_t));

            p_son_rach_opt_enable_req->bitmask |= SON_RACH_OPT_ENABLE_SRV_CGI_PRESENT;

            retVal = oam_son_send_son_oam_rach_opt_enable_req(p_son_rach_opt_enable_req,
                    OAM_MODULE_ID,
                    SON_MODULE_ID,
                    trans_id,
                    cid);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Error in sending SON_OAM_RACH_OPT_ENABLE_REQ message to lower layer");
            }
            else {
                OAM_LOG(OAM, OAM_INFO,
                        "SON_OAM_RACH_OPT_ENABLE_REQ sent to lower layer successfully");
                usr_intf_flag = OAM_TRUE;
                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                            OAM_TRANS_SON,msg_len,p_api_buf))
                {
                    OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                    /* spr 21390 fix start */
                    *p_error_code = OAM_INTERNAL_ERROR;
                    /* spr 21390 fix end */
                    retVal = OAM_FAILURE;
                }
#endif
                /* SPR 9620 CHANGE END */
                rach_usr_req_flag = (UInt8)OAM_TRUE;
            }
            oam_mem_free(p_son_rach_opt_enable_req, p_error_code);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }


        else if(NULL != oam_strstr(Parent_Name, "DISABLE"))
        {
            OAM_LOG(OAM, OAM_INFO,
                    "RACH  DISABLE REQ received from user for CID: %d", cid);
            cell_arr_idx = oam_get_son_serving_cell_idx(cid);
            if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        cid);
                /* spr 21390 fix start */
                *p_error_code = OAM_INVALID_CELL_CONTEXT;
                /* spr 21390 fix end */
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

            retVal = oam_mem_alloc(sizeof(son_oam_rach_opt_disable_req_t),
                    (void**)&p_son_rach_opt_disable_req, p_error_code);
            if (OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to p_son_rach_opt_disable_req failed"
						" with Error Code:%d",
						*p_error_code);
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }

            oam_memset(p_son_rach_opt_disable_req, OAM_ZERO,
                    sizeof(oam_son_rach_opt_disable_req_t));

            oam_memcpy(&p_son_rach_opt_disable_req->srv_cgi,
                    &SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi,
                    sizeof(son_intra_rat_global_cell_id_t));

            p_son_rach_opt_disable_req->bitmask |= SON_RACH_OPT_DISABLE_SRV_CGI_PRESENT;

            retVal = oam_son_send_son_oam_rach_opt_disable_req(p_son_rach_opt_disable_req,
                    OAM_MODULE_ID,
                    SON_MODULE_ID,
                    trans_id,
                    cid);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Error in sending SON_OAM_RACH_OPT_DISABLE_REQ message to lower layer");
            }
            else {
                OAM_LOG(OAM, OAM_INFO,
                        "SON_OAM_RACH_OPT_DISABLE_REQ sent to lower layer successfully");
                usr_intf_flag = OAM_TRUE;
#ifndef OAM_UT_FRAMEWORK
                oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);
#endif
            }
            oam_mem_free(p_son_rach_opt_disable_req, p_error_code);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

    }
    else if(oam_strstr(Parent_Name, SON_MRO_ENABLE)) {
        OAM_LOG(OAM, OAM_INFO,
                "CELL MRO ENABLE REQ received from user for CID: %d", cid);
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        retVal = oam_mem_alloc(sizeof(oam_son_mro_enable_req_t),
                (void**)&p_son_mro_enable_req, p_error_code);
        if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to p_son_mro_enable_req failed"
					" with Error Code:%d",
					*p_error_code);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        oam_memset(p_son_mro_enable_req, OAM_ZERO,
                sizeof(oam_son_mro_enable_req_t));

        oam_memcpy(&p_son_mro_enable_req->srv_cgi,
                &SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));

        p_son_mro_enable_req->bitmask |= SON_MRO_ENABLE_SRV_CGI_PRESENT;

        retVal = oam_son_send_son_oam_mro_enable_req(p_son_mro_enable_req,
                OAM_MODULE_ID,
                SON_MODULE_ID,
                trans_id,
                cid);
        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR,
                    "Error in sending SON_OAM_MRO_ENABLE_REQ message to lower layer");
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_MRO_ENABLE_REQ sent to lower layer successfully");
            usr_intf_flag = OAM_TRUE;
#ifndef OAM_UT_FRAMEWORK
            oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);
#endif
        }

        oam_mem_free(p_son_mro_enable_req, p_error_code);
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    else if(oam_strstr(Parent_Name, SON_MRO_DISABLE)) {
        OAM_LOG(OAM, OAM_INFO,
                "CELL MRO DISABLE REQ received from user for CID: %d", cid);

        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;

            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        retVal = oam_mem_alloc(sizeof(oam_son_mro_disable_req_t),
                (void**)&p_son_mro_disable_req, p_error_code);
        if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to p_son_mro_disable_req failed"
					" with Error Code:%d",
					*p_error_code);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }


        oam_memset(p_son_mro_disable_req, OAM_ZERO,
                sizeof(oam_son_mro_disable_req_t));

        oam_memcpy(&p_son_mro_disable_req->srv_cgi,
                &SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));

        p_son_mro_disable_req->bitmask |= SON_MRO_DISABLE_SRV_CGI_PRESENT;

        retVal = oam_son_send_son_oam_mro_disable_req(p_son_mro_disable_req,
                OAM_MODULE_ID,
                SON_MODULE_ID,
                trans_id,
                cid);
        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR,
                    "Error in sending SON_OAM_MRO_DISABLE_REQ message to lower layer");
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_MRO_DISABLE_REQ sent to lower layer successfully");
            usr_intf_flag = OAM_TRUE;
#ifndef OAM_UT_FRAMEWORK
            oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);
#endif
        }

        oam_mem_free(p_son_mro_disable_req, p_error_code);
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    else if(oam_strstr(Parent_Name, SON_MRO_MODIFY_CONFIG_PARAM)) {
        OAM_LOG(OAM, OAM_INFO,
                "Cell MRO parameter configuration request received "
                "from user for CID: %d", cid);

        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_memset(
                &LOCAL_SON_PROV_REQ.mro_modify_config_params_req[cell_arr_idx],
                OAM_ZERO,
                sizeof(oam_son_mro_modify_config_params_req_t));

        p_local_req =
            &LOCAL_SON_PROV_REQ.mro_modify_config_params_req[cell_arr_idx];

        oam_memcpy(
                &LOCAL_SON_PROV_REQ.mro_modify_config_params_req[cell_arr_idx].
                srv_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

        g_parameter_map_element = g_parameter_son_mro_modify_config_param;
    }
    else if(oam_strstr(Parent_Name, SON_MLB_ENABLE)) {
        OAM_LOG(OAM, OAM_INFO,
                "CELL MLB ENABLE REQ received from user for CID: %d", cid);

        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        retVal = oam_mem_alloc(sizeof(oam_son_mlb_enable_req_t),
                (void**)&p_son_mlb_enable_req, p_error_code);
        if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to p_son_mlb_enable_req failed"
					" with Error Code:%d",
					*p_error_code);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        oam_memset(p_son_mlb_enable_req, OAM_ZERO,
                sizeof(oam_son_mlb_enable_req_t));

        oam_memcpy(&p_son_mlb_enable_req->src_cgi,
                &SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));

        p_son_mlb_enable_req->bitmask |= SON_OAM_MLB_ENABLE_SRC_CGI_PRESENT;

        retVal = oam_son_send_son_oam_mlb_enable_req(p_son_mlb_enable_req,
                OAM_MODULE_ID,
                SON_MODULE_ID,
                trans_id,
                cid);
        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR,
                    "Error in sending SON_OAM_MLB_ENABLE_REQ message to lower layer, cell context = %d", cid);
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_MLB_ENABLE_REQ sent to lower layer successfully");
            usr_intf_flag = OAM_TRUE;
#ifndef OAM_UT_FRAMEWORK
            oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);
#endif
        }

        oam_mem_free(p_son_mlb_enable_req, p_error_code);
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    else if(oam_strstr(Parent_Name, SON_MLB_DISABLE)) {
        OAM_LOG(OAM, OAM_INFO,
                "CELL MLB DISABLE REQ received from user for CID: %d", cid);

        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        retVal = oam_mem_alloc(sizeof(oam_son_mlb_disable_req_t),
                (void**)&p_son_mlb_disable_req, p_error_code);
        if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to p_son_mlb_disable_req failed"
					" with Error Code:%d",
					*p_error_code);
            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        oam_memset(p_son_mlb_disable_req, OAM_ZERO,
                sizeof(oam_son_mlb_disable_req_t));

        oam_memcpy(&p_son_mlb_disable_req->src_cgi,
                &SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));

        p_son_mlb_disable_req->bitmask |= SON_OAM_MLB_DISABLE_SRC_CGI_PRESENT;

        retVal = oam_son_send_son_oam_mlb_disable_req(p_son_mlb_disable_req,
                OAM_MODULE_ID,
                SON_MODULE_ID,
                trans_id,
                cid);
        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR,
                    "Error in sending SON_OAM_MLB_DISABLE_REQ message to lower layer");
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_MLB_DISABLE_REQ sent to lower layer successfully");
            usr_intf_flag = OAM_TRUE;

#ifndef OAM_UT_FRAMEWORK
            oam_maintain_tcb(trans_id, OAM_TRANS_SON, msg_len, p_api_buf);
#endif
        }

        oam_mem_free(p_son_mlb_disable_req, p_error_code);
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }
    else if(oam_strstr(Parent_Name, SON_MLB_MODIFY_ATTR)) {
        OAM_LOG(OAM, OAM_INFO,
                "Cell MLB parameter configuration request received "
                "from user for CID: %d", cid);

        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_memset(
                &LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[cell_arr_idx],
                OAM_ZERO,
                sizeof(oam_son_mlb_modify_attributes_req_t));

        p_local_req =
            &LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[cell_arr_idx];

        oam_memcpy(
                &LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[cell_arr_idx].
                srv_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

        g_parameter_map_element = g_parameter_son_mlb_modify_attribute_val;
    }
    else if(oam_strstr(Parent_Name, "SON.ANR.MODIFY.UE_COUNT")) {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_memset(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_ue_count_req[cell_arr_idx],
                OAM_ZERO,
                sizeof(oam_son_anr_modify_ue_count_req_t));

        p_local_req =
            &LOCAL_SON_PROV_REQ.oam_son_anr_modify_ue_count_req[cell_arr_idx];

        oam_memcpy(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_ue_count_req[cell_arr_idx].
                src_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

        g_parameter_map_element = &(g_parameter_son_anr_modify_ue_count[OAM_ZERO]);
    }
    else if(OAM_ZERO == oam_strncasecmp(Parent_Name,
                "SON.ANR.MODIFY.MEAS_REPORTING_INTERVAL",
                oam_strlen("SON.ANR.MODIFY_MEAS_REPORTING_INTERVAL")))
    {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_memset(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_meas_reporting_interval_req[cell_arr_idx],
                OAM_ZERO,
                sizeof(oam_son_anr_modify_meas_reporting_interval_req_t));

        p_local_req =
            &LOCAL_SON_PROV_REQ.oam_son_anr_modify_meas_reporting_interval_req[cell_arr_idx];

        oam_memcpy(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_meas_reporting_interval_req[cell_arr_idx].
                src_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

        g_parameter_map_element = &(g_parameter_son_anr_modify_meas_reporting_interval[OAM_ZERO]);


    }
    else if(OAM_ZERO == oam_strncasecmp
            (Parent_Name, "SON.ANR.MODIFY.REMOVAL_ATTRIBUTES"
             , oam_strlen("SON.ANR.MODIFY.REMOVAL_ATTRIBUTES")))


    {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /* coverity fix 87109 start */
        oam_memset(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_removal_attributes_req[cell_arr_idx].src_cgi,
                OAM_ZERO,
                sizeof(son_intra_rat_global_cell_id_t));
        /* coverity fix 87109 end */

        p_local_req =
            &LOCAL_SON_PROV_REQ.oam_son_anr_modify_removal_attributes_req[cell_arr_idx].src_cgi;

        oam_memcpy(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_removal_attributes_req[cell_arr_idx].
                src_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

        g_parameter_map_element = &(g_parameter_son_anr_modify_removal_criteria[OAM_ZERO]);
    }

    else if(OAM_ZERO == oam_strncasecmp
            ((char *)Parent_Name,
             "SON.ANR.MODIFY.PCI_CONFUSION_CFG",
             oam_strlen("SON.ANR.MODIFY.PCI_CONFUSION_CFG")))
    {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_memset(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_pci_confusion_cfg_req[cell_arr_idx].src_cgi,
                OAM_ZERO,
                sizeof(oam_son_anr_modify_pci_confusion_cfg_req_t));

        p_local_req =
            &LOCAL_SON_PROV_REQ.oam_son_anr_modify_pci_confusion_cfg_req[cell_arr_idx].src_cgi;

        oam_memcpy(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_pci_confusion_cfg_req[cell_arr_idx].
                src_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));


        g_parameter_map_element = &(g_parameter_son_anr_modify_pci_confusion_cfg[OAM_ZERO]);

    }
    /* SPR 20653 Fix Start */
    else if(OAM_ZERO == oam_strncasecmp
            ((char *)Parent_Name,
             "SON.ANR.MODIFY.ATTRIBUTE",
             oam_strlen("SON.ANR.MODIFY.ATTRIBUTE")))
    {
        cell_arr_idx = oam_get_son_serving_cell_idx(cid);
        if(OAM_ERROR_RETURN_VAL == cell_arr_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                    cid);
            /* spr 21390 fix start */
            *p_error_code = OAM_INVALID_CELL_CONTEXT;
            /* spr 21390 fix end */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_memset(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_attribute_req[cell_arr_idx].src_cgi,
                OAM_ZERO,
                sizeof(oam_son_anr_modify_attribute_req_t));

        p_local_req =
            &LOCAL_SON_PROV_REQ.oam_son_anr_modify_attribute_req[cell_arr_idx].src_cgi;

        oam_memcpy(&LOCAL_SON_PROV_REQ.
                oam_son_anr_modify_attribute_req[cell_arr_idx].
                src_cgi,
                &(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

        g_parameter_map_element = &(g_parameter_son_anr_modify_attribute[OAM_ZERO]);
    }
    /* SPR 20653 Fix End */
#endif
    /* FLAG_CHANGES - Removed Code Here */
    else if (!oam_strcmp(Parent_Name, "Config.SaveConfig")) {
        OAM_LOG(OAM, OAM_INFO,
                "Command to save running configuration received");

        retVal = oam_qcli_save_current_config(p_api_buf_temp,
                p_error_code,
                trans_id, dest_id);
        if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
                    "Error in Saving Current Configuration for Persistance");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Running configuration saved successfully");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
    }
    else if (oam_strstr(Parent_Name, "Logs.Archive")) {
        OAM_LOG(OAM, OAM_DETAILED, "Saving Current Logs of OAM,RRM,L2,L3,SON");
        parameter_length =
            get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
        OAM_LOG(OAM, OAM_DETAILED, " parameter length  ::%d",
                parameter_length);
        parameter_name_length = parameter_length -OAM_FOUR;
        OAM_LOG(OAM,OAM_DETAILED," parameter name length  :: %d", parameter_name_length);
        /*SPR 16151 Fixed Start*/
        oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH_VALUE);
        /*SPR 16151 Fixed End*/
        oam_memcpy(Parameter_Name,p_api_buf_temp + OAM_FOUR,parameter_name_length);
        OAM_LOG(OAM, OAM_DETAILED, "Parameter-Value Pair: %s", Parameter_Name);

        name = oam_strtok(Parameter_Name, "=");
        OAM_LOG(OAM, OAM_DETAILED, "Parameter Name: %s", name);
        value = oam_strtok(OAM_NULL, "=");
        OAM_LOG(OAM, OAM_DETAILED, "Assigned Value: %s", value);

        if(OAM_FAILURE == oam_save_current_logs(p_api_buf_temp,p_error_code,trans_id,dest_id))
        {
			OAM_LOG(OAM,OAM_WARNING,"Error in Saving Current Logs");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        else
        {
            OAM_FUN_EXIT_TRACE();
            return OAM_SUCCESS;
        }
    }
    else if (!oam_strncmp(Parent_Name, "Cell", oam_strlen("Cell")) ||
            !oam_strncmp(Parent_Name, "Enable.RRM",
                oam_strlen("Enable.RRM")) ||
            !oam_strncmp(Parent_Name, "Disable.RRM",
                oam_strlen("Disable.RRM")))
    {
        g_parameter_map_element = g_parameter_CONTROL_COMMAND_element;
        control_command_flag = OAM_TRUE;
    }
    else if (!oam_strncmp(Parent_Name, "eNB.Download",
                oam_strlen("eNB.Download")) ||
            !oam_strncmp(Parent_Name, "eNB.Switch",
                oam_strlen("eNB.Switch")))
    {
        control_command_flag = OAM_TRUE;
    }
    else {
        *p_error_code = OAM_PARAMETER_NOT_FOUND;
        /* Send set parameters response from here only */
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                OAM_ERR_INVALID_PARAM_NAME,
                (UInt8 *) "Parameter not found", oam_strlen("Parameter not found") + OAM_ONE,
                OAM_VERSION_ID, OAM_MODULE_ID,
                dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                p_error_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;
    } 


    for(loop=OAM_ZERO; loop < Number_of_parameters; loop++)
    {
        parameter_length = get_word_from_header((UInt8*)(p_api_buf_temp) + OAM_ZERO);
        parameter_name_length = parameter_length - OAM_FOUR;

        /*SPR 16151 Fixed Start*/
        oam_memset(&Parameter_Name,OAM_ZERO,MAX_PARAMETER_NAME_LENGTH_VALUE);
        /*SPR 16151 Fixed End*/
        oam_memcpy(Parameter_Name,(p_api_buf_temp +OAM_FOUR),parameter_name_length);
        OAM_LOG(OAM, OAM_DETAILED, "Parameter-Value Pair: %s", Parameter_Name);

        /*SPR 16151 Fixed Start*/
        oam_memset(&parent_parameter_name, OAM_ZERO, 
                MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH_VALUE);
        /*SPR 16151 Fixed End*/

        oam_strcat(parent_parameter_name, Parent_Name);    
        oam_strcat(parent_parameter_name,".");
        oam_strcat(parent_parameter_name,Parameter_Name);

        retVal = oam_check_param_input_validity(parent_parameter_name);

        if (OAM_FAILURE == retVal) {
            *p_error_code = OAM_SET_PARAMETER_INPUT_INCORRECT;
            /* Coverity ID 85867 Fix Start*/
            if(p_local_req_memfree_flag){
                oam_mem_free(p_local_req, p_error_code);
                /*  coverity 85867 fix start */
                /*SPR 18504 FIX START*/
                p_local_req_memfree_flag=OAM_FALSE; 
                /*SPR 18504 FIX END*/
                p_local_req = OAM_NULL;
                /*  coverity 85867 fix end */
            }
            /* Coverity ID 85867 Fix End*/

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }
        OAM_LOG(OAM, OAM_DETAILED, "Fully Qualified Parameter Name-Value pair: %s", parent_parameter_name);

        if(NULL != oam_strstr(parent_parameter_name,"URL"))
            fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"URL",loop);
        if(NULL != oam_strstr(parent_parameter_name,"PeriodicUploadTime"))
            fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"PeriodicUploadTime",loop);
        if(NULL != oam_strstr(parent_parameter_name,"PeriodicUploadInterval"))
            fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"PeriodicUploadInterval",loop);
        if(NULL != oam_strstr(parent_parameter_name,"Enable"))
            fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"Enable",loop);
        if(NULL != oam_strstr(parent_parameter_name,"Username"))
            fill_str_for_multi_instance(temp_ptr,(UInt8 *)"InternetGatewayDevice.FAP.PerfMgmt.Config",(UInt8 *)"Username",loop);

        /* SPR 12447 Fix Start*/
        /* spr_21013_fix_start */
        if(NULL != oam_strstr(parent_parameter_name,"InternetGatewayDevice.Services.FAPService.AccessMgmt.LTE.CSGID"))
            /* spr_21013_fix_end */
        {
            if (RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx].access_mgmt_params.access_mode == OAM_TWO
                    ||LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx].access_mgmt_params.access_mode == OAM_TWO)
            {
                if(LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx].access_mgmt_params.access_mode != OAM_ZERO
                        &&LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx].access_mgmt_params.access_mode != OAM_ONE)
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INVALID_PARAM_VALUE,
                            (UInt8 *) "CSGID Cant Be set While Access Mode Is Open Access",
                            oam_strlen("CSGID Cant Be set While Access Mode Is Open Access")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                            p_error_code);
                }
            }
        }
        /* SPR 12447 Fix End*/

        /*Coverity fix Comments*/
        name = oam_strtok((char *)parent_parameter_name, "=");
        OAM_NULL_CHECK(NULL != name);/* Coverity FIX 35436-9 */
        OAM_LOG(OAM, OAM_DETAILED, "Parameter Name: %s", name);
        value = oam_strtok(OAM_NULL, "=");         
        OAM_LOG(OAM, OAM_DETAILED, "Assigned Value: %s", value);
#ifdef LTE_EMBMS_SUPPORTED
        oam_memcpy(DuplexMode, oam_prov_req.oam_tr069_req.tr069_init_params.DuplexMode,
                OAM_MAX_STR_LEN);
        if (!(oam_strcmp("FDDMode", (char*)DuplexMode)))
        {
            if (((oam_strstr(name, "X_VENDOR_NEIGHBOR_CELL_CONFIG")) ||
                        (oam_strstr(name, "NeighCellConfig"))) &&
                    (oam_atoi(value) == OAM_THREE))
            {
                *p_error_code = OAM_MBMS_DISABLED_WRONG_NEIGHCELLCONFIG;
                OAM_LOG(OAM, OAM_ERROR, "\nOperator can't configure "
                        "EMBMS with neigh_cell_config 3 for intra cell");
                retVal = OAM_FAILURE;

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
        }
#endif


        /* Spr 15596 Fix Start */


        if((!oam_strcmp(name,"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].Username"))||
                (!oam_strcmp(name,"InternetGatewayDevice.FAP.PerfMgmt.Config.[1].Password"))||
                (!oam_strcmp(name,"InternetGatewayDevice.FTPParams.FTPServerUserName"))||
                (!oam_strcmp(name,"InternetGatewayDevice.FTPParams.FTPServerpassword"))||
                (strstr(name,"SecGWServer")))
        {
            /* Do nothing as these parameter can be empty string */
        }
        else
        {
            /* Coverity CID 72259 Fix Start */
            if(OAM_NULL == value)
            {
                /* spr 21390 fix start */
                *p_error_code = OAM_NULL_POINTER_ERR;
                /* spr 21390 fix end */
                OAM_LOG(OAM,OAM_DETAILED,"NULL CHECK FAILURE!");
                return OAM_FAILURE;
            }

        }
        /* Spr 15596 Fix End */

        if (NULL != oam_strstr(Parent_Name, "LGW.Add"))
        {
            if(OAM_FALSE == oam_rrc_lgw_enable)
            {
                oam_maintain_tcb(trans_id,OAM_TRANS_RRC,msg_len,p_api_buf);
                oam_send_lgw_add_req(&oam_rrc_add_lgw_req, value, trans_id,p_api_buf,msg_len);
            }
            else
            {
                /* SPR 9709 FIX START */
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_REQUEST_DENIED,
                        (UInt8 *)"LGW Already Added !!",oam_strlen("LGW Already Added !!") + 1,
                        OAM_VERSION_ID, OAM_MODULE_ID,
                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                        p_error_code);
                /* SPR 9709 FIX END */
            }
            return OAM_SUCCESS; 
        }
        oam_rrm_config_capacity_enc_handling(parent_parameter_name,&oam_ul_dl_qci_cli_input,value);

        if(oam_strncasecmp(parent_parameter_name,"Disable.RRM.ECNCapacityEnhancement",
                    oam_strlen("Disable.RRM.ECNCapacityEnhancement"))== OAM_ZERO)
        {
            temp_ue_var = (SInt8)(oam_atoi(value));
        }
        if (oam_strncasecmp((char *)parent_parameter_name, "RRM.UE.RELEASE.X_VENDOR_COMMAND_UE_RELEASE_UE_INDEX",
                    oam_strlen("RRM.UE.RELEASE.X_VENDOR_COMMAND_UE_RELEASE_UE_INDEX")) == OAM_ZERO)
        {
            p_rrm_oam_ue_release_req.ue_index = (UInt16)(oam_atoi(value));
        }
        if(NULL != oam_strstr(parent_parameter_name,"Enable"))

        {
            if(NULL != oam_strstr(parent_parameter_name,"PerfMgmt"))
            {   
                if (g_pm_xml_params.pm_xml_file_reporting !=
                        (UInt8) oam_atoi(value))
                {
                    g_pm_xml_params.pm_xml_file_reporting = (UInt8) oam_atoi(value);
                    g_pm_xml_params.spv_bitmask |= PM_XML_SPV_PM_REPORT_EN_DISABLE;
                }
                spv_for_pm_xml_params = OAM_TRUE;
                oam_set_config_req.flag = OAM_TRUE; 
                oam_prov_req.oam_igd_params.perf_mgmt_params.Enable = (UInt32)(oam_atoi(value));
            } 

        }
        if((NULL != oam_strstr(parent_parameter_name,"URL")) && 
                (NULL != oam_strstr(parent_parameter_name,"PerfMgmt")))
        {
            oam_strcpy((char *)oam_prov_req.oam_igd_params.perf_mgmt_params.URL,value); 
            oam_set_config_req.flag = OAM_TRUE;     
        }
        if(NULL != oam_strstr(parent_parameter_name,"ConfigNumberOfEntries"))
        {
            if(OAM_ONE  == (UInt32)(oam_atoi(value)) )
            {
                oam_prov_req.oam_igd_params.perf_mgmt_params.ConfigNumberOfEntries = (UInt32)(oam_atoi(value));
                value_flag = OAM_ONE;
            }
            else
                value_flag = OAM_TWO; 
            config_number_of_entries_flag = OAM_TRUE;
            oam_set_config_req.flag = OAM_TRUE;  //flag set for not to send config request   
        }
        /* SPR 17880 18JAN FIX START */
        if( (NULL != oam_strstr(parent_parameter_name,"Username")) &&
                (NULL != oam_strstr(parent_parameter_name,"PerfMgmt")) )
            /* SPR 17880 18JAN FIX END */
        {
            /* Spr 15596 Fix Start */
            if(NULL != value)
            {
                oam_strcpy((char *)oam_prov_req.oam_igd_params.perf_mgmt_params.Username,value);
            }
            else
            {
                oam_prov_req.oam_igd_params.perf_mgmt_params.Username[0] = '\0';

            }
            oam_set_config_req.flag = OAM_TRUE; 
            oam_persist_one_parameter(xml_struct_tr196_g.Config,
                    "Username",(UInt8*)value);
            /* Spr 15596 Fix End */
        }        
        /* SPR 17880 18JAN FIX START */
        if( (NULL != oam_strstr(parent_parameter_name,"Password")) &&
                (NULL != oam_strstr(parent_parameter_name,"PerfMgmt")) )
            /* SPR 17880 18JAN FIX END */
        {
            /* Spr 15596 Fix Start */
            if(NULL != value)
            {
                oam_strcpy((char *)oam_prov_req.oam_igd_params.perf_mgmt_params.Password,value);
            }
            else
            {
                oam_prov_req.oam_igd_params.perf_mgmt_params.Password[0] = '\0';
            }
            oam_set_config_req.flag = OAM_TRUE; 
            oam_persist_one_parameter(xml_struct_tr196_g.Config,
                    "Password",(UInt8*)value);
            /* Spr 15596 Fix End */
        } 
        if(NULL != oam_strstr(parent_parameter_name,"PeriodicUploadInterval"))

        {
            if (OAM_FAILURE == oam_validate_pm_params(parent_parameter_name, (oam_atoi(value))))
            {
                *p_error_code = OAM_SET_PARAMETER_INPUT_INCORRECT;
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_INVALID_PARAM_VALUE,
                        (UInt8 *) "OAM Set Parameter Value - Incorrect Input Error", 
                        oam_strlen("OAM Set Parameter Value - Incorrect Input Error")+ OAM_ONE, 
                        OAM_VERSION_ID, OAM_MODULE_ID,
                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                        p_error_code);
                return OAM_SUCCESS;
            }
            if (g_pm_xml_params.pm_xml_upload_interval_timer != (UInt64)(oam_atoi(value)))
            {
                g_pm_xml_params.pm_xml_upload_interval_timer = (UInt64)(oam_atoi(value)); 
                g_pm_xml_params.spv_bitmask |= PM_XML_SPV_UPLOAD_INTERVAL_TIMER;
            }

            oam_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadInterval = (UInt32)(oam_atoi(value)); 
            oam_set_config_req.flag = OAM_TRUE; 
            spv_for_pm_xml_params = OAM_TRUE;
            /*SPR 14966 start*/
            spv_persist_for_pm_xml_params = OAM_TRUE;
            /*SPR 14966 end*/

        }
        if(NULL != oam_strstr(parent_parameter_name,"X_VENDOR_SamplingInterval"))

        {
            if (OAM_FAILURE == oam_validate_pm_params(parent_parameter_name, (oam_atoi(value))))
            {
                *p_error_code = OAM_SET_PARAMETER_INPUT_INCORRECT;
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_INVALID_PARAM_VALUE,
                        (UInt8 *) "OAM Set Parameter Value - Incorrect Input Error", 
                        oam_strlen("OAM Set Parameter Value - Incorrect Input Error")+ OAM_ONE, 
                        OAM_VERSION_ID, OAM_MODULE_ID,
                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                        p_error_code);

                return OAM_SUCCESS;
            }
            new_sampling_timer_val =  (UInt16)((oam_atoi(value)) * OAM_SIXTY);/*Coverity FIX 54276 */
            sampling_timer_val = (g_pm_xml_params.pm_xml_sampling_interval_timer);
            /*SPR 20171 Start */
            OAM_LOG(OAM, OAM_DETAILED, "Sampling timer = %d Upload Timer %llu, File Write Timer %llu",
                    g_pm_xml_params.pm_xml_sampling_interval_timer,
                    g_pm_xml_params.pm_xml_upload_interval_timer,
                    g_pm_xml_params.pm_xml_file_write_timer
                   );

            /*SPR 20171 End */


            if (sampling_timer_val != new_sampling_timer_val)
            {
                g_pm_xml_params.pm_xml_sampling_interval_timer = (UInt16)(oam_atoi(value)) * OAM_SIXTY;
                g_pm_xml_params.spv_bitmask |= PM_XML_SPV_SAMPLING_INTERVAL_TIMER;
                /* SPR-13139 START */            
                /*SPR 14966 start*/
                /*deleted*/
                /*SPR 14966 end*/
                /* SPR-13139 END */       
                /*SPR 20171 Start */

                OAM_LOG(OAM, OAM_DETAILED, "Sampling timer = %d Upload Timer %llu, File Write Timer %llu",
                        g_pm_xml_params.pm_xml_sampling_interval_timer,
                        g_pm_xml_params.pm_xml_upload_interval_timer,
                        g_pm_xml_params.pm_xml_file_write_timer
                       );
                /*SPR 20171 End*/


            }

            oam_prov_req.oam_igd_params.perf_mgmt_params.sampling_interval_timer = (UInt16)(oam_atoi(value));
            /* SPR_19838 :Coverity_12908 Fix Start */
            if(value >0)
            {
                oam_strcpy((char *)oam_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadTime,value);
            }

            /*SPR_20000 :Coverity_87096 Fix Start*/
            else
            {
                oam_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadTime[0] ='\0';
            }
            /*SPR_20000 :Coverity_87096 Fix End*/
            /* SPR_19838 :Coverity_12908 Fix Stop */
            oam_set_config_req.flag = OAM_TRUE; //flag set for not to send config request
            spv_for_pm_xml_params = OAM_TRUE;
            /*SPR 14966 start*/
            spv_persist_for_pm_xml_params = OAM_TRUE;
            /*SPR 14966 end*/
        }
        /*SPR_20065:Coverity_87096 Fix Start*/
        if((value != NULL) && (NULL != oam_strstr(parent_parameter_name,"PeriodicUploadTime")))
            /*SPR_20065:Coverity_87096 Fix End*/

        {
            if(OAM_FAILURE == oam_validate_upload_time(value))
            {
                *p_error_code = OAM_SET_PARAMETER_INPUT_INCORRECT;
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_INVALID_PARAM_VALUE,
                        (UInt8 *) "OAM Set Parameter Value - Incorrect Input Error", 
                        oam_strlen("OAM Set Parameter Value - Incorrect Input Error")+ OAM_ONE, 
                        OAM_VERSION_ID, OAM_MODULE_ID,
                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                        p_error_code);

                return OAM_SUCCESS;
            }
            if (oam_strncmp((char*)value, (char*)g_pm_xml_params.periodic_upload_timer_str, 
                        sizeof(g_pm_xml_params.periodic_upload_timer_str)) != OAM_ZERO)
            {
                oam_memset(g_pm_xml_params.periodic_upload_timer_str,OAM_ZERO,sizeof(g_pm_xml_params.periodic_upload_timer_str));

                /* COV_FIX_18_JUN */
                oam_strncpy(g_pm_xml_params.periodic_upload_timer_str, value,
                        sizeof(g_pm_xml_params.periodic_upload_timer_str) - OAM_ONE); /*COVERITY FIX 25may*/
                /* COV_FIX_18_JUN */
                g_pm_xml_params.spv_bitmask |= PM_XML_SPV_UPLOAD_TIMER;
            }
            /*SPR 20171 Start */

            OAM_LOG(OAM, OAM_DETAILED, "Sampling timer = %d Upload Timer %llu, File Write Timer %llu",
                    g_pm_xml_params.pm_xml_sampling_interval_timer,
                    g_pm_xml_params.pm_xml_upload_interval_timer,
                    g_pm_xml_params.pm_xml_file_write_timer
                   );

            /*SPR 20171 End */

            if((OAM_PM_XML_UPLOAD_ITRVL_TMR) == (g_pm_xml_params.pm_xml_upload_interval_timer))
            {
                if (g_pm_xml_params.pm_xml_sampling_interval_timer != OAM_PM_XML_SAMPLNG_ITRVL_TMR)
                {
                    g_pm_xml_params.pm_xml_sampling_interval_timer = OAM_PM_XML_SAMPLNG_ITRVL_TMR;
                    g_pm_xml_params.spv_bitmask |= PM_XML_SPV_SAMPLING_INTERVAL_TIMER;
                    /*SPR 20171 Start */

                    OAM_LOG(OAM, OAM_DETAILED, "Sampling timer = %d Upload Timer %llu, File Write Timer %llu",
                            g_pm_xml_params.pm_xml_sampling_interval_timer,
                            g_pm_xml_params.pm_xml_upload_interval_timer,
                            g_pm_xml_params.pm_xml_file_write_timer
                           );
                    /*SPR 20171 End */


                }
            }

            oam_strcpy((char *)oam_prov_req.oam_igd_params.perf_mgmt_params.PeriodicUploadTime,value); 
            oam_set_config_req.flag = OAM_TRUE; 
            spv_for_pm_xml_params = OAM_TRUE;
            /*SPR 14966 start*/
            spv_persist_for_pm_xml_params = OAM_TRUE;
            /*SPR 14966 end*/
        }
        if(NULL != oam_strstr(parent_parameter_name,"X_VENDOR_FileWriteTimer"))
        {
            if (OAM_FAILURE == oam_validate_pm_params(parent_parameter_name, (oam_atoi(value))))
            {
                *p_error_code = OAM_SET_PARAMETER_INPUT_INCORRECT;
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_INVALID_PARAM_VALUE,
                        (UInt8 *) "OAM Set Parameter Value - Incorrect Input Error", 
                        oam_strlen("OAM Set Parameter Value - Incorrect Input Error")+ OAM_ONE, 
                        OAM_VERSION_ID, OAM_MODULE_ID,
                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                        p_error_code);

                return OAM_SUCCESS;
            }
            /*SPR 20171 Start */
            OAM_LOG(OAM, OAM_DETAILED, "Sampling timer = %d Upload Timer %llu, File Write Timer %llu",
                    g_pm_xml_params.pm_xml_sampling_interval_timer,
                    g_pm_xml_params.pm_xml_upload_interval_timer,
                    g_pm_xml_params.pm_xml_file_write_timer
                   );
            /*SPR 20171 End */


            if ((g_pm_xml_params.pm_xml_file_write_timer/OAM_SIXTY) != (UInt16)(oam_atoi(value)))
            {
                g_pm_xml_params.pm_xml_file_write_timer = (UInt16)(oam_atoi(value)) * OAM_SIXTY;
                /*SPR 20171 Start */
                OAM_LOG(OAM, OAM_DETAILED, "Sampling timer = %d Upload Timer %llu, File Write Timer %llu",
                        g_pm_xml_params.pm_xml_sampling_interval_timer,
                        g_pm_xml_params.pm_xml_upload_interval_timer,
                        g_pm_xml_params.pm_xml_file_write_timer
                       );
                /*SPR 20171 End */


            }
            /* Cov CID 54869 fix */
            g_pm_rrm_xml_params.pm_rrm_xml_file_write_timer = (UInt16)(oam_atoi(value)) * OAM_SIXTY;
            oam_prov_req.oam_igd_params.perf_mgmt_params.file_write_timer = (UInt16)(oam_atoi(value));
            oam_set_config_req.flag = OAM_TRUE; 

            /* SPR-13139 START */            
            g_pm_xml_params.spv_bitmask |= PM_XML_SPV_FILE_WRITE_TIMER;
            spv_for_pm_xml_params = OAM_TRUE;
            /* SPR-13139 END */            
            /*SPR 14966 start*/
            /*deleted*/;
            spv_persist_for_pm_xml_params = OAM_TRUE;
            /*SPR 14966 end*/

        }

        /* SPR 12428 FIX END */
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.gbrBktDepthFactor",
                    oam_strlen("Modify.MACQosParams.gbrBktDepthFactor"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.gbrBktDepthFactor = (UInt8)(oam_atoi(value)); 
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_GBR_BKT_DEPTH_FACTOR;  

        }
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.ambrBktDepthFactor",
                    oam_strlen("Modify.MACQosParams.ambrBktDepthFactor"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.ambrBktDepthFactor = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_AMBR_BKT_DEPTH_FACTOR;  
        }
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.tokenPeriodicity",
                    oam_strlen("Modify.MACQosParams.tokenPeriodicity"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.tokenPeriodicity = (UInt16)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_TOKEN_PERIODICITY;  
        }
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.qosStrategyOverallocFactor",
                    oam_strlen("Modify.MACQosParams.qosStrategyOverallocFactor"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.qosStrategyOverallocFactor = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_QOS_STRATEGY_OVERALLOC_FACTOR; 
        }
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.dlQosStrategyWeights.pdbWeight",
                    oam_strlen("Modify.MACQosParams.dlQosStrategyWeights.pdbWeight"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.dlQosStrategyWeights.pdbWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_DL_QOS_STRATEGY_WEIGHT;  
        }
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.dlQosStrategyWeights.qciWeight",
                    oam_strlen("Modify.MACQosParams.dlQosStrategyWeights.qciWeight"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.dlQosStrategyWeights.qciWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_DL_QOS_STRATEGY_WEIGHT;  
        }         
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.dlQosStrategyWeights.tokenWeight",
                    oam_strlen("Modify.MACQosParams.dlQosStrategyWeights.tokenWeight"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.dlQosStrategyWeights.tokenWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_DL_QOS_STRATEGY_WEIGHT;  
        }
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.dlQosStrategyWeights.qLoadWeight",
                    oam_strlen("Modify.MACQosParams.dlQosStrategyWeights.qLoadWeight"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.dlQosStrategyWeights.qLoadWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_DL_QOS_STRATEGY_WEIGHT;  
        }
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.dlQosStrategyWeights.mcsWeight",
                    oam_strlen("Modify.MACQosParams.dlQosStrategyWeights.mcsWeight"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.dlQosStrategyWeights.mcsWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_DL_QOS_STRATEGY_WEIGHT;  
        }
        /*SPR 12091 FIX START*/
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.ulQosStrategyWeights.pdbWeight",
                    oam_strlen("Modify.MACQosParams.ulQosStrategyWeights.pdbWeight"))== OAM_ZERO)
            /*SPR 12091 FIX END*/
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.ulQosStrategyWeights.pdbWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_UL_QOS_STRATEGY_WEIGHT;  
        }
        /*SPR 12091 FIX START*/
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.ulQosStrategyWeights.qciWeight",
                    oam_strlen("Modify.MACQosParams.ulQosStrategyWeights.qciWeight"))== OAM_ZERO)
            /*SPR 12091 FIX END*/
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.ulQosStrategyWeights.qciWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_UL_QOS_STRATEGY_WEIGHT;  
        }
        /*SPR 12091 FIX START*/
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.ulQosStrategyWeights.tokenWeight",
                    oam_strlen("Modify.MACQosParams.ulQosStrategyWeights.tokenWeight"))== OAM_ZERO)
            /*SPR 12091 FIX END*/
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.ulQosStrategyWeights.tokenWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_UL_QOS_STRATEGY_WEIGHT;  
        }
        /*SPR 12091 FIX START*/
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.ulQosStrategyWeights.qLoadWeight",
                    oam_strlen("Modify.MACQosParams.ulQosStrategyWeights.qLoadWeight"))== OAM_ZERO)
            /*SPR 12091 FIX END*/
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.ulQosStrategyWeights.qLoadWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_UL_QOS_STRATEGY_WEIGHT;  
        }

        /*SPR 12091 FIX START*/
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.ulQosStrategyWeights.mcsWeight",
                    oam_strlen("Modify.MACQosParams.ulQosStrategyWeights.mcsWeight"))== OAM_ZERO)
            /*SPR 12091 FIX END*/
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.ulQosStrategyWeights.mcsWeight = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_UL_QOS_STRATEGY_WEIGHT;  
        }
        else if(oam_strncasecmp(parent_parameter_name,"Modify.MACQosParams.enableAllocAfterAllowedBitrate",
                    oam_strlen("Modify.MACQosParams.enableAllocAfterAllowedBitrate"))== OAM_ZERO)
        {
			local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.enableAllocAfterAllowedBitrate = (UInt8)(oam_atoi(value));
            Modify_MacQos_flag_bitmask =  Modify_MacQos_flag_bitmask | OAM_MOD_ENABLE_ALLOC_AFTER_ALLOWED_BITRATE; 
        }

        /* SPR-13187 START */
        if (oam_strncasecmp((char *)parent_parameter_name, "InternetGatewayDevice.ManagementServer.URL",
                    oam_strlen("InternetGatewayDevice.ManagementServer.URL")) == OAM_ZERO)
        {
            /* Persist the value */
            oam_persist_one_parameter(xml_struct_tr196_g.ManagementServer,
                    "X_VENDOR_CONNECT_TO_IHEMS",(UInt8*)"0");
        }
        /* SPR-13187 END */

        /* Spr 15596 Fix Start */
        /* Code Removed */
        /* Spr 15596 Fix End */

        /*Control Commands */
        if (control_command_flag) {
            if (!oam_strncmp(Parent_Name, "Cell", oam_strlen("Cell"))) {
                if (oam_strstr(parent_parameter_name, "Start")) {
                    /* BUG_9339_FIXED */
                    usr_intf_flag = OAM_TRUE;
                    /*BUG_9339_FIXED */
                    paramter_app_map_tbl |= RRM_OAM_CELL_START_REQ_MASK;
                }
                else if (oam_strstr(parent_parameter_name, "Stop")) {
                    paramter_app_map_tbl |= RRM_OAM_CELL_STOP_REQ_MASK;
                    usr_intf_flag = OAM_TRUE;
                }
                else if (oam_strstr(parent_parameter_name, "Delete")) {
                    paramter_app_map_tbl |= RRM_OAM_CELL_DELETE_REQ_MASK;
                }
                else if(oam_strstr(parent_parameter_name, "Unblock")) {
                    paramter_app_map_tbl |= OAM_RRM_CELL_UNBLOCK_REQ_MASK;
                }
                else if (oam_strstr(parent_parameter_name, "Block")) {
                    paramter_app_map_tbl |= OAM_RRM_CELL_BLOCK_REQ_MASK;
                    oam_prov_req.system_status.event_ongoing |=
                        OAM_RRM_CELL_BLOCK_REQ_MASK;
                    /*SPR 14451 START*/ 
                    g_parameter_map_element = &g_parameter_cell_block_param[OAM_ZERO];
                    cell_block_flag = OAM_TRUE;
                    if(oam_strstr(parent_parameter_name, "Block.Cell_Block_Priority"))
                    {
                        local_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_priority =     
                            (rrm_oam_cell_block_priority_et)oam_atoi(value); 
                    }    
                    if(oam_strstr(parent_parameter_name, "Block.Resource_Cleanup_Timer"))
                    {
                        local_prov_req.oam_rrm_req.rrm_cell_block_req.cell_block_resource_cleanup_timer = 
                            (S16)oam_atoi(value); 
                        local_prov_req.oam_rrm_req.rrm_cell_block_req.bitmask |= 
                            RRM_OAM_CELL_BLOCK_WAIT_TIMER_PRESENT;
                    }    
                    /*SPR 14451 END*/
                }
                else if (oam_strstr(parent_parameter_name, "Setup")) {
                    usr_intf_flag = OAM_TRUE;

                    /*SPR 21412 Fix Start */
                    /*SPR 21412 Fix End */
                    paramter_app_map_tbl |= RRM_OAM_CELL_SETUP_REQ_MASK;
                }

                /*SPR 14451 START*/
                if(cell_block_flag == OAM_FALSE){

                    retVal = oam_send_message_to_lower_layers(OAM_MODULE_ID,
                            msg_len, p_api_buf,
                            OAM_NULL,
                            OAM_NULL,
                            OAM_NULL,
                            OAM_NULL,
                            p_error_code);
                    if (OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_WARNING, "Failed to process request.");
                    }

                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }
                /*SPR 14451 END*/
            }
            /*CELL_SETUP_2.0*/
            else if (oam_strncasecmp(parent_parameter_name, "Enable.RRM.Radio_admission_control",
                        oam_strlen("Enable.RRM.Radio_admission_control")) == OAM_ZERO)
            {
                paramter_app_map_tbl |= RRM_OAM_RAC_ENABLE_REQ_MASK;
                retVal = oam_send_message_to_lower_layers(OAM_MODULE_ID,
                        msg_len, p_api_buf,
                        OAM_NULL,
                        OAM_NULL,
                        OAM_NULL,
                        OAM_NULL,
                        p_error_code);
                if (OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_WARNING, "Failed to process request.");
                }

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            else if(oam_strstr(parent_parameter_name, "eNB.Download")) {
                oam_memset(local_prov_req.oam_nms_ftp_server_params.sw_package_name,
                        OAM_ZERO, OAM_FTP_SW_PACKAGE_NAME_SIZE); 
                oam_strncpy(
                        (char *)local_prov_req.oam_nms_ftp_server_params.sw_package_name,
                        (const char *)value, oam_strlen(value));

                Char8 curl_error_msg[OAM_CURL_ERROR_MSG_ZIZE] = {OAM_ZERO};         
                CURLcode curl_error_code = CURLE_OK;
                retVal = oam_file_download_from_server(
                        &local_prov_req.oam_nms_ftp_server_params,
                        &curl_error_code, p_error_code);
                if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_WARNING,
                            "File Download from specified server failed");

                    oam_strncpy(err_str, "Image Download Failure",
                            OAM_USR_INTF_ERR_STR_MAX_SIZE);
                    usr_resp_code = OAM_RESULT_FAILURE;
                    usr_resp_err_code = OAM_ERR_INTERNAL_ERROR;
                    err_str_len = oam_strlen(err_str) + 1;

                    oam_snprintf(curl_error_msg,OAM_CURL_ERROR_MSG_ZIZE, 
                            "FTP Download failed, Libcurl error code: %d",
                            curl_error_code);
                    OAM_ALARM(IMAGE_DOWNLOAD_FAILURE_ALARM_ID,
                            MAJOR, NOTIFY_NEW_ALARM,
                            COMMUNICATIONS_ALARM,
                            COMMUNICATIONS_RECEIVE_FAILURE,
                            /* Spr 12880 Fix Start*/
                            EXPEDITED_ALARM, curl_error_msg, OAM_NULL,CellId);
                    /* Spr 12880 Fix End*/
                }
                else {
                    /* SPR 14647 FIX START */
                    //retVal = OAM_SUCCESS;
                    /* SPR 14647 FIX END */
                    usr_resp_code = OAM_RESULT_SUCCESS;
                    usr_resp_err_code = OAM_ZERO;
                    err_str_len = OAM_ZERO;
                }

                oam_construct_n_send_set_resp_to_usr(usr_resp_code,
                        usr_resp_err_code,
                        (UInt8*)err_str,
                        err_str_len,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id, trans_id,
                        OAM_ZERO, OAM_ZERO,
                        p_error_code);
                /* SPR 14647 FIX START */
                /* 
                   As we've sent response to user for both the success and
                   failure case, the transaction is completed and function
                   return value should be success
                   */
                retVal = OAM_SUCCESS;
                /* SPR 14647 FIX END */
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            else if (oam_strncasecmp((char *)parent_parameter_name, "eNB.Switch.", oam_strlen("eNB.Switch")) == OAM_ZERO)
            {
                /*SARAB:: Perform File Upgrade*/               
                oam_handle_software_upgrade_from_cli_or_snmp((UInt8 *)value,p_api_buf);
                return OAM_SUCCESS;
            }
            else if (oam_strncasecmp((char *)parent_parameter_name, "Disable.RRM.Radio_admission_control",
                        oam_strlen("Disable.RRM.Radio_admission_control")) == OAM_ZERO)
            {
                paramter_app_map_tbl = RRM_OAM_RAC_DISABLE_REQ_MASK;

                retVal = oam_send_message_to_lower_layers(OAM_MODULE_ID,
                        msg_len, p_api_buf,
                        OAM_NULL,
                        OAM_NULL,
                        OAM_NULL,
                        OAM_NULL,
                        p_error_code);
                if (OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_WARNING, "Failed to process request.");
                }

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            /* CSR 59167 removed*/
        }
        /* Control Commands */
        /* SPR 9986 FIX START */
        if (
                (NULL == oam_strstr(Parent_Name,"PerfMgmt.Config.Start"))&&
                (NULL == oam_strstr(Parent_Name,"PerfMgmt.Config.Stop"))&&
                (NULL == oam_strstr(Parent_Name,"PerfMgmt.Config.Ondemand")) &&
                ((OAM_TRUE == spv_persist_for_pm_xml_params)|| 
                 (OAM_FALSE == spv_for_pm_xml_params))&& 
                (OAM_ZERO == Modify_MacQos_flag) &&
                (OAM_FALSE == Config_CapacityEnc_flag) &&
                (OAM_FALSE == ue_Release_flag) &&
                /*SPR 14451 START*/ 
                (OAM_FALSE == Config_CapacityEnc_dis_flag)&&
                (OAM_FALSE == cell_block_flag))
            /*SPR 14451 END*/
        {
            /* SPR 9986 FIX END */
            *p_error_code = NO_ERROR;

            /* Send paramter name & value to update global mapp structure value */
            retVal = oam_update_set_parameter(name, value,
                    p_local_req,
                    &p_orig_parent,
                    &p_req_parent,
                    &p_p_xml_struct_addr,
                    /* SPR 17777 fix code removed */
                    /* SPR 18930  FIX START */
                    p_error_code,
                    cell_arr_idx);
            /* SPR 18930  FIX END */
            if (OAM_FAILURE == retVal) {
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            else {
                OAM_LOG(OAM, OAM_DETAILED, "Parameter updation succeeded");
            }
            /*Moving pointer buffer to point to next parameter */  
        }

        p_api_buf_temp += parameter_length;

        /* If Management Server URL changes, FAP is now connected to sHeMS */
        if (oam_strncasecmp((char *)parent_parameter_name, "InternetGatewayDevice.ManagementServer.URL", 
                    oam_strlen("InternetGatewayDevice.ManagementServer.URL")) == OAM_ZERO)
        {
            oam_prov_req.oam_tr069_req.connect_to_iHeMS = OAM_FALSE;
            OAM_LOG(OAM,OAM_INFO,"Value of connect_to_iHeMS reset to False");
            /* Persist the value */
            oam_persist_one_parameter(xml_struct_tr196_g.ManagementServer,
                    "X_VENDOR_CONNECT_TO_IHEMS",(UInt8*)"0");
        }

        /*SPR 11090 FIX START*/
        /* spr_21013_fix_start */
        if(oam_strncasecmp((char *)parent_parameter_name, "InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.S1ConnectionMode",
                    oam_strlen("InternetGatewayDevice.Services.FAPService.FAPControl.LTE.Gateway.S1ConnectionMode")) == OAM_ZERO)
            /* spr_21013_fix_end */
        {
            g_S1ConnectionMode_flag = OAM_TRUE;
        }
        /*SPR 11090 FIX END*/

        /* SPR 12274 FIX END */
        /* Redundant check removed */
        /* SPR 12274 FIX END */


    }
    /* SPR 9986 FIX START */
    /*SPR 14966 start*/
    if ( (OAM_TRUE == spv_for_pm_xml_params || OAM_TRUE == spv_persist_for_pm_xml_params) && (OAM_ZERO == Modify_MacQos_flag)
            && (g_pm_xml_params.spv_bitmask & PM_XML_SPV_PM_REPORT_EN_DISABLE)) //flag check for sending config request
        /*SPR 14966 end*/
    {

        /*SPR 15491 START */
        if (spv_persist_for_pm_xml_params == OAM_TRUE)
        {

            oam_sprintf(num_buffer,"%d",g_pm_xml_params.pm_xml_file_reporting);
            oam_persist_one_parameter(xml_struct_tr196_g.Config,
                    "Enable", (UInt8*)num_buffer);

            oam_sprintf(num_buffer,"%d",g_pm_xml_params.pm_xml_upload_interval_timer);
            oam_persist_one_parameter(xml_struct_tr196_g.Config,
                    "PeriodicUploadInterval",(UInt8*)num_buffer);

            oam_persist_one_parameter(xml_struct_tr196_g.Config,
                    "PeriodicUploadTime",(UInt8*)g_pm_xml_params.periodic_upload_timer_str);

            oam_sprintf(num_buffer,"%d",(g_pm_xml_params.pm_xml_sampling_interval_timer/OAM_SIXTY));
            oam_persist_one_parameter(xml_struct_tr196_g.Config,
                    "X_VENDOR_SamplingInterval",(UInt8*)num_buffer);

            oam_sprintf(num_buffer,"%d",(g_pm_xml_params.pm_xml_file_write_timer/OAM_SIXTY));
            oam_persist_one_parameter(xml_struct_tr196_g.Config,
                    "X_VENDOR_FileWriteTimer",(UInt8*)num_buffer);
            /* SPR 23283 Fix Start */
        }
        if (g_config_lower_layer_resp == OAM_TWO)
        {
            /* SPR 22296 Fix Start */
            OAM_LOG(OAM, OAM_DETAILED, "Trans_id : oam_pm_xml_handle_spv_for_pm_params: %d", trans_id);	
            oam_pm_xml_handle_spv_for_pm_params(trans_id);
#ifndef OAM_UT_FRAMEWORK

            /* CSR No 00055803 Start */
            /*SPR_10579 Start*/ 
            /* SPR_12955_FIXES */
            oam_maintain_tcb(trans_id,OAM_TRANS_RRC_MAC_PDCP_RRM,msg_len,p_api_buf);
            /* SPR_12955_FIXES */
            /*SPR_10579 End*/ 
            /* CSR No 00055803 End */
#endif
            return OAM_SUCCESS;
            /* SPR 23283 Fix End */
            /* SPR 22296 Fix End */
        }
        /* SPR 15491 END */

	/* SPR 9986 FIX END */
	/*Send to lower layer only when Enable field has been received or there has been trigger from CLI*/
	/*SPR 14966 start*/
	/* SPR 22296 Fix Start */
	/* Code Removed */
	/* SPR 22296 Fix End */
        if(g_config_lower_layer_resp != OAM_RESULT_FAILURE)
        { 
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                    OAM_ZERO,OAM_NULL,OAM_ZERO,
                    OAM_VERSION_ID, OAM_MODULE_ID,
                    dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                    p_error_code);
            return OAM_SUCCESS;
        }
        else
        {
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                    OAM_ZERO,(UInt8 *)"CONFIGURATION KPI FAILED", oam_strlen("CONFIGURATION KPI FAILED") + OAM_ONE,
                    OAM_VERSION_ID, OAM_MODULE_ID,
                    dest_id,trans_id,OAM_ZERO, OAM_ZERO,
                    p_error_code);
            return OAM_SUCCESS;

        }
    }

    if(OAM_TRUE == Config_CapacityEnc_flag)
    {

        oam_memset((void *)&p_oam_rrm_cell_ecn_capacity_enhance_req,OAM_ZERO,sizeof(p_oam_rrm_cell_ecn_capacity_enhance_req));

        oam_fill_ecn_cells (&p_oam_rrm_cell_ecn_capacity_enhance_req,
                oam_ul_dl_qci_cli_input,
                oam_ul_dl_qci_cli_input.num_of_ue);

        oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
        oam_rrm_send_rrm_oam_cell_ecn_capacity_enhance_req(
                &p_oam_rrm_cell_ecn_capacity_enhance_req,
                OAM_MODULE_ID,
                RRM_MODULE_ID,
                trans_id,
                cid);
        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
        if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRM,
                    OAM_TRANS_RRM,msg_len,p_api_buf))
        {
            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
            /* spr 21390 fix start */
            *p_error_code = OAM_INTERNAL_ERROR;
            return OAM_FAILURE; 
            /* spr 21390 fix end */
        }
#endif
        /* SPR 9620 CHANGE END */ 
        Config_CapacityEnc_flag = OAM_FALSE;
        /* CSR 59167 START */
        Config_CapacityEnc_dis_flag = OAM_TRUE;
        oam_ul_dl_qci_cli_flag.flag = OAM_ONE;
        /* Coverity ID : 85867  Fix Start*/
        if(p_local_req_memfree_flag){
            oam_mem_free(p_local_req, p_error_code);
            /*  coverity 85867 fix start */
            /*SPR 18504 FIX START*/
            p_local_req_memfree_flag=OAM_FALSE; 
            /*SPR 18504 FIX END*/

            p_local_req = OAM_NULL;
            /*  coverity 85867 fix end */
        }
        /* Coverity ID : 85867 Fix End*/ 
        return OAM_SUCCESS;

    }


    else if(OAM_TRUE == Config_CapacityEnc_dis_flag)
    {
        /* CSR 59167 END */
        oam_memset((void *)&p_oam_rrm_cell_ecn_capacity_enhance_req,OAM_ZERO,sizeof(p_oam_rrm_cell_ecn_capacity_enhance_req));

        oam_fill_ecn_cells (&p_oam_rrm_cell_ecn_capacity_enhance_req,
                oam_ul_dl_qci_cli_input, temp_ue_var);
        oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
        oam_rrm_send_rrm_oam_cell_ecn_capacity_enhance_req(
                &p_oam_rrm_cell_ecn_capacity_enhance_req,
                OAM_MODULE_ID,
                RRM_MODULE_ID,
                trans_id,
                cid);

        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
        if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRM,
                    OAM_TRANS_RRM,msg_len,p_api_buf))
        {
            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
            /* spr 21390 fix start */
            *p_error_code = OAM_INTERNAL_ERROR;
            return OAM_FAILURE;
            /* spr 21390 fix end */
        }
#endif
        /* SPR 9620 CHANGE END */ 

        Config_CapacityEnc_dis_flag = OAM_FALSE;
        oam_ul_dl_qci_cli_flag.flag = OAM_ONE; 
        /* Coverity ID : 85867  Fix Start*/
        if(p_local_req_memfree_flag){
            oam_mem_free(p_local_req, p_error_code);
            /*  coverity 85867 fix start */
            p_local_req = OAM_NULL;
            /*SPR 18504 FIX START*/
            p_local_req_memfree_flag=OAM_FALSE; 
            /*SPR 18504 FIX END*/
            /*  coverity 85867 fix end */
        }
        /* Coverity ID : 85867 Fix End*/ 
        return OAM_SUCCESS;

    }
    if(OAM_TRUE == ue_Release_flag)
    {
        oam_rrm_send_rrm_oam_ue_release_req(&p_rrm_oam_ue_release_req,
                OAM_MODULE_ID, RRM_MODULE_ID,
                trans_id,
                cid);
        /* SPR 9709 FIX START */
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                OAM_ZERO,OAM_NULL,OAM_ZERO,
                OAM_VERSION_ID, OAM_MODULE_ID,
                dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                p_error_code);
        /* SPR 9709 FIX END */
        return OAM_SUCCESS;

    }


    /* SPR 12448 FIX START */
    if(OAM_TRUE == oam_set_config_req.flag)     
    {  
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                OAM_ZERO,OAM_NULL,OAM_ZERO,
                OAM_VERSION_ID, OAM_MODULE_ID,
                oam_set_config_req.src_id, trans_id, OAM_ZERO, OAM_ZERO,
                p_error_code);
        return OAM_SUCCESS;
    }
    /* SPR 12448 FIX END */

    /*CID:54869 end*/
    if(OAM_TRUE == config_number_of_entries_flag)     
    {
        if(OAM_ONE  == value_flag)
        {
            /* SPR 9709 FIX START */
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                    OAM_ZERO,OAM_NULL,OAM_ZERO,
                    OAM_VERSION_ID, OAM_MODULE_ID,
                    dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                    p_error_code);
            return OAM_SUCCESS;
            /* SPR 9709 FIX END */

        }    
        else if(OAM_TWO  == value_flag )
        {

            /* SPR 9709 FIX START */
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                    OAM_ZERO,OAM_NULL,OAM_ZERO,
                    OAM_VERSION_ID, OAM_MODULE_ID,
                    dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                    p_error_code);
            return OAM_SUCCESS;
            /* SPR 9709 FIX END */


        } 
    }

    if(OAM_ONE == Modify_MacQos_flag) 
    {

		local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req.modBitMap = Modify_MacQos_flag_bitmask;
        oam_maintain_tcb(trans_id,OAM_TRANS_MAC,msg_len,p_api_buf);
        retVal  =  oam_send_mac_modify_layer_req(
                ((oam_mac_modify_req_params_t *)
				 &(local_prov_req.l2_setup_info.instance_info[OAM_ZERO].oam_l2_req.oam_mac_req.mac_modify_req)),
                src_module_id,
                trans_id,p_error_code);

        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR,
                    "Error in function oam_send_mac_modify_layer_req:"
                    "error code :%d",
                    *p_error_code);

        }
        else{
            /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_MAC,
                        OAM_TRANS_MAC,msg_len,p_api_buf))
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                /* spr 21390 fix start */
                *p_error_code = OAM_INTERNAL_ERROR;
                retVal = OAM_FAILURE;
                /* spr 21390 fix end */
            }
#endif
            /* SPR 9620 CHANGE END */
        }    

        return retVal;
    }

    /*SPR 14451 START*/ 
    if(cell_block_flag == OAM_TRUE){
        retVal = oam_send_message_to_lower_layers(OAM_MODULE_ID,
                msg_len, p_api_buf,
                OAM_NULL,
                OAM_NULL,
                OAM_NULL,
                OAM_NULL,
                p_error_code);
        if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING, "Failed to process request.");
        }
        return retVal;
    }
    /*SPR 14451 END*/
    /*Send message to lower layer new value set*/
    retVal = oam_send_message_to_lower_layers(src_module_id,
            msg_len,
            p_api_buf,
            p_local_req,
            p_orig_parent,
            p_req_parent,
            p_p_xml_struct_addr,
            p_error_code);
    if (OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR, "Message sending to lower failed");
        /* SPR 21370 changes start */
        /* spr 21390 fix start */
        *p_error_code = OAM_ERR_DATA_EXISTS;
        /* spr 21390 fix end */
        /* SPR 21370 changes end */
        /* Start bug 16589 fix */
        /*SPR 18504 FIX START*/
    }    
    /* Coverity ID : 85867  Fix Start*/
    if(p_local_req_memfree_flag)
    {
        oam_mem_free(p_local_req, p_error_code);
        /*  coverity 85867 fix start */
        p_local_req = OAM_NULL;
        p_local_req_memfree_flag=OAM_FALSE; 
        /*  coverity 85867 fix end */
    }
    /*SPR 18504 FIX END*/
    /* Coverity ID : 85867 Fix End*/
    /* End bug 16589 fix */
    /* Start bug 16589 fix */
    //code moved
    /* End bug 16589 fix */

    OAM_FUN_EXIT_TRACE();
    return retVal;
}


/******************************************************************************
 * Function Name  : oam_qcli_intf_msg_handler
 * Inputs         : p_api_buf : input buffer sent from upper layer.
 *                  api_id 
 *                  src_module_id : source module id from which it is called
 *                  msg_len : length of message sent to function 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : This is the message handling function of OAM.
 *******************************************************************************/
oam_return_et
oam_qcli_intf_msg_handler
(
 void *p_api_buf, 
 UInt16 api_id, 
 UInt16 src_module_id, 
 UInt16 msg_len
 )
{
	AdvL_LogLevel adv_log_level;
	AdvL_ContextIndex log_index = OAM_ZERO;               /* typedef unsigned short AdvL_ContextIndex */
	Char8 *str_err = OAM_NULL;
	UInt8 str_err_len = OAM_ZERO;
	UInt16 usr_err_code = OAM_ZERO;
	UInt16 usr_resp = OAM_RESULT_SUCCESS;
	UInt16 transaction_id = OAM_ZERO;
	UInt32 loglevel = OAM_ZERO;
	UInt8 log_level_rrc = OAM_ZERO;
    /* SPR 19703 changes start */
	/*SPR_20065: coverity 110690 Fix Start*/
	UInt32 log_level_rrm = RRM_OAM_INFO;
	/*SPR_20065: coverity 110690 Fix End*/
    /* SPR 19703 changes end */
	UInt8 log_level_oam = OAM_ZERO;
	SInt32 module_id = OAM_ZERO;
	SInt32 modid = OAM_ZERO;
	SInt32 enable = OAM_ZERO;
	SInt32 level = OAM_ZERO;

	UInt8 add_spec_emi = OAM_ZERO;
	UInt32 dflt_pag_cyl = OAM_ZERO;
	UInt32 mod_per_coeff=OAM_ZERO;
	UInt32 nb = OAM_ZERO;
	UInt8 time_align_timer = OAM_ZERO;
	UInt32 cell_barr = OAM_ZERO;
	UInt8 max_harq = OAM_ZERO;
	UInt32 pwr_offset = OAM_ZERO;
	UInt32 t311_timer = OAM_ZERO;
	UInt32 t310_timer = OAM_ZERO;
	UInt32 t301_timer = OAM_ZERO;
	UInt32 t300_timer = OAM_ZERO;
	UInt32 n311_timer = OAM_ZERO;
	UInt32 n310_timer = OAM_ZERO;
	UInt32 pwr_ramp =  OAM_ZERO;
	UInt32 init_tgt_pwr = OAM_ZERO;
	UInt32 pre_tx_max = OAM_ZERO;
	UInt16 Intra_freq = OAM_ZERO;
	UInt16 mnc_val = OAM_ZERO;
	UInt16 mcc_val = OAM_ZERO;
    /* SPR 15499 Fix : code removed */
	UInt32 offset = OAM_ZERO;
	UInt32 log_level;
    /* SPR 15499 Fix : code removed */
	/* coverity 35900 */
	oam_return_et ret_val = OAM_SUCCESS;
	destination_id=src_module_id;
	oam_error_code_et error_code = NO_ERROR;    
    /* SPR 15499 Fix : code removed */
	oam_mac_log_level_req_t  mac_set_log_level_req;
    oam_relay_Gtpu_Set_Log_Lvl_Req_t log_level_gtpu;

	UInt16  msg_api_length;
	UInt8 *p_msg, *p_oam_msg;
#ifdef OAM_SON_ENABLE
	/* SPR_13116_CHANGE_START */
	oam_son_get_log_level_req_t son_get_log_level_req;
	/* SPR_13116_CHANGE_END */
	oam_son_log_enable_disable_req_t son_log_enable_disable_req;
	UInt32 enable_son;
	UInt32 level_son;
	son_oam_set_log_level_req_t son_log_level_req;
    /* SPR 19703 changes start */
	UInt32 log_level_son = OAM_ZERO;
    /* SPR 19703 changes end */
	UInt32 mod_id_son;
	SInt32 module_id_son = OAM_ZERO;
#endif
	/* SPR_13116_CHANGE_START */
	oam_rrm_get_log_level_req_t rrm_get_log_level_req;
	/* SPR_13116_CHANGE_END */

	UInt32 bitmask;
	oam_rrc_log_enable_req_t rrc_enable_req;
	oam_pdcp_disable_log_category_req_t pdcp_disable_log_category_req;
	Oam_LogCategory_Req_t rlc_disable_log_category_req;
	oam_mac_disable_log_category_req_t mac_disable_log_category_req;
	oam_mac_enable_log_category_req_t mac_set_log_category_req;
	Oam_LogCategory_Req_t rlc_set_log_category_req;
	oam_pdcp_enable_log_category_req_t pdcp_set_log_category_req;
	rrc_oam_set_log_level_req_t rrc_log_level_req;
	x2ap_oam_set_log_level_req_t x2ap_log_level_req;
    s1ap_oam_set_log_level_req_t s1ap_log_level_req;
    x2ap_oam_log_enable_req_t x2ap_log_enable_req;
    s1ap_oam_log_enable_req_t s1ap_log_enable_req;
	rrm_oam_set_log_level_req_t rrm_log_level_req;
	oam_rrc_cell_traffic_trace_start_t oam_rrc_cell_traffic_trace_start;
	oam_rrc_cell_traffic_trace_start_t *p_oam_rrc_cell_traffic_trace_start = OAM_NULL;
	oam_rrc_cell_traffic_trace_stop_t oam_rrc_cell_traffic_trace_stop;
	oam_rrm_log_enable_disable_req_t log_enable_disable_req;
	oam_rrm_cell_reconfig_req_t *p_rrm_sib1_req = OAM_NULL;


	oam_rrm_cell_reconfig_req_t *p_rrm_sib1_mnc_req = OAM_NULL;

	oam_rrm_cell_reconfig_req_t *p_rrm_sib1_mcc_req = OAM_NULL;

	oam_rrm_cell_reconfig_req_t *p_rrm_sib2_spec_req = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_rrm_sib2_dflt_pag_cyl = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_rrm_sib2_mod_per_coeff = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_rrm_sib2_nb = OAM_NULL;

	oam_rrm_cell_reconfig_req_t *p_rrm_sib2_time_align_timer = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_barr_for_emergency = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_mac_rach_maxharq = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_mac_rach_msg_pwr_offset = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_mac_rach_pwr_ramp = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_mac_rach_preamble_init_rx = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_mac_rach_preable_trans_max = OAM_NULL;


	oam_rrm_cell_reconfig_req_t *p_fap_ran_rrctimer_n310 = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_rrctimer_n311 = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_rrctimer_t300 = OAM_NULL;

	oam_rrm_cell_reconfig_req_t *p_fap_ran_rrctimer_t301 = OAM_NULL;

	oam_rrm_cell_reconfig_req_t *p_fap_ran_rrctimer_t310 = OAM_NULL;
	oam_rrm_cell_reconfig_req_t *p_fap_ran_rrctimer_t311 = OAM_NULL;

    oam_mac_log_level_req_t  log_level_mac  = {OAM_ZERO};
    Oam_LogLevel_Req_t       log_level_rlc  = {OAM_ZERO};
    oam_pdcp_log_level_req_t log_level_pdcp = {OAM_ZERO};

	UInt16 inst_num = OAM_ZERO;
    /* SPR 15499 Fix : code removed */
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	/* coverity 35898 */
    /* SPR 15499 Fix : code removed */
	UInt16 trans_id = get_word_from_header((UInt8*)(p_api_buf) + 0); 
	UInt16 dest_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_TWO);

	/*SPR 21478 Start*/
        oam_cell_status_t *p_cell_status = OAM_NULL;

 p_cell_status = oam_get_cell_cntxt_status(cell_config_idx);
        if(p_cell_status)
        {
	if((p_cell_status->cell_state & OAM_CELL_DELETE)&&(!check_if_set_cell_context_cli(p_api_buf)))
	{
		error_code = OAM_CELL_DELETE_IN_PROGRESS;
		oam_get_err_string_n_err_code(error_code, &usr_err_code,
				&str_err);

		OAM_LOG(OAM, OAM_WARNING,
				"oam_set_parameter_values_api_handler failed. "
		        "Error: %s", str_err);
		str_err_len = oam_strlen(str_err) + OAM_ONE;

		oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
				usr_err_code,
				(UInt8*)str_err,
				str_err_len,
				OAM_VERSION_ID,
				OAM_MODULE_ID,
				dest_id, trans_id,
				OAM_ZERO, OAM_ZERO,
				&error_code);


		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;

	}
        }
	/*SPR 21478 End*/
	switch (api_id)
	{
		case OAM_CONTROL_COMMAND_REQ:
			if(OAM_SUCCESS == oam_handle_control_command_req(p_api_buf))
			{
				OAM_LOG(OAM,OAM_DETAILED,"OAM_CONTROL_COMMAND_REQ PROCESSED SUCCESSFULLY");
			} 
			break;

			/*Code added for Rel 1.0*/
        case OAM_SET_PARAMETER_VALUES :
            if(OAM_FAILURE == oam_set_parameter_values_api_handler(
                        p_api_buf, msg_len, src_module_id, &error_code)) {
                /* SPR 21390 fix start */

                oam_get_err_string_n_err_code(error_code, &usr_err_code,
                        &str_err);

				OAM_LOG(OAM, OAM_WARNING,
						"oam_set_parameter_values_api_handler failed. "
				        "Error: %s", str_err);
                str_err_len = oam_strlen(str_err) + OAM_ONE;
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        usr_err_code,
                        (UInt8*)str_err,
                        str_err_len,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id, trans_id,
                        OAM_ZERO, OAM_ZERO,
                        &error_code);

                
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            break;

        case OAM_GET_PARAMETER_VALUES:
            ret_val = oam_get_parameter_api_handler(p_api_buf, msg_len,
                    src_module_id, &error_code);
            if (OAM_FAILURE == ret_val) {
                /*SPR 20971 Fix Start*/
                oam_get_err_string_n_err_code(error_code, &usr_err_code,
                        &str_err);

                OAM_LOG(OAM, OAM_WARNING,
                        "oam_get_parameter_values_api_handler failed. "
				        "%s", str_err);

                usr_resp = OAM_RESULT_FAILURE;


                oam_construct_n_send_get_resp_to_usr(usr_resp,
                        usr_err_code,
                        OAM_VERSION,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id,
                        OAM_ZERO,
                        OAM_ZERO,
                        str_err,
                        &error_code);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            /*SPR 20971 Fix End*/
            break;

        case OAM_GET_LOG_CAT_L2_REQ:   /*MAC_GET_LOG_CATEGORY_RESP, RLC_GET_LOG_CATEGORY_RESP, PDCP_GET_LOG_CATEGORY_RESP, PR_GTPU_GET_LOG_CATEGORY_RESP*/
            oam_maintain_tcb(trans_id,OAM_TRANS_L2ALL,msg_len,p_api_buf);

			oam_mac_send_get_log_category_req(src_module_id,OAM_ONE,&error_code);
			oam_rlc_send_get_log_category_req(src_module_id,OAM_ONE,&error_code);
			oam_pdcp_send_get_log_category_req(src_module_id,OAM_ONE,&error_code);
			oam_pr_egtpu_send_get_log_category_req(src_module_id,OAM_ONE,&error_code);
			break;
		case OAM_CONFIG_KPI_MAC_REQ:  
		case OAM_GET_KPI_MAC_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_MAC,msg_len,p_api_buf);
			oam_layer_send_req(p_api_buf);
			break;
		case OAM_CONFIG_KPI_PDCP_REQ: 
		case OAM_GET_KPI_PDCP_REQ: 
			oam_maintain_tcb(trans_id,OAM_TRANS_PDCP,msg_len,p_api_buf);
			oam_layer_send_req(p_api_buf);
			break;
		case OAM_RRC_GET_CELL_STATS_REQ:
		case CONFIG_RRC_STATS_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_RRC,msg_len,p_api_buf);
			oam_layer_send_req(p_api_buf);
			break;

		case OAM_GET_LOG_LEVEL_MAC_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_MAC,msg_len,p_api_buf);
			oam_mac_send_get_log_level_req(src_module_id,trans_id,&error_code);
			break;
		case OAM_GET_LOG_LEVEL_RLC_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_RLC,msg_len,p_api_buf);
			oam_rlc_send_get_log_level_req(src_module_id,trans_id,&error_code);
			break;
		case OAM_GET_LOG_LEVEL_PDCP_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_PDCP,msg_len,p_api_buf);
			oam_pdcp_send_get_log_level_req(src_module_id,trans_id,&error_code);
			break;
			/*SPR 13617 START*/
		case OAM_GET_LOG_LEVEL_L3_REQ:
			OAM_LOG(OAM, OAM_INFO,
					"RRC_OAM_LOG_ENABLE_REQ: length %u", msg_len);

			msg_api_length = msg_len + OAM_CSPL_HDR_SIZE + LOWER_LAYER_INTERFACE_HEADER_SIZE;
			p_msg = oam_msg_mem_get(msg_api_length);

			if (p_msg == PNULL)
			{
                OAM_LOG(OAM,OAM_ERROR, "Memory allocation to p_msg failed");
				/* Not enough memory */
				return OAM_FAILURE;
			}

			oam_memset(p_msg, 0, msg_api_length);
			p_oam_msg = p_msg;

			/* Fill CSPL header */
			oam_construct_api_header(p_oam_msg, RRC_VERSION_ID, src_module_id,
					dest_id, RRC_OAM_GET_LOG_LEVEL_REQ, msg_api_length);

			/* Fill interface header */
			p_oam_msg += OAM_CSPL_HDR_SIZE;
			oam_construct_interface_api_header(p_oam_msg, trans_id, src_module_id,
					RRC_MODULE_ID, RRC_OAM_GET_LOG_LEVEL_REQ, msg_len,1);

			/* Fill RRC_OAM_GET_LOG_LEVEL_REQ message */
			p_oam_msg += LOWER_LAYER_INTERFACE_HEADER_SIZE;
			/* Send message to */
			/* SPR 13116 REVIEW COMMENTS FIX START */
			ret_val = oam_send_message(p_msg, dest_id, &error_code);

			if (OAM_SUCCESS == ret_val) {
				OAM_LOG(OAM, OAM_DETAILED,
						"RRC_OAM_GET_LOG_LEVEL_REQ Message sent successfully to RRC");
				oam_maintain_tcb(trans_id, OAM_TRANS_RRC, msg_len, p_api_buf);
			}
			else {
				OAM_LOG(OAM, OAM_ERROR, "Failed to RRC_OAM_GET_LOG_LEVEL_REQ message sent to RRC");
			}
			/* SPR 13116 REVIEW COMMENTS FIX END */

			break;

		case OAM_GET_LOG_LEVEL_L3_S1AP_REQ:
			OAM_LOG(OAM, OAM_INFO,
					"S1AP_OAM_LOG_ENABLE_REQ: length %u", msg_len);

			msg_api_length = msg_len + OAM_CSPL_HDR_SIZE + LOWER_LAYER_INTERFACE_HEADER_SIZE;
			p_msg = oam_msg_mem_get(msg_api_length);

			if (p_msg == PNULL)
			{
                OAM_LOG(OAM,OAM_ERROR, "Memory allocation to p_msg failed");
				/* Not enough memory */
				return OAM_FAILURE;
			}

			oam_memset(p_msg, 0, msg_api_length);
			p_oam_msg = p_msg;

			/* Fill CSPL header */
			oam_construct_api_header(p_oam_msg, RRC_VERSION_ID, src_module_id,
					dest_id, S1AP_OAM_GET_LOG_LEVEL_REQ, msg_api_length);

			/* Fill interface header */
			p_oam_msg += OAM_CSPL_HDR_SIZE;
			oam_construct_interface_api_header(p_oam_msg, trans_id, src_module_id,
					RRC_MODULE_ID, S1AP_OAM_GET_LOG_LEVEL_REQ, msg_len,1);

			/* Fill RRC_OAM_GET_LOG_LEVEL_REQ message */
			p_oam_msg += LOWER_LAYER_INTERFACE_HEADER_SIZE;
			/* Send message to */
			ret_val = oam_send_message(p_msg, dest_id, &error_code);

			if (OAM_SUCCESS == ret_val) {
				OAM_LOG(OAM, OAM_DETAILED,
						"Message sent successfully to S1AP");
				oam_maintain_tcb(trans_id, OAM_TRANS_S1AP, msg_len, p_api_buf);
			}
			else {
				OAM_LOG(OAM, OAM_ERROR, "Failed to message sent to S1AP");
			}

			break;

		case OAM_GET_LOG_LEVEL_L3_X2AP_REQ:
			OAM_LOG(OAM, OAM_INFO,
					"X2AP_OAM_LOG_ENABLE_REQ: length %u", msg_len);

			msg_api_length = msg_len + OAM_CSPL_HDR_SIZE + LOWER_LAYER_INTERFACE_HEADER_SIZE;
			p_msg = oam_msg_mem_get(msg_api_length);

			if (p_msg == PNULL)
			{
                OAM_LOG(OAM,OAM_ERROR, "Memory allocation to p_msg failed");
				/* Not enough memory */
				return OAM_FAILURE;
			}

			oam_memset(p_msg, 0, msg_api_length);
			p_oam_msg = p_msg;

			/* Fill CSPL header */
			oam_construct_api_header(p_oam_msg, RRC_VERSION_ID, src_module_id,
					dest_id, X2AP_OAM_GET_LOG_LEVEL_REQ, msg_api_length);

			/* Fill interface header */
			p_oam_msg += OAM_CSPL_HDR_SIZE;
			oam_construct_interface_api_header(p_oam_msg, trans_id, src_module_id,
					RRC_MODULE_ID, X2AP_OAM_GET_LOG_LEVEL_REQ, msg_len,1);

			/* Fill RRC_OAM_GET_LOG_LEVEL_REQ message */
			p_oam_msg += LOWER_LAYER_INTERFACE_HEADER_SIZE;

            /* Send message to */
			ret_val = oam_send_message(p_msg, dest_id, &error_code);

			OAM_LOG(OAM, OAM_INFO,"X2AP_OAM_LOG_ENABLE_REQ: length %u", ret_val);
			if (OAM_SUCCESS == ret_val) {
				OAM_LOG(OAM, OAM_DETAILED,
						"Message sent successfully to X2AP");
				oam_maintain_tcb(trans_id, OAM_TRANS_X2AP, msg_len, p_api_buf);
			    OAM_LOG(OAM, OAM_INFO,"X2AP_OAM_LOG_ENABLE_REQ: length %u", ret_val);
			}
			else {
				OAM_LOG(OAM, OAM_ERROR, "Failed to message sent to X2AP");
			}

			break;
			/*SPR 13617 END*/
		case OAM_GET_LOG_LEVEL_OAM_REQ:
			ret_val = oam_send_get_log_level_resp(trans_id,dest_id,&error_code);
			if( OAM_SUCCESS == ret_val)
			{
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully Send Response of OAM Log Level Request");
			}
			else
			{
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to Send Response of OAM Log Level Request");
			}
			break;
		case OAM_GET_LOG_LEVEL_RRM_REQ:
			OAM_LOG(OAM, OAM_INFO,
					"User request to set log level for RRM received");

			/*  Coverity ID : 79060 Fix Start */ 
			/*  offset = QCLI_HEADER_SIZE;  */
			/*  Coverity ID : 79060 Fix End */ 
			rrm_get_log_level_req.module_id =
				(rrm_internal_module_id_et)OAM_ZERO;
			ret_val =
				oam_rrm_send_rrm_oam_get_log_level_req(&rrm_get_log_level_req,
						src_module_id,
						RRM_MODULE_ID,
						trans_id,
						oam_prov_req.cell_cntxt.curr_cell_cid);
			if(OAM_FAILURE == ret_val) {
				OAM_LOG(OAM, OAM_ERROR,
						"Failed to send request to lower layer");
			}
			else {
				OAM_LOG(OAM, OAM_INFO, "Request sent to lower layer");

				/* SPR 13116 REVIEW COMMENTS FIX START */
				oam_maintain_tcb(trans_id, OAM_TRANS_RRM,
						msg_len, p_api_buf);
				/* SPR 13116 REVIEW COMMENTS FIX END */
			}
			break;


#ifdef OAM_SON_ENABLE
		case OAM_GET_LOG_LEVEL_SON_REQ:
			son_get_log_level_req.module_id = (son_module_id_et)OAM_ZERO;
			OAM_LOG(OAM, OAM_DETAILED, " Module_ID %d",son_get_log_level_req.module_id);
			ret_val=oam_son_send_son_oam_get_log_level_req(&son_get_log_level_req,
					src_module_id,
					SON_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			if(OAM_FAILURE == ret_val) {
				OAM_LOG(OAM, OAM_ERROR,
						"Failed to send SON_OAM_GET_LOG_LEVEL_REQ to lower layer");
			}
			else {
				OAM_LOG(OAM, OAM_INFO, "sent SON_OAM_GET_LOG_LEVEL_REQ to lower layer");

				/* SPR 13116 REVIEW COMMENTS FIX START */
				oam_maintain_tcb(trans_id, OAM_TRANS_SON,
						msg_len, p_api_buf);
				/* SPR 13116 REVIEW COMMENTS FIX END */
			}

			break;
#endif
			/* SPR_13116_CHANGE_END */

		case OAM_SET_LOG_LEVEL_MAC_REQ: 
			loglevel =  ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			mac_set_log_level_req.logLevel =  loglevel;
			if(OAM_SUCCESS == oam_mac_send_set_log_level_req(&mac_set_log_level_req,src_module_id,trans_id,&error_code))
				oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			else
				oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
			break;
        case OAM_SET_LOG_LEVEL_RLC_REQ:
            loglevel =  ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
            log_level_rlc.logLevel =  loglevel;
            if(OAM_SUCCESS == oam_rlc_send_set_log_level_req(&log_level_rlc,src_module_id,trans_id,&error_code))
                oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
            else
                oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
            break;
        case OAM_SET_LOG_LEVEL_PDCP_REQ:
            loglevel =  ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
            log_level_pdcp.logLevel =  loglevel;
            if(OAM_SUCCESS == oam_pdcp_send_set_log_level_req(&log_level_pdcp,src_module_id,trans_id,&error_code))
                oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
            else
                oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
            break;
		case OAM_SET_ENABLE_DISABLE_RRM_LOG_REQ: 
			modid =  (*(SInt32 *)((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			bitmask = (*(SInt32 *) ((UInt8*)p_api_buf + OAM_SIXTEEN));
			enable =  (*(SInt32 *) ((UInt8*)p_api_buf + OAM_TWENTY));
			level =  (*(SInt32 *)  ((UInt8*)p_api_buf + OAM_TWENTY_FOUR));
			/* coverity 41302 41301 41300 */
			log_enable_disable_req.module_id =  (rrm_internal_module_id_et)modid;
			log_enable_disable_req.log_config.bitmask = (rrm_bitmask_t)bitmask;
			log_enable_disable_req.log_config.log_level = (rrm_oam_log_level_et)level;
			log_enable_disable_req.log_config.log_on_off = (rrm_oam_log_on_off_et)enable;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			/* CSR 57877 Fix START*/
			oam_rrm_send_rrm_oam_log_enable_disable_req(
					(rrm_oam_log_enable_disable_req_t *)&log_enable_disable_req,
					src_module_id, RRM_MODULE_ID, trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRM,
						OAM_TRANS_RRM,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
			}
#endif
			/* SPR 9620 CHANGE END */
			/* CSR 57877 Fix End*/

			break;

#ifdef OAM_SON_ENABLE 
		case OAM_SET_ENABLE_DISABLE_SON_REQ: 
			mod_id_son =  (*(UInt32*)((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			bitmask = (*(UInt32 *)  ((UInt8*)p_api_buf + OAM_SIXTEEN));
			enable_son =  (*(UInt32 *)  ((UInt8*)p_api_buf + OAM_TWENTY));
			level_son =  (*(UInt32 *)  ((UInt8*)p_api_buf + OAM_TWENTY_FOUR));
			son_log_enable_disable_req.log_configuration.bitmask = bitmask;
			/* coverity 41324 41325 41326 41323*/
			son_log_enable_disable_req.log_configuration.log_level = (son_oam_log_level_et)level_son;
			son_log_enable_disable_req.log_configuration.log_on_off = (son_oam_log_on_off_et)enable_son;
			son_log_enable_disable_req.module_id = (son_module_id_et)mod_id_son;
			son_log_enable_disable_req.feature_id = (son_feature_id_et)OAM_ZERO;
			oam_maintain_tcb(trans_id,OAM_TRANS_SON,msg_len,p_api_buf);
			/* CSR 57877 Fix START*/
			oam_son_send_son_oam_log_enable_disable_req(
					(son_oam_log_enable_disable_req_t *)&son_log_enable_disable_req,
					src_module_id, SON_MODULE_ID, trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* CSR 57877 Fix End*/
			/* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
						OAM_TRANS_SON,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
			}
#endif
			/* SPR 9620 CHANGE END */
			break;
#endif
		case OAM_GET_LOG_CAT_MAC_REQ:

			oam_maintain_tcb(trans_id,OAM_TRANS_MAC,msg_len,p_api_buf);
			oam_mac_send_get_log_category_req(src_module_id,trans_id,&error_code);
			break;
		case OAM_GET_LOG_CAT_RLC_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_RLC,msg_len,p_api_buf);
			oam_rlc_send_get_log_category_req(src_module_id,trans_id,&error_code);
			break;
		case OAM_GET_LOG_CAT_PDCP_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_PDCP,msg_len,p_api_buf);
			oam_pdcp_send_get_log_category_req(src_module_id,trans_id,&error_code);
			break;
		case OAM_SET_ENABLE_LOG_CAT_MAC_REQ: 
			/* SPR 55317 */ oam_memcpy(&(mac_set_log_category_req.logCategory),
					(p_api_buf + OAM_MGMT_INTF_HEADER_SIZE),
					sizeof(UInt64));		
			if(OAM_SUCCESS == oam_mac_send_set_log_category_req(&mac_set_log_category_req,
						src_module_id,trans_id,&error_code))
			{
				OAM_LOG(OAM, OAM_DETAILED, "OAM_SET_ENABLE_LOG_CAT_MAC_REQ : Sending to MAC");	
				oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else
				oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);

			break;

		case OAM_SET_ENABLE_LOG_CAT_RLC_REQ:
			/* SPR 55317  */oam_memcpy((&rlc_set_log_category_req.logCategory),
					p_api_buf + OAM_MGMT_INTF_HEADER_SIZE,
					sizeof(UInt64));
			/*CSR:0055317_FIX_START*/
			/*Below line is commented to fix the CSR 00055317*/
			/* rlc_set_log_category_req.logCategory =
			   ((UInt64)  *((UInt8*)p_api_buf + OAM_TWELVE)); */
			/*CSR:0055317_FIX_END*/
			if(OAM_SUCCESS == oam_rlc_send_set_log_category_req(&rlc_set_log_category_req,
						src_module_id,trans_id,&error_code))
			{	
				OAM_LOG(OAM, OAM_DETAILED, "OAM_SET_ENABLE_LOG_CAT_RLC_REQ: Sending to RLC");	
				oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			} 
			else
				oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
			break;

		case OAM_SET_ENABLE_LOG_CAT_PDCP_REQ:
			/* SPR 55317  */oam_memcpy((&pdcp_set_log_category_req.logCategory),
					p_api_buf + OAM_MGMT_INTF_HEADER_SIZE,
					sizeof(UInt64));
			if(OAM_SUCCESS == oam_pdcp_send_set_log_category_req(&pdcp_set_log_category_req,
						src_module_id,trans_id,&error_code))
			{    		
				OAM_LOG(OAM, OAM_DETAILED, "OAM_SET_ENABLE_LOG_CAT_PDCP_REQ: Sending to PDCP");	
				oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else
				oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
			break;

		case OAM_SET_DISABLE_LOG_CAT_MAC_REQ: 
			/* SPR 55317 */oam_memcpy((&mac_disable_log_category_req.logCategory),
					p_api_buf + OAM_MGMT_INTF_HEADER_SIZE,
					sizeof(UInt64));
			if(OAM_SUCCESS == oam_mac_send_disable_log_category_req(&mac_disable_log_category_req,
						src_module_id,trans_id,&error_code))
			{
				OAM_LOG(OAM, OAM_DETAILED, "OAM_SET_DISABLE_LOG_CAT_MAC_REQ: Sending to PDCP");
				oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else
				oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
			break;

		case OAM_SET_DISABLE_LOG_CAT_RLC_REQ: 
			/* SPR 55317  */oam_memcpy((&rlc_disable_log_category_req.logCategory),
					p_api_buf + OAM_MGMT_INTF_HEADER_SIZE,
					sizeof(UInt64));
			if(OAM_SUCCESS == oam_rlc_send_disable_log_category_req(&rlc_disable_log_category_req,
						src_module_id,trans_id,&error_code))
			{
				OAM_LOG(OAM, OAM_DETAILED,"OAM_SET_DISABLE_LOG_CAT_RLC_REQ : Sending to RLC");
				oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else
				oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
			break;

		case OAM_SET_DISABLE_LOG_CAT_PDCP_REQ: 
			/* SPR 55317  */oam_memcpy((&pdcp_disable_log_category_req.logCategory),
					p_api_buf + OAM_MGMT_INTF_HEADER_SIZE,
					sizeof(UInt64));
			if(OAM_SUCCESS == oam_pdcp_send_disable_log_category_req(&pdcp_disable_log_category_req,
						src_module_id,trans_id,&error_code))
			{
				OAM_LOG(OAM, OAM_DETAILED,"OAM_SET_DISABLE_LOG_CAT_PDCP_REQ: Sending to PDCP");
				oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else
				oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
			break;

		case OAM_SET_CALL_TRACE_START:
			{
				/* SPR FIX 7851 */
				p_oam_rrc_cell_traffic_trace_start = (oam_rrc_cell_traffic_trace_start_t *)(p_api_buf+ OAM_MGMT_INTF_HEADER_SIZE);
				/* SPR 20804 Fix Start */
				/* Code Deleted */
				/* SPR 20804 Fix End */
				oam_memcpy(&oam_rrc_cell_traffic_trace_start,p_oam_rrc_cell_traffic_trace_start,sizeof(oam_rrc_cell_traffic_trace_start_t));
                /* SPR 15875 Fix Start */            
                oam_memcpy(&oam_rrc_cell_traffic_trace_start.traceRef,
                        &oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                        s1_setup_req_parameters.gb_enb_id.plmn_identity,
                        MAX_PLMN_ID_BYTES);
                /* SPR 15875 Fix Stop */           
				/* SPR FIX 10735 + */
				/* SPR FIX 11324 + */
				if (OAM_ZERO == oam_rrc_cell_traffic_trace_start.trace_collection_entity.length)
				{
					OAM_LOG(OAM, OAM_WARNING, "Invalid IP Address received");
					oam_send_call_trace_start_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
					break;
				}
				/* SPR FIX 11324 - */
				if ((oam_get_rrm_cell_config_idx(oam_rrc_cell_traffic_trace_start.cell_index)
							== OAM_ERROR_RETURN_VAL))
				{

					OAM_LOG(OAM, OAM_WARNING, "Invalid cell_index received");
					oam_send_call_trace_start_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
					break;
				}
				/* SPR 20804 Fix Start */
				/* Code Deleted */
				/* SPR 20804 Fix End */
				oam_maintain_tcb(trans_id,OAM_TRANS_RRC,msg_len,p_api_buf);
				/* CSR_59405_FIX_START */
				if(OAM_SUCCESS == oam_rrc_il_send_rrc_oam_cell_traffic_trace_start
						((rrc_oam_cell_traffic_trace_start_t *)&oam_rrc_cell_traffic_trace_start
						 ,src_module_id, RRC_MODULE_ID, trans_id,oam_rrc_cell_traffic_trace_start.cell_index))
					/* SPR FIX 10735 - */
					/* CSR 57877 Fix START*/
					/* CSR 57877 Fix End*/
				{
					oam_send_call_trace_start_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
				}else{
					oam_send_call_trace_start_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
					/* CSR_59405_FIX_END */
				}
				break;
			}
		case OAM_SET_CALL_TRACE_STOP:
			/* SPR FIX 10735 + */
			oam_rrc_cell_traffic_trace_stop.cell_index =
				((UInt8)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			/* CSR_59405_FIX_START */
			if ((oam_get_rrm_cell_config_idx(oam_rrc_cell_traffic_trace_stop.cell_index))
					== OAM_ERROR_RETURN_VAL)
			{
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell_index received");
				oam_send_call_trace_stop_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
				break;
			}

			ret_val = oam_rrc_il_send_rrc_oam_cell_traffic_trace_stop(
					&oam_rrc_cell_traffic_trace_stop,
					src_module_id, RRC_MODULE_ID,
					trans_id,
					oam_rrc_cell_traffic_trace_stop.cell_index);
			/* SPR FIX 10735 - */

			if(OAM_SUCCESS == ret_val) 
			{
				oam_send_call_trace_stop_resp(ret_val, trans_id,
						dest_id, &error_code);
#ifndef OAM_UT_FRAMEWORK
				oam_maintain_tcb(trans_id, OAM_TRANS_RRC,
						msg_len, p_api_buf);
#endif
			}
			else
			{
				oam_send_call_trace_stop_resp(ret_val, trans_id,
						dest_id, &error_code);
			}

			/* CSR_59405_FIX_END */
			break;

		case OAM_SET_LOG_ENABLE_RRC_REQ:  
			rrc_enable_req.log_on_off = OAM_RRC_ENABLE_LOG;
			oam_rrc_il_send_rrc_oam_log_enable_req(&rrc_enable_req,src_module_id,RRC_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid); /*Composer_Parser Changes*/
			/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
						OAM_TRANS_RRC,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
				return OAM_FAILURE;
			}
#endif
			/* SPR 9620 CHANGE END */


			break;

        case OAM_SET_LOG_ENABLE_X2AP_REQ:
            x2ap_log_enable_req.log_on_off = OAM_X2AP_ENABLE_LOG;
            oam_x2ap_il_send_x2ap_oam_log_enable_req(&x2ap_log_enable_req,src_module_id,RRC_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid); /*Composer_Parser Changes*/

#ifndef OAM_UT_FRAMEWORK
            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
                        OAM_TRANS_X2AP,msg_len,p_api_buf))
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                return OAM_FAILURE;
            }
#endif
            break;


        case OAM_SET_LOG_ENABLE_S1AP_REQ:
            s1ap_log_enable_req.log_on_off = OAM_S1AP_ENABLE_LOG;
            oam_s1ap_il_send_s1ap_oam_log_enable_req(&s1ap_log_enable_req,src_module_id,RRC_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid); /*Composer_Parser Changes*/

#ifndef OAM_UT_FRAMEWORK
            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
                        OAM_TRANS_S1AP,msg_len,p_api_buf))
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                return OAM_FAILURE;
            }
#endif
            break;

		case OAM_SET_LOG_DISABLE_RRC_REQ: 
			rrc_enable_req.log_on_off = OAM_RRC_DISABLE_LOG;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRC,msg_len,p_api_buf);
			oam_rrc_il_send_rrc_oam_log_enable_req(&rrc_enable_req,
					src_module_id,
					RRC_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
						OAM_TRANS_RRC,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
				return OAM_FAILURE;
			}
#endif
			/* SPR 9620 CHANGE END */

			break;

        case OAM_SET_LOG_DISABLE_X2AP_REQ:
            x2ap_log_enable_req.log_on_off = OAM_X2AP_DISABLE_LOG;
            oam_maintain_tcb(trans_id,OAM_TRANS_X2AP,msg_len,p_api_buf);
            oam_x2ap_il_send_x2ap_oam_log_enable_req(&x2ap_log_enable_req,
                    src_module_id,
                    RRC_MODULE_ID,
                    trans_id,
                    oam_prov_req.cell_cntxt.curr_cell_cid);

#ifndef OAM_UT_FRAMEWORK
            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
                        OAM_TRANS_X2AP,msg_len,p_api_buf))
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                return OAM_FAILURE;
            }
#endif

            break;

        case OAM_SET_LOG_DISABLE_S1AP_REQ:
            s1ap_log_enable_req.log_on_off = OAM_S1AP_DISABLE_LOG;
            oam_maintain_tcb(trans_id,OAM_TRANS_S1AP,msg_len,p_api_buf);
            oam_s1ap_il_send_s1ap_oam_log_enable_req(&s1ap_log_enable_req,
                    src_module_id,
                    RRC_MODULE_ID,
                    trans_id,
                    oam_prov_req.cell_cntxt.curr_cell_cid);

#ifndef OAM_UT_FRAMEWORK
            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
                        OAM_TRANS_S1AP,msg_len,p_api_buf))
            {
                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                return OAM_FAILURE;
            }
#endif
            break;
            
		case OAM_GET_LOG_CAT_EGTPU_REQ:
			oam_pr_egtpu_send_get_log_category_req(src_module_id,trans_id,&error_code);
			break;
			/***************************************************PM_CODE*******************************************************************/
		case OAM_GET_L2_RLC_STATS_REQ:  
			OAM_LOG(OAM,OAM_DETAILED,"In OAM_GET_L2_RLC_STATS_REQ");
			oam_maintain_tcb(trans_id,OAM_TRANS_RLC,msg_len,p_api_buf);
			oam_send_get_rlc_stats_req(src_module_id,trans_id,&error_code);
			break;
		case SHOW_STATS_L2_MAC:  
			OAM_LOG(OAM,OAM_DETAILED,"In SHOW_STATS_L2_MAC");
			oam_maintain_tcb(trans_id,OAM_TRANS_MAC,msg_len,p_api_buf);
			oam_send_mac_get_stats_req(src_module_id,trans_id,&error_code);
			break;
		case SHOW_STATS_L3_S1AP: 
			OAM_LOG(OAM,OAM_DETAILED,"In SHOW_STATS_L3_S1AP");
			oam_maintain_tcb(trans_id,OAM_TRANS_S1AP,msg_len,p_api_buf);
			break;
		case SHOW_STATS_L2_PDCP:  
			OAM_LOG(OAM,OAM_DETAILED,"In SHOW_STATS_L2_PDCP");
			oam_maintain_tcb(trans_id,OAM_TRANS_PDCP,msg_len,p_api_buf);
			oam_send_get_pdcp_stats_req(src_module_id,trans_id,&error_code);
			break;
		case SHOW_STATS_L2_EGTPU: 
			OAM_LOG(OAM,OAM_DETAILED,"In SHOW_STATS_L2_EGTPU");
			oam_maintain_tcb(trans_id,OAM_TRANS_EGTPU,msg_len,p_api_buf);
			break;
			/***************************************************PM_CODE***********************************************************************/

		case OAM_GET_LOG_LEVEL_L2_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_L2ALL,msg_len,p_api_buf);
			oam_mac_send_get_log_level_req(src_module_id,trans_id,&error_code);
			/*SPR 17842 START*/
                        global_trans_l2_log_flag = OAM_ONE;
                        global_trans_bitmap_l2_log = OAM_ZERO;
                        oam_rlc_send_get_log_level_req(src_module_id,trans_id,&error_code);
			oam_pdcp_send_get_log_level_req(src_module_id,trans_id,&error_code);
			oam_egtpu_get_log_level_req(OAM_NULL,src_module_id,trans_id,&error_code);
                        /*SPR 17842 END*/

			break;
            /* SPR 15499 Fix : code removed 
             Removed cases for OAM_SET_ENABLE_LOG_CAT_EGTPU_REQ and
             OAM_SET_DISABLE_LOG_CAT_EGTPU_REQ */

		case OAM_SET_LOG_LEVEL_L2_REQ:
			log_level = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));

			if(log_level==SYS_CRITICAL)
			{
				log_level_mac.logLevel  = MAC_CRITICALLOG;
				log_level_rlc.logLevel  = RLC_CRITICALLOG;
				log_level_pdcp.logLevel = PDCP_CRITICALLOG;
				log_level_gtpu.logLevel = GTPU_CRITICALLOG;
				oam_send_l2All_success_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else if(log_level==SYS_ERROR)
			{
				log_level_mac.logLevel  = MAC_ERRORLOG;
				log_level_rlc.logLevel  = RLC_ERRORLOG;
				log_level_pdcp.logLevel = PDCP_ERRORLOG;
				log_level_gtpu.logLevel = GTPU_ERRORLOG;
				oam_send_l2All_success_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else if(log_level==SYS_WARNING)
			{
				log_level_mac.logLevel  = MAC_WARNINGLOG;
				log_level_rlc.logLevel  = RLC_WARNINGLOG;
				log_level_pdcp.logLevel = PDCP_WARNINGLOG;
				log_level_gtpu.logLevel = GTPU_WARNINGLOG;
				oam_send_l2All_success_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else if(log_level==SYS_INFO)
			{
				log_level_mac.logLevel  = MAC_INFOLOG;
				log_level_rlc.logLevel  = RLC_INFOLOG;
				log_level_pdcp.logLevel = PDCP_INFOLOG;
				log_level_gtpu.logLevel = GTPU_INFOLOG;
				oam_send_l2All_success_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
            else if(log_level==SYS_BRIEF)
            {
                log_level_mac.logLevel  = MAC_BRIEFLOG;
                log_level_rlc.logLevel  = RLC_BRIEFLOG;
                log_level_pdcp.logLevel = PDCP_BRIEFLOG;
				log_level_gtpu.logLevel = GTPU_BRIEFLOG;
                oam_send_l2All_success_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
            }
			else if(log_level==SYS_DETAILED)
			{  
				log_level_mac.logLevel  = MAC_DETAILEDLOG;
				log_level_rlc.logLevel  = RLC_DETAILEDLOG;
				log_level_pdcp.logLevel = PDCP_DETAILEDLOG;
				log_level_gtpu.logLevel = GTPU_DETAILEDLOG;
				oam_send_l2All_success_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			else if(log_level==SYS_DETAILEDALL)
			{  
				log_level_mac.logLevel  = MAC_DETAILEDTTILOG;
				log_level_rlc.logLevel  = RLC_DETAILEDALLLOG;
				log_level_pdcp.logLevel = PDCP_DETAILEDALLLOG;
				log_level_gtpu.logLevel = GTPU_DETAILEDALLLOG;
				oam_send_l2All_success_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			}
			oam_rlc_send_set_log_level_req((Oam_LogLevel_Req_t *)&log_level_rlc,src_module_id,trans_id,&error_code);
			oam_pdcp_send_set_log_level_req((oam_pdcp_log_level_req_t *)&log_level_pdcp,src_module_id,trans_id,&error_code);
			oam_mac_send_set_log_level_req((oam_mac_log_level_req_t *)&log_level_mac,src_module_id,trans_id,&error_code);
			oam_egtpu_set_log_level_req(&log_level_gtpu,src_module_id,trans_id,&error_code);

			break;
		case OAM_SET_LOG_LEVEL_L3_RRC_REQ: 
			log_level_rrc = ((UInt8) *((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			rrc_log_level_req.log_level = log_level_rrc;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRC,msg_len,p_api_buf);
			/* CSR 57877 Fix START*/
			oam_rrc_il_send_rrc_oam_set_log_level_req(&rrc_log_level_req,
					src_module_id,
					RRC_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* CSR 57877 Fix End*/
			break;
            
		case OAM_SET_LOG_LEVEL_L3_X2AP_REQ: 
			log_level_rrc = ((UInt8) *((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			x2ap_log_level_req.log_level = log_level_rrc;
			oam_maintain_tcb(trans_id,OAM_TRANS_X2AP,msg_len,p_api_buf);
			oam_x2ap_il_send_x2ap_oam_set_log_level_req(&x2ap_log_level_req,
					src_module_id,
					RRC_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			break;
		case OAM_SET_LOG_LEVEL_L3_S1AP_REQ: 
			log_level_rrc = ((UInt8) *((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			s1ap_log_level_req.log_level = log_level_rrc;
			oam_maintain_tcb(trans_id,OAM_TRANS_S1AP,msg_len,p_api_buf);
			oam_s1ap_il_send_s1ap_oam_set_log_level_req(&s1ap_log_level_req,
					src_module_id,
					RRC_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			break;
		case OAM_SET_LOG_LEVEL_RRM_REQ: 
			OAM_LOG(OAM, OAM_INFO,
					"User request to set log level for RRM received");

			offset = QCLI_HEADER_SIZE;
			module_id = (SInt32)(*((UInt8*)p_api_buf + offset));
			offset += sizeof(rrm_oam_log_level_et);
            /* SPR 19703 changes start */
			log_level_rrm = (UInt32)(*((UInt8*)p_api_buf + offset));
            /* SPR 19703 changes end */
			/* coverity 35874 35873 */
			rrm_log_level_req.module_id =
				(rrm_internal_module_id_et)module_id;
            /* SPR 19703 changes start */
			/*SPR_20065: coverity 110690 Fix Start*/
			rrm_log_level_req.log_level = (rrm_oam_log_level_et)log_level_rrm;
			/*SPR_20065: coverity 110690 Fix End*/
            /* SPR 19703 changes end */
			trans_id = oam_get_new_trans_id();
			oam_maintain_tcb(trans_id, OAM_TRANS_RRM, msg_len, p_api_buf);
			ret_val =
				/* CSR 57877 Fix START*/
				oam_rrm_send_rrm_oam_set_log_level_req(&rrm_log_level_req,
						/* CSR 57877 Fix End*/
						src_module_id,
						RRM_MODULE_ID,
						trans_id,
						oam_prov_req.cell_cntxt.curr_cell_cid);
			if(OAM_FAILURE == ret_val) {
				OAM_LOG(OAM, OAM_ERROR,
						"Failed to send RRM_OAM_SET_LOG_LEVEL_REQ to lower layer");
			}
			else {
				OAM_LOG(OAM, OAM_INFO, "RRM_OAM_SET_LOG_LEVEL_REQ sent to lower layer");
			}
			break;

#ifdef OAM_SON_ENABLE
		case OAM_SET_LOG_LEVEL_SON_REQ: 
			oam_memcpy(&module_id_son,
					((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE),
					OAM_FOUR);
			oam_memcpy(&log_level_son,((UInt8*)p_api_buf + OAM_SIXTEEN),OAM_FOUR);
			/* Coverity Fix: Vivek */
			/* coverity 41328 */
			son_log_level_req.module_id = (son_module_id_et)module_id_son;
			/* coverity 41327 */
			son_log_level_req.log_level = (son_oam_log_level_et)log_level_son;
			oam_maintain_tcb(trans_id,OAM_TRANS_SON,msg_len,p_api_buf);
			/* CSR 57877 Fix START*/
			oam_son_send_son_oam_set_log_level_req(&son_log_level_req,
					src_module_id,
					SON_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* CSR 57877 Fix End*/
			/* SPR 9620 CHANGE START */ 
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
						OAM_TRANS_SON,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
				ret_val = OAM_FAILURE;
			}
#endif
			/* SPR 9620 CHANGE END */
			break;
#endif
		case OAM_SET_LOG_LEVEL_OAM_REQ:
			log_level = ((UInt32)  *((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			prov_req.log_level = log_level;
			/*BUG_FIX_ID : 597*/
			adv_log_level = oam_convert_log_level(log_level);
			set_loglevel_limit(log_index,adv_log_level);

			oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
			break;
		case OAM_SET_LOG_LEVEL_REQ:
			transaction_id = get_word_from_header((UInt8 *)p_api_buf + OAM_ZERO);
			oam_maintain_tcb(transaction_id,OAM_TRANS_SYSTEM_LOG,msg_len,p_api_buf);
			log_level = ((UInt32) *((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			oam_sys_log = 1;
			if(log_level==SYS_CRITICAL)
			{
				log_level_mac.logLevel  = MAC_CRITICALLOG;
				log_level_rlc.logLevel  = RLC_CRITICALLOG;
				log_level_pdcp.logLevel = PDCP_CRITICALLOG;
				log_level_gtpu.logLevel = GTPU_CRITICALLOG;
				/* CSR 57877 Fix START*/
				log_level_rrc=OAM_RRC_CRITICALLOG;
				/* CSR 57877 Fix End*/
				log_level_rrm = RRM_OAM_ERROR;
				log_level_oam=OAM_CRITICAL;
#ifdef OAM_SON_ENABLE
				/* CSR 57877 Fix START*/
				log_level_son=OAM_SON_ERRORLOG;
				/* CSR 57877 Fix End*/
#endif
			}
			else if(log_level==SYS_ERROR)
			{
				log_level_mac.logLevel  = MAC_ERRORLOG;
				log_level_rlc.logLevel  = RLC_ERRORLOG;
				log_level_pdcp.logLevel = PDCP_ERRORLOG;
				log_level_gtpu.logLevel = GTPU_ERRORLOG;
				/* CSR 57877 Fix START*/
				log_level_rrc=OAM_RRC_ERRORLOG;
				/* CSR 57877 Fix End*/
				log_level_rrm = RRM_OAM_ERROR;
				log_level_oam=OAM_ERROR;
#ifdef OAM_SON_ENABLE
				/* CSR 57877 Fix START*/
				log_level_son=OAM_SON_ERRORLOG;
				/* CSR 57877 Fix End*/
#endif
			}
			else if(log_level==SYS_WARNING)
			{
				log_level_mac.logLevel  = MAC_WARNINGLOG;
				log_level_rlc.logLevel  = RLC_WARNINGLOG;
				log_level_pdcp.logLevel = PDCP_WARNINGLOG;
				log_level_gtpu.logLevel = GTPU_WARNINGLOG;
				/* CSR 57877 Fix START*/
				log_level_rrc=OAM_RRC_WARNINGLOG;
				/* CSR 57877 Fix End*/
				log_level_rrm = RRM_OAM_WARNING;
				log_level_oam=OAM_WARNING;
#ifdef OAM_SON_ENABLE
				/* CSR 57877 Fix START*/
				log_level_son=OAM_SON_WARNINGLOG;
				/* CSR 57877 Fix End*/
#endif
			}
			else if(log_level==SYS_INFO)
			{
				log_level_mac.logLevel  = MAC_INFOLOG;
				log_level_rlc.logLevel  = RLC_INFOLOG;
				log_level_pdcp.logLevel = PDCP_INFOLOG;
				log_level_gtpu.logLevel = GTPU_INFOLOG;
				/* CSR 57877 Fix START*/
				log_level_rrc=OAM_RRC_INFOLOG;
				/* CSR 57877 Fix End*/
				log_level_rrm = RRM_OAM_BRIEF;
				log_level_oam=OAM_INFO;
#ifdef OAM_SON_ENABLE
				/* CSR 57877 Fix START*/
				log_level_son=OAM_SON_INFOLOG;
				/* CSR 57877 Fix End*/
#endif
			}
            else if(log_level==SYS_BRIEF)
            {
                log_level_mac.logLevel  = MAC_BRIEFLOG;
                log_level_rlc.logLevel  = RLC_BRIEFLOG;
                log_level_pdcp.logLevel = PDCP_BRIEFLOG;
				log_level_gtpu.logLevel = GTPU_BRIEFLOG;
                log_level_rrc           = OAM_RRC_BRIEFLOG;
                log_level_rrm           = RRM_OAM_BRIEF;
                log_level_oam           = OAM_BRIEF;
#ifdef OAM_SON_ENABLE
                log_level_son           = OAM_SON_BRIEFLOG;
#endif
            }
			else if(log_level==SYS_DETAILED)
			{
				log_level_mac.logLevel  = MAC_DETAILEDLOG;
				log_level_rlc.logLevel  = RLC_DETAILEDLOG;
				log_level_pdcp.logLevel = PDCP_DETAILEDLOG;
				log_level_gtpu.logLevel = GTPU_DETAILEDLOG;
				log_level_rrm = RRM_OAM_DETAILED;
				log_level_oam=OAM_DETAILED;
#ifdef OAM_SON_ENABLE
				/* CSR 57877 Fix START*/
				log_level_son=OAM_SON_DETAILEDLOG;
#endif
				log_level_rrc=OAM_RRC_DETAILEDLOG;
				/* CSR 57877 Fix End*/
			}
			else if(log_level==SYS_DETAILEDALL)
			{
				log_level_mac.logLevel  = MAC_DETAILEDTTILOG;
				log_level_rlc.logLevel  = RLC_DETAILEDALLLOG;
				log_level_pdcp.logLevel = PDCP_DETAILEDALLLOG;
				log_level_gtpu.logLevel = GTPU_DETAILEDALLLOG;
				log_level_rrm = RRM_OAM_DETAILEDALL;
				log_level_oam=OAM_DETAILEDALL;
/* spr17535 - start */
#ifdef OAM_SON_ENABLE
				log_level_son=OAM_SON_DETAILEDALLLOG;
#endif
/* spr17535 - end */
				log_level_rrc=OAM_RRC_DETAILEDALLLOG;
			}
			OAM_LOG(OAM,OAM_DETAILED, "SYSTEM LOG lEVEL COMMAND CALLED:LOG_LEVEL = %u",log_level );
			oam_rlc_send_set_log_level_req((Oam_LogLevel_Req_t *)&log_level_rlc,src_module_id,transaction_id,&error_code);
			oam_pdcp_send_set_log_level_req((oam_pdcp_log_level_req_t *)&log_level_pdcp,src_module_id,transaction_id,&error_code);
			oam_mac_send_set_log_level_req((oam_mac_log_level_req_t *)&log_level_mac,src_module_id,transaction_id,&error_code);
		    oam_egtpu_set_log_level_req(&log_level_gtpu,src_module_id,trans_id,&error_code);
			prov_req.log_level = log_level_oam;
			/* coverity 52801 52800*/
			rrm_log_level_req.module_id = (rrm_internal_module_id_et)OAM_ZERO;
            /* SPR 19703 changes start */
		
			/*SPR_20065: coverity 110690 Fix Start*/
			rrm_log_level_req.log_level = (rrm_oam_log_level_et)log_level_rrm;
			/*SPR_20065: coverity 110690 Fix Start*/
            /* SPR 19703 changes end */

			oam_rrc_il_send_rrc_oam_set_log_level_req(
					(rrc_oam_set_log_level_req_t *)&log_level_rrc,
					src_module_id,
					RRC_MODULE_ID,
					transaction_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/*Composer_Parser Changes*/
			/* CSR 57877 Fix START*/
			oam_rrm_send_rrm_oam_set_log_level_req(&rrm_log_level_req,
					src_module_id,
					RRM_MODULE_ID,
					transaction_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* CSR 57877 Fix End*/
#ifdef OAM_SON_ENABLE
			oam_memcpy(&module_id_son,
					((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE),
					OAM_FOUR);
			/* coverity 52802 35879*/
			son_log_level_req.module_id = (son_module_id_et)OAM_ZERO;
			son_log_level_req.log_level = (son_oam_log_level_et)log_level_son;
			/* CSR 57877 Fix START*/
			oam_son_send_son_oam_set_log_level_req(&son_log_level_req,
					src_module_id,
					SON_MODULE_ID,
					transaction_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* CSR 57877 Fix End*/
			/* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(transaction_id,OAM_SUB_MODULE_SON,
						OAM_TRANS_SON,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
				ret_val = OAM_FAILURE;
                /*Coverity fix start : 83308 */
                return ret_val;
                /*Coverity fix End : 83308 */
			}
#endif
			/* SPR 9620 CHANGE END */
#endif
			adv_log_level = oam_convert_log_level(log_level_oam);
			set_loglevel_limit(log_index,adv_log_level);
			break;
		case OAM_CELLMGT_RECONFIG_SIB1_INTRA_FREQ_REQ:
			Intra_freq = ((UInt16)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if (OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t), (void *)&p_rrm_sib1_req,&error_code))
			{
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to p_rrm_sib1_req failed"
						" with Error Code:%d",
						error_code);
				OAM_FUN_EXIT_TRACE();
				/* Not Enough Memory */
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83308 */
                return ret_val;
                /*Coverity fix End : 83308 */
			}
			/* Coverity ID : 72270 , 83452 Fix Start*/
			oam_memset(p_rrm_sib1_req,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72270 , 83452 Fix End*/
			oam_memcpy(&p_rrm_sib1_req->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));

			oam_memcpy(&p_rrm_sib1_req->cell_access_restriction_params,
					&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
					global_cell_info.cell_access_restriction_params,
					sizeof(p_rrm_sib1_req->cell_access_restriction_params));

			if(Intra_freq==RRM_OAM_INTRA_FREQ_RESELECTION_ALLOWED)
				oam_memcpy(&p_rrm_sib1_req->cell_access_restriction_params.intra_freq_reselection,(void *)&Intra_freq,sizeof(rrm_oam_intra_freq_reselection_et));
			else if(Intra_freq == RRM_OAM_INTRA_FREQ_RESELECTION_NOT_ALLOWED)
				oam_memcpy(&p_rrm_sib1_req->cell_access_restriction_params.intra_freq_reselection,(void *)&Intra_freq,sizeof(rrm_oam_intra_freq_reselection_et));
			/* coverity 41304 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				global_cell_info.cell_access_restriction_params.
				intra_freq_reselection = (rrm_oam_intra_freq_reselection_et)Intra_freq;

			oam_maintain_tcb(OAM_ONE,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_rrm_sib1_req,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72270 Fix Start*/
			oam_mem_free(p_rrm_sib1_req,&error_code);
			/* Coverity ID : 72270 Fix End*/
			break;
		case OAM_CELLMGT_RECONFIG_SIB1_MNC_REQ:
			mnc_val = ((UInt16)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if (OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void *)&p_rrm_sib1_mnc_req,&error_code))
			{
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to p_rrm_sib1_mnc_req failed"
						" with Error Code:%d",
						error_code);
				OAM_FUN_EXIT_TRACE();
				/* Not Enough Memory */
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83308 */
                return ret_val;
                /*Coverity fix End : 83308 */
			}
			/* Coverity ID : 72269 Fix Start*/
			oam_memset(p_rrm_sib1_mnc_req,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72269 Fix End*/
			oam_memcpy(&p_rrm_sib1_mnc_req->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_rrm_sib1_mnc_req->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.
					oam_rrm_cell_config_req[cell_config_idx].
					global_cell_info.cell_access_restriction_params,
					sizeof(rrm_oam_cell_access_restriction_params_t));/*    Coverity ID: 72275  Fix */

			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				global_cell_info.eutran_global_cell_id.primary_plmn_id.mnc[OAM_TWO] = 
				p_rrm_sib1_mnc_req->global_cell_id.primary_plmn_id.mnc[OAM_TWO] = mnc_val % OAM_TEN;
			mnc_val /= OAM_TEN;

			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				global_cell_info.eutran_global_cell_id.primary_plmn_id.mnc[OAM_ONE] =
				p_rrm_sib1_mnc_req->global_cell_id.primary_plmn_id.mnc[OAM_ONE] = mnc_val % OAM_TEN;
			mnc_val /= OAM_TEN;

			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				global_cell_info.eutran_global_cell_id.primary_plmn_id.mnc[OAM_ZERO] = 
				p_rrm_sib1_mnc_req->global_cell_id.primary_plmn_id.mnc[OAM_ZERO] = mnc_val % OAM_TEN;

			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_rrm_sib1_mnc_req,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72269 Fix Start*/
			oam_mem_free(p_rrm_sib1_mnc_req,&error_code);
			/* Coverity ID : 72269 Fix End*/
			break;
		case OAM_CELLMGT_RECONFIG_SIB1_MCC_REQ:
			mcc_val = ((UInt16)  *((UInt8*)p_api_buf + OAM_TEN));
			if (OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void *)&p_rrm_sib1_mcc_req,&error_code))
			{
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to p_rrm_sib1_mcc_req failed"
						" with Error Code:%d",
						error_code);
				OAM_FUN_EXIT_TRACE();
				/* Not Enough Memory */
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83308 */
                return ret_val;
                /*Coverity fix End : 83308 */
			}
			oam_memset(p_rrm_sib1_mcc_req,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			oam_memcpy(&p_rrm_sib1_mcc_req->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_rrm_sib1_mcc_req->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
					global_cell_info.cell_access_restriction_params,sizeof(p_rrm_sib1_mcc_req->cell_access_restriction_params));

			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				global_cell_info.eutran_global_cell_id.primary_plmn_id.mcc[OAM_TWO] = p_rrm_sib1_mcc_req->global_cell_id.
				primary_plmn_id.mcc[OAM_TWO] = mcc_val % OAM_TEN;
			mcc_val /= OAM_TEN;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				global_cell_info.eutran_global_cell_id.primary_plmn_id.mcc[OAM_ONE] = 
				p_rrm_sib1_mcc_req->global_cell_id.primary_plmn_id.mcc[OAM_ONE] = mcc_val % OAM_TEN;
			mcc_val /= OAM_TEN;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				global_cell_info.eutran_global_cell_id.primary_plmn_id.mcc[OAM_ZERO] = 
				p_rrm_sib1_mcc_req->global_cell_id.primary_plmn_id.mcc[OAM_ZERO] = mcc_val % OAM_TEN;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_rrm_sib1_mcc_req,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72268 Fix Start*/
			oam_mem_free(p_rrm_sib1_mcc_req,&error_code);
			/* Coverity ID : 72268 Fix End*/
			break;
		case OAM_CELLMGT_RECONFIG_SIB2_ADD_SPEC_EMI_REQ:
			add_spec_emi = ((UInt8)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_rrm_sib2_spec_req,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to p_rrm_sib2_spec_req failed"
						" with Error Code:%d",
						error_code);
				ret_val = OAM_FAILURE; 
/* SPR 20007 : CID 97118 fix start */
                return ret_val;
/* SPR 20007 : CID 97118 fix end */
			}
			/* Coverity ID : 72274 Fix Start*/
			oam_memset(p_rrm_sib2_spec_req,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72274 Fix End*/
			oam_memcpy(&p_rrm_sib2_spec_req->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_rrm_sib2_spec_req->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.
					oam_rrm_cell_config_req[cell_config_idx].
					global_cell_info.cell_access_restriction_params,
					sizeof(p_rrm_sib2_spec_req->cell_access_restriction_params));

			oam_memcpy(&p_rrm_sib2_spec_req->operator_info,&oam_prov_req.oam_rrm_req.
					oam_rrm_cell_config_req[cell_config_idx].
					operator_info,sizeof(p_rrm_sib2_spec_req->operator_info));

				oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= 
				p_rrm_sib2_spec_req->bitmask = RRM_OAM_OPERATOR_INFO_PRESENT;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].operator_info.
				sib_2_info.additional_spectrum_emission = p_rrm_sib2_spec_req->operator_info.sib_2_info.additional_spectrum_emission = 
				add_spec_emi;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_rrm_sib2_spec_req,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72274 Fix Start*/
			oam_mem_free(p_rrm_sib2_spec_req,&error_code);
			/* Coverity ID : 72274 Fix End*/
			break;
		case OAM_CELLMGT_RECONFIG_SIB2_DEF_PAG_CYL_REQ:
			/* Coverity Fix: Vivek */
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_rrm_sib2_dflt_pag_cyl,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_rrm_sib2_dflt_pag_cyl failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83311 */
                return ret_val;
                /*Coverity fix End : 83311 */

			}
			dflt_pag_cyl = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			oam_memset(p_rrm_sib2_dflt_pag_cyl,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			oam_memcpy(&p_rrm_sib2_dflt_pag_cyl->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_rrm_sib2_dflt_pag_cyl->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req
					[cell_config_idx].global_cell_info.cell_access_restriction_params,
					sizeof(p_rrm_sib2_dflt_pag_cyl->cell_access_restriction_params));
			oam_memcpy(&p_rrm_sib2_dflt_pag_cyl->operator_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req
					[cell_config_idx].operator_info,sizeof(p_rrm_sib2_dflt_pag_cyl->operator_info));


			if(dflt_pag_cyl==RRM_OAM_DEF_PAG_CYCLE_RF32)
				oam_memcpy(&p_rrm_sib2_dflt_pag_cyl->operator_info.sib_2_info.radio_res_config_common_sib.default_paging_cycle,(void *)& dflt_pag_cyl,sizeof(rrm_oam_default_paging_cycle_et));
			else if(dflt_pag_cyl == RRM_OAM_DEF_PAG_CYCLE_RF64)
				oam_memcpy(&p_rrm_sib2_dflt_pag_cyl->operator_info.sib_2_info.radio_res_config_common_sib.default_paging_cycle,(void *)& dflt_pag_cyl,sizeof(rrm_oam_default_paging_cycle_et));
			else if(dflt_pag_cyl == RRM_OAM_DEF_PAG_CYCLE_RF128)
				oam_memcpy(&p_rrm_sib2_dflt_pag_cyl->operator_info.sib_2_info.radio_res_config_common_sib.default_paging_cycle,(void *)& dflt_pag_cyl,sizeof(rrm_oam_default_paging_cycle_et));
			else if(dflt_pag_cyl == RRM_OAM_DEF_PAG_CYCLE_RF256)
				oam_memcpy(&p_rrm_sib2_dflt_pag_cyl->operator_info.sib_2_info.radio_res_config_common_sib.default_paging_cycle,(void *)& dflt_pag_cyl,sizeof(rrm_oam_default_paging_cycle_et));

			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_rrm_sib2_dflt_pag_cyl->bitmask = RRM_OAM_OPERATOR_INFO_PRESENT;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= p_rrm_sib2_dflt_pag_cyl->operator_info.sib_2_info.radio_res_config_common_sib.bitmask = RRM_OAM_DEFAULT_PAGING_CYCLE_PRESENT;
			/* coverity 41305 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
				operator_info.sib_2_info.radio_res_config_common_sib.default_paging_cycle = (rrm_oam_default_paging_cycle_et)dflt_pag_cyl;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_rrm_sib2_dflt_pag_cyl,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72271 Fix Start*/
			oam_mem_free(p_rrm_sib2_dflt_pag_cyl,&error_code);
			/* Coverity ID : 72271 Fix End*/
			break;
		case OAM_CELLMGT_RECONFIG_SIB2_DEF_MOD_PRD_COEFF_REQ:
			mod_per_coeff = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_rrm_sib2_mod_per_coeff,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_rrm_sib2_mod_per_coeff failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83333 */
                return ret_val;
                /*Coverity fix end : 83333 */
			}
			/* Coverity ID : 72272 Fix Start*/
			oam_memset(p_rrm_sib2_mod_per_coeff,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72272 Fix End*/
			oam_memcpy(&p_rrm_sib2_mod_per_coeff->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_rrm_sib2_mod_per_coeff->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req
					[cell_config_idx].global_cell_info.cell_access_restriction_params,
					sizeof(p_rrm_sib2_mod_per_coeff->cell_access_restriction_params));
			oam_memcpy(&p_rrm_sib2_mod_per_coeff->operator_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req
					[cell_config_idx].operator_info,sizeof(p_rrm_sib2_mod_per_coeff->operator_info));
			if(mod_per_coeff==RRM_OAM_MOD_PERIOD_COEFF_N2)
				oam_memcpy(&p_rrm_sib2_mod_per_coeff->operator_info.sib_2_info.radio_res_config_common_sib.modification_period_coeff,(void *)&mod_per_coeff,sizeof(rrm_oam_modification_period_coeff_et));
			else if(mod_per_coeff == RRM_OAM_MOD_PERIOD_COEFF_N4)
				oam_memcpy(&p_rrm_sib2_mod_per_coeff->operator_info.sib_2_info.radio_res_config_common_sib.modification_period_coeff,(void *)&mod_per_coeff,sizeof(rrm_oam_modification_period_coeff_et));
			else if(mod_per_coeff == RRM_OAM_MOD_PERIOD_COEFF_N8)
				oam_memcpy(&p_rrm_sib2_mod_per_coeff->operator_info.sib_2_info.radio_res_config_common_sib.modification_period_coeff,(void *)&mod_per_coeff,sizeof(rrm_oam_modification_period_coeff_et));
			else if(mod_per_coeff == RRM_OAM_MOD_PERIOD_COEFF_N16)
				oam_memcpy(&p_rrm_sib2_mod_per_coeff->operator_info.sib_2_info.radio_res_config_common_sib.modification_period_coeff,(void *)&mod_per_coeff,sizeof(rrm_oam_modification_period_coeff_et));


			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_rrm_sib2_mod_per_coeff->bitmask = RRM_OAM_OPERATOR_INFO_PRESENT;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= p_rrm_sib2_mod_per_coeff->operator_info.sib_2_info.radio_res_config_common_sib.bitmask = RRM_OAM_MODIFICATION_PERIOD_COEFF_PRESENT;
			/* coverity 41306 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].operator_info.sib_2_info.radio_res_config_common_sib.modification_period_coeff = (rrm_oam_modification_period_coeff_et)mod_per_coeff;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_rrm_sib2_mod_per_coeff,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72272 Fix Start*/
			oam_mem_free(p_rrm_sib2_mod_per_coeff,&error_code);
			/* Coverity ID : 72272 Fix End*/
			break;
		case OAM_CELLMGT_RECONFIG_SIB2_NB_REQ:
			nb = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_rrm_sib2_nb,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_rrm_sib2_nb failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83333 */
                return ret_val;
                /*Coverity fix end : 83333 */
			}
            /*Coverity fix start : 83342,83452 */
            oam_memset(p_rrm_sib2_nb,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
            /*Coverity fix end : 83342,83452 */
			oam_memcpy(&p_rrm_sib2_nb->global_cell_id,&oam_prov_req.oam_rrm_req.
					oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id,sizeof(p_rrm_sib2_nb->global_cell_id));
			oam_memcpy(&p_rrm_sib2_nb->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req
					[cell_config_idx].global_cell_info.cell_access_restriction_params,
					sizeof(p_rrm_sib2_nb->cell_access_restriction_params));
			oam_memcpy(&p_rrm_sib2_nb->operator_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
					operator_info,sizeof(p_rrm_sib2_nb->operator_info));

			if(nb==RRM_OAM_NB_FOUR_T)
				oam_memcpy(&p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB,(void *)&nb,sizeof(rrm_oam_nB_et));
			else if(nb == RRM_OAM_NB_ONE_T)
				oam_memcpy(&p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB,(void *)&nb,sizeof(rrm_oam_nB_et));
			else if(nb == RRM_OAM_NB_HALF_T)
				oam_memcpy(&p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB,(void *)&nb,sizeof(rrm_oam_nB_et));
			else if(nb == RRM_OAM_NB_QUARTER_T)
				oam_memcpy(&p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB,(void *)&nb,sizeof(rrm_oam_nB_et));
			else if(nb == RRM_OAM_NB_ONE_EIGHTH_T)
				oam_memcpy(&p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB,(void *)&nb,sizeof(rrm_oam_nB_et));
			else if(nb == RRM_OAM_NB_ONE_SIXTEENTH_T)
				oam_memcpy(&p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB,(void *)&nb,sizeof(rrm_oam_nB_et));
			else if(nb == RRM_OAM_NB_ONE_THIRTY_SECOND_T)
				oam_memcpy(&p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB,(void *)&nb,sizeof(rrm_oam_nB_et));


			oam_memcpy(&p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB,(void *)&nb,sizeof(p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.nB));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_rrm_sib2_nb->bitmask = RRM_OAM_OPERATOR_INFO_PRESENT;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= p_rrm_sib2_nb->operator_info.sib_2_info.radio_res_config_common_sib.bitmask = RRM_OAM_NB_PRESENT;
			/* coverity 41307*/
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].operator_info.sib_2_info.radio_res_config_common_sib.nB = (rrm_oam_nB_et)nb;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_rrm_sib2_nb,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72273 Fix Start*/
			oam_mem_free(p_rrm_sib2_nb,&error_code);
			/* Coverity ID : 72273 Fix End*/
			break;
		case OAM_CELLMGT_RECONFIG_SIB2_TIME_ALGN_TIMER_REQ:
			time_align_timer = ((UInt8)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_rrm_sib2_time_align_timer,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_rrm_sib2_time_align_timer failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83309 */
                return ret_val;
                /*Coverity fix end : 83309 */
			}
			/* Coverity ID : 72275 Fix Start*/
			oam_memset(p_rrm_sib2_time_align_timer,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72275 Fix End*/
			oam_memcpy(&p_rrm_sib2_time_align_timer->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_rrm_sib2_time_align_timer->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_rrm_sib2_time_align_timer->cell_access_restriction_params));
			oam_memcpy(&p_rrm_sib2_time_align_timer->operator_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].operator_info,sizeof(p_rrm_sib2_time_align_timer->operator_info));

			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_rrm_sib2_time_align_timer->bitmask = RRM_OAM_OPERATOR_INFO_PRESENT;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].operator_info.sib_2_info.time_alignment_timer_common = p_rrm_sib2_time_align_timer->operator_info.sib_2_info.time_alignment_timer_common = time_align_timer;
			oam_rrm_send_rrm_oam_cell_reconfig_req(
					p_rrm_sib2_time_align_timer,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72275 Fix Start*/
			oam_mem_free(p_rrm_sib2_time_align_timer,&error_code);
			/* Coverity ID : 72275 Fix End*/

			break;
		case OAM_FAP_CONFIG_RAN_BARR_EMERGENCY_REQ:
			cell_barr = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_fap_ran_barr_for_emergency,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_barr_for_emergency failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83309 */
                return ret_val;
                /*Coverity fix end : 83309 */
			}
			/* Coverity ID : 72260 Fix Start*/
			oam_memset(p_fap_ran_barr_for_emergency,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72260 Fix End*/
			oam_memcpy(&p_fap_ran_barr_for_emergency->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_barr_for_emergency->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_barr_for_emergency->cell_access_restriction_params));
			/* coverity 41303 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params.barring_for_emergency=p_fap_ran_barr_for_emergency->cell_access_restriction_params.barring_for_emergency=(rrm_bool_et)cell_barr;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(
					p_fap_ran_barr_for_emergency,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72260 Fix Start*/
			oam_mem_free(p_fap_ran_barr_for_emergency, &error_code);
			/* Coverity ID : 72260 Fix End*/
			break;
		case OAM_FAP_CONFIG_RAN_MAC_RACH_MAXHARQ_REQ:
			max_harq = ((UInt8)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_fap_ran_mac_rach_maxharq,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_mac_rach_maxharq failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                /*Coverity fix start : 83309 */
                return ret_val;
                /*Coverity fix end : 83309 */
			}
			/* Coverity ID : 72261 Fix Start*/
			oam_memset(p_fap_ran_mac_rach_maxharq,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72261 Fix End*/
			oam_memcpy(&p_fap_ran_mac_rach_maxharq->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_mac_rach_maxharq->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_maxharq->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_mac_rach_maxharq->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_mac_rach_maxharq->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.mac_layer_params.mac_layer_param_rach.max_harq_msg_3tx=p_fap_ran_mac_rach_maxharq->ran_info.mac_layer_params.mac_layer_param_rach.max_harq_msg_3tx = max_harq;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_mac_rach_maxharq->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(
					p_fap_ran_mac_rach_maxharq,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);

			/* Coverity ID : 72261 Fix Start*/
			oam_mem_free(p_fap_ran_mac_rach_maxharq, &error_code);
			/* Coverity ID : 72261 Fix End*/
			break;
		case OAM_FAP_CONFIG_RAN_MAC_RACH_MSG_PWR_OFFSET_GRP_B_REQ:
			pwr_offset = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
            /*Coverity fix start : 83326 */
            if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
                        (void*)&p_fap_ran_mac_rach_msg_pwr_offset,
                        &error_code)) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_mac_rach_msg_pwr_offset failed"
                        " with Error Code:%d",
                        error_code);
                ret_val = OAM_FAILURE;
                return ret_val;
            }

            oam_memset(p_fap_ran_mac_rach_msg_pwr_offset,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
            /*Coverity fix start : end */
            oam_memcpy(&p_fap_ran_mac_rach_msg_pwr_offset->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_mac_rach_msg_pwr_offset->global_cell_id,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id,sizeof(p_fap_ran_mac_rach_msg_pwr_offset->global_cell_id));
			oam_memcpy(&p_fap_ran_mac_rach_msg_pwr_offset->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_msg_pwr_offset->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_mac_rach_msg_pwr_offset->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_mac_rach_msg_pwr_offset->ran_info));
			/* coverity 41309 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_power_offset_group_b=p_fap_ran_mac_rach_msg_pwr_offset->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_power_offset_group_b = (rrm_oam_group_b_msg_power_offset_et)pwr_offset;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_mac_rach_msg_pwr_offset->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(
					p_fap_ran_mac_rach_msg_pwr_offset,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
                    /*coverity 85212 fix start*/
                    oam_mem_free(p_fap_ran_mac_rach_msg_pwr_offset,&error_code);
                    /*coverity 85212 fix end*/
			break;
		case OAM_FAP_CONFIG_RAN_MAC_RACH_PWR_RAMP_STEP_REQ:
			pwr_ramp = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
            /*Coverity fix start : 83326*/
            if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
                        (void*)&p_fap_ran_mac_rach_pwr_ramp,
                        &error_code)) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_mac_rach_pwr_ramp failed"
                        " with Error Code:%d",
                        error_code);
                ret_val = OAM_FAILURE;
                        return ret_val;
            }
            oam_memset(p_fap_ran_mac_rach_pwr_ramp,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
            /*Coverity fix start : 83326*/

			oam_memcpy(&p_fap_ran_mac_rach_pwr_ramp->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_mac_rach_pwr_ramp->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_pwr_ramp->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_mac_rach_pwr_ramp->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_mac_rach_pwr_ramp->ran_info));
			/* coverity 41308 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.mac_layer_params.mac_layer_param_rach.power_ramping_step = p_fap_ran_mac_rach_pwr_ramp->ran_info.mac_layer_params.mac_layer_param_rach.power_ramping_step = (rrm_oam_power_ramping_step_et)pwr_ramp;
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_mac_rach_pwr_ramp->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(
					p_fap_ran_mac_rach_pwr_ramp,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
            /*coverity 85205 fix start*/
            oam_mem_free(p_fap_ran_mac_rach_pwr_ramp,&error_code);
            /*coverity 85205 fix end*/
			break;
		case OAM_FAP_CONFIG_RAN_MAC_RACH_PREAMBLE_INIT_RX_TGT_PWR_REQ:
			init_tgt_pwr = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
            /*Coverity fix start : 83336 */
            if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
                        (void*)&p_fap_ran_mac_rach_preamble_init_rx,
                        &error_code)) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_mac_rach_preamble_init_rx failed"
                        " with Error Code:%d",
                        error_code);
                ret_val = OAM_FAILURE;
                return ret_val;
            }
            oam_memset(p_fap_ran_mac_rach_preamble_init_rx,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
            /*Coverity fix End : 83336 */

			oam_memcpy(&p_fap_ran_mac_rach_preamble_init_rx->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_mac_rach_preamble_init_rx->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_preamble_init_rx->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_mac_rach_preamble_init_rx->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_mac_rach_preamble_init_rx->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_mac_rach_preamble_init_rx->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			/* coverity 41310 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.mac_layer_params.mac_layer_param_rach.preamble_initial_received_target_power = p_fap_ran_mac_rach_preamble_init_rx->ran_info.mac_layer_params.mac_layer_param_rach.preamble_initial_received_target_power = (rrm_oam_preamble_init_rec_target_pow_et)init_tgt_pwr;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(
					p_fap_ran_mac_rach_preamble_init_rx,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
            /*coverity 85216 fix start*/
            oam_mem_free(p_fap_ran_mac_rach_preamble_init_rx,&error_code);
            /*coverity 85216 fix end */
			break;
		case OAM_FAP_CONFIG_RAN_MAC_RACH_PREAMBLE_TX_MAX_REQ:
			pre_tx_max = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_fap_ran_mac_rach_preable_trans_max,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_mac_rach_preable_trans_max failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                return ret_val;
			}
			/* Coverity ID : 72262 Fix Start*/
			oam_memset(p_fap_ran_mac_rach_preable_trans_max,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72262 Fix End*/
			oam_memcpy(&p_fap_ran_mac_rach_preable_trans_max->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_mac_rach_preable_trans_max->global_cell_id,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id,sizeof(p_fap_ran_mac_rach_preable_trans_max->global_cell_id));
			oam_memcpy(&p_fap_ran_mac_rach_preable_trans_max->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_preable_trans_max->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_mac_rach_preable_trans_max->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_mac_rach_preable_trans_max->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_mac_rach_preable_trans_max->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			/* coverity 41311 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.mac_layer_params.mac_layer_param_rach.preamble_trans_max = p_fap_ran_mac_rach_preable_trans_max->ran_info.mac_layer_params.mac_layer_param_rach.preamble_trans_max = (rrm_oam_preamble_trans_max_et)pre_tx_max;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(
					p_fap_ran_mac_rach_preable_trans_max,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72262 Fix Start*/
			oam_mem_free(p_fap_ran_mac_rach_preable_trans_max, &error_code);
			/* Coverity ID : 72262 Fix End*/
			break;
		case OAM_FAP_CONFIG_RAN_RRC_TIMER_N310_REQ:
			n310_timer = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_fap_ran_rrctimer_n310,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_rrctimer_n310 failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                return ret_val;
			}
			/* Coverity ID : 72263 Fix Start*/
			oam_memset(p_fap_ran_rrctimer_n310,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72263 Fix Start*/
			oam_memcpy(&p_fap_ran_rrctimer_n310->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_rrctimer_n310->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_preable_trans_max->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_rrctimer_n310->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_rrctimer_n310->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_rrctimer_n310->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			/* coverity 41312 52803*/
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.rrc_timers_and_constants.rrc_constants.n310 = p_fap_ran_rrctimer_n310->ran_info.rrc_timers_and_constants.rrc_constants.n310 = (rrm_oam_out_of_sync_n310_et)n310_timer;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_fap_ran_rrctimer_n310,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72263 Fix Start*/
			oam_mem_free(p_fap_ran_rrctimer_n310,&error_code);
			/* Coverity ID : 72263 Fix End*/ 
			break;
		case OAM_FAP_CONFIG_RAN_RRC_TIMER_N311_REQ:
			n311_timer = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_fap_ran_rrctimer_n311,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_rrctimer_n311 failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                return ret_val;
			}
			/* Coverity ID 72264 Fix Start*/
			oam_memset(p_fap_ran_rrctimer_n311, OAM_ZERO, sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID 72264 Fix End*/
			oam_memcpy(&p_fap_ran_rrctimer_n311->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_rrctimer_n311->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_preable_trans_max->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_rrctimer_n311->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_rrctimer_n311->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_rrctimer_n311->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			/* coverity 41313 52804 52775*/
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.rrc_timers_and_constants.rrc_constants.n311 = p_fap_ran_rrctimer_n311->ran_info.rrc_timers_and_constants.rrc_constants.n311 = (rrm_oam_in_sync_n311_et)n311_timer;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_fap_ran_rrctimer_n311,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
            /* Coverity CID 72264 Fix Start */
                    oam_mem_free((void *)(p_fap_ran_rrctimer_n311), &error_code);
                    /* Coverity CID 72264 Fix Start */
			break;
		case OAM_FAP_CONFIG_RAN_RRC_TIMER_T300_REQ:
			t300_timer = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
            /*Coverity fix start1 : 83319 */
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
                                (void*)&p_fap_ran_rrctimer_t300,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_rrctimer_t300 failed"
                        " with Error Code:%d",
						error_code);
				ret_val = OAM_FAILURE; 
                return ret_val;
			}
            oam_memset(p_fap_ran_rrctimer_t300,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
            /*Coverity fix End : 83319 */

			oam_memcpy(&p_fap_ran_rrctimer_t300->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_rrctimer_t300->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_preable_trans_max->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_rrctimer_t300->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_rrctimer_t300->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_rrctimer_t300->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			/* coverity 41314 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.rrc_timers_and_constants.rrc_timers.t300 = p_fap_ran_rrctimer_t300->ran_info.rrc_timers_and_constants.rrc_timers.t300 = (rrm_oam_timer_300_301_et)t300_timer;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_fap_ran_rrctimer_t300,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
            /* Coverity CID 85220 Fix Start */
            oam_mem_free(p_fap_ran_rrctimer_t300,&error_code);
            /* Coverity CID 85220 Fix End */
			break;
		case OAM_FAP_CONFIG_RAN_RRC_TIMER_T301_REQ:
			t301_timer = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_fap_ran_rrctimer_t301,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_rrctimer_t301 failed"
                        " with Error Code:%d",
						error_code);
				ret_val = OAM_FAILURE; 
                return ret_val;
			}
			/* Coverity ID : 72265 Fix Start*/
			oam_memset(p_fap_ran_rrctimer_t301,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72265 Fix End*/
			oam_memcpy(&p_fap_ran_rrctimer_t301->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_rrctimer_t301->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_preable_trans_max->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_rrctimer_t301->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_rrctimer_t301->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_rrctimer_t301->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			/* coverity 41315*/
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.rrc_timers_and_constants.rrc_timers.t301 = p_fap_ran_rrctimer_t301->ran_info.rrc_timers_and_constants.rrc_timers.t301 = (rrm_oam_timer_300_301_et)t301_timer;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_fap_ran_rrctimer_t301,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72265 Fix Start*/
			oam_mem_free(p_fap_ran_rrctimer_t301,&error_code);
			/* Coverity ID : 72265 Fix End*/ 
			break;
		case OAM_FAP_CONFIG_RAN_RRC_TIMER_T310_REQ:
			t310_timer = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_fap_ran_rrctimer_t310,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_rrctimer_t310 failed"
                        " with Error Code:%d",
						error_code);
				ret_val = OAM_FAILURE; 
                return ret_val;
			}
			/* Coverity ID : 72266 Fix Start*/
			oam_memset(p_fap_ran_rrctimer_t310,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72266 Fix End*/
			oam_memcpy(&p_fap_ran_rrctimer_t310->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_rrctimer_t310->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_preable_trans_max->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_rrctimer_t310->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_rrctimer_t310->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_rrctimer_t310->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			/* coverity 41316 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.rrc_timers_and_constants.rrc_timers.t310 = p_fap_ran_rrctimer_t310->ran_info.rrc_timers_and_constants.rrc_timers.t310 = (rrm_oam_timer_310_et)t310_timer;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_fap_ran_rrctimer_t310,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72266 Fix Start*/
			oam_mem_free(p_fap_ran_rrctimer_t310,&error_code);
			/* Coverity ID : 72266 Fix End*/ 
			break;
		case OAM_FAP_CONFIG_RAN_RRC_TIMER_T311_REQ:
			/* Coverity Fix: Vivek */
			if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
						(void*)&p_fap_ran_rrctimer_t311,
						&error_code)) {
				OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_fap_ran_rrctimer_t311 failed"
                        " with Error Code:%d",
                        error_code);
				ret_val = OAM_FAILURE; 
                return ret_val;
			}
			t311_timer = ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
			/* Coverity ID : 72267 Fix Start*/
			oam_memset(p_fap_ran_rrctimer_t311,OAM_ZERO,sizeof(oam_rrm_cell_reconfig_req_t));
			/* Coverity ID : 72267 Fix End*/
			oam_memcpy(&p_fap_ran_rrctimer_t311->global_cell_id, &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id, sizeof(rrm_oam_eutran_global_cell_id_t));
			oam_memcpy(&p_fap_ran_rrctimer_t311->cell_access_restriction_params,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.cell_access_restriction_params,sizeof(p_fap_ran_mac_rach_preable_trans_max->cell_access_restriction_params));
			oam_memcpy(&p_fap_ran_rrctimer_t311->ran_info,&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info,sizeof(p_fap_ran_rrctimer_t311->ran_info));
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].bitmask |= p_fap_ran_rrctimer_t311->bitmask = RRM_OAM_RAN_INFO_PRESENT;
			/* coverity 41317 */
			oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.rrc_timers_and_constants.rrc_timers.t311 = p_fap_ran_rrctimer_t311->ran_info.rrc_timers_and_constants.rrc_timers.t311 = (rrm_oam_timer_311_et)t311_timer;
			oam_maintain_tcb(trans_id,OAM_TRANS_RRM,msg_len,p_api_buf);
			oam_rrm_send_rrm_oam_cell_reconfig_req(p_fap_ran_rrctimer_t311,
					src_module_id,
					RRM_MODULE_ID,
					trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
			/* Coverity ID : 72267 Fix Start*/
			oam_mem_free(p_fap_ran_rrctimer_t311,&error_code);
			/* Coverity ID : 72267 Fix End*/ 
			break;
		case OAM_SET_LOG_LEVEL_GTPU_REQ:
             loglevel =  ((UInt32)*((UInt8*)p_api_buf + OAM_MGMT_INTF_HEADER_SIZE));
             log_level_gtpu.logLevel =  loglevel;
             if(OAM_SUCCESS == oam_egtpu_set_log_level_req(&log_level_gtpu,src_module_id,trans_id,&error_code))
                 oam_send_success_failure_resp(OAM_SUCCESS,trans_id,dest_id,&error_code);
             else
                 oam_send_success_failure_resp(OAM_FAILURE,trans_id,dest_id,&error_code);
             break;

		case OAM_GET_LOG_LEVEL_GTPU_REQ:
			oam_maintain_tcb(trans_id,OAM_TRANS_EGTPU,msg_len,p_api_buf);
            oam_egtpu_get_log_level_req(OAM_NULL,src_module_id,trans_id,&error_code);
			break;

		case OAM_NOTIFICATION_IND_RESP :

			if((OAM_FALSE == oam_prov_req.system_status.tr069_configured) ||
					(OAM_ZERO != oam_prov_req.system_status.event_ongoing))  
			{
				OAM_LOG(OAM,OAM_WARNING,"TR069 Agent not configured yet");   
			} 
			else if(OAM_SUCCESS == oam_handle_notification_ind_resp(p_api_buf))
			{
				OAM_LOG(OAM,OAM_DETAILED," Notification response handled succesfully"); 
			} 
			else
			{
				OAM_LOG(OAM,OAM_WARNING,"notifictaion ack failed");
				return OAM_FAILURE;
			}

			break;

		case OAM_DELETE_OBJECT_REQ:
			ret_val = oam_delete_object_api_handler(p_api_buf, &error_code);

			if(OAM_SUCCESS == ret_val) {
				OAM_LOG(OAM, OAM_DETAILED, "Object deleted Successfully"); 
				usr_resp = OAM_RESULT_SUCCESS;
				usr_err_code = OAM_ZERO;
				str_err_len = 0;
			} 
			else {
				oam_get_err_string_n_err_code(error_code, &usr_err_code,
						&str_err);
				usr_resp = OAM_RESULT_FAILURE;
				str_err_len = oam_strlen(str_err) + 1;
			}

			if ((OAM_CM_ST_ACTIVE !=  p_cm_cntxt->state) ||
					(OAM_FAILURE == ret_val)) {
				oam_construct_n_send_deleteobject_resp_to_usr(usr_resp,   
						usr_err_code,
						(UInt8*)str_err,
						str_err_len,
						OAM_VERSION_ID,
						OAM_MODULE_ID,
						dest_id,
						trans_id,
						OAM_ZERO, OAM_ZERO,
						&error_code);
			}
			break;

		case OAM_ADD_OBJECT_REQ:
			ret_val = oam_add_object_api_handler(p_api_buf, &error_code,
					&inst_num);
			if(OAM_SUCCESS == ret_val) {
				OAM_LOG(OAM, OAM_DETAILED,
						"oam_add_object_api_handler success");

				/* SPR 17051 FIX : code removed */
                /*  coverity 94798 fix start */
				/* code removed */
                /*  coverity 94798 fix end */
				usr_err_code = OAM_ZERO;

                /*  coverity 94833 fix start */
				/* code removed */
                /*  coverity 94833 fix end */
			}
			else {
				oam_get_err_string_n_err_code(error_code, &usr_err_code,
						&str_err);
                /*  coverity 94839 fix start */
				/* code removed */
                /*  coverity 94839 fix end */

                /*  coverity 94814 fix start */
				/* code removed */
                /*  coverity 94814 fix end */

				OAM_LOG(OAM, OAM_WARNING, "oam_add_object_api_handler failed");
			}

			/* SPR 17051 FIX : code removed */

			break;
	}
    /*+- coverity_87910_fix*/
	return ret_val;
}

#ifdef OAM_SON_ENABLE
/*****************************************************************************
 * Function Name  : oam_calc_total_num_param_to_send 
 * Description    : This function checks if the incoming NR_RETRIEVE_RESP is
 *                * too large to send to user in GPV response
 * Inputs         : p_resp
 *
 * Outputs        : NONE
 * Returns        : returns total number of parameters to send in GPV resp
 *****************************************************************************/
UInt16 oam_calc_total_num_param_to_send(oam_son_nr_retrieve_resp_t *p_resp)
{
	OAM_FUN_ENTRY_TRACE();
	UInt16 total_params = OAM_ZERO;
	UInt16 i = OAM_ZERO;

	if(OAM_SON_NR_CELL_INTRA_RETREIVE_ONGOING &
			SON_PROV_REQ.retreive_ongoing) {
		for(i = OAM_ZERO; i < p_resp->nr_list.intra_rat_nr_list_size; ++i) {
			/* PLMNID and Cell-Identity are always present */
			total_params += OAM_TWO;
#define INTRA_RAT_BITMASK(s)  p_resp->nr_list.intra_rat_nr_list[s].bitmask  

			if(SON_PCI_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* PCI is present */
				++total_params;
			}

			if(SON_CELL_OFFSET_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* cell_specific_offset is present */
				++total_params;
			}

			if(SON_TAC_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* TAC is present */
				++total_params;
			}

			if(SON_PLMN_ID_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* PLMN ID is present */
				total_params += OAM_ONE +
					p_resp->nr_list.intra_rat_nr_list[i].num_plmn_id;
			}

			if(SON_INTRA_CSG_ID_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* CSG_IDENTITY is present */
				++total_params;
			}

			if(SON_EARFCN_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* EARFcn is present */
				++total_params;
			}

			if(SON_RSRP_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* RSRP is present */
				++total_params;
			}

			if(SON_RSRQ_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* RSRQ is present */
				++total_params;
			}

			if(SON_ENABLE_NR_STATUS_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* NR_STATUS is present */
				++total_params;
			}

			if(SON_ENABLE_HO_STATUS_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* HO_STATUS is present */
				++total_params;
			}

			if(SON_ENABLE_X2_STATUS_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* X2_STATUS is present */
				++total_params;
			}

			if(SON_EUTRAN_NR_HO_STATS_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* handovers_attempted is present */
				++total_params;

				/* Populate handovers_succesful If present */
				++total_params;

				/* Populate handovers_failed If present */
				++total_params;
			}

			if(SON_SUSPECT_PCI_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* Populate suspected_pci If present */
				++total_params;
			}

			if(SON_ACCESS_MODE_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* Populate access mode If present */
				++total_params;
			}

			if(SON_BROADCAST_STATUS_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* Populate access mode If present */
				++total_params;
			}

			if(SON_CM_CELL_OFFSET_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* Populate access mode If present */
				++total_params;
			}

			if(SON_UL_EARFCN_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* Populate UL_EARFCN if present */
				++total_params;
			}

			if(SON_PRACH_CONFIGURATION_PRESENT & INTRA_RAT_BITMASK(i)) {
				/* Populate Prach_Configuration ParametersIf present */
				total_params += OAM_FOUR;

				if(SON_PRACH_CONFIG_INDEX_PRESENT & INTRA_RAT_BITMASK(i)) {
					/* Populate Prach_Config_Index If present */
					++total_params;
				}
			}

		}
	}
	else if(OAM_SON_NR_CELL_INTER_RETREIVE_ONGOING &
			SON_PROV_REQ.retreive_ongoing) {
		for(i = 0; i < p_resp->nr_list.inter_rat_nr_list_size; ++i) {
			if(p_resp->nr_list.inter_rat_nr_list[i].bitmask &
					SON_INTER_UTRAN_NEIGHBOR) {
				/* PLMNID and Cell-Identity(CID + RNCID) are always present */
				total_params += OAM_THREE;

#define UTRAN_BITMASK(s)  p_resp->nr_list.inter_rat_nr_list[s].\
				utran_neighbor.bitmask  

				if(SON_UTRAN_PCI_PRESENT & UTRAN_BITMASK(i)) {
					/* PCI is present */
					++total_params;
				}

				if(SON_UTRAN_CSO_PRESENT & UTRAN_BITMASK(i)) {
					/* CELL_SPECIFIC_OFFSET is present */
					++total_params;
				}

				if(SON_UTRAN_LAC_PRESENT & UTRAN_BITMASK(i)) {
					/* LAC is present */
					++total_params;
				}

				if(SON_UTRAN_RAC_PRESENT & UTRAN_BITMASK(i)) {
					/* RAC is present */
					++total_params;
				}

				if(SON_UTRAN_PLMN_ID_PRESENT & UTRAN_BITMASK(i)) {
					/* PLMN-IDs are present */
					total_params += OAM_ONE +
						p_resp->nr_list.inter_rat_nr_list[i].
						utran_neighbor.num_plmn_id;
				}

				if(SON_UTRAN_CSG_ID_PRESENT & UTRAN_BITMASK(i)) {
					/* CSG_IDENTITY is present */
					++total_params;
				}

				if(SON_UTRAN_UARFCN_PRESENT & UTRAN_BITMASK(i)) {
					/* UARFCN is present */
					++total_params;
				}

				if(SON_UTRAN_RSCP_PRESENT & UTRAN_BITMASK(i)) {
					/* RSCP is present */
					++total_params;
				}

				if(SON_UTRAN_ECNO_PRESENT & UTRAN_BITMASK(i)) {
					/* ECNO is present */
					++total_params;
				}

				if(SON_UTRAN_ENABLE_NR_STATUS_PRESENT & UTRAN_BITMASK(i)) {
					/* NR_STATUS is present */
					++total_params;
				}

				if(SON_UTRAN_ENABLE_HO_STATUS_PRESENT & UTRAN_BITMASK(i)) {
					/* HO_STATUS is present */
					/* HO_ATTEMPTED, HO_SUCCESSFULL, HO_FAILED */
					total_params += OAM_THREE;
				}

				if(SON_UTRAN_ACCESS_MODE_PRESENT & UTRAN_BITMASK(i)) {
					/* access mode is present */
					++total_params;
				}
			}
		}/* End of for loop */
	}

	OAM_FUN_EXIT_TRACE();
	return total_params;
}
/******************************************************************************
 * Function Name  : oam_populate_n_send_nr_retrieve_resp_to_usr 
 * Inputs         : p_resp
 *                  p_err 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 *******************************************************************************/
oam_return_et
oam_populate_n_send_nr_retrieve_resp_to_usr
(
 oam_son_nr_retrieve_resp_t      *p_resp,
 UInt16                          dst_id,
 UInt16                          trans_id,
 oam_error_code_et               *p_err
 )
{
	OAM_FUN_ENTRY_TRACE();
	Char8 parent_name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
	UInt8 i= OAM_ZERO;
	UInt8 j= OAM_ZERO;
	UInt8 k= OAM_ZERO;
	Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	UInt8 num_of_param = OAM_ZERO;
	UInt8 start_index = OAM_ONE; 
	UInt8 end_index = OAM_ZERO;
	Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
	UInt32 value = OAM_ZERO;
	UInt16 parent_name_len = OAM_ZERO; 
	oam_return_et retVal = OAM_FAILURE;
	UInt16 total_params = OAM_ZERO;
	UInt64 plmnid = OAM_ZERO;
	UInt32 cid = OAM_ZERO;
	SInt32 rncid = OAM_ZERO;
	UInt16 out_cid = OAM_ZERO;
	UInt16 out_rncid = OAM_ZERO;
	SInt32 instance = OAM_ZERO;
	UInt64 plmnid_atoi = OAM_ZERO;
	xmlNode *temp = OAM_NULL;
	xmlNode *p_xml_node = OAM_NULL;
	xmlNode *p_xml_node1 = OAM_NULL;
	xmlNode *p_xml_node2 = OAM_NULL;
	xmlChar *p_param_val = OAM_NULL;
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}



	total_params =
		oam_calc_total_num_param_to_send(p_resp);
	if(total_params > MAX_NUM_PARAMS_ALLOWED_GPV_RESP) {
		Char8 *err_str = "Too many parameters in the response";
		oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
				OAM_ERR_RESOURCES_EXCEEDED,
				OAM_VERSION_ID, OAM_MODULE_ID,
				dst_id, trans_id,
				OAM_ZERO, OAM_ZERO,
				err_str, p_err);
		OAM_FUN_EXIT_TRACE();
		return retVal;
	}

	if(OAM_SON_NR_CELL_INTRA_RETREIVE_ONGOING &
			SON_PROV_REQ.retreive_ongoing) {
		parent_name_len =
        /* spr_21013_fix_start */
			oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig"
					".LTE.RAN.NeighborList.LTECell") + OAM_ONE;
		oam_strncpy(parent_name, "InternetGatewayDevice.Services.FAPService."
        /* spr_21013_fix_end */
				"CellConfig.LTE.RAN.NeighborList.LTECell",
				parent_name_len);

		end_index = p_resp->nr_list.intra_rat_nr_list_size;

		OAM_LOG(OAM, OAM_DETAILED," total number of params %d ",end_index);

		for(i = OAM_ZERO; i < end_index; ++i) {
			/* Populate PLMN-ID */
			oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
			oam_generate_plmnid(temp_param, &(p_resp->nr_list.
						intra_rat_nr_list[i].nbr_cgi.plmn_id));
			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[j], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				OAM_FUN_EXIT_TRACE(); 
				return retVal;
			}

			oam_memset(param_list[j], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
					"PLMNID=%s", temp_param); 

			plmnid_atoi = oam_atoi((Char8*)temp_param);

			/* Populate Cell-Identity */
			/* SPR 11675 FIX START */
			retVal = oam_decode_bit_stream_into_eutran_cellidentity(
					p_resp->nr_list.intra_rat_nr_list[i].nbr_cgi.
					cell_identity, &cid);
			/* SPR 11675 FIX END */

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[j], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				OAM_FUN_EXIT_TRACE();
				return retVal;
			}
			oam_memset(param_list[j], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
					"CID=%d", cid);
			value =cid;

			OAM_LOG(OAM, OAM_DETAILED," plmnid %s cid %d",temp_param ,cid);

			/*  Instance id match code starts here */
			/* Spr Fix 11237 Start */	
            /* spr_21013_fix_start */
			temp = xml_struct_tr196_g.FAPService[cell_config_idx].CellConfig.LTECell[OAM_ZERO];
            /* spr_21013_fix_end */
			/* Spr Fix 11237 End */	
			while(OAM_NULL != temp) {
				p_xml_node = oam_xml_find_tag(temp->children,
						(xmlChar*)"PLMNID");
				if(p_xml_node != OAM_NULL) {	
					p_param_val = xmlNodeGetContent(p_xml_node);
					plmnid  = oam_atoi((Char8*)p_param_val);
					if(plmnid_atoi == plmnid) {

						p_xml_node1 = oam_xml_find_tag(temp->children,
								(xmlChar*)"CID");
						if(p_xml_node1 != OAM_NULL) {	
							p_param_val = xmlNodeGetContent(p_xml_node1);
							cid  = oam_atoi((Char8*)p_param_val);

							if (value == cid) {

								p_xml_node2 = oam_xml_find_tag(temp->children,
										(xmlChar*)"X_VENDOR_INSTANCE_ID");
								if(p_xml_node1 != OAM_NULL) {	
									p_param_val = xmlNodeGetContent(p_xml_node2);
									instance  = oam_atoi((Char8*)p_param_val);
									OAM_LOG(OAM, OAM_DETAILED,"IN LTE CELL Instance id corresponding to plmn %s cid %d is --: %d",temp_param ,value, instance);
									break;
								}
							}
						}
					}
				}
				/* Move to next instance of object */
				temp = (temp)->next;
			}


			/* Populate PCI If present */
			if(SON_PCI_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"PhyCellID=%d",
						p_resp->nr_list.intra_rat_nr_list[i].pci);
			}

			if(SON_CELL_OFFSET_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate cell_specific_offset If present */

				oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
						"%d", p_resp->nr_list.intra_rat_nr_list[i].
						cell_specific_offset);

				oam_search_integer_to_interger_for_get(temp_param,
						RAN_NeighborList_LTECell_QOffset[OAM_ZERO], 31);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"QOffset=%s", temp_param);
			}

			if(SON_TAC_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate tac If present */
				/*SPR 11315 start*/
				/*SPR 11315 Fix*/
				oam_cmn_convert_byte_string_to_short(
						p_resp->nr_list.intra_rat_nr_list[i].tac,
						&value,
						OAM_MAX_SHORT_INT_BITSTRING_SIZE - OAM_TAC_BIT_STRING_SIZE);
				/*SPR 11315 Fix*/

				/*SPR 11315 end*/
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_TAC=%d", value);
			}

			if(SON_PLMN_ID_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate PLMN ID count If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_NUM_PLMN_ID=%d", p_resp->nr_list.
						intra_rat_nr_list[i].num_plmn_id);

				/* Populate PLMN ID List If present */

				for(k = OAM_ZERO;
						k < p_resp->nr_list.intra_rat_nr_list[i].num_plmn_id;
						++k) {
					oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
					oam_generate_plmnid(temp_param,
							&(p_resp->nr_list.intra_rat_nr_list[i].plmn_id[k]));

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}
					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_PLMN_ID[%d]=%s", k + OAM_ONE,
							temp_param);
				}
			}

			if(SON_INTRA_CSG_ID_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate csg_identity If present */
				oam_cmn_convert_csgid_to_integer(
						p_resp->nr_list.intra_rat_nr_list[i].csg_identity,
						OAM_FOUR, &value);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_CSG_IDENTITY=%d", value);
			}

			if(SON_EARFCN_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate earfcn If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"EUTRACarrierARFCN=%d",
						p_resp->nr_list.intra_rat_nr_list[i].earfcn);
			}

			if(SON_RSRP_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate rsrp If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_RSRP=%d",
						p_resp->nr_list.intra_rat_nr_list[i].rsrp);
			}

			if(SON_RSRQ_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate rsrq If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_RSRQ=%d",
						p_resp->nr_list.intra_rat_nr_list[i].rsrq);
			}

			if(SON_ENABLE_NR_STATUS_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate nr_status If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++], MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_NR_STATUS=%d",
						p_resp->nr_list.intra_rat_nr_list[i].nr_status);
			}

			if(SON_ENABLE_HO_STATUS_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate ho_status If present */
				oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
						"%d", p_resp->nr_list.intra_rat_nr_list[i].ho_status);
				oam_search_integer_to_interger_for_get(temp_param,
						NR_Blacklisted[OAM_ZERO], 2);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"Blacklisted=%s", temp_param);
			}

			if(SON_ENABLE_X2_STATUS_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate x2_status If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_X2_STATUS=%d", p_resp->nr_list.
						intra_rat_nr_list[i].x2_status);

			}

			if(SON_EUTRAN_NR_HO_STATS_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate handovers_attempted If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HANDOVERS_ATTEMPTED=%d",
						p_resp->nr_list.intra_rat_nr_list[i].
						handover_stats.handovers_attempted);

				/* Populate handovers_succesful If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_HANDOVERS_SUCCESFUL=%d",
						p_resp->nr_list.intra_rat_nr_list[i].
						handover_stats.handovers_succesful);

				/* Populate handovers_failed If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_HANDOVERS_FAILED=%d",
						p_resp->nr_list.intra_rat_nr_list[i].
						handover_stats.handovers_failed);
			}

			if(SON_SUSPECT_PCI_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate suspected_pci If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_SUSPECTED_PCI=%d", p_resp->nr_list.
						intra_rat_nr_list[i].suspected_pci);
			}


			if(SON_CM_CELL_OFFSET_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate CIO If present */
				oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH,
						"%d", p_resp->nr_list.intra_rat_nr_list[i].
						cm_cell_specific_offset);

				oam_search_integer_to_interger_for_get(temp_param,
						RAN_NeighborList_LTECell_CIO[OAM_ZERO], 31);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"CIO=%s", temp_param);
			}

			if(SON_BROADCAST_STATUS_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate broadcast status If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_BROADCAST_STATUS=%s", p_resp->nr_list.
						intra_rat_nr_list[i].broadcast_status ?
						"Enabled" : "Disabled");
			}

			if(SON_ACCESS_MODE_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate access mode If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_ACCESS_MODE=%d", p_resp->nr_list.
						intra_rat_nr_list[i].access_mode);
			}

			if(SON_PRACH_CONFIGURATION_PRESENT & p_resp->nr_list.
					intra_rat_nr_list[i].bitmask) {
				/* Populate Prach_Configuration ParameterIf present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_PRACH_ROOT_SEQUENCE_INDEX=%d", p_resp->nr_list.
						intra_rat_nr_list[i].prach_config.root_sequence_index);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_PRACH_ZERO_CORRELATION_ZONE_CONFIG=%d", p_resp->nr_list.
						intra_rat_nr_list[i].prach_config.zero_correlation_zone_config);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_PRACH_HIGH_SPEED_FLAG=%d", p_resp->nr_list.
						intra_rat_nr_list[i].prach_config.high_speed_flag);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[j], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_PRACH_FREQUENCY_OFFSET=%d", p_resp->nr_list.
						intra_rat_nr_list[i].prach_config.prach_frequency_offset);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				if(SON_PRACH_CONFIG_INDEX_PRESENT & p_resp->nr_list.
						intra_rat_nr_list[i].prach_config.bitmask){
					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_PRACH_CONFIGURATION_INDEX=%d", p_resp->nr_list.
							intra_rat_nr_list[i].prach_config.prach_configuration_index);

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE();
						return retVal;
					}
				}

			}

			/* Changes for returning intance id corresponding to the neighors  */	

			if(plmnid_atoi && instance)
			{
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_INSTANCE_ID=%d",instance); 
			}

		}

		/* Reset value */
		SON_PROV_REQ.retreive_ongoing &=
			~(OAM_SON_NR_CELL_INTRA_RETREIVE_ONGOING);

	}
	else if(OAM_SON_NR_CELL_INTER_RETREIVE_ONGOING &
			SON_PROV_REQ.retreive_ongoing) {
		parent_name_len =
        /* spr_21013_fix_start */
			oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig"
					".LTE.RAN.NeighborList.InterRATCell.UMTS") + OAM_ONE;
		oam_strncpy(parent_name, "InternetGatewayDevice.Services.FAPService."
        /* spr_21013_fix_end */
				"CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS",
				parent_name_len);

		end_index = OAM_ZERO;

		for(i = OAM_ZERO; i < p_resp->nr_list.inter_rat_nr_list_size; ++i) {
			if(p_resp->nr_list.inter_rat_nr_list[i].bitmask &
					SON_INTER_UTRAN_NEIGHBOR) {
				/* Populate PLMN-ID */
				oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
				oam_generate_plmnid(temp_param, &(p_resp->nr_list.
							inter_rat_nr_list[i].utran_neighbor.nbr_cgi.plmn_id));

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[j], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"PLMNID=%s", temp_param); 

				plmnid_atoi = oam_atoi((Char8*)temp_param);

				/* RT SPR 8627 FIX START */
				oam_extract_cid_from_utran_cell_identity(&out_cid,
						p_resp->nr_list.
						inter_rat_nr_list[i].
						utran_neighbor.nbr_cgi.
						cell_identity);
				/* RT SPR 8627 FIX END */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[j], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"CID=%d", out_cid);

				/* RT SPR 8627 FIX START */
				oam_extract_rncid_from_utran_cell_identity(&out_rncid,
						p_resp->nr_list.
						inter_rat_nr_list[i].
						utran_neighbor.nbr_cgi.
						cell_identity);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[j], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[j], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
						"RNCID=%d", out_rncid);

				/* Maching the instance number corresponding to the neighbors */
                /* spr_21013_fix_start */
				temp = xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[OAM_ZERO];
                /* spr_21013_fix_end */
				while(OAM_NULL != temp) {
					p_xml_node = oam_xml_find_tag(temp->children,
							(xmlChar*)"PLMNID");
					if(p_xml_node != OAM_NULL) 
					{	
						p_param_val = xmlNodeGetContent(p_xml_node);
						plmnid  = oam_atoi((Char8*)p_param_val);
						if(plmnid_atoi == plmnid) 
						{
							p_xml_node1 = oam_xml_find_tag(temp->children,
									(xmlChar*)"CID");
							if(p_xml_node1 != OAM_NULL) 
							{	
								p_param_val = xmlNodeGetContent(p_xml_node1);
								cid  = oam_atoi((Char8*)p_param_val);
								if (out_cid == cid) 
								{
									/* RT SPR 8627 FIX START */
									p_xml_node1 =
										oam_xml_find_tag(temp->children,
												(xmlChar*)"RNCID");
									if(p_xml_node1) 
									{   
										p_param_val =
											xmlNodeGetContent(p_xml_node1);

										rncid = oam_atoi((Char8*)p_param_val);
										if(out_rncid == rncid) 
										{
											/* RT SPR 8627 FIX END */
											p_xml_node2 = oam_xml_find_tag(temp->children,
													(xmlChar*)"X_VENDOR_INSTANCE_ID");
											if(p_xml_node1 != OAM_NULL) 
											{   
												p_param_val = xmlNodeGetContent(p_xml_node2);
												instance  = oam_atoi((Char8*)p_param_val);
												OAM_LOG(OAM, OAM_DETAILED,"In UMTS Instance id corresponding to plmn %s cid %d is --: %d",temp_param ,value, instance);
												break;
											}
											/* RT SPR 8627 FIX START */
										}
										/* RT SPR 8627 FIX END */
									}
								}
							}
						}
					}
					/* Move to next instance of object */
					temp = (temp)->next;
				}

				if(SON_UTRAN_PCI_PRESENT & p_resp->nr_list.inter_rat_nr_list[i].
						utran_neighbor.bitmask) {
					/* Populate PCI If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}
					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					/* RT SPR 8627 FIX START */
					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
							"PCPICHScramblingCode=%d",
							p_resp->nr_list.inter_rat_nr_list[i].
							utran_neighbor.pci.pci_fdd);
					/* RT SPR 8627 FIX END */
				}

				if(SON_UTRAN_CSO_PRESENT & p_resp->nr_list.inter_rat_nr_list[i].
						utran_neighbor.bitmask) {
					/* Populate cell_specific_offset If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}
					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_CELL_SPECIFIC_OFFSET=%d",
							p_resp->nr_list.inter_rat_nr_list[i].utran_neighbor.
							cell_specific_offset);
				}

				if(SON_UTRAN_LAC_PRESENT & p_resp->nr_list.inter_rat_nr_list[i].
						utran_neighbor.bitmask) {
					/* Populate lac If present */
                    /*SPR 22398 Fix Start*/
					oam_cmn_convert_bytes_to_integer_for_LAC(
							p_resp->nr_list.inter_rat_nr_list[i].utran_neighbor.lac,
							&value);
                    /*SPR 22398 Fix End*/

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}
					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
							"LAC=%d", value);
				}

				if(SON_UTRAN_RAC_PRESENT & p_resp->nr_list.inter_rat_nr_list[i].
						utran_neighbor.bitmask) {
					/* Populate rac If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}
					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
							"RAC=%d", p_resp->nr_list.inter_rat_nr_list[i].
							utran_neighbor.rac);
				}

				if(SON_UTRAN_PLMN_ID_PRESENT & p_resp->nr_list.
						inter_rat_nr_list[i].utran_neighbor.bitmask) {
					/* Populate PLMN ID If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}


					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_NUM_PLMN_ID=%d", p_resp->nr_list.
							inter_rat_nr_list[i].utran_neighbor.num_plmn_id);


					/* Populate PLMN ID List If present */
					for(k = OAM_ZERO;
							k < p_resp->nr_list.inter_rat_nr_list[i].utran_neighbor.
							num_plmn_id; ++k) {
						oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
						oam_generate_plmnid(temp_param,
								&(p_resp->nr_list.inter_rat_nr_list[i].
									utran_neighbor.plmn_id[k]));

						retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
								(void**)&param_list[j], p_err);
						if(OAM_FAILURE == retVal) {
							OAM_LOG(OAM, OAM_ERROR,
									"Memory allocation to param_list failed"
									" with Error Code:%d",
									*p_err);
							OAM_FUN_EXIT_TRACE(); 
							return retVal;
						}
						oam_memset(param_list[j], OAM_ZERO,
								MAX_PARAMETER_NAME_LENGTH);

						oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
								"X_VENDOR_PLMN_ID[%d]=%s", k + OAM_ONE,
								temp_param);
					}
				}

				if(SON_UTRAN_CSG_ID_PRESENT & p_resp->nr_list.
						inter_rat_nr_list[i].utran_neighbor.bitmask) {
					/* Populate csg_identity If present */
					oam_cmn_convert_csgid_to_integer(p_resp->nr_list.
							inter_rat_nr_list[i].utran_neighbor.csg_identity,
							OAM_FOUR, &value);

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_CSG_IDENTITY=%d", value);
				}

				if(SON_UTRAN_UARFCN_PRESENT & p_resp->nr_list.
						inter_rat_nr_list[i].utran_neighbor.bitmask) {
					/* Populate uarfcn If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++], MAX_PARAMETER_NAME_LENGTH,
							"UARFCNDL=%d", p_resp->nr_list.inter_rat_nr_list[i].
							utran_neighbor.uarfcn);
				}

				if(SON_UTRAN_RSCP_PRESENT & p_resp->nr_list.inter_rat_nr_list[i].
						utran_neighbor.bitmask) {
					/* Populate rscp If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_RSCP=%d", p_resp->nr_list.
							inter_rat_nr_list[i].utran_neighbor.rscp);
				}

				if(SON_UTRAN_ECNO_PRESENT & p_resp->nr_list.inter_rat_nr_list[i].
						utran_neighbor.bitmask) {
					/* Populate ecno If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_ECNO=%d", p_resp->nr_list.
							inter_rat_nr_list[i].utran_neighbor.ecno);
				}

				if(SON_UTRAN_ENABLE_NR_STATUS_PRESENT & p_resp->nr_list.
						inter_rat_nr_list[i].utran_neighbor.bitmask) {
					/* Populate nr_status If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);
					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_NR_STATUS=%d", p_resp->nr_list.
							inter_rat_nr_list[i].utran_neighbor.nr_status);
				}

				if(SON_UTRAN_ENABLE_HO_STATUS_PRESENT & p_resp->nr_list.
						inter_rat_nr_list[i].utran_neighbor.bitmask) {
					/* Populate ho_status If present */
					oam_memset(temp_param , OAM_ZERO , MAX_PARAMETER_NAME_LENGTH);
					oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
							"%d", p_resp->nr_list.inter_rat_nr_list[i].
							utran_neighbor.ho_status); 
					/* SPR-11757 removed code */ 
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_HO_STATUS=%s", temp_param);
				}

				if(SON_UTRAN_NR_HO_STATS_PRESENT & p_resp->nr_list.
						inter_rat_nr_list[i].utran_neighbor.bitmask) {
					/* Populate handovers_attempted If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_HANDOVERS_ATTEMPTED=%d",
							p_resp->nr_list.inter_rat_nr_list[i].utran_neighbor.
							handover_stats.handovers_attempted);

					/* Populate handovers_succesful If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}


					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_HANDOVERS_SUCCESFUL=%d",
							p_resp->nr_list.inter_rat_nr_list[i].utran_neighbor.
							handover_stats.handovers_succesful);

					/* Populate handovers_failed If present */
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}


					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++], MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_HANDOVERS_FAILED=%d",
							p_resp->nr_list.inter_rat_nr_list[i].utran_neighbor.
							handover_stats.handovers_failed);
				}


				if(SON_UTRAN_ACCESS_MODE_PRESENT & p_resp->nr_list.
						inter_rat_nr_list[i].utran_neighbor.bitmask) {
					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE();
						return retVal;
					}


					oam_memset(param_list[j], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++],MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_ACCESS_MODE=%d", p_resp->nr_list.
							inter_rat_nr_list[i].utran_neighbor.access_mode);
				}

				/* Changes for returning intance id corresponding to the neighors  */	
				if(plmnid_atoi && instance)
				{

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[j], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[j], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[j++], MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_INSTANCE_ID=%d",instance); 
				}
				++end_index;
			} /* End of if(...SON_INTER_UTRAN_NEIGHBOR) */
		}/* End of for loop */

		/* Reset value */
		SON_PROV_REQ.retreive_ongoing &=
			~(OAM_SON_NR_CELL_INTER_RETREIVE_ONGOING);
	}/* End of if */

	num_of_param = j;

	retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
			(UInt8**)param_list,
			num_of_param, trans_id,
			p_err, dst_id,
			start_index, end_index);

	for(i = OAM_ZERO; i < j; ++i) {
		retVal = oam_mem_free(param_list[i], p_err);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"Error in memory free with error code: %d", *p_err);

		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/******************************************************************************
 * Function Name  : oam_populate_n_send_nr_enb_retrieve_resp_to_usr 
 * Inputs         : p_oam_son_nr_retrieve_resp
 *                  p_err 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 *******************************************************************************/
oam_return_et
oam_populate_n_send_nr_enb_retrieve_resp_to_usr(
		oam_son_nr_enb_retrieve_resp_t      *p_oam_son_nr_enb_retrieve_resp,
		UInt16                              trans_id,
		UInt16                              dest_id,
		oam_error_code_et                   *p_err)
{
	/* Coverity CID 62999 Fix */
	oam_return_et    ret_val = OAM_SUCCESS;
	char *parent_name = "eNodeBParams.oam_son_req.nbr_enb_list";
	UInt8 i= OAM_ZERO,j= OAM_ZERO,k= OAM_ZERO;
    /* Coverity 115229 Fix Start */
	UInt8 str[STR_LEN_255] = {OAM_ZERO};
    UInt8 temp_param[STR_LEN_255] = {OAM_ZERO};
    /* Coverity 115229 Fix End */
	Char8 str1[OAM_SEVEN] = {OAM_ZERO};
	UInt8 num_of_param= OAM_ZERO, start_index= OAM_ONE,end_index= OAM_ZERO;
	UInt8 *param_list[STR_LEN_255];
	UInt32 param_len = OAM_ZERO;
	UInt32 value = OAM_ZERO;
	UInt32 count = OAM_ZERO;

	for ( count= OAM_ZERO; count<STR_LEN_255; count++)
	{
		if (OAM_FAILURE == oam_mem_alloc(STR_LEN_255, (void *)&param_list[count] ,p_err))
		{
			OAM_LOG(OAM, OAM_ERROR,
					"Memory allocation to param_list failed"
					" with Error Code:%d",
					*p_err);
			OAM_FUN_EXIT_TRACE(); 

			return OAM_FAILURE; 
		}
		oam_memset(param_list[count],OAM_ZERO,STR_LEN_255);
	}
    /* Coverity Fix 79010 start */
    // end_index = p_oam_son_nr_enb_retrieve_resp->nbr_enb_list_size;
    /* Coverity Fix 79010 end */

	for(i= OAM_ZERO; i < p_oam_son_nr_enb_retrieve_resp->nbr_enb_list_size;i++)
	{
		/* Populate enb_type */
		oam_memset(str, OAM_ZERO, STR_LEN_255);
		oam_snprintf((char *)str,sizeof(str),"%d",p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_id.enb_type); 
		oam_strncpy((char *)temp_param,"enb_type=",oam_strlen("enb_type=")+ OAM_ONE);
		if ( oam_strlen((char*)str) == OAM_ZERO)
			oam_strncat((char *)temp_param,(char *)"0", oam_strlen((char*)"0")+ OAM_ONE);
		else
			oam_strncat((char *)temp_param,(char *)str, oam_strlen((char*)str)+ OAM_ONE);
		param_len = oam_strlen((char *)temp_param);
		temp_param[param_len] = OAM_ZERO;
		oam_strncpy((char *)param_list[j],(char *)temp_param, oam_strlen((char*)temp_param)+ OAM_ONE);
		j++;

		/* Populate plmn_id */
		oam_memset(str, OAM_ZERO, STR_LEN_255);
		oam_memset(str1, OAM_ZERO, OAM_SEVEN); /* Cov CID 63683 Fix */
		oam_generate_plmnid((Char8*)str1,&(p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_id.plmn_id));
		oam_strncpy((char *)temp_param,"plmn_id=",oam_strlen("plmn_id=")+ OAM_ONE);
		if ( oam_strlen((char*)str1) == OAM_ZERO)
			oam_strncat((char *)temp_param,(char *)"0", oam_strlen((char*)"0")+ OAM_ONE);
		else
			oam_strncat((char *)temp_param,(char *)str1, oam_strlen((char*)str1)+ OAM_ONE);
		param_len = oam_strlen((char *)temp_param);
		temp_param[param_len] = OAM_ZERO;
		oam_strncpy((char *)param_list[j],(char *)temp_param, oam_strlen((char*)temp_param)+ OAM_ONE);
		j++;

		/* Populate enb_id */
		oam_memset(str, OAM_ZERO ,STR_LEN_255);
		value = OAM_ZERO; 
		/*SPR 11650 Fix*/
		if (p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_id.enb_type == SON_MACRO_ENB)
		{
			oam_cmn_convert_byte_string_to_integer(p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_id.enb_id,OAM_FOUR,&value,                            OAM_MAX_INT_BITSTRING_SIZE - OAM_MACRO_ENB_ID_BITSTRING_SIZE);
		}
		else if (p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_id.enb_type == SON_HOME_ENB)
		{
			oam_cmn_convert_byte_string_to_integer(p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_id.enb_id,OAM_FOUR,&value,                            OAM_MAX_INT_BITSTRING_SIZE - OAM_HOME_ENB_ID_BITSTRING_SIZE);

		}
		/*SPR 11650 Fix*/
		oam_snprintf((char *)str,sizeof(str),"%d",value);
		oam_strncpy((char *)temp_param,"enb_id=",oam_strlen("enb_id=")+ OAM_ONE);
		if ( oam_strlen((char*)str) == OAM_ZERO)
			oam_strncat((char *)temp_param,(char *)"0", oam_strlen((char*)"0")+ OAM_ONE);
		else
			oam_strncat((char *)temp_param,(char *)str, oam_strlen((char*)str)+ OAM_ONE);
		param_len = oam_strlen((char *)temp_param);
		temp_param[param_len] = OAM_ZERO;
		oam_strncpy((char *)param_list[j],(char *)temp_param, oam_strlen((char*)temp_param)+ OAM_ONE);
		j++;

		if(SON_ANR_ENB_TAC_PRESENT & p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].bitmask)
		{
			/* Populate tac If present */
			oam_memset(str, OAM_ZERO, STR_LEN_255);
			value = OAM_ZERO; 
			/*SPR 11315 Fix*/
			oam_cmn_convert_byte_string_to_short(
					p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].tac_list[OAM_ZERO].tac,
					&value,
					OAM_MAX_SHORT_INT_BITSTRING_SIZE - OAM_TAC_BIT_STRING_SIZE);
			/*SPR 11315 Fix*/
			oam_snprintf((char *)str,sizeof(str),"%d",value);
			oam_strncpy((char *)temp_param,"tac=", oam_strlen("tac=")+ OAM_ONE);
			if ( oam_strlen((char*)str) == OAM_ZERO)
				oam_strncat((char *)temp_param,(char *)"0", oam_strlen((char*)"0")+ OAM_ONE);
			else
				oam_strncat((char *)temp_param,(char *)str, oam_strlen((char*)str)+ OAM_ONE);
			param_len = oam_strlen((char *)temp_param);
			temp_param[param_len] = OAM_ZERO;
			oam_strncpy((char *)param_list[j],(char *)temp_param, oam_strlen((char*)temp_param)+ OAM_ONE);
			j++;
		}

		if(SON_ANR_ENB_TNL_ADD_LIST_PRESENT & p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].bitmask)
		{
			/* Populate ENB TNL Address  List If present */
			oam_memset(str, OAM_ZERO ,STR_LEN_255);
			oam_snprintf((char *)str,sizeof(str),
					"%d.%d.%d.%d",p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_tnl_address_list[k].ipv4_add[OAM_ZERO], p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_tnl_address_list[k].ipv4_add[OAM_ONE], p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_tnl_address_list[k].ipv4_add[OAM_TWO], p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].enb_tnl_address_list[k].ipv4_add[OAM_THREE]);
			oam_snprintf(str1,sizeof(str1),"%d",k); 

			oam_strncpy((char *)temp_param,"enb_tnl_address_list[", oam_strlen("enb_tnl_address_list[")+ OAM_ONE);
			oam_strncat((char *)temp_param,str1, oam_strlen((char*)str1)+ OAM_ONE);
			oam_strncat((char *)temp_param,"]=", oam_strlen("]=")+ OAM_ONE);
			oam_strncat((char *)temp_param,(char *)str, oam_strlen((char*)str)+ OAM_ONE);
			param_len = oam_strlen((char *)temp_param);
			temp_param[param_len] = OAM_ZERO;
			oam_strncpy((char *)param_list[j],(char *)temp_param, oam_strlen((char*)temp_param)+ OAM_ONE);
			j++;
		}

		if(SON_ANR_ENB_X2_HO_STATUS_PRESENT & p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].bitmask)
		{
			/* Populate x2_status If present */
			oam_memset(str, OAM_ZERO ,STR_LEN_255);
			oam_snprintf((char *)str,sizeof(str),"%d",p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].x2_status); 
			oam_strncpy((char *)temp_param,"x2_status=",oam_strlen("x2_status=")+ OAM_ONE);
			oam_strncat((char *)temp_param,(char *)str, oam_strlen((char*)str)+ OAM_ONE);
			param_len = oam_strlen((char *)temp_param);
			temp_param[param_len] = OAM_ZERO;
			oam_strncpy((char *)param_list[j],(char *)temp_param, oam_strlen((char*)temp_param)+ OAM_ONE);
			j++;
		}

		if(SON_ANR_ENB_CUR_X2_CONN_PRESENT & p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].bitmask)
		{
			/* Populate x2_connection_status If present */
			oam_memset(str, OAM_ZERO ,STR_LEN_255);
			oam_snprintf((char *)str,sizeof(str),"%d",p_oam_son_nr_enb_retrieve_resp->nbr_enb_list[i].x2_connection_status); 
			oam_strncpy((char *)temp_param,"x2_connection_status=",oam_strlen("x2_connection_status=")+ OAM_ONE);
			oam_strncat((char *)temp_param,(char *)str, oam_strlen((char*)str)+ OAM_ONE);
			param_len = oam_strlen((char *)temp_param);
			temp_param[param_len] = OAM_ZERO;
			oam_strncpy((char *)param_list[j],(char *)temp_param, oam_strlen((char*)temp_param)+ OAM_ONE);
			j++;
		}
	}/* End of for loop */

	num_of_param=j;
	end_index = i;

	ret_val = oam_construct_n_send_gpv_response((UInt8* )parent_name,param_list,num_of_param, 
			trans_id,p_err,dest_id,start_index,end_index);
	for ( count= OAM_ZERO; count<STR_LEN_255; count++)
	{
		if (OAM_FAILURE == oam_mem_free(param_list[count] ,p_err))
		{
			OAM_LOG(OAM,OAM_WARNING,
					"Error in Memory Free with Error Code:%d",*p_err);
			OAM_FUN_EXIT_TRACE();

		}
	}

	return ret_val;
}

/******************************************************************************
 * Function Name  : oam_son_update_neigh_list_in_use 
 * Inputs         : none 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 *******************************************************************************/
	oam_return_et 
oam_son_update_neigh_list_in_use(UInt8 cell_arr_idx)

{
	oam_return_et retVal = OAM_SUCCESS;
	UInt16 cnt = OAM_ZERO;
	UInt16 cnt1 = OAM_ZERO;
	/* Spr 15438 Fix Start */
	UInt16 cnt2 = OAM_ZERO;
	/* Spr 15438 Fix End */
	SInt16 neigh_idx = OAM_ZERO;
	/* SPR-13586 START */
	SInt16 neigh_idx1 = OAM_ZERO;
	/* SPR-13586 END */
	/* Spr 15438 Fix Start */
	SInt16 neigh_idx_in_nr = OAM_ZERO;
	UInt16 num_intra_neigh = OAM_ZERO;
	UInt16 nr_enb_count = OAM_ZERO;

	/* Coverity ID : 96941 Fix Start*/
	oam_error_code_et err = NO_ERROR;
	/* Coverity ID : 96941 Fix End*/


	/*SPR 15799 START*/
	SInt16 arfcn_found = NOT_FOUND;
	/*SPR 15799 END*/ 
	oam_bool_et is_nr_add_req_at_son = OAM_FALSE;
	oam_bool_et is_send_enb_add = OAM_FALSE;
	UInt8 temp3[SON_ENB_ID_OCTET_SIZE] = {OAM_ZERO}; 
	UInt32 temp_cell_id = OAM_ZERO;
	/* Spr 15438 Fix End */
	/* Spr 15612  Fix Start*/
	UInt16 num_inter_neigh = OAM_ZERO;
	/* Spr 15612  Fix End*/


	/*SPR 15604 START */
	UInt16 length  = OAM_ZERO;
	char obj_name[STR_LEN_256] = {OAM_ZERO};
	/*SPR 15604 END */



	OAM_FUN_ENTRY_TRACE();
	/* Start: SPR 10567 */
	/* Spr 15438 Fix Start */
	/* Coverity 83448 fix start */
	oam_error_code_et p_error_code = NO_ERROR;
	oam_son_nr_add_req_t *p_req; 
	if (OAM_FAILURE == oam_mem_alloc(sizeof(oam_son_nr_add_req_t), (void *)&p_req, &p_error_code))
	{
		OAM_LOG(OAM, OAM_ERROR,
				"Memory allocation to p_req failed"
				" with Error Code:%d",
				p_error_code);
		OAM_FUN_EXIT_TRACE();
		/* Not Enough Memory */
		return OAM_FAILURE;
	}
	/* Coverity 83448 fix end */
	oam_son_anr_updated_nrt_info_t *p_local_son_nrt_info = OAM_NULL;
	oam_son_anr_updated_nrt_info_t *p_son_nrt_info = OAM_NULL;
	oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL; 
	oam_son_nr_add_req_t *p_local_son_nr_add = OAM_NULL; 
	oam_cell_neighbourlist_info_t *p_cell_neigh_info = OAM_NULL;
	rrm_oam_cell_config_req_t *p_rrm_cell_config = OAM_NULL;
	/* SPR 18930  FIX START */
	oam_son_anr_meas_config_req_t *p_anr_meas_config_req = OAM_NULL;
	/* SPR 18930  FIX END */

	/* SPR 18930  FIX START */
	UInt8 cid = OAM_ZERO;
    /* SPR 19065 Fix Start */
    UInt8  nbr_cell_id[SON_CELL_ID_OCTET_SIZE];
#ifdef LTE_EMBMS_SUPPORTED
    UInt8 cid_mbms_arr_idx = OAM_ZERO;
    rrm_oam_cell_config_req_t *p_mbms_cell_config = OAM_NULL;
    UInt8 nbr_count = OAM_ZERO;
    UInt8 srv_count = OAM_ZERO;
    UInt8 num_mbsfn_count = OAM_ZERO;
    oam_bool_et nbr_found_in_same_enb = OAM_FALSE;
    rrm_oam_cell_plmn_info_t nbr_plmn_id;
#endif
    oam_memset(nbr_cell_id, OAM_ZERO, SON_CELL_ID_OCTET_SIZE);
    /* SPR 19065 Fix End */
	SInt8 cell_config_idx_rrm = OAM_ZERO;
	SInt8 cell_meas_config_idx = OAM_ERROR_RETURN_VAL;
	SInt8 cell_config_nr_idx = OAM_ERROR_RETURN_VAL;
	cid = oam_prov_req.cell_cntxt.cell_ctxt_status[cell_arr_idx].cid;

	cell_meas_config_idx = oam_get_son_inter_freq_carrier_idx(cid);

	cell_config_idx_rrm = oam_get_rrm_cell_config_idx(cid);

    cell_config_nr_idx = oam_get_son_cell_nr_list_idx(cid); 

	if((OAM_ERROR_RETURN_VAL == cell_config_idx_rrm)||
			(OAM_ERROR_RETURN_VAL == cell_meas_config_idx)|| 
			(OAM_ERROR_RETURN_VAL == cell_config_nr_idx)) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
				cid);
		/*Coverity 96941 Fix*/
                oam_mem_free(p_req, &p_error_code);
		OAM_FUN_ENTRY_TRACE();
		return OAM_FAILURE;
	}

	p_local_son_nrt_info = &LOCAL_NRT_INFO(cell_arr_idx);
	p_son_nrt_info = &NRT_INFO(cell_arr_idx);
	/* SPR 18930  FIX START */
	p_son_nr_add = &SON_NR_ADD_REQ(cell_config_nr_idx);
	p_local_son_nr_add = &LOCAL_SON_NR_ADD_REQ(cell_config_nr_idx);
	p_cell_neigh_info = &SON_NEIGHBORLIST_INFO(cell_arr_idx);
	p_rrm_cell_config = &RRM_CELL_CONFIG(cell_config_idx_rrm); 
	p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_meas_config_idx);
	/* SPR 18930  FIX END */

	oam_memset(p_req,0,sizeof(oam_son_nr_add_req_t));

	oam_son_nr_enb_add_req_t *p_enb_add_req = &LOCAL_SON_PROV_REQ.oam_son_nr_enb_add_req;

	oam_memset(p_enb_add_req,0,sizeof(oam_son_nr_enb_add_req_t));

	/* SPR 17666 changes start */
	oam_eutran_nbr_cell_type_et nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
	/* SPR 17666 changes end */

	oam_memcpy(&p_req->src_cgi, &p_local_son_nrt_info->src_cgi,
			sizeof(son_intra_rat_global_cell_id_t));
	/* Spr 15438 Fix End */


	oam_memcpy(&NRT_INFO(cell_arr_idx).src_cgi, &LOCAL_NRT_INFO(cell_arr_idx).src_cgi,
			sizeof(son_intra_rat_global_cell_id_t));
	NRT_INFO(cell_arr_idx).nrt_op = LOCAL_NRT_INFO(cell_arr_idx).nrt_op;
	OAM_LOG(OAM, OAM_INFO, "Updating src_cgi and nrt_op of NeighborListInUse.");
	/*SPR 15604 START */
	oam_prov_req.system_status.event_ongoing |= OAM_NLIU_UPDATION_ONGOING;
	/*SPR 15604 END */


	if(LOCAL_NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list_size) 
	{
		OAM_LOG(OAM, OAM_INFO, "Updating intra-RAT NeighborListInUse.");
		for(cnt = OAM_ZERO; cnt < LOCAL_NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list_size; ++cnt) 
		{
			neigh_idx = oam_cgi_search_in_neigh_list(
					&LOCAL_NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list[cnt].nbr_cgi,
					NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list,
                    NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list_size,
                    &SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].intra_rat_neigh_valid_bitmap,
                    OAM_SON_NEIGH_TYPE_INTRA_RAT);

            /* SPR 19938 Fix Start*/
            /* If NRT upadate info received from SON with operation as NRT_NMM_OP_ADD and init time NR add req is already 
             ** send to SON when feature state indication received from SON, then OAM change the operation code from 
             ** NRT_NMM_OP_ADD to SON_NRT_OP_ADD. Know OAM only send the newly detected neighbors towards SON in NR add req
             **/ 

            /* If feature state ind is not received from SON then OAM save the neighbour information (detected neighbour
             ** through NR scan). OAM send all neighbour cells(configured as well as detected)information towards SON,
             ** when feature state indication received from SON on OAM.
             **/
            if ((OAM_SYS_EVENT_BIMASK & INIT_TIME_NR_SCAN_REQ_SEND) && (LOCAL_NRT_INFO(cell_arr_idx).nrt_op == SON_NRT_NMM_OP_ADD))
            {
               LOCAL_NRT_INFO(cell_arr_idx).nrt_op = SON_NRT_OP_ADD; 
            }
            /* SPR 19938 Fix Stop*/

            /* SPR 19938 Fix Start*/
            /* If NRT upadate info received from SON with operation as NRT_NMM_OP_ADD and init time NR add req is already 
             ** send to SON when feature state indication received from SON, then OAM change the operation code from 
             ** NRT_NMM_OP_ADD to SON_NRT_OP_ADD. Know OAM only send the newly detected neighbors towards SON in NR add req
             **/ 

            /* If feature state ind is not received from SON then OAM save the neighbour information (detected neighbour
             ** through NR scan). OAM send all neighbour cells(configured as well as detected)information towards SON,
             ** when feature state indication received from SON on OAM.
             **/
            if ((OAM_SYS_EVENT_BIMASK & INIT_TIME_NR_SCAN_REQ_SEND) && (LOCAL_NRT_INFO(cell_arr_idx).nrt_op == SON_NRT_NMM_OP_ADD))
            {
               LOCAL_NRT_INFO(cell_arr_idx).nrt_op = SON_NRT_OP_ADD; 
            }
            /* SPR 19938 Fix Stop*/

			switch(LOCAL_NRT_INFO(cell_arr_idx).nrt_op) 
			{
				case SON_NRT_OP_DELETE:
					if(neigh_idx != NOT_FOUND) 
					{ 
						if(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
								intra_rat_neigh_valid_bitmap &
								(OAM_ONE << neigh_idx))
						{
							SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
								intra_rat_neigh_valid_bitmap &=
								~(OAM_ONE << neigh_idx);
							/*SPR 15604 START*/ 
							oam_memset(&obj_name,OAM_ZERO, STR_LEN_256); 

							if(STR_LEN_256 >= length) 
								oam_memcpy(&obj_name , NLIU_LTECell_PATH ,oam_strlen(NLIU_LTECell_PATH));
							/* SPR 17409 fix start */
							retVal = oam_handle_nliu_object_deletion(obj_name, neigh_idx+1,cell_arr_idx );
							/* SPR 17409 fix end */
							if (retVal == OAM_FAILURE)
							{
								OAM_LOG(OAM,OAM_WARNING, "Unable to persist deleted NLIU instance");
							}
							/* SPR 17650 changes start */
							/* SPR 17650 changes end */
							/*SPR 15604 END*/  
							/* SPR 17409 fix start */
							OAM_LOG(OAM, OAM_INFO, "Intra RAT Neighbor[%d] deleted "
									"from NeighborListInUse", neigh_idx);
							/* SPR 17409 fix end */
							/*SPR 15604 START*/
							//--NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list_size;
							/*SPR 15604 END*/

							oam_memset(&SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].nrt_info.
									nr_list.intra_rat_nr_list[neigh_idx],
									OAM_ZERO,
									sizeof(son_intra_rat_neighbor_info_t));

							break;
						}
					}
					/* SPR-13586 START */
					else
					{    

						OAM_LOG(OAM, OAM_WARNING, "Delete operation for "
								"NeighborListInUse received for a neighbor "
								"that is not in the list.");
					}
					/* SPR-13586 END */
					break;

				case SON_NRT_OP_UPDATE:
					if(neigh_idx != NOT_FOUND) { 
						if(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
								intra_rat_neigh_valid_bitmap &
								(OAM_ONE << neigh_idx))
						{
							/*SPR 15604 START*/  
							oam_memset(&obj_name,OAM_ZERO, STR_LEN_256); 
							oam_memcpy(&obj_name , NLIU_LTECell_PATH ,oam_strlen(NLIU_LTECell_PATH));

							/* Spr 15438 Fix Start  */
							g_parameter_map_element = g_param_intra_rat_neigh_list_in_use;
							/* Spr 15438 Fix End  */
							/*cov 94775 +-*/
							retVal = (oam_return_et)oam_handle_nliu_object_updation((void *)&NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list[neigh_idx],
									(void *)&LOCAL_NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list[cnt],
									neigh_idx + 1,
                                            /* SPR 18930  FIX START */
									SON_EUTRAN_CELL,
                                    cell_arr_idx);
                                            /* SPR 18930  FIX END */

							if (retVal == OAM_FAILURE)
							{
								OAM_LOG(OAM,OAM_WARNING, "Error persisting NLIU parameters ");
							}
							/*SPR 15604 END*/  

							oam_update_intra_rat_nr(
									&NRT_INFO(cell_arr_idx).nr_list.
									intra_rat_nr_list[neigh_idx],
									&LOCAL_NRT_INFO(cell_arr_idx).nr_list.
									intra_rat_nr_list[cnt]);

							OAM_LOG(OAM, OAM_INFO, "Intra RAT Neighbor[%d] updated "
									"from NeighborListInUse", neigh_idx);
							break;
						}
					}
					/* SPR-13586 START */
					else
					{    
						OAM_LOG(OAM, OAM_WARNING,
								"Update operation for NeighborListInUse"
								" received for a neighbor that is not in "
								" the list.");
					}
					/* SPR-13586 END */
					break;

				case SON_NRT_OP_ADD:
					if(neigh_idx == NOT_FOUND) {
						/* Spr 15438 Fix Start */
						/* there is NO matching CGI in NLIU*/

						is_nr_add_req_at_son = OAM_TRUE;
						is_send_enb_add = OAM_TRUE;
						/*SPR 15604 START */
						neigh_idx_in_nr = oam_cgi_search_in_neigh_list(
								&p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].nbr_cgi,
								p_son_nr_add->nr_list.intra_rat_nr_list,
								p_son_nr_add->nr_list.intra_rat_nr_list_size,
								&p_cell_neigh_info->intra_rat_nr_entry_bitmap,
								OAM_SON_NEIGH_TYPE_INTRA_RAT);

						/* SPR-17833 START */
						/* code deleted */
						/* SPR-17833 END */

						if(neigh_idx_in_nr != NOT_FOUND)
						{
							/* SPR 18930  FIX START */
							if((p_cell_neigh_info->eutran_nbr_ctxt[neigh_idx_in_nr].must_include == OAM_FALSE)&&
									(p_cell_neigh_info->eutran_nbr_ctxt[neigh_idx_in_nr].enable == OAM_TRUE)) 
							{
/*SPR 22442 Fix Start*/
								OAM_LOG(OAM,OAM_INFO,"EUTRAN Neighbour Detected by SON is present in NR Configuration"
										" With MustInclude = FALSE. Not adding in NLIU");
/*SPR 22442 Fix End*/
								break;
							}
							else if ((p_cell_neigh_info->eutran_nbr_ctxt[neigh_idx_in_nr].enable == OAM_TRUE)&&
									(p_cell_neigh_info->eutran_nbr_ctxt[neigh_idx_in_nr].must_include == OAM_TRUE))
							{
								/* Neighbour Added By OAM itself */
								is_nr_add_req_at_son = OAM_FALSE;

							}  
							/* SPR 18930  FIX END */

						}
						else
						{
							/* SPR 18930  FIX START */
/*SPR 22442 Fix Start*/
							OAM_LOG(OAM,OAM_INFO,"EUTRAN Neighbour Detected by SON");
/*SPR 22442 Fix End*/

							/*SPR 15799 START*/
							if(p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].earfcn !=
									p_rrm_cell_config->ran_info.
									rf_params.rf_configurations.dl_earfcn)
							{
								arfcn_found =
									oam_arfcn_search_in_meas_config_list(
											&p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].earfcn,
											p_anr_meas_config_req->eutran_config_list,  
											p_anr_meas_config_req->eutran_config_list_size,  
											&SON_INTER_FREQ_CARR_PARAMS(cell_meas_config_idx).eutran_meas_entry_bitmap,
											OAM_SON_MEAS_CONFIG_TYPE_EUTRAN);

								/* Validating if earfcn configured for requested neighbour */
								if((arfcn_found == NOT_FOUND)||((arfcn_found != NOT_FOUND)&&
											(SON_INTER_FREQ_CARR_PARAMS(cell_meas_config_idx).
											 eutran_meas_enable[arfcn_found].enable == OAM_FALSE)))
								{
									if(SON_NR_LOCKED == p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].nr_status)
									{
										OAM_LOG(OAM,OAM_DETAILED,"Earfcn not present/enable and nr status is locked"
												" ignoring neighbour");
										is_nr_add_req_at_son = OAM_FALSE;
									}
								}
							}
							if((p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].
										bitmask & SON_ENABLE_X2_STATUS_PRESENT)&&
									((p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].
									  x2_status == SON_X2_ALLOWED_CONNECTED)||
									 (p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].
                                      x2_status == SON_X2_PROHIBITED_CONNECTED)||
                                     (p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].
                                      x2_status == SON_LOCALLY_CONNECTED_CELL))) 
							{
								/* X2 is already established */
								is_send_enb_add = OAM_FALSE;
							}
							/* Detected Neighbour */
							/*SPR 15799 END*/
							/* Removing readonly bitmask rcvd from SON */
                            /* SPR 21903 FIXED START*/

							p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].	
								bitmask &= ~SON_ENABLE_X2_STATUS_PRESENT;
							p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].
								bitmask &= ~SON_EUTRAN_NR_HO_STATS_PRESENT;
							p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].	
								bitmask &= ~SON_SUSPECT_PCI_PRESENT;

                             /* SPR 21903 FIXED END*/
							/* SPR 18930  FIX END */
						}
						/* SPR-17833 START */
						/* code deleted */
						/* SPR-17833 END */
						/*SPR 15604 END */
						/* Spr 15438 Fix End*/

						for(cnt1 = OAM_ZERO;
								cnt1 < SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
								max_lte_cell_entries;
								++cnt1) {
							/* SPR 18930  FIX START */
							OAM_LOG(OAM,OAM_DETAILED,"cnt1 = %u,SON_PROV_REQ.neigh_list_in_use[%u].intra_rat_neigh_valid_bitmap = %u",cnt1,cell_arr_idx,SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].intra_rat_neigh_valid_bitmap);
							/* SPR 18930  FIX END */
							if(!(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
										intra_rat_neigh_valid_bitmap &
										(OAM_ONE << cnt1)))
							{

							/* SPR 18930  FIX START */
                                if(neigh_idx_in_nr == NOT_FOUND)
                                {     
                                    SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
                                        is_detected_intra_neighbour[cnt1]= OAM_TRUE;
                                } 
							/* SPR 18930  FIX END */

								/* Spr 15438 Fix Start */
								if(is_nr_add_req_at_son == OAM_TRUE)
                                {
                                    oam_memcpy(&p_req->nr_list.
                                            /*SPR 15799 START*/ 
							/* SPR 18930  FIX START */
                                            intra_rat_nr_list[num_intra_neigh++],
							/* SPR 18930  FIX END */
                                            /*SPR 15799 END*/ 
                                            &p_local_son_nrt_info->nr_list.
                                            intra_rat_nr_list[cnt],
                                            sizeof(son_intra_rat_neighbor_info_t));
                                    /*SPR 15799 START*/ 
                                    /* Remove bitmask from nr add req */
							/* SPR 18930  FIX START */
                                    p_req->nr_list.intra_rat_nr_list[num_intra_neigh].
							/* SPR 18930  FIX END */
                                        bitmask &= ~SON_ENABLE_X2_STATUS_PRESENT;
                                        /* SPR 21903 FIXED START */
                                        p_req->nr_list.intra_rat_nr_list[num_intra_neigh].
                                        bitmask &= ~SON_EUTRAN_NR_HO_STATS_PRESENT;

                                        p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].
                                        bitmask &= ~SON_SUSPECT_PCI_PRESENT;
                                        /* SPR 21903 FIXED END */

                                    /*SPR 15799 END*/ 
                                    if(p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].earfcn ==
                                            p_rrm_cell_config->ran_info.
                                            rf_params.rf_configurations.dl_earfcn)   
                                    {     
                                        /* SPR 17666 changes start */
                                        nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
                                        /* SPR 17666 changes end */
                                    }     
                                    else  
                                    {     
                                        /* SPR 17666 changes start */  
                                        nbr_cell_type = OAM_INTER_FREQ_NBR_CELL;
                                        /* SPR 17666 changes end */
                                    }                                      
                                    /* SPR 17666 changes start */                                      
                                    if (OAM_FAILURE == oam_dynamic_nbr_cell_access_mode_pci_validation(
                                                nbr_cell_type,
                                                p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].earfcn,
                                                &p_req->nr_list.intra_rat_nr_list[num_intra_neigh-1],
                                                cell_arr_idx))
                                        //neigh_idx_in_nr-1))
                                    {
                                        OAM_LOG(OAM,OAM_DETAILED,
                                                " Neighbor Cell Access Mode Validation could not continue");
                                    }
                                    /* SPR 17666 changes end */
                                    p_req->nr_list.intra_rat_nr_list[num_intra_neigh-1].bitmask |= 
                                        SON_ACCESS_MODE_PRESENT;

                                    /* Spr 15595 Fix Start */
                                    p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].bitmask |= SON_ACCESS_MODE_PRESENT;
                                    p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].access_mode =  
                                        p_req->nr_list.intra_rat_nr_list[num_intra_neigh-1].access_mode;
                                    /* Spr 15595 Fix End */   
                                    /*SPR 15799 START*/
                                    /*SPR 15604 START*/
							/* SPR 18930  FIX START */
                                    /* Code Removed */
							/* SPR 18930  FIX END */
                                }
									oam_memset(&obj_name,OAM_ZERO, STR_LEN_256);

									g_parameter_map_element = g_param_intra_rat_neigh_list_in_use;
									if(STR_LEN_256 >= length)

										oam_memcpy(&obj_name , NLIU_LTECell_PATH ,oam_strlen(NLIU_LTECell_PATH));

									retVal = oam_handle_nliu_object_addition(obj_name,
											&LOCAL_NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list[cnt],
											SON_EUTRAN_CELL,
                                            /* SPR 18930  FIX START */
                                            cell_arr_idx);
                                            /* SPR 18930  FIX END */
									if (retVal == OAM_FAILURE)
									{
										OAM_LOG(OAM,OAM_WARNING, "Error adding NLIU object");
									}
								/*SPR 17423 changes end */
								/* Nr enb Add Start */
								if(OAM_TRUE == oam_prov_req.oam_son_req.tnl_discovery_enable_disable_flag )
								{
									/* Spr 15595 Fix Start */
									/* Code removed */
									/* Spr 15595 Fix End */   

									if(is_send_enb_add == OAM_TRUE)
									{
										/* validate and send Send nr enb add */ 
										oam_memcpy(&p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.plmn_id,  
												&p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].nbr_cgi.plmn_id,
												sizeof(son_cell_plmn_info_t));

										if(p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].access_mode == SON_OPEN) 
										{
											p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.enb_type = SON_MACRO_ENB;

											oam_cmn_convert_byte_string_to_integer(
													p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].nbr_cgi.cell_identity,
													OAM_FOUR,
													&temp_cell_id,
													/* Spr 15595 Fix Start */
													OAM_MAX_INT_BITSTRING_SIZE - OAM_MACRO_ENB_ID_BITSTRING_SIZE);
											/* Spr 15595 Fix End */   

											oam_conversion_from_macro_enb_to_byte_string(temp3,temp_cell_id, OAM_TWELVE);
											oam_memcpy(p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.enb_id,
													temp3, SON_ENB_ID_OCTET_SIZE - OAM_ONE);

										}
										else 
										{
											p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.enb_type = SON_HOME_ENB;

											oam_memcpy(&p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.enb_id,  
													&p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].nbr_cgi.cell_identity,
													SON_ENB_ID_OCTET_SIZE);
										}

										for(cnt2 = OAM_ZERO;cnt2 < SON_PROV_REQ.
												neigh_list_in_use[cell_arr_idx].intra_rat_last_added_instance_id;++cnt2)  
										{
											if(p_son_nrt_info->nr_list.
													intra_rat_nr_list[cnt2].access_mode != SON_OPEN)
											{
												if(!oam_memcmp(p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.enb_id,
															p_son_nrt_info->
															nr_list.intra_rat_nr_list[cnt2].nbr_cgi.cell_identity,
															SON_ENB_ID_OCTET_SIZE))
												{
													if(!oam_memcmp(&p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.plmn_id,
																&p_son_nrt_info->nr_list.
																intra_rat_nr_list[cnt2].nbr_cgi.plmn_id,
																sizeof(son_cell_plmn_info_t)))
													{
														is_send_enb_add = OAM_FALSE;
														break;
													}

												}
											}
											else
											{
												oam_cmn_convert_byte_string_to_integer(
														p_son_nrt_info->nr_list.intra_rat_nr_list[cnt2].nbr_cgi.cell_identity,
														OAM_FOUR,
														&temp_cell_id,
														/* Spr 15595 Fix Start */
														OAM_MAX_INT_BITSTRING_SIZE - OAM_MACRO_ENB_ID_BITSTRING_SIZE);
												/* Spr 15595 Fix End */   

												oam_conversion_from_macro_enb_to_byte_string(temp3,temp_cell_id, OAM_TWELVE);

												if(!oam_memcmp(p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.enb_id,
															temp3,SON_ENB_ID_OCTET_SIZE - OAM_ONE))
												{
													if(!oam_memcmp(&p_enb_add_req->nbr_enb_list[nr_enb_count].enb_id.plmn_id,
																&p_son_nrt_info->nr_list.
																intra_rat_nr_list[cnt2].nbr_cgi.plmn_id,
																sizeof(son_cell_plmn_info_t)))
													{
														is_send_enb_add = OAM_FALSE;
														break;
													}

												}
											} 
										}     
										/* Spr 15595 Fix Start */
										if(is_send_enb_add) 
											/* Spr 15595 Fix End */   
										{   
											oam_memcpy(p_enb_add_req->nbr_enb_list[nr_enb_count].tac_list[0].tac,
													p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].tac,SON_TAC_OCTET_SIZE); 

											p_enb_add_req->nbr_enb_list[nr_enb_count].tac_list_size = OAM_ONE; 
											p_enb_add_req->nbr_enb_list[nr_enb_count].bitmask|= 
												SON_ANR_ENB_TAC_PRESENT; 

											p_enb_add_req->nbr_enb_list[nr_enb_count].x2_status = SON_X2_ALLOWED; 
											p_enb_add_req->nbr_enb_list[nr_enb_count].bitmask 
												|= SON_ANR_ENB_X2_HO_STATUS_PRESENT; 
											p_enb_add_req->nbr_enb_list[nr_enb_count].x2_connection_status = SON_X2_CONNECT; 
											p_enb_add_req->nbr_enb_list[nr_enb_count++].bitmask 
												|= SON_ANR_ENB_CUR_X2_CONN_PRESENT; 
										}  
									}
								}
								/* Spr 15438 Fix End */

								/* Spr 15595 Fix Start */
								oam_memcpy(&NRT_INFO(cell_arr_idx).nr_list.
										intra_rat_nr_list[cnt1],
										&LOCAL_NRT_INFO(cell_arr_idx).nr_list.
										intra_rat_nr_list[cnt],
										sizeof(son_intra_rat_neighbor_info_t));

 
								OAM_LOG(OAM, OAM_INFO, "Intra RAT Neighbor added"
										" to NeighborListInUse[%d]", cnt1);

								/* SPR 18930  FIX START */
								/*SPR 15604 START*/ 	
								//++NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list_size; 
								/* SPR 17651 changes start */
								//++SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].intra_rat_nr_list_size; 
								/* SPR 18930  FIX END */
								/* SPR 17651 changes end */
								/*SPR 15604 END*/
								/* SPR 15612 Fix Start */
								p_son_nrt_info->nr_list.inter_rat_nr_list[cnt1].bitmask |= 
									p_local_son_nrt_info->nr_list.inter_rat_nr_list[cnt].bitmask;
								/* SPR 15612 Fix End */

								SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									intra_rat_neigh_valid_bitmap |=
									(OAM_ONE << cnt1);
                            OAM_LOG(OAM,OAM_DETAILED,"cnt1 = %u,SON_PROV_REQ.neigh_list_in_use[%u].intra_rat_neigh_valid_bitmap = %u",cnt1,cell_arr_idx,SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].intra_rat_neigh_valid_bitmap);
								/* Spr 15595 Fix End */
								break;
							}
						}

						if(cnt1 == SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
								max_lte_cell_entries) {
							OAM_LOG(OAM, OAM_WARNING,
									"Add operation for NeighborListInUse"
									" received but the NeighborListInUse has"
									" been exhausted.");
						}
					} 
					else {
						/* SPR 18930  FIX START */
						/* Code Removed */
						/* SPR 18930  FIX END */
						OAM_LOG(OAM, OAM_WARNING,
								"Add operation for NeighborListInUse"
								" received for a neighbor that is already in "
								" the list.");
						/* SPR 18930  FIX START */		
						OAM_LOG(OAM,OAM_DETAILED,"addition for neighbor cid = %d is ignored",
								oam_extract_cid_from_eutran_cellidentity(
									LOCAL_NRT_INFO(cell_arr_idx).nr_list.
									intra_rat_nr_list[cnt].nbr_cgi.cell_identity));

						/* SPR 18930  FIX END */
					}
					break;
                    /*+SPR 18853 FIX*/
                case SON_NRT_NMM_OP_ADD : 
                    {
                        if(neigh_idx == NOT_FOUND) {
                            neigh_idx_in_nr = oam_cgi_search_in_neigh_list(
                                    &p_local_son_nrt_info->nr_list.intra_rat_nr_list[cnt].nbr_cgi,
                                    p_son_nr_add->nr_list.intra_rat_nr_list,
                                    p_son_nr_add->nr_list.intra_rat_nr_list_size,
                                    &p_cell_neigh_info->intra_rat_nr_entry_bitmap,
                                    OAM_SON_NEIGH_TYPE_INTRA_RAT);

                            if(neigh_idx_in_nr != NOT_FOUND)
                            {
                                if((p_cell_neigh_info->eutran_nbr_ctxt[neigh_idx_in_nr].must_include == OAM_FALSE)&&
                                        (p_cell_neigh_info->eutran_nbr_ctxt[neigh_idx_in_nr].enable == OAM_TRUE))
                                {
                                    OAM_LOG(OAM,OAM_DETAILED,"Neighbour Detected by SON is present in NR Configuration"
                                            " With MustInclude = FALSE. Not adding in NLIU");
                                    break;
                                }
                            }

                            for(cnt1 = OAM_ZERO;
                                    cnt1 < SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
                                    max_lte_cell_entries;
                                    ++cnt1) 
                            {
                                if(!(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
                                            intra_rat_neigh_valid_bitmap &
                                            (OAM_ONE << cnt1)))
                                {
                                    oam_memcpy(&p_son_nrt_info->nr_list.  
                                            intra_rat_nr_list[cnt1],
                                            &LOCAL_NRT_INFO(cell_arr_idx).nr_list.
                                            intra_rat_nr_list[cnt],
                                            sizeof(son_intra_rat_neighbor_info_t));

                                    if(LOCAL_NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list[cnt].earfcn ==
                                            RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx].ran_info.
                                            rf_params.rf_configurations.dl_earfcn)   
                                    {     
                                        nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
                                    }     
                                    else  
                                    {     
                                        nbr_cell_type = OAM_INTER_FREQ_NBR_CELL;
                                    }                                      

                                    if (OAM_FAILURE == oam_dynamic_nbr_cell_access_mode_pci_validation(
                                                nbr_cell_type,
                                                LOCAL_NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list[cnt].earfcn,
                                                &p_son_nrt_info->nr_list.intra_rat_nr_list[cnt1],cell_arr_idx))
                                    {
                                        OAM_LOG(OAM,OAM_DETAILED,
                                                " Neighbor Cell Access Mode Validation could not continue");
                                    }
                                    p_son_nrt_info->nr_list.intra_rat_nr_list[cnt1].bitmask |= 
                                                                                  SON_ACCESS_MODE_PRESENT;
                                    p_son_nrt_info->nr_list.intra_rat_nr_list[cnt1].
                                        bitmask &= ~SON_ENABLE_X2_STATUS_PRESENT;
                                    /* SPR 19343 START */
                                    
									oam_memset(&obj_name,OAM_ZERO, STR_LEN_256);

									g_parameter_map_element = g_param_intra_rat_neigh_list_in_use;
									if(STR_LEN_256 >= length)

										oam_memcpy(&obj_name , NLIU_LTECell_PATH ,oam_strlen(NLIU_LTECell_PATH));

									retVal = oam_handle_nliu_object_addition(obj_name,
											&LOCAL_NRT_INFO(cell_arr_idx).nr_list.intra_rat_nr_list[cnt],
											SON_EUTRAN_CELL,
                                            /* SPR 18930  FIX START */
                                            cell_arr_idx);
                                            /* SPR 18930  FIX END */
									if (retVal == OAM_FAILURE)
									{
										OAM_LOG(OAM,OAM_WARNING, "Error adding NLIU object");
									}
								/*SPR 17423 changes end */

                                    /* SPR 19343 END */
                                        OAM_LOG(OAM, OAM_INFO, "Neighbor added"
                                            " to NeighborListInUse[%d]", cnt1);
                                    
                                    SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
                                     intra_rat_neigh_valid_bitmap |=
                                    (OAM_ONE << cnt1);
                                
                                    ++p_son_nrt_info->nr_list.intra_rat_nr_list_size;
                                    break; 
                                }
                            }
                        }
                        else {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Add operation for NeighborListInUse"
                                    " received for a neighbor that is already in "
                                    " the list.");
                        }
                        break;
                    }
                    /*-SPR 18853 FIX*/
			} 
		} 
	} 

	if(LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list_size) {
		OAM_LOG(OAM, OAM_INFO, "Updating inter-RAT NeighborListInUse.");
		for(cnt = OAM_ZERO;
				cnt < LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list_size;
				++cnt) {
			/* SPR-13586 START */
			/*  coverity 94760 and 94770 fix start */
			/* code removed */
			/*  coverity 94760 and 94770 fix end */
			neigh_idx1 = OAM_ZERO;
/*SPR 22442 Fix Start*/
            if((LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].bitmask &
                        SON_INTER_GERAN_NEIGHBOR)) {

                neigh_idx1 = oam_cgi_search_in_neigh_list(&LOCAL_NRT_INFO(cell_arr_idx).nr_list.
                        inter_rat_nr_list[cnt].geran_neighbor.nbr_cgi,
                        NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list,
                        NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list_size,
                        &SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_gsm_neigh_valid_bitmap,
                        OAM_SON_NEIGH_TYPE_INTER_RAT_GERAN);
            }
/*SPR 22442 Fix End*/

							/* SPR 18930  FIX START */
            if((LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].bitmask &
                        SON_INTER_UTRAN_NEIGHBOR)) {

                neigh_idx = oam_cgi_search_in_neigh_list(&LOCAL_NRT_INFO(cell_arr_idx).nr_list.
                        inter_rat_nr_list[cnt].utran_neighbor.nbr_cgi,
                        NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list,
                        NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list_size,
                        &SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_umts_neigh_valid_bitmap,
                        OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);
            }
							/* SPR 18930  FIX END */

			/* Spr 15595 Fix Start */
			/* Code Moved */
			/* Spr 15595 Fix End */   
			/* SPR-13586 END */
			switch(LOCAL_NRT_INFO(cell_arr_idx).nrt_op) {
				case SON_NRT_OP_DELETE:
					/* SPR-13586 START */
					{   
							/* SPR 18930  FIX START */
						OAM_LOG(OAM, OAM_INFO, "neigh_idx = %d,bitmask = %d ",
                                        neigh_idx,LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].bitmask & SON_INTER_UTRAN_NEIGHBOR);
                        if((neigh_idx != NOT_FOUND)&&
                             (LOCAL_NRT_INFO(cell_arr_idx).nr_list.
                              inter_rat_nr_list[cnt].bitmask &
                              SON_INTER_UTRAN_NEIGHBOR)){
							/* SPR 18930  FIX END */

							if(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									inter_rat_umts_neigh_valid_bitmap &
									(OAM_ONE << neigh_idx))
							{
								SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									inter_rat_umts_neigh_valid_bitmap &=
									~(OAM_ONE << neigh_idx);

								OAM_LOG(OAM, OAM_INFO, "UTRAN Neighbor[%d] deleted "
										"from NeighborListInUse", neigh_idx + OAM_ONE);
								/*SPR 15604 START*/ 
								oam_memset(&obj_name,OAM_ZERO, STR_LEN_256); 

								if(STR_LEN_256 >= length) 

									oam_memcpy(&obj_name , NLIU_UMTS_PATH 
											,oam_strlen(NLIU_UMTS_PATH));

								retVal =
                                            /* SPR 18930  FIX START */
									oam_handle_nliu_object_deletion(obj_name,neigh_idx+1,cell_arr_idx);
                                            /* SPR 18930  FIX END */
								if (retVal == OAM_FAILURE)
								{
									OAM_LOG(OAM,OAM_WARNING, "Error deleting NLIU object");
								}

								/*SPR 15604 END*/  


								--NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list_size;
								/* SPR 15604 START */
								//code remove 
								/*--SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_umts_neigh_size;
								  oam_memset(&SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
								  nrt_info.nr_list.inter_rat_nr_list[neigh_idx].utran_neighbor,
								  OAM_ZERO,
								  sizeof(son_utran_neighbor_info_t));
								  SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].nrt_info.nr_list.
								  inter_rat_nr_list[neigh_idx].bitmask &= ~SON_INTER_UTRAN_NEIGHBOR;*/
								/*SPR 15604 END*/
							}
						}
                        /* SPR 12542/SES-483 Fix Start */
						if((neigh_idx1 != NOT_FOUND) && 
                                (LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].bitmask & SON_INTER_GERAN_NEIGHBOR)){ 
                            /* SPR 12542/SES-483 Fix End */
							if(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									inter_rat_gsm_neigh_valid_bitmap &
									(OAM_ONE << neigh_idx1))
							{
								SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									inter_rat_gsm_neigh_valid_bitmap &=
									~(OAM_ONE << neigh_idx1);
								OAM_LOG(OAM, OAM_INFO, "GSM Neighbor[%d] deleted "
										"from NeighborListInUse", neigh_idx1 + OAM_ONE);
								--NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list_size;
								--SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_gsm_neigh_size;
								oam_memset(&SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
										nrt_info.nr_list.inter_rat_nr_list[neigh_idx1].geran_neighbor,
										OAM_ZERO,
										sizeof(son_geran_neighbor_info_t));
								SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].nrt_info.nr_list.
									inter_rat_nr_list[neigh_idx1].bitmask &= ~SON_INTER_GERAN_NEIGHBOR;
							}
						}
						else
						{
							OAM_LOG(OAM, OAM_WARNING, "Delete operation for "
									"NeighborListInUse received for a GSM neighbor "
									"that is not in the list.");
						}
						break;
					}
					/* SPR-13586 END */         

				case SON_NRT_OP_UPDATE:
					if(neigh_idx != NOT_FOUND) { 
						/* SPR-13586 START */
						if(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
								inter_rat_umts_neigh_valid_bitmap &
								(OAM_ONE << neigh_idx))
						{
							/* Spr 15438 Fix Start */
							g_parameter_map_element =
								g_param_inter_rat_neigh_list_in_use;
							/* Spr 15438 Fix Start */
							oam_update_inter_rat_nr(
									&NRT_INFO(cell_arr_idx).nr_list.
									inter_rat_nr_list[neigh_idx].utran_neighbor,
									&LOCAL_NRT_INFO(cell_arr_idx).nr_list.
									inter_rat_nr_list[cnt].utran_neighbor);
							/*SPR 15604 START*/
							oam_memset(&obj_name,OAM_ZERO, STR_LEN_256); 
							oam_memcpy(&obj_name , NLIU_UMTS_PATH ,oam_strlen(NLIU_UMTS_PATH));
							g_parameter_map_element =
								g_param_inter_rat_neigh_list_in_use;
							retVal = (oam_return_et)oam_handle_nliu_object_updation(/*cov 94799 +-*/
									(void *)&NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[neigh_idx].utran_neighbor,
									(void *)&LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].utran_neighbor,
									neigh_idx + 1,
                                    /* SPR 18930  FIX START */
									SON_UTRAN_CELL,
                                    cell_arr_idx);
                            /* SPR 18930  FIX END */

							if (retVal == OAM_FAILURE)
							{
								OAM_LOG(OAM,OAM_WARNING, "Error persisting NLIU parameters ");
								/*Alarm to be raised on object failure*/
							}
							/*SPR 15604 END*/
							OAM_LOG(OAM, OAM_INFO, "UTRAN Neighbor[%d] updated "
									"from NeighborListInUse", neigh_idx);
						}
					}
					/*SPR 22442 Fix Start*/
					if(neigh_idx1 != NOT_FOUND) { 
					/*SPR 22442 Fix End*/
					/*Cov 94770 fix start*/
					if(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
							inter_rat_gsm_neigh_valid_bitmap &
							(OAM_ONE << neigh_idx1))
					{
						oam_update_inter_rat_gsm_nr(
								&NRT_INFO(cell_arr_idx).nr_list.
								inter_rat_nr_list[neigh_idx1].geran_neighbor,
								&LOCAL_NRT_INFO(cell_arr_idx).nr_list.
								inter_rat_nr_list[cnt].geran_neighbor);

						OAM_LOG(OAM, OAM_INFO, "GSM Neighbor[%d] updated "
								"from NeighborListInUse", neigh_idx1);
					}
					/*Cov 94770 fix end*/
					else
					{     
						OAM_LOG(OAM, OAM_WARNING,
								"Update operation for NeighborListInUse"
								" received for a GSM neighbor that is not in "
								" the list.");
					}
					/* SPR-13586 END */
					/*SPR 22442 Fix Start*/
					}
					/*SPR 22442 Fix End*/
					break;

				case SON_NRT_OP_ADD:
					/* SPR-13586 START */
					if(LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].bitmask & SON_INTER_UTRAN_NEIGHBOR)
					{    
						if(neigh_idx == NOT_FOUND) {
							/* Spr 15612  Fix Start*/

							/* there is NO matching CGI in NLIU*/
							is_nr_add_req_at_son = OAM_TRUE;

							/*SPR 15604 START*/
                                            /* SPR 18930  FIX START */
							neigh_idx_in_nr = oam_cgi_search_in_neigh_list(
									&p_local_son_nrt_info->nr_list.inter_rat_nr_list[cnt].utran_neighbor.
									nbr_cgi,
									p_son_nr_add->nr_list.inter_rat_nr_list,
									p_son_nr_add->nr_list.inter_rat_nr_list_size,
									&p_cell_neigh_info->inter_rat_umts_entry_bitmap,
									OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);
							/*SPR 15929 changes start*/
							/* SPR-17833 START */
							/* code deleted */
							/* SPR-17833 END */
							if(neigh_idx_in_nr != NOT_FOUND)
							{
								if((p_cell_neigh_info->utran_nbr_ctxt[neigh_idx_in_nr].enable == OAM_TRUE)&&
										(p_cell_neigh_info->utran_nbr_ctxt[neigh_idx_in_nr].must_include == OAM_FALSE))
								{
									OAM_LOG(OAM,OAM_DETAILED,"UTRAN Neighbour Detected by SON is present in NR Configuration"
											" With MustInclude = FALSE. Not adding in NLIU");
									break;
								}
								else if ((p_cell_neigh_info->utran_nbr_ctxt[neigh_idx_in_nr].enable == OAM_TRUE)&&
										(p_cell_neigh_info->utran_nbr_ctxt[neigh_idx_in_nr].must_include == OAM_TRUE))
								{
									/* Neighbour Added By OAM itself */
									is_nr_add_req_at_son = OAM_FALSE;

								}

							}
                                            /* SPR 18930  FIX END */
							else
							{
								/* Detected Neighbour */
								OAM_LOG(OAM,OAM_DETAILED,"UTRAN Neighbour Detected by SON");
							}
							/* SPR-17833 START */
							/* code deleted */
							/* SPR-17833 END */
							/*SPR 15604 END */
							/* Spr 15612  Fix End*/

							for(cnt1 = OAM_ZERO;
									cnt1 < SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									max_umts_entries;
									++cnt1) {

								if(!(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
											inter_rat_umts_neigh_valid_bitmap &
											(OAM_ONE << cnt1)))
								{
									oam_memcpy(&NRT_INFO(cell_arr_idx).nr_list.
											inter_rat_nr_list[cnt1].utran_neighbor,
											&LOCAL_NRT_INFO(cell_arr_idx).nr_list.
											inter_rat_nr_list[cnt].utran_neighbor,
											sizeof(son_utran_neighbor_info_t)); 
									/*SPR 15604 START*/ 
									if(neigh_idx_in_nr == NOT_FOUND)
									{
										NR_LIST_IN_USE(cell_arr_idx).
											is_detected_utran_neighbour[cnt1]= OAM_TRUE;
									}
									oam_memset(&obj_name,OAM_ZERO, STR_LEN_256); 

									if(STR_LEN_256 >= length) 


										oam_memcpy(&obj_name , 
												NLIU_UMTS_PATH ,
												oam_strlen(NLIU_UMTS_PATH));

									g_parameter_map_element =
										g_param_inter_rat_neigh_list_in_use;
									retVal = oam_handle_nliu_object_addition(obj_name,
											&NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt1].utran_neighbor,
                                            /* SPR 18930  FIX START */
											SON_UTRAN_CELL,cell_arr_idx);
                                            /* SPR 18930  FIX END */
									if (retVal == OAM_FAILURE)
									{
										OAM_LOG(OAM,OAM_WARNING, "Error adding NLIU object");
									}
									/*SPR 15604 END*/  


									NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt1].bitmask |= SON_INTER_UTRAN_NEIGHBOR; 
									OAM_LOG(OAM, OAM_INFO, "UTRAN Neighbor added"
											" to NeighborListInUse[%d]", cnt1);
									++NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list_size;
									/*SPR 15604 START*/
									  //++SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_umts_neigh_size;
										 SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
										 inter_rat_umts_neigh_valid_bitmap |=
										 (OAM_ONE << cnt1);
									/*SPR 15604 END*/      

									/* Spr 15612  Fix Start*/
									if(is_nr_add_req_at_son == OAM_TRUE)
									{
										SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
											is_detected_utran_neighbour[cnt1]= OAM_TRUE;

										p_req->nr_list.inter_rat_nr_list[num_inter_neigh].bitmask |=
											SON_INTER_UTRAN_NEIGHBOR;

										/* SPR-16495 START */
										oam_memcpy(&(p_req->nr_list.inter_rat_nr_list[num_inter_neigh ++].utran_neighbor),
												&(p_local_son_nrt_info->nr_list.inter_rat_nr_list[cnt].utran_neighbor),
												sizeof(son_utran_neighbor_info_t));
										/* SPR-16495 START */
									}
									/* Spr 15612  Fix End*/

									/* SPR-13586 END */
									break;
								}
							}

							if(cnt1 == SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									max_umts_entries) {
								OAM_LOG(OAM, OAM_WARNING,
										"Add operation for NeighborListInUse"
										" received but the NeighborListInUse has"
										" been exhausted.");
							}
						}
						else {
							OAM_LOG(OAM, OAM_WARNING,
									"Add operation for NeighborListInUse"
									" received for a UTRAN neighbor that is already in "
									" the list.");
						}
						/* SPR-13586 START */
					}
					if(LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].bitmask & SON_INTER_GERAN_NEIGHBOR)
					{
						if(neigh_idx1 == NOT_FOUND) {
							for(cnt1 = OAM_ZERO;
									cnt1 < SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									max_gsm_entries;
									++cnt1) {

								if(!(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
											inter_rat_gsm_neigh_valid_bitmap &
											(OAM_ONE << cnt1)))
								{
									oam_memcpy(&NRT_INFO(cell_arr_idx).nr_list.
											inter_rat_nr_list[cnt1].geran_neighbor,
											&LOCAL_NRT_INFO(cell_arr_idx).nr_list.
											inter_rat_nr_list[cnt].geran_neighbor,
											sizeof(son_geran_neighbor_info_t));
									NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt1].bitmask |= SON_INTER_GERAN_NEIGHBOR; 
									OAM_LOG(OAM, OAM_INFO, "GSM Neighbor added"
											" to NeighborListInUse[%d]", cnt1);
									++NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list_size;
									++SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_gsm_neigh_size;

									SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
										inter_rat_gsm_neigh_valid_bitmap |=
										(OAM_ONE << cnt1);

									break;
								}
							}

							if(cnt1 == SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
									max_gsm_entries) {
								OAM_LOG(OAM, OAM_WARNING,
										"Add operation for NeighborListInUse"
										" received but the NeighborListInUse has"
										" been exhausted.");
							}
						}
						else {
							OAM_LOG(OAM, OAM_WARNING,
									"Add operation for NeighborListInUse"
									" received for a GSM neighbor that is already in "
									" the list.");
						}
					}    
					break;
                    /*+SPR 18853 FIX*/
                case SON_NRT_NMM_OP_ADD : 
                    {
                        if(neigh_idx == NOT_FOUND) {
                            neigh_idx_in_nr = oam_cgi_search_in_neigh_list(
                                    &p_local_son_nrt_info->nr_list.inter_rat_nr_list[cnt].utran_neighbor.
                                    nbr_cgi,
                                    p_son_nr_add->nr_list.inter_rat_nr_list,
                                    p_son_nr_add->nr_list.inter_rat_nr_list_size,
                                    &p_cell_neigh_info->inter_rat_umts_entry_bitmap,
                                    OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);

                            if(neigh_idx_in_nr != NOT_FOUND)
                            {
                                if((p_cell_neigh_info->utran_nbr_ctxt[neigh_idx_in_nr].must_include == OAM_FALSE)&&
                                        (p_cell_neigh_info->utran_nbr_ctxt[neigh_idx_in_nr].enable == OAM_TRUE))
                                {
                                    OAM_LOG(OAM,OAM_DETAILED,"Neighbour Detected by SON is present in NR Configuration"
                                            " With MustInclude = FALSE. Not adding in NLIU");
                                    break;
                                }
                            }
                            /* SPR 19343 START */
                            else
                            {
                                /* Detected Neighbour */
                                OAM_LOG(OAM,OAM_DETAILED,"UTRAN Neighbour Detected by SON");
                            }
                            /* SPR 19343 END */

                            for(cnt1 = OAM_ZERO;
                                    cnt1 < SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
                                    max_umts_entries;
                                    ++cnt1) 
                            {
                                if(!(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
                                            inter_rat_umts_neigh_valid_bitmap &
                                            (OAM_ONE << cnt1)))
                                {

                                    /* Spr 15595 Fix Start */
                                    oam_memcpy(&p_son_nrt_info->nr_list.  //local
                                            inter_rat_nr_list[cnt1],
                                            &LOCAL_NRT_INFO(cell_arr_idx).nr_list.
                                            inter_rat_nr_list[cnt],
                                            sizeof(son_inter_rat_neighbor_info_t));
                                    /* SPR 19343 START */
                                    oam_memset(&obj_name,OAM_ZERO, STR_LEN_256); 

                                    if(STR_LEN_256 >= length) 


                                        oam_memcpy(&obj_name , 
                                                NLIU_UMTS_PATH ,
                                                oam_strlen(NLIU_UMTS_PATH));

                                    g_parameter_map_element =
                                        g_param_inter_rat_neigh_list_in_use;
                                    retVal = oam_handle_nliu_object_addition(obj_name,
                                            &NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt1].utran_neighbor,
                                            /* SPR 18930  FIX START */
                                            SON_UTRAN_CELL,cell_arr_idx);
                                    /* SPR 18930  FIX END */
                                    if (retVal == OAM_FAILURE)
                                    {
                                        OAM_LOG(OAM,OAM_WARNING, "Error adding NLIU object");
                                    }
                                    /* SPR 19343 END */
                                    /*SPR 15799 START*/
                                    p_son_nrt_info->nr_list.inter_rat_nr_list[cnt1].
                                        bitmask &= ~SON_ENABLE_X2_STATUS_PRESENT;
                                    /*SPR 15799 END*/
                                    if(LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].utran_neighbor.uarfcn ==
                                            RRM_PROV_REQ.oam_rrm_cell_config_req[cell_arr_idx].ran_info.
                                            rf_params.rf_configurations.dl_earfcn)   
                                    {     
                                        nbr_cell_type = OAM_INTER_FREQ_NBR_CELL;
                                    }     
                                    else  
                                    {     
                                        nbr_cell_type = OAM_INTRA_FREQ_NBR_CELL;
                                    }                                      

                                    if (OAM_FAILURE == oam_dynamic_nbr_cell_access_mode_pci_validation(
                                                nbr_cell_type,
                                                LOCAL_NRT_INFO(cell_arr_idx).nr_list.inter_rat_nr_list[cnt].utran_neighbor.uarfcn,
                                                &p_req->nr_list.intra_rat_nr_list[cnt1], cell_arr_idx))
                                        //neigh_idx_in_nr-1))
                                    {
                                        OAM_LOG(OAM,OAM_DETAILED,
                                                " Neighbor Cell Access Mode Validation could not continue");
                                    }
                                    p_req->nr_list.inter_rat_nr_list[cnt1].utran_neighbor.bitmask |= 
                                        SON_ACCESS_MODE_PRESENT;

                                    OAM_LOG(OAM, OAM_INFO, "UTRAN Neighbor added"
                                            " to NeighborListInUse[%d]", cnt1);
                                    ++p_son_nrt_info->nr_list.inter_rat_nr_list_size;

                                    SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
                                        inter_rat_umts_neigh_valid_bitmap |=
                                        (OAM_ONE << cnt1);
                                    break; 
                                }
                            }
                        }
                        else {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Add operation for NeighborListInUse"
                                    " received for a neighbor that is already in "
                                    " the list.");
                        }
                        break;
                    }
                    /*-SPR 18853 FIX*/
			} 
		} 
	} 
	/* Spr 15612  Fix Start*/
	/* Spr 15438 Fix Start */
	p_enb_add_req->nbr_enb_list_size = nr_enb_count; 

	/* SPR 17452 changes removed */
	p_req->nr_list.intra_rat_nr_list_size = num_intra_neigh;
	p_req->nr_list.inter_rat_nr_list_size = num_inter_neigh;

#ifdef LTE_EMBMS_SUPPORTED
    /* SPR 19065 Fix Start */
    for(nbr_count = 0 ; (nbr_count < p_req->nr_list.intra_rat_nr_list_size) &&
            ( OAM_FALSE == nbr_found_in_same_enb); nbr_count++)
    {
        //NBR cell id
        oam_memcpy(nbr_cell_id,
                p_req->nr_list.intra_rat_nr_list[nbr_count].nbr_cgi.cell_identity,
                SON_CELL_ID_OCTET_SIZE);
        //NBR PLMN_INFO 
        oam_memcpy(nbr_plmn_id.mcc,
                p_req->nr_list.intra_rat_nr_list[nbr_count].nbr_cgi.plmn_id.mcc,
                MAX_MCC_DIGITS);
        nbr_plmn_id.num_mnc_digit = p_req->nr_list.intra_rat_nr_list[nbr_count].nbr_cgi.plmn_id.
            num_mnc_digit;
        oam_memcpy(nbr_plmn_id.mnc,
                p_req->nr_list.intra_rat_nr_list[nbr_count].nbr_cgi.plmn_id.mnc,
                MAX_MNC_DIGITS);
        /* Comparing Neighbour Cell_Id and PLMN_INFO with
         * Cells Configured in the eNB . */
        for (srv_count = 0; srv_count < oam_prov_req.num_cells_configured; ++srv_count)
        {
            cid_mbms_arr_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.cell_ctxt_status[srv_count].cid);
            p_mbms_cell_config = &RRM_CELL_CONFIG(cid_mbms_arr_idx);
            if((OAM_ZERO == (oam_memcmp(&nbr_plmn_id,&(p_mbms_cell_config->global_cell_info.eutran_global_cell_id.primary_plmn_id),
                                sizeof(rrm_oam_cell_plmn_info_t))) )&&
                    (OAM_ZERO == (oam_memcmp(nbr_cell_id, p_mbms_cell_config->global_cell_info.eutran_global_cell_id.cell_identity,
                                             MAX_CELL_IDENTITY_OCTETS)))
              )
            {
                nbr_found_in_same_enb = OAM_TRUE;
                break;
            }
        }
        /* If Neighbour Found in eNB, then copy mbms_config data for SON */
        if(OAM_TRUE == nbr_found_in_same_enb)
        {
            p_req->nr_list.intra_rat_nr_list[nbr_count].bitmask |= SON_EMBMS_MBMSFN_INFO_PRESENT;
            p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.num_mbsfn=
                p_mbms_cell_config->ran_info.physical_layer_params.mbsfn_subframe_config_list.count;

            for(num_mbsfn_count = 0 ; num_mbsfn_count < p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.num_mbsfn;
                    num_mbsfn_count++)
            {
                p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.mbsfn_info[num_mbsfn_count].radioframe_alloc_period = 
                    (son_u8)p_mbms_cell_config->ran_info.physical_layer_params.mbsfn_subframe_config_list.
                    mbsfn_subframe_config_info[num_mbsfn_count].radio_frame_allocation_period;
                p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.mbsfn_info[num_mbsfn_count].radioframe_alloc_offset = 
                    (son_u8)p_mbms_cell_config->ran_info.physical_layer_params.mbsfn_subframe_config_list. 
                    mbsfn_subframe_config_info[num_mbsfn_count].radio_frame_allocation_offset;
                p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.mbsfn_info[num_mbsfn_count].subframe_alloc.bitmask = 0x00;
                if( p_mbms_cell_config->ran_info.physical_layer_params.mbsfn_subframe_config_list.
                        mbsfn_subframe_config_info[num_mbsfn_count].subframe_allocation.sf_alloc_choice )
                {
                    p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.mbsfn_info[num_mbsfn_count].subframe_alloc.bitmask |= 
                        SON_SUBFRAME_ALLOC_FOUR_FRAME_INFO_PRESENT;
                    oam_memcpy(p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.mbsfn_info[num_mbsfn_count].subframe_alloc.fourframe,
                            p_mbms_cell_config->ran_info.physical_layer_params.mbsfn_subframe_config_list.
                            mbsfn_subframe_config_info[num_mbsfn_count].subframe_allocation.subframe_allocation, SON_SUBFRAME_ALLOC_FOUR_FRAME_OCTET_SIZE);
                }
                else
                {
                    p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.mbsfn_info[num_mbsfn_count].subframe_alloc.bitmask |= 
                        SON_SUBFRAME_ALLOC_ONE_FRAME_INFO_PRESENT;
                    oam_memcpy(p_req->nr_list.intra_rat_nr_list[nbr_count].mbms_config.mbsfn_info[num_mbsfn_count].subframe_alloc.oneframe,
                            p_mbms_cell_config->ran_info.physical_layer_params.mbsfn_subframe_config_list.
                            mbsfn_subframe_config_info[num_mbsfn_count].subframe_allocation.subframe_allocation,
                            SON_SUBFRAME_ALLOC_ONE_FRAME_OCTET_SIZE);

                }
            }

        }
    }
    /* SPR 19065 Fix End */
#endif

/* SPR 18930  FIX START */
    if(FIRST_NR_ADD_REQ_TO_BE_SENT == SON_NEIGHBORLIST_INFO(cell_arr_idx).first_nr_add_state)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Neighbour Detected by SON before first NR ADD REQ sent"
                " nbr cell shall be persisted and added to first nr add req list");
    }
    else
    {
        if (num_intra_neigh||num_inter_neigh)
        {
            UInt16 trans_id = oam_get_new_trans_id();
            if (OAM_FAILURE == oam_son_send_son_oam_nr_add_req(p_req, 
                        OAM_MODULE_ID, 
                        SON_MODULE_ID,
                        trans_id,
                        cell_arr_idx))
            {
                OAM_LOG(OAM, OAM_ERROR,"Failed to Send SON_OAM_NR_ADD_REQ for Detected Neighbour");

            }
            else
            {
                OAM_LOG(OAM, OAM_DETAILED,"Successfully Sent SON_OAM_NR_ADD_REQ for Detected Neighbour");
                /* SPR 18930  FIX END */
                oam_save_nr_add_req_with_trans_id(p_req,trans_id,cell_arr_idx);
                /* SPR 18930  FIX START */
                /*SPR 18071, 17981 START*/
                oam_memcpy(p_local_son_nr_add,p_req,sizeof(oam_son_nr_add_req_t));
                /*SPR 18071, 17981 END*/
            } 
        }
        /* Spr 15438 Fix End */
        /*SPR 15799 START*/ 
        if(nr_enb_count)
        {  
            UInt16 trans_id = oam_get_new_trans_id();
            if (OAM_FAILURE == oam_son_send_son_oam_nr_enb_add_req(p_enb_add_req, 
                        OAM_MODULE_ID,
                        SON_MODULE_ID,
                        trans_id,
                        oam_prov_req.cell_cntxt.curr_cell_cid)) 
            {     
                OAM_LOG(OAM, OAM_ERROR, "Failed to send SON_OAM_NR_ENB_ADD_REQ");
            }     
            else  
            {     
                OAM_LOG(OAM, OAM_DETAILED, "Successfully sent SON_OAM_NR_ENB_ADD_REQ for detected neighbour");
            }        
        }   
    }
	/*SPR 15799 END*/
	/* Spr 15612  Fix End*/

	/*SPR 15604 START*/   
	local_prov_req.oam_son_req.nr_action = OAM_NR_NO_ACTION;
	oam_prov_req.system_status.event_ongoing &= ~OAM_NLIU_UPDATION_ONGOING;
	/* SPR-17833 START */
	/* code deleted */
	/* SPR-17833 END */
	/*SPR 15929 changes end*/
	/* SPR 15604 END */



	oam_memset(&LOCAL_NRT_INFO(OAM_ZERO), OAM_ZERO, sizeof (oam_son_anr_updated_nrt_info_t));
	oam_memset(&LOCAL_NRT_INFO(OAM_ONE), OAM_ZERO, sizeof (oam_son_anr_updated_nrt_info_t));
	/* SPR-13586 END */

	/* Coverity ID : 96941 Fix Start*/
	oam_mem_free(p_req, &err);
	/* Coverity ID : 96941 Fix End*/


	OAM_FUN_EXIT_TRACE();
	return retVal; 
	/*End: SPR 10567 */
}
/******************************************************************************
 * Function Name  : oam_son_update_meas_config_data
 * Inputs         : p_data
 * Outputs        : none
 * Returns        : None
 * Description    :
 *******************************************************************************/
	oam_return_et
oam_son_update_meas_config_data(oam_son_anr_meas_config_res_t *p_data)
{

	OAM_FUN_ENTRY_TRACE();
	UInt32 meas_bit = 1;
	/* SPR 13177 Fix Start */
	oam_return_et retVal = OAM_SUCCESS;
	/* SPR 13177 Fix End */
	/* RT SPR 8154 FIX START */
	UInt16 loop = OAM_ZERO, index = 0;
	/* RT SPR 8154 FIX END */
	SInt16 arfcn_found = OAM_ZERO;
	UInt32 bitmask = OAM_ZERO;
	UInt8 cid = OAM_ZERO;
	/* RT SPR 8154 FIX START */
	UInt32 usr_req_resp = oam_prov_req.system_status.event_ongoing &
		USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;

	oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params = OAM_NULL;
	oam_son_inter_freq_carrier_t *p_local_son_inter_freq_carr_params = OAM_NULL;
	oam_son_anr_meas_config_req_t *p_local_anr_meas_config_req = OAM_NULL;
	oam_son_anr_meas_config_req_t *p_anr_meas_config_req = OAM_NULL;
	/* SPR 13177 Fix Start */
	rrm_oam_inter_frequency_params_list_t *p_rrm_cell_config_inter_freq_param =OAM_NULL; 
	/* SPR 13177 Fix End */
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	/* RT SPR 12097 Fix Start */
	SInt8 cell_config_idx_rrm = OAM_ERROR_RETURN_VAL;
	/* RT SPR 12097 Fix End*/

	if(OAM_NULL == p_data) {
		OAM_LOG(OAM, OAM_WARNING, "Null pointer passed.");
		OAM_FUN_ENTRY_TRACE();
		return OAM_FAILURE;
	}

	cid = oam_extract_cid_from_eutran_cellidentity(
			p_data->src_cgi.cell_identity);

	cell_config_idx = oam_get_son_inter_freq_carrier_idx(cid);

	/* RT SPR 12097 Fix Start */
	cell_config_idx_rrm = oam_get_rrm_cell_config_idx(cid);

	if((OAM_ERROR_RETURN_VAL == cell_config_idx)
			||(OAM_ERROR_RETURN_VAL == cell_config_idx_rrm))
		/* RT SPR 12097 Fix End*/
	{
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d], son_inter_freq_carrier_idx=[%d], rrm_cell_config_idx=[%d]",
                         cid, cell_config_idx, cell_config_idx_rrm);
		return OAM_FAILURE;
	}
	/* SPR 13177 Fix Start */
	p_rrm_cell_config_inter_freq_param  = &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx_rrm].ran_info.mobility_params.idle_mode_mobility_params.idle_mode_inter_freq_params_list;
	/* SPR 13177 Fix End */
	p_son_inter_freq_carr_params = &SON_INTER_FREQ_CARR_PARAMS(cell_config_idx);
	p_local_son_inter_freq_carr_params = 
		&LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx);
	p_local_anr_meas_config_req =
		&LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_config_idx);
	p_anr_meas_config_req = &SON_ANR_MEAS_CONFIG_REQ(cell_config_idx);

	/* RT SPR 8154 FIX END */
	UInt8 idx = p_local_son_inter_freq_carr_params->query_index;

	/* RT SPR 8154 FIX START */
	if(!usr_req_resp) {
		/* The response is not due to user request.
		 * ANR_MEAS_CONFIG request is sent from OAM itself when cell setup
		 * is complete.
		 */

		/* Set the corresponding neighbor entry valid bit */
		while (loop < p_anr_meas_config_req->eutran_config_list_size) {
			p_son_inter_freq_carr_params->
				eutran_meas_entry_bitmap |= (meas_bit << loop++);
		}

		loop = OAM_ZERO;
		while (loop < p_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_fdd_list_size) {
			p_son_inter_freq_carr_params->
				utran_fdd_meas_entry_bitmap |= (meas_bit << loop++);
		}

		/* RT SPR 9019 FIX START */
		loop = OAM_ZERO;
		while (loop < p_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_tdd_list_size) {
			p_son_inter_freq_carr_params->
				utran_tdd_meas_entry_bitmap |= (meas_bit << loop++);
		}
		/* RT SPR 9019 FIX END */


		loop = OAM_ZERO;
		while (loop < p_anr_meas_config_req->other_rat_config_list.
				geran_config_list.geran_freq_info_list_size) {
			p_son_inter_freq_carr_params->
				geran_meas_entry_bitmap |= (meas_bit << loop++);
		}

		OAM_FUN_ENTRY_TRACE();
		return OAM_SUCCESS;
	}

	oam_prov_req.system_status.event_ongoing &=
		~USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
	/* RT SPR 8154 FIX END */

	if (p_local_anr_meas_config_req->eutran_config_list_size) {
		OAM_LOG(OAM, OAM_DETAILED, "Updating EUTRAN meas config data");
		arfcn_found =
			oam_arfcn_search_in_meas_config_list(
					/* RT SPR 8154 FIX START */
					&p_local_anr_meas_config_req->eutran_config_list[idx].earfcn,
					/* RT SPR 8154 FIX END */
					p_anr_meas_config_req->eutran_config_list,
					p_anr_meas_config_req->eutran_config_list_size,
					&p_son_inter_freq_carr_params->eutran_meas_entry_bitmap,
					OAM_SON_MEAS_CONFIG_TYPE_EUTRAN);

        /* SPR 14651 START */
        /* Updating Meas Enable Data */
        if(p_local_son_inter_freq_carr_params->
              eutran_meas_enable[idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
        {
            p_son_inter_freq_carr_params->
                eutran_meas_enable[idx].enable =
                p_local_son_inter_freq_carr_params->
                eutran_meas_enable[idx].enable;

            p_son_inter_freq_carr_params->
                eutran_meas_enable[idx].
                bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
        }
        /* SPR 14651 END */

		if(NOT_FOUND == arfcn_found) {
			OAM_LOG(OAM, OAM_DETAILED, "Adding a new meas config record");
			oam_memcpy(&p_anr_meas_config_req->eutran_config_list[idx],
					&p_local_anr_meas_config_req->eutran_config_list[idx],
					sizeof(son_meas_config_eutran_t));
            /* SPR 14651 START */
			//++p_anr_meas_config_req->eutran_config_list_size;
            /* SPR 14651 END */
			/* SPR 13177 Fix start */
			index = p_rrm_cell_config_inter_freq_param->num_valid_inter_freq_list;

			p_rrm_cell_config_inter_freq_param->idle_mode_mobility_inter_freq_params[index].
				eutra_carrier_arfcn =
				p_local_anr_meas_config_req->eutran_config_list[idx].earfcn;

			p_rrm_cell_config_inter_freq_param->num_valid_inter_freq_list++;


			/* SPR 13177 Fix end */


			p_son_inter_freq_carr_params->
				eutran_meas_entry_bitmap |= (meas_bit << idx);  
		}
		else {
			OAM_LOG(OAM, OAM_DETAILED,
					"Updating an existing meas config record");
			bitmask =
				p_local_anr_meas_config_req->eutran_config_list[idx].bitmask;

			if(bitmask & SON_MC_EUTRAN_ALLOW_MEAS_BW_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_ALLOW_MEAS_BW_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].
					meas_bandwidth_for_earfcn =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					meas_bandwidth_for_earfcn;
			}

			if(bitmask & SON_MC_EUTRAN_PRESENCE_ANTENNA_PORT_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_PRESENCE_ANTENNA_PORT_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].
					presence_antenna_port =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					presence_antenna_port;
			}

			if(bitmask & SON_MC_EUTRAN_NBR_CELL_CONFIG_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_NBR_CELL_CONFIG_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].
					neighbor_cell_config =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					neighbor_cell_config;
			}

			if(bitmask & SON_MC_EUTRAN_OFFSET_FREQ_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_OFFSET_FREQ_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].
					offset_frequency =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					offset_frequency;
			}

			if(bitmask & SON_MC_EUTRAN_Q_RX_LEV_MIN_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_Q_RX_LEV_MIN_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].
					q_rx_lev_min =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					q_rx_lev_min;
			}

			if(bitmask & SON_MC_EUTRAN_P_MAX_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_P_MAX_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].p_max =
					p_local_anr_meas_config_req->eutran_config_list[idx].p_max;
			}

			if(bitmask & SON_MC_EUTRAN_RESELECTION_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_RESELECTION_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].t_reselection =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					t_reselection;
			}

			if(bitmask & SON_MC_EUTRAN_RESELECTION_SF_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_RESELECTION_SF_PRESENT;

				oam_memcpy(&p_anr_meas_config_req->eutran_config_list[idx].
						t_reselection_sf,
						&p_local_anr_meas_config_req->eutran_config_list[idx].
						t_reselection_sf,
						sizeof(son_speed_state_scale_factors_t));
			}

			if(bitmask & SON_MC_EUTRAN_CELL_THRESH_HIGH_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_CELL_THRESH_HIGH_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].threshX_high =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					threshX_high;
			}

			if(bitmask & SON_MC_EUTRAN_CELL_THRESH_LOW_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_CELL_THRESH_LOW_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].threshX_low =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					threshX_low;
			}

			if(bitmask & SON_MC_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].
					cell_reselection_priority =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					cell_reselection_priority;
			}

			if(bitmask & SON_MC_EUTRAN_Q_QUAL_MIN_R9) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_Q_QUAL_MIN_R9;

				p_anr_meas_config_req->eutran_config_list[idx].q_qualmin_r9 =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					q_qualmin_r9;
			}

			if(bitmask & SON_MC_EUTRAN_THRESHX_HIGH_Q_R9) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_THRESHX_HIGH_Q_R9;

				p_anr_meas_config_req->eutran_config_list[idx].
					threshx_highq_r9 =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					threshx_highq_r9;
			}

			if(bitmask & SON_MC_EUTRAN_THRESHX_LOW_Q_R9) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_THRESHX_LOW_Q_R9;

				p_anr_meas_config_req->eutran_config_list[idx].
					threshx_lowq_r9 =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					threshx_lowq_r9;
			}

			if(bitmask & SON_MC_EUTRAN_CM_OFFSET_FREQ_PRESENT) {
				p_anr_meas_config_req->eutran_config_list[idx].bitmask |=
					SON_MC_EUTRAN_CM_OFFSET_FREQ_PRESENT;

				p_anr_meas_config_req->eutran_config_list[idx].
					cm_offset_frequency =
					p_local_anr_meas_config_req->eutran_config_list[idx].
					cm_offset_frequency;
			}
		}
	}
	else if (p_local_anr_meas_config_req->other_rat_config_list.
			utran_config_list.utran_fdd_list_size) {
		OAM_LOG(OAM, OAM_DETAILED, "Updating UTRAN meas config fdd data");
		arfcn_found =
			oam_arfcn_search_in_meas_config_list(
					/* RT SPR 8154 FIX START */
					&p_local_anr_meas_config_req->other_rat_config_list.
					/* RT SPR 8154 FIX END */
					utran_config_list.utran_fdd_list[idx].uarfcn,
					p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list,
					p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list_size,
					/* RT SPR 9019 FIX START */
					&p_son_inter_freq_carr_params->
					utran_fdd_meas_entry_bitmap,
					/* RT SPR 9019 FIX END */
					OAM_SON_MEAS_CONFIG_TYPE_UTRAN_FDD);

                    /* SPR 14651 START */
                    /* Updating Meas Enable Data */
                    if(p_local_son_inter_freq_carr_params->
                        utran_meas_enable[idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
                    {
                        p_son_inter_freq_carr_params->
                            utran_meas_enable[idx].enable =
                            p_local_son_inter_freq_carr_params->
                            utran_meas_enable[idx].enable;

                        p_son_inter_freq_carr_params->
                            utran_meas_enable[idx].
                            bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
                    }
                    /* SPR 14651 END */

		if(NOT_FOUND == arfcn_found) {
			OAM_LOG(OAM, OAM_DETAILED, "Adding a new meas config fdd record");
			oam_memcpy(&p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx],
					&p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx],
					sizeof(son_meas_config_utran_fdd_t));

            /* SPR 14651 START */
			//++p_anr_meas_config_req->other_rat_config_list.utran_config_list.
				//utran_fdd_list_size;
            /* SPR 14651 END */
			p_son_inter_freq_carr_params->
				utran_fdd_meas_entry_bitmap |= (meas_bit << idx);  
			/* SPR 9969 Fix Start */
			/* RT SPR 12097 Fix Start */
			index = (++RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx_rrm].ran_info.
					mobility_params.idle_mode_mobility_params.
					idle_mode_mobility_inter_rat_utra_params.
					irat_eutran_to_utran_fdd_list.
					num_irat_eutran_to_utran_fdd_carriers);

			RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx_rrm].ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_inter_rat_utra_params.
				irat_eutran_to_utran_fdd_list.
				irat_eutran_to_utran_fdd_carriers[index - 1].
				utra_carrier_arfcn =
				p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_fdd_list[idx].uarfcn;
			/* RT SPR 12097 Fix Start */

			/* SPR 9969 Fix End */
		}
		else {
			OAM_LOG(OAM, OAM_DETAILED,
					"Updating an existing meas config record");
			bitmask =
				p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_fdd_list[idx].bitmask;

			if(bitmask & SON_MC_UTRAN_FDD_OFFSET_FREQ_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_FDD_OFFSET_FREQ_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].offset_frequency =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].offset_frequency;
			}

			if (bitmask & SON_MC_UTRAN_FDD_CELL_RESELECTION_PRIORITY_PRESENT)
			{
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_FDD_CELL_RESELECTION_PRIORITY_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].
					cell_reselection_priority =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].
					cell_reselection_priority;
			}

			if (bitmask & SON_MC_UTRAN_FDD_THRESH_HIGH_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_FDD_THRESH_HIGH_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].threshX_high =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].threshX_high;
			}

			if (bitmask & SON_MC_UTRAN_FDD_THRESH_LOW_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_FDD_THRESH_LOW_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].threshX_low =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].threshX_low;
			}

			if (bitmask & SON_MC_UTRAN_FDD_Q_RX_LEV_MIN_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_FDD_Q_RX_LEV_MIN_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].q_rx_lev_min =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].q_rx_lev_min;
			}

			if (bitmask & SON_MC_UTRAN_FDD_P_MAX_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_FDD_P_MAX_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].p_max =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].p_max;
			}

			if (bitmask & SON_MC_UTRAN_FDD_Q_QUAL_MIN_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_FDD_Q_QUAL_MIN_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].q_qual_min =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].q_qual_min;
			}

			if (bitmask & SON_MC_UTRAN_FDD_CSG_REPORTING_CELL_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_FDD_CSG_REPORTING_CELL_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].
					num_csg_allowed_reporting_cell =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].
					num_csg_allowed_reporting_cell;

				oam_memcpy(
						p_anr_meas_config_req->other_rat_config_list.
						utran_config_list.utran_fdd_list[idx].
						csg_allowed_reporting_cell_list,
						p_local_anr_meas_config_req->other_rat_config_list.
						utran_config_list.utran_fdd_list[idx].
						csg_allowed_reporting_cell_list,
						(sizeof(son_utran_pci_fdd_range_t) *
						 p_anr_meas_config_req->other_rat_config_list.
						 utran_config_list.utran_fdd_list[idx].
						 num_csg_allowed_reporting_cell)
					  );
			}

			if(bitmask & SON_MC_UTRAN_THRESHX_HIGH_Q_R9) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_THRESHX_HIGH_Q_R9;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].threshx_highq_r9 =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].threshx_highq_r9;
			}

			if (bitmask & SON_MC_UTRAN_THRESHX_LOW_Q_R9) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_UTRAN_THRESHX_LOW_Q_R9;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].threshx_lowq_r9 =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].threshx_lowq_r9;
			}


			bitmask = p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list.bitmask;

			if (bitmask & SON_UTRAN_RESELECTION_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.bitmask |=
					SON_UTRAN_RESELECTION_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection;
			}

			if (bitmask & SON_UTRAN_RESELECTION_SF_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.bitmask |=
					SON_UTRAN_RESELECTION_SF_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection_sf.sf_medium =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection_sf.sf_medium;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection_sf.sf_high =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection_sf.sf_high;
			}
		}
	}
	/* RT SPR 8154 FIX START */
	else if (p_local_anr_meas_config_req->other_rat_config_list.
			geran_config_list.geran_freq_info_list_size) {
		OAM_LOG(OAM, OAM_DETAILED, "Updating GERAN meas config data");
		arfcn_found =
			oam_arfcn_search_in_meas_config_list(
					&p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs,
					p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list,
					p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list_size,
					&p_son_inter_freq_carr_params->geran_meas_entry_bitmap,
					OAM_SON_MEAS_CONFIG_TYPE_GERAN);

                    /* SPR 14651 START */
                    /* Updating Meas Enable Data */
                    if(p_local_son_inter_freq_carr_params->
                         geran_meas_enable[idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
                    {
                        p_son_inter_freq_carr_params->
                            geran_meas_enable[idx].enable =
                            p_local_son_inter_freq_carr_params->
                            geran_meas_enable[idx].enable;

                        p_son_inter_freq_carr_params->
                            geran_meas_enable[idx].
                            bitmask |= OAM_SON_MEAS_ENABLE_PRESENT;
                    }
                    /* SPR 14651 END */

		if(NOT_FOUND == arfcn_found) {
			OAM_LOG(OAM, OAM_INFO, "Adding a new meas config record");
			oam_memcpy(&p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx],
					&p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx],
					sizeof(son_geran_carrier_freq_info_t));

            /* SPR 14651 START */
			//++p_anr_meas_config_req->other_rat_config_list.
				//geran_config_list.geran_freq_info_list_size;
            /* SPR 14651 END */
			p_son_inter_freq_carr_params->
				geran_meas_entry_bitmap |= (meas_bit << idx);  

			/* RT SPR 14298 FIX START */
			index = RRM_CELL_CONFIG(cell_config_idx_rrm).ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_inter_rat_geran_params.
				carrier_freq_info_list.count_geran_carrier;

			RRM_CELL_CONFIG(cell_config_idx_rrm).ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_inter_rat_geran_params.
				carrier_freq_info_list.carrier_list[index].
				carrier_freq.starting_arfcn =
				p_local_anr_meas_config_req->other_rat_config_list.
				geran_config_list.geran_freq_info_list[idx].
				geran_car_freqs.starting_arfcn;

			++RRM_CELL_CONFIG(cell_config_idx_rrm).ran_info.
				mobility_params.idle_mode_mobility_params.
				idle_mode_mobility_inter_rat_geran_params.
				carrier_freq_info_list.count_geran_carrier;
			/* RT SPR 14298 FIX END */
		}
		else {
			OAM_LOG(OAM, OAM_INFO, "Updating an existing meas config record");
			bitmask = p_local_anr_meas_config_req->other_rat_config_list.
				geran_config_list.geran_freq_info_list[idx].bitmask;

			if (bitmask & SON_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].bitmask |=
					SON_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					cell_reselection_priority =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					cell_reselection_priority;
			}

			if (bitmask & SON_GERAN_CFI_NCC_PERMITTED_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					bitmask |= SON_GERAN_CFI_NCC_PERMITTED_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].ncc_permitted =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].ncc_permitted;
			}

			if (bitmask & SON_GERAN_CFI_Q_RX_LEV_MIN_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					bitmask |= SON_GERAN_CFI_Q_RX_LEV_MIN_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].q_rx_lev_min =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].q_rx_lev_min;
			}

			if (bitmask & SON_GERAN_CFI_MAX_ALLOWED_TRANS_PWR_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					bitmask |= SON_GERAN_CFI_MAX_ALLOWED_TRANS_PWR_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].p_max_geran =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].p_max_geran;
			}

			if (bitmask & SON_GERAN_CFI_THRESH_HIGH_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					bitmask |= SON_GERAN_CFI_THRESH_HIGH_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].threshX_high =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].threshX_high;
			}

			if (bitmask & SON_GERAN_CFI_THRESH_LOW_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					bitmask |= SON_GERAN_CFI_THRESH_LOW_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].threshX_low =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].threshX_low;
			}

			if (bitmask & SON_GERAN_CFI_OFFSET_FREQ_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					bitmask |= SON_GERAN_CFI_OFFSET_FREQ_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					offset_frequency =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					offset_frequency;
			}

			bitmask = p_local_anr_meas_config_req->other_rat_config_list.
				geran_config_list.geran_freq_info_list[idx].
				geran_car_freqs.following_arfcns.bitmask;

			if (bitmask & SON_MC_GERAN_EXP_ARFCN_SET_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.
					bitmask |= SON_MC_GERAN_EXP_ARFCN_SET_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.exp_arfcn_list_size =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.exp_arfcn_list_size;

				oam_memcpy(p_anr_meas_config_req->other_rat_config_list.
						geran_config_list.geran_freq_info_list[idx].
						geran_car_freqs.following_arfcns.exp_arfcn_list,
						p_local_anr_meas_config_req->other_rat_config_list.
						geran_config_list.geran_freq_info_list[idx].
						geran_car_freqs.following_arfcns.exp_arfcn_list,
						(sizeof(son_u16) *
						 p_anr_meas_config_req->other_rat_config_list.
						 geran_config_list.geran_freq_info_list[idx].
						 geran_car_freqs.following_arfcns.
						 exp_arfcn_list_size));
			}

			if (bitmask & SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.
					bitmask |= SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.arfcn_spacing =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.arfcn_spacing;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.num_of_following_arfcn =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.num_of_following_arfcn;
			}

			if (bitmask & SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx].bitmask |=
					SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.arfcn_bmp_list_size =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx].
					geran_car_freqs.following_arfcns.arfcn_bmp_list_size;

				oam_memcpy(p_anr_meas_config_req->other_rat_config_list.
						geran_config_list.geran_freq_info_list[idx].
						geran_car_freqs.following_arfcns.arfcn_bmp_list,
						p_local_anr_meas_config_req->other_rat_config_list.
						geran_config_list.geran_freq_info_list[idx].
						geran_car_freqs.following_arfcns.arfcn_bmp_list,
						(sizeof(son_u8) *
						 p_anr_meas_config_req->other_rat_config_list.
						 geran_config_list.geran_freq_info_list[idx].
						 geran_car_freqs.following_arfcns.
						 arfcn_bmp_list_size));
			}


			bitmask = p_local_anr_meas_config_req->other_rat_config_list.
				geran_config_list.bitmask;

			if (bitmask & SON_MC_GERAN_RESELECTION_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.bitmask |=
					SON_MC_GERAN_RESELECTION_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.t_reselection =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.t_reselection;
			}

			if (bitmask & SON_MC_GERAN_RESELECTION_SF_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.
					bitmask |= SON_MC_GERAN_RESELECTION_SF_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.t_reselection_sf.sf_medium =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.t_reselection_sf.sf_medium;

				p_anr_meas_config_req->other_rat_config_list.
					geran_config_list.t_reselection_sf.sf_high =
					p_local_anr_meas_config_req->other_rat_config_list.
					geran_config_list.t_reselection_sf.sf_high;
			}
		}
	}
	/* RT SPR 8154 FIX END */
	else if (p_local_anr_meas_config_req->other_rat_config_list.
			utran_config_list.utran_tdd_list_size) {
		OAM_LOG(OAM, OAM_DETAILED, "Updating UTRAN meas config tdd data");
		arfcn_found =
			oam_arfcn_search_in_meas_config_list(
					&p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].uarfcn,
					p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list,
					p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list_size,
					&p_son_inter_freq_carr_params->
					utran_tdd_meas_entry_bitmap,
					OAM_SON_MEAS_CONFIG_TYPE_UTRAN_TDD);

		if(NOT_FOUND == arfcn_found) {
			OAM_LOG(OAM, OAM_DETAILED, "Adding a new meas config tdd record");
			oam_memcpy(&p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx],
					&p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx],
					sizeof(son_meas_config_utran_tdd_t));

			++p_anr_meas_config_req->other_rat_config_list.utran_config_list.
				utran_tdd_list_size;
			p_son_inter_freq_carr_params->
				utran_tdd_meas_entry_bitmap |= (meas_bit << idx);

		}
		else {
			OAM_LOG(OAM, OAM_DETAILED,
					"Updating an existing meas config record");

			bitmask = p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list.utran_tdd_list[idx].bitmask;

			if (bitmask & SON_MC_UTRAN_TDD_OFFSET_FREQ_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].bitmask |=
					SON_MC_UTRAN_TDD_OFFSET_FREQ_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].offset_frequency =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].offset_frequency;
			}            
			if (bitmask & SON_MC_UTRAN_TDD_CELL_RESELECTION_PRIORITY_PRESENT)
			{
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].bitmask |=
					SON_MC_UTRAN_TDD_CELL_RESELECTION_PRIORITY_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].
					cell_reselection_priority =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].
					cell_reselection_priority;
			}

			if (bitmask & SON_MC_UTRAN_TDD_THRESH_HIGH_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].bitmask |=
					SON_MC_UTRAN_TDD_THRESH_HIGH_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].threshX_high =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].threshX_high;
			}

			if (bitmask & SON_MC_UTRAN_TDD_THRESH_LOW_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].bitmask |=
					SON_MC_UTRAN_TDD_THRESH_LOW_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].threshX_low =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].threshX_low;
			}

			if (bitmask & SON_MC_UTRAN_TDD_Q_RX_LEV_MIN_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].bitmask |=
					SON_MC_UTRAN_TDD_Q_RX_LEV_MIN_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].q_rx_lev_min =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].q_rx_lev_min;
			}
			if (bitmask & SON_MC_UTRAN_TDD_P_MAX_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].bitmask |=
					SON_MC_UTRAN_TDD_P_MAX_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].p_max =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_tdd_list[idx].p_max;
			}

			bitmask = p_local_anr_meas_config_req->other_rat_config_list.
				utran_config_list.bitmask;

			if (bitmask & SON_UTRAN_RESELECTION_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.bitmask |=
					SON_UTRAN_RESELECTION_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection;
			}

			if (bitmask & SON_UTRAN_RESELECTION_SF_PRESENT) {
				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.bitmask |=
					SON_UTRAN_RESELECTION_SF_PRESENT;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection_sf.sf_medium =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection_sf.sf_medium;

				p_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection_sf.sf_high =
					p_local_anr_meas_config_req->other_rat_config_list.
					utran_config_list.t_reselection_sf.sf_high;
			}
		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}
/******************************************************************************
 * Function Name  : oam_son_update_neigh_list
 * Inputs         : p_resp,resp_type
 * Outputs        : none
 * Returns        : None
 * Description    :
 *******************************************************************************/
	oam_return_et
oam_son_update_neigh_list(void *p_resp, UInt16 resp_type)
{

	OAM_FUN_ENTRY_TRACE();
	oam_return_et  ret_val = OAM_SUCCESS;
	UInt32 nr_bit = OAM_ONE;
	/* SPR-13586 START */
	/* code removed */
	/* SPR-13586 END */
    /* SPR 18930  FIX START */
	//oam_counter_t idx = OAM_ZERO;
    /* SPR 18930  FIX END */
	UInt32 usr_req_resp =
		oam_prov_req.system_status.event_ongoing & OAM_SON_ADD_NR_ONGOING;
	oam_son_nr_add_resp_t *p_add_resp = p_resp;
	oam_son_nr_update_resp_t *p_upd_resp = p_resp;
	oam_son_nr_delete_resp_t *p_del_resp = p_resp;
	SInt16 cgi_found = OAM_ZERO;
    /* SPR 18930  FIX START */
	//UInt32 bitmask = OAM_ZERO;
    /* SPR 18930  FIX END */
	UInt8 cid = OAM_ZERO;
	UInt8 query_idx = OAM_ZERO;
	oam_cell_neighbourlist_info_t *p_cell_neighborlist_info = OAM_NULL;
    /* SPR 18930  FIX START */
    oam_cell_neighbourlist_info_t *p_local_neighborlist_info = OAM_NULL;
    /* SPR 18930  FIX END */

    /* Spr 15438 Fix Start */
    /*SPR_16927_START*/
    UInt32 is_neigh_idx_occupied = OAM_ZERO;
    /*SPR_16927_END*/
    /* Spr 15438 Fix End */
	oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;
	oam_son_nr_add_req_t *p_local_son_nr_add  = OAM_NULL;
	oam_son_neigh_list_in_use_t *p_nliu = OAM_NULL;

	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    /* SPR 18930  FIX START */
	SInt8 cell_config_idx1 = OAM_ERROR_RETURN_VAL;
    /* SPR 18930  FIX END */

	cid = oam_extract_cid_from_eutran_cellidentity(
			p_add_resp->src_cgi.cell_identity);


    /* SPR 18930  FIX START */
	cell_config_idx1 = oam_get_son_neigh_list_in_use_idx(cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx1) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         cid);
		return OAM_FAILURE;
	}

	p_nliu = &SON_PROV_REQ.neigh_list_in_use[cell_config_idx1];
    /* SPR 18930  FIX END */

	cell_config_idx = oam_get_son_cell_nr_list_idx(cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         cid);
		return OAM_FAILURE;
	}
	p_cell_neighborlist_info = &SON_NEIGHBORLIST_INFO(cell_config_idx);
    /* SPR 18930  FIX START */
	p_local_neighborlist_info = &LOCAL_SON_NEIGHBORLIST_INFO(cell_config_idx);
	p_son_nr_add = &p_cell_neighborlist_info->oam_son_nr_add_req;
	p_local_son_nr_add  =
		&p_local_neighborlist_info->oam_son_nr_add_req;

	query_idx = p_local_neighborlist_info->nr_list_query_idx;
	/*End: SPR 10567 */
    /* SPR 18930  FIX END */

	OAM_LOG(OAM, OAM_DETAILED, "oam_son_update_neigh_list: [cid=%d, cell_config_idx=%d cell_config_idx1=%d, query_idx= %d]",
            cid,cell_config_idx,cell_config_idx1,query_idx);
	switch(resp_type) {
		case SON_OAM_NR_ADD_RESP:
			if(SON_SUCCESS == p_add_resp->result) {
				if(usr_req_resp) {
					if(p_local_son_nr_add->nr_list.intra_rat_nr_list_size) {
						/* Start: SPR 10567 */
						oam_memcpy(
								&p_son_nr_add->nr_list.intra_rat_nr_list[query_idx],
								&p_local_son_nr_add->nr_list.intra_rat_nr_list[OAM_ZERO],
								sizeof(son_intra_rat_neighbor_info_t));
    /* SPR 18930  FIX START */
                                /* SPR 17178 change start */
                                //p_son_nr_add->nr_list.intra_rat_nr_list_size += 1;  
                                /* SPR 17178 change end */
    /* SPR 18930  FIX END */
                        /* Spr 15438 Fix Start */

                        /* SPR 18930  FIX START */
                                if(p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].bitmask & 
                                        OAM_SON_NEIGHBOUR_ENABLE_PRESENT) 
                                {    
                                    p_cell_neighborlist_info->eutran_nbr_ctxt[query_idx].enable = 
                                        p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].enable;
                                } 
                                if(p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].bitmask & 
                                        OAM_SON_NEIGHBOUR_MI_PRESENT) 
                                {    
                                    p_cell_neighborlist_info->eutran_nbr_ctxt[query_idx].must_include = 
                                        p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].must_include;
                                }
                        /* SPR 18930  FIX END */
                                cgi_found = oam_cgi_search_in_neigh_list(
                                        &p_son_nr_add->nr_list.intra_rat_nr_list[query_idx].nbr_cgi,
                                        p_son_nr_add->nr_list.intra_rat_nr_list,
                                        p_son_nr_add->nr_list.intra_rat_nr_list_size,
                                        &p_cell_neighborlist_info->intra_rat_nr_entry_bitmap,
                                OAM_SON_NEIGH_TYPE_INTRA_RAT);

                                is_neigh_idx_occupied = 
                                    p_cell_neighborlist_info->intra_rat_nr_entry_bitmap & (OAM_ONE << query_idx);

                                if((cgi_found == query_idx) && is_neigh_idx_occupied) {
                                    OAM_LOG(OAM, OAM_DETAILED,
                                            "User triggered for SON_OAM_NR_UPDATE_REQ");
                                }
                                else
                                {
                                    p_cell_neighborlist_info->intra_rat_nr_entry_bitmap |=
                                        (nr_bit << query_idx);
                                    /* Spr 15438 Fix Start */
                                    /* Code Removed*/
                                    /* Spr 15438 Fix End */  
                                }
                                /* Spr 15438 Fix End */
                    }
					/* SPR-13586 START */
					else if(p_local_son_nr_add->nr_list.inter_rat_nr_list_size) {
						if(oam_prov_req.system_status.event_ongoing & OAM_SON_ADD_NR_UMTS_ONGOING)
						{    
							oam_prov_req.system_status.event_ongoing &= ~OAM_SON_ADD_NR_UMTS_ONGOING;
							oam_memcpy(
									&p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor,
									&p_local_son_nr_add->nr_list.inter_rat_nr_list[OAM_ZERO].utran_neighbor,
									sizeof(son_utran_neighbor_info_t));
/* Spr 15612  Fix Start*/
                            if(p_local_neighborlist_info->utran_nbr_ctxt[query_idx].bitmask & 
                                    OAM_SON_NEIGHBOUR_ENABLE_PRESENT) 
                            {    
                                p_cell_neighborlist_info->utran_nbr_ctxt[query_idx].enable = 
                                    p_local_neighborlist_info->utran_nbr_ctxt[query_idx].enable;
                            } 
                            if(p_local_neighborlist_info->utran_nbr_ctxt[query_idx].bitmask & 
                                    OAM_SON_NEIGHBOUR_MI_PRESENT) 
                            {    
                                p_cell_neighborlist_info->utran_nbr_ctxt[query_idx].must_include = 
                                    p_local_neighborlist_info->utran_nbr_ctxt[query_idx].must_include;
                            }
                            cgi_found = oam_cgi_search_in_neigh_list(
                                    &p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.nbr_cgi,
                                    p_son_nr_add->nr_list.inter_rat_nr_list,
                                    p_son_nr_add->nr_list.inter_rat_nr_list_size,
                                    &p_cell_neighborlist_info->inter_rat_umts_entry_bitmap,
                                    OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);

                            is_neigh_idx_occupied =
							SON_NEIGHBORLIST_INFO(cell_config_idx).
                                       inter_rat_umts_entry_bitmap & (OAM_ONE << query_idx);


                            if((cgi_found == query_idx) && is_neigh_idx_occupied) {
                                OAM_LOG(OAM, OAM_DETAILED,
                                        "User triggered for SON_OAM_NR_UPDATE_REQ");
                            }
                            else
                            {
							SON_NEIGHBORLIST_INFO(cell_config_idx).inter_rat_umts_entry_bitmap |=
								(nr_bit << query_idx);
                    
                            } 
/* Spr 15612  Fix End*/

							p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].bitmask |= SON_INTER_UTRAN_NEIGHBOR; 

							p_son_nr_add->nr_list.inter_rat_nr_list_size++;
/*SPR 22442 Fix Start*/
							++p_cell_neighborlist_info->inter_rat_umts_list_size;
/*SPR 22442 Fix End*/
							/*End: SPR 10567 */
						}
						if(oam_prov_req.system_status.event_ongoing & OAM_SON_ADD_NR_GSM_ONGOING)
						{    
							oam_prov_req.system_status.event_ongoing &= ~OAM_SON_ADD_NR_GSM_ONGOING;
							oam_memcpy(
									&p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor,
									&p_local_son_nr_add->nr_list.inter_rat_nr_list[OAM_ZERO].geran_neighbor,
									sizeof(son_geran_neighbor_info_t));
							p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].bitmask |= SON_INTER_GERAN_NEIGHBOR; 

							SON_NEIGHBORLIST_INFO(cell_config_idx).inter_rat_gsm_entry_bitmap |=
								(nr_bit << query_idx);
							++p_son_nr_add->nr_list.inter_rat_nr_list_size;
							++p_cell_neighborlist_info->inter_rat_gsm_list_size;
							/*End: SPR 10567 */
							/* SPR-13586 END */
						}
					}
				}
				else {
                    if(!usr_req_resp) {
                        /* Spr 15438 Fix Start */
                        /* The response is not due to user request.
                         * As Neighbors are added from OAM itself when cell setup is complete.
                         * Not Copying the neighbour in NR list it is already added at init time
                         * Or it is due to Detected cell NR add at Son 
                         */
                        /* Removed Code */
                        /* Spr 15438 Fix End */

                        /* SPR 18930  FIX START */
                        /* Code Removed */
                        /* SPR 18930  FIX END */
					}
				} 
			}
			break;

		case SON_OAM_NR_UPDATE_RESP:
			if(SON_SUCCESS == p_upd_resp->result) {
				if(p_local_son_nr_add->nr_list.intra_rat_nr_list_size) {
					cgi_found = oam_cgi_search_in_neigh_list(
							&p_local_son_nr_add->nr_list.
							intra_rat_nr_list[query_idx].nbr_cgi,
							p_son_nr_add->nr_list.intra_rat_nr_list,
							p_son_nr_add->nr_list.intra_rat_nr_list_size,
							&p_cell_neighborlist_info->intra_rat_nr_entry_bitmap,
							OAM_SON_NEIGH_TYPE_INTRA_RAT);

					if (cgi_found == NOT_FOUND) {
						cgi_found = oam_cgi_search_in_neigh_list(
								&p_local_son_nr_add->nr_list.
								intra_rat_nr_list[query_idx].nbr_cgi,
								p_nliu->nrt_info.nr_list.intra_rat_nr_list,
								p_nliu->nrt_info.nr_list.intra_rat_nr_list_size,
								&p_nliu->intra_rat_neigh_valid_bitmap,
								OAM_SON_NEIGH_TYPE_INTRA_RAT);
						if (cgi_found != NOT_FOUND) {
							oam_memcpy(&p_son_nr_add->nr_list.
									intra_rat_nr_list[query_idx],
									&p_nliu->nrt_info.nr_list.
									intra_rat_nr_list[cgi_found],
									sizeof(son_intra_rat_neighbor_info_t));
						}
					}
                    else {
                        oam_update_intra_rat_nr(&p_son_nr_add->nr_list.
                                intra_rat_nr_list[query_idx],
                                &p_local_son_nr_add->nr_list.
                                intra_rat_nr_list[query_idx]);
                        /* SPR 18930  FIX START */
                        /* Spr 15438 Fix Start */
                        if(p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].bitmask &
                                OAM_SON_NEIGHBOUR_ENABLE_PRESENT)
                        {
                            p_cell_neighborlist_info->eutran_nbr_ctxt[query_idx].enable =
                                p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].enable;
                        }
                        if(p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].bitmask &
                                OAM_SON_NEIGHBOUR_MI_PRESENT)
                        {
                            p_cell_neighborlist_info->eutran_nbr_ctxt[query_idx].must_include =
                                p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].must_include;
                        }
                        /* Spr 15438 Fix End */
                        /* SPR 18930  FIX END */
                    }
				}
				else { /* Update req for inter-RAT neighbor was received */
					/* SPR-13586 START */
					if(oam_prov_req.system_status.event_ongoing & OAM_SON_UPD_NR_UMTS_ONGOING)
					{    
						oam_prov_req.system_status.event_ongoing &= ~OAM_SON_UPD_NR_UMTS_ONGOING;

						oam_update_inter_rat_nr(
								&SON_NR_LIST(cell_config_idx).inter_rat_nr_list[query_idx].utran_neighbor,
								&LOCAL_SON_NR_LIST(cell_config_idx).inter_rat_nr_list[query_idx].utran_neighbor);
/* Spr 15612  Fix Start*/
                    if(p_local_neighborlist_info->utran_nbr_ctxt[query_idx].bitmask &
                            OAM_SON_NEIGHBOUR_ENABLE_PRESENT)
                    {
                        p_cell_neighborlist_info->utran_nbr_ctxt[query_idx].enable =
                            p_local_neighborlist_info->utran_nbr_ctxt[query_idx].enable;
                    }
                    if(p_local_neighborlist_info->utran_nbr_ctxt[query_idx].bitmask &
                            OAM_SON_NEIGHBOUR_MI_PRESENT)
                    {
                        p_cell_neighborlist_info->utran_nbr_ctxt[query_idx].must_include =
                            p_local_neighborlist_info->utran_nbr_ctxt[query_idx].must_include;
                    }
/* Spr 15612  Fix End*/


					}
					if(oam_prov_req.system_status.event_ongoing & OAM_SON_UPD_NR_GSM_ONGOING)
					{    
						oam_prov_req.system_status.event_ongoing &= ~OAM_SON_UPD_NR_GSM_ONGOING;

						oam_update_inter_rat_gsm_nr(
								&SON_NR_LIST(cell_config_idx).inter_rat_nr_list[query_idx].geran_neighbor,
								&LOCAL_SON_NR_LIST(cell_config_idx).inter_rat_nr_list[query_idx].geran_neighbor);

					}
					/* SPR-13586 END */
				}
			}

			break;

		case SON_OAM_NR_DELETE_RESP:
			if (SON_SUCCESS == p_del_resp->result) {
				/* Start: SPR 10567 */
    /* Spr 15438 Fix Start */
                if(SON_PROV_REQ.nr_action & OAM_NLIU_ACTION_DELETE_EUTRAN) {

                    /* SPR 18930  FIX START */
                    /* Updating the Enable and MI Value Only */
                     if(p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].bitmask & 
                             OAM_SON_NEIGHBOUR_ENABLE_PRESENT) 
                     {    
                         p_cell_neighborlist_info->eutran_nbr_ctxt[query_idx].enable = 
                             p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].enable;
                     } 
                     if(p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].bitmask & 
                             OAM_SON_NEIGHBOUR_MI_PRESENT) 
                     {    
                         p_cell_neighborlist_info->eutran_nbr_ctxt[query_idx].must_include = 
                             p_local_neighborlist_info->eutran_nbr_ctxt[query_idx].must_include;
                     }
                     /* SPR 18930  FIX END */
                     oam_memcpy(&p_son_nr_add->nr_list.intra_rat_nr_list[query_idx],
                             &p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx],
                             sizeof(son_intra_rat_neighbor_info_t)); 
                } 
                else if(SON_PROV_REQ.nr_action & OAM_NR_ACTION_DELETE_EUTRAN) {
    /* Spr 15438 Fix End */
					SON_PROV_REQ.nr_action &= ~OAM_NR_ACTION_DELETE_EUTRAN;
					p_son_nr_add->nr_list.intra_rat_nr_list_size--;

					SON_NEIGHBORLIST_INFO(cell_config_idx).intra_rat_nr_entry_bitmap &=
						~(nr_bit << query_idx);
					OAM_LOG(OAM,OAM_INFO,"Value of intra_rat_nr_entry_bitmap[cell_config_idx] is: %d",
							SON_NEIGHBORLIST_INFO(cell_config_idx).intra_rat_nr_entry_bitmap);
					oam_memset(&p_son_nr_add->nr_list.intra_rat_nr_list[query_idx], OAM_ZERO,
							sizeof (son_intra_rat_neighbor_info_t));
				}
				else {
					/* SPR-13586 START */ 
                    if(SON_PROV_REQ.nr_action == OAM_NLIU_ACTION_DELETE_UTRAN) {
                        /* Spr 15612  Fix Start*/
                    /* Updating the Enable and MI Value Only */
                    if(p_local_neighborlist_info->utran_nbr_ctxt[query_idx].bitmask & 
                             OAM_SON_NEIGHBOUR_ENABLE_PRESENT) 
                     {    
                         p_cell_neighborlist_info->utran_nbr_ctxt[query_idx].enable = 
                             p_local_neighborlist_info->utran_nbr_ctxt[query_idx].enable;
                     } 
          	    /* SPR 19221: CID 88730 Fix Start */ 
                    if(p_local_neighborlist_info->utran_nbr_ctxt[query_idx].bitmask & 
                             OAM_SON_NEIGHBOUR_MI_PRESENT) 
          	    /* SPR 19221: CID 88730 Fix End */ 
                     {    
                         p_cell_neighborlist_info->utran_nbr_ctxt[query_idx].must_include = 
                             p_local_neighborlist_info->utran_nbr_ctxt[query_idx].must_include;
                     } 
                        /* Spr 15612  Fix End*/
                    }
                    if(SON_PROV_REQ.nr_action == OAM_NR_ACTION_DELETE_UTRAN) {
                        SON_PROV_REQ.nr_action &= ~OAM_NR_ACTION_DELETE_UTRAN;
                    oam_memcpy(&p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor,
                            &p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor,
                            sizeof(son_utran_neighbor_info_t));

						p_son_nr_add->nr_list.inter_rat_nr_list_size-- ;

						SON_NEIGHBORLIST_INFO(cell_config_idx).inter_rat_umts_list_size--;
						SON_NEIGHBORLIST_INFO(cell_config_idx).inter_rat_umts_entry_bitmap &=
							~(nr_bit << query_idx);
						OAM_LOG(OAM,OAM_INFO,"Value of inter_rat_umts_entry_bitmap is: %d",
								SON_NEIGHBORLIST_INFO(cell_config_idx).inter_rat_umts_entry_bitmap);

						oam_memset(&p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor, OAM_ZERO,
								sizeof (son_utran_neighbor_info_t));
						p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].bitmask &= ~SON_INTER_UTRAN_NEIGHBOR; 
						/*End: SPR 10567 */
					}   
					if(SON_PROV_REQ.nr_action == OAM_NR_ACTION_DELETE_GERAN) {
						SON_PROV_REQ.nr_action &= ~OAM_NR_ACTION_DELETE_GERAN;
						p_son_nr_add->nr_list.inter_rat_nr_list_size-- ;
						/* TAG */
						SON_NEIGHBORLIST_INFO(cell_config_idx).inter_rat_gsm_list_size--;
						SON_NEIGHBORLIST_INFO(cell_config_idx).inter_rat_gsm_entry_bitmap &=
							~(nr_bit << query_idx);
						OAM_LOG(OAM,OAM_INFO,"Value of inter_rat_gsm_entry_bitmap is: %d",
								SON_NEIGHBORLIST_INFO(cell_config_idx).inter_rat_gsm_entry_bitmap);

						oam_memset(&p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor, OAM_ZERO,
								sizeof (son_geran_neighbor_info_t));
						p_son_nr_add->nr_list.inter_rat_nr_list[query_idx].bitmask &= ~SON_INTER_GERAN_NEIGHBOR; 

					}
					/* SPR-13586 END */
				}
			}

    /* SPR 18930  FIX START */
			//SON_PROV_REQ.nr_action = OAM_NR_NO_ACTION;
    /* SPR 18930  FIX END */
	}

	OAM_FUN_EXIT_TRACE();
	return ret_val;
	/* review_comment_fix */
}

/*OAM_REVIEW_CHANGES*/
/*SPR_16048 Fix Start*/
/*+ SPR 18392*/
UInt8 oam_nw_scan_status[OAM_FIVE][OAM_THIRTY_TWO] = {
    {"Indeterminate"},
    {"InProgress"},
    {"Success"},
    {"Error"},
    {"Error_TIMEOUT"}
};
/*- SPR 18392*/
/*SPR_16048 Fix End*/
/*OAM_REVIEW_CHANGES*/
/******************************************************************************
 * Function Name  : oam_fill_time_stamp 
 * Inputs         : p_time_stamp 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 *******************************************************************************/
void
oam_fill_time_stamp
(       
 oam_time_stamp_t *p_time_stamp
 )
{   
	time_t  currentTimestamp ;
	struct tm  *currentTime;

	OAM_TIME(&currentTimestamp);

	/*localtime function will fill the structure currentTime*/
	currentTime = OAM_LOCALTIME(&currentTimestamp);
	if (OAM_NULL != currentTime)   
	{
		p_time_stamp->year  = (1900+currentTime->tm_year);
		p_time_stamp->month = ++currentTime->tm_mon;
		p_time_stamp->day   = currentTime->tm_mday ;
		p_time_stamp->hour  = currentTime->tm_hour ;
		p_time_stamp->min   = currentTime->tm_min;
		p_time_stamp->sec   = currentTime->tm_sec;
	}
	else
	{
		OAM_LOG(OAM,OAM_DETAILED,"localtime function not working properly ");
	}
}


/******************************************************************************
 * Function Name  : oam_son_execute_reboot 
 * Inputs         : Message buffer 
 * Outputs        : none 
 * Returns        : none 
 * Description    : 
 *******************************************************************************/
void
oam_son_execute_reboot
(
 void *p_api_buf
 )
{
	char	 	*p_api_buf_temp = p_api_buf;
	char		*p_start_param_list = OAM_NULL;
	UInt16 		len_of_admin_info = OAM_ZERO; 
	UInt16		cmd_name_len = OAM_ZERO;
	UInt8 		num_of_params = OAM_ZERO;
	UInt8 		*comp_string = OAM_NULL;
	UInt8 		cmd_name[OAM_HUNDRED];
	OAM_FUN_ENTRY_TRACE();

	/* Increment the pointer to start of API Payload */
	p_api_buf_temp += OAM_MGMT_INTF_HEADER_SIZE;

	/* Decoding total length of parent + all children */
	/* length of input string is at 0 position in p_api_buf_temp*/

	len_of_admin_info  = get_word_from_header((UInt8*)(p_api_buf_temp)); 
	OAM_LOG(OAM,OAM_DETAILED,"Length of Admin Info in Control Command  == %d",
			len_of_admin_info);

	/* Points to start of parameter list */
	p_start_param_list = p_api_buf_temp ;
	p_start_param_list+= len_of_admin_info;

	/* Move the pointer to start of command name */
	p_api_buf_temp+= OAM_TWO*sizeof(UInt16); /* Move past the length and reserved field */   

	/* Calculate length of command name */
	cmd_name_len = len_of_admin_info - (OAM_TWO*sizeof(UInt8) +OAM_THREE*sizeof(UInt16) + sizeof(UInt32));

	oam_memcpy(cmd_name,p_api_buf_temp,cmd_name_len);

	/* Get no of parameters */
	oam_memcpy(&num_of_params,p_api_buf_temp+ cmd_name_len,sizeof(UInt8));


	/* Extract the comparison string, 
	 * For e.g.: AdminControlCommand=Shutdown 
	 * AdminControlCommand=Restart
	 * AdminControlCommand=FactoryReset
	 * AdminControlCommand=InitiateConfiguration * */

	/*Coverity Fix after comments*/
	comp_string = (UInt8 *)oam_strtok((char *)cmd_name,"=");
    /*Coverity Fix 86970 Fix Start*/
	if (OAM_NULL != comp_string)   
    {
	OAM_LOG(OAM,OAM_DETAILED," Comp string value [%u] " , *comp_string);
    }
    /*Coverity Fix 86970 Fix End*/

	cmd_map_element[OAM_ONE].callback(p_api_buf,num_of_params,(UInt8 *)p_start_param_list);

}


/******************************************************************************
 * Function Name  : oam_fill_network_scan_status 
 * Inputs         : none 
 * Outputs        : none 
 * Returns        : none 
 * Description    : 
 *******************************************************************************/
/* + SPR 17439 */
	void
oam_fill_network_scan_status(void)
{
/* - SPR 17439 */
	oam_time_stamp_t time_stamp = {OAM_ZERO};
	Char8 *err_str = OAM_NULL;
	oam_memset(&(oam_prov_req.oam_igd_params.nw_scan_status),OAM_ZERO,sizeof(oam_nw_scan_status_t));

	if(SON_SUCCESS == oam_prov_req.oam_son_req.bulk_scan_resp.result)
	{
		/*OAM_REVIEW_CHANGES*/
		oam_memcpy(&(oam_prov_req.oam_igd_params.nw_scan_status.scan_status),oam_nw_scan_status[OAM_TWO],OAM_THIRTY_TWO);
		/*OAM_REVIEW_CHANGES*/
		oam_memcpy(&(oam_prov_req.oam_igd_params.nw_scan_status.error_details),
				"OAM_SON_NO_ERROR",oam_strlen("OAM_SON_NO_ERROR")); 
/*SPR_16048 Fix Start*/
        oam_prov_req.oam_igd_params.nw_scan_status.max_cell_entry = OAM_MAX_CELL_OBJECTS;
/*SPR_16048 Fix End*/
		oam_prov_req.oam_igd_params.nw_scan_status.num_cell_entry = oam_prov_req.oam_son_req.oam_nw_scan_result.num_cell_discover;
		oam_prov_req.oam_igd_params.nw_scan_status.max_carrier_meas_entry =OAM_FIVE ;
		oam_prov_req.oam_igd_params.nw_scan_status.num_carrier_meas_entry = oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_list_size;
		oam_fill_time_stamp(&time_stamp);
/*SPR_16048 Fix Start*/
        oam_fill_last_scan_time_format(oam_prov_req.oam_igd_params.nw_scan_status.last_scan_time,time_stamp);
		//oam_snprintf((char *)oam_prov_req.oam_igd_params.nw_scan_status.last_scan_time,OAM_TWENTY_FOUR,"%d-%d-%d %d:%d:%d",time_stamp.day,time_stamp.month,time_stamp.year,time_stamp.hour,time_stamp.min,time_stamp.sec);
/*SPR_16048 Fix End*/
	}
	else
	{

/*SPR_16048 Fix Start*/
        oam_prov_req.oam_igd_params.nw_scan_status.max_cell_entry = OAM_MAX_CELL_OBJECTS;
        oam_prov_req.oam_igd_params.nw_scan_status.max_carrier_meas_entry =OAM_FIVE ;
/*SPR_16048 Fix End*/
		/*OAM_REVIEW_CHANGES*/
		oam_memcpy(&(oam_prov_req.oam_igd_params.nw_scan_status.scan_status),oam_nw_scan_status[OAM_THREE],OAM_THIRTY_TWO);
		/*OAM_REVIEW_CHANGES*/
		err_str =
			oam_son_resp_code_to_str(SON_PROV_REQ.bulk_scan_resp.error_code);

		oam_strncpy(oam_prov_req.oam_igd_params.nw_scan_status.error_details,
				err_str, OAM_NMM_MAX_STR_SIZE); 
		oam_fill_time_stamp(&time_stamp);
/*SPR_16048 Fix Start*/
        oam_fill_last_scan_time_format(oam_prov_req.oam_igd_params.nw_scan_status.last_scan_time,time_stamp);
		//oam_snprintf((char *)oam_prov_req.oam_igd_params.nw_scan_status.last_scan_time,OAM_TWENTY_FOUR,"%d-%d-%d %d:%d:%d",time_stamp.day,time_stamp.month,time_stamp.year,time_stamp.hour,time_stamp.min,time_stamp.sec);
/*SPR_16048 Fix End*/
	}
}


/******************************************************************************
 * Function Name  : oam_fill_network_scan_response 
 * Inputs         : none 
 * Outputs        : none 
 * Returns        : none 
 * Description    : 
 *******************************************************************************/
/* + SPR 17439 */
	void
oam_fill_network_scan_response(void)
{
/* - SPR 17439 */
	UInt16 earfcn_index = OAM_ZERO;
	UInt16 cell_index = OAM_ZERO;
	UInt16 discover_cell_index = OAM_ZERO;
	UInt8 plmn_index = OAM_ZERO;
	UInt32 temp_val = OAM_ZERO;
	oam_memset(&(oam_prov_req.oam_son_req.oam_nw_scan_result),OAM_ZERO, sizeof(oam_nw_scan_result_t));
	if((SON_SUCCESS == oam_prov_req.oam_son_req.bulk_scan_resp.result) && 
			(SON_INTRA_RAT_BULK_NW_SCAN_RESP_PRESENT & oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.bitmask))
	{
		for(;(earfcn_index < oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_list_size) &&
				(earfcn_index < SON_MAX_NO_EARFCN); earfcn_index++)
		{
			oam_prov_req.oam_son_req.oam_nw_scan_result.num_cell_discover += 
				oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list_size;
			for(cell_index = OAM_ZERO;
					(cell_index <  
					 oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list_size) &&
					(cell_index < MAX_SERVED_CELLS);
					cell_index++)
			{
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].carrier_earfcn = 
																    oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].earfcn;
                /*SPR_16048 Fix Start*/
                /*SPR_16390 Fix start*/

				oam_prov_req.oam_son_req.oam_nw_scan_result.
                    oam_cell_discover[discover_cell_index].rssi = 
                                           oam_prov_req.oam_son_req.
                                           bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.
                                           rf_freq_channel_num[earfcn_index].rssi + (MIN_3GPP_RSSI_RANGE);

                if(oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rssi < MIN_RSSI)
                {
                    oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rssi = MIN_RSSI;    
                }
                /*SPR_16390 Fix end*/
                if(oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rssi > MAX_RSSI)
                {
                    oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rssi = MAX_RSSI;
                }

				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].phy_cell_id = 
																 oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].rf_list.pci_id;


                /*SPR_16390 Fix start*/
				oam_prov_req.oam_son_req.oam_nw_scan_result.
                    oam_cell_discover[discover_cell_index].rsrp = 
									oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.
                                    intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].
                                    cell_list[cell_index].rf_list.rsrp + (MIN_3GPP_RSRP);

                if(oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rsrp < MIN_RSRP)
                {
                    oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rsrp = MIN_RSRP;
                }
                /*SPR_16390 Fix end*/
                if(oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rsrp > MAX_RSRP)
                {
                    oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rsrp = MAX_RSRP;
                }

                /*SPR_16390 Fix start*/
				oam_prov_req.oam_son_req.oam_nw_scan_result.
                    oam_cell_discover[discover_cell_index].rsrq = 
									((oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.
                                    intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].
                                    cell_list[cell_index].rf_list.rsrq *(FACTOR_FIVE)) + (MIN_3GPP_RSRQ_RANGE)) * OAM_TEN;
                
                if(oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rsrq > MAX_RSRQ)
                {
                oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rsrq = MAX_RSRQ;    
                }
                if(oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rsrq < MIN_RSRQ)
                {
                    oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].rsrq = MIN_RSRQ;    
                }
                /*SPR_16390 Fix end*/
                /*SPR_16048 Fix Start*/

				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.dl_bandwidth = \
																		oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.dl_sys_bw;
                
                /* SPR 22925 Fix + */
                if(OAM_ZERO == oam_strncmp((const char *)oam_prov_req.oam_tr069_req.tr069_init_params.DuplexMode
                                            ,"TDDMode",oam_strlen("TDDMode")+1))
                {
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.ul_bandwidth = \
																		oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.dl_sys_bw;
                }
                else
                {
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.ul_bandwidth = \
																		oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.ul_sys_bw;
                }
                /* SPR 22925 Fix - */
				
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.rx_tx_power = \
																	       oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.rsTxPower;

				/* SPR 11315 FIX START*/
				temp_val =
					oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.tac[OAM_ZERO];
				temp_val = temp_val << OAM_EIGHT;
				temp_val |=
					oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.tac[OAM_ONE];
				/* SPR 11315 FIX END*/
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.tac = 
					(UInt16)(temp_val & 0x0000FFFF);
				temp_val = OAM_ZERO;

                /*SPR_16048 Fix Start*/
				oam_cmn_convert_byte_string_to_integer(
                        (UInt8 *)oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.
                        intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].
                        cell_list[cell_index].bcch_list.cell_Id,
                        OAM_FOUR, 
                        &temp_val,
                        OAM_MAX_INT_BITSTRING_SIZE - OAM_CELL_ID_BITSTRING_SIZE);
                /*SPR_16048 Fix End*/
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.cell_identity = 
					temp_val;
				temp_val = OAM_ZERO;
                /*SPR_16048 Fix Start*/
				oam_cmn_convert_csgid_to_integer(
                        (UInt8 *)oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.
                        intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].
                        cell_list[cell_index].bcch_list.csg_identity,
                        OAM_FOUR, 
                        &temp_val);
                /*SPR_16048 Fix End*/
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.csg_identity = 
					temp_val;

               /*SPR 16407 START*/
                /*value of cell barred is converted as per tr196 spec*/
                if(oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.cell_barred == OAM_TRUE)
                {
                    oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.cell_barred 
                        = OAM_FALSE;
                }
                else
                {
                    oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.cell_barred = OAM_TRUE;
                } 
                /*SPR 16407 END*/
                

                /*SPR_16048 Fix Start*/
				oam_prov_req.oam_son_req.oam_nw_scan_result.
                    oam_cell_discover[discover_cell_index].oam_bcch_data.csg_indication = 
										oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.
                                        intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].
                                        cell_list[cell_index].bcch_list.csg_indication;
                /*SPR_16048 Fix End*/
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.max_plmn_entry = SON_MAX_NUM_PLMN;
				oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.num_plm_entry = 
																		 oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.num_plmn_id;
                /*SPR_16048 Fix Start*/
				for(plmn_index = OAM_ZERO;
                /*SPR_16048 Fix End*/
						( plmn_index < oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].oam_bcch_data.num_plm_entry)
						&& (plmn_index < SON_MAX_NUM_PLMN );
						plmn_index++)
				{
                /*SPR_16048 Fix Start*/
                    Char8 *p_plmn_id = oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].
                                             oam_bcch_data.oam_plmn_list[plmn_index].plmnid;

                    son_cell_plmn_info_t *p_plmn_info = &(oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.intra_rat_scan_resp.
                                             rf_freq_channel_num[earfcn_index].cell_list[cell_index].bcch_list.plmn_identity_info[plmn_index].plmn_id);

                    UInt8 mcc_idx,mnc_idx = OAM_ZERO; 
                    for(mcc_idx = OAM_ZERO;mcc_idx<OAM_THREE;mcc_idx++)
                    {
                            sprintf(p_plmn_id + mcc_idx ,"%d",(UInt8)p_plmn_info->mcc[mcc_idx]);
                    }
                    for(mnc_idx = OAM_ZERO;mnc_idx<p_plmn_info->num_mnc_digit;mnc_idx++)
                    {
                            sprintf(p_plmn_id + mcc_idx + mnc_idx,"%d",(UInt8)p_plmn_info->mnc[mnc_idx]);
                    }

                    oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[discover_cell_index].
                            oam_bcch_data.oam_plmn_list[plmn_index].cell_reserver_for_operator_use = oam_prov_req.oam_son_req.bulk_scan_resp.nw_scan_resp.
                                                                               intra_rat_scan_resp.rf_freq_channel_num[earfcn_index].cell_list[cell_index].
                                                                               bcch_list.plmn_identity_info[plmn_index].cell_res_for_operator_use;
                /*SPR_16048 Fix Start*/

				}
				discover_cell_index++;
				if(discover_cell_index >= OAM_MAX_NUM_CELL_COUNT)
				{
					break;
				}
			}
			if(discover_cell_index >= OAM_MAX_NUM_CELL_COUNT)
			{
				break;
			}

		}

	}   
}

/******************************************************************************
 * Function Name  : oam_son_intf_msg_handler 
 * Inputs         : p_api_buf
 *		   api_id
 *		   src module id
 *		   message length	 
 * Outputs        : none 
 * Returns        : none 
 * Description    : 
 *******************************************************************************/
oam_return_et
oam_son_intf_msg_handler
(
 void      *p_api_buf, 
 UInt16    api_id, 
 UInt16    src_module_id, 
 UInt16    msg_len
 )
{
    OAM_FUN_ENTRY_TRACE();
    oam_error_code_et err = NO_ERROR;
    /* SPR 13024 FIX START */
    UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    /* SPR 13024 FIX END */
    SInt32 length_left = OAM_ZERO;
    /*SPR_15770 Fix start*/
    /*+SPR 18853 FIX*/
    UInt8 cell_cnt = OAM_ZERO;
    /*-SPR 18853 FIX*/
    UInt8 curr_cid = OAM_ZERO;
    UInt8 tran_id = OAM_ZERO;
    /*SPR_15770 Fix end*/
    SInt32 length_read = OAM_ZERO;
    /* Transaction ID of the response from layer */
    UInt32 trans_id = get_word_from_header(p_api_buf);
    /* TCB details for getting user request info */
    oam_struct_t *tcb_det = oam_tcb_get_detail(&trans_id);
    UInt16 resp_trans_id = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;
    oam_return_et layer_resp = OAM_FAILURE;
    Char8 *err_string = OAM_NULL;
    UInt8 err_str_size = OAM_ZERO;
    UInt16 usr_error_code = OAM_ZERO;
    UInt32 usr_req_resp = OAM_ZERO;
    UInt8 *p_usr_req = OAM_NULL;
    UInt16 dst_id = OAM_ZERO;
    oam_son_nr_delete_resp_t *p_del_resp = OAM_NULL;
    oam_time_stamp_t time_stamp = {OAM_ZERO};
    UInt8 usr_resp = OAM_RESULT_SUCCESS;
    oam_son_nr_add_resp_t *p_resp = OAM_NULL; 
    oam_son_anr_updated_nrt_info_t *p_nrt_resp = OAM_NULL; 
    UInt8 *p_tmp_buf = OAM_NULL;
    void *timer_ptr;
    UInt16 trans_id_resp = OAM_ZERO;
    UInt16 dest_id = OAM_ZERO;
    oam_son_anr_modify_ue_count_resp_t *p_son_anr_modify_ue_count_resp = OAM_NULL;
    son_oam_anr_modify_meas_reporting_interval_resp_t *p_son_anr_modify_meas_reporting_interval_resp = OAM_NULL;
    son_oam_anr_modify_removal_attributes_resp_t *p_oam_son_anr_modify_removal_attributes_resp  = OAM_NULL;
    son_oam_anr_modify_pci_confusion_cfg_resp_t *p_son_anr_modify_pci_confusion_cfg_resp = OAM_NULL;
    /* SPR 20653 Fix Start */
    son_oam_anr_modify_attribute_resp_t *p_son_anr_modify_attribute_resp = OAM_NULL;
    /* SPR 20653 Fix End */
    /* SPR_19619 start*/
    son_oam_peer_cell_activation_resp_t  *p_son_oam_peer_cell_activation_resp = OAM_NULL;
    /* SPR_19619 stop*/
    oam_son_rach_opt_enable_resp_t *p_oam_son_rach_opt_enable_resp = OAM_NULL;
    oam_son_mro_enable_resp_t *p_son_mro_enable_resp = OAM_NULL;
    oam_son_anr_enable_resp_t *p_son_anr_enable_resp = OAM_NULL;
    oam_son_mlb_enable_resp_t *p_son_mlb_enable_resp = OAM_NULL;
    oam_son_es_autonomous_switch_off_config_resp_t
        *p_es_autonomous_switch_off_config_resp = OAM_NULL;
    oam_son_es_modify_ue_count_threshold_resp_t
        *p_oam_son_es_modify_ue_count_threshold_resp = OAM_NULL;
    oam_son_mro_disable_resp_t *p_son_mro_disable_resp = OAM_NULL;
    oam_son_anr_disable_resp_t *p_son_anr_disable_resp = OAM_NULL;
    /* SPR 11156 FIX START */
    oam_son_nr_delete_from_remove_list_resp_t
        *p_del_from_rem_list_resp = OAM_NULL;
    /* SPR 11156 FIX END */
    oam_son_mro_modify_config_params_resp_t
        *p_mro_modify_config_params_resp = OAM_NULL;
    oam_son_mlb_modify_attributes_resp_t
        *p_mlb_modify_attributes_resp = OAM_ZERO;
    oam_son_es_enable_resp_t *p_son_es_enable_resp = OAM_NULL;
    oam_son_mlb_disable_resp_t *p_son_mlb_disable_resp = OAM_NULL;
    oam_son_es_disable_resp_t *p_son_es_disable_resp = OAM_ZERO;

    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    SInt8 cell_config_idx1 = OAM_ERROR_RETURN_VAL;
    oam_son_es_modify_ue_count_interval_resp_t
        *p_oam_son_es_modify_ue_count_interval_resp = OAM_NULL;

    oam_tcb_cntxt_data_t tcb_data = {OAM_ZERO};
    oam_bool_et tcb_found  = OAM_FALSE;
    oam_son_nr_update_resp_t *p_update_resp = OAM_NULL;
    /* RT SPR 12768 FIX START */
    oam_son_x2_link_down_ind_t *p_oam_son_x2_link_down_ind = OAM_NULL;
    /* RT SPR 12768 FIX END */
    /* Spr 12880 Fix Start*/
    UInt8 CellId = OAM_INVALID_CELL_ID;
    /* Spr 12880 Fix End*/
    oam_son_pci_conflict_confusion_ind_t 
        *p_pci_conflict_confusion_ind = OAM_NULL;
    UInt32 loop = OAM_ZERO;
    /* Spr 17753 Changes Start */
    UInt32 lp = OAM_ZERO;
    /* Spr 17753 Changes End */

    Char8 add_txt[OAM_ALARM_ADD_TXT_MAX_LEN] = {OAM_ZERO};
    UInt32 serv_cellidentity = OAM_ZERO;
    UInt32 neigh1_cellidentity = OAM_ZERO;
    UInt32 neigh2_cellidentity = OAM_ZERO;

    oam_son_anr_meas_config_obj_remove_res_t
        *p_anr_meas_config_obj_remove_res = OAM_NULL;
    oam_son_anr_meas_config_req_t *p_anr_meas_config_req = OAM_NULL;
    oam_son_inter_freq_carrier_t *p_inter_freq_carr_params = OAM_NULL;
    /* SPR 14651 START */
    oam_son_inter_freq_carrier_t *p_local_inter_freq_carr_params = OAM_NULL;
    UInt8 cli_resp_send = OAM_FALSE;
    UInt8 idx = OAM_ZERO;
    /* SPR 14651 END */
    UInt8 query_idx = OAM_ZERO;
    /* SPR 13024 FIX START */
    oam_son_pci_reselection_resp_t *p_pci_reselection_resp = OAM_NULL;
    oam_rrm_cell_reconfig_req_t    *p_cell_reconfig_req = OAM_NULL;

    /* SPR 12214 FIX START */
    oam_rrm_cell_config_req_t *p_rrm_cell_config = OAM_NULL;
    oam_rrm_cell_config_req_t *p_local_cell_config = OAM_NULL;
    /* SPR 12214 FIX END*/

    oam_cell_status_t *p_cell_status = OAM_NULL;
    /* SPR 13024 FIX END */

    /* SPR 19343 START */
    static UInt8 num_feature_state_change_ind_anr = 0;
    /* SPR 19343 END */
    oam_son_anr_meas_config_res_t *p_anr_meas_config_resp = OAM_NULL;

    /*eICIC_PHASE_1_2_CHANGES_START*/
    son_oam_anr_neighbor_default_config_resp_t *p_anr_neighbor_default_config_resp = OAM_NULL;
    /*eICIC_PHASE_1_2_CHANGES_END*/

    /*SPR 19981 Fix Start*/
    UInt32 tid = 0;
    /*SPR 19981 Fix Stop*/
    /* SPR 17777 fix start */
    OAM_LOG(OAM, OAM_DETAILED, "api_id received is = %d, unused parametrr %u ", api_id, src_module_id);

    switch (api_id) {
        case SON_OAM_MLB_MODIFY_ATTRIBUTES_RESP:
        OAM_LOG(OAM, OAM_INFO,
                "Received SON_OAM_MLB_MODIFY_ATTRIBUTES_RESP from SON");
        /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
        if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
        {
            OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
            break;
        }
#endif
        /* SPR 9620 CHANGE END */
        retVal = oam_mem_alloc(
                sizeof(oam_son_mlb_modify_attributes_resp_t),
                (void**)&p_mlb_modify_attributes_resp,
                &err);
        if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_mlb_modify_attributes_resp failed"
                        " with Error Code:%d",
                        err);
            break;
        }
        /* OAM SPR 11691 FIX START*/
        oam_memset(p_mlb_modify_attributes_resp, OAM_ZERO,
                sizeof(oam_son_mlb_modify_attributes_resp_t));
        /* OAM SPR 11691 FIX END*/

        length_left = get_word_from_header((UInt8*)p_api_buf +
                OAM_INTF_HDR_MSG_SIZE_OFFSET);
        length_read = OAM_ZERO;
        p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;


        retVal = oam_parse_son_oam_mlb_modify_attributes_resp(
                p_mlb_modify_attributes_resp,
                p_tmp_buf,
                length_left,
                &length_read);


        if(OAM_SUCCESS == retVal) {
            OAM_LOG(OAM, OAM_DETAILED,
                    "SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP: Parsing Success");
            if(SON_SUCCESS == p_mlb_modify_attributes_resp->result) {
                OAM_LOG(OAM, OAM_INFO,
                        "SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP returned success");
                /* This function directly uses global structures:
                 * oam_prov_req, and local_prov_req
                 */
                oam_update_son_mlb_config_params(
                        &p_mlb_modify_attributes_resp->srv_cgi);

                err_str_size = OAM_ZERO;
                usr_error_code = OAM_ZERO;
                usr_resp = OAM_RESULT_SUCCESS;
            }
            else {
                    OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP returned failure"
                        " with error code: %d",
                        p_mlb_modify_attributes_resp->error_code);

                err_string = "Unable to modify attributes for MLB";
                err_str_size = oam_strlen(err_string);
                /* SPR 11001 FIX START */
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                /* SPR 11001 FIX END */
                usr_resp = OAM_RESULT_FAILURE;
            }
        }
        else
        {
                OAM_LOG(OAM, OAM_WARNING,
                    "SON_OAM_MLB_MODIFY_ATTRIBUTES_RESP: Parsing Failed");

            err_string = "Response message parsing failed";
            err_str_size = oam_strlen(err_string);
            usr_error_code = OAM_ERR_INTERNAL_ERROR;
            usr_resp = OAM_RESULT_FAILURE;
        }


        oam_construct_n_send_set_resp_to_usr(usr_resp,
                usr_error_code,
                (UInt8*)err_string,
                err_str_size,
                OAM_VERSION_ID,
                OAM_MODULE_ID,
                dest_id,
                trans_id_resp,
                OAM_ZERO, OAM_ZERO,
                &err);
        /* Coverity ID : 85858 Fix Start*/
        oam_mem_free(p_mlb_modify_attributes_resp, &err);
        /* Coverity ID : 85858 Fix End*/
        break;

        case SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP:
        OAM_LOG(OAM, OAM_INFO,
                "Received SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP from SON");
        /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
        if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
        {
            OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
            break;
        }
#endif
        /* SPR 9620 CHANGE END */
        retVal = oam_mem_alloc(
                sizeof(oam_son_mro_modify_config_params_resp_t),
                (void**)&p_mro_modify_config_params_resp,
                &err);
        if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_mro_modify_config_params_resp failed"
                        " with Error Code:%d",
                        err);
            break;
        }

        /* SPR 10936 FIX START */
        oam_memset(p_mro_modify_config_params_resp, OAM_ZERO,
                sizeof(oam_son_mro_modify_config_params_resp_t));
        /* SPR 10936 FIX END */

        length_left = get_word_from_header((UInt8*)p_api_buf +
                OAM_INTF_HDR_MSG_SIZE_OFFSET);
        length_read = OAM_ZERO;
        p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

        retVal = oam_parse_son_oam_mro_modify_config_params_resp(
                p_mro_modify_config_params_resp,
                p_tmp_buf,
                length_left,
                &length_read);


        if(OAM_SUCCESS == retVal) {
            OAM_LOG(OAM, OAM_DETAILED,
                    "SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP: Parsing Success");
            if(SON_SUCCESS == p_mro_modify_config_params_resp->result) {
                OAM_LOG(OAM, OAM_INFO,
                        "SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP returned success");
                /* This function directly uses global structures:
                 * oam_prov_req, and local_prov_req
                 */
                oam_update_son_mro_config_params(
                        &p_mro_modify_config_params_resp->srv_cgi);

                err_str_size = OAM_ZERO;
                usr_error_code = OAM_ZERO;
                usr_resp = OAM_RESULT_SUCCESS;
            }
            else {
                    OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP returned failure"
                        " with error code: %d",
                        p_mro_modify_config_params_resp->error_code);

                err_string = "Unable to modify attributes for MRO";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INVALID_PARAM_NAME;
                usr_resp = OAM_RESULT_FAILURE;
            }
        }
        else {
                OAM_LOG(OAM, OAM_WARNING,
                    "SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP: Parsing Failed");

            err_string = "Response message parsing failed";
            err_str_size = oam_strlen(err_string);
            usr_error_code = OAM_ERR_INTERNAL_ERROR;
            usr_resp = OAM_RESULT_FAILURE;
        }


        oam_construct_n_send_set_resp_to_usr(usr_resp,
                usr_error_code,
                (UInt8*)err_string,
                err_str_size,
                OAM_VERSION_ID,
                OAM_MODULE_ID,
                dest_id,
                trans_id_resp,
                OAM_ZERO, OAM_ZERO,
                &err);
        /* Coverity ID : 85857 Fix Start*/
        oam_mem_free(p_mro_modify_config_params_resp, &err);
        /* Coverity ID : 85857 Fix End*/
        break;

        case SON_OAM_CHK_HEALTH_RESP:
			/*SPR 21369 Start*/
            oam_hm_recieved_resp_bitmask_update(p_api_buf);
			/*SPR 21369 End*/
            break;
        case SON_OAM_INIT_IND:
        OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_INIT_IND from SON");
        p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;
        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&err))
        {
            OAM_LOG(OAM,OAM_DETAILED, "Successfully sent SON_OAM_INIT_CONFIG_REQ to FSM");
        }
        else
        {
            OAM_LOG(OAM,OAM_DETAILED, "Failed to send SON_OAM_INIT_CONFIG_REQ to FSM");
            return OAM_FAILURE;
        }
        break;
        case SON_OAM_INIT_CONFIG_RESP:
        OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_INIT_CONFIG_RESP from SON");
        p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;
        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&err))
        {
            OAM_LOG(OAM,OAM_DETAILED, "Successfully sent SON_OAM_INIT_CONFIG_REQ to FSM");
        }
        else
        {
            OAM_LOG(OAM,OAM_DETAILED, "Failed to send SON_OAM_INIT_CONFIG_REQ to FSM");
            return OAM_FAILURE;
        }
        /*SPR_15770 Fix start*/
        /* check if nr scan is not required 
         * then assume nr_scan resp has recived*/
                /*SPR_16390 Fix start*/
                if((OAM_FALSE == oam_prov_req.oam_igd_params.rem_lte_params.is_nr_scan_required)
                        || (OAM_FALSE == oam_prov_req.system_status.is_nmm_enabled))
                    /*SPR_16390 Fix end*/
                {
                    /*+SPR 18853 FIX*/
                    OAM_SYS_EVENT_BIMASK |= NR_SCAN_RESP_RCVD;
                    /*-SPR 18853 FIX*/
                }
                else
                {       
                    OAM_LOG(OAM,OAM_DETAILED, "NR Scanning is enable");
                }
                /*SPR_15770 Fix end*/

                break;
                /* SPR_13116_CHANGE_START */
        case SON_OAM_GET_LOG_LEVEL_RESP:
                /* SPR 13116 REVIEW COMMENTS FIX START */
                OAM_LOG(OAM, OAM_INFO,
                        "Received SON_OAM_GET_LOG_LEVEL_RESP from SON");
                /* SPR 13116 REVIEW COMMENTS FIX END */

                OAM_LOG(OAM, OAM_DETAILED, "Trans_id received is = %d", trans_id);
                oam_son_get_log_level_resp_t son_get_log_level_resp;
                /* SPR 13116 REVIEW COMMENTS FIX START */
                length_left = get_word_from_header((UInt8*)p_api_buf +
                        OAM_INTF_HDR_MSG_SIZE_OFFSET);
                /* SPR 13116 REVIEW COMMENTS FIX END */
                length_read= OAM_ZERO;
                retVal = oam_parse_son_oam_get_log_level_resp(&son_get_log_level_resp,
                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        &length_read);
                /* SPR 13116 REVIEW COMMENTS FIX START */
                if(OAM_FAILURE == retVal)
                    /* SPR 13116 REVIEW COMMENTS FIX END */
                {
                OAM_LOG(OAM,OAM_WARNING, "Parsing Failed in SON_OAM_GET_LOG_LEVEL_RESP from SON");
                    return OAM_FAILURE;
                }
                else
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Parsing Successful in SON_OAM_GET_LOG_LEVEL_RESP from SON");
                }
                /* SPR 17777 fix */
                retVal = oam_son_get_loglevel_resp(&son_get_log_level_resp,p_api_buf);
                /* SPR 13116 REVIEW COMMENTS FIX START */
                if(OAM_FAILURE == retVal)
                    /* SPR 13116 REVIEW COMMENTS FIX END */
                {
                OAM_LOG(OAM,OAM_WARNING, "Failed in SON_OAM_GET_LOG_LEVEL_RESP from SON");
                    return OAM_FAILURE;
                }
                else
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Successful in SON_OAM_GET_LOG_LEVEL_RESP from SON");
                }
                break;
                /* SPR_13116_CHANGE_END */


        case SON_OAM_SET_LOG_LEVEL_RESP:
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_SET_LOG_LEVEL_RESP from SON");
                    /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                    if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                        break;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                    oam_son_set_log_level_resp_t son_set_log_level_resp;
                    length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                    length_read= OAM_ZERO;            
                    oam_struct_t  *node;
                    UInt8 *p_req_msg;
                    oam_parse_son_oam_set_log_level_resp(&son_set_log_level_resp,
                            p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            &length_read);
                    UInt32 bitmask = OAM_ZERO;
                    SInt32 complete_msg_len = OAM_ZERO;
                    UInt8* p_son_msg  = OAM_NULL;
                    UInt8 *p_msg = OAM_NULL;
                    UInt16 tcb_detail = get_word_from_header(p_api_buf + OAM_ZERO);
                    UInt32 temp_tcb = tcb_detail;
                    complete_msg_len =  OAM_EIGHT +
                        OAM_MGMT_INTF_HEADER_SIZE + OAM_CSPL_HDR_SIZE;

                    node=oam_tcb_get_detail(&temp_tcb);
                    if(OAM_NULL == node)
                    {
                    OAM_LOG(OAM,OAM_WARNING, "oam_tcb_get_detail returned null in SON_OAM_SET_LOG_LEVEL_RESP");
                    }
                    else
                    {
                        p_req_msg = node->oam_tcb_context;
                        dest_id = get_word_from_header((UInt8*)(p_req_msg) + OAM_TWO);
                    }

                    OAM_LOG(OAM,OAM_DETAILED,"complete_msg_len :%d",complete_msg_len);
                    if (OAM_FAILURE == oam_mem_alloc(complete_msg_len,
                                (void *)&p_msg,&err))
                    {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to p_msg failed"
                            " with Error Code:%d",
                            err);
                        OAM_FUN_EXIT_TRACE();
                        /* Not Enough Memory */
                        return OAM_FAILURE;
                    }

                    p_son_msg = p_msg;
                    oam_construct_api_header(p_son_msg, OAM_VERSION_ID,OAM_MODULE_ID,
                            dest_id,
                            OAM_SET_PARAMETER_VALUES_RESP,
                            complete_msg_len);

                    p_son_msg = p_son_msg + OAM_CSPL_HDR_SIZE;

                    /* Fill API header in message*/
                    /* CHECK */
                    oam_construct_mgmt_api_hdr(p_son_msg,
                            tcb_detail,
                            OAM_MODULE_ID,
                            dest_id,
                            OAM_SET_PARAMETER_VALUES_RESP,
                            complete_msg_len - OAM_CSPL_HDR_SIZE,
                            /*SPR 17777 fix*/
                            OAM_ZERO);

                    p_son_msg = p_son_msg + OAM_MGMT_INTF_HEADER_SIZE;

                    /*This is done because the encoding of result field is just opposite
                      to that assumed to be sent in the response message from OAM.*/
                    *(p_son_msg + OAM_ZERO) = 
                        (SON_SUCCESS == son_set_log_level_resp.result)? OAM_ZERO : OAM_ONE;
                    /* encoding 2 byte of error code */
                    *(p_son_msg + OAM_ONE) = (son_set_log_level_resp.error_code & OAM_UPPER_EIGHT_BITS_SET) >> OAM_EIGHT;
                    *(p_son_msg + OAM_TWO) = (son_set_log_level_resp.error_code & OAM_ALL_8_BIT_SET); 
                    *(p_son_msg +OAM_THREE) = OAM_ZERO; /* 1-Byte of reserved field */
                    *(p_son_msg +OAM_FOUR) = OAM_ZERO; /* 3-Bytes of reserved field onwards */
                    *(p_son_msg +OAM_FIVE) = OAM_ZERO;
                    *(p_son_msg + OAM_SIX) = OAM_ZERO;
                    *(p_son_msg + OAM_SEVEN) = OAM_ZERO; /* 1-Byte of error string length */
                    /*set the master dataset of parameters if the SET reqest is success*/
                    if(SON_SUCCESS == son_set_log_level_resp.result) 
                    {
                        oam_memcpy(&oam_prov_req.oam_son_req.oam_son_set_log_level_req,
                                &local_prov_req.oam_son_req.oam_son_set_log_level_req,
                                sizeof(son_oam_set_log_level_req_t));

                        if(node)
                        {
                            oam_tcb_update_bitmask(tcb_detail,OAM_TRANS_SON,&bitmask);

                            if(bitmask == OAM_ZERO)
                            {
                                if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                {
                                OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                }

                                if(OAM_SUCCESS == oam_send_message(p_msg, dest_id,&err))
                                {
                                OAM_LOG(OAM,OAM_INFO,"Sending message to dest_id: %d",dest_id);
                                }
                                else
                                {
                                OAM_LOG(OAM,OAM_ERROR,"Error in oam_send_message : %d",
                                            err);
                                    OAM_FUN_EXIT_TRACE();
                                    return OAM_FAILURE;
                                }
                            }
                            else
                            {
                                OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_SET_LOG_LEVEL_RESP from SON for system command,waiting for response from other layers");
                            }
                        } 
                    }
                    else        
                    {
                        if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                        {
                        OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                        }

                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                son_set_log_level_resp.result, (UInt8 *) "Set log level response failed from SON",
                                oam_strlen("Set log level response failed from SON")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp,OAM_ZERO,
                                OAM_ZERO,&err);
                    }
                    /* SPR 19703 changes start/end Code Removed */
                }
                break;
        case SON_OAM_LOG_ENABLE_DISABLE_RESP:
                {
                    SInt32 complete_msg_len = OAM_ZERO;
                    UInt8* p_son_msg  = OAM_NULL;
                    UInt8 *p_msg = OAM_NULL;
                    oam_son_log_enable_disable_resp_t son_log_enable_disable_resp;
                    length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                    length_read= OAM_ZERO;            
                    OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_LOG_LEVEL_ENABLE_DISABLE_RESP from SON");
                    /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                    if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                        break;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                    if(OAM_SUCCESS == oam_parse_son_oam_log_enable_disable_resp(
                                &son_log_enable_disable_resp,p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                &length_read))
                    {

                        complete_msg_len = OAM_EIGHT +
                            OAM_MGMT_INTF_HEADER_SIZE + OAM_CSPL_HDR_SIZE;


                        OAM_LOG(OAM,OAM_DETAILED,"complete_msg_len :%d",complete_msg_len);
                        if (OAM_FAILURE == oam_mem_alloc(complete_msg_len,
                                    (void *)&p_msg,&err))
                        {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Memory allocation to p_msg failed"
                                " with Error Code:%d",
                                err);
                            OAM_FUN_EXIT_TRACE();
                            /* Not Enough Memory */
                            return OAM_FAILURE;
                        }

                        p_son_msg = p_msg;

                        oam_construct_api_header(p_son_msg, OAM_VERSION_ID,OAM_MODULE_ID,
                                dest_id,
                                OAM_SET_PARAMETER_VALUES_RESP,
                                complete_msg_len);

                        p_son_msg = p_son_msg + OAM_CSPL_HDR_SIZE;


                        /* Fill API header in message*/
                        oam_construct_mgmt_api_hdr(p_son_msg,
                                trans_id_resp,
                                OAM_MODULE_ID,
                                dest_id,
                                OAM_SET_PARAMETER_VALUES_RESP,
                                complete_msg_len - OAM_CSPL_HDR_SIZE,
                                /*SPR 17777 fix*/
                                OAM_ZERO);
                        p_son_msg = p_son_msg + OAM_MGMT_INTF_HEADER_SIZE;


                        /*This is done because the encoding of result field is just opposite
                          to that assumed to be sent in the response message from OAM.*/
                        /* coverity 34797 */	
                        *(p_son_msg + OAM_ZERO) = 
                            (SON_SUCCESS == (son_return_et)(son_log_enable_disable_resp.result))? OAM_ZERO : OAM_ONE;
                        /* encoding 2 byte of error code */
                        *(p_son_msg + OAM_ONE) = (son_log_enable_disable_resp.error_code & OAM_UPPER_EIGHT_BITS_SET)>> OAM_EIGHT;
                        *(p_son_msg + OAM_TWO) = (son_log_enable_disable_resp.error_code & OAM_ALL_8_BIT_SET); 
                        *(p_son_msg +OAM_THREE) = OAM_ZERO; /* 1-Byte of reserved field */
                        *(p_son_msg +OAM_FOUR) = OAM_ZERO; /* 3-Bytes of reserved field onwards */
                        *(p_son_msg +OAM_FIVE) = OAM_ZERO;
                        *(p_son_msg + OAM_SIX) = OAM_ZERO;
                        *(p_son_msg + OAM_SEVEN) = OAM_ZERO; /* 1-Byte of error string length */


                        /* No way to store the status of logging to oam_prov_req */

                        if(OAM_SUCCESS == oam_send_message(p_msg, dest_id,&err))
                        {
                        OAM_LOG(OAM,OAM_INFO,"Sending message to Management Interface");
                        }
                        else
                        {
                        OAM_LOG(OAM,OAM_ERROR,"Error in oam_send_message : %d",
                                    err);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        OAM_FUN_EXIT_TRACE();
                        return(OAM_SUCCESS);
                    }
                    else
                    {
                    OAM_LOG(OAM,OAM_WARNING,"Error in parsing");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                break;

        case SONMRO_HO_COUNTER_REPORT:
                {   /* Cov CID 63604 Fix */ 
                    OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_MRO_HO_COUNTER_REPORT from SON");
                    /* Coverity CID 31382 Fix Start*/ 
                    son_oam_mro_ho_counter_report_t * p_son_mro_ho_counter_report = OAM_NULL;

                    retVal = oam_mem_alloc(sizeof(son_oam_mro_ho_counter_report_t),
                            (void**)&p_son_mro_ho_counter_report, &err);

                    if(OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to p_son_mro_ho_counter_report failed"
                            " with Error Code:%d",
                            err);
                        return OAM_FAILURE;
                    }
                    /* Coverity CID 31382 Fix Start*/ 

                    length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                    length_read= OAM_ZERO;

                    if(OAM_SUCCESS == oam_parse_son_oam_mro_ho_counter_report(p_son_mro_ho_counter_report,
                                p_api_buf,length_left,&length_read))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "Successfully parse SON_OAM_MRO_HO_COUNTER_REPORT");
                        /*SPR 17777 fix*/
                        oam_handle_son_oam_mro_ho_counter_report(p_son_mro_ho_counter_report);
                    }       
                    else
                    {       
                        OAM_LOG(OAM,OAM_DETAILED, "Fail to SON_OAM_MRO_HO_COUNTER_REPORT");
                    }       
                    /* Coverity CID 31382 Fix Start*/ 
                    oam_mem_free(p_son_mro_ho_counter_report, &err);
                    /* Coverity CID 31382 Fix End*/ 
                } /* Cov CID 63604 Fix */
                break;

        case SON_OAM_NR_ADD_RESP:
                usr_req_resp = oam_prov_req.system_status.
                    event_ongoing & OAM_SON_ADD_NR_ONGOING;
                if(usr_req_resp) {
                    retVal = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                            &tcb_data.usr_req_trans_id,
                            &tcb_data.usr_intf_src_id,
                            &tcb_data.p_orig_xml_parent,
                            &tcb_data.p_usr_msg_xml_parent,
                            &tcb_data.p_parent_xml_struct_addr);

                    if(OAM_FAILURE == retVal) {
                        usr_req_resp = OAM_ZERO;
                    }
                    else {
                        tcb_found = OAM_TRUE;
                    }
                }
                retVal = oam_mem_alloc(sizeof(oam_son_nr_add_resp_t),
                        (void**)&p_resp, &err);

                if(OAM_FAILURE == retVal) {
                    /* Not Enough Memory */
                    OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_resp failed"
                        " with Error Code:%d",
                            err);

                    if(usr_req_resp) {
                        oam_get_err_string_n_err_code(err, &usr_error_code,
                                &err_string);
                        err_str_size = oam_strlen(err_string) + OAM_ONE;
                        usr_resp = OAM_RESULT_FAILURE;

                        oam_construct_n_send_set_resp_to_usr(usr_resp,
                                usr_error_code,
                                (UInt8*)err_string,
                                err_str_size,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                tcb_data.usr_intf_src_id,
                                tcb_data.usr_req_trans_id,
                                OAM_ZERO, OAM_ZERO,
                                &err);
                    }

                    oam_prov_req.system_status.
                        event_ongoing &= ~OAM_SON_ADD_NR_ONGOING;

                    oam_prov_req.system_status.
                        event_ongoing &= ~OAM_ADD_OBJ_ONGOING;
                    break;
                }

                length_left = get_word_from_header((UInt8*)p_api_buf +
                        OAM_INTF_HDR_MSG_SIZE_OFFSET);
                length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                retVal = oam_parse_son_oam_nr_add_resp(p_resp,
                        p_api_buf,
                        length_left,
                        &length_read);
                /* SPR 18930  FIX START */
                cid = oam_extract_cid_from_eutran_cellidentity(
                        p_resp->src_cgi.cell_identity);

                /* SPR 18930  FIX END */
                OAM_LOG(OAM, OAM_INFO,
                        "SON_OAM_NR_ADD_RESP received from cell context: %d", cid);
                if(OAM_SUCCESS == retVal) {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Successfully parsed SON_OAM_NR_ADD_RESP.");
                    /* SPR 15604 START */

                    UInt8 cell_arr_idx = oam_get_son_serving_cell_idx(cid);
                    /*Cov 94841_94766 fix start*/
                    if(OAM_ERROR_RETURN_VAL == (SInt8)cell_arr_idx) {
                        /*Cov 94841_94766 fix end*/    
                    OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]", cid);
                        /* SPR_19838 : Coverity_11039 Fix Start */
                        oam_mem_free(p_resp, &err);
                        /* SPR_19838 : Coverity_11039 Fix Stop */

                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }

                    /* SPR 18930  FIX START */
                    if(FIRST_NR_ADD_REQ_SENT == SON_NEIGHBORLIST_INFO(cell_arr_idx).first_nr_add_state)
                        /* SPR 18930  FIX END */
                    {
                        /* SPR 18930  FIX START */
                        SON_NEIGHBORLIST_INFO(cell_arr_idx).first_nr_add_state = FIRST_NR_ADD_RESP_RECVD;
                        OAM_LOG(OAM, OAM_DETAILED, " cell_config_idx = %d,is_first_time_nr_add_resp_rcv = %d",cell_arr_idx,SON_NEIGHBORLIST_INFO(cell_arr_idx).first_nr_add_state);
                        /* SPR 18930  FIX END */
                    }

                    /* SPR 15604 END */

                    /* SPR 18930  FIX START */
                    oam_son_update_neigh_list(p_resp, api_id);
                    /* SPR 18930  FIX START */

                    if((SON_SUCCESS == p_resp->result) || 
                            (SON_PARTIAL_SUCCESS == p_resp->result)) {
                        layer_resp = OAM_SUCCESS;
                        OAM_LOG(OAM, OAM_INFO,
                                "Success SON NR ADD Response Received");
                        /* Filling the neighbor_list_in_use for the HeMS configured neighbors */

                        cell_config_idx = oam_get_son_neigh_list_in_use_idx(cid);
                        if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                    cid);
                            /* SPR_19838 : Coverity_11039 Fix Start */
                            oam_mem_free(p_resp, &err);
                            /* SPR_19838 : Coverity_11039 Fix Stop */

                            return OAM_FAILURE;
                        }

                        cell_config_idx1 = oam_get_son_cell_nr_list_idx(cid);
                        if(OAM_ERROR_RETURN_VAL == cell_config_idx1) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                    cid);
                            /* SPR_19838 : Coverity_11039 Fix Start */
                            oam_mem_free(p_resp, &err);
                            /* SPR_19838 : Coverity_11039 Fix Stop */
                            return OAM_FAILURE;
                        }

                        /* SPR 19221: CID 31382 Fix Start */ 
                        oam_son_nr_add_req_t  *neighbore_tobe_added = OAM_NULL; 
                        oam_son_nr_add_req_t  *neighbore_tobe_deleted = OAM_NULL;
                        retVal = oam_mem_alloc(sizeof(oam_son_nr_add_req_t),
                                (void**)&neighbore_tobe_added, &err);
                        if(OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR,
                                "Memory allocation to neighbore_tobe_added failed"
                                " with Error Code:%d",
                                err);
                        }    
                        retVal = oam_mem_alloc(sizeof(oam_son_nr_add_req_t),
                                (void**)&neighbore_tobe_deleted, &err);
                        if(OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR,
                                "Memory allocation to neighbore_tobe_deleted failed"
                                " with Error Code:%d",
                                err);
                        }
                        oam_memset(neighbore_tobe_added,0,sizeof(oam_son_nr_add_req_t));
                        oam_memset(neighbore_tobe_deleted,0,sizeof(oam_son_nr_add_req_t));
                        /* SPR 19221: CID 31382 Fix END */ 

                        oam_find_nr_add_req(trans_id,cell_config_idx);
                        oam_prepare_nr_list_for_nliu(p_resp,&LOCAL_SON_NR_ADD_REQ(cell_config_idx1),
                                /* SPR 19221: CID 31382 Fix Start */ 
                                neighbore_tobe_added,neighbore_tobe_deleted,cell_config_idx);

                        if((neighbore_tobe_deleted->nr_list.intra_rat_nr_list_size)||
                                (neighbore_tobe_deleted->nr_list.inter_rat_nr_list_size))
                            /* SPR 19221: CID 31382 Fix END */ 
                        {
                            oam_memset(&LOCAL_NRT_INFO(cell_config_idx), OAM_ZERO,
                                    sizeof(oam_son_anr_updated_nrt_info_t));

                            oam_memcpy(&LOCAL_NRT_INFO(cell_config_idx).nr_list, 
                                    /* SPR 19221: CID 31382 Fix Start */ 
                                    &neighbore_tobe_deleted->nr_list,sizeof(son_neighbor_info_t));
                            /* SPR 19221: CID 31382 Fix End */ 

                            oam_memcpy(&LOCAL_NRT_INFO(cell_config_idx).src_cgi, &LOCAL_SON_NR_ADD_REQ(cell_config_idx1).src_cgi,
                                    sizeof(son_intra_rat_global_cell_id_t));

                            LOCAL_NRT_INFO(cell_config_idx).nrt_op = SON_NRT_OP_DELETE;
                            oam_son_update_neigh_list_in_use(cell_config_idx);
                        }
                        /* SPR 19221: CID 31382 Fix Start */ 
                        if((neighbore_tobe_added->nr_list.intra_rat_nr_list_size)||
                                (neighbore_tobe_added->nr_list.inter_rat_nr_list_size))
                            /* SPR 19221: CID 31382 Fix END */ 
                        {
                            oam_memset(&LOCAL_NRT_INFO(cell_config_idx), OAM_ZERO,
                                    sizeof(oam_son_anr_updated_nrt_info_t));

                            oam_memcpy(&LOCAL_NRT_INFO(cell_config_idx).nr_list, 
                                    /* SPR 19221: CID 31382 Fix Start */ 
                                    &neighbore_tobe_added->nr_list,sizeof(son_neighbor_info_t));
                            /* SPR 19221: CID 31382 Fix END */ 

                            oam_memcpy(&LOCAL_NRT_INFO(cell_config_idx).src_cgi, &LOCAL_SON_NR_ADD_REQ(cell_config_idx1).src_cgi,
                                    sizeof(son_intra_rat_global_cell_id_t));

                            LOCAL_NRT_INFO(cell_config_idx).nrt_op = SON_NRT_OP_ADD;
                            oam_son_update_neigh_list_in_use(cell_config_idx);

                        }

                        OAM_LOG(OAM, OAM_INFO,
                                "Filling the oam_son_update_neigh_list_in_use for the HeMS configured neighbors");
                        /*SPR_20000 :Coverity_108850 Fix Start*/
                        oam_mem_free(neighbore_tobe_added, &err);
                        /*SPR_20000 :Coverity_108850 Fix End*/

                        /*SPR_20065 :Coverity_108849 Fix Start*/
                        oam_mem_free(neighbore_tobe_deleted, &err);
                        /*SPR_20065 :Coverity_108849 Fix End*/
                        /*End: SPR 10567 */
                    }
                    else {
                        layer_resp = OAM_FAILURE;
                        OAM_LOG(OAM, OAM_INFO,
                                "Failure SON_OAM_NR_ADD_RESP Received");

                        /*SPR 21421 Fixed START*/
                        if(usr_req_resp)
                        {
                            err_string = "Response message failed";
                            err_str_size = oam_strlen(err_string);
                            usr_error_code = OAM_ERR_INTERNAL_ERROR;
                            usr_resp = OAM_RESULT_FAILURE;

                        }    
                        /*SPR 21421 Fixed END*/
                    }
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Failed to parse SON_OAM_NR_ADD_RESP.");
                    layer_resp = OAM_FAILURE;

                    if(usr_req_resp) {
                        oam_get_err_string_n_err_code(err, &usr_error_code,
                                &err_string);
                        err_str_size = oam_strlen(err_string) + OAM_ONE;
                        usr_resp = OAM_RESULT_FAILURE;
                    }
                }

                if(usr_req_resp) {
                    oam_construct_n_send_set_resp_to_usr(usr_resp,
                            usr_error_code,
                            (UInt8*)err_string,
                            err_str_size,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            tcb_data.usr_intf_src_id,
                            tcb_data.usr_req_trans_id,
                            OAM_ZERO, OAM_ZERO,
                            &err);
                }
                if (tcb_found) {
                    oam_update_xml_dom(layer_resp,
                            tcb_data.p_orig_xml_parent,
                            tcb_data.p_usr_msg_xml_parent,
                            tcb_data.p_parent_xml_struct_addr);
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "XML DOM can't be updated as TCB is not found");
                }

                oam_prov_req.system_status.
                    event_ongoing &= ~OAM_SON_ADD_NR_ONGOING;

                oam_prov_req.system_status.
                    event_ongoing &= ~OAM_ADD_OBJ_ONGOING;

                oam_mem_free(p_resp, &err);
                break;

        case SON_OAM_NR_UPDATE_RESP:
                retVal = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                        &tcb_data.usr_req_trans_id,
                        &tcb_data.usr_intf_src_id,
                        &tcb_data.p_orig_xml_parent,
                        &tcb_data.p_usr_msg_xml_parent,
                        &tcb_data.p_parent_xml_struct_addr);

                if(OAM_SUCCESS == retVal) {
                    tcb_found = OAM_TRUE;
                }

                retVal = oam_mem_alloc(sizeof(oam_son_nr_update_resp_t),
                        (void**)&p_update_resp, &err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_update_resp failed"
                        " with Error Code:%d",
                        err);

                    if (tcb_found) {
                        oam_get_err_string_n_err_code(err, &usr_error_code,
                                &err_string);
                        err_str_size = oam_strlen(err_string) + OAM_ONE;
                        usr_resp = OAM_RESULT_FAILURE;
                        oam_construct_n_send_set_resp_to_usr(usr_resp,
                                usr_error_code,
                                (UInt8*)err_string,
                                err_str_size,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                tcb_data.usr_intf_src_id,
                                tcb_data.usr_req_trans_id,
                                OAM_ZERO, OAM_ZERO,
                                &err);
                    }
                    break;
                }

                length_left = get_word_from_header((UInt8*)p_api_buf +
                        OAM_INTF_HDR_MSG_SIZE_OFFSET);
                length_read= OAM_ZERO;

                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                retVal = oam_parse_son_oam_nr_update_resp(p_update_resp,
                        p_api_buf,
                        length_left,
                        &length_read);

                cid = oam_extract_cid_from_eutran_cellidentity(
                        p_update_resp->src_cgi.cell_identity);

                OAM_LOG(OAM, OAM_INFO,
                        "SON_OAM_NR_UPDATE_RESP received from cell id: %d", cid);

                if(OAM_SUCCESS == retVal) {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "SON_OAM_NR_UPDATE_RESP: Parsing Success");

                    /* SPR-13586 START */
                    /* code removed */ 
                    /* SPR-13586 END */
                    oam_prov_req.system_status.event_ongoing &=
                        ~OAM_SON_ADD_NR_ONGOING;

                    if(SON_SUCCESS == p_update_resp->result) {
                        layer_resp = OAM_SUCCESS;
                        OAM_LOG(OAM, OAM_INFO,
                                "Success SON_OAM_NR_UPDATE_RESP Received");

                        err_string = OAM_NULL;
                        err_str_size = OAM_ZERO;
                        usr_error_code = OAM_ZERO;
                        usr_resp = OAM_RESULT_SUCCESS;
                    }
                    else {
                        OAM_LOG(OAM, OAM_INFO,
                                "Failure SON_OAM_NR_UPDATE_RESP Received"
                                " with error code: %d",
                                p_update_resp->trgt_cell_status_list[0].
                                error_code);

                        err_string = oam_son_resp_code_to_str(
                                p_update_resp->trgt_cell_status_list[0].
                                error_code);

                        err_str_size = oam_strlen(err_string) + OAM_ONE;
                        usr_error_code = OAM_ERR_INTERNAL_ERROR;
                        usr_resp = OAM_RESULT_FAILURE;
                    }
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "SON_OAM_NR_UPDATE_RESP: Parsing Failure");

                    oam_get_err_string_n_err_code(err, &usr_error_code,
                            &err_string);
                    err_str_size = oam_strlen(err_string) + OAM_ONE;
                    usr_resp = OAM_RESULT_FAILURE;
                }

                if (tcb_found) {
                    oam_update_xml_dom(layer_resp,
                            tcb_data.p_orig_xml_parent,
                            tcb_data.p_usr_msg_xml_parent,
                            tcb_data.p_parent_xml_struct_addr);
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "XML DOM can't be updated as TCB is not found");
                }

                if (tcb_found) {
                    oam_construct_n_send_set_resp_to_usr(usr_resp,
                            usr_error_code,
                            (UInt8*)err_string,
                            err_str_size,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            tcb_data.usr_intf_src_id,
                            tcb_data.usr_req_trans_id,
                            OAM_ZERO, OAM_ZERO,
                            &err);
                }

                /* Start: SPR 10567 */
                /* Updating the neighbor_list_in_use for the HeMS updated neighbors */
                cid = oam_extract_cid_from_eutran_cellidentity(
                        p_update_resp->src_cgi.cell_identity);

                cell_config_idx = oam_get_son_neigh_list_in_use_idx(cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                    /*coverity_86085_fix_start*/
                    /*coverity_85996_fix_start*/
                    oam_mem_free(p_update_resp, &err);
                    /*coverity_85996_fix_End*/
                    /*coverity_86085_fix_end*/
                OAM_LOG(OAM, OAM_WARNING, "Invalid cell context [cid=%d]",cid);
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_NR_UPDATE_RESP Successfully sent SON_CID : %d",cid);
                    return OAM_FAILURE;
                }


                cell_config_idx1 = oam_get_son_cell_nr_list_idx(cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx1) {
                    /*coverity_86085_fix_start*/
                    /*coverity_85996_fix_start*/
                    oam_mem_free(p_update_resp, &err);
                    /*coverity_85996_fix_End*/
                    /*coverity_86085_fix_end*/
                OAM_LOG(OAM, OAM_WARNING, "Invalid cell context [cid=%d]",cid);
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_NR_UPDATE_RESP Successfully sent SON_CID : %d",cid);
                    return OAM_FAILURE;
                }

                OAM_LOG(OAM, OAM_INFO,
                        "Updating the neighbor_list_in_use for the HeMS updated neighbors");
                oam_update_usr_updateded_neigh_to_nliu(cell_config_idx,cell_config_idx1);
                oam_son_update_neigh_list(p_update_resp, api_id);

                /* Coverity ID : 85872,85996 Fix Start*/
                oam_mem_free(p_update_resp, &err);
                /* Coverity ID : 85872,85996 Fix End*/
                /*End: SPR 10567 */
                break;

        case SON_OAM_NR_DELETE_RESP:
                retVal = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                        &tcb_data.usr_req_trans_id,
                        &tcb_data.usr_intf_src_id,
                        &tcb_data.p_orig_xml_parent,
                        &tcb_data.p_usr_msg_xml_parent,
                        &tcb_data.p_parent_xml_struct_addr);

                if(OAM_SUCCESS == retVal) {
                    tcb_found = OAM_TRUE;
                }

                length_left = get_word_from_header((UInt8*)p_api_buf +
                        OAM_INTF_HDR_MSG_SIZE_OFFSET);
                length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read= OAM_ZERO;   
                retVal = oam_mem_alloc(sizeof(oam_son_nr_delete_resp_t),
                        (void**)&p_del_resp, &err);

                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_del_resp failed"
                        " with Error Code:%d",
                            err);
                    break;
                }

                retVal = oam_parse_son_oam_nr_delete_resp(p_del_resp,
                        p_api_buf,
                        length_left,
                        &length_read);


                if(OAM_SUCCESS == retVal) {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "SON_OAM_NR_DELETE_RESP: Parsing Success");


                    if(SON_SUCCESS == p_del_resp->result) {
                        OAM_LOG(OAM, OAM_INFO,
                                "Success SON_OAM_NR_DELETE_RESP Received");

                        layer_resp = OAM_SUCCESS;

                        /* Start: SPR 10567 */
                        /* Deleting the neighbor from neighbor_list_in_use for the HeMS Deleted neighbors */

                        cid = oam_extract_cid_from_eutran_cellidentity(
                                p_del_resp->src_cgi.cell_identity);

                        cell_config_idx = oam_get_son_neigh_list_in_use_idx(cid);

                        if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                    cid);
                            /*SPR_20000 :Coverity_97020 Fix Start*/
                            oam_mem_free(p_del_resp, &err);
                            /*SPR_20000 :Coverity_97020 Fix End*/
                            return OAM_FAILURE;
                        }

                        cell_config_idx1 = oam_get_son_cell_nr_list_idx(cid);

                        if(OAM_ERROR_RETURN_VAL == cell_config_idx1) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                    cid);
                            /* SPR_19838 : Coverity_11010 Fix Start */
                            oam_mem_free(p_del_resp, &err);
                            /* SPR_19838 : Coverity_11010 Fix Stop */
                            return OAM_FAILURE;
                        }

                        /* SPR 13176 FIX START */
                        oam_son_update_neigh_list_in_use(cell_config_idx);
                        /* SPR 13176 FIX END */


                        oam_son_update_neigh_list(p_del_resp, api_id);
                        /*End: SPR 10567 */
                        err_string = OAM_NULL;
                        /*  coverity 94910 fix start */
                        /* code removed */
                        /*  coverity 94910 fix end */
                        usr_error_code = OAM_ZERO;
                        /*  coverity 94900 fix start */
                        /* code removed */
                        /*  coverity 94900 fix end */
                    }
                    else {
                    OAM_LOG(OAM, OAM_WARNING,
                                "Failure SON_OAM_NR_DELETE_RESP Received"
                                " with error code: %d",
                                p_del_resp->trgt_cell_status_list[0].error_code);

                        err_string = oam_son_resp_code_to_str(
                                p_del_resp->trgt_cell_status_list[0].error_code);

                        /* Coverity_94903 Fix Start */
                        /* Coverity_94903 Fix End */

                        usr_error_code = OAM_ERR_INTERNAL_ERROR;
                        /* Coverity_94906 Fix Start */
                        /* Coverity_94906 Fix End */

                    }
                    /* Spr 15438 Fix Start */
                    /* Spr 15612  Fix Start*/
                    /* Spr 15438 Fix End */
                }
                else {
                OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_NR_DELETE_RESP: Parsing Failure");

                    err = OAM_PARSE_MSG_DMG; 

                    oam_get_err_string_n_err_code(err, &usr_error_code,
                            &err_string);
                    /*  coverity 94903 fix start */
                    /* code removed */
                    /*  coverity 94903 fix end */
                    /*  coverity 94906 fix start */
                    /* code removed */
                    /*  coverity 94906 fix end */
                }

                if (tcb_found) {
                    /* SPR 17409 changes start */
                    /* code removed */
                    /* SPR 18930  FIX START  */
                    if((SON_PROV_REQ.nr_action & OAM_NLIU_ACTION_DELETE_EUTRAN)||
                            (SON_PROV_REQ.nr_action & OAM_NLIU_ACTION_DELETE_UTRAN))
                        /* Spr 15612  Fix End*/
                    {
                        SON_PROV_REQ.nr_action &= ~OAM_NLIU_ACTION_DELETE_EUTRAN;
                        /* Spr 15612  Fix Start*/
                        SON_PROV_REQ.nr_action &= ~OAM_NLIU_ACTION_DELETE_UTRAN;
                        /* Spr 15612  Fix End*/
                        oam_construct_n_send_set_resp_to_usr(usr_resp,
                                usr_error_code,
                                (UInt8*)err_string,
                                err_str_size,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                tcb_data.usr_intf_src_id,
                                tcb_data.usr_req_trans_id,
                                OAM_ZERO, OAM_ZERO,
                                &err);

                    }else {
                        oam_construct_n_send_deleteobject_resp_to_usr(usr_resp,
                                usr_error_code,
                                (UInt8*)err_string,
                                err_str_size, 
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                tcb_data.usr_intf_src_id,
                                tcb_data.usr_req_trans_id,
                                OAM_ZERO,
                                OAM_ZERO,
                                &err);
                    }
                    /* SPR 18930  FIX END  */
                    /* SPR 17409 changes end */

                    oam_update_xml_dom(layer_resp,
                            tcb_data.p_orig_xml_parent,
                            tcb_data.p_usr_msg_xml_parent,
                            tcb_data.p_parent_xml_struct_addr);
                }

                oam_prov_req.system_status.event_ongoing &=
                    ~OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING;

                oam_mem_free(p_del_resp, &err);
                break;

        case SON_OAM_NR_ENB_UPDATE_RESP:
                {
                    /* */
                    oam_son_nr_enb_update_resp_t oam_son_nr_enb_update_resp;          
                    length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                    length_read= OAM_ZERO;

                    /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                    if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                        break;
                    }
#endif
                    /* SPR 9620 CHANGE END */

                    if (OAM_SUCCESS == oam_parse_son_oam_nr_enb_update_resp(&oam_son_nr_enb_update_resp,
                                p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                &length_read))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_NR_ENB_UPDATE_RESP: Parsing Success");

                        if(SON_SUCCESS == oam_son_nr_enb_update_resp.result)
                        {
                            OAM_LOG(OAM, OAM_INFO, "Success SON_NR_ENB_UPDATE_RESP Received");
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                    OAM_ZERO,
                                    OAM_NULL, OAM_ZERO, 
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                    &err); 
                        }
                        else 
                        {
                            OAM_LOG(OAM, OAM_INFO, "Failure SON_NR_ENB_UPDATE_RESP Received");
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR,
                                    (UInt8 *)"Internal Error", oam_strlen("Internal Error")+ OAM_ONE, 
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                    &err); 
                        }
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_NR_ENB_UPDATE_RESP: Parsing Failure");
                    }
                }
                break;               
        case SON_OAM_NR_ENB_DELETE_RESP:
                {
                    /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                    if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                        break;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                    oam_son_nr_enb_delete_resp_t oam_son_nr_enb_delete_resp;
                    length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                    length_read= OAM_ZERO;

                    if (OAM_SUCCESS == oam_parse_son_oam_nr_enb_delete_resp(&oam_son_nr_enb_delete_resp,
                                p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                &length_read))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_NR_ENB_DELETE_RESP: Parsing Success");

                        if(SON_SUCCESS == oam_son_nr_enb_delete_resp.result)
                        {
                            OAM_LOG(OAM, OAM_INFO, "Success SON_OAM_NR_ENB_DELETE_RESP Received");
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                    OAM_ZERO,
                                    OAM_NULL, OAM_ZERO, 
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                    &err); 
                        }
                        else 
                        {
                            OAM_LOG(OAM, OAM_INFO, "Failure SON_OAM_NR_ENB_DELETE_RESP Received");
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR,
                                    (UInt8 *)"Internal Error", oam_strlen("Internal Error")+ OAM_ONE, 
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                    &err); 
                        }
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_NR_ENB_DELETE_RESP: Parsing Failure");
                    }
                }
                break;               
        case SON_OAM_NR_ENB_ADD_RESP:
                {

                    /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                    if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                        break;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                    oam_son_nr_enb_add_resp_t oam_son_nr_enb_add_resp;
                    length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                    length_read= OAM_ZERO;

                    if(OAM_SUCCESS == oam_parse_son_oam_nr_enb_add_resp(&(oam_son_nr_enb_add_resp),
                                p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                &length_read))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_NR_ENB_ADD_RESP: Parsing Success");

                        if(SON_SUCCESS == oam_son_nr_enb_add_resp.result) {
                            OAM_LOG(OAM, OAM_INFO,
                                    "Success SON_OAM_NR_ENB_ADD_RESP Received");
                        }
                        else {
                            OAM_LOG(OAM, OAM_INFO,
                                    "Failure SON_OAM_NR_ENB_ADD_RESP Received");
                        }

                        if(OAM_SON_ADD_NR_ENB_ONGOING & oam_prov_req.system_status.event_ongoing)
                        {
                            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(
                                        p_api_buf,&trans_id_resp,&dest_id))
                            {
                                OAM_FUN_EXIT_TRACE();
                                return OAM_FAILURE;
                            }
                            oam_prov_req.system_status.event_ongoing &= ~OAM_SON_ADD_NR_ENB_ONGOING;

                            if(SON_SUCCESS == oam_son_nr_enb_add_resp.result)
                            {
                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                        OAM_ZERO,
                                        OAM_NULL, OAM_ZERO, 
                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                        &err); 
                            }
                            else 
                            {
                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                        OAM_ERR_INTERNAL_ERROR,
                                        (UInt8 *)"Internal Error", oam_strlen("Internal Error")+ OAM_ONE, 
                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                        &err); 
                            }
                        }
                    }
                    else
                    {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_NR_ENB_ADD_RESP: Parsing Failure");
                    }
                }
                break;
        case SON_OAM_X2_LINK_UP_IND:
                {
                    oam_son_x2_link_up_ind_t *p_oam_son_x2_link_up_ind;
                    length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                    length_read= OAM_ZERO;
                    if (OAM_FAILURE == oam_mem_alloc(sizeof(oam_son_x2_link_up_ind_t),(void *)&p_oam_son_x2_link_up_ind ,&err))
                    {     
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to p_oam_son_x2_link_up_ind  failed"
                            " with Error Code:%d",
                            err);
                        OAM_FUN_EXIT_TRACE();
                        /* Not Enough Memory */
                    }  
                    if (OAM_SUCCESS == oam_parse_son_oam_x2_link_up_ind(p_oam_son_x2_link_up_ind,
                                p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                &length_read))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_X2_LINK_UP_IND: Parsed Successfully");
                        /* RT SPR 12768 FIX START */
                        OAM_ALARM(OAM_X2_LINK_UP_IND_ALARM_ID, WARNING,
                                NOTIFY_NEW_ALARM, COMMUNICATIONS_ALARM,
                                UNAVAILABLE, EXPEDITED_ALARM,
                                /* Spr 12880 Fix Start*/
                                "X2 LINK UP INDICATION", OAM_NULL,CellId);
                        /* Spr 12880 Fix End*/
                        /* RT SPR 12768 FIX END */
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_X2_LINK_UP_IND: Parsing Failed");
                    }
                    oam_mem_free(p_oam_son_x2_link_up_ind ,&err);
                }
                break;

        case SON_OAM_X2_LINK_DOWN_IND:
                /* RT SPR 12768 FIX START */
                OAM_LOG(OAM, OAM_INFO, "SON_OAM_X2_LINK_DOWN_IND received");

                length_left = get_word_from_header((UInt8*)p_api_buf +
                        OAM_INTF_HDR_MSG_SIZE_OFFSET);
                length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                retVal = oam_mem_alloc(sizeof(oam_son_x2_link_down_ind_t),
                        (void**)&p_oam_son_x2_link_down_ind,
                        &err);
                if (OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_oam_son_x2_link_down_ind failed"
                        " with Error Code:%d",
                            err);

                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }

                retVal = oam_parse_son_oam_x2_link_down_ind(
                        p_oam_son_x2_link_down_ind,
                        p_api_buf,
                        length_left,
                        &length_read);
                if (OAM_SUCCESS == retVal) {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_X2_LINK_DOWN_IND Message Parssing Successfully");
                    OAM_ALARM(OAM_X2_LINK_DOWN_IND_ALARM_ID, MINOR,
                            NOTIFY_NEW_ALARM, COMMUNICATIONS_ALARM,
                            UNAVAILABLE, EXPEDITED_ALARM,
                            /* Spr 12880 Fix Start*/
                            "X2 LINK DOWN INDICATION", OAM_NULL,CellId);
                    /* Spr 12880 Fix End*/
                }
                else {
                OAM_LOG(OAM, OAM_WARNING, "SON_OAM_X2_LINK_DOWN_IND Message Parssing failed");
                }

                oam_mem_free(p_oam_son_x2_link_down_ind, &err);
                break;
                /* RT SPR 12768 FIX END */

        case SON_OAM_PCI_SELECTION_RESP:
                {
                    /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                    if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                        break;
                    }
#endif
                    /* SPR 9620 CHANGE END */
                /*SPR 21561 +-*/
                    oam_son_pci_selection_resp_t oam_son_pci_selection_resp;
                    length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                    length_read= OAM_ZERO;

                if (OAM_SUCCESS == oam_parse_son_oam_pci_selection_resp(&oam_son_pci_selection_resp,
                            p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,                           
                            length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            &length_read))
                {
                    /* Start: CSR 00058940 */
                    initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;
                    /*End: CSR 00058940 */
                    OAM_LOG(OAM, OAM_INFO, "SON_OAM_PCI_SELECTION : Parsing Success");
                    if(SON_SUCCESS == oam_son_pci_selection_resp.result)
                        {

                            /* SPR 13024 FIX START */
                            cell_config_idx1 = oam_get_son_serving_cell_idx(
                                    oam_prov_req.cell_cntxt.curr_cell_cid);
                            if(OAM_ERROR_RETURN_VAL == cell_config_idx1) {
                            OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                        oam_prov_req.cell_cntxt.curr_cell_cid);
                                return OAM_FAILURE;
                            }
                            /* SPR 13024 FIX END */
                            OAM_LOG(OAM, OAM_INFO, "SON_OAM_PCI_SELECTION Result : Success");
                            /* Start: CSR 00058940 */
                            OAM_LOG(OAM, OAM_INFO,"Sending Cell configuration for selected cell ID : %d",
                                    oam_son_pci_selection_resp.selected_pci);


                            /* SPR 13024 FIX START */
                            cell_config_idx = oam_get_rrm_cell_config_idx(cid);
                            if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                            OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                        cid);
                                retVal = OAM_FAILURE;
                                break;
                            }
                            /* SPR 13024 FIX END */
                            oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.rf_params.rf_configurations.phy_cell_id = 
                                oam_son_pci_selection_resp.selected_pci;
                            /*SPR 21702 Start*/
                            oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                                serving_cell[OAM_ZERO].pci = oam_son_pci_selection_resp.selected_pci;
                            /*SPR 21702 End*/
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.
                                srvd_cell.srvd_cell_arr[OAM_ZERO].served_cell_info.pci = 
                                oam_son_pci_selection_resp.selected_pci;
                            /*End: CSR 00058940 */

                        }
                        else
                        {
                            OAM_ALARM(CRITICAL_CONFIGURATION_FAILURE_ALARM_ID,CRITICAL,NOTIFY_NEW_ALARM,
                                    PROCESSING_ERROR_ALARM,UNAVAILABLE,EXPEDITED_ALARM,
                                    "Startup Configuration Failure: PCI SELECTION Failure ",
                                    /* Spr 12880 Fix Start*/
                                    OAM_NULL,CellId);
                            /* Spr 12880 Fix End*/
                        OAM_LOG(OAM, OAM_INFO, "SON_OAM_PCI_SELECTION Result : Failure. "
                            "SON is not able to select a PCI from the list provided");
                        }
                    }
                    else
                    {
                        OAM_ALARM(CRITICAL_CONFIGURATION_FAILURE_ALARM_ID,CRITICAL,NOTIFY_NEW_ALARM,
                                PROCESSING_ERROR_ALARM,UNAVAILABLE,EXPEDITED_ALARM,
                                "Startup Configuration Failure: PCI SELECTION Failure",
                                /* Spr 12880 Fix Start*/
                                OAM_NULL,CellId);
                        /* Spr 12880 Fix End*/
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_SELECTION : Parsing Failure");
                        /* Start: CSR 00058940 */
                        return OAM_FAILURE;
                        /*End: CSR 00058940 */
                    }
                    /* Start: CSR 00058940 */
                    /*SPR_15770 Fix start*/	
                    /*check scan_on_boot is enable trigger nw scan*/
                    /*SPR_16048 Fix Start*/
                    if((OAM_TRUE == oam_prov_req.oam_son_req.temp_values.scan_on_boot)  && 
                            (OAM_TRUE == oam_prov_req.system_status.is_nmm_enabled))
                        /*SPR_16048 Fix End*/
                    {
                        initialisation_flag |= INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK;

                        /*SPR_16636 Fix Start*/
                        if(OAM_TRUE == oam_prov_req.oam_igd_params.rem_lte_params.scan_periodically)
                        {
                        if(OAM_SUCCESS == 
                                    oam_son_send_son_oam_periodic_nw_scan_req(
                                        &(LOCAL_SON_PROV_REQ.periodic_nw_scan),
                                        OAM_MODULE_ID, SON_MODULE_ID,
                                        tcb_transaction_id,
                                        curr_cid))

                            {
                                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PERIODIC_NW_SCAN_REQ sent Successfully!!");
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PERIODIC_NW_SCAN_REQ sent Failure");
                                return OAM_FAILURE;
                            }
                        }
                        else
                        {
                            /*SPR_18666 Fix Start*/
                            tran_id = oam_get_new_trans_id();
                            /*SPR_18666 Fix End*/
                            /*SPR_16636 Fix End*/
                        if(OAM_SUCCESS == 
                                    oam_son_send_son_oam_nw_scan_req(
                                        &(oam_prov_req.oam_son_req.nw_scan),
                                        OAM_MODULE_ID,
                                        SON_MODULE_ID,
                                        tran_id,
                                        oam_prov_req.cell_cntxt.curr_cell_cid))

                            {
                                OAM_LOG(OAM,OAM_DETAILED, "SON_OAM_NW_SCAN_REQ sent Successfully");
                            }
                            else
                            {
                                OAM_LOG(OAM,OAM_ERROR, "SON_OAM_NW_SCAN_REQ sent Failure, cell context = %d", oam_prov_req.cell_cntxt.curr_cell_cid);
                            }
                            /*SPR_16636 Fix start*/
                        }
                        /*SPR_16636 Fix End*/
                    }
                /*SPR_15770 Fix end*/	
                /*SPR_18664 Fix Start*/
		/*SPR 21561 +-*/
                /*End: CSR 00058940 */
            }
            break;
        case SON_OAM_PCI_RESELECTION_RESP:
            OAM_LOG(OAM, OAM_INFO, "SON_OAM_PCI_RESELECTION_RESP received");

            /* SPR 13024 FIX START */
            retVal = oam_mem_alloc(sizeof(oam_son_pci_reselection_resp_t),
                    (void**)&p_pci_reselection_resp,
                    &err);

            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_pci_reselection_resp failed"
                        " with Error Code:%d",
                        err);
                    break;
            }

            oam_memset(p_pci_reselection_resp, 0,
                    sizeof(oam_son_pci_reselection_resp_t));


            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal =
                oam_parse_son_oam_pci_reselection_resp(p_pci_reselection_resp,
                        p_tmp_buf,
                        length_left,
                        &length_read);

            /* Coverity 69302 FIX START */
            cid = oam_extract_cid_from_eutran_cellidentity(
                    p_pci_reselection_resp->src_cgi.cell_identity);

            p_cell_status = oam_get_cell_cntxt_status(cid);
            if (!p_cell_status) {
                OAM_LOG(OAM, OAM_WARNING, "Invalid cell context: %d", cid);

                oam_mem_free(p_pci_reselection_resp, &err);
                retVal = OAM_FAILURE;
                break;;
            }
            /* Coverity 69302 FIX END */

            if (OAM_SUCCESS == retVal) {
                if (!(p_cell_status->cell_event & OAM_CELL_PCI_CONFLICT)) {
#ifndef OAM_UT_FRAMEWORK
                    retVal = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                            &tcb_data.usr_req_trans_id,
                            &tcb_data.usr_intf_src_id,
                            &tcb_data.p_orig_xml_parent,
                            &tcb_data.p_usr_msg_xml_parent,
                            &tcb_data.p_parent_xml_struct_addr);

                    if (OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_WARNING, "Failed to process TCB entry");
                        /*coverity 85859  fix start*/
                        oam_mem_free(p_pci_reselection_resp, &err);
                        retVal = OAM_FAILURE;
                        /*coverity 85859 fix end*/
                        break;
                    }
#endif
                }
                else {
                    retVal = oam_process_tcb_for_layer_resp(p_api_buf,
                            &tcb_data.usr_req_trans_id,
                            &tcb_data.usr_intf_src_id);
                }


                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_PCI_RESELECTION: Parsing Success."
                        " Received cell id: %d", cid);

                if (SON_SUCCESS == p_pci_reselection_resp->result) {
                    OAM_LOG(OAM, OAM_INFO, "SON_OAM_PCI_RESELECTION Success response received. "
                            "Sending cell reconfiguration request "
                            "for selected PCI: %d",
                            p_pci_reselection_resp->reselected_pci);
                    /* SPR 12214 FIX START */
                    trans_id = get_word_from_header(p_api_buf);
                    /* SPR 12214 FIX END */
                    retVal =
                        oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
                                (void**)&p_cell_reconfig_req, &err);
                    if (OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Memory allocation to p_cell_reconfig_req failed"
                                " with Error Code:%d",
                                err);
                        oam_get_err_string_n_err_code(err, &usr_error_code,
                                &err_string);
                        err_str_size = oam_strlen(err_string) + 1;
                        usr_resp = OAM_RESULT_FAILURE;

                        if (!(p_cell_status->cell_event &
                                    OAM_CELL_PCI_CONFLICT)) {
                            oam_construct_n_send_set_resp_to_usr(usr_resp,
                                    usr_error_code,
                                    (UInt8*)err_string,
                                    err_str_size,
                                    OAM_VERSION_ID,
                                    OAM_MODULE_ID,
                                    tcb_data.usr_intf_src_id,
                                    tcb_data.usr_req_trans_id,
                                    OAM_ZERO, OAM_ZERO,
                                    &err);
                        }

                        oam_mem_free(p_pci_reselection_resp, &err);
                        oam_update_xml_dom(OAM_FAILURE,
                                tcb_data.p_orig_xml_parent,
                                tcb_data.p_usr_msg_xml_parent,
                                tcb_data.p_parent_xml_struct_addr);
                        break;
                    }

                    oam_memset(p_cell_reconfig_req, OAM_ZERO,
                            sizeof(oam_rrm_cell_reconfig_req_t));

                    cell_config_idx = oam_get_rrm_cell_config_idx(cid);
                    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                cid);

                        err = OAM_INVALID_CELL_CONTEXT;
                        oam_get_err_string_n_err_code(err, &usr_error_code,
                                &err_string);
                        err_str_size = oam_strlen(err_string) + 1;
                        usr_resp = OAM_RESULT_FAILURE;

                        if (!(p_cell_status->cell_event &
                                    OAM_CELL_PCI_CONFLICT)) {
                            oam_construct_n_send_set_resp_to_usr(usr_resp,
                                    usr_error_code,
                                    (UInt8*)err_string,
                                    err_str_size,
                                    OAM_VERSION_ID,
                                    OAM_MODULE_ID,
                                    tcb_data.usr_intf_src_id,
                                    tcb_data.usr_req_trans_id,
                                    OAM_ZERO, OAM_ZERO,
                                    &err);

                            /* coverity 85859 fix start */
                            /* Code Deleted */
                            /* coverity 85859 fix end */
                            oam_update_xml_dom(OAM_FAILURE,
                                    tcb_data.p_orig_xml_parent,
                                    tcb_data.p_usr_msg_xml_parent,
                                    tcb_data.p_parent_xml_struct_addr);
                       
                           
                        }
                        /* coverity 85859 fix start */
                        retVal = OAM_FAILURE;
                        oam_mem_free(p_pci_reselection_resp, &err);
                        oam_mem_free(p_cell_reconfig_req, &err);
                        /* coverity 85859 fix end */
                        /* Coverity 99049_99050 + */
                        break;
                        /* Coverity 99049_99050 - */
                    }


                    p_local_cell_config =
                        &LOCAL_RRM_CELL_CONFIG(cell_config_idx);
                    p_rrm_cell_config =
                        &RRM_CELL_CONFIG(cell_config_idx);

                    /* SPR 13060 FIX START */
                    oam_memcpy(&p_local_cell_config->global_cell_info, 
                            &p_rrm_cell_config->global_cell_info, 
                            sizeof(rrm_oam_cell_info_t));


                    oam_memcpy(&p_local_cell_config->ran_info.rf_params, 
                            &p_rrm_cell_config->ran_info.rf_params, 
                            sizeof(rrm_oam_rf_params_t));
                    /* SPR 13060 FIX END */


                    p_local_cell_config->ran_info.rf_params.
                        rf_configurations.phy_cell_id =
                        p_pci_reselection_resp->reselected_pci;

                    /* SPR 13060 FIX START */
                    p_cell_reconfig_req->bitmask |= RRM_OAM_RAN_INFO_PRESENT;
                    p_cell_reconfig_req->ran_info.
                        bitmask |= RRM_OAM_RF_PARAMS_PRESENT;
                    /* SPR 13060 FIX END */

                    oam_copy_config_to_reconfig(p_local_cell_config, 
                            p_cell_reconfig_req); 

                    retVal = oam_rrm_send_rrm_oam_cell_reconfig_req(
                            p_cell_reconfig_req,
                            OAM_MODULE_ID,
                            RRM_MODULE_ID,
                            trans_id,
                            cid);
                    if (OAM_SUCCESS == retVal) {
                        OAM_LOG(OAM, OAM_INFO,
                                "RRM_OAM_CELL_RECONFIG_REQ sent successfully!!");

                        if (!(p_cell_status->cell_event &
                                    OAM_CELL_PCI_CONFLICT)) {

                            oam_cp_pack_UInt16(
                                    p_api_buf + OAM_INTF_HDR_TRANS_ID_OFFSET,
                                    &tcb_data.usr_req_trans_id,"abc");

                            oam_cp_pack_UInt16(
                                    p_api_buf + OAM_INTF_HDR_SRC_ID_OFFSET,
                                    &tcb_data.usr_intf_src_id,"abc");

#ifndef OAM_UT_FRAMEWORK
                            retVal = oam_maintain_tcb_ext(trans_id,
                                    OAM_TRANS_RRM,
                                    msg_len, p_api_buf,
                                    tcb_data.p_orig_xml_parent,
                                    tcb_data.p_usr_msg_xml_parent,
                                    tcb_data.p_parent_xml_struct_addr);

                                if (OAM_FAILURE == retVal) {
                                OAM_LOG(OAM, OAM_WARNING,
                                            "Failed to maintain TCB ");
                                    err = OAM_INTERNAL_ERROR;
                                }
#endif
                        }
                        else {
#ifndef OAM_UT_FRAMEWORK
                            retVal = oam_maintain_tcb(trans_id,
                                    OAM_TRANS_RRM,
                                    msg_len, p_api_buf);

                            if (OAM_FAILURE == retVal) {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "Failed to maintain TCB ");
                            }
#endif
                        }
                    }
                    else {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Failed to send RRM_OAM_CELL_RECONFIG_REQ!!");
                        err = OAM_SEND_FAIL;
                    }
                }
                else {

                    /* Spr 17753 Changes Start */
                    if(p_pci_reselection_resp->error_code == SON_ERR_PCI_RESELECTION_NOT_REQUIRED)
                    {
		        OAM_LOG(OAM, OAM_WARNING, "SON_OAM_PCI_RESELECTION Failure response received"
                            " with error code: %d",
                            p_pci_reselection_resp->error_code);
                        lp = oam_get_earfcn_pci_select_arr_idx(cid);
                        /* CID 115960-115962 + */
                        if(lp != OAM_ERROR_RETURN_VAL)
                        {
                        /* CID 115960-115962 - */
                        /* Updating the list with latest list */ 
                        oam_memcpy(&oam_prov_req.oam_son_req.earfcn_pci_selection[lp].oam_son_pci_reselection_req,
                                &local_prov_req.oam_son_req.earfcn_pci_selection[lp].oam_son_pci_reselection_req,
                                sizeof(oam_son_pci_reselection_req_t));

                        err_string = OAM_NULL;
                        err_str_size = OAM_ZERO;
                        usr_error_code = OAM_ZERO;
                        usr_req_resp = OAM_RESULT_SUCCESS;
                        /* CID 115960-115962 + */
                        }
                        else
                        {
                           OAM_LOG(OAM, OAM_ERROR, "Negitive array index returned by oam_get_earfcn_pci_select_arr_idx");
                        }
                    }

                    else if ((p_pci_reselection_resp->error_code != SON_ERR_PCI_RESELECTION_NOT_REQUIRED) ||
                               (lp == OAM_ERROR_RETURN_VAL))
                    /* CID 115960-115962 - */
                    {
                        OAM_LOG(OAM, OAM_INFO, "\nSON_OAM_PCI_RESELECTION Result : Failure");
                        OAM_LOG(OAM, OAM_INFO, "\nSON is not able to re-select a PCI from the list provided");
                        /*SPR 15281 START */
                        OAM_ALARM(OAM_SON_PCI_RESELECTION_FAILURE,
                                CRITICAL,
                                NOTIFY_NEW_ALARM,
                                NOTIFICATION_TYPE,
                                UNAVAILABLE,
                                EXPEDITED_ALARM,
                                "PCI Reselection Failure",
                                OAM_NULL,
                                CellId);
                        /*SPR 15281 END */

                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                        usr_req_resp = OAM_RESULT_FAILURE;
                        err_string = "pci reselction failed at SON";
                        err_str_size = oam_strlen(err_string)+1;
                    }
                    if(g_son_triggered_reconfig_flag == OAM_FALSE)
                    {
                        if(!tcb_det) {
                            OAM_LOG(OAM, OAM_ERROR, "Can't fetch TCB details. "
                                    "Response to user request can't be sent.");
                            /*coverity 85859  fix start*/
                            oam_mem_free(p_pci_reselection_resp, &err);
                            retVal = OAM_FAILURE;
                            /*coverity 85859 fix end*/
                            retVal = OAM_FAILURE;
                            break;
                        }

                        p_usr_req = tcb_det->oam_tcb_context;
                        dst_id = get_word_from_header(p_usr_req + OAM_TWO);
                        resp_trans_id = get_word_from_header(p_usr_req);

                        retVal = oam_stop_timer(tcb_det->timer_id);
                        if(OAM_SUCCESS != retVal) {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Error returned while stopping the timer");
                        }
                        else {
                            OAM_LOG(OAM, OAM_INFO, "User request timer stopped");
                        }

                        oam_tcb_delete(&trans_id);
                        oam_construct_n_send_set_resp_to_usr(usr_req_resp,//1 for failure
                                usr_error_code,
                                (UInt8 *)err_string, err_str_size,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                                &err);
                    }
                    g_son_triggered_reconfig_flag = OAM_FALSE;
                    /* Spr 17753 Changes End */
                
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_PCI_RESELECTION: Parsing Failure");

                /*SPR 15281 START */
                UInt8 CellId = OAM_INVALID_CELL_ID;
                OAM_ALARM(OAM_SON_PCI_RESELECTION_FAILURE,
                        CRITICAL,
                        NOTIFY_NEW_ALARM,
                        NOTIFICATION_TYPE,
                        UNAVAILABLE,
                        EXPEDITED_ALARM,
                        "PCI Reselection Failure",
                        OAM_NULL,
                        CellId);
                /*SPR 15281 END */
                err = OAM_PARSE_MSG_DMG; 

                oam_get_err_string_n_err_code(err, &usr_error_code,
                        &err_string);
                err_str_size = oam_strlen(err_string) + OAM_ONE;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if ((OAM_FAILURE == retVal)) {
                if (!(p_cell_status->cell_event & OAM_CELL_PCI_CONFLICT)) {
                    oam_construct_n_send_set_resp_to_usr(usr_resp,
                            usr_error_code,
                            (UInt8*)err_string,
                            err_str_size,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            tcb_data.usr_intf_src_id,
                            tcb_data.usr_req_trans_id,
                            OAM_ZERO, OAM_ZERO,
                            &err);
                }
                else {
                    p_cell_status->cell_event &= ~OAM_CELL_PCI_CONFLICT;
                }
            }

            oam_mem_free(p_pci_reselection_resp, &err);
            oam_mem_free(p_cell_reconfig_req, &err);
            /* SPR 13024 FIX END */
            break;

        case SON_OAM_PCI_CONFLICT_CONFUSION_IND:
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_PCI_CONFLICT_CONFUSION_IND received");
            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_mem_alloc(
                    sizeof(oam_son_pci_conflict_confusion_ind_t),
                    (void**)&p_pci_conflict_confusion_ind, &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_pci_conflict_confusion_ind failed"
                        " with Error Code:%d",
                        err);

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }

            oam_memset(p_pci_conflict_confusion_ind, OAM_ZERO,
                    sizeof(oam_son_pci_conflict_confusion_ind_t));

            retVal = oam_parse_son_oam_pci_conflict_confusion_ind(
                    p_pci_conflict_confusion_ind,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_PCI_CONFLICT_CONFUSION_IND: Parsing Success");

                cid = oam_extract_cid_from_eutran_cellidentity(
                        p_pci_conflict_confusion_ind->src_cgi.
                        intra_rat_global_cell_id.cell_identity);

                oam_decode_bit_stream_into_eutran_cellidentity(
                        p_pci_conflict_confusion_ind->src_cgi.
                        intra_rat_global_cell_id.cell_identity,
                        &serv_cellidentity);

                oam_decode_bit_stream_into_eutran_cellidentity(
                        p_pci_conflict_confusion_ind->cgi_1.
                        intra_rat_global_cell_id.cell_identity,
                        &neigh1_cellidentity);

                switch (p_pci_conflict_confusion_ind->cause) {
                    case SON_PCI_CONFLICT:
                    /* SPR 13024 FIX START */
                    oam_snprintf(add_txt, OAM_ALARM_ADD_TXT_MAX_LEN,
                            "PCI conflict detected for serving cell "
                            "identity[%d] with neighbor cell identity[%d]",
                            serv_cellidentity, neigh1_cellidentity);

                    OAM_LOG(OAM, OAM_INFO, "%s", add_txt);

                    resp_trans_id = oam_get_new_trans_id(); 

                    loop = oam_get_earfcn_pci_select_arr_idx(cid);

                    if(OAM_ERROR_RETURN_VAL == (SInt32)loop) {
                            OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                cid);

                        retVal = OAM_FAILURE;
                        break;
                    }

                    cell_config_idx = oam_get_son_serving_cell_idx(cid);
                    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                            OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                cid);

                        retVal = OAM_FAILURE;
                        break;
                    }
                    /* SPR 13024 FIX END */

                    /*SPR 21702 Start*/
                    if (SON_PROV_REQ.oam_son_cell_info_ind[cell_config_idx].
                            /*SPR 21702 End*/
                            serving_cell[OAM_ZERO].
                            choice_eutra_mode.bitmask &
                            SON_EUTRA_MODE_FDD) {
                        SON_PROV_REQ.earfcn_pci_selection[loop].
                            oam_son_pci_reselection_req.earfcn =
                            /*SPR 21702 Start*/
                            SON_PROV_REQ.oam_son_cell_info_ind[cell_config_idx].
                            /*SPR 21702 End*/
                            serving_cell[OAM_ZERO].
                            choice_eutra_mode.fdd_info.dl_earfcn;
                    }
                    else {
                        SON_PROV_REQ.earfcn_pci_selection[loop].
                            oam_son_pci_reselection_req.earfcn =
                            /*SPR 21702 Start*/
                            SON_PROV_REQ.oam_son_cell_info_ind[cell_config_idx].
                            /*SPR 21702 End*/
                            serving_cell[OAM_ZERO].
                            choice_eutra_mode.tdd_info.earfcn;
                    }

                    /* SPR 13060 FIX START */
                    oam_memcpy(&SON_PROV_REQ.earfcn_pci_selection[loop].
                            oam_son_pci_reselection_req.src_cgi,
                            /*SPR 21702 Start*/
                            &SON_PROV_REQ.oam_son_cell_info_ind[cell_config_idx].
                            /*SPR 21702 End*/
                            serving_cell[OAM_ZERO].src_cgi,
                            sizeof(son_intra_rat_global_cell_id_t));
                    /* SPR 13060 FIX END */
                        /* Spr 17753 Changes Start */
                        if((OAM_ONE == oam_prov_req.oam_son_req.earfcn_pci_selection[loop].oam_son_pci_reselection_req.pci_list_size)&&
                                (oam_prov_req.oam_son_req.earfcn_pci_selection[loop].oam_son_pci_reselection_req.pci_list[0] == 
                                 oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.rf_params.rf_configurations.phy_cell_id ))
                        {
                            OAM_LOG(OAM, OAM_ERROR, "SON_OAM_PCI_RESELECTION_REQ Failed"
                                    " As PCI List Only Contain the Serving cell pci = %d",
                                    oam_prov_req.oam_son_req.earfcn_pci_selection[loop].
                                    oam_son_pci_reselection_req.pci_list[0]);
                        }

                        else if(g_son_triggered_reconfig_flag == OAM_FALSE)
                        {    
                        /* Spr 17753 Changes End */
                    /* SPR 13024 FIX START */
                    retVal = oam_son_send_son_oam_pci_reselection_req(
                            &(SON_PROV_REQ.earfcn_pci_selection[loop].
                                oam_son_pci_reselection_req),
                            OAM_MODULE_ID, SON_MODULE_ID,
                            resp_trans_id, cid);

                    if (OAM_SUCCESS == retVal) {
                        OAM_LOG(OAM, OAM_INFO,
                                "SON_OAM_PCI_RESELECTION_REQ sent "
                                "Successfully");
#ifndef OAM_UT_FRAMEWORK
                        /* SPR 13060 FIX START */
                        retVal = oam_maintain_tcb(resp_trans_id,
                                OAM_TRANS_SON,
                                msg_len, p_api_buf);
                        /* SPR 13060 FIX END */

                        if (OAM_FAILURE == retVal) {
                                OAM_LOG(OAM, OAM_WARNING,
                                    "Failed to maintain TCB ");
                        }
                        else {
                            p_cell_status = oam_get_cell_cntxt_status(cid);

                            if (!p_cell_status) {
                                    OAM_LOG(OAM, OAM_WARNING,
                                        "Invalid cell context: %d", cid);
                                retVal = OAM_FAILURE;
                                break;
                            }

                            p_cell_status->cell_event |= OAM_CELL_PCI_CONFLICT;
                        }
#endif
                    }
                    else {
                        OAM_LOG(OAM, OAM_ERROR, "Failed to send "
                                "SON_OAM_PCI_RESELECTION_REQ");
                    }

                        /* Spr 17753 Changes Start */
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_ERROR, "\nnot sending SON_OAM_PCI_RESELECTION_REQ"
                                    " as cell reconfig triggered from SON is already ongoing");
                        }
                        /* Spr 17753 Changes End */


                    OAM_ALARM(OAM_SON_PCI_CONFLICT_NOTIFICATION,
                            WARNING,
                            NEW_NOTIFICATION,
                            NOTIFICATION_TYPE,
                            UNAVAILABLE,
                            EXPEDITED_ALARM,
                            add_txt,
                            /* Spr 12880 Fix Start*/
                            OAM_NULL, cid);
                    /* Spr 12880 Fix End*/
                    /* SPR 13024 FIX END */
                    break;

                    case SON_PCI_CONFUSION:
                    oam_decode_bit_stream_into_eutran_cellidentity(
                            p_pci_conflict_confusion_ind->cgi_2.
                            intra_rat_global_cell_id.cell_identity,
                            &neigh2_cellidentity);
                    /*  SPR 13199 START */
                    oam_snprintf(add_txt, OAM_ALARM_ADD_TXT_MAX_LEN,
                            "PCI confusion detected for serving cell "
                            "identity[%d] with neighbor cell identities "
                            "[%d] and [%d]",
                            serv_cellidentity, neigh1_cellidentity,
                            neigh2_cellidentity);
                    /*  SPR 13199 END */

                    OAM_LOG(OAM, OAM_INFO, "%s", add_txt);

                    OAM_ALARM(OAM_SON_PCI_CONFUSION_NOTIFICATION,
                            WARNING,
                            NEW_NOTIFICATION,
                            NOTIFICATION_TYPE,
                            UNAVAILABLE,
                            EXPEDITED_ALARM,
                            add_txt,
                            /* Spr 12880 Fix Start*/
                            /* SPR 13060 FIX START */
                            OAM_NULL, cid);
                    /* SPR 13060 FIX END */
                    /* Spr 12880 Fix End*/
                    break;

                    case SON_PCI_CONFLICT_CLEARED:
                    oam_snprintf(add_txt, OAM_ALARM_ADD_TXT_MAX_LEN,
                            "PCI conflict resolved for serving cell "
                            "identity[%d] with neighbor cell identity[%d]",
                            serv_cellidentity, neigh1_cellidentity);

                    /* SPR 13060 FIX START */
                    OAM_LOG(OAM, OAM_INFO, "%s", add_txt);
                    /* SPR 13060 FIX END */

                    OAM_ALARM(OAM_SON_PCI_CONFLICT_NOTIFICATION,
                            CLEARED,
                            NOTIFY_CLEARED_ALARM,
                            NOTIFICATION_TYPE,
                            UNAVAILABLE,
                            EXPEDITED_ALARM,
                            add_txt,
                            /* Spr 12880 Fix Start*/
                            /* SPR 13060 FIX START */
                            OAM_NULL, cid);
                    /* SPR 13060 FIX END */
                    /* Spr 12880 Fix End*/
                    break;

                    case SON_PCI_CONFUSION_CLEARED:
                    oam_decode_bit_stream_into_eutran_cellidentity(
                            p_pci_conflict_confusion_ind->cgi_2.
                            intra_rat_global_cell_id.cell_identity,
                            &neigh2_cellidentity);
                    /*  SPR 13199 START */
                    oam_snprintf(add_txt, OAM_ALARM_ADD_TXT_MAX_LEN,
                            "PCI confusion resolved for serving cell "
                            "identity[%d] with neighbor cell identities "
                            "[%d] and [%d]",
                            serv_cellidentity, neigh1_cellidentity,
                            neigh2_cellidentity);
                    /*  SPR 13199 END */

                    /* SPR 13060 FIX START */
                    OAM_LOG(OAM, OAM_INFO, "%s", add_txt);
                    /* SPR 13060 FIX END */

                    OAM_ALARM(OAM_SON_PCI_CONFUSION_NOTIFICATION,
                            CLEARED,
                            NOTIFY_CLEARED_ALARM,
                            NOTIFICATION_TYPE,
                            UNAVAILABLE,
                            EXPEDITED_ALARM,
                            add_txt,
                            /* Spr 12880 Fix Start*/
                            /* SPR 13060 FIX START */
                            OAM_NULL, cid);
                    /* SPR 13060 FIX END */
                    /* Spr 12880 Fix End*/
                    break;

                    default:
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cause for "
                            "SON_OAM_PCI_CONFLICT_CONFUSION_IND received");
                    retVal = OAM_FAILURE;
                }
                /* SPR-12596 Start */
                /*SPR 9614 Fix start*/
                if(oam_prov_req.oam_tr069_req.tr069_mode)
                {
                    if (oam_inform_son_pci_conflict_confusion_ind_hems(
                                p_pci_conflict_confusion_ind, &err) == OAM_FAILURE)
                    {
                        OAM_LOG(OAM, OAM_WARNING, "SON_OAM_PCI_CONFLICT_CONFUSION_IND : error sending"
                                " inform message to HeMS");
                        /* Coverity ID : 85864 Fix Start*/
                        oam_mem_free(p_pci_conflict_confusion_ind, &err);
                        /* Coverity ID : 85864 Fix End*/	
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                    /*SPR 9614 Fix end*/
                }
                /* SPR-12596 End */
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_PCI_CONFLICT_CONFUSION_IND: Parsing Failure");
            }

            oam_mem_free(p_pci_conflict_confusion_ind, &err);
            break;

        case SON_OAM_ES_ENABLE_RESP:
            OAM_LOG(OAM, OAM_INFO, "Received SON_OAM_ES_ENABLE_RESP from SON");

            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed in SON_OAM_ES_ENABLE_RESP");
                break;
            }

#endif

            /* SPR 9620 CHANGE END */
            retVal = oam_mem_alloc(sizeof(oam_son_es_enable_resp_t),
                    (void**)&p_son_es_enable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_es_enable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_es_enable_resp, OAM_ZERO,
                    sizeof(oam_son_es_enable_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            retVal = oam_parse_son_oam_es_enable_resp(p_son_es_enable_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ES_ENABLE_RESP: Parsing Success");

                /* SPR 13024 FIX START */
                cell_config_idx = oam_get_son_serving_cell_idx(cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                    OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            cid);
                    /* Coverity ID : 85856 Fix Start*/
                    oam_mem_free(p_son_es_enable_resp, &err);
                    /* Coverity ID : 85856 Fix End*/
                    return OAM_FAILURE;
                }
                /* SPR 13024 FIX END */

                if(SON_SUCCESS == p_son_es_enable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ES_ENABLE_RESP returned success");

                    /* SPR 13024 FIX START */
                    /* Code moved */
                    /* SPR 13024 FIX END */
                    SON_PROV_REQ.oam_energy_saving_config[cell_config_idx].
                        es_enable_disable = OAM_ONE;

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ES_ENABLE_RESP returned failure");

                    err_string = "Unable to enable son ES";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                    SON_PROV_REQ.oam_energy_saving_config[cell_config_idx].
                        es_enable_disable = OAM_ZERO;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_MLB_ENABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";

                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if (usr_intf_flag) {
                usr_intf_flag = OAM_FALSE;

                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        &err);

            }

            oam_mem_free(p_son_es_enable_resp, &err);
            break;

        case SON_OAM_ES_DISABLE_RESP:
            OAM_LOG(OAM, OAM_INFO, "Received SON_OAM_ES_DISABLE_RESP from SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, 
                        &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function "
                        " failed in SON_OAM_ES_DISABLE_RESP");
                break;
            }
#endif
            /* SPR 9620 CHANGE END */
            retVal = oam_mem_alloc(sizeof(oam_son_es_disable_resp_t),
                    (void**)&p_son_es_disable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_es_disable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_es_disable_resp, OAM_ZERO,
                    sizeof(oam_son_es_disable_resp_t));


            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            retVal = oam_parse_son_oam_es_disable_resp(p_son_es_disable_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);


            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ES_DISABLE_RESP: Parsing Success");
                if(SON_SUCCESS == p_son_es_disable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ES_DISABLE_RESP returned success");

                    cell_config_idx = oam_get_son_serving_cell_idx(
                            oam_prov_req.cell_cntxt.curr_cell_cid);
                    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                oam_prov_req.cell_cntxt.curr_cell_cid);
                        /* SPR_19838 :Coverity_10861 Fix Start */
                        oam_mem_free(p_son_es_disable_resp, &err);
                        /* SPR_19838 :Coverity_10861 Fix Stop */
                        return OAM_FAILURE;
                    }

                    SON_PROV_REQ.oam_energy_saving_config[cell_config_idx].
                        es_enable_disable = OAM_ZERO;

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ES_DISABLE_RESP returned failure");

                    err_string = "Unable to disable son ES";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_MLB_DISABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";

                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if (usr_intf_flag) {
                usr_intf_flag = OAM_FALSE;


                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        &err);

            }

            oam_mem_free(p_son_es_disable_resp, &err);
            break;

        case SON_OAM_MRO_ENABLE_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_MRO_ENABLE_RESP from SON");

            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                break;
            }
#endif
            /* SPR 9620 CHANGE END */

            retVal = oam_mem_alloc(sizeof(oam_son_mro_enable_resp_t),
                    (void**)&p_son_mro_enable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_mro_enable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_mro_enable_resp, OAM_ZERO,
                    sizeof(oam_son_mro_enable_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_mro_enable_resp(p_son_mro_enable_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_MRO_ENABLE_RESP: Parsing Success");

                if(SON_SUCCESS == p_son_mro_enable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_MRO_ENABLE_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_MRO_ENABLE_RESP returned failure");

                    err_string = "Unable to enable son MRO";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_MRO_ENABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if (usr_intf_flag) {
                usr_intf_flag = OAM_FALSE;


                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        &err);

            }

            oam_mem_free(p_son_mro_enable_resp, &err);
            break;

        case SON_OAM_MRO_DISABLE_RESP:
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                break;
            }
#endif
            /* SPR 9620 CHANGE END */
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_MRO_DISABLE_RESP from SON");

            retVal = oam_mem_alloc(sizeof(oam_son_mro_disable_resp_t),
                    (void**)&p_son_mro_disable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_mro_disable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_mro_disable_resp, OAM_ZERO,
                    sizeof(oam_son_mro_disable_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;


            retVal =
                oam_parse_son_oam_mro_disable_resp(p_son_mro_disable_resp,
                        p_tmp_buf,
                        length_left,
                        &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_MRO_DISABLE_RESP: Parsing Success");

                if(SON_SUCCESS == p_son_mro_disable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_MRO_DISABLE_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_MRO_DISABLE_RESP returned failure");

                    err_string = "Unable to disable son MRO";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_MRO_DISABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";

                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if (usr_intf_flag) {
                usr_intf_flag = OAM_FALSE;


                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        &err);

            }

            oam_mem_free(p_son_mro_disable_resp, &err);
            break;

        case SON_OAM_MLB_ENABLE_RESP:
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_MLB_ENABLE_RESP from SON");

            retVal = oam_mem_alloc(sizeof(oam_son_mlb_enable_resp_t),
                    (void**)&p_son_mlb_enable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_mlb_enable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_mlb_enable_resp, OAM_ZERO,
                    sizeof(oam_son_mlb_enable_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal =
                oam_parse_son_oam_mlb_enable_resp(p_son_mlb_enable_resp,
                        p_tmp_buf,
                        length_left,
                        &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_MLB_ENABLE_RESP: Parsing Success");
                if(SON_SUCCESS == p_son_mlb_enable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_MLB_ENABLE_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_MLB_ENABLE_RESP returned failure");

                    err_string = "Unable to enable son MLB";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_MLB_ENABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";

                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if (usr_intf_flag) {
                usr_intf_flag = OAM_FALSE;


                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        &err);

            }

            oam_mem_free(p_son_mlb_enable_resp, &err);
            break;

        case SON_OAM_MLB_DISABLE_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_MLB_DISABLE_RESP from SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */
            retVal = oam_mem_alloc(sizeof(oam_son_mlb_disable_resp_t),
                    (void**)&p_son_mlb_disable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_mlb_disable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_mlb_disable_resp, OAM_ZERO,
                    sizeof(oam_son_mlb_disable_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;


            retVal = oam_parse_son_oam_mlb_disable_resp(p_son_mlb_disable_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_MLB_DISABLE_RESP: Parsing Success");
                if(SON_SUCCESS == p_son_mlb_disable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_MLB_DISABLE_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_MLB_DISABLE_RESP returned failure");

                    err_string = "Unable to disable son MLB";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_MLB_ENABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";

                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if (usr_intf_flag) {
                usr_intf_flag = OAM_FALSE;


                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        &err);

            }

            oam_mem_free(p_son_mlb_disable_resp, &err);
            break;

        case SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_RESP:
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_RESP from SON");

            retVal = oam_mem_alloc(
                    sizeof(oam_son_es_modify_ue_count_interval_resp_t),
                    (void**)&p_oam_son_es_modify_ue_count_interval_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR, "Memory allocation to "
                    "p_oam_son_es_modify_ue_count_interval_resp failed"
                    " with Error Code:%d", err);
                break;
            }

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read= OAM_ZERO;


            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_es_modify_ue_count_interval_resp(
                    p_oam_son_es_modify_ue_count_interval_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_RESP : "
                        "Parsing Success");

                if(p_oam_son_es_modify_ue_count_interval_resp->result ==
                        SON_SUCCESS) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_RESP "
                            "returned success");
                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_RESP "
                            "returned failure");
                    err_string = "Unable to modify ue count interval son ES";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;

                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ES_MODIFY_UE_COUNT_INTERVAL_RESP : "
                        "Parsing Failed");
                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);

            oam_mem_free(p_oam_son_es_modify_ue_count_interval_resp, &err);
            break;

        case SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_RESP from SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */

            retVal = oam_mem_alloc(
                    sizeof(oam_son_es_modify_ue_count_threshold_resp_t),
                    (void**)&p_oam_son_es_modify_ue_count_threshold_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_oam_son_es_modify_ue_count_threshold_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read= OAM_ZERO;


            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_es_modify_ue_count_threshold_resp(
                    p_oam_son_es_modify_ue_count_threshold_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_RESP : "
                        "Parsing Success");

                if(p_oam_son_es_modify_ue_count_threshold_resp->result
                        == SON_SUCCESS) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_RESP "
                            "returned success");
                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_RESP "
                            "returned failure");
                    err_string = "Unable to modify ue count threshold";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ES_MODIFY_UE_COUNT_THRESHOLD_RESP : "
                        "Parsing Failed");
                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);

            oam_mem_free(p_oam_son_es_modify_ue_count_threshold_resp, &err);
            break;

        case SON_OAM_ES_AUTONOMOUS_SWITCH_OFF_CONFIG_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_ES_AUTONOMOUS_SWITCH_OFF_CONFIG_RESP "
                    "from SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */

            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_WARNING, "Error in fetching TCB details");
                break;
            }

            retVal = oam_mem_alloc(
                    sizeof(oam_son_es_autonomous_switch_off_config_resp_t),
                    (void**)&p_es_autonomous_switch_off_config_resp,
                    &err);

            if(OAM_FAILURE == retVal) {
                /* Not Enough Memory */
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_es_autonomous_switch_off_config_resp failed"
                        " with Error Code:%d",
                        err);
                /* SPR 20007 : CID 97117 fix start */				
                return OAM_FAILURE;
                /* SPR 20007 : CID 97117 fix end */				
            }

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_es_autonomous_switch_off_config_resp(
                    p_es_autonomous_switch_off_config_resp,
                    p_tmp_buf, length_left, &length_read);
            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ES_AUTONOMOUS_SWITCH_OFF_CONFIG_RESP : "
                        "Parsing Success");

                if(SON_SUCCESS ==
                        p_es_autonomous_switch_off_config_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ES_AUTONOMOUS_SWITCH_OFF_CONFIG_RESP "
                            "returned success");
                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ES_AUTONOMOUS_SWITCH_OFF_CONFIG_RESP "
                            "returned failure");
                    err_string = "autonomous cell switch off failed";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ES_AUTONOMOUS_SWITCH_OFF_CONFIG_RESP : Parsing Failed");
                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);

            oam_mem_free(p_es_autonomous_switch_off_config_resp ,&err);
            break;

        case SON_OAM_ES_CELL_SWITCH_OFF_RESP:
            OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_ES_CELL_SWITCH_OFF_RESP from SON");
            if(!tcb_det) {
                OAM_LOG(OAM, OAM_WARNING, "Can't fetch TCB details. "
                        "Response to user request can't be sent.");
                retVal = OAM_FAILURE;
                break;
            }

            p_usr_req = tcb_det->oam_tcb_context;
            dst_id = get_word_from_header(p_usr_req + OAM_TWO);
            resp_trans_id = get_word_from_header(p_usr_req);

            retVal = oam_stop_timer(tcb_det->timer_id);
            if(OAM_SUCCESS != retVal) {
                OAM_LOG(OAM, OAM_WARNING,
                        "Error returned while stopping the timer");
            }
            else {
                OAM_LOG(OAM, OAM_INFO, "User request timer stopped");
            }

            oam_tcb_delete(&trans_id);

            oam_son_es_cell_switch_off_resp_t oam_son_es_cell_switch_off_resp;
            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
            length_read= OAM_ZERO;

            if(OAM_SUCCESS== oam_parse_son_oam_es_cell_switch_off_resp(&oam_son_es_cell_switch_off_resp,
                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_left  - LOWER_LAYER_INTERFACE_HEADER_SIZE,&length_read))
            {
                if(oam_son_es_cell_switch_off_resp.result== OAM_ONE)
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO,
                            (UInt8 *)"", OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                    /* coverity 41293 */
                    oam_prov_req.system_status.op_state = (oam_op_state_et)OAM_ZERO;
                    if(OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode)
                    {
                        oam_inform_value_change_event(OAM_ZERO,OAM_MODULE_ID,TR069_MODULE_ID);
                    }
                }
                else
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INVALID_PARAM_NAME,
                            (UInt8 *) "Unable to switch off son ES cell", oam_strlen("Unable to switch off son ES cell")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);

                }
            }
            else
            {
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_INVALID_PARAM_NAME,
                        (UInt8 *) "Unable to switch off son ES cell", oam_strlen("Unable to switch off son ES cell")+ OAM_ONE,
                        OAM_VERSION_ID, OAM_MODULE_ID,
                        dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                        &err);

            }



            break;
        case SON_OAM_ES_CELL_SWITCH_ON_RESP:
            OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_ES_CELL_SWITCH_ON_RESP from SON");
            if(!tcb_det) {
                OAM_LOG(OAM, OAM_WARNING, "Can't fetch TCB details. "
                        "Response to user request can't be sent.");
                retVal = OAM_FAILURE;
                break;
            }

            p_usr_req = tcb_det->oam_tcb_context;
            dst_id = get_word_from_header(p_usr_req + OAM_TWO);
            resp_trans_id = get_word_from_header(p_usr_req);

            retVal = oam_stop_timer(tcb_det->timer_id);
            if(OAM_SUCCESS != retVal) {
                OAM_LOG(OAM, OAM_WARNING,
                        "Error returned while stopping the timer");
            }
            else {
                OAM_LOG(OAM, OAM_INFO, "User request timer stopped");
            }

            oam_tcb_delete(&trans_id);

            oam_son_es_cell_switch_on_resp_t oam_son_es_cell_switch_on_resp;
            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
            length_read= OAM_ZERO;

            if(OAM_SUCCESS== oam_parse_son_oam_es_cell_switch_on_resp(&oam_son_es_cell_switch_on_resp,
                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        &length_read))
            {
                if(oam_son_es_cell_switch_on_resp.result== OAM_ONE)
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO,
                            (UInt8 *)"", OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                    /* coverity 35860 */
                    oam_prov_req.system_status.op_state = (oam_op_state_et)OAM_ONE;
                    if(OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode)
                    {
                        oam_inform_value_change_event(OAM_ZERO,OAM_MODULE_ID,TR069_MODULE_ID);
                    }

                }
                else
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INVALID_PARAM_NAME,
                            (UInt8 *) "Unable to switch on son ES cell", oam_strlen("Unable to switch on son ES cell")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);

                }
            }
            else
            {
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                        OAM_ERR_INVALID_PARAM_NAME,
                        (UInt8 *) "Unable to switch on son ES cell", oam_strlen("Unable to switch on son ES cell")+ OAM_ONE,
                        OAM_VERSION_ID, OAM_MODULE_ID,
                        dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                        &err);

            }
            break;

        case SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_RES:
            {
                /* SPR 13024 FIX START */
                /*SPR_15647 Fix start*/
                /*SPR_15647 Fix end*/
                cell_config_idx = oam_get_rrm_cell_config_idx(
                        oam_prov_req.cell_cntxt.curr_cell_cid);
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                    OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            oam_prov_req.cell_cntxt.curr_cell_cid);
                    return OAM_FAILURE;
                }

                p_rrm_cell_config = &RRM_CELL_CONFIG(cell_config_idx);
                p_local_cell_config = &LOCAL_RRM_CELL_CONFIG(cell_config_idx);

                /*SPR 21702 +-*/
                /* SPR 13024 FIX END */
                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                /* SPR-13074 Start*/
                if(!(OAM_SON_CARRIER_FREQ_ONGOING & oam_prov_req.system_status.event_ongoing))
                {

                    if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                        return OAM_FAILURE;
                    }
                } 
                /* SPR-13074 End*/
#endif

                /*  SPR 9620 CHANGE END */
                /* Start: CSR 00058940 */
                /* U8 send_pci_req = 0;
                   UInt16 dest_id = OAM_ZERO; */
                /*End: CSR 00058940 */
                UInt8 loop;
                oam_son_carrier_freq_and_dl_tx_power_resp_t oam_son_carrier_freq_and_dl_tx_power_resp;
                length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                length_read= OAM_ZERO;
                if(OAM_SUCCESS== oam_parse_son_oam_carrier_freq_and_dl_tx_power_resp(&oam_son_carrier_freq_and_dl_tx_power_resp,
                            p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            &length_read))
                {
                    /* SPR-13074 Start*/
                    if(!oam_son_carrier_freq_and_dl_tx_power_resp.result)
                    {
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_INTERNAL_ERROR,
                                (UInt8 *)"Failure from SON", oam_strlen("Failure from SON")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                &err);

                        OAM_LOG(OAM, OAM_WARNING, "SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_RES: Failure from SON!!");
                    }
                    /* SPR-13074 End*/

                    /* SPR 18541 FIX START*/
                    /*code removed*/
                    /* SPR 18541 FIX END*/

                    /* Start: CSR 00058940 */
                    initialisation_flag |= INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK;
                    /*End: CSR 00058940 */
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_RES: Success!!");
                    if(oam_son_carrier_freq_and_dl_tx_power_resp.bitmask & SON_OAM_CARR_FREQ_DL_TX_PWR_DL_EARFCN_PRESENT)
                    {
                        oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.earfcn=
                                                                                                                 oam_son_carrier_freq_and_dl_tx_power_resp.dl_earfcn;

                        p_rrm_cell_config->ran_info.rf_params.
                            rf_configurations.dl_earfcn =
                            oam_son_carrier_freq_and_dl_tx_power_resp.dl_earfcn;
                        /*SPR 21702 Start*/
                        oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                            serving_cell[OAM_ZERO].choice_eutra_mode.fdd_info.dl_earfcn =oam_son_carrier_freq_and_dl_tx_power_resp.dl_earfcn;
                        /*SPR 21702 End*/
                        /* Update the response values in prov and DOM Tree */
                        UInt8   temp_str[OAM_MAX_STR_LEN]="";
                        oam_snprintf((char*)temp_str, (OAM_MAX_STR_LEN-OAM_ONE), "%d",
                                oam_son_carrier_freq_and_dl_tx_power_resp.dl_earfcn);
                        oam_strcpy((char*)oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcn_list,
                                (char*)temp_str);
                        /* spr_21013_fix_start */
                        oam_persist_one_parameter(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1,"EARFCNDL",
                                /* spr_21013_fix_end */
                                (UInt8*)temp_str);
                        /* CSR 58157 START */
                        for(loop = 0; loop < oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcndl_list_size; loop++)
                        {
                            if(oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].
                                    earfcn_list_dl[loop] == oam_son_carrier_freq_and_dl_tx_power_resp.dl_earfcn)
                            {
                                break;
                            }
                        }
                        /*SPR_18668 Fix Start*/
                        /* SPR-13074 Start*/
                        oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].ran_info.
                            rf_params.rf_configurations.ul_earfcn = oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcn_list_ul[loop];
                        /*SPR 21702 Start*/
                        oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                            serving_cell[OAM_ZERO].choice_eutra_mode.fdd_info.ul_earfcn = oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcn_list_ul[loop];
                        /*SPR 21702 End*/
                        /* Update the response values in prov and DOM Tree */
                        UInt8   temp_str1[OAM_MAX_STR_LEN]="";
                        oam_snprintf((char*)temp_str1,(OAM_MAX_STR_LEN-OAM_ONE), "%d",
                                oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcn_list_ul[loop]);
                        /* SPR-13074 End*/
                        oam_strcpy((char*)oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].earfcnul_list,(char*)temp_str1);
                        /* spr_21013_fix_start */
                        oam_persist_one_parameter(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1,"EARFCNUL",
                                /* spr_21013_fix_end */
                                (UInt8*)temp_str1);
                        /* CSR 58157 END */
                    }
                    /*Code Removed */
                    /*SPR_18668 Fix End*/
                    if(oam_son_carrier_freq_and_dl_tx_power_resp.bitmask & SON_OAM_CARR_FREQ_DL_TX_PWR_REF_SIGNAL_POWER_PRESENT)
                    {
                        p_rrm_cell_config->ran_info.rf_params.rf_configurations.
                            reference_signal_power =
                            oam_son_carrier_freq_and_dl_tx_power_resp.reference_signal_power;
                        /* Update the response values in prov and DOM Tree */
                        UInt8   temp_str[OAM_MAX_STR_LEN]="";
                        /*SPR_18729 Fix Start*/
                        oam_snprintf((char*)temp_str,(OAM_MAX_STR_LEN-OAM_ONE), "%d",
                                oam_son_carrier_freq_and_dl_tx_power_resp.reference_signal_power);
                        /*SPR_18729 Fix End*/
                        oam_strcpy((char*)oam_prov_req.oam_params.cell_carrier_params[OAM_ZERO].reference_signal_power_list,
                                (char*)temp_str);
                        /* spr_21013_fix_start */
                        oam_persist_one_parameter(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.RF_1,"ReferenceSignalPower",
                                /* spr_21013_fix_end */
                                (UInt8*)temp_str);
                    }
                    if(oam_son_carrier_freq_and_dl_tx_power_resp.bitmask & SON_OAM_CARR_FREQ_DL_TX_PWR_P_MAX_PRESENT)
                    {

                        p_rrm_cell_config->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_P_MAX_SIB1_PRESENT;
                        p_rrm_cell_config->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.p_max_sib_1=oam_son_carrier_freq_and_dl_tx_power_resp.p_max;
                        /* Start: CSR 00058940 */
                        p_rrm_cell_config->ran_info.mobility_params.idle_mode_mobility_params.
                            idle_mode_mobility_intra_freq_params.p_max_sib_3 = oam_son_carrier_freq_and_dl_tx_power_resp.p_max;
                        p_rrm_cell_config->ran_info.mobility_params.idle_mode_mobility_params.
                            idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_P_MAX_SIB3_PRESENT; 
                        /*End: CSR 00058940 */  
                        /* Update the response values in prov and DOM Tree */
                        UInt8   temp_str[OAM_MAX_STR_LEN]="";
                        oam_snprintf((char*)temp_str,(OAM_MAX_STR_LEN-OAM_ONE), "%d",
                                oam_son_carrier_freq_and_dl_tx_power_resp.p_max);
                        oam_strcpy((char*)oam_prov_req.oam_params.ue_trans_power_list,
                                (char*)temp_str);
                        /* spr_21013_fix_start */
                        oam_persist_one_parameter(xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.IntraFreq,"PMax",
                                /* spr_21013_fix_end */
                                (UInt8*)temp_str);
                    }


                    /* Start: CSR 00058940 */
                    /*    send_pci_req = 1; */

                    /*End: CSR 00058940 */
                    if(OAM_SON_CARRIER_FREQ_ONGOING & oam_prov_req.system_status.event_ongoing)
                    {
                        if(SON_FAILURE == oam_son_carrier_freq_and_dl_tx_power_resp.result)
                        {
                            /* SPR-13074 Start*/
                            oam_prov_req.system_status.event_ongoing &= ~OAM_SON_CARRIER_FREQ_ONGOING;
                            /* SPR-13074 End*/
                            OAM_ALARM(CRITICAL_CONFIGURATION_FAILURE_ALARM_ID,CRITICAL,NOTIFY_NEW_ALARM,
                                    PROCESSING_ERROR_ALARM,UNAVAILABLE,EXPEDITED_ALARM,
                                    /* Spr 12880 Fix Start*/
                                    "Startup Configuration Failure: CARRIER FREQUENCY SELECTION Failure ", OAM_NULL,CellId);
                            /* Spr 12880 Fix End*/
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR,
                                    (UInt8 *)"Internal Error", oam_strlen("Internal Error")+ OAM_ONE, 
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                    &err);
                        }
                        else
                        {
                            UInt32 bitmask=OAM_ZERO;
                            /*Coverity_CID_31382_FIX_START*/
                            oam_rrm_cell_reconfig_req_t *p_cell_reconfig_req =
                                OAM_NULL;
                            UInt16 trans_id = oam_prov_req.oam_params.temp_trans_id;
                            if(OAM_FAILURE == 
                                    oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),(void **)&p_cell_reconfig_req,&err))
                            {
                                OAM_LOG(OAM, OAM_ERROR,
                                        "Memory allocation to p_cell_reconfig_req failed"
                                        " with Error Code:%d",
                                        err);
                                break;
                            }
                            oam_memset(p_cell_reconfig_req, OAM_ZERO,
                                    sizeof(oam_rrm_cell_reconfig_req_t));

                            oam_tcb_update_bitmask(trans_id,OAM_TRANS_SON,&bitmask);

                            /* SPR-13074 Start*/
                            oam_memcpy(&p_local_cell_config->global_cell_info,
                                    &p_rrm_cell_config->global_cell_info,
                                    sizeof(rrm_oam_cell_info_t));


                            oam_memcpy(&p_local_cell_config->ran_info.rf_params,
                                    &p_rrm_cell_config->ran_info.rf_params,
                                    sizeof(rrm_oam_rf_params_t));

                            p_cell_reconfig_req->bitmask |= RRM_OAM_RAN_INFO_PRESENT;
                            p_cell_reconfig_req->ran_info.
                                bitmask |= RRM_OAM_RF_PARAMS_PRESENT;

                            /* SPR-13074 End*/
                            OAM_LOG(OAM,OAM_DETAILED,"Sending RRM_OAM_CELL_RECONFIG_REQ");
                            OAM_LOG(OAM,OAM_DETAILED,"Trans_id sent is: %d",trans_id);
                            oam_copy_config_to_reconfig(p_local_cell_config,
                                    p_cell_reconfig_req);
                            retVal = oam_rrm_send_rrm_oam_cell_reconfig_req(
                                    p_cell_reconfig_req,
                                    OAM_MODULE_ID,
                                    RRM_MODULE_ID,
                                    trans_id,
                                    oam_prov_req.cell_cntxt.curr_cell_cid);
                            if (OAM_FAILURE == retVal)
                            {
                                OAM_LOG(OAM,OAM_WARNING,
                                        "Error in function oam_rrm_send_rrm_oam_cell_reconfig_req");
                            }
                            oam_mem_free(p_cell_reconfig_req, &err);
                            /*Coverity_CID_31382_FIX_END*/
                        }
                    } 
                } 
                else
                {
                    /* Start: CSR 00058940 */
                    /* UInt16     gen_trans_id  = 0; */
                    /*End: CSR 00058940 */
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_REQ Failed!!");
                    /* Send failure SPV response */
                    OAM_ALARM(CRITICAL_CONFIGURATION_FAILURE_ALARM_ID,CRITICAL,NOTIFY_NEW_ALARM,
                            PROCESSING_ERROR_ALARM,UNAVAILABLE,EXPEDITED_ALARM,
                            /* Spr 12880 Fix Start*/
                            "Startup Configuration Failure: CARRIER FREQUENCY SELECTION Failure!!",OAM_NULL,CellId);
                    /* Spr 12880 Fix End*/
                    if(OAM_SON_CARRIER_FREQ_ONGOING & oam_prov_req.system_status.event_ongoing)
                    {
                        oam_prov_req.system_status.event_ongoing &= ~OAM_SON_CARRIER_FREQ_ONGOING;
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_INTERNAL_ERROR,
                                (UInt8 *)"Internal Error", oam_strlen("Internal Error")+ OAM_ONE, 
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                &err);
                    } 
                    /* Start: CSR 00058940 */
                    /*  init_time_startup = OAM_ZERO;
                        oam_handle_initial_admin_state_unlocked(&gen_trans_id);
                        */
                    /*End: CSR 00058940 */
                    break;
                }
                /* SPR 22925 Fix + */
                /* SPR 22925 Fix - */
                /* Start: CSR 00058940 */
                /*End: CSR 00058940 */
                //Send PCI selection request
                //Based on pci selected by SON start cell reconfiguration
                //Fill Structure

                UInt16 trans_id = oam_get_new_trans_id(); 

                /* Start: CSR 00058940 */
                if (OAM_ONE < oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list_size)
                {
                    /*End: CSR 00058940 */
                    if(OAM_SUCCESS == 
                            oam_son_send_son_oam_pci_selection_req(&(oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req),
                                OAM_MODULE_ID, SON_MODULE_ID, trans_id, oam_prov_req.cell_cntxt.curr_cell_cid))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_SELECTION_REQ sent Successfully!!");
                        /*SPR_18665 Fix Start*/
                        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                                    OAM_TRANS_SON,msg_len,p_api_buf))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            /* Coverity_99557 Fix Start */
                            return  OAM_FAILURE;
                            /* Coverity_99557 Fix End */
                        }
#endif
                        /*SPR_18665 Fix End*/
                    }
                    else 
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_SELECTION_REQ sent Failure");
                        /* Start: CSR 00058940 */
                        return OAM_FAILURE;
                    }
                } 
                /*SPR_18664 Fix Start*/
                /*SPR_16048 Fix Start*/
                else if((OAM_TRUE == oam_prov_req.oam_son_req.temp_values.scan_on_boot) &&
                        (OAM_TRUE == oam_prov_req.system_status.is_nmm_enabled))
                    /*SPR_16048 Fix End*/
                {
                    initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;

                    if(OAM_SUCCESS == 
                            oam_son_send_son_oam_nw_scan_req(&(oam_prov_req.oam_son_req.nw_scan),
                                OAM_MODULE_ID,SON_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "SON_NW_SCAN_REQ sent Successfully");
                    }
                    else
                    {
                        OAM_LOG(OAM,OAM_WARNING, "SON_NW_SCAN_REQ sent Failuer");
                    }
                }
                /*SPR_16636 Fix End*/
                /*SPR_18664 Fix End*/

                else
                {
                    initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;
                    /*SPR_15647 Fix start*/
                    if ((LOWER_LAYERS_PROVISIONING_MASK & initialisation_flag) &&
                            (INIT_TIME_PCI_SELECTION_MASK & initialisation_flag) &&
                            (INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK & initialisation_flag))
                    {
                        /*SPR 22925 Start*/
                        UInt16   gen_trans_id = OAM_ZERO;
                        /*SPR 22925 End*/
                        init_time_startup = OAM_ZERO;
                        /*+ SPR 18390*/
                        UInt8 cell_cnt = OAM_ZERO;
                        for (cell_cnt = OAM_ZERO;cell_cnt < oam_prov_req.num_cells_configured; ++cell_cnt) {
                            p_rrm_cell_config = &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_cnt];
                            /* spr_21013_fix_start */
				/* SPR 22248 MBMS Changes Start */
                            retVal = oam_handle_initial_admin_state_unlocked((UInt8 *)INVALID_ARGUMENT,
				/* SPR 22248 MBMS Changes Stop */
                                    /* spr_21013_fix_end */
                                    p_rrm_cell_config,
                                    &gen_trans_id);
                        }
                        /*- SPR 18390*/
                    }
                    /*SPR_15647 Fix end*/
                }
            }
            break;

        case SON_OAM_ANR_MEAS_CONFIG_RESP:
            /* RT SPR 8154 FIX START */
            usr_req_resp = oam_prov_req.system_status.event_ongoing &
                USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;

            if(usr_req_resp) {
                retVal = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                        &tcb_data.usr_req_trans_id,
                        &tcb_data.usr_intf_src_id,
                        &tcb_data.p_orig_xml_parent,
                        &tcb_data.p_usr_msg_xml_parent,
                        &tcb_data.p_parent_xml_struct_addr);

                if(OAM_FAILURE == retVal) {
                    usr_req_resp = OAM_ZERO;
                }
                else {
                    tcb_found = OAM_TRUE;
                }
            }
            /* RT SPR 8154 FIX END */

            length_left = get_word_from_header((UInt8*)(p_api_buf) +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_mem_alloc(sizeof(oam_son_anr_meas_config_res_t),
                    (void**)&p_anr_meas_config_resp, &err);

            if(OAM_FAILURE == retVal) {
                /* Not Enough Memory */
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_anr_meas_config_resp failed"
                        " with Error Code:%d",
                        err);

                /* RT SPR 8154 FIX START */
                if(usr_req_resp) {
                    /* RT SPR 8154 FIX END */
                    oam_get_err_string_n_err_code(err, &usr_error_code,
                            &err_string);
                    err_str_size = oam_strlen(err_string) + OAM_ONE;
                    usr_resp = OAM_RESULT_FAILURE;

                    oam_construct_n_send_set_resp_to_usr(usr_resp,
                            usr_error_code,
                            (UInt8*)err_string,
                            err_str_size,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            tcb_data.usr_intf_src_id,
                            tcb_data.usr_req_trans_id,
                            OAM_ZERO, OAM_ZERO,
                            &err);
                    /* RT SPR 8154 FIX START */
                    oam_prov_req.system_status.
                        event_ongoing &= ~USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
                }
                /* RT SPR 8154 FIX END */

                oam_prov_req.system_status.
                    event_ongoing &= ~OAM_ADD_OBJ_ONGOING;
                break;
            }

            length_read = OAM_ZERO;

            retVal = oam_parse_son_oam_anr_meas_config_res(
                    p_anr_meas_config_resp,
                    p_api_buf, length_left,
                    &length_read);

            cid = oam_extract_cid_from_eutran_cellidentity(
                    p_anr_meas_config_resp->src_cgi.cell_identity);
            OAM_LOG(OAM, OAM_INFO, "SON_OAM_ANR_MEAS_CONFIG_RESP received. "
                    "for cell identity: %d", cid);

            if(OAM_SUCCESS == retVal) {
                if(SON_SUCCESS == p_anr_meas_config_resp->result) {
                    layer_resp = OAM_SUCCESS;
                    OAM_LOG(OAM, OAM_INFO, "SON_OAM_ANR_MEAS_CONFIG_RESP Success response received");
                    /* Update from local to actual provisioning */
                    oam_son_update_meas_config_data(p_anr_meas_config_resp);

                    err_string = OAM_NULL;
                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_INFO, "Failure SON_OAM_ANR_MEAS_CONFIG_RESP response received "
                            "with error code: %d",
                            p_anr_meas_config_resp->error_code);

                    err_string = oam_son_resp_code_to_str(
                            p_anr_meas_config_resp->error_code);

                    err_str_size = oam_strlen(err_string) + OAM_ONE;
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                    /* SPR 14651 START */
                    oam_prov_req.system_status.event_ongoing &=
                        ~USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
                    /* SPR 14651 END */
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING, "SON_OAM_ANR_MEAS_CONFIG_RESP Parsing Failure");

                oam_get_err_string_n_err_code(err, &usr_error_code,
                        &err_string);
                err_str_size = oam_strlen(err_string) + OAM_ONE;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if (tcb_found) {
                oam_update_xml_dom(layer_resp,
                        tcb_data.p_orig_xml_parent,
                        tcb_data.p_usr_msg_xml_parent,
                        tcb_data.p_parent_xml_struct_addr);
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "XML DOM can't be updated as TCB is not found");
            }

            /* RT SPR 8154 FIX START */
            if(usr_req_resp) {
                /* RT SPR 8154 FIX END */
                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        tcb_data.usr_intf_src_id,
                        tcb_data.usr_req_trans_id,
                        OAM_ZERO, OAM_ZERO,
                        &err);
                oam_prov_req.system_status.
                    event_ongoing &= ~USR_REQ_TO_ANR_MEAS_CONFIG_ONGOING;
                /* RT SPR 8154 FIX START */
            }
            /* RT SPR 8154 FIX END */

            oam_prov_req.system_status.event_ongoing &= ~OAM_ADD_OBJ_ONGOING;

            /* Coverity ID : 72210 Fix Start*/
            oam_mem_free(p_anr_meas_config_resp,&err);
            /* Coverity ID : 72210 Fix End*/
            break;

        case SON_OAM_NR_RETRIEVE_RESP:
            OAM_LOG(OAM, OAM_INFO, "SON_OAM_NR_RETRIEVE_RESP received.");

            if(!tcb_det) {
                OAM_LOG(OAM, OAM_WARNING, "Can't fetch TCB details. "
                        "Response to user request can't be sent.");
                retVal = OAM_FAILURE;
                break;
            }

            p_usr_req = tcb_det->oam_tcb_context;
            dst_id = get_word_from_header(p_usr_req + OAM_TWO);
            resp_trans_id = get_word_from_header(p_usr_req);

            retVal = oam_stop_timer(tcb_det->timer_id);
            if(OAM_SUCCESS != retVal) {
                OAM_LOG(OAM, OAM_WARNING,
                        "Error returned while stopping the timer");
            }
            else {
                OAM_LOG(OAM, OAM_INFO, "User request timer stopped");
            }

            /*-------------Deleting Entry In TCB --------------*/
            oam_tcb_delete(&trans_id);

            oam_son_nr_retrieve_resp_t      *p_nr_retrieve_resp;
            length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT)
                - LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_read = OAM_ZERO;
            p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_mem_alloc(sizeof(oam_son_nr_retrieve_resp_t),
                    (void**)&p_nr_retrieve_resp, &err);

            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_nr_retrieve_resp failed"
                        " with Error Code:%d",
                        err);

                oam_get_err_string_n_err_code(err, &usr_error_code,
                        &err_string);
                usr_resp = OAM_RESULT_FAILURE;

                oam_construct_n_send_get_resp_to_usr(usr_resp,
                        usr_error_code,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dst_id, resp_trans_id,
                        OAM_ZERO, OAM_ZERO,
                        err_string, &err);

                break;
            }

            oam_memset(p_nr_retrieve_resp, OAM_ZERO,
                    sizeof(oam_son_nr_retrieve_resp_t));

            retVal = oam_parse_son_oam_nr_retrieve_resp(p_nr_retrieve_resp,
                    p_api_buf,
                    length_left,
                    &length_read);
            if(OAM_SUCCESS == retVal) {
                if(SON_SUCCESS == p_nr_retrieve_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "Success SON_OAM_NR_RETRIEVE_RESP Received");
                    oam_populate_n_send_nr_retrieve_resp_to_usr(
                            p_nr_retrieve_resp,
                            dst_id,
                            resp_trans_id,
                            &err);
                }
                else {
                    OAM_LOG(OAM, OAM_INFO,
                            "Failure SON_OAM_NR_RETRIEVE_RESP Received");

                    err_string = "Internal Error";
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;

                    oam_construct_n_send_get_resp_to_usr(usr_resp,
                            usr_error_code,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dst_id, resp_trans_id,
                            OAM_ZERO, OAM_ZERO,
                            err_string, &err);
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_NR_RETRIEVE_RESP: Parsing Failure");

                oam_get_err_string_n_err_code(err, &usr_error_code,
                        &err_string);
                usr_resp = OAM_RESULT_FAILURE;

                oam_construct_n_send_get_resp_to_usr(usr_resp,
                        usr_error_code,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dst_id, resp_trans_id,
                        OAM_ZERO, OAM_ZERO,
                        err_string, &err);
            }
            /* Coverity ID : 72213 Fix Start*/
            oam_mem_free(p_nr_retrieve_resp,&err);
            /* Coverity ID : 72213 Fix End*/
            break; 

        case SON_OAM_NR_ENB_RETRIEVE_RESP:
            {
                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                {
                    OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                    break;
                }
#endif
                /* SPR 9620 CHANGE END */
                int ti[OAM_HUNDRED];
                oam_son_nr_enb_retrieve_resp_t      oam_son_nr_enb_retrieve_resp;
                int te[OAM_HUNDRED];
                ti[OAM_ZERO]= OAM_ONE;
                te[OAM_ONE]= OAM_ONE;
                ti[OAM_ZERO]=te[OAM_ONE]; 
                te[OAM_ONE]=ti[OAM_ZERO]; 
                length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                length_read= OAM_ZERO;

                if(OAM_SUCCESS == oam_parse_son_oam_nr_enb_retrieve_resp(&oam_son_nr_enb_retrieve_resp,
                            p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            &length_read))
                {
                    if(SON_SUCCESS == oam_son_nr_enb_retrieve_resp.result)
                    {
                        OAM_LOG(OAM, OAM_INFO, "Success SON_OAM_NR_ENB_RETRIEVE_RESP Received");
                        oam_populate_n_send_nr_enb_retrieve_resp_to_usr(
                                &oam_son_nr_enb_retrieve_resp,trans_id_resp,dest_id,&err);
                    }
                    else 
                    {
                        OAM_LOG(OAM, OAM_INFO, "Failure SON_OAM_NR_ENB_RETRIEVE_RESP Received");
                        oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_INTERNAL_ERROR,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                "Internal Error", 
                                &err); 
                    }
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_NR_ENB_RETRIEVE_RESP : Parsing Failure");
                }
            }
            break; 
        case SON_OAM_ANR_MODIFY_PCI_CONFUSION_CFG_RESP:
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                break;
            }
#endif
            /* SPR 9620 CHANGE END */
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_ANR_MODIFY_PCI_CONFUSION_CFG_RESP from SON");

            retVal = oam_mem_alloc(sizeof(son_oam_anr_modify_pci_confusion_cfg_resp_t),
                    (void**)&p_son_anr_modify_pci_confusion_cfg_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_anr_modify_pci_confusion_cfg_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_anr_modify_pci_confusion_cfg_resp, OAM_ZERO,
                    sizeof(son_oam_anr_modify_pci_confusion_cfg_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_anr_modify_pci_confusion_cfg_resp(p_son_anr_modify_pci_confusion_cfg_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_MODIFY_PCI_CONFUSION_CFG_RESP");

                if(SON_SUCCESS == p_son_anr_modify_pci_confusion_cfg_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ANR_MODIFY_PCI_CONFUSION_CFG_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_MODIFY_PCI_CONFUSION_CFG_RESP "
                            "SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_RESP" 
                            "returned failure with error code: %d",
                            p_son_anr_modify_pci_confusion_cfg_resp->error_code);



                    err_string = "Unable to modify PCI_CONFUSION_CFG";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ANR_MODIFY_PCI_CONFUSION_CFG_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);


            oam_mem_free(p_son_anr_modify_pci_confusion_cfg_resp, &err); 
            break;

        case SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_RESP:

            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_RESP from SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */

            retVal = oam_mem_alloc(sizeof(son_oam_anr_modify_removal_attributes_resp_t),
                    (void**)&p_oam_son_anr_modify_removal_attributes_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_oam_son_anr_modify_removal_attributes_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_oam_son_anr_modify_removal_attributes_resp, OAM_ZERO,
                    sizeof(son_oam_anr_modify_removal_attributes_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_anr_modify_removal_attributes_resp(p_oam_son_anr_modify_removal_attributes_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_RESP parsed");

                if(SON_SUCCESS == p_oam_son_anr_modify_removal_attributes_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_RESP" 
                            "returned failure with error code: %d",
                            p_oam_son_anr_modify_removal_attributes_resp->error_code);


                    err_string = "Unable to modify RemOVAL_ATTRIBUTES";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ANR_MODIFY_REMOVAL_ATTRIBUTES_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);


            oam_mem_free(p_oam_son_anr_modify_removal_attributes_resp, &err); 

            break;

        case SON_OAM_ANR_MODIFY_MEAS_REPORTING_INTERVAL_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_ANR_MODIFY_MEAS_REPORTING_INTERVAL_RESP from SON");

            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */
            retVal = oam_mem_alloc(sizeof(son_oam_anr_modify_meas_reporting_interval_resp_t),
                    (void**)&p_son_anr_modify_meas_reporting_interval_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_anr_modify_meas_reporting_interval_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_anr_modify_meas_reporting_interval_resp, OAM_ZERO,
                    sizeof(son_oam_anr_modify_meas_reporting_interval_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_anr_modify_meas_reporting_interval_resp
                (p_son_anr_modify_meas_reporting_interval_resp,
                 p_tmp_buf,
                 length_left,
                 &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_MODIFY_MEAS_REPORTING_INTERVAL_RESP: Parsing Success");

                if(SON_SUCCESS == p_son_anr_modify_meas_reporting_interval_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ANR_MODIFY_MEAS_REPORTING_INTERVAL_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_MODIFY_MEAS_REPORTING_INTERVAL_RESP "
                            "returned failure with error code: %d",
                            p_son_anr_modify_meas_reporting_interval_resp->error_code);

                    err_string = "Unable to modify MEAS_REPORTING_INTERVAL";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ANR_MODIFY_MEAS_REPORTING_INTERVAL_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }


            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);

            oam_mem_free(p_son_anr_modify_meas_reporting_interval_resp, &err);

            break;
        case SON_OAM_ANR_MODIFY_UE_COUNT_RESP:

            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_ANR_MODIFY_UE_COUNT_RESP FROM SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */
            retVal = oam_mem_alloc(sizeof(oam_son_anr_modify_ue_count_resp_t),
                    (void**)&p_son_anr_modify_ue_count_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_anr_modify_ue_count_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_anr_modify_ue_count_resp, OAM_ZERO,
                    sizeof(oam_son_anr_modify_ue_count_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_anr_modify_ue_count_resp(
                    p_son_anr_modify_ue_count_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_MODIFY_UE_COUNT_RESP parsing success");

                if(SON_SUCCESS == p_son_anr_modify_ue_count_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ANR_MODIFY_UE_COUNT_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_MODIFY_UE_COUNT_RESP returned failure"
                            " with error code: %d",
                            p_son_anr_modify_ue_count_resp->error_code);

                    err_string = "Unable to modify UE count";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ANR_MODIFY_UE_COUNT_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }


            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);


            oam_mem_free(p_son_anr_modify_ue_count_resp, &err); 

            break;
            /* SPR 20653 Fix Start */
        case SON_OAM_ANR_MODIFY_ATTRIBUTE_RESP:

            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_ANR_MODIFY_ATTRIBUTE_RESP FROM SON");
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            retVal = oam_mem_alloc(sizeof(oam_son_anr_modify_attribute_resp_t),
                    (void**)&p_son_anr_modify_attribute_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_anr_modify_attribute_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_anr_modify_attribute_resp, OAM_ZERO,
                    sizeof(oam_son_anr_modify_attribute_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_anr_modify_attribute_resp(
                    p_son_anr_modify_attribute_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_MODIFY_ATTRIBUTE_RESP parsing success");

                if(SON_SUCCESS == p_son_anr_modify_attribute_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ANR_MODIFY_ATTRIBUTE_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
					OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_MODIFY_ATTRIBUTE_RESP returned failure"
                            " with error code: %d",
                            p_son_anr_modify_attribute_resp->error_code);

                    err_string = "Unable to modify ANR attribute";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
				OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ANR_MODIFY_ATTRIBUTE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }


            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);


            oam_mem_free(p_son_anr_modify_attribute_resp, &err); 

            break;
            /* SPR 20653 Fix End */ 

        case SON_OAM_ANR_ENABLE_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_ANR_ENABLE_RESP from SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */
            retVal = oam_mem_alloc(sizeof(oam_son_anr_enable_resp_t),
                    (void**)&p_son_anr_enable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_anr_enable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_anr_enable_resp, OAM_ZERO,
                    sizeof(oam_son_anr_enable_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_anr_enable_resp(p_son_anr_enable_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_ENABLE_RESP: Parsing Success");

                if(SON_SUCCESS == p_son_anr_enable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ANR_ENABLE_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_ENABLE_RESP returned failure"
                            " with error code: %d",
                            p_son_anr_enable_resp->error_code);

                    err_string = oam_son_resp_code_to_str(
                            p_son_anr_enable_resp->error_code);

                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ANR_ENABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }



            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);


            oam_mem_free(p_son_anr_enable_resp, &err);
            break;

        case SON_OAM_ANR_DISABLE_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_ANR_DISABLE_RESP from SON");

            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */

            retVal = oam_mem_alloc(sizeof(oam_son_anr_disable_resp_t),
                    (void**)&p_son_anr_disable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_anr_disable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_anr_disable_resp, OAM_ZERO,
                    sizeof(oam_son_anr_disable_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;


            retVal =
                oam_parse_son_oam_anr_disable_resp(p_son_anr_disable_resp,
                        p_tmp_buf,
                        length_left,
                        &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_DISABLE_RESP: Parsing Success");

                if(SON_SUCCESS == p_son_anr_disable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_ANR_DISABLE_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_DISABLE_RESP returned failure"
                            " with error code: %d",
                            /*COV_FIXED_12 */
                            p_son_anr_disable_resp->error_code);
                    /*COV_FIXED_12 */

                    err_string = oam_son_resp_code_to_str(
                            p_son_anr_disable_resp->error_code);

                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ANR_DISABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";

                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }


            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);


            oam_mem_free(p_son_anr_disable_resp, &err);
            break;

        case SON_OAM_ENABLE_DISABLE_X2_RESP:
            {
                length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read= OAM_ZERO;
                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                {
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
#endif
                /* SPR 9620 CHANGE END */

                if (OAM_SUCCESS == oam_parse_son_oam_enable_disable_x2_resp(
                            &(oam_prov_req.oam_son_req.x2_enable_disable_resp),p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            length_left,&length_read))
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_ENABLE_DISABLE_X2_RESP Parsing Success");

                    if(SON_SUCCESS == oam_prov_req.oam_son_req.x2_enable_disable_resp.result)
                    {
                        OAM_LOG(OAM, OAM_INFO, "SON_OAM_ENABLE_DISABLE_X2_RESP: Success");
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                OAM_ZERO,
                                OAM_NULL, OAM_ZERO, 
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                &err); 
                    }
                    else 
                    {
                        OAM_LOG(OAM, OAM_INFO, "SON_OAM_ENABLE_DISABLE_X2_RESP Result: Failure");
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ERR_INTERNAL_ERROR,
                                (UInt8 *)"Internal Error", oam_strlen("Internal Error")+ OAM_ONE, 
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                &err); 
                    }
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_ENABLE_DISABLE_X2_RESP Parsing Failure");
                }
                break;               
            }
        case  SON_OAM_NR_DELETE_FROM_REMOVE_LIST_RESP:
            /* SPR 11156 FIX START */
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_NR_DELETE_FROM_REMOVE_LIST_RESP received from SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
#endif
            /* SPR 9620 CHANGE END */

            retVal = oam_mem_alloc(
                    sizeof(oam_son_nr_delete_from_remove_list_resp_t),
                    (void**)&p_del_from_rem_list_resp,
                    &err);

            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_del_from_rem_list_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_del_from_rem_list_resp, OAM_ZERO,
                    sizeof(oam_son_nr_delete_from_remove_list_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;


            retVal =
                oam_parse_son_oam_nr_delete_from_remove_list_resp(
                        p_del_from_rem_list_resp,
                        p_tmp_buf,
                        length_left,
                        &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_NR_DELETE_FROM_REMOVE_LIST_RESP: Parsing Success");

                if(SON_SUCCESS == p_del_from_rem_list_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_NR_DELETE_FROM_REMOVE_LIST_RESP: Success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_NR_DELETE_FROM_REMOVE_LIST_RESP: Failure"
                            " with error code: %d",
                            p_del_from_rem_list_resp->error_code);

                    err_string = oam_son_resp_code_to_str(
                            p_del_from_rem_list_resp->error_code);

                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_NR_DELETE_FROM_REMOVE_LIST_RESP: Parsing Failed");

                err_string = "Response message parsing failed";

                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }


            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);


            oam_mem_free(p_del_from_rem_list_resp, &err);
            /* SPR 11156 FIX END */
            break;
            /*+SPR 18853 FIX*/
        case SON_OAM_FEATURE_STATE_CHANGE_IND:
            {
                OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_FEATURE_STATE_CHANGE_IND from SON");
                oam_son_feature_state_change_ind_t son_feature_state_change_ind;
                length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                length_read = OAM_ZERO;
                retVal      = oam_parse_son_oam_feature_state_change_ind(&son_feature_state_change_ind,
                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        &length_read);

                if(retVal == OAM_FAILURE)
                {
                    OAM_LOG(OAM,OAM_WARNING, "Parsing Failed in SON_OAM_FEATURE_STATE_CHANGE_IND from SON");
                    return OAM_FAILURE;
                }
                else
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Parsing Successful in SON_OAM_FEATURE_STATE_CHANGE_IND from SON");
                }
                /* SPR 19343 START */
                /*check if feature_ind is received for ANR */
                if((SON_ANR_MODULE_ID == son_feature_state_change_ind.module_id))            
                {
                    /*SPR #14531 Fixed Start*/ 
                    if(SON_STATE_ENABLED == son_feature_state_change_ind.state)
                    {
                        cid =
                            oam_extract_cid_from_eutran_cellidentity(
                                    son_feature_state_change_ind.srv_cgi.
                                    cell_identity);

                        /* send SON_OAM_NR_ADD_REQ */
                        cell_config_idx = oam_get_son_cell_nr_list_idx(cid);
                        if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                            OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",cid);
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }


                        /* SPR 18930  FIX START  */
                        OAM_LOG(OAM, OAM_INFO,"Sending INIT TIME NR ADD For CID =%d",cid);
                        /* SPR 18930  FIX END  */
                        oam_send_init_time_nr_add_req(cell_config_idx);   
                        /*SPR 19938 Fix Start*/
                        OAM_SYS_EVENT_BIMASK |= INIT_TIME_NR_SCAN_REQ_SEND;
                        /*SPR 19938 Fix Stop*/
                        /*SPR #14560 Fixed End*/

                        retVal = oam_send_init_time_anr_meas_config_req(cid);


                        if(OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Failed to send SON_OAM_ANR_MEAS_CONFIG_REQ"); 
                        }
                        else {
                            OAM_LOG(OAM, OAM_INFO,
                                    "Successfully sent SON_OAM_ANR_MEAS_CONFIG_REQ");
                        }


                        /* send SON_OAM_NR_ENB_ADD_REQ */
                        retVal = oam_son_send_son_oam_nr_enb_add_req(
                                &oam_prov_req.oam_son_req.oam_son_nr_enb_add_req,
                                OAM_MODULE_ID, SON_MODULE_ID,
                                oam_get_new_trans_id(),
                                oam_prov_req.cell_cntxt.curr_cell_cid);

                        if (OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Failed to send SON_OAM_NR_ENB_ADD_REQ");
                        }
                        else {
                            OAM_LOG(OAM, OAM_DETAILED,
                                    "Successfully sent SON_OAM_NR_ENB_ADD_REQ");
                        }

                    }
                    /*SPR #14531 Fixed End*/

                    num_feature_state_change_ind_anr ++ ;
                    /* SPR 20927 Fix Start */
                    /*Code Deleted*/
                    /* SPR 20927 Fix Stop */
                    /*SPR 19981 Fix Start*/
#ifdef OAM_SON_ENABLE

                    if(OAM_ONE == SON_PROV_REQ.oam_energy_saving_config[0].es_enable_disable)
                    {
                        /* SPR 11636 Fix Start */ 
                        oam_son_es_enable_req_t oam_son_es_enable_req  = {OAM_ZERO};
                        /* SPR 11636 Fix End*/ 
                        /* SPR 11791 start */
                        oam_son_es_enable_req.bitmask |= SON_ES_ENABLE_SRV_CGI_PRESENT;
                        /*SPR 19981 Fix start*/
                        oam_memcpy(&oam_son_es_enable_req.srv_cgi,&son_feature_state_change_ind.srv_cgi,
                                sizeof(son_intra_rat_global_cell_id_t));
                        /*SPR 19981 Fix start*/
                        oam_son_es_enable_req.interval =
                            SON_PROV_REQ.oam_energy_saving_config[0].ActiveUECountIntervalSeconds;
                        oam_son_es_enable_req.threshold_value =
                            SON_PROV_REQ.oam_energy_saving_config[0].ActiveUECountThreshold;
                        /* SPR 9620 CHANGE START */
                        tid=oam_get_new_trans_id();
                        if (OAM_FAILURE == oam_son_send_son_oam_es_enable_req(
                                    &oam_son_es_enable_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    tid,
                                    cid))
                            /* SPR 9620 CHANGE END */    
                        {
                            OAM_LOG(OAM, OAM_ERROR, "Failed to send SON_OAM_ES_ENABLE_REQ at init time");
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Successfully sent SON_OAM_ES_ENABLE_REQ at init time");
                            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                            if( OAM_FAILURE == oam_maintain_tcb_with_timer(tid,OAM_SUB_MODULE_SON,            
                                        OAM_TRANS_SON,msg_len,p_api_buf))
                            {
                                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            }
#endif
                        }
                        /* SPR 9620 CHANGE END */
                    }
                    else {
                        /*COV_FIX_18_JUN*/
                        /* SPR 11636 Fix Start */ 
                        oam_son_es_disable_req_t oam_son_es_disable_req = {OAM_ZERO};
                        /* SPR 11636 Fix End*/ 
                        /* SPR 11791 start */
                        oam_son_es_disable_req.bitmask |= SON_ES_DISABLE_SRV_CGI_PRESENT;
                        /*SPR 19981 Fix Start*/
                        oam_memcpy(&oam_son_es_disable_req.srv_cgi,&son_feature_state_change_ind.srv_cgi,
                                /*SPR 19981 Fix Stop*/
                                sizeof(son_intra_rat_global_cell_id_t));
                        /* SPR 11791 end */
                        if (OAM_FAILURE == oam_son_send_son_oam_es_disable_req(
                                    &oam_son_es_disable_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    oam_get_new_trans_id(),
                                    cid))
                        {
                            OAM_LOG(OAM, OAM_ERROR, "Failed to send SON_OAM_ES_DISABLE_REQ at init time");
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "Successfully sent SON_OAM_ES_DISABLE_REQ at init time");
#ifndef OAM_UT_FRAMEWORK
                            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                                        OAM_TRANS_SON,msg_len,p_api_buf))
                            {
                                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                                return OAM_FAILURE;
                            }
#endif

                        }

                    } 


                    if (OAM_ONE == oam_prov_req.oam_son_req.mro_config.mro_enable_disable_flag)
                    {
                        /* SPR 11636 Fix Start */ 
                        oam_son_mro_enable_req_t oam_son_mro_enable_req = {OAM_ZERO};
                        oam_son_mro_enable_req.bitmask |= SON_MRO_ENABLE_SRV_CGI_PRESENT;
                        /*SPR 19981 Fix Start*/
                        oam_memcpy(&oam_son_mro_enable_req.srv_cgi,&son_feature_state_change_ind.srv_cgi,
                                /*SPR 19981 Fix Stop*/
                                sizeof(son_intra_rat_global_cell_id_t));
                        /* SPR 11636 Fix End*/ 
                        /* SPR 9620 CHANGE START */
                        tid=oam_get_new_trans_id();
                        if(OAM_SUCCESS == oam_son_send_son_oam_mro_enable_req(
                                    &oam_son_mro_enable_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    tid,
                                    cid))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_MRO_ENABLE_REQ sent Successfully!!");
#ifndef OAM_UT_FRAMEWORK
                            if( OAM_FAILURE == oam_maintain_tcb_with_timer(tid,OAM_SUB_MODULE_SON,
                                        OAM_TRANS_SON,msg_len,p_api_buf))
                            {
                                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            }
#endif
                        }
                        /* SPR 9620 CHANGE END */
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_MRO_ENABLE_REQ sending Failure");
                        }
                    }   
                    else if (OAM_ZERO == oam_prov_req.oam_son_req.mro_config.mro_enable_disable_flag)
                    {
                        /* SPR 11636 Fix Start */ 
                        oam_son_mro_disable_req_t oam_son_mro_disable_req = {OAM_ZERO};
                        /*SPR 19981 Fix Start*/
                        oam_memcpy(&oam_son_mro_disable_req.srv_cgi,&son_feature_state_change_ind.srv_cgi,
                                /*SPR 19981 Fix Stop*/
                                sizeof(son_intra_rat_global_cell_id_t));
                        oam_son_mro_disable_req.bitmask |= SON_MRO_DISABLE_SRV_CGI_PRESENT;
                        /* SPR 11636 Fix End*/ 
                        /* SPR 9620 CHANGE START */
                        tid=oam_get_new_trans_id();
                        if(OAM_SUCCESS == oam_son_send_son_oam_mro_disable_req(
                                    &oam_son_mro_disable_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    tid,
                                    cid))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_MRO_DISABLE_REQ sent Successfully!!");
#ifndef OAM_UT_FRAMEWORK
                            if( OAM_FAILURE == oam_maintain_tcb_with_timer(tid,OAM_SUB_MODULE_SON,
                                        OAM_TRANS_SON,msg_len,p_api_buf))
                            {
                                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            }
#endif
                        }
                        /* SPR 9620 CHANGE END */
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_MRO_DISABLE_REQ sending Failure");
                        }
                    }   
                    else
                    {
                            OAM_LOG(OAM, OAM_WARNING, "Incorrect value recived for mro_enable_disable tag");
                    }    
                    if (OAM_ONE == oam_prov_req.oam_son_req.mlb_config.mlb_enable_disable_flag)
                    {
                        /* SPR 11636 Fix Start */ 
                        oam_son_mlb_enable_req_t oam_son_mlb_enable_req = {OAM_ZERO};
                        /*SPR 19981 Fix Start*/
                        oam_memcpy(&oam_son_mlb_enable_req.src_cgi,&son_feature_state_change_ind.srv_cgi,
                                /*SPR 19981 Fix Stop*/
                                sizeof(son_intra_rat_global_cell_id_t));
                        oam_son_mlb_enable_req.bitmask |= SON_OAM_MLB_ENABLE_SRC_CGI_PRESENT;
                        /* SPR 11636 Fix End*/ 
                        /* SPR 9620 CHANGE START */
                        tid=oam_get_new_trans_id();
                        if(OAM_SUCCESS == oam_son_send_son_oam_mlb_enable_req(
                                    &oam_son_mlb_enable_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    tid,
                                    cid))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_MLB_ENABLE_REQ sent Successfully!!");
#ifndef OAM_UT_FRAMEWORK
                            if( OAM_FAILURE == oam_maintain_tcb_with_timer(tid,OAM_SUB_MODULE_SON,
                                        OAM_TRANS_SON,msg_len,p_api_buf))
                            {
                                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            }
#endif
                            /* SPR 9620 CHANGE END */
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_MLB_ENABLE_REQ sending Failure");
                        }
                    }   
                    else if (OAM_ZERO == oam_prov_req.oam_son_req.mlb_config.mlb_enable_disable_flag)
                    {
                        /* SPR 11636 Fix Start */ 
                        oam_son_mlb_disable_req_t oam_son_mlb_disable_req = {OAM_ZERO};
                        /*SPR 19981 Fix Start*/
                        oam_memcpy(&oam_son_mlb_disable_req.src_cgi,&son_feature_state_change_ind.srv_cgi,
                                /*SPR 19981 Fix Stop*/
                                sizeof(son_intra_rat_global_cell_id_t));
                        oam_son_mlb_disable_req.bitmask |= SON_OAM_MLB_DISABLE_SRC_CGI_PRESENT;
                        /* SPR 11636 Fix End*/ 
                        /* SPR 9620 CHANGE START */
                        tid=oam_get_new_trans_id();
                        if(OAM_SUCCESS == oam_son_send_son_oam_mlb_disable_req(
                                    &oam_son_mlb_disable_req,
                                    OAM_MODULE_ID,
                                    SON_MODULE_ID,
                                    tid,
                                    cid))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_MLB_DISABLE_REQ sent Successfully!!");
#ifndef OAM_UT_FRAMEWORK
                            if( OAM_FAILURE == oam_maintain_tcb_with_timer(tid,OAM_SUB_MODULE_SON,
                                        OAM_TRANS_SON,msg_len,p_api_buf))
                            {
                                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            }
#endif
                            /* SPR 9620 CHANGE END */
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_MLB_DISABLE_REQ sending Failure");
                        }
                    }   
                    else
                    {
                            OAM_LOG(OAM, OAM_WARNING, "Incorrect value recived for mlb_enable_disable tag");
                    }     

#endif
                    /*Spr 19981 Fix Stop*/
                    /* SPR 19343 END */
                    /* check if ANR_MODULE is enabled then send NR_SCAN_REQ*/
                    /*SPR_16390 Fix start*/
                    /* SPR 20927 Fix Start */
                    if(num_feature_state_change_ind_anr == oam_prov_req.num_cells_configured)            
                    {
                        /* SPR 20927 Fix Stop */
                        if((SON_STATE_ENABLED == son_feature_state_change_ind.state) 
                                && ((OAM_TRUE == oam_prov_req.oam_igd_params.rem_lte_params.is_nr_scan_required)
                                    && (OAM_TRUE == oam_prov_req.system_status.is_nmm_enabled)))
                            /*SPR_16390 Fix end*/
                        {   
                            if(OAM_SUCCESS == 
                                    oam_son_send_son_oam_nr_scan_req(&(oam_prov_req.oam_son_req.nr_scan),
                                        OAM_MODULE_ID,SON_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid))
                            {
                                OAM_LOG(OAM,OAM_DETAILED, "SON_NR_SCAN_REQ sent Successfully");
                            }
                            else
                            {
                                OAM_LOG(OAM,OAM_WARNING, "SON_NR_SCAN_REQ sent Failuer");
                            }
                        }
                        /*SPR_16390 Fix start*/
                        else if((SON_STATE_ENABLED != son_feature_state_change_ind.state)
                                &&((OAM_TRUE == oam_prov_req.oam_igd_params.rem_lte_params.is_nr_scan_required)
                                    && (OAM_TRUE == oam_prov_req.system_status.is_nmm_enabled)))
                            /*SPR_16390 Fix end*/
                        {
                            /*start Cell*/
                            if(cell_to_be_started_by_operator == RRM_TRUE)
                            {
                                for (cell_cnt = OAM_ZERO;cell_cnt < oam_prov_req.num_cells_configured; ++cell_cnt)
                                {
                                    if(OAM_SYS_EVENT_BIMASK & S1AP_LINK_UP_RCVD)
                                    {
                                        p_rrm_cell_config =
                                            &RRM_CELL_CONFIG(cell_cnt);

                                        cid =
                                            oam_extract_cid_from_eutran_cellidentity(
                                                    p_rrm_cell_config->global_cell_info.
                                                    eutran_global_cell_id.cell_identity);

                                        p_cell_status = oam_get_cell_cntxt_status(cid);
                                        if (p_cell_status == OAM_NULL)
                                        {
                                            OAM_LOG(OAM, OAM_WARNING,
                                                    "No cell found, cell identity = %d", cid);
                                            OAM_FUN_EXIT_TRACE();
                                            return OAM_FAILURE;
                                        }

                                        if(p_cell_status->cell_event & CELL_CONFIG_RESP_RCVD)
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED,"Sending cell start to rrm");
                                            if(OAM_FAILURE == oam_rrm_send_rrm_oam_cell_start_req((rrm_oam_cell_start_req_t *)
                                                        (&(OWN_CELL_CGI(cell_cnt)))
                                                        ,OAM_MODULE_ID,RRM_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid))
                                            {
                                                OAM_LOG(OAM,OAM_ERROR,"Error in function oam_rrm_send_rrm_oam_cell_start_req");
                                                OAM_FUN_EXIT_TRACE ();
                                                return OAM_FAILURE;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        /* SPR 19343 START */
                    }
                    /* SPR 19343 END */
                }
                break;
            }
        case SON_OAM_NR_SCAN_RESP:
            {
                OAM_SYS_EVENT_BIMASK |= NR_SCAN_RESP_RCVD;
                OAM_LOG(OAM,OAM_DETAILED,"SON_OAM_NR_SCAN_RESP received ");

                if(cell_to_be_started_by_operator == RRM_TRUE)
                {
                    /*start Cell*/
                    for (cell_cnt = OAM_ZERO;cell_cnt < oam_prov_req.num_cells_configured; ++cell_cnt)
                    {
                        if(OAM_SYS_EVENT_BIMASK & S1AP_LINK_UP_RCVD)
                        {
                            p_rrm_cell_config =
                                &RRM_CELL_CONFIG(cell_cnt);

                            cid =
                                oam_extract_cid_from_eutran_cellidentity(
                                        p_rrm_cell_config->global_cell_info.
                                        eutran_global_cell_id.cell_identity);

                            p_cell_status = oam_get_cell_cntxt_status(cid);
                            if (p_cell_status == OAM_NULL)
                            {
                                OAM_LOG(OAM, OAM_WARNING,
                                        "No cell found, cell identity = %d", cid);
                                OAM_FUN_EXIT_TRACE();
                                return OAM_FAILURE;
                            }

                            if(p_cell_status->cell_event & CELL_CONFIG_RESP_RCVD)
                            {
                                OAM_LOG(OAM,OAM_DETAILED,"Sending cell start to rrm");
                                if(OAM_FAILURE == oam_rrm_send_rrm_oam_cell_start_req((rrm_oam_cell_start_req_t *)
                                            (&(OWN_CELL_CGI(cell_cnt)))
                                            ,OAM_MODULE_ID,RRM_MODULE_ID,trans_id,oam_prov_req.cell_cntxt.curr_cell_cid))
                                {
                                    OAM_LOG(OAM,OAM_ERROR,"Error in function oam_rrm_send_rrm_oam_cell_start_req");
                                    OAM_FUN_EXIT_TRACE ();
                                    return OAM_FAILURE;
                                }
                            }
                        }
                    }
                }
                break;    
            }
            /*-SPR 18853 FIX*/
        case SON_OAM_ANR_MEAS_CONFIG_OBJ_REMOVE_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_ANR_MEAS_CONFIG_OBJ_REMOVE_RESP received");
            retVal = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                    &tcb_data.usr_req_trans_id,
                    &tcb_data.usr_intf_src_id,
                    &tcb_data.p_orig_xml_parent,
                    &tcb_data.p_usr_msg_xml_parent,
                    &tcb_data.p_parent_xml_struct_addr);

            if(OAM_SUCCESS == retVal) {
                tcb_found = OAM_TRUE;
            }

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_read = OAM_ZERO;

            retVal = oam_mem_alloc(
                    sizeof(oam_son_anr_meas_config_obj_remove_res_t),
                    (void**)&p_anr_meas_config_obj_remove_res, &err);

            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_anr_meas_config_obj_remove_res failed"
                        " with Error Code:%d",
                        err);

                OAM_FUN_ENTRY_TRACE();
                return retVal;
            }

            oam_memset(p_anr_meas_config_obj_remove_res, OAM_ZERO,
                    sizeof(oam_son_anr_meas_config_obj_remove_res_t));


            retVal = oam_parse_son_oam_anr_meas_config_obj_remove_res(
                    p_anr_meas_config_obj_remove_res,
                    p_api_buf,
                    length_left,
                    &length_read);

            /* SPR 14651 START .... Code Moved/Added */
            cid = oam_extract_cid_from_eutran_cellidentity(
                    p_anr_meas_config_obj_remove_res->src_cgi.
                    cell_identity);

            cell_config_idx = oam_get_son_inter_freq_carrier_idx(cid);
            if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                        cid);
                /* SPR_19838 :Coverity_15243 Fix Start*/
                oam_mem_free(p_anr_meas_config_obj_remove_res, &err);
                /* SPR_19838 :Coverity_15243 Fix Stop*/
                OAM_FUN_EXIT_TRACE();
                return  OAM_FAILURE;
            }
            p_inter_freq_carr_params =
                &SON_INTER_FREQ_CARR_PARAMS(cell_config_idx);
            p_local_inter_freq_carr_params =
                &LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx);
            p_anr_meas_config_req =
                &SON_ANR_MEAS_CONFIG_REQ(cell_config_idx);
            query_idx = p_inter_freq_carr_params->query_index;

            if (OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_MEAS_CONFIG_OBJ_REMOVE_RESP: Parsing Success");

                if(SON_SUCCESS == p_anr_meas_config_obj_remove_res->result) {
                    OAM_LOG(OAM, OAM_INFO, "SON_OAM_ANR_MEAS_CONFIG_OBJ_REMOVE_RESP Success Response Received");
                    layer_resp = OAM_SUCCESS;

                    /* SPR 14651 START */
                    if (p_inter_freq_carr_params->config_ongoing &
                            OAM_ANR_ACTION_DELETE_INTER_FREQ_CARRIER_ONGOING_AT_SON) 
                    {
                        /* Updating at OAM meas enable record */ 
                        if(p_local_inter_freq_carr_params->
                                eutran_meas_enable[query_idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
                        {
                            p_inter_freq_carr_params->eutran_meas_enable[query_idx].
                                bitmask |= OAM_SON_MEAS_ENABLE_PRESENT; 
                        }
                        p_inter_freq_carr_params->config_ongoing &=
                            ~OAM_ANR_ACTION_DELETE_INTER_FREQ_CARRIER_ONGOING_AT_SON;
                    }
                    else if (p_inter_freq_carr_params->config_ongoing &
                            OAM_ANR_ACTION_DELETE_UTRAN_FDD_CARRIER_ONGOING_AT_SON) {

                        /* Updating at OAM meas enable record */ 
                        if(p_local_inter_freq_carr_params->
                                utran_meas_enable[query_idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
                        {
                            p_inter_freq_carr_params->utran_meas_enable[query_idx].
                                bitmask |= OAM_SON_MEAS_ENABLE_PRESENT; 
                        }
                        p_inter_freq_carr_params->config_ongoing &=
                            ~OAM_ANR_ACTION_DELETE_UTRAN_FDD_CARRIER_ONGOING_AT_SON;
                    }
                    else if (p_inter_freq_carr_params->config_ongoing &
                            OAM_ANR_ACTION_DELETE_GERAN_FREQ_CARRIER_ONGOING_AT_SON) {

                        /* Updating at OAM meas enable record */ 
                        if(p_local_inter_freq_carr_params->
                                geran_meas_enable[query_idx].bitmask & OAM_SON_MEAS_ENABLE_PRESENT)
                        {
                            p_inter_freq_carr_params->geran_meas_enable[query_idx].
                                bitmask |= OAM_SON_MEAS_ENABLE_PRESENT; 
                        }
                        p_inter_freq_carr_params->config_ongoing &=
                            ~OAM_ANR_ACTION_DELETE_GERAN_FREQ_CARRIER_ONGOING_AT_SON;
                    }
                    else if (p_inter_freq_carr_params->config_ongoing &
                            /* SPR 14651 END */
                            OAM_ANR_ACTION_DELETE_INTER_FREQ_CARRIER_ONGOING) {
                        /* SPR 14651 START/END Code Removed  */

                        oam_memset(&p_anr_meas_config_req->
                                eutran_config_list[query_idx],
                                OAM_ZERO, sizeof(son_meas_config_eutran_t));

                        p_inter_freq_carr_params->config_ongoing &=
                            ~OAM_ANR_ACTION_DELETE_INTER_FREQ_CARRIER_ONGOING;
                    }
                    else if (p_inter_freq_carr_params->config_ongoing &
                            OAM_ANR_ACTION_DELETE_UTRAN_FDD_FREQ_ONGOING) {
                        /* SPR 14651 START/END Code Removed  */

                        oam_memset(&p_anr_meas_config_req->
                                other_rat_config_list.utran_config_list.
                                utran_fdd_list[query_idx],
                                OAM_ZERO,
                                sizeof(son_meas_config_utran_fdd_t));

                        p_inter_freq_carr_params->config_ongoing &=
                            ~OAM_ANR_ACTION_DELETE_UTRAN_FDD_FREQ_ONGOING;
                    }
                    /* SPR 14651 START */
                    else if (p_inter_freq_carr_params->config_ongoing &
                            OAM_ANR_ACTION_DELETE_GERAN_FREQ_GROUP_ONGOING) {

                        oam_memset(&p_anr_meas_config_req->
                                other_rat_config_list.geran_config_list.
                                geran_freq_info_list[query_idx],
                                OAM_ZERO,
                                sizeof(son_geran_carrier_freq_info_t));

                        p_inter_freq_carr_params->config_ongoing &=
                            ~OAM_ANR_ACTION_DELETE_GERAN_FREQ_GROUP_ONGOING;
                    }
                    /* SPR 14651 END */

                    if (tcb_found) {
                        oam_update_xml_dom(layer_resp,
                                tcb_data.p_orig_xml_parent,
                                tcb_data.p_usr_msg_xml_parent,
                                tcb_data.p_parent_xml_struct_addr);
                    }
                    else {
                        OAM_LOG(OAM, OAM_WARNING,
                                "XML DOM can't be updated as TCB is not found");
                    }

                    err_string = OAM_NULL;
                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_MEAS_CONFIG_OBJ_REMOVE_RESP Result: Failure with error code: %d",
                            p_anr_meas_config_obj_remove_res->error_code);

                    err_string = oam_son_resp_code_to_str(
                            p_anr_meas_config_obj_remove_res->error_code);

                    err_str_size = oam_strlen(err_string) + OAM_ONE;
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_ANR_MEAS_CONFIG_OBJ_REMOVE_RESP: Parsing Failure");

                err = OAM_PARSE_MSG_DMG; 

                oam_get_err_string_n_err_code(err, &usr_error_code,
                        &err_string);
                err_str_size = oam_strlen(err_string) + OAM_ONE;
                usr_resp = OAM_RESULT_FAILURE;
            }

            /* SPR 14651 START */
            idx = LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).query_index;
            if (LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_config_idx).eutran_config_list_size) 
            {
                if(p_inter_freq_carr_params->eutran_meas_enable[idx].enable)
                {
                    if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            eutran_meas_enable[idx].enable == OAM_FALSE)
                    {
                        p_inter_freq_carr_params->eutran_meas_enable[query_idx].enable = 
                            p_local_inter_freq_carr_params->
                            eutran_meas_enable[query_idx].enable;
                        oam_construct_n_send_set_resp_to_usr(usr_resp,
                                usr_error_code,
                                (UInt8*)err_string,
                                err_str_size,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                tcb_data.usr_intf_src_id,
                                tcb_data.usr_req_trans_id,
                                OAM_ZERO, OAM_ZERO,
                                &err);
                        cli_resp_send = OAM_TRUE;
                    }
                }
            }
            else if (LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_config_idx).other_rat_config_list. 
                    utran_config_list.utran_fdd_list_size) 
            {
                if(p_inter_freq_carr_params->utran_meas_enable[idx].enable)
                {
                    if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            utran_meas_enable[idx].enable == OAM_FALSE)
                    {
                        p_inter_freq_carr_params->utran_meas_enable[query_idx].enable = 
                            p_local_inter_freq_carr_params->
                            utran_meas_enable[query_idx].enable;
                        oam_construct_n_send_set_resp_to_usr(usr_resp,
                                usr_error_code,
                                (UInt8*)err_string,
                                err_str_size,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                tcb_data.usr_intf_src_id,
                                tcb_data.usr_req_trans_id,
                                OAM_ZERO, OAM_ZERO,
                                &err);
                        cli_resp_send = OAM_TRUE;
                    }
                }
            }
            else if(LOCAL_SON_ANR_MEAS_CONFIG_REQ(cell_config_idx).other_rat_config_list. 
                    geran_config_list.geran_freq_info_list_size)
            {
                if(p_inter_freq_carr_params->geran_meas_enable[idx].enable)
                {
                    if(LOCAL_SON_INTER_FREQ_CARR_PARAMS(cell_config_idx).
                            geran_meas_enable[idx].enable == OAM_FALSE)
                    {
                        p_inter_freq_carr_params->geran_meas_enable[query_idx].enable = 
                            p_local_inter_freq_carr_params->
                            geran_meas_enable[query_idx].enable;
                        oam_construct_n_send_set_resp_to_usr(usr_resp,
                                usr_error_code,
                                (UInt8*)err_string,
                                err_str_size,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                tcb_data.usr_intf_src_id,
                                tcb_data.usr_req_trans_id,
                                OAM_ZERO, OAM_ZERO,
                                &err);
                        cli_resp_send = OAM_TRUE;
                    }
                }
            }

            if( (tcb_found) && (OAM_FALSE == cli_resp_send) ) {
                /* SPR 14651 END */
                oam_construct_n_send_deleteobject_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size, 
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        tcb_data.usr_intf_src_id,
                        tcb_data.usr_req_trans_id,
                        OAM_ZERO,
                        OAM_ZERO,
                        &err);
            }

            oam_prov_req.system_status.event_ongoing &=
                ~OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING;

            oam_mem_free(p_anr_meas_config_obj_remove_res, &err);
            break;

            /*SPR_15950 Fix Start*/
        case SON_OAM_LAST_SCAN_TIMESTAMP_IND:
            {
                OAM_LOG(OAM,OAM_DETAILED, "Received SON_OAM_LAST_SCAN_TIMESTAMP_IND from SON");
                son_oam_last_scan_timestamp_ind_t son_oam_last_scan_timestamp_ind; 
                UInt8  last_scan_time[OAM_MAX_STR_LEN];
                length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                length_read = OAM_ZERO;
                retVal      = oam_parse_son_oam_last_scan_timestamp_ind(&son_oam_last_scan_timestamp_ind,
                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        &length_read);

                if(retVal == OAM_FAILURE)
                {
                    OAM_LOG(OAM,OAM_WARNING, "Parsing Failed in SON_OAM_LAST_SCAN_TIMESTAMP_IND from SON");
                    return OAM_FAILURE;
                }
                else
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Parsing Successful in SON_OAM_LAST_SCAN_TIMESTAMP_IND from SON");
                }
                oam_memset(last_scan_time, OAM_ZERO, OAM_MAX_STR_LEN);
                /*SPR_16048 Fix Start*/
                oam_time_stamp_t time_stamp;
                oam_memset(&time_stamp, OAM_ZERO, sizeof(oam_time_stamp_t));
                oam_memcpy(&time_stamp,&son_oam_last_scan_timestamp_ind.time_stamp,sizeof(son_oam_last_scan_timestamp_ind.time_stamp));
                oam_fill_last_scan_time_format(last_scan_time,time_stamp);
                /*SPR_16048 Fix End*/
                /* Update the response values in prov and DOM Tree */
                /* spr_21013_fix_start */
                oam_persist_one_parameter(xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5,"LastScanTime",
                        /* spr_21013_fix_end */
                        (UInt8*)last_scan_time);

                break;
            }
            /*SPR_15950 Fix End*/

        case  SON_OAM_BULK_NW_SCAN_RESP:
            OAM_LOG(OAM, OAM_INFO, "SON_OAM_BULK_NW_SCAN_RESP received");
            /* SPR 19829 Fix Start */
            /* Changes for cell start after NMM */
            OAM_SYS_EVENT_BIMASK |= NR_SCAN_RESP_RCVD;
            /* SPR 19829 Fix End */
            if (!(oam_prov_req.system_status.
                        event_ongoing & OAM_SON_NMM_PERIODIC_SCAN_ONGOING)) {
                /* Coverity 69697 Fix Start */
                retVal = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                        &tcb_data.usr_req_trans_id,
                        &tcb_data.usr_intf_src_id,
                        &tcb_data.p_orig_xml_parent,
                        &tcb_data.p_usr_msg_xml_parent,
                        &tcb_data.p_parent_xml_struct_addr);
                if (OAM_FAILURE == retVal)
                {
                    /* Coverity_100517 Fix Start */
                    OAM_LOG(OAM, OAM_WARNING,"XML DOM can't be updated as TCB is not found");
                    /* Coverity_100517 Fix End */
                }
                else
                {
                    /* Coverity_100518 Fix Start */
                    OAM_LOG(OAM, OAM_WARNING,"XML DOM updated Successfully");
                    /* Coverity_100518 Fix End */
                }
                /* Coverity 69697 Fix End */
            }

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_read = OAM_ZERO;

            retVal = oam_parse_son_oam_bulk_nw_scan_resp(
                    &(SON_PROV_REQ.bulk_scan_resp),
                    p_api_buf,
                    length_left,
                    &length_read);
            if (OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_BULK_NW_SCAN_RESP:: Parsing Success");

                if (SON_SUCCESS == SON_PROV_REQ.bulk_scan_resp.result) {
                    OAM_LOG(OAM, OAM_INFO, "Success SON_OAM_BULK_NW_SCAN_RESP received");

                    /* Coverity_79015 Fix Start */
                    /* Code Removed */
                    /* Coverity_79015 Fix End */
                }
                else {
                    err_string = oam_son_resp_code_to_str(
                            SON_PROV_REQ.bulk_scan_resp.error_code);
                    OAM_LOG(OAM, OAM_INFO, "SON_OAM_BULK_NW_SCAN_RESP Failure response received with "
                            "error code: %s", err_string);
                    /* Coverity_79045 Fix Start */
                    /* Code Removed */ 
                    /* Coverity_79045 Fix End */

                }

                oam_fill_network_scan_response();	
                oam_fill_network_scan_status();

                /* CID 63819 FIX START */

                retVal = oam_inform_value_change_event(OAM_ZERO,
                        OAM_ZERO,
                        TR069_MODULE_ID);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_WARNING, "Failed to send the "
                            "value-change inform indication to TR069 agent");
                    retVal = OAM_SUCCESS;
                }
                /* CID 63819 FIX END */
                oam_memcpy(&(local_prov_req.oam_son_req.oam_nw_scan_result),
                        &(oam_prov_req.oam_son_req.oam_nw_scan_result),
                        sizeof(oam_nw_scan_result_t)); 
                oam_memcpy(&(local_prov_req.oam_igd_params.nw_scan_status),
                        &(oam_prov_req.oam_igd_params.nw_scan_status),
                        sizeof(oam_nw_scan_status_t));

                oam_save_nw_scan_results_in_dom();

                if(OAM_NULL != oam_prov_req.system_status.timer_id && g_oam_nmm_scan_first_time == OAM_TRUE)
                {
                    if(qvTimerRunning((QTIMER)(oam_prov_req.system_status.timer_id))== OAM_ONE)
                    {
                        OAM_LOG(OAM,OAM_BRIEF,"Stopping Timer: Id(%p)",
                                (QTIMER)(oam_prov_req.system_status.timer_id));
                        qvTimerStop((QTIMER)(oam_prov_req.system_status.timer_id),OAM_NULL);
                        timer_ptr = qvTimerData((QTIMER)(oam_prov_req.system_status.timer_id));       
                        if(OAM_NULL != timer_ptr)
                            oam_mem_free(timer_ptr,&err);
                    }
                    else
                    {
                        OAM_LOG(OAM,OAM_WARNING,"Trying to stop inavlid timer");
                    }
                    g_oam_nmm_scan_first_time = OAM_FALSE;

                    oam_son_execute_reboot(nmm_tmp_str);

                } 
                /* SPR 22925 Fix + */
                /* SPR 22925 Fix - */
            }

            else {
				OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_BULK_NW_SCAN_RESP:: Parsing Failure");
                /* Coverity_79045 Fix Start */
                /* Code Removed */ 
                /* Coverity_79045 Fix End */
            }
            /*SPR_18666 Fix Start*/
            /*Code Removed*/
            /*SPR_18666 Fix End*/
            /*+ SPR 18393*/
                    if ((OAM_TRUE == g_oam_nmm_bulk_resp_first_time) &&
                        (LOWER_LAYERS_PROVISIONING_MASK & initialisation_flag) &&
                        (INIT_TIME_PCI_SELECTION_MASK & initialisation_flag) &&
                        (INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK & initialisation_flag))
                    {
                    UInt16    gen_trans_id = OAM_ZERO;
                    init_time_startup = OAM_ZERO;
                    UInt8 cell_cnt = OAM_ZERO;
                    for (cell_cnt = OAM_ZERO;cell_cnt < oam_prov_req.num_cells_configured; ++cell_cnt) {
                    p_rrm_cell_config = &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_cnt];

                    retVal =
                    /* spr_21013_fix_start */
		    /* SPR 22248 MBMS Changes Start */
                    oam_handle_initial_admin_state_unlocked((UInt8 *)INVALID_ARGUMENT ,p_rrm_cell_config,
		    /* SPR 22248 MBMS Changes Stop */
                            /* spr_21013_fix_end */
                            &gen_trans_id);
                    }
                    g_oam_nmm_bulk_resp_first_time = OAM_FALSE;
                    }
            /*- SPR 18393*/
            break;

        case SON_OAM_ANR_UPDATED_NRT_INFO:
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_ANR_UPDATED_NRT_INFO received from SON");
            retVal = oam_mem_alloc(sizeof(oam_son_anr_updated_nrt_info_t),
                    (void**)&p_nrt_resp, &err);
            /*Coverity 81841 Fix Start*/
            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_nrt_resp failed"
                        " with Error Code:%d",
                        err);
                oam_get_err_string_n_err_code(err, &usr_error_code,
                        &err_string);
                usr_resp = OAM_RESULT_FAILURE;

                oam_construct_n_send_get_resp_to_usr(usr_resp,
                        usr_error_code,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dst_id, resp_trans_id,
                        OAM_ZERO, OAM_ZERO,
                        err_string, &err);

                break;
            }
            /*Coverity 81841 Fix End*/

            length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) -
                LOWER_LAYER_INTERFACE_HEADER_SIZE;
            p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_read = OAM_ZERO;
            retVal =
                oam_parse_son_oam_anr_updated_nrt_info(p_nrt_resp,
                        p_api_buf,
                        length_left,
                        &length_read);

            cid = oam_extract_cid_from_eutran_cellidentity(
                    p_nrt_resp->src_cgi.cell_identity);
            cell_config_idx = oam_get_son_neigh_list_in_use_idx(cid);
            if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        cid);
                /* Coverity ID : 85861 Fix Start*/
                oam_mem_free(p_nrt_resp, &err);
                /* Coverity ID : 85861 Fix End*/
                return OAM_FAILURE;
            }
            /* SPR 18930  FIX START  */
            OAM_LOG(OAM, OAM_DETAILED, " cell_config_idx = %d,is_first_time_nr_add_resp_rcv = %d,cellid %u ",cell_config_idx,SON_NEIGHBORLIST_INFO(cell_config_idx).first_nr_add_state,cid);

            /* SPR 18930  FIX END  */

            oam_fill_time_stamp(&time_stamp);

            oam_memset(SON_PROV_REQ.neigh_list_in_use[cell_config_idx].last_nrt_upd_time,
                    OAM_ZERO, NRT_INFO_MAX_TIMESTAMP_LEN);
            oam_memset(&LOCAL_NRT_INFO(cell_config_idx), OAM_ZERO,
                    sizeof(oam_son_anr_updated_nrt_info_t));

            oam_memcpy(&LOCAL_NRT_INFO(cell_config_idx),
                    p_nrt_resp,
                    sizeof(oam_son_anr_updated_nrt_info_t));

            LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_config_idx].cid = cid;

            oam_snprintf(SON_PROV_REQ.neigh_list_in_use[cell_config_idx].last_nrt_upd_time,
                    NRT_INFO_MAX_TIMESTAMP_LEN,"%d-%d-%d %d:%d:%d",
                    time_stamp.day, time_stamp.month, time_stamp.year,
                    time_stamp.hour, time_stamp.min, time_stamp.sec);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_UPDATED_NRT_INFO: Parsing Success");
                oam_son_update_neigh_list_in_use(cell_config_idx);
                oam_inform_value_change_event(OAM_NULL, OAM_MODULE_ID,
                        TR069_MODULE_ID);
            }
            else {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_UPDATED_NRT_INFO: Parsing Failure");
            }
            /* Coverity ID : 85861 Fix Start*/
            oam_mem_free(p_nrt_resp, &err);
            /* Coverity ID : 85861 Fix End*/
            break;

        case SON_OAM_ES_SWITCHED_OFF_CELL_INFO_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_ES_SWITCHED_OFF_CELL_INFO_RESP received from SON");

            if(!tcb_det) {
                OAM_LOG(OAM, OAM_WARNING, "Can't fetch TCB details. "
                        "Response to user request can't be sent.");
                retVal = OAM_FAILURE;
                break;
            }

            p_usr_req = tcb_det->oam_tcb_context;
            dst_id = get_word_from_header(p_usr_req + OAM_TWO);
            resp_trans_id = get_word_from_header(p_usr_req);

            retVal = oam_stop_timer(tcb_det->timer_id);
            if(OAM_SUCCESS != retVal) {
                OAM_LOG(OAM, OAM_WARNING,
                        "Error returned while stopping the timer");
            }
            else {
                OAM_LOG(OAM, OAM_INFO, "User request timer stopped");
            }

            /*-------------Deleting Entry In TCB --------------*/
            oam_tcb_delete(&trans_id);

            son_oam_es_switched_off_cell_info_resp_t *p_resp;

            retVal =
                oam_mem_alloc(sizeof(son_oam_es_switched_off_cell_info_resp_t),
                        (void**)&p_resp, &err);

            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_resp failed"
                        " with Error Code:%d",
                        err);

                oam_get_err_string_n_err_code(err, &usr_error_code,
                        &err_string);
                usr_resp = OAM_RESULT_FAILURE;

                oam_construct_n_send_get_resp_to_usr(usr_resp,
                        usr_error_code,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dst_id, resp_trans_id,
                        OAM_ZERO, OAM_ZERO,
                        err_string, &err);

                break;
            }

            length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT)
                - LOWER_LAYER_INTERFACE_HEADER_SIZE;
            p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_read = OAM_ZERO;
            retVal =
                oam_parse_son_oam_es_switched_off_cell_info_resp(p_resp,
                        p_api_buf,
                        length_left,
                        &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ES_SWITCHED_OFF_CELL_INFO_RESP: Parsing Success");
                oam_send_son_es_switched_of_cell_info_to_usr(p_resp,
                        dst_id,
                        resp_trans_id);
            }
            else {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_ANR_UPDATED_NRT_INFO: Parsing Failure");
                err_string = "Response message damaged!";
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;

                oam_construct_n_send_get_resp_to_usr(usr_resp,
                        usr_error_code,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dst_id, resp_trans_id,
                        OAM_ZERO, OAM_ZERO,
                        err_string, &err);
            }
            /* Coverity ID : 72214 Fix Start*/
            oam_mem_free(p_resp,&err);
            /* Coverity ID : 72214 Fix End*/
            break;
        case SON_OAM_RACH_OPT_ENABLE_RESP:


            OAM_LOG(OAM, OAM_INFO,
                    "Received SON_OAM_RACH_EABLE_RESP from SON");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                break;
            }
#endif
            /* SPR 9620 CHANGE END */
            retVal = oam_mem_alloc(sizeof(oam_son_rach_opt_enable_resp_t),
                    (void**)&p_oam_son_rach_opt_enable_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_oam_son_rach_opt_enable_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_oam_son_rach_opt_enable_resp, OAM_ZERO,
                    sizeof(oam_son_rach_opt_enable_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_rach_opt_enable_resp(p_oam_son_rach_opt_enable_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_RACH_ENABLE_RESP: Parsing Success");

                if(SON_SUCCESS == p_oam_son_rach_opt_enable_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_RACH_ENABLE_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_RACH_ENABLE_RESP returned failure");

                    err_string = "Unable to enable son RACH";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_RACH_ENABLE_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            if (rach_usr_req_flag) {
                rach_usr_req_flag = OAM_FALSE;


                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        &err);

            }

            oam_mem_free(p_oam_son_rach_opt_enable_resp, &err);
            break;


        case SON_OAM_RACH_OPT_DISABLE_RESP:
            {
                /* coverity 53536 */
                if(!tcb_det) {
                    OAM_LOG(OAM, OAM_WARNING, "Can't fetch TCB details. "
                            "Response to user request can't be sent.");

                    retVal = OAM_FAILURE;
                    break;
                }
                p_usr_req = tcb_det->oam_tcb_context;
                dst_id = get_word_from_header(p_usr_req + OAM_TWO);
                resp_trans_id = get_word_from_header(p_usr_req);

                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_DISABLE_RESP Received From SON Interface");
                /* coverity 53555 */
                oam_son_rach_opt_disable_resp_t oam_son_rach_opt_disable_resp;
                oam_memset(&oam_son_rach_opt_disable_resp,OAM_ZERO, sizeof(oam_son_rach_opt_disable_resp_t)); 
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;
                if (OAM_FAILURE == oam_parse_son_oam_rach_opt_disable_resp(&oam_son_rach_opt_disable_resp,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_RACH_OPT_DISABLE_RESP: Parsing Failed ");
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_DISABLE_RESP: Parsing Success ");
                }

                if(SON_SUCCESS == oam_son_rach_opt_disable_resp.result)
                {

                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                }
                else
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR,(UInt8 *)"Failure Response from SON",
                            oam_strlen("Failure Response from SON")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                }
            }
            break;

        case SON_OAM_RACH_OPT_MODIFY_RACH_OPTMODE_RESP:
            {
                /* coverity 53536 */
                if(!tcb_det) {
                    OAM_LOG(OAM, OAM_WARNING, "Can't fetch TCB details. "
                            "Response to user request can't be sent.");

                    retVal = OAM_FAILURE;
                    break;
                }
                p_usr_req = tcb_det->oam_tcb_context;
                dst_id = get_word_from_header(p_usr_req + OAM_TWO);
                resp_trans_id = get_word_from_header(p_usr_req);

                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_MODIFY_RACH_OPTMODE_RESP Received from SON Interface" );	

                oam_son_rach_opt_modify_rach_optmode_resp_t oam_son_rach_opt_modify_rach_optmode_resp;
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                if(OAM_FAILURE == oam_parse_son_oam_rach_opt_modify_rach_optmode_resp(
                            &oam_son_rach_opt_modify_rach_optmode_resp,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_RACH_OPT_MODIFY_RACH_OPTMODE_RESP: Parsing Failed");
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_MODIFY_RACH_OPTMODE_RESP: Parsing Success");
                }

                if(SON_SUCCESS == oam_son_rach_opt_modify_rach_optmode_resp.result)
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                }
                else
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR,(UInt8 *)"Failure Response from SON",
                            oam_strlen("Failure Response from SON")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                }	
            }
            break;

        case SON_OAM_RACH_OPT_MODIFY_CONFIG_PARAMS_RESP:
            {	
                /* coverity 53536 */
                if(!tcb_det) {
                    OAM_LOG(OAM, OAM_WARNING, "Can't fetch TCB details. "
                            "Response to user request can't be sent.");

                    retVal = OAM_FAILURE;
                    break;
                }
                p_usr_req = tcb_det->oam_tcb_context;
                dst_id = get_word_from_header(p_usr_req + OAM_TWO);
                resp_trans_id = get_word_from_header(p_usr_req);

                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_MODIFY_CONFIG_PARAMS_RESP Received From SON Interface" );

                oam_son_rach_opt_modify_config_params_resp_t oam_son_rach_opt_modify_config_params_resp ;
                oam_memset(&oam_son_rach_opt_modify_config_params_resp, OAM_ZERO, sizeof(oam_son_rach_opt_modify_config_params_resp_t));
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                if(OAM_FAILURE == oam_parse_son_oam_rach_opt_modify_config_params_resp(
                            &oam_son_rach_opt_modify_config_params_resp,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_RACH_OPT_MODIFY_CONFIG_PARAMS_RESP: Parsing Failed");
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_MODIFY_CONFIG_PARAMS_RESP: Parsing Success");
                }

                if(SON_SUCCESS == oam_son_rach_opt_modify_config_params_resp.result)
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                }
                else
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR,(UInt8 *)"Failure Response from SON",
                            oam_strlen("Failure Response from SON")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);

                }	
            }
            break; 

        case SON_OAM_RACH_OPT_PARAMETER_UPDATE_REQ:
            {

                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_PARAMETER_UPDATE_REQ Received From SON Interface");
                retVal = oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),(void **)&p_cell_reconfig_req,&err);/*Coverity FIX 31382 */

                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to p_cell_reconfig_req failed"
                            " with Error Code:%d",
                            err);

                    break;
                }
                /* SPR 20174 Fix Start */
                oam_memset(p_cell_reconfig_req, OAM_ZERO, sizeof(oam_rrm_cell_reconfig_req_t));
                /* SPR 20174 Fix End */

                oam_son_rach_opt_parameter_update_req_t oam_son_rach_opt_parameter_update_req ;
                oam_memset(&oam_son_rach_opt_parameter_update_req, OAM_ZERO, sizeof(oam_son_rach_opt_parameter_update_req_t));
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                if(OAM_FAILURE == oam_parse_son_oam_rach_opt_parameter_update_req(
                            &oam_son_rach_opt_parameter_update_req,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_RACH_OPT_PARAMETER_UPDATE_REQ: Parsing Failed");
                    /* Coverity ID : 72211 Fix Start*/
                    oam_mem_free(p_cell_reconfig_req, &err);
                    /* Coverity ID : 72211 Fix End*/
                    break;
                }
                else
                {
                    /* SPR 11567 Fix Start*/
                    cell_config_idx = cell_config_idx1 = OAM_ERROR_RETURN_VAL;
                    cid = oam_extract_cid_from_eutran_cellidentity(
                            oam_son_rach_opt_parameter_update_req.srv_cgi.cell_identity);

                    OAM_LOG(OAM,OAM_DETAILED,"SON_OAM_RACH_OPT_PARAMETER_UPDATE_REQ received for cell identity %d",cid);

                    cell_config_idx = oam_get_rrm_cell_config_idx(cid);

                    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                cid);
                        oam_mem_free(p_cell_reconfig_req, &err);
                        return OAM_FAILURE;
                    }

                    p_rrm_cell_config = &RRM_CELL_CONFIG(cell_config_idx);
                    /* BUG_FIXED_12749 */
                    /* SPR 13024 FIX START */
                    p_local_cell_config = &LOCAL_RRM_CELL_CONFIG(cell_config_idx);
                    /* SPR 13024 FIX END */
                    /* BUG_FIXED_12749 */

                    cell_config_idx1 = oam_get_son_serving_cell_idx(cid);

                    if(OAM_ERROR_RETURN_VAL == cell_config_idx1) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                cid);
                        oam_mem_free(p_cell_reconfig_req, &err);
                        return OAM_FAILURE;
                    }
                    /* SPR 11567 Fix End*/

                    /* BUG_FIXED_12749 */
                    oam_memcpy(p_local_cell_config, p_rrm_cell_config,
                            sizeof(oam_rrm_cell_config_req_t));

                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_PARAMETER_UPDATE_REQ: Parsing Success");
                    /* SPR 20270 changes start */
                    if(OAM_FAILURE == oam_maintain_tcb(tcb_transaction_id,OAM_TRANS_RRM,msg_len,p_api_buf))  
                    {
                    OAM_LOG(OAM, OAM_WARNING,
                                "Failed to maintain TCB ");
                    }
                    else
                    {    
                        oam_prov_req.system_status.event_ongoing |= OAM_SON_RACH_OPT_PARAMETER_UPDATE_ONGOING;
                    }
                    /* SPR 20270 changes end */
                    oam_set_bitmask_for_son_parameter_update_req(p_cell_reconfig_req, oam_son_rach_opt_parameter_update_req);
                    oam_copy_config_to_reconfig(p_local_cell_config, p_cell_reconfig_req);        	

                    oam_set_son_parameter_update_for_reconfig(oam_son_rach_opt_parameter_update_req, p_cell_reconfig_req);	
                    /*BUG_FIXED_12749 */
                    oam_memcpy(p_local_cell_config, p_cell_reconfig_req,
                            sizeof(oam_rrm_cell_config_req_t));

                    /*BUG_FIXED_12749 */

                    /*SPR 21702 Start*/
                    oam_set_son_parameter_update_for_cell_info(oam_son_rach_opt_parameter_update_req, 
                            &SON_PROV_REQ.oam_son_cell_info_ind[cell_config_idx]);	
                    /*SPR 21702 End*/

                    if(OAM_FAILURE == oam_rrm_send_rrm_oam_cell_reconfig_req(
                                p_cell_reconfig_req,
                                OAM_MODULE_ID,
                                RRM_MODULE_ID,
                                tcb_transaction_id,
                                cid))
                    {
                        OAM_LOG(OAM, OAM_WARNING, "RRM_OAM_CELL_RECONFIG_REQ failed");
                    }
                }
            }
            /* Coverity ID : 72211 Fix Start*/
            oam_mem_free(p_cell_reconfig_req, &err);
            /* Coverity ID : 72211 Fix End*/
            break;

        case SON_OAM_RACH_OPT_FAILURE_NOTIFICATION:
            {
                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_FAILURE_NOTIFICATION Received From SON Interface");
                oam_son_rach_opt_failure_notification_t oam_son_rach_opt_failure_notification;
                oam_memset(&oam_son_rach_opt_failure_notification, OAM_ZERO, sizeof(oam_son_rach_opt_failure_notification_t));
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                if(OAM_FAILURE == oam_parse_son_oam_rach_opt_failure_notification(
                            &oam_son_rach_opt_failure_notification,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_RACH_OPT_FAILURE_NOTIFICATION: Parsing Failed");
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_FAILURE_NOTIFICATION: Parsing Success");
                }

            }
            break;

        case SON_OAM_RACH_OPT_UE_INFO_REPORT:	 
            {
                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_UE_INFO_REPORT Received From SON Interface");
                oam_son_rach_opt_ue_info_report_t *oam_son_rach_opt_ue_info_report;
                oam_error_code_et p_error_code = NO_ERROR;   
                /* Coverity FIX 31382 */
                if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_son_rach_opt_ue_info_report_t),(void *)&oam_son_rach_opt_ue_info_report,&p_error_code))
                {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to oam_son_rach_opt_ue_info_report failed"
                            " with Error Code:%d",
                            p_error_code);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
                oam_memset(oam_son_rach_opt_ue_info_report, OAM_ZERO, sizeof(oam_son_rach_opt_ue_info_report_t));
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                if(OAM_FAILURE == oam_parse_son_oam_rach_opt_ue_info_report(
                            oam_son_rach_opt_ue_info_report,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_RACH_OPT_UE_INFO_REPORT: Parsing Failed");
                    /* Coverity ID : 72209 Fix Start*/
                    oam_mem_free(oam_son_rach_opt_ue_info_report,&p_error_code);
                    /* Coverity ID : 72209 Fix End*/
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_UE_INFO_REPORT: Parsing Success");
                }


                /* Coverity ID : 72209 Fix Start*/
                oam_mem_free(oam_son_rach_opt_ue_info_report,&p_error_code);
                /* Coverity ID : 72209 Fix End*/
            }
            break;
        case SON_OAM_RACH_OPT_L2_PERF_REPORT:
            {
                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_UE_INFO_REPORT Received From SON Interface");
                oam_son_rach_opt_l2_perf_report_t oam_son_rach_opt_l2_perf_report ;
                oam_memset(&oam_son_rach_opt_l2_perf_report, OAM_ZERO, sizeof(oam_son_rach_opt_l2_perf_report_t));
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                if(OAM_FAILURE == oam_parse_son_oam_rach_opt_l2_perf_report(
                            &oam_son_rach_opt_l2_perf_report,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_RACH_OPT_L2_PERF_REPORT: Parsing Failed");
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_L2_PERF_REPORT: Parsing Success");
                }

            }
            break;
            /* BUG_1171_START */
            /* SPR-9485 START */
#ifdef OAM_SON_ENABLE
        case SON_OAM_ANR_GU_GROUP_ID_CONFIG_RESP:
            {
                son_oam_anr_gu_group_id_config_resp_t oam_son_anr_gu_group_id_config_res;
                oam_memset(&oam_son_anr_gu_group_id_config_res, 
                        OAM_ZERO, 
                        sizeof(son_oam_anr_gu_group_id_config_resp_t));

                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                OAM_LOG(OAM, OAM_DETAILED, 
                        "SON_OAM_ANR_GU_GROUP_ID_CONFIG_RESP Received From SON Interface");
                /* parsing the response received from SON */
                if(OAM_FAILURE == oam_parse_son_oam_anr_gu_group_id_config_resp(&oam_son_anr_gu_group_id_config_res,
                            p_api_buf,
                            length_left,
                            &length_read)) 
                {
                    OAM_LOG(OAM, OAM_WARNING, 
                            "SON_OAM_ANR_GU_GROUP_ID_CONFIG_RESP: Parsing Failed");
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, 
                            "SON_OAM_ANR_GU_GROUP_ID_CONFIG_RESP: Parsing Success");

                    if(SON_SUCCESS == oam_son_anr_gu_group_id_config_res.result)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, 
                                "SON_OAM_ANR_GU_GROUP_ID_CONFIG_RESP: Received Response Success");
                    }

                }

            }
            break;
#endif
            /* SPR-9485 END */
        case SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_RESP:
            {
                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_RESP Response received");
                if(!tcb_det) {
                    OAM_LOG(OAM, OAM_WARNING, "Can't fetch TCB details. "
                            "Response to user request can't be sent.");

                    retVal = OAM_FAILURE;
                    break;
                }
                p_usr_req = tcb_det->oam_tcb_context;
                dst_id = get_word_from_header(p_usr_req + OAM_TWO);
                resp_trans_id = get_word_from_header(p_usr_req);

                oam_son_pci_conflict_enable_disable_resp_t oam_son_pci_conflict_enable_disable_resp;
                oam_error_code_et p_error_code = NO_ERROR;
                /* Coverity FIX 31382 */
                if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_son_pci_conflict_enable_disable_resp_t),(void *)&oam_son_pci_conflict_enable_disable_resp,&p_error_code))
                {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to oam_son_pci_conflict_enable_disable_resp failed"
                            " with Error Code:%d",
                            p_error_code);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                oam_memset((void *)&oam_son_pci_conflict_enable_disable_resp, OAM_ZERO, sizeof(oam_son_pci_conflict_enable_disable_resp_t));
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                if(OAM_FAILURE == oam_parse_son_oam_pci_conflict_enable_disable_resp(
                            &oam_son_pci_conflict_enable_disable_resp,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_RESP: Parsing Failed");
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_CONFLICT_ENABLE_DISABLE_RESP: Parsing Success");
                }
                if(SON_SUCCESS == oam_son_pci_conflict_enable_disable_resp.result)
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                }
                else
                {
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR,(UInt8 *)"Failure Response from SON",
                            oam_strlen("Failure Response from SON")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, resp_trans_id, OAM_ZERO, OAM_ZERO,
                            &err);
                }
            }
            break;

            /* BUG_1171_END */

            /*BUG_1170_START*/
        case SON_OAM_ES_ACTIVE_UE_COUNT_REPORT:
            {
                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_ES_ACTIVE_UE_COUNT_REPORT Response received");

                oam_son_es_active_ue_count_report_t oam_son_es_active_ue_count_report;
                oam_error_code_et p_error_code = NO_ERROR;
                /* Coverity FIX 31382 */
                if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_son_es_active_ue_count_report_t),(void *)&oam_son_es_active_ue_count_report,&p_error_code))
                {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to oam_son_es_active_ue_count_report failed"
                            " with Error Code:%d",
                            p_error_code);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                oam_memset((void *)&oam_son_es_active_ue_count_report, OAM_ZERO, sizeof(oam_son_es_active_ue_count_report_t));
                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                if(OAM_FAILURE == oam_parse_son_oam_es_active_ue_count_report(
                            &oam_son_es_active_ue_count_report,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, "SON_OAM_ES_ACTIVE_UE_COUNT_REPORT: Parsing Failed");
                    break;
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_ES_ACTIVE_UE_COUNT_REPORT: Parsing Success");
                }
            }
            break;
            /* SON Cell Delete Support Start*/
        case SON_OAM_CELL_DELETE_RESP:
            {

                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                {
                    OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                    break;
                }
#endif
                /* SPR 9620 CHANGE END */
                son_oam_cell_delete_resp_t oam_son_cell_delete_resp = {OAM_ZERO};

                length_left = get_word_from_header((UInt8*)p_api_buf + OAM_EIGHT)
                    - LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_read = OAM_ZERO;

                OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_CELL_DELETE_RESP received");
                if(OAM_FAILURE == oam_parse_son_oam_cell_delete_resp(
                            &oam_son_cell_delete_resp,
                            p_api_buf,
                            length_left,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_WARNING, 
                            "SON_OAM_CELL_DELETE_RESP: Parsing Failed");
                    return OAM_FAILURE; 
                }
                else
                {
                    OAM_LOG(OAM, OAM_INFO, 
                            "SON_OAM_CELL_DELETE_RESP: Parsing Success");
                    switch(oam_son_cell_delete_resp.cell_delete_status_list[OAM_ZERO].result)
                    {
                        case SON_FAILURE:

                            OAM_LOG(OAM, OAM_WARNING,
                                "Failure Response Received from SON_OAM_CELL_DELETE_RESP");
                        break;

                        case SON_SUCCESS:

                        OAM_LOG(OAM, OAM_DETAILED,
                                "Success Response Received from SON_OAM_CELL_DELETE_RESP");
                        break;

                        case SON_PARTIAL_SUCCESS:

                            OAM_LOG(OAM, OAM_INFO,
                                "Partial Success Response Received from SON_OAM_CELL_DELETE_RESP");
                        break;

                        default:
                            OAM_LOG(OAM, OAM_WARNING, 
                                "Invalid resp [%d] Response Received from SON_OAM_CELL_DELETE_RESP",
                                oam_son_cell_delete_resp.cell_delete_status_list[OAM_ZERO].result);
                        break;
                    }
                    /*SPR 21412 Fix Start */
                    /*SPR 21412 Fix End */
                }
            }
            break;
            /* SON Cell Delete Support End*/
            /*eICIC_PHASE_1_2_CHANGES_START*/
        case SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_RESP:
            {
                OAM_LOG(OAM, OAM_INFO, "Received SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_RESP  from SON");

#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                {
                    OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed in SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_RESP");
                    break;
                }

#endif

                /* SPR 21154 Fixed Start */
                OAM_LOG(OAM, OAM_DETAILED, "RSEP to maintain TCB %d%d", trans_id,dest_id);
                /* SPR 21154 Fixed End */
                retVal = oam_mem_alloc(sizeof(son_oam_anr_neighbor_default_config_req_t),
                        (void**)&p_anr_neighbor_default_config_resp,
                        &err);
                if (OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to p_anr_neighbor_default_config_resp failed"
                            " with Error Code:%d",
                            err);
                    break;
                }

                oam_memset(p_anr_neighbor_default_config_resp, OAM_ZERO,
                        sizeof(son_oam_anr_neighbor_default_config_req_t));

                length_left = get_word_from_header((UInt8*)p_api_buf +
                        OAM_INTF_HDR_MSG_SIZE_OFFSET);
                length_read = OAM_ZERO;
                p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
                length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                retVal = oam_parse_son_oam_anr_neighbor_default_config_resp(p_anr_neighbor_default_config_resp,
                        p_tmp_buf,
                        length_left,
                        &length_read);

                if(OAM_SUCCESS == retVal) {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_RESP: Parsing Success");

                    cell_config_idx = oam_get_son_serving_cell_idx(cid);
                    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
                        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                cid);
                        /* Coverity ID : 85863 Fix Start*/
                        oam_mem_free(p_anr_neighbor_default_config_resp,&err);
                        /* Coverity ID : 85863 Fix End*/
                        return OAM_FAILURE;
                    }

                    if(SON_SUCCESS == p_anr_neighbor_default_config_resp->result) {
                        OAM_LOG(OAM, OAM_INFO,
                                "SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_RESP returned success");

                        SON_PROV_REQ.oam_energy_saving_config[cell_config_idx].
                            es_enable_disable = OAM_ONE;

                        err_str_size = OAM_ZERO;
                        usr_error_code = OAM_ZERO;
                        usr_resp = OAM_RESULT_SUCCESS;
                    }
                    else {
                        OAM_LOG(OAM, OAM_WARNING,
                                "SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_RESP returned failure");

                        err_string = "Unable to enable son ES";
                        err_str_size = oam_strlen(err_string);
                        usr_error_code = OAM_ERR_INTERNAL_ERROR;
                        usr_resp = OAM_RESULT_FAILURE;
                        SON_PROV_REQ.oam_energy_saving_config[cell_config_idx].
                            es_enable_disable = OAM_ZERO;
                    }
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_RESP: Parsing Failed");

                    err_string = "Response message parsing failed";

                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }

                if (usr_intf_flag) {
                    usr_intf_flag = OAM_FALSE;

                    oam_construct_n_send_set_resp_to_usr(usr_resp,
                            usr_error_code,
                            (UInt8*)err_string,
                            err_str_size,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dest_id,
                            trans_id_resp,
                            OAM_ZERO, OAM_ZERO,
                            &err);

                }

                oam_mem_free(p_anr_neighbor_default_config_resp, &err);
                break;


            } 
            break;
            /*eICIC_PHASE_1_2_CHANGES_END*/   

            /* SPR_19619 start*/

        case SON_OAM_PEER_CELL_ACTIVATION_RESP:

            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                break;
            }
#endif
            /* SPR 9620 CHANGE END */
            OAM_LOG(OAM, OAM_INFO,
                    "SON_OAM_PEER_CELL_ACTIVATION_RESP received from SON");

            retVal = oam_mem_alloc(sizeof(son_oam_peer_cell_activation_resp_t),
                    (void**)&p_son_oam_peer_cell_activation_resp,
                    &err);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_son_oam_peer_cell_activation_resp failed"
                        " with Error Code:%d",
                        err);
                break;
            }

            oam_memset(p_son_oam_peer_cell_activation_resp, OAM_ZERO,
                    sizeof(son_oam_peer_cell_activation_resp_t));

            length_left = get_word_from_header((UInt8*)p_api_buf +
                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
            length_read = OAM_ZERO;
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            retVal = oam_parse_son_oam_peer_cell_activation_resp(p_son_oam_peer_cell_activation_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if(OAM_SUCCESS == retVal) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "SON_OAM_PEER_CELL_ACTIVATION_RESP");

                if(SON_SUCCESS == p_son_oam_peer_cell_activation_resp->result) {
                    OAM_LOG(OAM, OAM_INFO,
                            "SON_OAM_PEER_CELL_ACTIVATION_RESP returned success");

                    err_str_size = OAM_ZERO;
                    usr_error_code = OAM_ZERO;
                    usr_resp = OAM_RESULT_SUCCESS;
                }
                else {
                    OAM_LOG(OAM, OAM_WARNING,
                            "SON_OAM_PEER_CELL_ACTIVATION_RESP "
                            "returned failure with error code: %d",
                            p_son_oam_peer_cell_activation_resp->error_code);



                    err_string = "Unable to send peer cell activation response";
                    err_str_size = oam_strlen(err_string);
                    usr_error_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp = OAM_RESULT_FAILURE;
                }
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "SON_OAM_PEER_CELL_ACTIVATION_RESP: Parsing Failed");

                err_string = "Response message parsing failed";
                err_str_size = oam_strlen(err_string);
                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                usr_resp = OAM_RESULT_FAILURE;
            }

            oam_construct_n_send_set_resp_to_usr(usr_resp,
                    usr_error_code,
                    (UInt8*)err_string,
                    err_str_size,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id,
                    trans_id_resp,
                    OAM_ZERO, OAM_ZERO,
                    &err);


            oam_mem_free(p_son_oam_peer_cell_activation_resp, &err); 

            break;
            /* SPR_19619 stop*/
			/*spr 22474 start*/
        case SON_OAM_GET_DEBUG_INFO_RESP:
            {
                son_oam_get_debug_info_resp_t oam_son_get_debug_info_resp;
                SInt32 length_read= OAM_ZERO;
                UInt8 **str_arr = OAM_NULL;/* stores the strings[line][text] to be printed */
                UInt8 size_x = OAM_ZERO; /* Counts the number of strings to be printed */
                oam_error_code_et error_code = NO_ERROR;

                UInt8 cell_index = (UInt8)(*((UInt8*)(p_api_buf) + OAM_INTF_HDR_CELL_IDX_OFFSET));
                if (cell_index != oam_prov_req.cell_cntxt.curr_cell_cid)
                {
                    OAM_LOG(OAM,OAM_ERROR,"Received invalid cell_index %d",cell_index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                {
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
#endif
                if(OAM_SUCCESS == oam_parse_son_oam_get_debug_info_resp(&oam_son_get_debug_info_resp,
                            p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_DETAILED, "Successfully parse SON_OAM_GET_DEBUG_INFO_RESP");

                    if( OAM_SUCCESS == oam_son_get_debug_info_resp.response)
                    {
                        size_x = oam_get_son_debug_info_prints(&oam_son_get_debug_info_resp,&str_arr);
                        if (size_x)
                        {
                            oam_construct_n_send_gpv_response((UInt8 *)"Debug.Get.SON", str_arr, size_x,
                                    trans_id_resp, &error_code, dest_id, OAM_ZERO, OAM_ZERO);
                        }
                        else
                        {
                            OAM_LOG(OAM,OAM_ERROR,"Received error in response from SON in SON_OAM_GET_DEBUG_INFO_RESP %u %u",
                                    oam_son_get_debug_info_resp.response, size_x);

                            oam_construct_n_send_get_resp_to_usr(
                                    OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR,
                                    OAM_VERSION,
                                    OAM_MODULE_ID,dest_id,
                                    trans_id_resp,
                                    OAM_ZERO,OAM_ZERO,"SON LAYER FAILURE RESPONSE",
                                    &error_code
                                    );
                        }


                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_ERROR, "Received error in SON_OAM_GET_DEBUG_INFO_RESP with error code %d",
                                oam_son_get_debug_info_resp.fail_cause);
                        oam_construct_n_send_get_resp_to_usr(
                                OAM_RESULT_FAILURE,
                                OAM_ERR_INTERNAL_ERROR,
                                OAM_VERSION,
                                OAM_MODULE_ID,dest_id,
                                trans_id_resp,
                                OAM_ZERO,OAM_ZERO,"SON LAYER FAILURE RESPONSE received",
                                &error_code
                                );
                    }
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "Failed to parse SON_OAM_GET_DEBUG_INFO_RESP");
                    oam_construct_n_send_get_resp_to_usr(
                                OAM_RESULT_FAILURE,
                                OAM_ERR_INTERNAL_ERROR,
                                OAM_VERSION,
                                OAM_MODULE_ID,dest_id,
                                trans_id_resp,
                                OAM_ZERO,OAM_ZERO,"SON LAYER FAILURE RESPONSE received",
                                &error_code
                                );
                }
                break;					
            }
            /*spr 22474 end*/

        default:
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "Invalid api_id %d received in SON Msg Handler!!!", api_id);
                return OAM_FAILURE;
            }
            break;

            return OAM_SUCCESS;
    }


    return retVal;
}
#endif
/******************************************************************************
 * Function Name : oam_radio_transmission_carrier_enable_disable 
 * Description   : This function enable/disable radio transmission carrier. 
 * Inputs        : Cans_idrrier_state
 * Output        : None
 * Return        : None 
 ******************************************************************************/

oam_return_et
oam_radio_transmission_carrier_enable_disable
(
 oam_bool_et  carrier_state
 )
{
	oam_return_et    ret_val = OAM_SUCCESS; 

	/* IMP - Proper handling should be added here for actually 
	 * enabling and disabling radio carrier for L1 */ 
	/* Shall be added as part of Platform related Services */
	if(ENODEB_OP_STATE_ENABLED == (oam_op_state_et )carrier_state)
	{
		OAM_LOG(OAM, OAM_INFO, "RFTxStatus is set to True");
		oam_prov_req.system_status.rftx_status = OAM_TRUE;
	}
	else
	{
		OAM_LOG(OAM, OAM_INFO, "RFTxStatus is set to False");
		oam_prov_req.system_status.rftx_status = OAM_FALSE;
	}

	return ret_val;
}


/******************************************************************************
 * Function Name : oam_handle_rrm_cell_block_for_shutdown 
 * Description   : 
 * Inputs        : transaction_id 
 * Output        : None
 * Return        : OAM_FAILURE\OAM_SUCCESS 
 ******************************************************************************/
oam_return_et
oam_handle_rrm_cell_block_for_shutdown
(
 UInt16 transaction_id,
 void *p_api_buf
 )
{
	static UInt8 cell_block_req_sent = OAM_FALSE;
	/* coverity 35900 */	
	oam_return_et ret_val = OAM_SUCCESS;
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	OAM_FUN_ENTRY_TRACE();
	oam_rrm_cell_config_req_t *p_rrm_cell_config = &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx];
	if (cell_block_req_sent == OAM_FALSE)
	{
		oam_rrm_cell_block_req_t    oam_rrm_cell_block={OAM_ZERO};

		oam_rrm_cell_block.bitmask = OAM_ZERO;
		oam_memcpy(&(oam_rrm_cell_block.global_cell_id),
				&(p_rrm_cell_config->global_cell_info.eutran_global_cell_id),
				sizeof(oam_rrm_cell_block.global_cell_id));
		/* coverity 35891 */
		oam_rrm_cell_block.cell_block_priority = (rrm_oam_cell_block_priority_et)OAM_ZERO; /* High Priority */

		if(OAM_FAILURE == oam_rrm_send_rrm_oam_cell_block_req(
					&oam_rrm_cell_block,
					OAM_MODULE_ID,
					RRM_MODULE_ID,
					transaction_id,
					oam_prov_req.cell_cntxt.curr_cell_cid))
		{
			OAM_LOG(OAM, OAM_ERROR, "Sending RRM_OAM_CELL_BLOCK_REQ Failed");
			ret_val= OAM_FAILURE;
		}
		else{
			/* SPR 9620 CHANGE START */
			UInt16 msg_len=get_word_from_header((U8*)(p_api_buf) + OAM_EIGHT);   
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(transaction_id,OAM_SUB_MODULE_RRM,
						OAM_TRANS_RRM,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, "Failed to maintain TCB ");
				ret_val = OAM_FAILURE;
			}
#endif
			/* SPR 9620 CHANGE END */
		}
	}
	else
	{
		OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_CELL_BLOCK_RESP Recieved from RRM for shutdown OAM");
		oam_s1ap_close_mme_conn_t s1ap_close_mme_conn={OAM_ZERO};
		/* Handle cell block Response */
		s1ap_close_mme_conn.mme_count = OAM_ONE;
		s1ap_close_mme_conn.mme_id[OAM_ZERO] = OAM_ONE;

		if(OAM_SUCCESS == oam_s1ap_il_send_s1ap_oam_close_mme_conn(
					&s1ap_close_mme_conn,
					OAM_MODULE_ID,
					RRC_MODULE_ID,
					transaction_id,
					oam_prov_req.cell_cntxt.curr_cell_cid))
		{
			OAM_LOG(OAM, OAM_INFO, "S1AP_OAM_CLOSE_MME_CONN Request Succeeded");

			if(OAM_SUCCESS == oam_radio_transmission_carrier_enable_disable(OAM_FALSE))
			{
				OAM_LOG(OAM, OAM_WARNING, "Setting RFTxStatus to False Failed");
				if (OAM_FAILURE == oam_handle_shutdown_cmd((void*)OAM_NULL,OAM_ZERO,OAM_NULL))
				{
					OAM_LOG(OAM,OAM_WARNING,"Failed to Handle Shutdown Req");

					OAM_FUN_EXIT_TRACE();
					return OAM_FAILURE;
				}
			}
		}
		else
		{
			OAM_LOG(OAM, OAM_ERROR, "S1AP_OAM_CLOSE_MME_CONN Request Failed");
			ret_val= OAM_FAILURE;
		}
		cell_block_req_sent = OAM_FALSE;
	}
	cell_block_req_sent = OAM_TRUE;
	OAM_FUN_EXIT_TRACE();
	return ret_val;
}
/******************************************************************************
 * Function Name  : oam_rrm_msg_handler
 * Inputs         : p_api_buf, api_id, msg_len
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : This function handles rrm functions for OAM
 ******************************************************************************/
oam_return_et 
oam_rrm_intf_msg_handler
(
 void   *p_api_buf, 
 UInt16 api_id, 
 UInt16 msg_len
 )
{
    /*CID:56395 start*/
    OAM_FUN_ENTRY_TRACE();
    /* SPR 11001 FIX START */
    /* CODE DELETED */
    /* SPR 11001 FIX END */
    oam_rrm_cell_start_resp_t cell_start_resp;
    oam_rrm_cell_stop_resp_t cell_stop_resp; 
    oam_error_code_et error_code = NO_ERROR;
    /*CELL_DELETE_2.0*/
    oam_rrm_delete_resp_t cell_delete_resp;
    SInt32 length_read = OAM_ZERO;
    SInt32 length_left = OAM_ZERO;
    oam_return_et ret_val = OAM_SUCCESS;
    UInt8 *p_req_msg = OAM_NULL;
    UInt8* p_tmp_buf = OAM_NULL;
#ifndef OAM_SON_ENABLE
    UInt8  neigh_count = OAM_ZERO;
    /* SPR-16334 START */
    oam_x2ap_enb_config_update_req_t ecu_req = {OAM_ZERO};
    UInt8 index = OAM_ZERO;
    /* SPR-16334 END */


#else
	/* SPR 21831 +- */
    oam_son_cell_info_ind_t oam_cell_info_ind = {OAM_ZERO};
    /*eICIC_PHASE_1_2_CHANGES_START*/
    oam_son_anr_neighbor_default_config_req_t anr_neighbor_default_config_req = {OAM_ZERO};
    /*eICIC_PHASE_1_2_CHANGES_END*/
    /* BCOM Compiltaion Fix */
    UInt16 index = OAM_ZERO;
#endif
    /* BCOM Compiltaion Fix */

    UInt16 ret_state = OAM_ZERO;
    UInt16 trans_id_resp = OAM_ZERO;
    UInt16 dest_id = OAM_ZERO;
    UInt16 trans_id = get_word_from_header((UInt8 *)p_api_buf);
    UInt32 tid = trans_id;
    oam_struct_t *tcb_det = oam_tcb_get_detail(&tid);
    Char8 err_str[OAM_MAX_STR_LEN] = {OAM_ZERO};
    /* SPR 11001 FIX START */
    Char8 *err_string = OAM_NULL;
    /* SPR 11001 FIX END */
    UInt8 err_str_len = OAM_ZERO;
    UInt8 usr_resp_code = OAM_RESULT_FAILURE;
    UInt16 usr_err_code = OAM_ZERO;
    UInt8 loop = OAM_ZERO;
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    UInt8 cid = OAM_ZERO;
    oam_cell_status_t *p_cell_status = OAM_NULL;
    rrm_oam_cell_config_resp_t rrm_oam_cell_config_resp;
    Char8 p_al_add_txt[OAM_MAX_STR_LEN] = {OAM_ZERO};
    Char8 *p_al_add_info = OAM_NULL;
    /* SPR 11001 FIX START */
    rrm_oam_load_config_resp_t load_config_resp;
    /* SPR 11001 FIX END */
    /* Spr 10926 Fix Start */  
    static UInt8 count_cell_statr_rcvd = OAM_ZERO;
    /* Spr 10926 Fix End */  

    oam_rrm_cell_reconfig_resp_t cell_reconfig_resp;

    /* SPR 14498 START */
    /* SPR_19279_START */  
    /* Code Deleted */
    /* SPR_19279_END */
    UInt8 temp_str[OAM_TWO]="";
    /* SPR 14498 END */
    /* SPR 14118 START */
    /* Coverity_72203 Fix Start */
    /* Code Removed */
    /* Coverity_72203 Fix End */
    /* SPR 14118 END*/
    /* SPR 21412 Fix Start */
    /* SPR 21412 Fix End */
#ifdef LTE_EMBMS_SUPPORTED
    static oam_bool_et init_time_cell_start_flag = OAM_TRUE;
#endif
	/* SPR 21738 Fix Start */
	static UInt8  cell_started = OAM_ZERO, 
		      cell_stopped = OAM_ZERO;
	/* SPR 21738 Fix End */

	switch(api_id) {
		case RRM_OAM_CHK_HEALTH_RESP:
			/*SPR 21369 Start*/
            oam_hm_recieved_resp_bitmask_update(p_api_buf);
			/*SPR 21369 End*/
			break;

        case RRM_OAM_CELL_ECN_CAPACITY_ENHANCE_RESP:
            {
                OAM_LOG(OAM,OAM_DETAILED,"RRM_OAM_CELL_ECN_CAPACITY_ENHANCE_RESP Start up");
                oam_rrm_cell_ecn_capacity_enhance_resp_t  oam_cell_ecn_capacity_enhance_resp;
                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                {
                    OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                    break;
                }
#endif
                /* SPR 9620 CHANGE END */
                oam_parse_rrm_oam_cell_ecn_capacity_enhance_resp(
                        &oam_cell_ecn_capacity_enhance_resp,
                        p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        &length_read);
                if(OAM_ONE == oam_ul_dl_qci_cli_flag.flag)
                {
                    if(RRM_SUCCESS  == oam_cell_ecn_capacity_enhance_resp.response)
                    {
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                OAM_ZERO,(UInt8 *)"CELL ECN CAPACITY ENHENCEMENT COMMAND SUCCESS", oam_strlen("CELL ECN CAPACITY ENHENCEMENT SUCCESS") + 1,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id , trans_id, OAM_ZERO, OAM_ZERO,
                                /* SPR 11001 FIX START */
                                &error_code);
                        /* SPR 11001 FIX END */
                    }
                    else
                    {
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ZERO,(UInt8 *)"CELL ECN CAPACITY ENHENCEMENT FAIL", oam_strlen("CELL ECN CAPACITY ENHENCEMENT FAIL") + 1,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id , trans_id, OAM_ZERO, OAM_ZERO,
                                /* SPR 11001 FIX START */
                                &error_code);
                        /* SPR 11001 FIX END */
                    }
                    oam_ul_dl_qci_cli_flag.flag = OAM_ZERO;
                }

                break;
            }   

        case RRM_OAM_INIT_IND:
            OAM_LOG(OAM, OAM_INFO, "Received RRM_OAM_INIT_IND from RRM");
            p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;
            ret_val = oam_cm_fsm_process_event(p_api_buf,
                    p_cm_cntxt,
                    &error_code);
            if (OAM_SUCCESS == ret_val) {
                OAM_LOG(OAM, OAM_INFO,
                        "Successfully sent RRM_OAM_INIT_CONFIG_REQ to FSM");
            }
            else {
				OAM_LOG(OAM, OAM_ERROR,
                        "Failed to send RRM_OAM_INIT_CONFIG_REQ to FSM");
            }
            break;

        case RRM_OAM_INIT_CONFIG_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received RRM_OAM_INIT_CONFIG_RESP from RRM");
            p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;
            ret_val = oam_cm_fsm_process_event(p_api_buf,
                    p_cm_cntxt,
                    &error_code);
            if(OAM_SUCCESS == ret_val) {
                OAM_LOG(OAM, OAM_INFO,
                        "Successfully Received RRM_OAM_INIT_CONFIG_RESP");

#ifdef OAM_SON_ENABLE
                 OAM_LOG(OAM,OAM_DETAILED, "oam_prov_req.system_status.is_nmm_enabled %d "
                                            "oam_prov_req.oam_tr069_req.connect_to_iHeMS %d "
                                            "g_oam_nmm_scan_first_time %d", 
						oam_prov_req.system_status.is_nmm_enabled, 
						oam_prov_req.oam_tr069_req.connect_to_iHeMS, 
                        g_oam_nmm_scan_first_time);

                if((oam_prov_req.system_status.is_nmm_enabled) &&
                        (OAM_FALSE == oam_prov_req.oam_tr069_req.connect_to_iHeMS) &&
                        (OAM_FALSE == g_oam_nmm_scan_first_time))
                {
                    OAM_LOG(OAM, OAM_DETAILED, "NMM is enabled, sending SON_NW_SCAN_CONFIG_CMD");
                    oam_son_send_son_oam_set_nw_scan_config_cmd(
                            &oam_prov_req.oam_son_req.nw_scan_config,
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            oam_get_new_trans_id(),
                            oam_prov_req.cell_cntxt.curr_cell_cid);

                }
                /* Trigger ICIC feature when eNodeB is not connected to iHeMS */
                /*+ SPR 18395*/
                /* Code Removed*/
                /*- SPR 18395*/
#endif
            }
            else
            {
                OAM_LOG(OAM,OAM_DETAILED, "RRM_OAM_INIT_CONFIG_RESP FAILED");
                return OAM_FAILURE;
            }
            break;

        case RRM_OAM_CELL_CONFIG_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received RRM_OAM_CELL_CONFIG_RESP from RRM");

            oam_memset(&rrm_oam_cell_config_resp, OAM_ZERO,
                    sizeof(rrm_oam_cell_config_resp_t));
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left = msg_len - LOWER_LAYER_INTERFACE_HEADER_SIZE;
            ret_val =
                oam_parse_rrm_oam_cell_config_resp(&rrm_oam_cell_config_resp,
                        p_tmp_buf,
                        length_left,
                        &length_read);

            if(OAM_FAILURE == ret_val) {
		OAM_LOG(OAM, OAM_WARNING, "RRM_OAM_CELL_CONFIG_RESP Message Parsing failed");
                break;
            }

            cid = oam_extract_cid_from_eutran_cellidentity(
                    rrm_oam_cell_config_resp.
                    global_cell_id.cell_identity);

            OAM_LOG(OAM, OAM_INFO, "RRM_OAM_CELL_CONFIG_RESP Response rcvd for cid: %d!!", cid);
            /*LTE_OAM_BUG_1113_FIXED */
            p_cell_status = oam_get_cell_cntxt_status(cid);
            oam_prov_req.cell_cntxt.curr_cell_cid = cid;
            /*LTE_OAM_BUG_1113_FIXED */
            if(!p_cell_status) {
		OAM_LOG(OAM, OAM_WARNING,
                        "RRM_OAM_CELL_CONFIG_RESP Response for unknown CID %d is received", cid);
                ret_val = OAM_FAILURE;

                break;
            }

            p_cell_status->cell_event |= CELL_CONFIG_RESP_RCVD;
            /* Stop timer after cell setup response received */
            if(qvTimerRunning(oam_prov_req.system_status.timer_id)) {
                for(loop = OAM_ZERO;
                        loop < oam_prov_req.num_cells_configured;
                        ++loop) {
                    /* Checking if all the cell config responses have been
                     * received
                     */
                    if(!(OAM_CELL_EV_ONGOING(loop) & CELL_CONFIG_RESP_RCVD)) {
                        break;
                    }
                }

                if(oam_prov_req.num_cells_configured == loop) {
                    ret_val =
                        oam_stop_timer(oam_prov_req.system_status.timer_id);
                    if(OAM_SUCCESS != ret_val) {
				OAM_LOG(OAM, OAM_WARNING,
                                "Error returned while stopping the timer");
                        break;
                    }
                    else {
                        OAM_LOG(OAM, OAM_INFO, "Cell Setup Timer Stopped");
                    }
                }
                else {
                    OAM_LOG(OAM, OAM_INFO,
                            "Timer will only be stopped after all cell "
                            "config responses are received");
                }
            }
            else {
                OAM_LOG(OAM, OAM_ERROR, "Timer is Already expired,"
                        " CELL IS NOT CONFIGURED!!!!!!");
            }
            /*Coverity Cid 56395 */ 
            if(RRM_SUCCESS == rrm_oam_cell_config_resp.response) {
		OAM_LOG(OAM, OAM_INFO, "RRM_OAM_CELL_CONFIG_RESP Success response received. "
				"!!..CELL SETUP SUCCESSFUL..!!");

                cell_config_idx = oam_get_rrm_cell_config_idx(cid);
                /* SPR_19838 : Coverity_10344_10447 Fix Start */
                if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
			OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                            cid);
                    ret_val = OAM_FAILURE;
                    break;
                }
                /* SPR_19838 : Coverity_10344_10447 Fix Stop */
                /* CSR 00058746 Fix START*/

                /*SPR 21018 Fixed Start */ 
                Config_Flag = OAM_ONE ;
                /*SPR 21018 Fixed End */ 
                p_cell_status->cell_state &= ~OAM_CELL_IDLE;
                p_cell_status->cell_state |= OAM_CELL_STOP; 
                OAM_LOG(OAM, OAM_INFO, "cell state = %s",
                        (char *)oam_get_cell_state_string(p_cell_status->cell_state));
                /* SPR 11243 FIX : code removed*/
                /* SPR 1248 FIX START */
                /* SPR 21412 Fix Start */
                            /* SPR 21412 Fix End */
                            /* SPR 11243 FIX End*/
                            if(cell_to_be_started_by_operator != RRM_FALSE)
                                p_cell_status->send_initialization_req = OAM_TRUE;

                            /* SPR 1248 FIX END */
                            /*+SPR 18853 FIX*/
                            if((OAM_SYS_EVENT_BIMASK & S1AP_LINK_UP_RCVD)
#ifdef OAM_SON_ENABLE
                                    /*check if NR SCAN Resp has receievd send start cell req*/
                                    && (OAM_SYS_EVENT_BIMASK & NR_SCAN_RESP_RCVD)
#endif
                              )
                            {
                                /*-SPR 18853 FIX*/
                                /* SPR 11243 FIX Start*/
                                if(cell_to_be_started_by_operator == RRM_TRUE){
                                    OAM_LOG(OAM, OAM_INFO, "Sending cell start to RRM");

                                    ret_val = oam_rrm_send_rrm_oam_cell_start_req(
                                            /* SPR 21412 Fix Start */
                                            (rrm_oam_cell_start_req_t*)
                                            (&OWN_CELL_CGI(cell_config_idx)),
                                            /* SPR 21412 Fix End */
                                            OAM_MODULE_ID, RRM_MODULE_ID, trans_id,
                                            cid);

                                    if(OAM_FAILURE == ret_val) {
                                        OAM_LOG(OAM, OAM_ERROR,
                                                "Failed to send RRM_OAM_CELL_START_REQ ");
                                        break;
                                    }
                                }
                                else
                                {

                                    OAM_LOG(OAM, OAM_INFO, "No need to start the cell as immediate start is false");

                                }
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_INFO, "cell not started as user S1 Link is not Up");
                            }
                            /* SPR 11243 FIX End*/
                            /* CSR 00058746 Fix END*/ 
                            /* SPR 11243 FIX End*/
                            /* SPR 21412 Fix Start */
                    if(usr_intf_flag == OAM_TRUE)
                        /* SPR 21412 FIX End*/
                    {
#ifndef OAM_UT_FRAMEWORK
                        p_cell_status->cell_event &= ~OAM_USER_TRIGGERED_STOP;

                        ret_val = oam_process_tcb_for_layer_resp(
                                p_api_buf,&trans_id_resp,&dest_id);
                        if(OAM_FAILURE == ret_val)
                        {
                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;
                        }
                        /* SPR 21412 FIX Start*/
                        /* SPR 21412 FIX End*/
#endif
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                OAM_ZERO, OAM_NULL, OAM_ZERO,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                /* SPR 21412 FIX Start*/
                                dest_id,
                                trans_id_resp,
                                /* SPR 21412 FIX End*/
                                OAM_ZERO,
                                OAM_ZERO,&error_code);
                        resp_destination_id = OAM_ZERO;
                        /* SPR 21412 FIX Start*/
                        /* SPR 11002 Fix Start */
                        usr_intf_flag = OAM_FALSE; 
                        /* SPR 11002 Fix End */
                        /* SPR 21412 FIX End*/
                        oam_prov_req.system_status.event_ongoing &= ~OAM_CELL_SETUP_MASK;
                        oam_prov_req.system_status.event_ongoing &= ~OAM_SET_ADMIN_STATE_RESP_PENDING;
                    }

                if(send_config_update_flag == OAM_ONE)
                {
                    oam_update_enb_config_info_from_current_mme_list();
                    /* SPR 13542 START */
                    if(OAM_SUCCESS == oam_update_s1ap_enb_config())
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "S1AP_ENB_CONFIG has been updated, Sending S1AP_OAM_ENB_CONFIG_UPDATE to L3");
                        oam_s1ap_il_send_s1ap_oam_enb_config_update(
                                /* SPR 15917 START */
                                &local_prov_req.oam_l3_req.oam_s1ap_req.
                                /* SPR 15917 END */
                                enb_config_update,
                                OAM_MODULE_ID,
                                RRC_MODULE_ID,
                                oam_get_new_trans_id(),
                                cid);
                    }
                    /* SPR 13542 END */
                    /* SPR-16334 START */
#ifndef OAM_SON_ENABLE
                    ecu_req.bitmask |= X2AP_SERVED_CELLS_TO_ADD_LIST_PRESENT;

                    /* send list for all enb */
                    if(OAM_SUCCESS == oam_update_list_all_enb(&ecu_req))
                    {
                        oam_update_serving_enb_info(&ecu_req);
                        if(OAM_FAILURE == oam_send_x2ap_enb_config_update_req(&ecu_req))
                        {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Failure in sending X2AP_ENB_CONFIG_UPDATE_REQ");
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED,
                                    "Successfully sent X2AP_ENB_CONFIG_UPDATE_REQ");
                        }
                        oam_update_connected_gu_grp_id_list(&ecu_req, OAM_ONE);
                    }
#endif
                    /* SPR-16334 END */



                    /* SPR 14118 START */
                    OAM_LOG(OAM, OAM_DETAILED, "Cell Config Resp Recieved, Sending s1ap_enb_config_update to L3");
                    /* SPR 16567 START */
                    if (oam_send_enb_config_update() != OAM_SUCCESS)
                    {
                        OAM_LOG(OAM, OAM_WARNING, "Failed to send enb config update");
                    }
                    else
                    {
                        if(OAM_NULL != (oam_prov_req.system_status.timer_id =
                                    oam_start_new_timer(OAM_SUB_MODULE_MIH,
                                        OAM_MODULE_ID,
                                        OAM_ENB_CONFIG_UPDATE_TIMER,
                                        OAM_USER_INTF_RESP_TIMEOUT_S * OAM_THOUSAND,
                                        p_api_buf,
                                        msg_len,
                                        OAM_FALSE)))
                        {
                       OAM_LOG(OAM,OAM_INFO,"Layers Config Timer started successfully");
                        }
                    }
                    /* SPR 16567 START */
                    /* SPR 14118 END */
                    send_config_update_flag = OAM_ZERO;
                }

#ifdef OAM_SON_ENABLE
                /*SPR 21702 Start*/
                oam_memcpy((void *)&oam_cell_info_ind.serving_cell[OAM_ZERO],
                    (void *)&oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].serving_cell[OAM_ZERO],sizeof(son_cell_t));
                oam_cell_info_ind.cell_info_size = oam_prov_req.oam_son_req.oam_son_cell_info_ind[cid].cell_info_size;
                /*SPR 21702 End*/

                /* send SON_CELL_INFO_IND */
                if (OAM_FAILURE == oam_son_send_son_oam_cell_info_ind(
                            &oam_cell_info_ind,
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            oam_get_new_trans_id(),
                            cid))
                {
                    OAM_LOG(OAM, OAM_ERROR, "Failed to send SON_OAM_CELL_INFO_IND"); 
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "Successfully sent SON_OAM_CELL_INFO_IND CID : %d",cid); 
                }

                /*eICIC_PHASE_1_2_CHANGES_START */
                /*SPR 14107 start*/
                if ((oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.bitmask & SON_OAM_ANR_NBR_DEF_NR_STATUS_PRESENT) || 
                        (oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.bitmask & SON_OAM_ANR_NBR_DEF_HO_STATUS_PRESENT) ||
                        (oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.bitmask & SON_OAM_ANR_NBR_DEF_X2_STATUS_PRESENT) || 
                        (oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.bitmask & SON_OAM_ANR_CSG_DEF_SCHEME_PRESENT) || 
                        (oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.bitmask & SON_OAM_ANR_PICO_DEF_SCHEME_PRESENT) || 
                        (oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req.bitmask & SON_OAM_ANR_MACRO_DEF_SCHEME_PRESENT))
                {
                    oam_memcpy((void *)&anr_neighbor_default_config_req,
                            (void *)&oam_prov_req.oam_son_req.oam_son_anr_neighbor_default_config_req,
                            sizeof(oam_son_anr_neighbor_default_config_req_t));
                    ret_val = oam_son_send_son_oam_anr_neighbor_default_config_req(
                            &anr_neighbor_default_config_req,
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            oam_get_new_trans_id(),
                            cid);

                    if(OAM_FAILURE == ret_val){
                        OAM_LOG(OAM, OAM_WARNING,
                                "Failed to send SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ");
                    }
                    else {
                        OAM_LOG(OAM, OAM_INFO,
                                "Successfully sent SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ");
                    }
                    tid=oam_get_new_trans_id();
                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(tid,OAM_SUB_MODULE_RRM,
                                OAM_TRANS_RRM,msg_len,p_api_buf))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                        ret_val = OAM_FAILURE;
                    }
                }
                else
                {
                    OAM_LOG(OAM, OAM_WARNING,
                            "No parameters are present:SON_OAM_ANR_NEIGHBOR_DEFAULT_CONFIG_REQ not send");
                }
                /*SPR 14107 end*/
                /*eICIC_PHASE_1_2_CHANGES_END */

                /* SPR #14531 Fix : code removed */



                /*SPR #14560 Code Removed*/

                /* RACH OPT code is moved after cell start success */ 
                /*SPR 11636 Fix Start 
                  Code Removed
                  SPR 11636 Fix End*/ 
                /*SPR 19981 Fix Start*/
                /*Code moved */
                /*SPR 19981 Fix Stop*/
#endif
                /* Set cell_setup_complete flag */
                oam_prov_req.system_status.cell_setup_complete = OAM_TRUE;

                /*Take backup of Admin State Parameter*/

                oam_prov_req.system_status.event_ongoing &= ~OAM_SET_ADMIN_STATE_RESP_PENDING;
                /*SPR 11120 FIX */
		/* SPR 22296 Fix Start */
#ifndef PDCP_GTPU_INTF
                ret_val = oam_handle_pm_reporting_at_startup();
#endif
		/* SPR 22296 Fix End */
                /*SPR 11120 FIX */

                /* Ensure persistence of parameters */
                oam_maintain_parameter_persistence();
                /* Review Comment incorporation */ 
                /* update the product info */      
                oam_update_enodeb_product_info();
            }
            else {
                /* SPR 11002 Fix */
                if(usr_intf_flag == OAM_TRUE)
                {
                    usr_intf_flag = OAM_FALSE;
#ifndef OAM_UT_FRAMEWORK 
                    if(OAM_FAILURE == oam_process_tcb_for_layer_resp(
                                p_api_buf,&trans_id_resp,&dest_id))
                    {
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
#endif

                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            rrm_oam_cell_config_resp.fail_cause, (UInt8 *) "Cell Setup Fail", oam_strlen("Cell Setup Fail")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dest_id, trans_id_resp,OAM_ZERO,
                            OAM_ZERO,&error_code);
                    resp_destination_id = OAM_ZERO;
                    return OAM_SUCCESS;
                }
                /*If cell config fails raise a critical alarm  */
		OAM_LOG(OAM,OAM_WARNING, "Failed RRM_OAM_CELL_CONFIG_RESP"
                        "Critical alarm raised as cell config failed!");

                oam_prov_req.system_status.op_state = ENODEB_OP_STATE_DISABLED;
                oam_snprintf(p_al_add_txt, OAM_MAX_STR_LEN,
                        /* Spr 12880 Fix Start*/
                        "Cell Configuration Failure For Cellid: %d", cid);
                /* Spr 12880 Fix End*/

                p_al_add_info = oam_rrm_resp_code_to_str(
                        rrm_oam_cell_config_resp.fail_cause);

                /* Spr 12880 Fix Start*/
                OAM_ALARM(CRITICAL_CONFIGURATION_FAILURE_ALARM_ID,CRITICAL,NOTIFY_NEW_ALARM,
                        PROCESSING_ERROR_ALARM,UNAVAILABLE,EXPEDITED_ALARM,
                        p_al_add_txt, p_al_add_info,cid);	
                /* Spr 12880 Fix End*/
            }

            break;

            /* SPR_13116_CHANGE_START */
        case RRM_OAM_GET_LOG_LEVEL_RESP :
            /*Coverity fix start : 54277 */
            {
                OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_GET_LOG_LEVEL_RESP from RRM");
                oam_rrm_get_log_level_resp_t   oam_get_loglevel_rrm;
                length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                length_read= OAM_ZERO;
                ret_val = oam_parse_rrm_oam_get_log_level_resp(&oam_get_loglevel_rrm,
                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        &length_read);
                /* SPR 13116 REVIEW COMMENTS FIX START */
                if(OAM_FAILURE == ret_val)
                    /* SPR 13116 REVIEW COMMENTS FIX END */
                {
		OAM_LOG(OAM,OAM_WARNING, "Parsing Failed in RRM_OAM_GET_LOG_LEVEL_RESP ");
                    return OAM_FAILURE;
                }
                else
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Parsing Successful in RRM_OAM_GET_LOG_LEVEL_RESP ");
                }


                ret_val=oam_rrm_get_loglevel_resp(&oam_get_loglevel_rrm,p_api_buf);
                /* SPR 13116 REVIEW COMMENTS FIX START */
                if(OAM_FAILURE == ret_val)
                    /* SPR 13116 REVIEW COMMENTS FIX END */
                {
		OAM_LOG(OAM,OAM_WARNING, "Failed in RRM_OAM_GET_LOG_LEVEL_RESP");
                    return OAM_FAILURE;
                }
                else
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Successful in RRM_OAM_GET_LOG_LEVEL_RESP ");
                }
            }
            /*Coverity fix end : 54277 */
            break;
            /* SPR_13116_CHANGE_END */


        case RRM_OAM_SET_LOG_LEVEL_RESP:
            {
                OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_SET_LOG_LEVEL_RESP: from RRM");
                /* coverity 41297 */
                oam_rrm_set_log_level_resp_t set_log_level_resp;
                oam_memset(&set_log_level_resp, OAM_ZERO, sizeof(oam_rrm_set_log_level_resp_t));
                length_read=0;
                UInt8 *p_req_msg;
                oam_struct_t        *node;
                UInt16 tcb_detail = get_word_from_header(p_api_buf + OAM_ZERO);
                UInt32 temp_tcb = tcb_detail;
                UInt32 bitmask = OAM_ZERO;

                if((OAM_SUCCESS== oam_parse_rrm_oam_set_log_level_resp(&set_log_level_resp,
                                p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE,&length_read))) 
                {

                    OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_SET_LOG_LEVEL_RESP:SUCCESS from RRM");
                    if(set_log_level_resp.response == RRM_SUCCESS)
                    {
                        node=oam_tcb_get_detail(&temp_tcb);
                        if(node)
                        {
                            oam_tcb_update_bitmask(tcb_detail,OAM_TRANS_RRM,&bitmask);

                            if(bitmask == 0)
                            {
                                p_req_msg = node->oam_tcb_context;
                                dest_id = get_word_from_header((UInt8*)(p_req_msg) + OAM_TWO);
#ifndef OAM_UT_FRAMEWORK
                                if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                    return OAM_FAILURE;
#endif
                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                        OAM_ZERO, OAM_NULL, OAM_ZERO,
                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                        dest_id, trans_id_resp,OAM_ZERO, 
                                        OAM_ZERO,&error_code);
                            }
                            else
                            {
                                OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_SET_LOG_LEVEL_RESP:SUCCESS from RRM for system log command,waiting for response from other layers");                      
                            }
                        }
                    }
                    else           
                    {
#ifndef OAM_UT_FRAMEWORK
                        if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                        { 
					OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");       
                        }                        
#endif
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                set_log_level_resp.fail_cause, (UInt8 *) "Set log level response fail from RRM", 
                                oam_strlen("Set log level response fail from RRM")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp,OAM_ZERO, 
                                OAM_ZERO,&error_code);

                    }

                }
                else                        
                {
			OAM_LOG(OAM,OAM_WARNING, "Received RRM_OAM_SET_LOG_LEVEL_RESP:FAILURE from RRM");
#ifndef OAM_UT_FRAMEWORK
                    if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                    {
				OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                    }
#endif
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            set_log_level_resp.fail_cause, (UInt8 *) "Set log level parsing failed", oam_strlen("Set log level parsing failed")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dest_id, trans_id_resp,OAM_ZERO,
                            OAM_ZERO,&error_code);

                }
            }
            break;

        case RRM_OAM_LOAD_CONFIG_RESP:
            /* SPR 11001 FIX START */
            OAM_LOG(OAM, OAM_INFO,
                    "Received RRM_OAM_LOAD_CONFIG_RESP from RRM");
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                break;
            }
#endif
            /* SPR 9620 CHANGE END */
            oam_memset(&load_config_resp, OAM_ZERO,
                    sizeof(rrm_oam_load_config_resp_t));

            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left = msg_len - LOWER_LAYER_INTERFACE_HEADER_SIZE;

            ret_val = oam_parse_rrm_oam_load_config_resp(&load_config_resp,
                    p_tmp_buf,
                    length_left,
                    &length_read);

            if (OAM_SUCCESS == ret_val) {
                OAM_LOG(OAM, OAM_DETAILED,
                        "RRM_OAM_LOAD_CONFIG_RESP: Parsing Success");

                if(RRM_SUCCESS == load_config_resp.response) {
                    OAM_LOG(OAM, OAM_INFO, "RRM_OAM_LOAD_CONFIG_RESP Success resposne received");

                    /* This function directly uses global structures:
                     * "oam_prov_req" to update the required data
                     */
                    oam_commit_local_load_config_data(
                            &LOCAL_RRM_PROV_REQ.oam_load_config_req);

                    err_str_len = OAM_ZERO;
                    usr_err_code = OAM_ZERO;
                    usr_resp_code = OAM_RESULT_SUCCESS;
                }
                else {
			OAM_LOG(OAM, OAM_WARNING,
                            "RRM_OAM_LOAD_CONFIG_RESP returned failure"
                            " with error code: %d", load_config_resp.fail_cause);

                    err_string = "Invalid Action set or Other Failure";
                    err_str_len = oam_strlen(err_string) + 1;
                    usr_err_code = OAM_ERR_INTERNAL_ERROR;
                    usr_resp_code = OAM_RESULT_FAILURE;
                }
            }
            else {
                error_code = OAM_PARSE_MSG_DMG;
		OAM_LOG(OAM, OAM_WARNING, " RRM_OAM_LOAD_CONFIG_RESP Message Parsing failed");
                break;
            }

            if (usr_intf_flag) {
                usr_intf_flag = OAM_FALSE;

                oam_construct_n_send_set_resp_to_usr(usr_resp_code,
                        usr_err_code,
                        (UInt8*)err_string,
                        err_str_len,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        &error_code);
            }

            /* SPR 11001 FIX END */
            break;

        case RRM_OAM_GET_VER_ID_RESP:
            {
                OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_GET_VER_ID_RESP from RRM");
                /* coverity 41298 */
                rrm_oam_get_ver_id_resp_t ver_id_resp;            
                if((OAM_SUCCESS==
                            oam_parse_rrm_oam_get_ver_id_resp(&ver_id_resp,p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE,&length_read)) && 
                        (ver_id_resp.response==RRM_SUCCESS))
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_GET_VER_ID_RESP:SUCCESS from RRM");
                    if(ver_id_resp.response == OAM_ZERO)
                    {
                        oam_memcpy(&(ver_id_resp.ver_id),
                                (oam_prov_req.oam_rrm_req.oam_send_oam_rrm_ver_id_resp.ver_id),
                                sizeof(ver_id_resp.ver_id));

                        {
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                    OAM_ZERO, OAM_NULL, OAM_ZERO,
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    destination_id, trans_id,OAM_ZERO,
                                    OAM_ZERO,&error_code);
                        }
                    }
                    else
                    {
				OAM_LOG(OAM,OAM_WARNING, "Received RRM_OAM_GET_VER_ID_RESP:FAILURE from RRM");
                        {
                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                    OAM_ZERO, (UInt8 *) "get version id fail", oam_strlen("get version id fail")+ OAM_ONE,
                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                    destination_id, trans_id,OAM_ZERO,
                                    OAM_ZERO,&error_code);
                        }

                    }


                }
                else
                {
			OAM_LOG(OAM,OAM_WARNING, "Received RRM_OAM_LOAD_CONFIG_RESP:FAILURE from RRM");
                }

                break;
            }
        case RRM_OAM_LOAD_REPORT_IND:
            {	
                OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_LOAD_REPORT_IND from RRM");
#ifndef OAM_SON_ENABLE
                rrm_oam_load_report_ind_t load_report_ind;
                if(OAM_SUCCESS==oam_parse_rrm_oam_load_report_ind(&load_report_ind,p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE,&length_read))
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_LOAD_REPORT_IND:SUCCESS from RRM");
                    OAM_LOG(OAM,OAM_DETAILED, "############SERVING CELL LOAD INFO###############");
                    oam_log_load_config_info(&load_report_ind.serv_cell_load_info);
                    for (neigh_count = OAM_ZERO; neigh_count<load_report_ind.count; neigh_count++)
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "##############NEIGHBOUR CELL[%d] LOAD INFO##############", neigh_count);
                        oam_log_load_config_info(&load_report_ind.neigh_cell_load_info[neigh_count]);
                    }
                }


#endif

                break;
            }
        case RRM_OAM_LOG_ENABLE_DISABLE_RESP:
            {
                OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_LOG_ENABLE_DISABLE_RESP from RRM");
                /* coverity 41296 */
                oam_rrm_log_enable_disable_resp_t log_enable_disable_resp;
                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                {
                    OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                    break;
                }
#endif
                /* SPR 9620 CHANGE END */
                if((OAM_SUCCESS==oam_parse_rrm_oam_log_enable_disable_resp(&log_enable_disable_resp,p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE, &length_read))&& log_enable_disable_resp.response==RRM_SUCCESS)
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_LOG_ENABLE_DISABLE_RESP:SUCCESS from RRM");
                    if(log_enable_disable_resp.response == RRM_SUCCESS)
                    {
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                OAM_ZERO, OAM_NULL, OAM_ZERO,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp,OAM_ZERO, 
                                OAM_ZERO,&error_code);
                    }
                    else
                    {
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                log_enable_disable_resp.fail_cause, (UInt8 *) "log enable disable fail", oam_strlen("log enable disable fail")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp,OAM_ZERO,
                                OAM_ZERO,&error_code);

                    }

                }
                else
                {
			OAM_LOG(OAM,OAM_WARNING, "Received RRM_OAM_LOG_ENABLE_DISABLE_RESP:FAILURE from RRM");
                }
            } 
            break;

        case RRM_OAM_CELL_RECONFIG_RESP:
            OAM_LOG(OAM, OAM_INFO,
                    "Received RRM_OAM_CELL_RECONFIG_RESP from RRM");

            oam_memset(&cell_reconfig_resp, OAM_ZERO,
                    sizeof(oam_rrm_cell_reconfig_resp_t));
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            msg_len -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

            ret_val =
                oam_parse_rrm_oam_cell_reconfig_resp(&cell_reconfig_resp,
                        p_tmp_buf, msg_len,
                        &length_read);
            if(OAM_SUCCESS == ret_val) {
                OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_CELL_RECONFIG_RESP Parsing successful...");

                /* SPR 12214 FIX START */
                send_reconfig_resp_to_mgmt_intf(p_api_buf,
                        &cell_reconfig_resp);
                /* SPR 12214 FIX END */
                if(RRM_SUCCESS == cell_reconfig_resp.response) {
                    OAM_LOG(OAM, OAM_INFO, "RRM_OAM_CELL_RECONFIG_RESP Success response received");
                    /*BUG_FIXED_11180 */

                    cid = oam_extract_cid_from_eutran_cellidentity(
                            cell_reconfig_resp.global_cell_id.cell_identity);

                    cell_config_idx = oam_get_rrm_cell_config_idx(cid);
                    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
				OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                                cid);
                        ret_val = OAM_FAILURE;
                        break;
                    }
                    /* SPR_19279_START */  
                    OAM_LOG(OAM,OAM_DETAILED,"Updating cell_config_idx= %d,local_prov_req.is_valid_bitmap=%d", cell_config_idx,local_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].is_valid_bitmap);
                    if((oam_prov_req.system_status.event_ongoing &
                                /* SPR 19977 Fix START */
                                OAM_CELL_PLMNLIST_CONFIG_ONGOING)||(oam_prov_req.system_status.event_ongoing &
                                    OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING ))
                    {
                        /* SPR_20467_FIX_START/END Code Removed*/

                        oam_memcpy(oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries,
                                local_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries,
                                sizeof(oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries));
                        /* Updating the dom for IsPrimary field of PLMNList */
                        oam_memset(temp_str, OAM_ZERO, OAM_TWO);
                        oam_populate_PLMNList();
                    }
                    /* SPR_19279_END */
                    /* SPR 19279 Fix Start/End Code Deleted */
                    /* SPR 19977 Fix End */
#ifdef OAM_SON_ENABLE /*Coverity Fix 67038*/
            /*SPR 21702 Start*/
                            OAM_LOG(OAM, OAM_DETAILED,
                                    "Updating SON_INFO_IND API");
                            oam_update_son_cell_info_ind_af_reconfig(
                cid, cell_config_idx);
                            oam_memset(&oam_cell_info_ind, OAM_ZERO,
                                    sizeof(oam_son_cell_info_ind_t));
                            /* SPR 11597 FIX END */
                            oam_memcpy(&oam_cell_info_ind.serving_cell[0],
                &SON_CELL_INFO_IND_SERVING_CELL(cell_config_idx),
                                    sizeof(son_cell_t));
                            oam_cell_info_ind.cell_info_size = 1;

                    /* SPR_20467_FIX_START */
                    UInt8 mnc_idx = OAM_ZERO;
                    UInt8 mcc_idx = OAM_ZERO;
            /*SPR 21702 +-*/
                    UInt8 mnc_index_present = 0;
            /*SPR 21702 Start*/
                        for(index = OAM_ZERO; index < oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].curr_plmn_entries; index++)
                        {
                            mnc_index_present = local_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries[index].plmn_id.num_mnc_digit;
                            for(mnc_idx = OAM_ZERO;mnc_idx<mnc_index_present;mnc_idx++)
                            {
                  oam_cell_info_ind.serving_cell[OAM_ZERO].plmn_id[index].mnc[mnc_idx] =  
                                    oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries[index].plmn_id.mnc[mnc_idx];
                            }    
                            for(mcc_idx = OAM_ZERO;mcc_idx<OAM_THREE;mcc_idx++)
                            {
                  oam_cell_info_ind.serving_cell[OAM_ZERO].plmn_id[index].mcc[mcc_idx] =  
                                    oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries[index].plmn_id.mcc[mcc_idx];
                            }

                oam_cell_info_ind.serving_cell[OAM_ZERO].plmn_id[index].num_mnc_digit = mnc_index_present;
                    }
            /*SPR 21702 End*/
                    /* SPR_20467_FIX_END */


                    /*BUG_FIXED_11180 */
                    ret_val = oam_son_send_son_oam_cell_info_ind(
                            &oam_cell_info_ind,
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            oam_get_new_trans_id(),
                            cid);

                    if(OAM_FAILURE == ret_val) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Failed to send SON_CELL_INFO_IND");
                    }
                    else {
                        OAM_LOG(OAM, OAM_INFO,
                                "Successfully sent SON_CELL_INFO_IND");
                    }

                    /* SPR-16334 START */
#else
                    if(OAM_TRUE == g_x2_ecu_send_check)
                    {
                        g_x2_ecu_send_check = OAM_FALSE;
                        if(OAM_TRUE == oam_check_ecu_send_required())
                        {
                            ecu_req.bitmask |= X2AP_SERVED_CELLS_TO_MODIFY_LIST_PRESENT;

                            /* send list for all enb */
                            if(OAM_SUCCESS == oam_update_list_all_enb(&ecu_req))
                            {    
                                oam_update_serving_enb_info(&ecu_req);
                                if(OAM_FAILURE == oam_send_x2ap_enb_config_update_req(&ecu_req))
                                {
                                    OAM_LOG(OAM, OAM_ERROR,
                                            "Failure in sending X2AP_ENB_CONFIG_UPDATE_REQ");
                                }
                                else
                                {
                                    OAM_LOG(OAM, OAM_DETAILED,
                                            "Successfully sent X2AP_ENB_CONFIG_UPDATE_REQ");
                                }
                            }

                        }
                    }
                    /* SPR-16334 END */
#endif
                    /* CSR 58157 FIX code removed */

            /* SPR_19279_START */  
            /* Code Removed */
            /* SPR_19279_END */  
            /* SPR 15527 START */
            if(oam_prov_req.system_status.event_ongoing & OAM_MODIFY_QOS_OBJ_ONGOING)
            {
              oam_prov_req.system_status.event_ongoing &= ~OAM_MODIFY_QOS_OBJ_ONGOING;
              oam_memcpy(RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list,
                    LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list,
                    sizeof(LOCAL_RRM_PROV_REQ.qos_data[cell_config_idx].qos_obj_list));
            }
            /* SPR 15527 END */

            /* SPR_20467_FIX_START */
            /* SPR 21531 start */
            if(!(oam_prov_req.system_status.event_ongoing & 
                  OAM_CELL_PLMNLIST_CONFIG_ONGOING)) 
            /* SPR 21531 end */
            {
            /* SPR_20467_FIX_END */
			   /* SPR 13542 START */
			   oam_update_enb_config_info_from_current_mme_list();

			   if(OAM_SUCCESS == oam_update_s1ap_enb_config())
               {
                   OAM_LOG(OAM, OAM_DETAILED, 
                           "S1AP_ENB_CONFIG has been updated, Sending config_update to L3");
                   /* SPR 18866 START */
                   oam_s1ap_il_send_s1ap_oam_enb_config_update(
                           &local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update,
                           OAM_MODULE_ID, RRC_MODULE_ID, oam_get_new_trans_id(),
                           cid);
                   /* SPR 18866 END */

               }
			   /* SPR 13542 END */
            /* SPR_20467_FIX_START */
            }
            /* SPR_20467_FIX_END */

                    /* SPR-16334 START */
#ifndef OAM_SON_ENABLE
                    ecu_req.bitmask |= X2AP_SERVED_CELLS_TO_ADD_LIST_PRESENT;   

                    /* send list for all enb */
                    if(OAM_SUCCESS == oam_update_list_all_enb(&ecu_req))
                    {    
                        oam_update_serving_enb_info(&ecu_req);
                        if(OAM_FAILURE == oam_send_x2ap_enb_config_update_req(&ecu_req))
                        {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Failure in sending X2AP_ENB_CONFIG_UPDATE_REQ");
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED,
                                    "Successfully sent X2AP_ENB_CONFIG_UPDATE_REQ");
                        }
                        oam_update_connected_gu_grp_id_list(&ecu_req, OAM_ONE);                   
                    }
#endif
                    /* SPR-16334 END */

                    /* SPR_20467_FIX_START/END Moved Code */
                    /* SPR 15917 START */
                    if(oam_prov_req.system_status.event_ongoing & 
                            OAM_CELL_PLMNLIST_CONFIG_ONGOING) {
                        oam_prov_req.system_status.event_ongoing &= 
                            ~OAM_CELL_PLMNLIST_CONFIG_ONGOING;
                    }
                    /* SPR 15917 END */
                }
                else if(RRM_FAILURE == cell_reconfig_resp.response) {
			OAM_LOG(OAM, OAM_WARNING, "RRM_OAM_CELL_RECONFIG_RESP Failure response received with "
                            "error code: %d", cell_reconfig_resp.fail_cause);

                    /* SPR_20467_FIX_START */
                    if(oam_prov_req.system_status.event_ongoing & 
                            OAM_CELL_PLMNLIST_CONFIG_ONGOING) 
                    {
                        /* OAM received failure in RRM_OAM_CELL_REOCNFIG_RESP, OAM send ECU to all connected MMEs 
                         * with the old configurations of BPLMNs/Supported TAs. 
                         * Further OAM shall send failure to UI
                         */
                OAM_LOG(OAM, OAM_WARNING, "Sending s1ap_enb_config_update to L3 with old configuration");

                        oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask = OAM_ZERO;
                        oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |= 
                            S1AP_OAM_ENB_CONFIG_UPDATE_TA_LIST_PRESENT;
                        oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |= 
                            S1AP_OAM_ENB_CONFIG_UPDATE_MME_LIST_PRESENT;

                        UInt8 index = 0;            
                        UInt8 index1 = 0;            
                        UInt8 mme_id = 0;            

                        for(index=0; index<oam_prov_req.oam_l3_req.mme_data.num_mme_id; index++)
                        {
                            mme_id = oam_prov_req.oam_l3_req.mme_data.mme_id[index];
                            oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.s1ap_oam_mme_id_list.mme_id[index1]= mme_id;
                            index1++;
                        }

                        oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.s1ap_oam_mme_id_list.num_mme_id=index1;

                        UInt16 transaction_id = oam_get_new_trans_id();
                        if(OAM_FAILURE == oam_s1ap_il_send_s1ap_oam_enb_config_update(
                                    &oam_prov_req.oam_l3_req.
                                    oam_s1ap_req.enb_config_update,
                                    OAM_MODULE_ID,
                                    RRC_MODULE_ID,
                                    transaction_id,
                                    oam_prov_req.cell_cntxt.curr_cell_cid))
                        {
                            OAM_LOG(OAM, OAM_WARNING, "Failed to send enb config update");
                        }
                        else
                        {
                            void *p_temp = OAM_NULL;
                            p_temp = oam_maintain_tcb_for_ecu(transaction_id, OAM_TRANS_X2AP,
                                    msg_len,p_api_buf,sizeof(oam_s1ap_ecu_resp_data_t),OAM_NULL,OAM_TRUE);

                            if (OAM_NULL == p_temp) {
                        OAM_LOG(OAM, OAM_WARNING, "Failed to maintain TCB ");
                                break;
                            }

                            oam_prov_req.system_status.timer_id = oam_start_guard_timer(transaction_id,OAM_SUB_MODULE_MIH,
                                    OAM_MODULE_ID,
                                    OAM_ENB_CONFIG_UPDATE_TIMER,
                                    OAM_USER_INTF_RESP_TIMEOUT_S * OAM_THOUSAND,
                                    (UInt8 *)p_temp,
                                    msg_len,
                                    OAM_FALSE);
                        }

                        /* SPR_20467_FIX_START */
                        if (current_enb_config_count > MAX_RETRY_COUNT )
                        {
                            oam_prov_req.system_status.event_ongoing &= 
                                ~OAM_CELL_PLMNLIST_CONFIG_ONGOING;
                        }    
                        /* SPR_20467_FIX_END */
                    }
                    /* SPR_20467_FIX_END */
                }
                else {
                    OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_CELL_RECONFIG_RESP Unknown response received");
                    /* SPR_20467_FIX_START/END Moved Code */
                    if(oam_prov_req.system_status.event_ongoing & 
                            OAM_CELL_PLMNLIST_CONFIG_ONGOING) {
                        oam_prov_req.system_status.event_ongoing &= 
                            ~OAM_CELL_PLMNLIST_CONFIG_ONGOING;
                    }
                }
                /* SPR_20467_FIX_START/END Moved Code */
            }
            /* SPR-13074 Start*/
            else
            {
                oam_prov_req.system_status.event_ongoing &= ~OAM_SON_CARRIER_FREQ_ONGOING;
            }
            /* SPR-13074 End */
            /* SPR 19977 Fix Start*/
            if(oam_prov_req.system_status.event_ongoing &
                    OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING)
            {
                oam_prov_req.system_status.event_ongoing &=
                    ~OAM_DELETE_OBJ_CELL_RECONFIG_ONGOING;

            }
            /* SPR 19977 Fix End*/

            break;

        case RRM_OAM_RAC_ENABLE_DISABLE_RESP:
            {
                oam_rrm_rac_enable_disable_resp_t rac_enable_disable_resp={OAM_ZERO};
                /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                {
			OAM_LOG(OAM,OAM_WARNING, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                    break;
                }
#endif
                /* SPR 9620 CHANGE END */


                if((OAM_SUCCESS==oam_parse_rrm_oam_rac_enable_disable_resp(&rac_enable_disable_resp,p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE, &length_read))&& rac_enable_disable_resp.response==RRM_SUCCESS)
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_RAC_ENABLE_DISABLE_RESP:SUCCESS from RRM");

                    if(rac_enable_disable_resp.response == RRM_SUCCESS)
                    {
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                OAM_ZERO, OAM_NULL, OAM_ZERO,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp,OAM_ZERO, 
                                OAM_ZERO,&error_code);
                    }
                    else
                    {
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                rac_enable_disable_resp.fail_cause, (UInt8 *) "Rac enable disable fail", oam_strlen("Rac enable disable fail")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp,OAM_ZERO, 
                                OAM_ZERO,&error_code);

                    }
                }
                else
                {
			OAM_LOG(OAM,OAM_WARNING, "Received RRM_OAM_RAC_ENABLE_DISABLE_RESP:FAILURE from RRM");
                }

            }
            break;
            /*SPR 11830 FIX START*/
        case RRM_OAM_CELL_START_RESP:
            /*SPR 11830 FIX END*/
            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            msg_len -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            ret_val = oam_parse_rrm_oam_cell_start_resp(&cell_start_resp,
                    p_tmp_buf,
                    msg_len,
                    &length_read);
            if(OAM_FAILURE == ret_val) {
		OAM_LOG(OAM, OAM_WARNING, "RRM_OAM_CELL_START_RESP Message parsing failed");
                break;
            }

            cid = oam_extract_cid_from_eutran_cellidentity(cell_start_resp.
                    global_cell_id.cell_identity);

            /*SPR 11830 FIX START*/
            OAM_LOG(OAM, OAM_INFO, "Received RRM_OAM_CELL_START_RESP for cell identity: %d",
                    cid);
            /*SPR 11830 FIX END*/
            p_cell_status = oam_get_cell_cntxt_status(cid);
            if(!p_cell_status) {
		OAM_LOG(OAM, OAM_WARNING,
                        "RRM_OAM_CELL_START_RESP Response for unknown CID is received");
                return OAM_FAILURE;
            } /* Cov CID 63645 */

            /* SPR-10648 Start */
            if(RRM_SUCCESS == cell_start_resp.response) {
                OAM_LOG(OAM,OAM_INFO, "RRM_OAM_CELL_START_RESP Success response received");
                p_cell_status->cell_state |= OAM_CELL_ACTIVE;
                p_cell_status->cell_state &= ~OAM_CELL_IDLE;
                p_cell_status->cell_state &= ~OAM_CELL_STOP;
                /*SPR 14423  FIX START */ 
                if (oam_prov_req.system_status.event_ongoing & OAM_SET_ADMIN_STATE_RESP_PENDING)
                {
                    oam_prov_req.system_status.admin_state =
                        local_prov_req.system_status.admin_state;

                    oam_prov_req.system_status.event_ongoing &=
                        ~OAM_SET_ADMIN_STATE_RESP_PENDING;
                }
                /*SPR 14423  FIX END */ 
        /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
        if (init_time_cell_start_flag)
        {
            /* 7.0 OAM_SSI Fix Start */
            M2AP_REQ.num_cells_start_received++;


            OAM_LOG(OAM, OAM_DETAILED,
                    "\nnum_cells_start_resp_received from RRM is %d\n", M2AP_REQ.num_cells_start_received);
            if (M2AP_REQ.num_cells_start_received == oam_prov_req.num_cells_configured)
                /* 7.0 OAM_SSI Fix End */
            {
                ret_val = oam_m2ap_send_init_time_cell_start_ind();

                if (OAM_SUCCESS == ret_val) 
                {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Successfully sent first cell start ind to M2AP");
                }
                else
                {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Failed to send first cell start ind to M2AP");
                }
                init_time_cell_start_flag = OAM_FALSE;
            }
        }
        else
        {
            ret_val = oam_m2ap_cell_change_state_ind(cid, CELL_START);

            if (OAM_SUCCESS == ret_val) 
            {
                OAM_LOG(OAM, OAM_DETAILED,
                        "Successfully sent cell state Change Ind to M2AP");
            }
            else
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Failed to send cell state Change Ind to M2AP");
            }
        }
#endif
        /* EMBMS Changes End */
                /* SPR Fix 21412 Start_Stop Start */
					cell_started ++;
					if(cell_stopped > OAM_ZERO)
					{
						cell_stopped --;
					}
					/* Cell Start has been trigerred internally due to S1 Link Up recieved */
					/* Check num of connected mme */
					if((OAM_S1_LINK_DOWN_SET == flag_for_s1_link)
							&& (cell_started == oam_prov_req.num_cells_configured))
					{
						/* No S1 Link is active, Send Cell Stop Req */
						OAM_LOG(OAM,OAM_INFO,"Sending cell stop to rrm as no s1 link is active and all the cells are in active state");
						if(OAM_FAILURE == oam_stop_all_cells(p_api_buf, msg_len))
						{
							OAM_LOG(OAM,OAM_ERROR,"Failed to stop all cells");
						}
					}
					else if((OAM_S1_LINK_UP_SET == flag_for_s1_link) && 
							(cell_started == oam_prov_req.num_cells_configured))
					{
						flag_for_s1_link = OAM_NO_S1_LINK_STATUS_SET;
					}
                /* SPR Fix 21412 Start_Stop End */

            }
            /* SPR-10648 End */
            else {
                OAM_LOG(OAM, OAM_INFO, "RRM_OAM_CELL_START_RESP Failure response received");
            }

            OAM_LOG(OAM, OAM_INFO, "cell state = %s",
                    (char *)oam_get_cell_state_string(p_cell_status->cell_state));
            /* Spr 10926 Fix Start */  
            if (((usr_intf_flag == OAM_TRUE)||(user_trigger_admin_state_lock_unlock_flag == OAM_TRUE))
                    /* SPR Fix 21412 Start_Stop Start */
                    /* SPR Fix 21412 Start_Stop End */
               ){
#ifndef OAM_UT_FRAMEWORK
                ret_val = oam_process_tcb_for_layer_resp(p_api_buf,
                        &trans_id_resp,
                        &dest_id);
                if(OAM_FAILURE == ret_val) {
			OAM_LOG(OAM, OAM_WARNING,
                            "Failure in fetching user request data");
                    ret_val = OAM_FAILURE;
                    break;
                }
#endif
                if(cell_start_resp.response == RRM_SUCCESS) {
                    p_cell_status->cell_event &= ~OAM_USER_TRIGGERED_STOP;
                    usr_resp_code = OAM_RESULT_SUCCESS;
                    usr_err_code = OAM_ZERO;
                    err_str_len =  OAM_ZERO;
                }
                else {
                    usr_resp_code = OAM_RESULT_FAILURE;
                    usr_err_code = cell_start_resp.fail_cause;
                    oam_strncpy(err_str, "Cell Start Fail", sizeof(err_str));
                    err_str_len = oam_strlen(err_str) + 1;
                }
                oam_construct_n_send_set_resp_to_usr(usr_resp_code,
                        usr_err_code,
                        (UInt8*)err_str,
                        err_str_len,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        /* SPR Fix 21412 Start_Stop Start */
                        trans_id_resp,
                        /* SPR Fix 21412 Start_Stop End */
                        OAM_ZERO,
                        OAM_ZERO, &error_code);
                resp_destination_id = OAM_ZERO;
                usr_intf_flag = OAM_FALSE;
                user_trigger_admin_state_lock_unlock_flag = OAM_FALSE;
                /* Spr 10926 Fix End */  
                /* SPR Fix 21412 Start_Stop Start */
                /* SPR Fix 21412 Start_Stop End */
            }
            /* coverity 52805 */	
            index = OAM_ZERO;	

            while(index < oam_prov_req.num_cells_configured) {
                ret_state = OAM_CELL_CURR_STATE(index) & OAM_CELL_ACTIVE;
                index++;
                if(ret_state)
                    break;
            }		 

            if(ret_state)
            {
                oam_prov_req.system_status.op_state = ENODEB_OP_STATE_ENABLED;
                oam_prov_req.system_status.admin_state = ENODEB_ADMIN_STATE_UNLOCKED;
                oam_prov_req.system_status.rftx_status = OAM_TRUE;
            }	
            if(OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode)
            {
                oam_inform_value_change_event(OAM_ZERO,OAM_MODULE_ID,TR069_MODULE_ID);
            }

            OAM_LOG(OAM,OAM_DETAILED,"System state op_state= %d ,admin_state =%d",
                    oam_prov_req.system_status.op_state,oam_prov_req.system_status.admin_state);  

            if(send_config_update_flag == OAM_ONE) {
                oam_update_enb_config_info_from_current_mme_list();
                /* SPR 13542 START */
                if(OAM_SUCCESS == oam_update_s1ap_enb_config())
                {
                    OAM_LOG(OAM, OAM_DETAILED, 
                            "S1AP_ENB_CONFIG has been updated, Sending S1AP_OAM_ENB_CONFIG_UPDATE to L3");

                    oam_s1ap_il_send_s1ap_oam_enb_config_update(
                            /* SPR 15917 START */
                            &local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update,
                            /* SPR 15917 END */
                            OAM_MODULE_ID, RRC_MODULE_ID,
                            oam_get_new_trans_id(), cid);
                }
                /* SPR 13542 END */

                send_config_update_flag = OAM_ZERO;
            }
            /* SPR 11243 Fix start */
            if(p_cell_status->send_initialization_req) { 
                /* SPR 11243 Fix End */
                if(oam_prov_req.oam_rrm_req.enable_load_config) {

                    /* Spr 12715 Fix Start */
                    /* bug_15101_start CID -66663 */
                    /* Coverity 66663 Fix Start */
                    oam_error_code_et p_error_code = NO_ERROR;
                    rrm_oam_load_config_req_t  *p_oam_rrm_load_config_req=OAM_NULL;
                    if(OAM_FAILURE == oam_mem_alloc(sizeof(rrm_oam_load_config_req_t),
                                (void*)&p_oam_rrm_load_config_req,
                                &p_error_code))
                    {     
                        OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to p_oam_rrm_load_config_req failed"
                        " with Error Code:%d",
                                p_error_code);
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }    

                    oam_memset(p_oam_rrm_load_config_req, OAM_ZERO,
                            sizeof(rrm_oam_load_config_req_t));
                    /* Coverity 66663 Fix End */
                    /* bug_15101_end CID -66663 */

                    /* Filling enb Specific Info*/
                    /* Coverity 66663 Fix Start */
                    p_oam_rrm_load_config_req->bitmask =RRM_PROV_REQ.oam_load_config_req.bitmask;
                    p_oam_rrm_load_config_req->ncl_load_ind_intrvl =RRM_PROV_REQ.oam_load_config_req.ncl_load_ind_intrvl;
                    p_oam_rrm_load_config_req->load_rpt_intrvl = RRM_PROV_REQ.oam_load_config_req.load_rpt_intrvl;
                    p_oam_rrm_load_config_req->num_enb_cells = OAM_ONE;
                    p_oam_rrm_load_config_req->load_chk_periodicity = RRM_PROV_REQ.oam_load_config_req.load_chk_periodicity;
                    p_oam_rrm_load_config_req->high_actn_repeat_lmt = RRM_PROV_REQ.oam_load_config_req.high_actn_repeat_lmt;
                    /* SPR 20653 Fix Start */
                    p_oam_rrm_load_config_req->tnl_load_support_flag = RRM_PROV_REQ.oam_load_config_req.tnl_load_support_flag;
                    p_oam_rrm_load_config_req->hw_load_support_flag = RRM_PROV_REQ.oam_load_config_req.hw_load_support_flag;
                    /* SPR 20653 Fix End */
                    /* Coverity 66663 Fix End */


                    /* Filling Cell Specific Info*/
                    for (index= OAM_ZERO; index < RRM_PROV_REQ.oam_load_config_req.num_enb_cells; index++)
                    {
                        if (cid == oam_extract_cid_from_eutran_cellidentity(RRM_PROV_REQ.oam_load_config_req.
                                    serv_enb_cell_info[index].global_cell_id.cell_identity))
                        {
                            /* Coverity 66663 Fix Start */
                            oam_memcpy((void *)&p_oam_rrm_load_config_req->serv_enb_cell_info[0],
                                    /* Coverity 66663 Fix End */
                                    (void *)&oam_prov_req.oam_rrm_req.oam_load_config_req.serv_enb_cell_info[index],
                                    sizeof(rrm_oam_serving_enb_cell_info_t));
                            break;
                        }
                    }

                    ret_val = oam_rrm_send_rrm_oam_load_config_req(
                            /* Coverity 66663 Fix Start */
                            p_oam_rrm_load_config_req,
                            /* Coverity 66663 Fix End */
                            OAM_MODULE_ID, RRM_MODULE_ID,
                            oam_get_new_trans_id(), cid);

                    /* Spr 12715 Fix End */
                    if (OAM_SUCCESS== ret_val) {
                        OAM_LOG(OAM, OAM_INFO,
                                "Successfully sent RRM_OAM_LOAD_CONFIG_REQ");
                    }
                    else {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Failed to send RRM_OAM_LOAD_CONFIG_REQ");
                    }
                    /* Coverity CID 66673 Fix Start */
                    oam_mem_free(p_oam_rrm_load_config_req,&p_error_code);
                    /* Coverity CID 66673 Fix End */
                }
                /*SPR #14531 Fixed Start*/
                /* Code Removed */
                /*SPR #14531 Fixed End*/

                /* SPR-16334 START */
#ifndef OAM_SON_ENABLE
                if(OAM_FALSE == g_flag_add_enb)
                {
                    oam_send_x2ap_enb_config_update_req_first(oam_prov_req.oam_l3_req.peer_enb_data);
                    g_flag_add_enb = OAM_TRUE;
                }
                oam_memset(&local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req,
                        OAM_ZERO,
                        sizeof(oam_x2ap_add_enb_req_t));
                local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.num_peer_enb =
                    oam_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.num_peer_enb;

                oam_memset(&oam_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req,
                        OAM_ZERO,
                        sizeof(oam_x2ap_add_enb_req_t));
                for(index = OAM_ZERO; index< local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.num_peer_enb; index++)
                {
                    oam_memcpy(&local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.enb_info[index],
                            &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[index],
                            sizeof(x2_enb_comm_info_t));

                }

                UInt16 transaction_id = oam_get_new_trans_id();
                if(OAM_SUCCESS == oam_add_x2ap_enb_req(&local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req, transaction_id))
                {
                    OAM_LOG(OAM, OAM_DETAILED, "Successfully sent X2AP_ADD_ENB_REQ");
                }
                else
                {
                    OAM_LOG(OAM, OAM_ERROR, "Failed to send X2AP_ADD_ENB_REQ");
                }
#endif
                /* SPR-16334 END */


                /* SPR 11742 FIX START */
                /* RACH_OPT CHANGES START */

                /* SPR 11791 start */
                /* BCOM Compiltaion Fix */
#ifdef OAM_SON_ENABLE
                oam_memset(&oam_cell_info_ind, OAM_ZERO,
                        sizeof(oam_son_cell_info_ind_t));
                    /*SPR 21702 Start*/
                    oam_memcpy((void *)&oam_cell_info_ind.serving_cell[OAM_ZERO],
                        (void *)&oam_prov_req.oam_son_req.oam_son_cell_info_ind[cid].serving_cell[OAM_ZERO],sizeof(son_cell_t));
                    /*SPR 21702 End*/

                /* SPR 11791 end */
                if (OAM_ONE == oam_prov_req.oam_son_req.rachopt_config.rachopt_enable_disable_flag)
                {
                    /* SPR 11636 Fix Start */
                    son_oam_rach_opt_enable_req_t son_oam_rach_opt_enable_req = {OAM_ZERO};
                    /* SPR 11791 start */
                    oam_memcpy(&son_oam_rach_opt_enable_req.srv_cgi,&oam_cell_info_ind.serving_cell[OAM_ZERO].src_cgi,
                            sizeof(son_intra_rat_global_cell_id_t));
                    son_oam_rach_opt_enable_req.bitmask |= SON_RACH_OPT_ENABLE_SRV_CGI_PRESENT;
                    /* SPR 11791 end */
                    /* SPR 11636 Fix End*/
                    tid=oam_get_new_trans_id();
                    if(OAM_SUCCESS == oam_son_send_son_oam_rach_opt_enable_req(&son_oam_rach_opt_enable_req,
                                OAM_MODULE_ID,
                                SON_MODULE_ID,
                                tid,
                                cid))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_ENABLE_REQ sent Successfully!!");
                        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(tid,OAM_SUB_MODULE_SON,
                                    OAM_TRANS_SON,msg_len,p_api_buf))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            ret_val = OAM_FAILURE;
                        }
#endif
                        /* SPR 9620 CHANGE END */
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_ERROR, "SON_OAM_RACH_OPT_ENABLE_REQ sending Failure");
                    }
                }		
                else if (OAM_ZERO == oam_prov_req.oam_son_req.rachopt_config.rachopt_enable_disable_flag)
                {
                    /* SPR 11636 Fix Start */
                    son_oam_rach_opt_disable_req_t son_oam_rach_opt_disable_req = {OAM_ZERO};
                    /*SPR_11742_FIXED_START */
                    /* SPR 11791 start */
                    oam_memcpy(&son_oam_rach_opt_disable_req.srv_cgi,&oam_cell_info_ind.serving_cell[OAM_ZERO].src_cgi,
                            sizeof(son_intra_rat_global_cell_id_t));
                    son_oam_rach_opt_disable_req.bitmask |= SON_RACH_OPT_DISABLE_SRV_CGI_PRESENT;
                    /* SPR 11791 end */
                    /*SPR_11742_FIXED_END */
                    /* SPR 11636 Fix End*/
                    if(OAM_SUCCESS == oam_son_send_son_oam_rach_opt_disable_req(&son_oam_rach_opt_disable_req,
                                OAM_MODULE_ID,
                                SON_MODULE_ID,
                                oam_get_new_trans_id(),
                                cid))

                    {
                        /* SPR 12049 FIX START */
                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_RACH_OPT_DISABLE_REQ sent Successfully!!");
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_ERROR, "SON_OAM_RACH_OPT_DISABLE_REQ sending Failure");
                        /* SPR 12049 FIX END */
                    }

                }
#endif
                /* BCOM Compiltaion Fix */
                /* SPR 11243 Fix start */
                p_cell_status->send_initialization_req = OAM_FALSE; 
            }
            /* SPR 11243 Fix End */
            /* SPR 11742 FIX END */
            /* RACH_OPT CHANGES END */

            /* BUG 9339 FIXED */


            break;
            /*SPR 11830 FIX START*/
        case RRM_OAM_CELL_STOP_RESP:
            /*SPR 11830 FIX END*/
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                break;
            }
            /* SPR Fix 21412 Start_Stop Start */
            /* SPR Fix 21412 Start_Stop End */

#endif
            /* SPR 9620 CHANGE END */

            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            msg_len -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
            ret_val = oam_parse_rrm_oam_cell_stop_resp(&cell_stop_resp,
                    p_tmp_buf,
                    msg_len,
                    &length_read);
            if(OAM_FAILURE == ret_val) {
		OAM_LOG(OAM, OAM_WARNING, "RRM_OAM_CELL_STOP_RESP Message parsing failed");
                break;
            }


            cid = oam_extract_cid_from_eutran_cellidentity(cell_stop_resp.
                    global_cell_id.cell_identity);

            /*SPR 11830 FIX START*/
            OAM_LOG(OAM, OAM_INFO, "Received RRM_OAM_CELL_STOP_RESP for cell idenetity: %d",
                    cid);
            /*SPR 11830 FIX END*/
            p_cell_status = oam_get_cell_cntxt_status(cid);
            if(!p_cell_status) {
		OAM_LOG(OAM, OAM_WARNING,
                        "RRM_OAM_CELL_STOP_RESP Response for unknown CID is received");
                ret_val = OAM_FAILURE;
                break;
            }  
            if(cell_stop_resp.response == RRM_SUCCESS)
            {
                OAM_LOG(OAM,OAM_INFO, "RRM_OAM_CELL_STOP_RESP Success response received");
                p_cell_status->cell_state |= OAM_CELL_STOP;
                p_cell_status->cell_state &= ~OAM_CELL_ACTIVE;
                p_cell_status->cell_state &= ~OAM_CELL_IDLE;
                /*SPR 14423  FIX START */ 
                if (oam_prov_req.system_status.event_ongoing 
                        & OAM_SET_ADMIN_STATE_RESP_PENDING)
                {
                    oam_prov_req.system_status.admin_state =
                        local_prov_req.system_status.admin_state;

                    oam_prov_req.system_status.event_ongoing &=
                        ~OAM_SET_ADMIN_STATE_RESP_PENDING;
                }
                /*SPR 14423  FIX END */ 
        /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
        ret_val = oam_m2ap_cell_change_state_ind(cid, CELL_STOP);

        if (OAM_SUCCESS == ret_val) 
        {
            OAM_LOG(OAM, OAM_DETAILED,
                    "Successfully sent cell state Change Ind to M2AP");
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Failed to send cell state Change Ind to M2AP");
        }
#endif
        /* EMBMS Changes End */

                /* SPR Fix 21412 Start_Stop Start */
                /* SPR Fix 21412 Start_Stop End */
            }
            /* SPR 14663 Fix Start */
            else
            {
                OAM_LOG(OAM,OAM_DETAILED,"RRM_OAM_STOP_RESP : Failure Resp Received");
            }
            /* SPR 14663 Fix End */

            OAM_LOG(OAM, OAM_INFO, "cell state = %s",
                    (char *)oam_get_cell_state_string(p_cell_status->cell_state));

            if (usr_intf_flag == OAM_TRUE
                    /* SPR Fix 21412 Start_Stop Start */
                    /* SPR Fix 21412 Start_Stop End */
               )
            {
                /*UT BUG FIX for CELL STATE*/
                if(cell_stop_resp.response == RRM_SUCCESS)
                {

                    p_cell_status->cell_event |= OAM_USER_TRIGGERED_STOP;
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL, OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            resp_destination_id,
                            /* SPR Fix 21412 Start_Stop Start */
                            trans_id_resp,
                            /* SPR Fix 21412 Start_Stop End */
                            OAM_ZERO,
                            OAM_ZERO,&error_code);
                    resp_destination_id = OAM_ZERO;
                }
                else
                {
                    OAM_LOG(OAM,OAM_INFO, "RRM_OAM_CELL_STOP_RESP Failure response received");
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            cell_stop_resp.fail_cause, (UInt8 *) "Cell Stop Fail", oam_strlen("Cell Stop Fail")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            resp_destination_id,
                            /* SPR Fix 21412 Start_Stop Start */
                            trans_id_resp,
                            /* SPR Fix 21412 Start_Stop End */
                            OAM_ZERO,
                            OAM_ZERO,&error_code);
                    resp_destination_id = OAM_ZERO;

                }
                usr_intf_flag = OAM_FALSE;
                /* SPR Fix 21412 Start_Stop Start */
                /* SPR Fix 21412 Start_Stop End */
            }
			/* SPR 21738 Fix Start */
			else
			{
				cell_stopped++;
				if(cell_started > OAM_ZERO)
				{
					cell_started--;
				}

				/* Cell Start has been trigerred internally due to S1 Link Up recieved */
				/* Check num of connected mme */
				if((OAM_S1_LINK_UP_SET == flag_for_s1_link)
						&& (cell_stopped == oam_prov_req.num_cells_configured))
				{
					/* S1 Link is active, Send Cell Start Req */
					OAM_LOG(OAM,OAM_INFO,"Sending cell start to rrm as atleast one S1 Link is active");
					if(OAM_FAILURE == oam_start_all_cells(p_api_buf, msg_len))
					{
						OAM_LOG(OAM, OAM_ERROR, "Could not send RRM_OAM_CELL_START_REQ for all cells");
					}
				}
				else if((OAM_S1_LINK_DOWN_SET == flag_for_s1_link)
						&& (cell_stopped == oam_prov_req.num_cells_configured))
				{
					flag_for_s1_link = OAM_NO_S1_LINK_STATUS_SET;
				}

			}
			/* SPR 21738 Fix End */
            /* Spr 10926 Fix Start */  
            if (user_trigger_admin_state_lock_unlock_flag == OAM_TRUE)
            {
                if(cell_stop_resp.response == RRM_SUCCESS)
                    count_cell_statr_rcvd ++; 

                if(count_cell_statr_rcvd == cell_stop_sent_to_lock_admin_state)
                {
                    ret_val = oam_process_tcb_for_layer_resp(p_api_buf,
                            &trans_id_resp,
                            &dest_id);
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL, OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            resp_destination_id,trans_id_resp,OAM_ZERO,
                            OAM_ZERO,&error_code);
                    user_trigger_admin_state_lock_unlock_flag = OAM_FALSE;
                    count_cell_statr_rcvd = OAM_ZERO;
                    cell_stop_sent_to_lock_admin_state = OAM_ZERO; 
                }
                if(cell_stop_resp.response == RRM_FAILURE)  
                {  
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            cell_stop_resp.fail_cause, (UInt8 *) "Fail to lock admin state", 
                            oam_strlen("Fail to lock admin state")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            resp_destination_id,trans_id_resp,OAM_ZERO,
                            OAM_ZERO,&error_code);
                }   

            }
            /* Spr 10926 Fix ENd */  
            index = OAM_ZERO;
            while(index < oam_prov_req.num_cells_configured) 
            {	
                ret_state = OAM_CELL_CURR_STATE(index) & OAM_CELL_STOP;
                index++;
                if(!ret_state)
                    break;
            }		 

            if(ret_state) /* When both cells are in stopped state */
            {	
                oam_prov_req.system_status.op_state = ENODEB_OP_STATE_DISABLED;
                oam_prov_req.system_status.admin_state = ENODEB_ADMIN_STATE_LOCKED;
                /* SPR 14413 Fix Start */ 
                oam_prov_req.system_status.rftx_status = OAM_FALSE; 
                if(OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode)
                {
                    oam_inform_value_change_event(OAM_ZERO,OAM_MODULE_ID,TR069_MODULE_ID);
                }
                /* SPR 14413 Fix End */

            }
            else
            {
                oam_prov_req.system_status.op_state = ENODEB_OP_STATE_ENABLED;
                oam_prov_req.system_status.admin_state = ENODEB_ADMIN_STATE_UNLOCKED;
                oam_prov_req.system_status.rftx_status = OAM_TRUE; 
            }
            OAM_LOG(OAM,OAM_DETAILED,"System state op_state= %d ,admin_state =%d",
                    oam_prov_req.system_status.op_state,oam_prov_req.system_status.admin_state);  

            oam_update_enb_config_info_from_current_mme_list();
            /* SPR 13542 START */
            if(OAM_SUCCESS == oam_update_s1ap_enb_config())
            {
                OAM_LOG(OAM, OAM_DETAILED, 
                        "S1AP_ENB_CONFIG has been updated, Sending S1AP_OAM_ENB_CONFIG_UPDATE to L3");
                oam_s1ap_il_send_s1ap_oam_enb_config_update(
                        /* SPR 15917 START */
                        &local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update,
                        /* SPR 15917 END */
                        OAM_MODULE_ID, RRC_MODULE_ID,
                        oam_get_new_trans_id(), cid);

            }
            /* SPR 13542 END */

            break; 

            /*SPR 11830 FIX START*/
        case RRM_OAM_CELL_DELETE_RESP:
            OAM_LOG(OAM, OAM_INFO, "Received RRM_OAM_CELL_DELETE_RESP");
            /*SPR 11830 FIX END*/

            /* SPR 22356 fix start */
            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                break;
            }
            /* SPR 21412 Fix Start */
    /* SPR 21478 Start */
#endif
            /* SPR 22356 fix end */
            /* SPR 21412 Fix End */
	/* SPR 9620 CHANGE END */
	oam_memset(&cell_delete_resp, OAM_ZERO,
			sizeof(oam_rrm_delete_resp_t));

            p_tmp_buf = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
            length_left = msg_len - LOWER_LAYER_INTERFACE_HEADER_SIZE;

	ret_val =
		oam_parse_rrm_oam_delete_resp(&cell_delete_resp, p_tmp_buf,
				length_left, &length_read);

            if(OAM_FAILURE == ret_val) {
		OAM_LOG(OAM, OAM_WARNING, "RRM_OAM_CELL_DELETE_RESP Parsing failed");
                break;
            }
            cid = oam_extract_cid_from_eutran_cellidentity(cell_delete_resp.
                    global_cell_id.cell_identity);
            UInt8 l2_instance;
            oam_return_et ret_val;
            ret_val = find_l2_instance_id_from_cell_index(cid,&l2_instance) ;
            if(OAM_FAILURE == ret_val)
            {
                OAM_LOG(OAM, OAM_WARNING,"instance id not exist for received cell_idex: [%d]", cid);
                return ret_val;
            }

            if(l2_comm_info[l2_instance].init_flag != OAM_ZERO)
            {
                if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                {
                    OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                    break;
                }
            }
            /* SPR 21478 End */
            /* SPR 9620 CHANGE END */
            /* SPR 21478 +- */
            OAM_LOG(OAM, OAM_INFO, "RRM_OAM_CELL_DELETE_RESP Response rcvd for cell identity: %d!!", cid);
            /* SPR_11955_FIX Start */
#ifdef OAM_SON_ENABLE
            cell_config_idx = oam_get_son_neigh_list_in_use_idx(cid);
            if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                        cid);
                return OAM_FAILURE;
            }
#endif

            /* SPR_11955_FIX END  */

                /* SPR 21412 Fix End */
	p_cell_status = oam_get_cell_cntxt_status(cell_config_idx);

	if(!p_cell_status) {
		OAM_LOG(OAM, OAM_WARNING,
				"RRM_OAM_CELL_DELETE_RESP Response for unknown CID is received");
		ret_val = OAM_FAILURE;
		break;
	}

	if(cell_delete_resp.response == RRM_SUCCESS) {
		/*CELL_SETUP_2.0*/
                /*SPR 21478 Start*/
		p_cell_status->cell_state = OAM_CELL_IDLE;
                /*SPR 21478 End*/
		p_cell_status->cell_event |= OAM_USER_TRIGGERED_STOP;
        /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
        ret_val = oam_m2ap_cell_change_state_ind(cid, CELL_DELETE);

        if (OAM_SUCCESS == ret_val) 
        {
            OAM_LOG(OAM, OAM_DETAILED,
                    "Successfully sent cell state Change Ind to M2AP");
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Failed to send cell state Change Ind to M2AP");
        }
        /* 7.0 OAM_SSI Fix Start */
        if (M2AP_REQ.num_cells_start_received)
        {
            M2AP_REQ.num_cells_start_received--;
        }
        /* 7.0 OAM_SSI Fix End */
#endif
        /* EMBMS Changes End */

		usr_resp_code = OAM_RESULT_SUCCESS;
		usr_err_code = OAM_ZERO;
		err_str_len =  OAM_ZERO;
		OAM_LOG(OAM, OAM_INFO, "RRM_OAM_CELL_DELETE_RESP Success response received. cell state = %s",
				(char *)oam_get_cell_state_string(p_cell_status->cell_state));

#ifdef OAM_SON_ENABLE
                /* SON Cell Delete Support Start*/

        /* SPR 21827 Fix Start */
        /* Code Removed */
        /* SPR 21827 Fix End */

                son_oam_cell_delete_req_t oam_son_cell_del_req = {OAM_ZERO};
		/* SPR 21831 +- */
                        oam_memcpy(&oam_son_cell_del_req.cell_delete_list[OAM_ZERO],
				/* SPR 21831 Start */
				&SON_CELL_INFO_IND_SERVING_CELL(cid).src_cgi,
				/* SPR 21831 End */
                                /* SPR_19838 :Coverity_10477_10427 Fix Start */
                                sizeof(son_intra_rat_global_cell_id_t));
                        /* SPR_19838 :Coverity_10477_10427 Fix Stop */
                        oam_son_cell_del_req.cell_delete_list_size++;
		/* SPR 21831 +- */
                tid=oam_get_new_trans_id(); 
		/* SPR 21831 +- */

                    if(OAM_FAILURE == oam_son_send_son_oam_cell_delete_req(&oam_son_cell_del_req, OAM_MODULE_ID, SON_MODULE_ID
                                ,tid,cid))
                    {   
                        OAM_LOG(OAM, OAM_ERROR, "oam failed to send SON_OAM_CELL_DELETE_REQ");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "Successfully sent SON_OAM_CELL_DELETE_REQ");
                        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(tid,OAM_SUB_MODULE_SON,
                                    OAM_TRANS_SON,msg_len,p_api_buf))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            ret_val = OAM_FAILURE;
                        }
#endif
                        /* SPR 9620 CHANGE END */
                    }
		/* SPR 21831 +- */
                /* SON Cell Delete Support End*/
#endif

            }
            else {
                OAM_LOG(OAM,OAM_INFO, "RRM_OAM_CELL_DELETE_RESP Failure response received");
                usr_resp_code = OAM_RESULT_FAILURE;
                usr_err_code = cell_delete_resp.fail_cause;
                oam_strncpy(err_str, "Cell Delete Fail", sizeof(err_str));
                err_str_len = oam_strlen(err_str) + 1;
            }
            /* SPR 21412 Fix Start */
/*SPR 21369 Start*/
    /* SPR 21478 Start */
    if(l2_comm_info[l2_instance].init_flag != OAM_ZERO)
    {
    /* SPR 21478 End */
                /* SPR 21412 Fix End */
                oam_construct_n_send_set_resp_to_usr(usr_resp_code,
                        usr_err_code,
                        (UInt8*)err_str,
                        err_str_len,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dest_id,
                        /* SPR 21412 Fix Start */
                        trans_id_resp,
                        /* SPR 21412 Fix End */
                        OAM_ZERO,
                        OAM_ZERO, &error_code);
                /* SPR 21412 Fix Start */
            }
            /* SPR 21412 Fix End */
/*SPR 21369 End*/
            /* coverity 41318 */
            index = OAM_ZERO;
            while(index < oam_prov_req.num_cells_configured) 
            {	
                ret_state = OAM_CELL_CURR_STATE(index) & OAM_CELL_IDLE;
                index++;
                if(!ret_state)
                    break;
            }		 

            if(ret_state) /* When both cells are in idle state */
            {	
                oam_prov_req.system_status.op_state = ENODEB_OP_STATE_DISABLED;
                oam_prov_req.system_status.admin_state = ENODEB_ADMIN_STATE_LOCKED;
                oam_prov_req.system_status.cell_setup_complete =  OAM_FALSE;
                oam_prov_req.system_status.rftx_status = OAM_FALSE;
            }
            else
            {
                oam_prov_req.system_status.op_state = ENODEB_OP_STATE_ENABLED;
                oam_prov_req.system_status.admin_state = ENODEB_ADMIN_STATE_UNLOCKED;
            }	
            OAM_LOG(OAM,OAM_DETAILED,"System state op_state= %d ,admin_state =%d",
                    oam_prov_req.system_status.op_state,oam_prov_req.system_status.admin_state);  
            if(OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode)
            {
                oam_inform_value_change_event(OAM_ZERO,OAM_MODULE_ID,TR069_MODULE_ID);
            } 
            oam_update_enb_config_info_from_current_mme_list(); 
            /* Coverity_72203 Fix Start */
            /* Code Removed */
            /* Coverity_72203 Fix End */

            OAM_LOG(OAM, OAM_DETAILED, "S1AP_ENB_CONFIG has been updated, Sending config_update to L3");
            /* SPR 16567 START */
            if (oam_send_enb_config_update() != OAM_SUCCESS)
            {
                OAM_LOG(OAM, OAM_WARNING, "Failed to send enb config update");
            }
            else
            {
                if(OAM_NULL != (oam_prov_req.system_status.timer_id =
                            oam_start_new_timer(OAM_SUB_MODULE_MIH,
                                OAM_MODULE_ID,
                                OAM_ENB_CONFIG_UPDATE_TIMER,
                                OAM_USER_INTF_RESP_TIMEOUT_S * OAM_THOUSAND,
                                p_api_buf,
                                msg_len,
                                OAM_FALSE)))
                { 
            OAM_LOG(OAM,OAM_INFO,"Layers Config Timer started successfully");
                }
            }
            /* SPR 16567 END */
            /* SPR 14118 END */
            /* SPR 13542 START */
            if(OAM_SUCCESS == oam_update_s1ap_enb_config())
            {
                OAM_LOG(OAM, OAM_DETAILED, 
                        "S1AP_ENB_CONFIG has been updated, Sending S1AP_OAM_ENB_CONFIG_UPDATE to L3");

                oam_s1ap_il_send_s1ap_oam_enb_config_update(
                        /* SPR 15917 END */
                        &local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update,
                        /* SPR 15917 END */
                        OAM_MODULE_ID, RRC_MODULE_ID,
                        oam_get_new_trans_id(), cid);
            }
            /* SPR 13542 END */
            /* SPR-16334 START */
#ifndef OAM_SON_ENABLE
            g_flag_add_enb = OAM_FALSE;
#endif
            /* SPR-16334 END */

            break;

        case RRM_OAM_CELL_BLOCK_RESP:
            if(shutdown_flag != OAM_TRUE) {
                oam_rrm_cell_block_resp_t oam_cell_block_resp;
                oam_memset(&oam_cell_block_resp, OAM_ZERO,
                        sizeof(oam_rrm_cell_block_resp_t));
                p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;
                msg_len -= LOWER_LAYER_INTERFACE_HEADER_SIZE;

                ret_val =
                    oam_parse_rrm_oam_cell_block_resp(&oam_cell_block_resp,
                            p_api_buf, msg_len,
                            &length_read);
                if(OAM_SUCCESS == ret_val) {

                    cid = oam_extract_cid_from_eutran_cellidentity(
                            oam_cell_block_resp.global_cell_id.cell_identity);

                    OAM_LOG(OAM, OAM_INFO,
                            "Received RRM_OAM_CELL_BLOCK_RESP for cell identity: %d", cid);


                    p_cell_status = oam_get_cell_cntxt_status(cid);

                    if(!p_cell_status) {
				OAM_LOG(OAM, OAM_WARNING,
                                "RRM_OAM_CELL_BLOCK_RESP Response for unknown CID is received");
                        ret_val = OAM_FAILURE;
                        break;
                    }
                    if(RRM_SUCCESS == oam_cell_block_resp.response) {
                        p_cell_status->cell_state |= OAM_CELL_STOP;
                        p_cell_status->cell_state &=  ~OAM_CELL_IDLE;
                        p_cell_status->cell_state &=  ~OAM_CELL_ACTIVE;
                /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
                ret_val = oam_m2ap_cell_change_state_ind(cid, CELL_BLOCK);

                if (OAM_SUCCESS == ret_val) 
                {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Successfully sent cell state Change Ind to M2AP");
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Failed to send cell state Change Ind to M2AP");
                }
#endif
                /* EMBMS Changes End */

                        p_cell_status->cell_event |= OAM_USER_TRIGGERED_STOP; 
                        ret_val =
                            oam_handle_cell_block_response(&oam_cell_block_resp,
                                    &error_code);
                        if(OAM_SUCCESS == ret_val) {
                            err_str_len = 0;
                            usr_resp_code = OAM_RESULT_SUCCESS;
                            usr_err_code = OAM_ZERO;
                        }
                        else {
                            oam_strncpy(err_str, "Internal error",
                                    sizeof(err_str));
                            err_str_len = oam_strlen(err_str) + 1;
                            usr_resp_code = OAM_RESULT_FAILURE;
                            usr_err_code = OAM_ERR_INTERNAL_ERROR;
                        }
                    }
                    else {
                        /*SPR 20905 Fix Start*/
                        if (oam_cell_block_resp.fail_cause == RRM_ERR_EMERGENCY_CALL_ONGOING)
                        {
                            p_cell_status->cell_state |= OAM_CELL_STOP;
                            p_cell_status->cell_state &=  ~OAM_CELL_IDLE;
                            p_cell_status->cell_state &=  ~OAM_CELL_ACTIVE;
                            p_cell_status->cell_event |= OAM_USER_TRIGGERED_STOP;
                            /* SPR 21152 Fix start*/
                            oam_strncpy(err_str,
                                    "Cell is blocked, emergency call ongoing",
                                    sizeof(err_str));
                        }
                        else
                        {
                            /*SPR 20905 Fix Stop*/
                            oam_strncpy(err_str,
                                    "Failure response received from lower layer",
                                    sizeof(err_str));
                        }
                        /* SPR 21152 Fix stop*/
                        err_str_len = oam_strlen(err_str) + 1;
                        usr_resp_code = OAM_RESULT_FAILURE;
                        usr_err_code = OAM_ERR_INTERNAL_ERROR;
                    }		

                    index = OAM_ZERO;
                    while(index < oam_prov_req.num_cells_configured) 
                    {	
                        ret_state = OAM_CELL_CURR_STATE(index) & OAM_CELL_STOP;
                        index++;
                        if(!ret_state)
                            break;
                    }		 

			if(ret_state) /* When both cells are in idle state */
			{	
				oam_prov_req.system_status.op_state = ENODEB_OP_STATE_DISABLED;
				oam_prov_req.system_status.admin_state = ENODEB_ADMIN_STATE_LOCKED;
			}
			else
			{
				oam_prov_req.system_status.op_state = ENODEB_OP_STATE_ENABLED;
				oam_prov_req.system_status.admin_state = ENODEB_ADMIN_STATE_UNLOCKED;
			}		
			OAM_LOG(OAM, OAM_INFO, "cell state = %s",
					(char *)oam_get_cell_state_string(p_cell_status->cell_state));
			OAM_LOG(OAM,OAM_DETAILED,"System state op_state= %d ,admin_state =%d",
					oam_prov_req.system_status.op_state,oam_prov_req.system_status.admin_state);  
		}
		else {
			OAM_LOG(OAM, OAM_WARNING,
					"Decoding failed for RRM_OAM_CELL_BLOCK_RESP");

			/* Reset Event */
			oam_strncpy(err_str, "Internal error",
					sizeof(err_str));
			err_str_len = oam_strlen(err_str) + 1;
			usr_resp_code = OAM_RESULT_FAILURE;
			usr_err_code = OAM_ERR_INTERNAL_ERROR;
		}
		oam_update_enb_config_info_from_current_mme_list();
		ret_val = oam_s1ap_il_send_s1ap_oam_enb_config_update(
                /* SPR 15917 START */
				&local_prov_req.oam_l3_req.
				oam_s1ap_req.enb_config_update,
                /* SPR 15917 END */
				OAM_MODULE_ID,
				RRC_MODULE_ID,
				oam_get_new_trans_id(),
				cid);
		if(OAM_FAILURE == ret_val) {

			OAM_LOG(OAM,OAM_ERROR,"Failed to send S1AP_OAM_ENB_CONFIG_UPDATE message " );
		}             

                /* RT SPR 9301 FIX - LINES DELETED */

                if(oam_prov_req.system_status.event_ongoing &
                        OAM_RRM_CELL_BLOCK_REQ_MASK) {
                    oam_prov_req.system_status.event_ongoing &=
                        ~OAM_RRM_CELL_BLOCK_REQ_MASK;
                    oam_prov_req.system_status.event_ongoing &=
                        ~OAM_SET_ADMIN_STATE_RESP_PENDING;
                    if(OAM_NULL == tcb_det) {
				OAM_LOG(OAM, OAM_WARNING,
                                "Unable to fetch details from TCB");
                        ret_val =  OAM_FAILURE;
                        break;
                    }
                    else {
                        p_req_msg = tcb_det->oam_tcb_context;
                        trans_id_resp = get_word_from_header(p_req_msg);
                        dest_id = get_word_from_header(p_req_msg + 2);
                        ret_val = oam_stop_timer(tcb_det->timer_id);

                        if(OAM_SUCCESS != ret_val) {
                            OAM_LOG(OAM, OAM_WARNING,
                                    "Error returned while stopping the timer");
                        }
                        else {
                            OAM_LOG(OAM, OAM_INFO, "User request timer stopped");
                        }
                        oam_tcb_delete(&tid);

                        oam_construct_n_send_set_resp_to_usr(usr_resp_code,
                                usr_err_code,
                                (UInt8*)err_str,
                                err_str_len,
                                OAM_VERSION_ID,
                                OAM_MODULE_ID,
                                dest_id,
                                trans_id_resp,
                                OAM_ZERO,
                                OAM_ZERO,
                                &error_code);
                    }
                }
            }
            else {
                oam_rrm_cell_block_resp_t oam_cell_block_resp;
                oam_memset(&oam_cell_block_resp, OAM_ZERO, sizeof(oam_rrm_cell_block_resp_t));
                /* Check Cell block error code Before ShutDown */  
                ret_val = oam_handle_rrm_cell_block_for_shutdown(trans_id,p_api_buf);
                if(OAM_FAILURE == ret_val) {

			OAM_LOG(OAM,OAM_WARNING,"Failed to Handle RRM_OAM_CELL_BLOCK_RESP for Shutdown" );
                    return OAM_FAILURE;
                }             
                if(ret_val == OAM_SUCCESS)
                {
			OAM_LOG(OAM,OAM_INFO,"Received Success RRM_OAM_CELL_BLOCK_RESP for Shutdown" );
                    return OAM_SUCCESS;
                }
                else
                {
                    OAM_LOG(OAM,OAM_DETAILED, "Failed RRM_OAM_CELL_BLOCK_RESP");
                    return OAM_FAILURE;
                }
            }
            break;

        case RRM_OAM_CONFIG_KPI_RESP:
            {
                /*SPR_10579 Start*/
                if (OAM_FAILURE == oam_qcli_send_resp(p_api_buf))
                {
			OAM_LOG(OAM,OAM_WARNING, "Error Handling RRM_OAM_CONFIG_KPI_RESP");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
                /*SPR_10579 End*/

                break;
            } 
            /* FLAG_CHANGES - Code Removed Here */

        case OAM_RRM_GET_KPI_RESP:
            {
                rrm_oam_get_kpi_resp_t rrm_oam_get_kpi_resp;
                SInt32 length_read= OAM_ZERO;
                UInt8 cell_index = (UInt8)(*((UInt8*)(p_api_buf) + OAM_INTF_HDR_CELL_IDX_OFFSET));
                if (cell_index != oam_prov_req.cell_cntxt.curr_cell_cid)
                {
			OAM_LOG(OAM,OAM_WARNING,"Received invalid cell_index %d",cell_index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                {
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
#endif
                if(OAM_SUCCESS == oam_parse_rrm_oam_get_kpi_resp(&rrm_oam_get_kpi_resp,
                            p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_DETAILED, "Successfully parse RRM_OAM_GET_KPI_RESP");
                }

                if(OAM_ZERO == pm_rrm_reset.flag )
                {

                    if( OAM_SUCCESS == oam_handle_rrm_get_kpi_resp(&rrm_oam_get_kpi_resp, 
                                /*SPR 17777 fix*/
                                trans_id_resp,
                                dest_id,
                                &error_code))
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_GET_KPI_RESP Handling :SUCCESS");
                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_GET_KPI_RESP Handling :FAILED");
                    }
                }
                else
                {
                    if ( OAM_SUCCESS == rrm_oam_get_kpi_resp.response )
                    {       
                        OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_GET_KPI_RESP Reset :Success");
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                OAM_ONE,
                                (UInt8*)"Reset RRM KPIs: SUCCESS",oam_strlen("Reset RRM KPIs: SUCCESS")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                &error_code);
                    }       
                    else    
                    {       
                        OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_GET_KPI_RESP Reset :Failed");
                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                OAM_ONE,
                                (UInt8*)"Reset RRM KPIs: FAIL",oam_strlen("Reset RRM KPIs: FAIL")+ OAM_ONE,
                                OAM_VERSION_ID, OAM_MODULE_ID,
                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                &error_code);
                    }        
                }
                break;                  
            }
        case RRM_OAM_KPI_IND:
            {
                UInt8 cell_index = (UInt8)(*((UInt8*)(p_api_buf) + OAM_INTF_HDR_CELL_IDX_OFFSET)) ;
                if (cell_index != oam_prov_req.cell_cntxt.curr_cell_cid)
                {
			OAM_LOG(OAM,OAM_WARNING,"Received invalid cell_index %d",cell_index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                OAM_LOG(OAM, OAM_DETAILED, " RRM_OAM_KPI_IND Receivced Successfully" );
                oam_rrm_kpi_ind_handle(p_api_buf);
            }
            break;

        case RRM_OAM_ENB_CONFIG_RESP:
            OAM_LOG(OAM,OAM_DETAILED, "Received RRM_OAM_ENB_CONFIG_RESP from RRM");
            p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;
            ret_val = oam_cm_fsm_process_event(p_api_buf,
                    p_cm_cntxt,
                    &error_code);
            if (OAM_SUCCESS == ret_val) {
                OAM_LOG(OAM, OAM_INFO,
                        "Successfully Received RRM_OAM_ENB_CONFIG_RESP");
            }
            else {
		OAM_LOG(OAM, OAM_WARNING,
                        "Failed to handle RRM_OAM_ENB_CONFIG_RESP!!!");
            }
            break;
            /*spr 22474 start*/
        case RRM_OAM_GET_DEBUG_INFO_RESP:
            {
                rrm_oam_get_debug_info_resp_t oam_rrm_get_debug_info_resp;
                SInt32 length_read= OAM_ZERO;
                UInt8 **str_arr = OAM_NULL;/* stores the strings[line][text] to be printed */
                UInt8 size_x = OAM_ZERO; /* Counts the number of strings to be printed */
                /* coverity_271490_fix_start */ 
                oam_error_code_et error_code = OAM_PARSE_MSG_DMG;
                /* coverity_271490_fix_start */
                UInt8 cell_index = (UInt8)(*((UInt8*)(p_api_buf) + OAM_INTF_HDR_CELL_IDX_OFFSET));
                if (cell_index != oam_prov_req.cell_cntxt.curr_cell_cid)
                {
                    OAM_LOG(OAM,OAM_ERROR,"Received invalid cell_index %d",cell_index);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
#ifndef OAM_UT_FRAMEWORK
                if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                {
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
#endif
                if(OAM_SUCCESS == oam_parse_rrm_oam_get_debug_info_resp(&oam_rrm_get_debug_info_resp,
                            p_api_buf+LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            msg_len-LOWER_LAYER_INTERFACE_HEADER_SIZE,
                            &length_read))
                {
                    OAM_LOG(OAM, OAM_DETAILED, "Successfully parse RRM_OAM_GET_DEBUG_INFO_RESP");

                    if( OAM_SUCCESS == oam_rrm_get_debug_info_resp.response)
                    {
                        size_x = oam_get_rrm_debug_info_prints(&oam_rrm_get_debug_info_resp,&str_arr);
                        if (size_x)
                        {
                            oam_construct_n_send_gpv_response((UInt8 *)"Debug.Get.RRM", str_arr, size_x,
                                    trans_id_resp, &error_code, dest_id, OAM_ZERO, OAM_ZERO);
                            /* coverity_271490_fix_start */
                            oam_mem_free(str_arr, &error_code);
                            /* coverity_271490_fix_end */
                        }
                        else
                        {
                            OAM_LOG(OAM,OAM_ERROR,"Received error in response from RRM in RRM_OAM_GET_DEBUG_INFO_RESP %u %u",
                                    oam_rrm_get_debug_info_resp.response, size_x);

                            oam_construct_n_send_get_resp_to_usr(
                                    OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR,
                                    OAM_VERSION,
                                    OAM_MODULE_ID,dest_id,
                                    trans_id_resp,
                                    OAM_ZERO,OAM_ZERO,"RRM LAYER FAILURE RESPONSE",
                                    &error_code
                                    );
                        }


                    }
                    else
                    {
                        OAM_LOG(OAM, OAM_ERROR, "Received error in RRM_OAM_GET_DEBUG_INFO_RESP with error code %d",
                                oam_rrm_get_debug_info_resp.fail_cause);
                        oam_construct_n_send_get_resp_to_usr(
                                    OAM_RESULT_FAILURE,
                                    OAM_ERR_INTERNAL_ERROR,
                                    OAM_VERSION,
                                    OAM_MODULE_ID,dest_id,
                                    trans_id_resp,
                                    OAM_ZERO,OAM_ZERO,"RRM LAYER FAILURE RESPONSE",
                                    &error_code
                                    );
                    }
                }
                else
                {
                    OAM_LOG(OAM, OAM_DETAILED, "Failed to parse RRM_OAM_GET_DEBUG_INFO_RESP");
                    oam_construct_n_send_get_resp_to_usr(
                            OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR,
                            OAM_VERSION,
                            OAM_MODULE_ID,dest_id,
                            trans_id_resp,
                            OAM_ZERO,OAM_ZERO,"RRM LAYER FAILURE RESPONSE",
                            &error_code
                            );
                }
                break;					
            }
            /*spr 22474 end*/
        default:
	OAM_LOG(OAM, OAM_WARNING,
                    "Invalid api_id %d received in RRM Msg Handler!!!",
                    api_id);
            ret_val = OAM_FAILURE;
    }

    return ret_val;
    /*CID:56395 end*/
}


/******************************************************************************
 * Function Name  : oam_mac_intf_msg_handler 
 * Inputs         : p_api_buf, api_id,src_module_id, msg_len
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : This function handles MAC functions for OAM
 ******************************************************************************/
oam_return_et 
oam_mac_intf_msg_handler
(
 void *p_api_buf, 
 UInt16 api_id, 
  /*SPR 17777 fix*/
 UInt16 msg_len
 )
{
        /* Coverity_96944 Fix Start */
        oam_error_code_et p_err = OAM_ERR_ATTEMPT_SET_FOR_NON_WRITABLE_PARAM_VAL;
        /* Coverity_96944 Fix End */
/*spr 19296 fix start*/
	UInt16 res_trans_id = get_word_from_header((UInt8*)p_api_buf);
/*spr 19296 fix end*/
	UInt16 trans_id = OAM_ZERO;
	UInt16 dest_id = OAM_ZERO;
	oam_return_et retVal = OAM_SUCCESS;
	OAM_FUN_ENTRY_TRACE();
	/* SPR 9620 CHANGE START */
	UInt16 trans_id_resp = OAM_ZERO;
	trans_id = get_word_from_header((UInt8 *)p_api_buf); 
	/* SPR 9620 CHANGE END */
	switch (api_id)
	{
		case MAC_PROC_SUP_RESP:
			/*SPR 21369 Start*/
            oam_hm_recieved_resp_bitmask_update(p_api_buf);
			/*SPR 21369 End*/
			break;

		case MAC_RESET_STATS_CNF:
#ifndef OAM_UT_FRAMEWORK             
			if(OAM_FAILURE == oam_process_tcb_for_layer_resp(
						p_api_buf,&trans_id,&dest_id))
			{
				OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
				break;
			}
#endif
			/* SPR 9620 CHANGE END */    
			if (OAM_FAILURE == oam_handle_mac_reset_stats_cnf(p_api_buf,trans_id,dest_id))
			{
				OAM_LOG(OAM,OAM_WARNING,"Failure handling MAC_RESET_STATS_CNF");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
		case MAC_INIT_LAYER_IND:
			OAM_LOG(OAM,OAM_DETAILED, "Received MAC_OAM_INIT_IND from MAC");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;

			if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&p_err))
			{
				OAM_LOG(OAM,OAM_DETAILED, "Successfully sent MAC_OAM_INIT_IND to FSM");
			}
			else
			{
				OAM_LOG(OAM,OAM_DETAILED, "Failed to send MAC_OAM_INIT_IND to FSM");
				return OAM_FAILURE;
			}
			break;
		case MAC_INIT_LAYER_CNF:
			OAM_LOG(OAM, OAM_INFO, "Received MAC_INIT_LAYER_CNF from MAC");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;

			retVal = oam_cm_fsm_process_event(p_api_buf, p_cm_cntxt, &p_err);
			if(OAM_SUCCESS == retVal) {
				OAM_LOG(OAM, OAM_INFO, "Successfully sent MAC_INIT_LAYER_CNF to FSM");
			}
			else {
				OAM_LOG(OAM, OAM_WARNING,
						"Failed to send MAC_INIT_LAYER_CNF to FSM");
				retVal = OAM_FAILURE;
			}
			break;

		case MAC_GET_STATS_CNF:
#ifndef OAM_UT_FRAMEWORK
			if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
			{
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
#endif

			if(OAM_FAILURE == oam_handle_mac_get_stats_cnf(
						p_api_buf,
                        /*SPR 17777 fix*/
						trans_id,
						dest_id,
						&p_err))
			{
				OAM_LOG(OAM,OAM_WARNING, "Error Handling MAC_GET_STATS_CNF");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
		case MAC_MODIFY_LAYER_CNF :
			oam_handle_mac_modify_layer_cnf(p_api_buf);
			break;

			/* SPR_12955_FIXES */	
		case MAC_GET_LOG_LEVEL_RESP:
            /*SPR 17777 fix*/
			oam_mac_get_loglevel_resp(p_api_buf);
			break;
		case MAC_GET_LOG_CATEGORY_RESP:
			oam_mac_get_logcategory_resp(p_api_buf,&p_err);
			break;
		case MAC_CONFIGURE_KPI_STATS_CNF:
			if (OAM_FAILURE == oam_qcli_send_resp(p_api_buf))
			{
				OAM_LOG(OAM,OAM_WARNING, 
						"Error Handling MAC_CONFIGURE_KPI_STATS_CNF");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
/*spr 19296 fix start*/
		case MAC_GET_KPI_STATS_CNF:
			{
				UInt8 cell_index = (UInt8) (*((UInt8*) (p_api_buf + OAM_INTF_HDR_CELL_IDX_OFFSET)));
				if(!(cell_index == oam_prov_req.cell_cntxt.curr_cell_cid) &&
						(oam_get_rrm_cell_config_idx(cell_index) == OAM_ERROR_RETURN_VAL)
				  )
				{
					OAM_LOG(OAM, OAM_DETAILED, "Invalid cell_index received from PDCP : %d", cell_index);    
					break;
				}

				if(OAM_ZERO == cli_reset_flag.mac_reset_flag)  
				{
					msg_len = get_word_from_header((U8*)(p_api_buf) + OAM_EIGHT);
					if (OAM_FAILURE == oam_mem_alloc(msg_len,&(oam_mac_direct_stats_hndlr.p_kpi_stats_buf),&p_err))
					{
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to oam_mac_direct_stats_hndlr.p_kpi_stats_buf failed"
								" with Error Code:%d",
								p_err);
						OAM_FUN_EXIT_TRACE();
						/* Not Enough Memory */
						return OAM_FAILURE;
					}
					oam_memcpy(oam_mac_direct_stats_hndlr.p_kpi_stats_buf,p_api_buf,msg_len);

					mac_kpi_info.direct_bit_mask = mac_kpi_info.direct_bit_mask & 0x02;
					if(OAM_ZERO == mac_kpi_info.direct_bit_mask)
					{
						if( ( (g_mac_kpi_stats_ind_params_name.bitmask) & 0x01) ||  ((g_mac_kpi_stats_ind_params_name.bitmask) & 0x02)
								||  ((g_mac_kpi_stats_ind_params_name.bitmask) & 0x04) )
						{
							mac_kpi_info.direct_bit_mask = 0x01;
						}
						if(((g_mac_kpi_stats_ind_params_name.bitmask) & 0x08)  || ((g_mac_kpi_stats_ind_params_name.bitmask) & 0x10))
							mac_kpi_info.direct_bit_mask = mac_kpi_info.direct_bit_mask | 0x02;

						if(OAM_FAILURE == oam_mac_get_kpi_direct_thp_stats_cnf(res_trans_id))
						{
							OAM_LOG(OAM,OAM_WARNING, "Error returned by oam_mac_get_kpi_direct_thp_stats_cnf function");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
						/* SPR 22022 FIXED START */
						else
						{
                            oam_mem_free(oam_mac_direct_stats_hndlr.p_kpi_stats_buf - LOWER_LAYER_INTERFACE_HEADER_SIZE, &p_err);
                        }
					}
					else
					{
						oam_mem_free(oam_mac_direct_stats_hndlr.p_kpi_stats_buf, &p_err);
					}	
					/* SPR 22022 FIXED END */
				}
				else
				{
#ifndef OAM_UT_FRAMEWORK
					if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
					{
						OAM_LOG(OAM,OAM_WARNING, "No TCB Entry Found for MAC_GET_KPI_STATS_CNF");
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
#endif
					cli_reset_flag.mac_reset_flag = OAM_ZERO;

					oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
							OAM_ZERO,OAM_NULL,OAM_ZERO,
							OAM_VERSION_ID, OAM_MODULE_ID,
							dest_id, trans_id, OAM_ZERO, OAM_ZERO,
							&p_err);
				}
				break;
			}

		case MAC_GET_KPI_THP_STATS_CNF:
			{
				/*SPR 10023 FIX*/
				/*
				 * Description: fn oam_handle_get_mac_thp_batch_data adds all the batches of
				 * API MAC_GET_KPI_THP_STATS_CNF to link list. This if condition will be hit
				 * when endIndicator received is "1"
				 */
					OAM_LOG(OAM,OAM_DETAILED,"Inside case MAC_GET_KPI_THP_STATS_CNF \n");
				if (oam_handle_get_mac_thp_batch_data(p_api_buf, &p_err) == OAM_SUCCESS)
				{
					OAM_LOG(OAM,OAM_INFO,"received MAC_GET_KPI_THP_STATS_CNF with"
							" endIndicator 1");

					mac_kpi_info.direct_bit_mask = mac_kpi_info.direct_bit_mask & 0x01;
					if(OAM_ZERO == mac_kpi_info.direct_bit_mask)
					{

						if( ( (g_mac_kpi_stats_ind_params_name.bitmask) & 0x01) ||  ((g_mac_kpi_stats_ind_params_name.bitmask) & 0x02)
								||  ((g_mac_kpi_stats_ind_params_name.bitmask) & 0x04) )
						{
							mac_kpi_info.direct_bit_mask = 0x01;
						}
						if(((g_mac_kpi_stats_ind_params_name.bitmask) & 0x08)  || ((g_mac_kpi_stats_ind_params_name.bitmask) & 0x10))
							mac_kpi_info.direct_bit_mask = mac_kpi_info.direct_bit_mask | 0x02;

						if(OAM_FAILURE == oam_mac_get_kpi_direct_thp_stats_cnf(res_trans_id))
						{
							OAM_LOG(OAM,OAM_WARNING, "Error returned by oam_mac_get_kpi_direct_thp_stats_cnf function");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}        
						/* SPR_12955_FIXES */	
						/*SPR 10023 FIX*/

					}
				}
				/*SPR 10023 FIX*/
				/*
				 * Description: This else condition will be hit when endIndicator received is "0".
				 */
				else
				{
					OAM_LOG(OAM,OAM_INFO,"received MAC_GET_KPI_THP_STATS_CNF with"
							" endIndicator 0");
				}
				/*SPR 10023 FIX*/
				break;
			}

/*spr 19296 fix end*/
/*spr 19296 fix start*/
		case MAC_KPI_THP_STATS_IND:
/*spr 19296 fix end*/
		case MAC_KPI_STATS_IND:
			if(OAM_FAILURE == oam_mac_handle_kpi_inds(p_api_buf))
			{
				OAM_LOG(OAM,OAM_WARNING,"Error handling MAC_KPI_STATS_IND");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
			/* CSR_00057386 */
		case MAC_GET_STATUS_CNF:
			OAM_LOG(OAM,OAM_DETAILED, "MAC_GET_STATUS_CNF Received");
			if(OAM_FAILURE == oam_mac_get_ue_status_resp(p_api_buf, &p_err))
			{
				OAM_LOG(OAM,OAM_WARNING,"Error handling MAC_GET_STATUS_CNF");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
		case MAC_UE_SINR_TA_RESP:
			OAM_LOG(OAM,OAM_DETAILED, "Received MAC_UE_SINR_TA_RESP");

			/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
			if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
			{
				OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
				break;
			}
#endif
			/* SPR 9620 CHANGE END */


			if(OAM_FAILURE == oam_mac_get_mac_ue_sinr_ta_resp(p_api_buf,&p_err))
			{
				OAM_LOG(OAM,OAM_WARNING,"Error handling MAC_UE_SINR_TA_RESP");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
		case MAC_OAM_STARTPHY_IND :

			OAM_LOG(OAM,OAM_DETAILED, "MAC_OAM_STARTPHY_IND  Received");
			if(OAM_ZERO == OAM_NMM_PRESENCE_FLAG)
			{
				UInt16 trans_id = oam_get_new_trans_id();
				oam_send_mac_start_phy_cnf(OAM_MODULE_ID,trans_id,&p_err);
			}
			break;

		case MAC_INIT_CELL_CNF:
			p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;

			retVal = oam_cm_fsm_process_event(p_api_buf, p_cm_cntxt, &p_err);
			if(OAM_SUCCESS == retVal) {
				OAM_LOG(OAM, OAM_INFO,
						"MAC_INIT_CELL_CNF successfully handled by FSM");
			}
			else {
				OAM_LOG(OAM, OAM_INFO,
						"Failed to handle MAC_INIT_CELL_CNF by FSM");
				retVal = OAM_FAILURE;
			}
			break;
        /*spr 22474 start*/
        case MAC_OAM_GET_DEBUG_INFO_RESP:
        {
		OAM_LOG(OAM,OAM_DETAILED,"MAC_OAM_GET_DEBUG_INFO_RESP received from MAC");
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
            {
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
#endif
            if(OAM_FAILURE == oam_handle_mac_get_debug_info_cnf(
                        p_api_buf,
                        trans_id,
                        dest_id,
                        &p_err))
            {
                /* Need to confirm if some indication need to be sent to CLI */
                OAM_LOG(OAM,OAM_ERROR, "Error Handling MAC_OAM_GET_DEBUG_INFO_RESP:%u", p_err);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            break;
        }
        /*spr 22474 end*/

		default:
			OAM_LOG(OAM, OAM_WARNING,
					"Invalid api_id %d received in MAC Msg Handler!!!", api_id);
			retVal = OAM_FAILURE;
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/******************************************************************************
 * Function Name  : oam_rlc_intf_msg_handler 
 * Inputs         : p_api_buf, api_id,msg_len
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/

oam_return_et 
oam_rlc_intf_msg_handler
(
 void *p_api_buf,
 UInt16 msg_len, 
 UInt16 api_id
 )
{
	  /* Coverity_96942 Fix Start */
        oam_error_code_et p_err = OAM_ERR_ATTEMPT_SET_FOR_NON_WRITABLE_PARAM_VAL;
         /* Coverity_96942 Fix End */

	UInt16 trans_id = OAM_ZERO;
	UInt16 dest_id = OAM_ZERO;
	OAM_FUN_ENTRY_TRACE();


	OAM_LOG(OAM,OAM_DETAILED,"Entering oam_rlc_intf_msg_handler...");
	switch (api_id)
	{
		case RLC_PROC_SUP_RESP:
			/*SPR 21369 Start*/
            oam_hm_recieved_resp_bitmask_update(p_api_buf);
			/*SPR 21369 End*/
			break;

		case RLC_RESET_STATS_CNF:
			if(OAM_FAILURE == oam_handle_rlc_reset_stats_cnf(p_api_buf))
			{
				OAM_LOG(OAM,OAM_WARNING, "Failed to handle RLC_RESET_STATS_CNF");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
		case RLC_INIT_LAYER_IND:
			OAM_LOG(OAM,OAM_DETAILED, "Received RLC_INIT_LAYER_IND from l2");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;
			p_cm_cntxt->event= OAM_CM_EV_LAYER_REQ;

			if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&p_err))
			{
				OAM_LOG(OAM,OAM_DETAILED, "Successfully sent RLC_INIT_LAYER_REQ to FSM");
			}
			else
			{
				OAM_LOG(OAM,OAM_DETAILED, "Failed to send RLC_INIT_LAYER_REQ to FSM");
				return OAM_FAILURE;
			}
			break;
		case RLC_INIT_LAYER_CNF:
			OAM_LOG(OAM,OAM_DETAILED, "Received RLC_INIT_LAYER_CNF from l2");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;
			p_cm_cntxt->event= OAM_CM_EV_LAYER_RES;

			if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&p_err))
			{
				OAM_LOG(OAM,OAM_DETAILED, "Successfully sent RLC_INIT_LAYER_CNF to FSM");
			}

			else
			{
				OAM_LOG(OAM,OAM_DETAILED, "Failed to send RLC_INIT_LAYER_CNF to FSM");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;

		case RLC_GET_LOG_CATEGORY_RESP:
			if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
			{
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			oam_rlc_get_logcategory_resp(p_api_buf,msg_len,trans_id,dest_id,&p_err);
			break;
			/********************************PM_CODE**************************************/
		case RLC_GET_STATS_CNF:
			OAM_LOG(OAM,OAM_DETAILED, "RLC_GET_STATS_CNF  Received");
			if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
			{
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
            /*SPR 17777 fix*/
			if(OAM_FAILURE == oam_handle_rlc_get_stats_cnf(p_api_buf,trans_id,dest_id,&p_err))
			{
				OAM_LOG(OAM,OAM_WARNING, "Failed to handle RLC_GET_STATS_CNF");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
        case RLC_GET_LOG_LEVEL_RESP:
            /*SPR 17777 fix*/
            oam_rlc_get_loglevel_resp(p_api_buf); 
            break;

			/********************************PM_CODE**************************************/
        /*spr 22474 start*/
        case RLC_OAM_GET_DEBUG_INFO_RESP:
        {
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
            {
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
#endif

            if(OAM_FAILURE == oam_handle_rlc_get_debug_info_cnf(
                        p_api_buf,
                        trans_id,
                        dest_id,
                        &p_err))
            {
                OAM_LOG(OAM,OAM_ERROR, "Error Handling RLC_OAM_GET_DEBUG_INFO_RESP:%u", p_err);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            break;
        }
        /*spr 22474 end*/
		default:
			{
				OAM_LOG(OAM,OAM_WARNING,"Invalid api_id %d received in rlc Msg Handler!!!",api_id );
				return OAM_FAILURE;
			}


	}
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}

/******************************************************************************
 * Function Name  : oam_pdcp_intf_msg_handler 
 * Inputs         : p_api_buf, api_id
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et 
oam_pdcp_intf_msg_handler
(
 void *p_api_buf,
 UInt16 api_id
 )
{
	UInt16 msg_len = OAM_ZERO;
	oam_error_code_et p_err =NO_ERROR;
	UInt16 trans_id = OAM_ZERO;
	UInt16 dest_id = OAM_ZERO;
	OAM_FUN_ENTRY_TRACE();
	/* Spr 12880 Fix Start*/
	UInt8 CellId = OAM_INVALID_CELL_ID;
	/* Spr 12880 Fix End*/
    /* SPR 17883 fix start */
    UInt16 transaction_id = OAM_ZERO;
    /* SPR 17883 fix end */
	OAM_LOG(OAM,OAM_DETAILED,"Entering oam_pdcp_intf_msg_handler...");
	switch (api_id)
	{
		case PDCP_PROC_SUP_RESP:
			/*SPR 21369 Start*/
            oam_hm_recieved_resp_bitmask_update(p_api_buf);
			/*SPR 21369 End*/
			break;

		case PDCP_RESET_STATS_CNF:
			if(OAM_FAILURE == oam_handle_pdcp_reset_stats_cnf(p_api_buf))
			{
				OAM_LOG(OAM,OAM_WARNING, "Error handling PDCP_RESET_STATS_CNF");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;

		case PDCP_INIT_LAYER_IND:
			OAM_LOG(OAM,OAM_DETAILED, "Received PDCP_INIT_LAYER_IND from l2");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;

			if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&p_err))
			{
				OAM_LOG(OAM,OAM_DETAILED, "Successfully sent PDCP_INIT_LAYER_REQ to FSM");
			}
			else
			{
				OAM_LOG(OAM,OAM_DETAILED, "Failed to send PDCP_INIT_LAYER_REQ to FSM");
				return OAM_FAILURE;
			}
			break;
		case PDCP_INIT_LAYER_CNF:
			OAM_LOG(OAM,OAM_DETAILED, "Received PDCP_INIT_LAYER_CNF from l2");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;
			if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&p_err))
			{
				OAM_LOG(OAM,OAM_DETAILED, "Successfully sent PDCP_INIT_LAYER_CNF to FSM");
                /* SPR 22925 Fix + */
                oam_return_et retVal = OAM_SUCCESS;
                oam_rrm_cell_config_req_t *p_rrm_cell_config = OAM_NULL;
                /*SPR_15574 Fix Start*/
#ifdef OAM_SON_ENABLE
                if((oam_prov_req.system_status.is_nmm_enabled) &&
                        (OAM_FALSE == oam_prov_req.oam_tr069_req.connect_to_iHeMS) &&
                        (OAM_FALSE == g_oam_nmm_scan_first_time))
                {
                    OAM_LOG(OAM, OAM_DETAILED, "NMM is enabled, sending SON_OAM_SET_NW_SCAN_CONFIG_CMD");
                    oam_son_send_son_oam_set_nw_scan_config_cmd(
                            &oam_prov_req.oam_son_req.nw_scan_config,
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            oam_get_new_trans_id(),
                            oam_prov_req.cell_cntxt.curr_cell_cid);

                }
                /* Trigger ICIC feature when eNodeB is not connected to iHeMS */
                /*+ SPR 18390*/
                OAM_LOG(OAM,OAM_DETAILED, "earfcn_list_size %d pci_list_size %d scan_on_boot %d,is_nmm_enabled %d ",
                        oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.earfcn_list_size,
                        oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list_size,
                        oam_prov_req.oam_son_req.temp_values.scan_on_boot,
                        oam_prov_req.system_status.is_nmm_enabled);
                /* Start: CSR 00058940 */                
                if (OAM_ONE < oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.earfcn_list_size)
                {
                    /*End: CSR 00058940 */                        
                    /*son career freq dl tx req*/

                    if (OAM_SUCCESS ==
                            oam_son_send_son_oam_carrier_freq_and_dl_tx_power_req(
                                &oam_prov_req.oam_son_req.
                                earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req,
                                OAM_MODULE_ID,
                                SON_MODULE_ID,
                                oam_get_new_trans_id(),
                                oam_prov_req.cell_cntxt.curr_cell_cid))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "successfully sent SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_REQ");
                        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                        /* SPR 18540 FIX START*/
                        oam_prov_req.system_status.event_ongoing |= OAM_SON_CARRIER_FREQ_ONGOING;
                        /* SPR 18540 FIX END*/
                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(oam_get_new_trans_id(),OAM_SUB_MODULE_SON,
                                    OAM_TRANS_SON,msg_len,p_api_buf))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                            return OAM_FAILURE;
                        }
                        /*- SPR 18390*/
#endif
                        /* SPR 9620 CHANGE END */
                    }
                    else
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "Failed to send SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_REQ");
                        /* Start: CSR 00058940 */
                        return OAM_FAILURE;
                    }
                }
                /*+ SPR 18393*/
                /* Spr 17753 Changes Start */

                else if ((OAM_ONE < oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list_size) &&
                        (OAM_TRUE == oam_prov_req.system_status.is_nmm_enabled))
                    /* Spr 17753 Changes End */
                {
                    initialisation_flag |= INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK;
                    if (OAM_ONE < oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list_size)
                    {
                        if(OAM_SUCCESS == \
                                oam_son_send_son_oam_pci_selection_req(&(oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req),
                                    OAM_MODULE_ID, SON_MODULE_ID, trans_id, oam_prov_req.cell_cntxt.curr_cell_cid))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_SELECTION_REQ sent Successfully!!");
                            /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                            if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                                        OAM_TRANS_SON,msg_len,p_api_buf))
                            {
                                OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                                /* Coverity_99557 Fix Start */
                                return  OAM_FAILURE;
                                /* Coverity_99557 Fix End */
                            }
#endif
                            /* SPR 9620 CHANGE END */
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_SELECTION_REQ sent Failure");
                            return OAM_FAILURE;
                        }
                    }
                    else
                    {
                        initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;
                    }
                }

                /*check if scan_on_boot is enabled then trigger NW scan*/
                else if((OAM_TRUE == oam_prov_req.oam_son_req.temp_values.scan_on_boot) &&
                        (OAM_TRUE == oam_prov_req.system_status.is_nmm_enabled))
                    /*SPR_16048 Fix End*/
                {
                    initialisation_flag |= INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK;
                    initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;

                    /*SPR_16636 Fix start*/
                    if(OAM_TRUE == oam_prov_req.oam_igd_params.rem_lte_params.scan_periodically)
                    {
                        if(OAM_SUCCESS == \
                                oam_son_send_son_oam_periodic_nw_scan_req(&(oam_prov_req.oam_son_req.periodic_nw_scan),
                                    OAM_MODULE_ID,SON_MODULE_ID,oam_get_new_trans_id(),OAM_ZERO))
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "\nnSON_OAM_PERIODIC_NW_SCAN_REQ sent Successfully!!");
                        }
                        else
                        {
                            OAM_LOG(OAM, OAM_DETAILED, "\nnSON_OAM_PERIODIC_NW_SCAN_REQ sent Failure");
                            return OAM_FAILURE;
                        }
                    }
                    else
                    {
                        /*SPR_16636 Fix end*/
                        if(OAM_SUCCESS == \
                                oam_son_send_son_oam_nw_scan_req(&(oam_prov_req.oam_son_req.nw_scan),
                                    OAM_MODULE_ID,SON_MODULE_ID,oam_get_new_trans_id(),OAM_ZERO))
                        {
                            OAM_LOG(OAM,OAM_DETAILED, "\nSON_NW_SCAN_REQ sent Successfully");
                        }
                        else
                        {
                            OAM_LOG(OAM,OAM_ERROR, "\nSON_NW_SCAN_REQ sent Failuer");
                        }
                        /*SPR_16636 Fix start*/
                    }
                    /*SPR_16636 Fix end*/
                }

                /*SPR_15770 Fix end*/
                /* SPR 20788 FIXED START */           
                else if(((OAM_ZERO == oam_prov_req.oam_tr069_req.tr069_mode) &&
                            (ENODEB_ADMIN_STATE_UNLOCKED == oam_prov_req.system_status.admin_state)) || 
                        ((ENODEB_ADMIN_STATE_LOCKED == oam_prov_req.system_status.admin_state) && 
                         (ENODEB_ADMIN_STATE_UNLOCKED == local_prov_req.system_status.admin_state))|| 
                        ((ENODEB_ADMIN_STATE_UNLOCKED == oam_prov_req.system_status.admin_state) &&
                         (ENODEB_ADMIN_STATE_UNLOCKED == local_prov_req.system_status.admin_state)&&                                                                                   (OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode)))
                {
                    OAM_LOG(OAM, OAM_INFO, "lock-unlock unlock-unlock");
                    /* SPR 20788 FIXED END */            
                    initialisation_flag |= INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK;
                    initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;

                    if ((LOWER_LAYERS_PROVISIONING_MASK & initialisation_flag) &&
                            (INIT_TIME_PCI_SELECTION_MASK & initialisation_flag) &&
                            (INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK & initialisation_flag))
                    {                
                        init_time_startup = OAM_ZERO;   
                        UInt16    gen_trans_id = OAM_ZERO;
                        UInt8 cell_cnt = OAM_ZERO;
                        for (cell_cnt = OAM_ZERO;cell_cnt < oam_prov_req.num_cells_configured; ++cell_cnt) {
                            p_rrm_cell_config = &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_cnt];

                            /*SPR 20908 Start*/
                            /*SPR 21206 Start*/ 
                            if(/*(l2_comm_info[p_rrm_cell_config->operator_info.associated_layer2_inst].init_flag & EGTPU_OAM_INIT_CNF)
                                    &&*/(l2_comm_info[p_rrm_cell_config->operator_info.associated_layer2_inst].init_flag & MAC_OAM_INIT_CNF)
                                    &&(l2_comm_info[p_rrm_cell_config->operator_info.associated_layer2_inst].init_flag & RLC_OAM_INIT_CNF )
                                    &&(l2_comm_info[p_rrm_cell_config->operator_info.associated_layer2_inst].init_flag & PDCP_OAM_INIT_CNF))
                            {
                                /*SPR 21206 End*/
                                OAM_LOG(OAM, OAM_DETAILED, "Sending Cell Config to RRM for cell index  %d",cell_cnt);
                                retVal =
                                    oam_handle_initial_admin_state_unlocked((UInt8 *)INVALID_ARGUMENT,p_rrm_cell_config,
                                            &gen_trans_id);
                            }
                            else
                            {
                                OAM_LOG(OAM, OAM_DETAILED, "INIT not received from all l2 sub modules for cell index = %d",cell_cnt);
                            }
                            /*SPR 20908 End*/
                            /*Coverity_99556 Fix Start */
                            if(OAM_FAILURE == retVal)
                            {
                                OAM_LOG(OAM,OAM_ERROR, "Failed in oam_handle_initial_admin_state_unlocked");
                                return OAM_FAILURE; 
                            }
                            /* Coverity_99556 Fix End */
                        }
                    }
                }
                /*- SPR 18393*/
#endif
                /*SPR_15574 Fix End*/ 
                /* SPR 22925 Fix - */
			}
			else
			{
				OAM_LOG(OAM,OAM_DETAILED, "Failed to send PDCP_INIT_LAYER_CNF to FSM");
				return OAM_FAILURE;
			}
			break;

		case PDCP_GET_KPI_STATS_RESP:
			{
				/*SPR 12754 FIX: code removed*/
				/*SPR 12511 FIX: code removed*/
				UInt8 cell_index = (UInt8) (*((UInt8*) (p_api_buf + OAM_INTF_HDR_CELL_IDX_OFFSET)));
				/* SPR_11231_START */
				if(!(cell_index == oam_prov_req.cell_cntxt.curr_cell_cid) &&
						(oam_get_rrm_cell_config_idx(cell_index) == OAM_ERROR_RETURN_VAL)
				  )
				{
					OAM_LOG(OAM, OAM_DETAILED, "Invalid cell_index received from PDCP : %d", cell_index);    
					break;
				}
				/* SPR_11231_END*/

				if(OAM_ZERO == cli_reset_flag.pdcp_reset_flag)  
				{
					msg_len = get_word_from_header((U8*)(p_api_buf) + OAM_EIGHT);
					if (OAM_FAILURE == oam_mem_alloc(msg_len,&(oam_pdcp_direct_stats_hndlr.p_kpi_stats_buf),&p_err))
					{
						OAM_LOG(OAM, OAM_WARNING,
								"Memory allocation to oam_pdcp_direct_stats_hndlr.p_kpi_stats_buf failed"
								" with Error Code:%d",
								p_err);
						OAM_FUN_EXIT_TRACE();
						/* Not Enough Memory */
						return OAM_FAILURE;
					}
					oam_memcpy(oam_pdcp_direct_stats_hndlr.p_kpi_stats_buf,p_api_buf,msg_len);

					pdcp_kpi_info.direct_bit_mask = pdcp_kpi_info.direct_bit_mask & 0x02;
                    /* SPR 17883 fix start */
                    transaction_id = get_word_from_header((U8*)(p_api_buf) + OAM_TRANSACTION_ID);
                    /* SPR 17883 fix end */
					if(OAM_ZERO == pdcp_kpi_info.direct_bit_mask)
					{
						if( ( (g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x01) ||  ((g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x02)
								||  ((g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x04) )
						{
							pdcp_kpi_info.direct_bit_mask = 0x01;
						}
						if(((g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x08)  || ((g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x10))
							pdcp_kpi_info.direct_bit_mask = pdcp_kpi_info.direct_bit_mask | 0x02;

                        /* SPR 17883 fix start */
						if(OAM_FAILURE == oam_pdcp_get_kpi_direct_thp_stats_cnf(transaction_id))
                        /* SPR 17883 fix end */
						{
							OAM_LOG(OAM,OAM_WARNING, "Error returned by oam_pdcp_get_kpi_direct_thp_stats_cnf function");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
						/* SPR 22022 FIXED START */
						else
						{
							oam_mem_free(oam_pdcp_direct_stats_hndlr.p_kpi_stats_buf - LOWER_LAYER_INTERFACE_HEADER_SIZE, &p_err);
						}
					}
					else {
						oam_mem_free(oam_pdcp_direct_stats_hndlr.p_kpi_stats_buf, &p_err);
					}
					/* SPR 22022 FIXED END */
				}
				else
				{
#ifndef OAM_UT_FRAMEWORK
					if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
					{
						OAM_LOG(OAM,OAM_WARNING, "No TCB Entry Found for PDCP_GET_KPI_STATS_RESP:");
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
#endif
					cli_reset_flag.pdcp_reset_flag = OAM_ZERO;

					oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
							OAM_ZERO,OAM_NULL,OAM_ZERO,
							OAM_VERSION_ID, OAM_MODULE_ID,
							dest_id, trans_id, OAM_ZERO, OAM_ZERO,
							&p_err);
				}
				break;
			}

		case PDCP_GET_KPI_THP_STATS_RESP:
			{
				/*SPR 10023 FIX*/
				/*
				 * Description: fxn oam_handle_get_pdcp_thp_batch_data adds all the batches of
				 * API PDCP_GET_KPI_THP_STATS_CNF to link list. This if condition will be hit
				 * when endIndicator received is "1"
				 */
				if (oam_handle_get_pdcp_thp_batch_data(p_api_buf, &p_err) == OAM_SUCCESS)
				{
					OAM_LOG(OAM,OAM_INFO,"received PDCP_GET_KPI_THP_STATS_CNF with"
							" endIndicator 1");
					/*SPR 10023 FIX: removed code*/

					pdcp_kpi_info.direct_bit_mask = pdcp_kpi_info.direct_bit_mask & 0x01;
                    /* SPR 17883 fix start */
                    transaction_id = get_word_from_header((U8*)(p_api_buf) + OAM_TRANSACTION_ID);
                    /* SPR 17883 fix end */
					if(OAM_ZERO == pdcp_kpi_info.direct_bit_mask)
					{

						if( ( (g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x01) ||  ((g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x02)
								||  ((g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x04) )
						{
							pdcp_kpi_info.direct_bit_mask = 0x01;
						}
						if(((g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x08)  || ((g_pdcp_kpi_stats_ind_params_name.bitmask[OAM_ZERO]) & 0x10))
							pdcp_kpi_info.direct_bit_mask = pdcp_kpi_info.direct_bit_mask | 0x02;

						/*SPR 10023 FIX*/
						/* SPR_12955_FIXES */	
                        /* SPR 17883 fix start */
						if(OAM_FAILURE == oam_pdcp_get_kpi_direct_thp_stats_cnf(transaction_id))
                        /* SPR 17883 fix end */
						{
							OAM_LOG(OAM,OAM_WARNING, "Error returned by oam_pdcp_get_kpi_direct_thp_stats_cnf function");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}        
						/* SPR_12955_FIXES */	
						/*SPR 10023 FIX*/

					}
				}
				/*SPR 10023 FIX*/
				/*
				 * Description: This else condition will be hit when endIndicator received is "0".
				 */
				else
				{
					OAM_LOG(OAM,OAM_INFO,"received PDCP_GET_KPI_THP_STATS_CNF with"
							" endIndicator 0");
				}
				/*SPR 10023 FIX*/
				break;
			}
		case  PDCP_NOTIFY_OAM_DEVICE_FAILURE:
			OAM_ALARM(OAM_PDCP_SECURITY_ENGINE_ERROR_ALARM_ID, OAM_ZERO,
					NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
					UNAVAILABLE, EXPEDITED_ALARM,
					/* Spr 12880 Fix Start*/
					"L2 Device Failure", OAM_NULL,CellId);
			/* Spr 12880 Fix End*/
			break;
		case PDCP_GET_LOG_CATEGORY_RESP:
            /*SPR 17777 fix*/
            /*SPR 19771 FIXED START*/
			oam_pdcp_get_logcategory_resp(p_api_buf ,&p_err);
            /*SPR 19771 FIXED END*/
			break;
		case PDCP_CONFIGURE_KPI_STATS_RESP:
			if(OAM_FAILURE == oam_qcli_send_resp(p_api_buf))
			{
				OAM_LOG(OAM, OAM_WARNING, "Failure in handling api_id:%d",api_id);
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
        case PDCP_GET_LOG_LEVEL_RESP:
            /*SPR 17777 fix*/
            oam_pdcp_get_loglevel_resp(p_api_buf); 
            break;
			/********************************PM_CODE**************************************/
			/* SPR 14019 FIX Start */
#ifdef PERF_STATS
			/* SPR 14019 FIX End */
		case PDCP_CONFIGURE_PERF_STATS_CNF:
			if(OAM_FAILURE == oam_pm_handle_pdcp_config_perf_stats_cnf(p_api_buf))
			{
				OAM_LOG(OAM, OAM_WARNING, "Failure in handling api_id:%d",api_id);
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;
			/* SPR 14019 FIX Start */
#endif
			/* SPR 14019 FIX End */
		case PDCP_KPI_THP_STATS_IND:
		case PDCP_KPI_STATS_IND:
			if (OAM_FAILURE == oam_pdcp_handle_kpi_inds(p_api_buf))
			{
				OAM_LOG(OAM, OAM_WARNING, "Failure in handling api_id:%d",api_id);
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			break;           
		case PDCP_GET_STATS_RESP:
            {
                OAM_LOG(OAM,OAM_DETAILED, "PDCP_GET_STATS_RESP  Received");
                /*SPR 20870 +*/
                oam_pdcp_stats_cnf_t *p_pdcp_stats_resp = OAM_NULL;
                UInt8 *temp_buf = OAM_NULL;
                temp_buf            = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
                p_pdcp_stats_resp    = (oam_pdcp_stats_cnf_t*)temp_buf;
                if(p_pdcp_stats_resp->UesLeft == 0)
                {
                    if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
                    {
                        OAM_LOG(OAM,OAM_WARNING, "No TCB Entry Found for PDCP_GET_STATS_RESP");
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                }
                /*SPR 20870 -*/
                /*SPR 17777 fix*/
                if (oam_handle_pdcp_get_stats_cnf(p_api_buf,trans_id,dest_id,&p_err) == OAM_FAILURE)
                {
                    OAM_LOG(OAM,OAM_WARNING, "Failure handling PDCP_GET_STATS_RESP");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
            }
			break;

			/* SPR 14019 FIX Start */
#ifdef PERF_STATS
			/* SPR 14019 FIX End */
		case PDCP_GET_CELL_PERF_STATS_CNF:
		case PDCP_GET_UE_PERF_STATS_CNF:

			OAM_LOG(OAM, OAM_DETAILED,"Either PDCP_GET_CELL_PERF_STATS_CNF or PDCP_GET_UE_PERF_STATS_CNF received");
			if (OAM_FAILURE == oam_qcli_send_resp(p_api_buf))
			{
				OAM_LOG(OAM,OAM_WARNING, "Error Handling MAC_CONFIGURE_KPI_STATS_CNF");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}

			break;
			/* SPR 14019 FIX Start */
#endif
			/* SPR 14019 FIX End */
			/********************************PM_CODE**************************************/
        /*spr 22474 start*/
        case PDCP_OAM_GET_DEBUG_INFO_RESP:
        {
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
            {
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
#endif

            if(OAM_FAILURE == oam_handle_pdcp_get_debug_info_cnf(
                        p_api_buf,
                        trans_id,
                        dest_id,
                        &p_err))
            {
                OAM_LOG(OAM,OAM_ERROR, "Error Handling PDCP_OAM_GET_DEBUG_INFO_RESP:%u", p_err);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            break;
        }
        /*spr 22474 end*/
		default:
			{
				OAM_LOG(OAM,OAM_WARNING,"Invalid api_id %d received in pdcp Msg Handler!!!",api_id );
				return OAM_FAILURE;
			}

	}

	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}

/******************************************************************************
 * Function Name  : oam_egtpu_intf_msg_handler 
 * Inputs         : p_api_buf, api_id
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et 
oam_egtpu_intf_msg_handler
(
 void *p_api_buf, 
 UInt16 api_id
 )
{
	/* Coverity_96943 Fix Start */
        oam_error_code_et p_err = OAM_ERR_ATTEMPT_SET_FOR_NON_WRITABLE_PARAM_VAL;
        /* Coverity_96943 Fix End */

	UInt16 trans_id = OAM_ZERO;
	UInt16 dest_id = OAM_ZERO;

	OAM_LOG(OAM,OAM_DETAILEDALL,"Entering oam_egtpu_intf_msg_handler...");

            /*SPR 17777 fix*/
	switch (api_id)
	{
		case PR_GTPU_PROC_SUP_RESP:
			/*SPR 21369 Start*/
            oam_hm_recieved_resp_bitmask_update(p_api_buf);
			/*SPR 21369 End*/
			break; 

		case EGTPU_LM_INITDB_CNF:
			OAM_LOG(OAM,OAM_DETAILED, "Received EGTPU_LM_INITDB_CNF from l2");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;
			p_cm_cntxt->event= OAM_CM_EV_LAYER_RES;

			if(OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&p_err))
			{
				OAM_LOG(OAM,OAM_DETAILED, "Successfully sent EGTPU_LM_INITDB_CNF to FSM");
			}
			else
			{
				OAM_LOG(OAM,OAM_DETAILED, "Failed to send EGTPU_LM_INITDB_CNF to FSM");
				return OAM_FAILURE;
			}
			break;
		case PR_GTPU_GET_LOG_CATEGORY_RESP:
			if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
			{
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			oam_pr_egtpu_get_logcategory_resp(p_api_buf,trans_id,dest_id,&p_err);
			break;
		case LM_SET_TRACE_LEVEL_CNF :
            /*SPR 17777 fix*/
			oam_handle_egtpu_set_trace_level_cnf(p_api_buf,&p_err);
			break;
		case LM_GET_TRACE_LEVEL_CNF:
			oam_handle_egtpu_get_trace_level_cnf(p_api_buf,&p_err);
			break;  
		case PR_GTPU_GET_LOG_LEVEL_RESP:
            oam_egtpu_get_loglevel_resp(p_api_buf);
            /*SPR 17777 fix*/
			break;  

		case PR_GTPU_GET_STATS_RESP:
            {
                OAM_LOG(OAM,OAM_DETAILED,"Inside EGTPU STATS api_id %d received in egtpu Msg Handler!!!",api_id );
                oam_memset(&getStatsResp, 0, sizeof(oam_egtpu_stats_res_t));
                SInt32 length_left = OAM_ZERO;
                UInt32 length_read = OAM_ZERO;
                /*SPR 21030 Fixed Start */
                trans_id=g_egtpu_trans_id;
                /*SPR 21030 Fixed End */
                length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                oam_parse_egtpu_stats_resp(&getStatsResp,
                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_read);
                oam_handle_egtpu_stats_resp(
                        trans_id,
                        QCLI_MODULE_ID,
                        &getStatsResp,
                        &p_err);
                break;
            }
        case S1U_INIT_LAYER_IND:
            {
              /*SPR 22451 FIXED START */
                /* OAM should start handling init request when communication
                 * with TR is successfully established */
                if((OAM_TRUE == oam_prov_req.oam_tr069_req.tr069_mode) &&
                        (oam_prov_req.system_status.tr069_configured != OAM_TRUE))
                {

                    OAM_LOG(OAM,OAM_DETAILED, "Received S1U_INIT_LAYER_IND from l2 before tr069 configured ");
                    return OAM_FAILURE;

                }
                else
                {

                    OAM_LOG(OAM,OAM_DETAILED, "Received S1U_INIT_LAYER_IND from l2");
                    p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;
                    if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&p_err))
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "Successfully sent s1u_oam_init_config_req to FSM");
                    }
                    else
                    {
                        OAM_LOG(OAM,OAM_DETAILED, "Failed to send s1u_oam_init_config_req to FSM");
                        return OAM_FAILURE;
                    }
                }
              /*SPR 22451 FIXED END*/

                break;
            }

        /*spr 22474 start*/
        case GTPU_OAM_GET_DEBUG_INFO_RESP:
        {
#ifndef OAM_UT_FRAMEWORK
            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id,&dest_id))
            {
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
#endif

            if(OAM_FAILURE == oam_handle_gtpu_get_debug_info_cnf(
                        p_api_buf,
                        trans_id,
                        dest_id,
                        &p_err))
            {
                OAM_LOG(OAM,OAM_ERROR, "Error Handling EGTPU_OAM_GET_DEBUG_INFO_RESP:%u", p_err);
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            break;
        }
        /*spr 22474 end*/
		default:
			{
				OAM_LOG(OAM,OAM_WARNING,"Invalid api_id %d received in egtpu Msg Handler!!!",api_id );
				return OAM_FAILURE;
			}

	}

	return OAM_SUCCESS;
}

/*--------------RRH Handlers------------------*/
#ifdef OAM_RADIO_HEAD_SUPPORT

/*---------------GET Request APIs to the Layers Begins----------------*/
/******************************************************************************
 * Function Name  : oam_rrh_process_inventory_req 
 * Inputs         : src_module_id,transaction_id,p_error_code 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et
oam_rrh_process_inventory_req
(
 UInt16 src_module_id,
 UInt16 transaction_id,
 oam_error_code_et *p_error_code
 )
{
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_rcm_send_inventory_req(src_module_id,transaction_id,
				p_error_code);
	}
#endif
	*p_error_code = OAM_MODULE_DISABLED;
	return OAM_FAILURE;
}

/******************************************************************************
 * Function Name  : oam_rrh_process_capabilities_req 
 * Inputs         : src_module_id,transaction_id,p_error_code 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et
oam_rrh_process_capabilities_req
(
 UInt16 src_module_id, 
 UInt16 transaction_id,
 oam_error_code_et *p_error_code
 )
{
	OAM_FUN_ENTRY_TRACE();
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_rcm_send_capabilities_req(src_module_id, transaction_id,
				p_error_code);
	}
#endif
	*p_error_code = OAM_MODULE_DISABLED;
	OAM_FUN_EXIT_TRACE();
	return OAM_FAILURE;
}

/******************************************************************************
 * Function Name  : oam_rrh_process_attributes_req 
 * Inputs         : src_module_id,transaction_id,p_error_code 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et
oam_rrh_process_attributes_req
(
 UInt16 src_module_id, 
 UInt16 transaction_id,
 oam_error_code_et *p_error_code
 )
{
	OAM_FUN_ENTRY_TRACE();
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_rcm_send_attributes_req(src_module_id, transaction_id,
				p_error_code);
	}
#endif
	*p_error_code = OAM_MODULE_DISABLED;
	OAM_FUN_EXIT_TRACE();
	return OAM_FAILURE;
}

/******************************************************************************
 * Function Name  : oam_rrh_process_reconfig_req 
 * Inputs         : api_buf,src_module_id,transaction_id,p_error_code 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et
oam_rrh_process_reconfig_req
(
 UInt8    *p_api_buf,
 UInt16   src_module_id,
 UInt16   transaction_id,
 oam_error_code_et     *p_error_code
 )
{
	OAM_FUN_ENTRY_TRACE();
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_rcm_send_reconfig_req(
				p_api_buf,src_module_id, transaction_id, p_error_code);
	}
#endif
	*p_error_code = OAM_MODULE_DISABLED;
	OAM_FUN_EXIT_TRACE();
	return OAM_FAILURE;
}

/******************************************************************************
 * Function Name  : oam_rrh_process_sw_download_req 
 * Inputs         : p_rcm_sw_download_req,src_module_id,transaction_id,p_error_code 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et
oam_rrh_process_sw_download_req
(
 void *p_rcm_sw_download_req,
 UInt16 src_module_id,
 UInt16 transaction_id,
 oam_error_code_et *p_error_code
 )
{
	OAM_FUN_ENTRY_TRACE();
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_rcm_handle_rrh_sw_download_req(
				(oam_rcm_rrh_sw_download_req_t*)p_rcm_sw_download_req,
				src_module_id, transaction_id, p_error_code);
	}
#endif
	*p_error_code = OAM_MODULE_DISABLED;
	OAM_FUN_EXIT_TRACE();
	return OAM_FAILURE;
}

/******************************************************************************
 * Function Name  : oam_rrh_process_unit_reset_req 
 * Inputs         : p_rcm_unit_reset_req,src_module_id,transaction_id,p_error_code 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et
oam_rrh_process_unit_reset_req
(
 void *p_rcm_unit_reset_req,
 UInt16   src_module_id,
 UInt16   transaction_id,
 oam_error_code_et *p_error_code
 )
{
	OAM_FUN_ENTRY_TRACE();
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_rcm_handle_unit_reset_req(
				(oam_rcm_unit_reset_req_t*)p_rcm_unit_reset_req,
				src_module_id, transaction_id, p_error_code);
	}
#endif
	*p_error_code = OAM_MODULE_DISABLED;
	OAM_FUN_EXIT_TRACE();
	return OAM_FAILURE;
}

/*---------------GET Request APIs to the Layers Ends----------------*/

/****************************************************************************
 * FUNCTION NAME : oam_handle_rrh_unit_reset_resp
 * DESCRIPTION   : This function  handles  OAM_RCM_UNIT_RESET_RESP message.
 * Inputs        : 1. pointer to the incoming message buffer
 2. transaction id
 *                 3. pointer to error code
 * Output        : 1. Pointer to Error code
 * RETURNS       : NONE
 ****************************************************************************/
void oam_handle_rrh_unit_reset_resp(UInt8 *p_api_buf, UInt16 trans_id,
		oam_error_code_et *p_err_code)
{
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		oam_handle_rcm_unit_reset_resp(p_api_buf, trans_id, p_err_code);
	}
#endif
	*p_err_code = OAM_MODULE_DISABLED;
}


/****************************************************************************
 * FUNCTION NAME : oam_handle_rrh_sw_download_ack
 * DESCRIPTION   : This function  handles  OAM_RCM_RRH_SW_DOWNLOAD_ACK message.
 * Inputs        : 1. pointer to the incoming message buffer
 2. transaction id
 *                 3. pointer to error code
 * Output        : 1. Pointer to Error code
 * RETURNS       : NONE
 ****************************************************************************/
void oam_handle_rrh_sw_download_ack(UInt8 *p_api_buf, UInt16 trans_id,
		oam_error_code_et *p_err_code)
{
	OAM_FUN_ENTRY_TRACE();
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		oam_handle_rcm_rrh_sw_download_ack(p_api_buf, trans_id, p_err_code);
	}
#endif
	*p_err_code = OAM_MODULE_DISABLED;
	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * FUNCTION NAME : oam_handle_rrh_sw_download_resp
 * DESCRIPTION   : This function  handles  OAM_RCM_RRH_SW_DOWNLOAD_RESP message.
 * Inputs        : 1. pointer to the incoming message buffer
 2. transaction id
 *                 3. pointer to error code
 * Output        : 1. Pointer to Error code
 * RETURNS       : NONE
 ****************************************************************************/
void oam_handle_rrh_sw_download_resp(UInt8 *p_api_buf, UInt16 trans_id,
		oam_error_code_et *p_err_code)
{
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		oam_handle_rcm_rrh_sw_download_resp(p_api_buf, trans_id, p_err_code);
	}
#endif
	*p_err_code = OAM_MODULE_DISABLED;
}


/****************************************************************************
 * FUNCTION NAME : oam_handle_oam_alarm_ind
 * DESCRIPTION   : This function handles RCM_OAM_ALARM_IND message.
 * Inputs        : 1. pointer to the incoming message buffer
 2. transaction id
 *                 3. pointer to error code
 * Output        : 1. Pointer to Error code
 * RETURNS       : NONE
 ****************************************************************************/
void oam_handle_oam_alarm_ind(UInt8 *p_api_buf, UInt16 trans_id,
		oam_error_code_et *p_err_code)
{
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		oam_handle_rcm_oam_alarm_ind(p_api_buf, trans_id, p_err_code);
	}
#endif
	*p_err_code = OAM_MODULE_DISABLED;
}


/****************************************************************************
 * Function Name  : oam_handle_capabilities_resp
 * Description    : This function handles the response from Layer at RRH
 *                  for Capabilities Response
 * Inputs         : p_api_buf : API Buffer
 *                : transaction_id: Transaction ID
 * Outputs        : pointer to error code
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
	oam_return_et
oam_handle_capabilities_resp(void* p_api_buf, UInt16 transaction_id,
		oam_error_code_et *p_err_code)
{
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_handle_rcm_capabilities_resp(p_api_buf, transaction_id,
				p_err_code);
	}
#endif
	*p_err_code = OAM_MODULE_DISABLED;
	return OAM_FAILURE;
}


/****************************************************************************
 * Function Name  : oam_handle_attributes_resp
 * Description    : This function handles the response from Layer at RRH
 *                  for Attributes Response
 * Inputs         : p_api_buf : API Buffer
 *                : transaction_id: Transaction ID
 * Outputs        : pointer to error code
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
	oam_return_et
oam_handle_attributes_resp(void* p_api_buf, UInt16 transaction_id,
		oam_error_code_et *p_err_code)
{
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_handle_rcm_attributes_resp(p_api_buf, transaction_id,
				p_err_code);
	}
#endif
	*p_err_code = OAM_MODULE_DISABLED;
	return OAM_FAILURE;
}



/****************************************************************************
 * Function Name  : oam_handle_inventory_details_resp
 * Description    : This function handles the response  from  RRH  Layer  for
 *                  Inventory Details Response
 * Inputs         : p_api_buf : API Buffer
 *                : transaction_id: Transaction ID
 *                : msg_len :Message Length
 *                : pointer to error code
 * Outputs        : None
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
	oam_return_et
oam_handle_inventory_details_resp(void* p_api_buf,
		UInt16 transaction_id,
		oam_error_code_et *p_err_code)
{
#ifdef OAM_RRH_TYPE_1_SUPPORT
	if(oam_prov_req.rcm_flag) {
		return oam_handle_rcm_inventory_details_resp(p_api_buf,
				transaction_id,
				p_err_code);
	}
#endif
	*p_err_code = OAM_MODULE_DISABLED;
	return OAM_FAILURE;
}


/******************************************************************************
 * Function Name  : oam_rrh_intf_msg_handler
 * Inputs     : p_api_buf, api_id, transid
 * Outputs    : none
 * Returns    : OAM_SUCCESS/OAM_FAILURE
 * Description    : This function handles RRH functions for OAM
 ******************************************************************************/
	oam_return_et
oam_rrh_intf_msg_handler(void *p_api_buf, UInt16 transid,UInt16 api_id)
{
	OAM_FUN_ENTRY_TRACE();

	oam_error_code_et err_code = NO_ERROR;
	oam_return_et retVal = OAM_FAILURE;
	oam_return_et retVal2 = OAM_FAILURE;
	UInt16        msg_size     = OAM_ZERO;
	void          *p_data      = OAM_NULL;
	UInt16        data_len     = OAM_ZERO;
	UInt16        new_trans_id = OAM_ZERO;
	new_trans_id = oam_get_new_trans_id();

	msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
	p_data   = p_api_buf + OAM_MGMT_INTF_HEADER_SIZE;
	data_len = msg_size - OAM_MGMT_INTF_HEADER_SIZE;

	if(OAM_NULL == p_api_buf) {
		OAM_LOG(OAM, OAM_WARNING, "Passing a null pointer.");
		return retVal;
	}

	switch (api_id) {
		case RCM_OAM_INIT_IND:
			OAM_LOG(OAM, OAM_DETAILED, "Received RCM_OAM_INIT_IND from RCM");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;
			if(OAM_SUCCESS ==
					oam_cm_fsm_process_event(p_api_buf, p_cm_cntxt, &err_code)) {
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully sent RCM_OAM_INIT_IND to FSM");
				retVal = OAM_SUCCESS;
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to send RCM_OAM_INIT_IND to FSM");
			}
			break;

		case OAM_RCM_INIT_CONFIG_RESP:
			OAM_LOG(OAM, OAM_DETAILED,
					"Received OAM_RCM_INIT_CONFIG_RESP from RCM");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;

			if(OAM_SUCCESS ==
					oam_cm_fsm_process_event(p_api_buf, p_cm_cntxt, &err_code)) {
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully sent OAM_RCM_INIT_CONFIG_RESP to FSM");
				retVal = OAM_SUCCESS;
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to send OAM_RCM_INIT_CONFIG_RESP to FSM");
			}
			break;

		case RCM_OAM_RRH_STATUS_IND:
			OAM_LOG(OAM, OAM_DETAILED,
					"Received OAM_RCM_RRH_STATUS_INDS from RCM");
			p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;
			if(OAM_CM_ST_ACTIVE == p_cm_cntxt->state) {
				retVal = oam_handle_rrh_status_init_ind(p_data, data_len, &err_code);
				if(OAM_SUCCESS == retVal) {
					OAM_LOG(OAM, OAM_DETAILED,
							"Successfully handled OAM_RCM_RRH_STATUS_INDS");
					if(RRH_DETECTED ==
							oam_prov_req.oam_rcm_req.rrh_status_ind.state) {
						retVal2 = oam_rcm_send_inventory_req(OAM_MODULE_ID,
								new_trans_id,
								&err_code);
						if(OAM_SUCCESS != retVal2) {
							OAM_LOG(OAM, OAM_WARNING,
									"Inventory fetch request failed for the first"
									" time. Inventory will not be available for"
									" further requests!!! Error: %d", err_code);
						}
						else {
							OAM_LOG(OAM, OAM_DETAILED,
									"Successfully sent OAM_RCM_INVENTORY_DETAILS_REQ");
						}
					}
				}
			}
			else {
				if(OAM_SUCCESS ==
						oam_cm_fsm_process_event(p_api_buf, p_cm_cntxt, &err_code)) {
					OAM_LOG(OAM, OAM_DETAILED,
							"Successfully sent OAM_RCM_RRH_STATUS_INDS  to FSM");
					retVal = OAM_SUCCESS;
				}
				else {
					OAM_LOG(OAM, OAM_DETAILED,
							"Failed to send OAM_RCM_RRH_STATUS_INDS to FSM");
				}
			}

			break;

		case OAM_RCM_UNIT_RESET_RESP:
			OAM_LOG(OAM, OAM_DETAILED,
					"Received OAM_RCM_UNIT_RESET_RESP from RCM");
			/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
			if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
			{
				OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
				break;
			}
#endif
			/* SPR 9620 CHANGE END */
			oam_handle_rrh_unit_reset_resp(p_api_buf, transid, &err_code);
			if(NO_ERROR == err_code) {
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCtrans_idRESET_RESP");
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_UNIT_RESET_RESP");
			}
			break;

		case OAM_RCM_RRH_SW_DOWNLOAD_ACK:
			OAM_LOG(OAM, OAM_DETAILED,
					"Received OAM_RCM_RRH_SW_DOWNLOAD_ACK from RCM");
			oam_handle_rrh_sw_download_ack(p_api_buf, transid, &err_code);
			if(NO_ERROR == err_code) {
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCM_RRH_SW_DOWNLOAD_ACK");
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_RRH_SW_DOWNLOAD_ACK");
			}
			break;

		case OAM_RCM_RRH_SW_DOWNLOAD_RESP:
			OAM_LOG(OAM, OAM_DETAILED,
					"Received OAM_RCM_RRH_SW_DOWNLOAD_RESP from RRH");
			oam_handle_rrh_sw_download_resp(p_api_buf, transid, &err_code);
			if(NO_ERROR == err_code) {
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCM_RRH_SW_DOWNLOAD_RESP");
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_RRH_SW_DOWNLOAD_RESP");
			}
			break;

		case RCM_OAM_ALARM_IND:
			OAM_LOG(OAM, OAM_DETAILED,
					"Received RCM_OAM_ALARM_IND from RRH");
			oam_handle_oam_alarm_ind(p_api_buf, transid, &err_code);
			if(NO_ERROR == err_code) {
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCM_RRH_SW_DOWNLOAD_RESP");
				retVal = OAM_SUCCESS;
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_RRH_SW_DOWNLOAD_RESP");
			}
			break;

		case OAM_RCM_GET_RRH_INVENTORY_DETAIL_RESP:
			oam_handle_inventory_details_resp(p_api_buf, transid, &err_code);

			if(NO_ERROR == err_code) {
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCM_GET_RRH_INVENTORY_DETAILS_RESP");
				retVal = OAM_SUCCESS;
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_GET_RRH_INVENTORY_DETAILS_RESP");
			}
			break;

		case OAM_RCM_GET_RRH_CAPABILITY_RESP:
			oam_handle_capabilities_resp(p_api_buf, transid, &err_code);

			if(NO_ERROR == err_code) {
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCM_GET_RRH_CAPABILITIES_REQ");
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_GET_RRH_CAPABILITIES_REQ");
			}
			break;

		case OAM_RCM_RECONFIG_RESP:
			oam_handle_rcm_reconfig_resp(p_api_buf, transid, &err_code);

			if(NO_ERROR == err_code) {
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCM_RECONFIG_RESP");
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_RECONFIG_RESP");
			}
			break;

		case OAM_RCM_GET_RRH_ATTR_RESP:
			oam_handle_attributes_resp(p_api_buf, transid, &err_code);

			if(NO_ERROR == err_code) {
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCM_GET_RRH_ATTR_RESP");
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_GET_RRH_ATTR_RESP");
			}
			break;

		case OAM_RCM_PROC_SUP_RSP:
			if(OAM_SUCCESS == oam_hm_resp_handler(p_api_buf))
			{
				retVal = OAM_SUCCESS;
				OAM_LOG(OAM, OAM_DETAILED,
						"Successfully handled OAM_RCM_PROC_SUP_RSP");
			}
			else 
			{
				retVal = OAM_FAILURE;
				OAM_LOG(OAM, OAM_DETAILED,
						"Failed to handle OAM_RCM_PROC_SUP_RSP");
			}
			break;

		default:
			OAM_LOG(OAM, OAM_DETAILED, "Invalid message: %d", api_id);
			break; 
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/******************************************************************************
 * Function Name  : oam_rrh_process_user_req 
 * Inputs         : p_api_buf,msg_len,api_mask,src_module_id,transaction_id,p_error_code 
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
oam_return_et 
oam_rrh_process_user_req
(
 UInt8     *p_api_buf, 
 UInt16    msg_len,
 UInt16    api_mask, 
 UInt16    transaction_id,
 UInt16    src_module_id,
 oam_error_code_et *p_error_code
 )
{
	OAM_FUN_ENTRY_TRACE();
	UInt32 reset_mask = OAM_ZERO;
	oam_return_et retVal;
	switch(api_mask) {
		case OAM_RCM_UNIT_RESET_REQ_MASK:
			OAM_LOG(OAM, OAM_DETAILED,
					"OAM_RCM_UNIT_RESET_REQ received from user.");
			retVal = oam_rrh_process_unit_reset_req(
					&local_prov_req.oam_rcm_req.unit_reset_req,
					src_module_id, transaction_id, p_error_code);
			/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
			if( OAM_FAILURE == oam_maintain_tcb_with_timer(transaction_id,OAM_SUB_MODULE_SON,
						OAM_TRANS_SON,msg_len,p_api_buf))
			{
				OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
				ret_val = OAM_FAILURE;
			}
#endif
			/* SPR 9620 CHANGE END */
			reset_mask = OAM_RCM_UNIT_RESET_REQ_MASK;
			reset_mask = ~reset_mask;
			paramter_app_map_tbl &= reset_mask; 
			break;

		case OAM_RCM_RRH_SW_DWNLD_REQ_MASK:
			OAM_LOG(OAM, OAM_DETAILED,
					"OAM_RCM_RRH_SW_DWNLD_REQ received from user.");
			retVal = oam_rrh_process_sw_download_req(
					&(local_prov_req.oam_rcm_req.rrh_sw_dwnld_req),
					src_module_id, transaction_id, p_error_code);

			reset_mask = OAM_RCM_RRH_SW_DWNLD_REQ_MASK;
			reset_mask = ~reset_mask;
			paramter_app_map_tbl &= reset_mask; 
			break;

		case RRH_OAM_RECONFIG_REQ_MASK:
			OAM_LOG(OAM, OAM_DETAILED,
					"RRH_OAM_RECONFIG_REQ received from user.");
			retVal = oam_rrh_process_reconfig_req(
					p_api_buf,src_module_id, transaction_id, p_error_code); 

			reset_mask = RRH_OAM_RECONFIG_REQ_MASK;
			reset_mask = ~reset_mask;
			paramter_app_map_tbl &= reset_mask; 
			break;

		case RRH_OAM_CAPABILITIES_MASK:
			OAM_LOG(OAM, OAM_DETAILED,
					"RRH_OAM_CAPABILITIES_REQ received from user.");
			retVal = oam_rrh_process_capabilities_req(src_module_id,
					transaction_id,
					p_error_code);

			reset_mask = RRH_OAM_CAPABILITIES_MASK;
			reset_mask = ~reset_mask;
			paramter_app_map_tbl &= reset_mask; 
			break;

		case RRH_OAM_ATTRIBUTES_MASK:
			OAM_LOG(OAM, OAM_DETAILED,
					"RRH_OAM_ATTRIBUTES_REQ received from user.");
			retVal = oam_rrh_process_attributes_req(src_module_id,
					transaction_id,
					p_error_code);

			reset_mask = RRH_OAM_ATTRIBUTES_MASK;
			reset_mask = ~reset_mask;
			paramter_app_map_tbl &= reset_mask; 
			break;
		default:
			OAM_LOG(OAM, OAM_WARNING, "Invalid request to RRH");
			*p_error_code = OAM_INVALID_REQ;
	}
	OAM_FUN_EXIT_TRACE();
	return retVal;
}



#endif  /* OAM_RADIO_HEAD_SUPPORT */
/*spr 22474 start*/
UInt16
oam_get_l3_debug_info_prints
(
 rrc_oam_get_debug_info_resp_t * p_rrc_resp,
 UInt8*** str_arr
)
{
    UInt16 num_str = OAM_ZERO;
    OAM_LOG(OAM,OAM_DETAILED,"p_rrc_resp->bitmask = %u",p_rrc_resp->bitmask);
    if(p_rrc_resp->bitmask &= RRC_OAM_DEBUG_GET_MEM_POOL_PRESENT) 
    {
        OAM_LOG(OAM,OAM_DETAILED,"RRC_OAM_DEBUG_GET_MEM_POOL_PRESENT");
        num_str = oam_get_l3_debug_mem_stats_prints(&p_rrc_resp->csplMemPoolStats, str_arr);
    }
    else
    {
        OAM_LOG(OAM, OAM_ERROR,
               "Received wrong p_rrc_resp->bitmask %u  in response from"
               " RRC in RRC_OAM_GET_DEBUG_INFO_RESP with resp:%u",
               p_rrc_resp->bitmask, p_rrc_resp->response);

    }

    return num_str;
}


UInt16
oam_get_rrm_debug_info_prints
(
 rrm_oam_get_debug_info_resp_t * p_rrm_resp,
 UInt8*** str_arr
)
{
    UInt16 num_str = OAM_ZERO;
    if(p_rrm_resp->bitmask & RRM_OAM_DEBUG_GET_MEM_POOL_PRESENT) 
    {
        num_str = oam_get_l3_debug_mem_stats_prints((rrc_MemPoolStats *)&p_rrm_resp->csplMemPoolStats, str_arr);
    }
    else
    {
        OAM_LOG(OAM, OAM_ERROR,
               "Received wrong p_rrm_resp->bitmask %u  in response from"
               " RRM in RRM_OAM_GET_DEBUG_INFO_RESP with resp:%u",
               p_rrm_resp->bitmask, p_rrm_resp->response);

    }

    return num_str;
}
UInt16
oam_get_son_debug_info_prints
(
 son_oam_get_debug_info_resp_t * p_son_resp,
 UInt8*** str_arr
)
{
    UInt16 num_str = OAM_ZERO;
    if(p_son_resp->bitmask & SON_OAM_DEBUG_GET_MEM_POOL_PRESENT) 
    {
        num_str = oam_get_l3_debug_mem_stats_prints((rrc_MemPoolStats *)&p_son_resp->csplMemPoolStats, str_arr);
    }
    else
    {
        OAM_LOG(OAM, OAM_ERROR,
               "Received wrong p_son_resp->bitmask %u  in response from"
               " SON in SON_OAM_GET_DEBUG_INFO_RESP with resp:%u",
               p_son_resp->bitmask, p_son_resp->response);

    }

    return num_str;
}
UInt16
oam_get_oam_debug_info_prints
(
 oam_get_debug_info_resp_t * p_oam_resp,
 UInt8*** str_arr
)
{
    UInt16 num_str = OAM_ZERO;
    if(p_oam_resp->bitmask & OAM_DEBUG_GET_MEM_POOL_PRESENT) 
    {
        num_str = oam_get_l3_debug_mem_stats_prints((rrc_MemPoolStats *)&p_oam_resp->csplMemPoolStats, str_arr);
    }
    else
    {
        OAM_LOG(OAM, OAM_ERROR,
               "Received wrong p_oam_resp->bitmask %u  in response from"
               " OAM in OAM_GET_DEBUG_INFO_RESP with resp:%u",
               p_oam_resp->bitmask, p_oam_resp->response);

    }

    return num_str;
}

/*spr 22474 end*/


/* SPR_20467_FIX_START */
/****************************************************************************
 * Function Name  : oam_process_tcb_for_ecu_resp
 * Inputs         : p_api_buf :Pointer to api buffer
 * Outputs        : tid :Transaction id	fetched from TCB
 *                  dest_id: Destination id fetched from TCB
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : This function is used to stop the timer, delete tcb entry
 *                  and get transaction/destination id.
 ****************************************************************************/

oam_s1ap_ecu_resp_data_t *
oam_process_tcb_for_ecu_resp
(
 oam_s1ap_ecu_resp_data_t *p_oam_s1ap_ecu_resp_data,
 UInt8* p_api_buf,
 UInt16 trans_id
 )
{
	UInt32 transaction_id;
	oam_struct_t *node;

	OAM_FUN_ENTRY_TRACE();

	transaction_id = get_word_from_header(p_api_buf);

	OAM_LOG(OAM, OAM_DETAILED,
			"trans_id received from lower layer: %d, trans_id %d", transaction_id,trans_id);
    if(0 == trans_id)
    {    
	   node = oam_tcb_get_detail(&transaction_id);
    }
    else
    {
        node = oam_tcb_get_detail(&trans_id);
        transaction_id = trans_id;
    }    
	if(node) {
		if(node->timer_id) {
			p_oam_s1ap_ecu_resp_data = node->oam_procedure_specific_context;

			if(qvTimerRunning(node->timer_id)) {
				OAM_LOG(OAM, OAM_DETAILED, "Stopping Timer");
				if(OAM_SUCCESS !=  oam_stop_timer(node->timer_id)) {
					OAM_LOG(OAM, OAM_ERROR,
							"Error returned while stopping the timer");
				}
				else {
					OAM_LOG(OAM, OAM_DETAILED, "Timer Stopped");
				}
			}
			else {
				OAM_LOG(OAM, OAM_DETAILED,
						"Timer not running for the response");
			}
		}

	}
	else {
		OAM_LOG(OAM, OAM_ERROR,
				"Node fetched from TCB is NULL, Returning Failure");
		return OAM_NULL;
	}

	OAM_FUN_EXIT_TRACE();
	return p_oam_s1ap_ecu_resp_data;
}
/* SPR_20467_FIX_END */

/******************************************************************************
 * Function Name  : oam_rrc_intf_msg_handler 
 * Inputs         : p_api_buf,api_id,transaction_id
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : 
 ******************************************************************************/
	oam_return_et 
oam_rrc_intf_msg_handler(void *p_api_buf, UInt16 transid, UInt16 api_id)
{
    UInt16 msg_size= OAM_ZERO;
    SInt32 length_left= OAM_ZERO;
    SInt32 length_read= OAM_ZERO;
    UInt16 trans_id = OAM_ZERO;
    trans_id = get_word_from_header(p_api_buf);
    UInt16 trans_id_resp = OAM_ZERO;
    UInt16 dest_id = OAM_ZERO;
    UInt8 temp_str_cli[OAM_HUNDRED];
    UInt8 temp_arr_cli_2[OAM_HUNDRED];
    UInt8 **temp_arr= OAM_NULL;
    UInt8 str_count = OAM_ZERO;
    UInt16 size_x = OAM_THOUSAND;
    UInt16 size_y = OAM_TWO_THOUSAND;
    /* coverity 62595 */ 
    oam_error_code_et error_code = NO_ERROR;
    oam_counter_t loop_counter = OAM_ZERO, loop_counter1 = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;
    oam_return_et layer_resp = OAM_FAILURE;
    UInt8 cid = OAM_ZERO;
    oam_rrm_cell_config_req_t *p_rrm_cell_config = OAM_NULL;
    UInt8 *p_curr_offset = OAM_NULL;
    oam_cell_status_t *p_cell_status = OAM_NULL;
    UInt8 usr_resp = OAM_RESULT_SUCCESS;
    Char8 *err_string = OAM_NULL;
    UInt8 err_str_size = OAM_ZERO;
    UInt16 usr_error_code = OAM_ZERO;
    oam_tcb_cntxt_data_t tcb_data = {OAM_ZERO};
    /*CID:66646 start*/
    oam_return_et tcb_found  = OAM_FAILURE;
    /*CID:66646 end*/
    UInt16 msg_len=OAM_ZERO;
    /* BCOM Compiltaion Fix */
#ifndef OAM_SON_ENABLE
    oam_error_code_et p_err = OAM_ERR_ATTEMPT_SET_FOR_NON_WRITABLE_PARAM_VAL;
#endif
    /* BCOM Compiltaion Fix */
    /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
    m2ap_oam_config_update_resp_t *p_m2ap_config_update_resp = OAM_NULL;
    m2ap_oam_mce_link_status_ind_t *p_m2ap_mce_link_status_ind = OAM_NULL;
    m2ap_oam_set_log_level_resp_t *p_m2ap_set_log_level_resp = OAM_NULL;
    m2ap_oam_get_stat_resp_t *p_m2ap_get_stat_resp = OAM_NULL;
    m2ap_oam_alarm_notification_ind_t *p_m2ap_notif_ind = OAM_NULL;
    m2ap_oam_session_details_resp_t *p_m2ap_session_details_resp = OAM_NULL;
    m2ap_oam_get_log_level_resp_t *p_m2ap_get_log_level_resp = OAM_NULL;
    m2ap_oam_reset_resp_t *p_m2ap_reset_resp = OAM_NULL;
    /* Coverity 93570 Fix Start */
    oam_bool_et tcb_found_1  = OAM_FALSE;
    /* Coverity 93570 Fix End */
#endif
    /* EMBMS Changes End */

    msg_len=get_word_from_header((U8*)(p_api_buf) + OAM_EIGHT);
    OAM_FUN_ENTRY_TRACE();

    /* Coverity 109463_31371 + */
    /* SPR_19279_START */
    oam_rrm_cell_reconfig_req_t  *p_cell_reconfig_req = OAM_NULL;
    oam_rrm_cell_plmnlist_data_t *p_cell_local_plmnlist_data = OAM_NULL;
    /* SPR_20467_FIX_START */
    UInt8 mme_id = OAM_ZERO;
    oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
    UInt8 ecu_resp_recvd_for_all_mme = OAM_FALSE;
    UInt8 ecu_failure_received = OAM_FALSE;
    UInt8 temp_count = OAM_ZERO;
    UInt8 num_failure_mmeId = OAM_ZERO;
    UInt8 send_s1ap_oam_close_mme_conn_req = OAM_FALSE;
    oam_s1ap_close_mme_conn_t s1ap_close_mme_conn={OAM_ZERO};
    /* SPR_20467_FIX_END */

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(
            oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return OAM_FAILURE;
    }
    /* SPR_19279_END */
    /* Coverity 109463_31371 - */

    switch (api_id)
    {
        case X2AP_OAM_PROC_SUPP_RESP:
        /*SPR 21369 Start*/
        oam_hm_recieved_resp_bitmask_update(p_api_buf);
        /*SPR 21369 End*/
        break;
        case S1AP_OAM_PROC_SUPP_RESP:
        /*SPR 21369 Start*/
        oam_hm_recieved_resp_bitmask_update(p_api_buf);
        /*SPR 21369 End*/
        break;
        case RRC_OAM_PROC_SUPP_RESP:
        /*SPR 21369 Start*/
        oam_hm_recieved_resp_bitmask_update(p_api_buf);
        /*SPR 21369 End*/
        break;

        case RRC_OAM_INIT_IND:
        OAM_LOG(OAM,OAM_DETAILED, "Received RRC_OAM_INIT_IND from l3");
        p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;
        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&error_code))
        {
            OAM_LOG(OAM,OAM_DETAILED, "Successfully sent RRC_OAM_COMMUNICATION_INFO_REQ to FSM");
        }
        else
        {
            OAM_LOG(OAM,OAM_DETAILED, "Failed to send RRC_OAM_COMMUNICATION_INFO_REQ to FSM");
            return OAM_FAILURE;
        }
        break;
        case RRC_OAM_COMMUNICATION_INFO_RESP:
        OAM_LOG(OAM,OAM_DETAILED, "Received RRC_OAM_COMMUNICATION_INFO_RESP from l3");
        p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;

        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&error_code))
        {
            OAM_LOG(OAM,OAM_DETAILED, "Successfully sent RRC_OAM_COMMUNICATION_INFO_RESP to FSM");
        }
        else
        {
            OAM_LOG(OAM,OAM_DETAILED, "Failed to send RRC_OAM_COMMUNICATION_INFO_RESP to FSM");
            return OAM_FAILURE;
        }
        break;
        case RRC_OAM_PROVISION_RESP:
        OAM_LOG(OAM, OAM_INFO, "Received RRC_OAM_PROVISION_RESP from L3");
        p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;

        retVal = oam_cm_fsm_process_event(p_api_buf,
                p_cm_cntxt,
                &error_code);
        if (OAM_SUCCESS == retVal) {
            OAM_LOG(OAM, OAM_DETAILED,
                    "Successfully sent RRC_OAM_PROVISION_RESP to FSM");
        }
        else {
            OAM_LOG(OAM, OAM_ERROR,
                    "Failed to send RRC_OAM_PROVISION_RESP to FSM");
        }

        if (oam_prov_req.system_status.event_ongoing &
                OAM_FSM_INIT_TIME_USR_REQ_ONGOING) {
            oam_prov_req.system_status.event_ongoing &=
                ~OAM_FSM_INIT_TIME_USR_REQ_ONGOING;
            if (OAM_SUCCESS == retVal) {
                layer_resp = OAM_SUCCESS;
                err_string = OAM_NULL;
                err_str_size = OAM_ZERO;
                usr_error_code = OAM_ZERO;
                usr_resp = OAM_RESULT_SUCCESS;
            }
            else {
                oam_get_err_string_n_err_code(error_code,
                        &usr_error_code,
                        &err_string);
                err_str_size = oam_strlen(err_string) + OAM_ONE;
                usr_resp = OAM_RESULT_FAILURE;
            }

            tcb_found = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                    &tcb_data.usr_req_trans_id,
                    &tcb_data.usr_intf_src_id,
                    &tcb_data.p_orig_xml_parent,
                    &tcb_data.p_usr_msg_xml_parent,
                    &tcb_data.p_parent_xml_struct_addr);

            if (OAM_SUCCESS == tcb_found) {
                oam_construct_n_send_set_resp_to_usr(usr_resp,
                        usr_error_code,
                        (UInt8*)err_string,
                        err_str_size,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        tcb_data.usr_intf_src_id,
                        tcb_data.usr_req_trans_id,
                        OAM_ZERO, OAM_ZERO,
                        &error_code);

                oam_update_xml_dom(layer_resp,
                        tcb_data.p_orig_xml_parent,
                        tcb_data.p_usr_msg_xml_parent,
                        tcb_data.p_parent_xml_struct_addr);
            }
            else {
                OAM_LOG(OAM, OAM_WARNING,
                        "XML DOM can't be updated as TCB is not found");
            }
        }
        break;

        case RRC_OAM_GET_CELL_STATUS_RESP:
        {
            OAM_LOG(OAM,OAM_DETAILED, "Received RRC_OAM_GET_CELL_STATUS_RESP from l3");
            oam_rrc_get_cell_status_resp_t p_oam_rrc_get_cell_status_resp;
            UInt16 dst_id = OAM_ZERO;
            trans_id_resp = get_word_from_header((UInt8 *)p_api_buf);
            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id_resp, &trans_id, &dst_id))
            {
                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                return OAM_FAILURE;
            }
            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
            length_read= OAM_ZERO;
            oam_memset(&p_oam_rrc_get_cell_status_resp, 0x00, sizeof(oam_rrc_get_cell_status_resp_t));
            if(OAM_SUCCESS == oam_rrc_il_parse_rrc_oam_get_cell_status_resp(&p_oam_rrc_get_cell_status_resp,
                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                        &length_read))
            {
                OAM_LOG(OAM,OAM_DETAILED, "RRC_OAM_GET_CELL_STATUS_RESP function success");
            }
            else
            {
                OAM_LOG(OAM,OAM_DETAILED, "RRC_OAM_GET_CELL_STATUS_RESP function failed");
                oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
                        NO_ERROR,
                        OAM_VERSION, OAM_MODULE_ID,
                        dst_id, trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        "Parsing of RRC_OAM_GET_CELL_STATUS_RESP failed", &error_code);
                return OAM_FAILURE;
            }
            if(OAM_SUCCESS==p_oam_rrc_get_cell_status_resp.response)
            {
                if (OAM_FAILURE == oam_mem_alloc((size_x * sizeof(UInt16 *)),(void *)&temp_arr,&error_code))
                {
                    OAM_LOG(OAM,OAM_ERROR,
                            "Error in Memory Allocation with error code %d",
                            error_code);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                for (loop_counter = OAM_ZERO; loop_counter < size_x; loop_counter++)
                {
                    if(OAM_FAILURE == oam_mem_alloc((size_y * sizeof(UInt16)),(void *)&temp_arr[loop_counter],&error_code))
                    {
                        OAM_LOG(OAM,OAM_ERROR,"Error in Memory Allocation with error code %d",
                                error_code);
                        /* Coverity ID 72208 Fix Start*/
                        for(loop_counter1 = OAM_ZERO ;loop_counter1 < loop_counter;loop_counter1++)
                        {
                            oam_mem_free(temp_arr[loop_counter1], &error_code);
                        }
                        oam_mem_free(temp_arr, &error_code);
                        /* Coverity ID 72208 Fix End*/
                        OAM_FUN_EXIT_TRACE();
                        return OAM_FAILURE;
                    }
                    oam_memset(temp_arr[loop_counter], 0x00, (size_y * sizeof(UInt16)));
                }

                oam_sprintf((char *)temp_arr[str_count++],"%s=%lu",
                        "Number 0f UEs",p_oam_rrc_get_cell_status_resp.cell_status.num_ue);

                oam_sprintf((char *)temp_arr[str_count++],"%s=%lu",
                        "Number 0f SRB1s",p_oam_rrc_get_cell_status_resp.cell_status.num_srb1);

                oam_sprintf((char *)temp_arr[str_count++],"%s=%lu",
                        "Number 0f SRB2s",p_oam_rrc_get_cell_status_resp.cell_status.num_srb2);

                oam_sprintf((char *)temp_arr[str_count++],"%s=%lu",
                        "Number 0f DRBs",p_oam_rrc_get_cell_status_resp.cell_status.num_drb);

                oam_construct_n_send_gpv_response((UInt8 *)"Show.CellStatus.RRC",temp_arr,str_count,
                        trans_id_resp,&error_code,dst_id,OAM_ZERO,OAM_ZERO);

                /* Coverity ID 72208 Fix Start*/
                for(loop_counter1 = OAM_ZERO ;loop_counter1 < loop_counter;loop_counter1++)
                {
                    oam_mem_free(temp_arr[loop_counter1], &error_code);
                }
                /* Coverity ID 72208 Fix End*/
                oam_mem_free(temp_arr, &error_code);
            }
            else
            {
                OAM_LOG(OAM,OAM_ERROR, "FAILURE RESPONSE from RRC_OAM_GET_CELL_STATUS_RESP");
                oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
                        NO_ERROR,
                        OAM_VERSION, OAM_MODULE_ID,
                        dst_id, trans_id_resp,
                        OAM_ZERO, OAM_ZERO,
                        "Failure response from RRC", &error_code);
            }

            break;
        }

        case RRC_OAM_GET_UE_STATUS_RESP:{/*COVERITY FIX 54277*/
                                            OAM_LOG(OAM,OAM_DETAILED, "Received RRC_OAM_GET_UE_STATUS_RESP from l3");
                                            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                                            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                                                break;
                                            }
#endif
                                            /* SPR 9620 CHANGE END */   
                                            rrc_oam_get_ue_status_resp_t *p_rrc_oam_get_ue_status_resp;
                                            UInt16 ue_num = OAM_ZERO;
                                            UInt16 i = OAM_ZERO;
                                            UInt16 dst_id = QCLI_MODULE_ID;
                                            trans_id_resp = get_word_from_header((UInt8 *)p_api_buf);
                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                            length_read= OAM_ZERO;
                                            if(OAM_FAILURE == oam_mem_alloc(sizeof(rrc_oam_get_ue_status_resp_t),(void*)&p_rrc_oam_get_ue_status_resp, &error_code))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED,"Error in Memory Allocation with Error Code:%d",error_code);
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;
                                            }
                                            if(OAM_SUCCESS == oam_rrc_il_parse_rrc_oam_get_ue_status_resp(p_rrc_oam_get_ue_status_resp,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        &length_read))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "RRC_OAM_GET_UE_STATUS_RESP function success");
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "RRC_OAM_GET_UE_STATUS_RESP function failed");
                                            }

                                            if(OAM_SUCCESS==p_rrc_oam_get_ue_status_resp->response && (p_rrc_oam_get_ue_status_resp->ue_status_list.num_ue_status > OAM_ZERO))
                                            {
                                                if (OAM_FAILURE == oam_mem_alloc((size_x * sizeof(UInt16 *)),(void *)&temp_arr,&error_code))
                                                {
                                                    OAM_LOG(OAM,OAM_ERROR,
                                                            "Error in Memory Allocation with error code %d",
                                                            error_code);
                                                    OAM_FUN_EXIT_TRACE();
                                                    /* Coverity ID : 72207 Fix Start*/
                                                    oam_mem_free(p_rrc_oam_get_ue_status_resp,&error_code);
                                                    /* Coverity ID : 72207 Fix End*/
                                                    return OAM_FAILURE;
                                                }

                                                for (loop_counter = OAM_ZERO; loop_counter < size_x; loop_counter++)
                                                {
                                                    if(OAM_FAILURE == oam_mem_alloc((size_y * sizeof(UInt16)),(void *)&temp_arr[loop_counter],&error_code))
                                                    {
                                                        OAM_LOG(OAM,OAM_ERROR,"Error in Memory Allocation with error code %d",
                                                                error_code);
                                                        /* Coverity ID 72208 Fix Start*/
                                                        for(loop_counter1 = OAM_ZERO ;loop_counter1 < loop_counter;loop_counter1++)
                                                        {
                                                            oam_mem_free(temp_arr[loop_counter1], &error_code);
                                                        }
                                                        oam_mem_free(temp_arr, &error_code);
                                                        /* Coverity ID 72208 Fix End*/

                                                        /* Coverity ID : 72207 Fix Start*/
                                                        oam_mem_free(p_rrc_oam_get_ue_status_resp,&error_code);
                                                        /* Coverity ID : 72207 Fix End*/
                                                        OAM_FUN_EXIT_TRACE();
                                                        return OAM_FAILURE;
                                                    }
                                                    oam_memset(temp_arr[loop_counter], 0x00, (size_y * sizeof(UInt16))); 
                                                }
                                                ue_num = p_rrc_oam_get_ue_status_resp->ue_status_list.num_ue_status;
                                                for(i=0;i<ue_num;i++)
                                                {

                                                    oam_sprintf((char *)temp_arr_cli_2,"%s[%d]",
                                                            "CRNTI",i + 1);
                                                    oam_strcpy((char *)temp_str_cli,(char *)temp_arr_cli_2);
                                                    oam_sprintf((char *)temp_arr[str_count++],"%s=%u",
                                                            temp_str_cli,p_rrc_oam_get_ue_status_resp->ue_status_list.ue_status[i].crnti);

                                                    oam_sprintf((char *)temp_arr_cli_2,"%s[%d]",
                                                            "UE STATE",i + 1);
                                                    oam_strcpy((char *)temp_str_cli,(char *)temp_arr_cli_2);
                                                    oam_sprintf((char *)temp_arr[str_count++],"%s=%u",
                                                            temp_str_cli,p_rrc_oam_get_ue_status_resp->ue_status_list.ue_status[i].ue_state);

                                                    oam_sprintf((char *)temp_arr_cli_2,"%s[%d]",
                                                            "UE CATEGORY",i + 1);
                                                    oam_strcpy((char *)temp_str_cli,(char *)temp_arr_cli_2);
                                                    oam_sprintf((char *)temp_arr[str_count++],"%s=%u",
                                                            temp_str_cli,p_rrc_oam_get_ue_status_resp->ue_status_list.ue_status[i].ue_category);

                                                    oam_sprintf((char *)temp_arr_cli_2,"%s[%d]",
                                                            "Num SRB",i + 1);
                                                    oam_strcpy((char *)temp_str_cli,(char *)temp_arr_cli_2);
                                                    oam_sprintf((char *)temp_arr[str_count++],"%s=%u",
                                                            temp_str_cli,p_rrc_oam_get_ue_status_resp->ue_status_list.ue_status[i].num_srb);

                                                    oam_sprintf((char *)temp_arr_cli_2,"%s[%d]",
                                                            "Num DRB",i + 1);
                                                    oam_strcpy((char *)temp_str_cli,(char *)temp_arr_cli_2);
                                                    oam_sprintf((char *)temp_arr[str_count++],"%s=%u",
                                                            temp_str_cli,p_rrc_oam_get_ue_status_resp->ue_status_list.ue_status[i].num_drb);

                                                    oam_sprintf((char *)temp_arr_cli_2,"%s[%d]",
                                                            "enbUeS1ApId",i + 1);
                                                    oam_strcpy((char *)temp_str_cli,(char *)temp_arr_cli_2);
                                                    oam_sprintf((char *)temp_arr[str_count++],"%s=%u",
                                                            temp_str_cli,p_rrc_oam_get_ue_status_resp->ue_status_list.ue_status[i].enb_ue_s1ap_id);

                                                    oam_sprintf((char *)temp_arr_cli_2,"%s[%d]",
                                                            "mmeUeS1ApId",i + 1);
                                                    oam_strcpy((char *)temp_str_cli,(char *)temp_arr_cli_2);
                                                    oam_sprintf((char *)temp_arr[str_count++],"%s=%u",
                                                            temp_str_cli,p_rrc_oam_get_ue_status_resp->ue_status_list.ue_status[i].mme_ue_s1ap_id);

                                                }
                                                /* CSR_69212_FIX_START */
                                                oam_construct_n_send_gpv_response((UInt8 *)"Show.UeStatus.RRC",temp_arr,str_count,
                                                        trans_id_resp,&error_code,dst_id,OAM_ZERO,OAM_ZERO);
                                                /* CSR_69212_FIX_END */

                                                /* Coverity ID 72208 Fix Start*/
                                                for(loop_counter1 = OAM_ZERO ;loop_counter1 < loop_counter;loop_counter1++)
                                                {
                                                    oam_mem_free(temp_arr[loop_counter1], &error_code);
                                                }
                                                oam_mem_free(temp_arr, &error_code);
                                                /* Coverity ID 72208 Fix End*/
                                            }
                                            else if(OAM_SUCCESS==p_rrc_oam_get_ue_status_resp->response && (p_rrc_oam_get_ue_status_resp->ue_status_list.num_ue_status == OAM_ZERO))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "SUCCESS RESPONSE from RRC_OAM_GET_UE_STATUS_RESP, but no UE attached");
                                                /*start BUG 10274 */
                                                oam_construct_n_send_gpv_response((UInt8 *)"Show.UeStatus.RRC",temp_arr,str_count,
                                                        trans_id_resp,&error_code,dst_id,OAM_ZERO,OAM_ZERO);
                                                /*end BUG 10274 */
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "FAILURE RESPONSE from RRC_OAM_GET_UE_STATUS_RESP");
                                                oam_construct_n_send_get_resp_to_usr(OAM_RESULT_FAILURE,
                                                        NO_ERROR,
                                                        OAM_VERSION, OAM_MODULE_ID,
                                                        dst_id, trans_id_resp,
                                                        OAM_ZERO, OAM_ZERO,
                                                        "Failure response from RRC", &error_code);
                                            }
                                            /* Coverity ID : 72207 Fix Start*/
                                            oam_mem_free(p_rrc_oam_get_ue_status_resp,&error_code);
                                            /* Coverity ID : 72207 Fix End*/
                                            break;}
        case RRC_OAM_LOG_ENABLE_RESP:
                                        /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                                        if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                                            break;
                                        }
#endif
                                        /* SPR 9620 CHANGE END */

                                        oam_rrc_log_enable_resp_t *p_oam_rrc_log_enable_resp;

                                        if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_rrc_log_enable_resp_t),(void*)&p_oam_rrc_log_enable_resp, &error_code))
                                        {
                                            OAM_LOG(OAM, OAM_ERROR,
                                                    "Memory allocation to p_oam_rrc_log_enable_resp failed"
                                                    " with Error Code:%d",
                                                    error_code);
                                            OAM_FUN_EXIT_TRACE();
                                            return OAM_FAILURE;               
                                        }

                                        length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                        length_read= OAM_ZERO;

                                        OAM_LOG(OAM,OAM_DETAILED, "Received RRC_OAM_LOG_ENABLE_RESP from l3");


                                        if(OAM_SUCCESS== oam_rrc_il_parse_rrc_oam_log_enable_resp(p_oam_rrc_log_enable_resp,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                    &length_read))
                                        {
                                            if (RRC_SUCCESS == p_oam_rrc_log_enable_resp->response)
                                            {
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                        OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED,
                                                    "Failed to parse RRC_OAM_LOG_ENABLE_RESP");

                                            /* Coverity ID : 72204 Fix Start*/
                                            oam_mem_free(p_oam_rrc_log_enable_resp,&error_code);
                                            /* Coverity ID : 72204 Fix End*/
                                            return OAM_FAILURE;
                                        }
                                        /* Coverity ID : 72204 Fix Start*/
                                        oam_mem_free(p_oam_rrc_log_enable_resp,&error_code);
                                        /* Coverity ID : 72204 Fix End*/
                                        break;

        case X2AP_OAM_LOG_ENABLE_RESP:

#ifndef OAM_UT_FRAMEWORK
                                        if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                                            break;
                                        }
#endif

                                        oam_x2ap_log_enable_resp_t *p_oam_x2ap_log_enable_resp;

                                        if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_x2ap_log_enable_resp_t),(void*)&p_oam_x2ap_log_enable_resp, &error_code))
                                        {
                                            OAM_LOG(OAM, OAM_ERROR,
                                                    "Memory allocation to p_oam_x2ap_log_enable_resp failed"
                                                    " with Error Code:%d",
                                                    error_code);
                                            OAM_FUN_EXIT_TRACE();
                                            return OAM_FAILURE;
                                        }

                                        length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                        length_read= OAM_ZERO;

                                        OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_OAM_LOG_ENABLE_RESP from l3");


                                        if(OAM_SUCCESS== oam_rrc_il_parse_x2ap_oam_log_enable_resp(p_oam_x2ap_log_enable_resp,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                    &length_read))
                                        {
                                            if (RRC_SUCCESS == p_oam_x2ap_log_enable_resp->response)
                                            {
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                        OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED,
                                                    "Failed to parse X2AP_OAM_LOG_ENABLE_RESP");

                                            oam_mem_free(p_oam_x2ap_log_enable_resp,&error_code);
                                            return OAM_FAILURE;
                                        }

                                        oam_mem_free(p_oam_x2ap_log_enable_resp,&error_code);
                                        break;

        case S1AP_OAM_LOG_ENABLE_RESP:

#ifndef OAM_UT_FRAMEWORK
                                        if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                                            break;
                                        }
#endif

                                        oam_s1ap_log_enable_resp_t *p_oam_s1ap_log_enable_resp;

                                        if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_s1ap_log_enable_resp_t),(void*)&p_oam_s1ap_log_enable_resp, &error_code))
                                        {
                                            OAM_LOG(OAM, OAM_ERROR,
                                                    "Memory allocation to p_oam_s1ap_log_enable_resp failed"
                                                    " with Error Code:%d",
                                                    error_code);
                                            OAM_FUN_EXIT_TRACE();
                                            return OAM_FAILURE;
                                        }

                                        /* CID 122023 fix start */
#if 0
                                        if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_s1ap_log_enable_resp_t),(void*)&p_oam_s1ap_log_enable_resp, &error_code))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED,"Error in Memory Allocation with Error Code:%d",error_code);
                                            OAM_FUN_EXIT_TRACE();
                                            return OAM_FAILURE;
                                        }
#endif
                                        /* CID 122023 fix end */
                                        length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                        length_read= OAM_ZERO;

                                        OAM_LOG(OAM,OAM_DETAILED, "Received S1AP_OAM_LOG_ENABLE_RESP from l3");


                                        if(OAM_SUCCESS== oam_rrc_il_parse_s1ap_oam_log_enable_resp(p_oam_s1ap_log_enable_resp,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                    &length_read))
                                        {
                                            if (RRC_SUCCESS == p_oam_s1ap_log_enable_resp->response)
                                            {
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                        OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED,
                                                    "Failed to parse S1AP_OAM_LOG_ENABLE_RESP");

                                            oam_mem_free(p_oam_s1ap_log_enable_resp,&error_code);
                                            return OAM_FAILURE;
                                        }

                                        oam_mem_free(p_oam_s1ap_log_enable_resp,&error_code);
                                        break;


        case S1AP_OAM_INIT_IND:
                                        OAM_LOG(OAM,OAM_DETAILED, "Received S1AP_OAM_INIT_IND from l3");
                                        p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;
                                        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&error_code))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Successfully sent S1AP_OAM_PROVISION_REQ to FSM");
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Failed to send S1AP_OAM_PROVISION_REQ to FSM");
                                            return OAM_FAILURE;
                                        }
                                        break;

        case S1AP_OAM_S1AP_LINK_STATUS_IND:
                                        {
                                            OAM_LOG(OAM, OAM_INFO,
                                                    "Received S1AP_OAM_S1AP_LINK_STATUS_IND from L3");
                                            length_left = get_word_from_header((UInt8*)p_api_buf +
                                                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                            length_read = OAM_ZERO;
                                            /* SPR 21738 Fix Start */
                                            /* Code Moved */
                                            /* SPR 21738 Fix End */
                                            oam_s1ap_link_status_ind_t oam_s1ap_link_status_ind; 
                                            oam_s1ap_close_mme_conn_t s1ap_close_mme_conn={OAM_ZERO};

                                            p_curr_offset = p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                            length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                            retVal = oam_rrc_il_parse_s1ap_oam_s1ap_link_status_ind(
                                                    &oam_s1ap_link_status_ind,
                                                    p_curr_offset,
                                                    length_left,
                                                    &length_read);
                                            if(OAM_SUCCESS == retVal) {
                                                if(OAM_S1AP_LINK_UP == oam_s1ap_link_status_ind.status) {
                                                    /* CSR 00058746 Fix START*/ 
                                                    OAM_SYS_EVENT_BIMASK |= S1AP_LINK_UP_RCVD;
                                                    /* CSR 00058746 Fix END*/ 
                                                    OAM_LOG(OAM, OAM_INFO, "S1AP Link UP Received for mme id %d",oam_s1ap_link_status_ind.mme_id);
                                                    /*Coverity 57702 */  
                                                    /*UT BUG FIX for CELL STATE*/
                                                    transid = oam_get_new_trans_id();
                                                    oam_prov_req.oam_l3_req.mme_data.num_mme_id++;    
                                                    oam_prov_req.oam_l3_req.mme_data.mme_id[oam_prov_req.oam_l3_req.mme_data.num_mme_id - OAM_ONE] = 
                                                        oam_s1ap_link_status_ind.mme_id;
                                                    s1ap_close_mme_conn.mme_count=OAM_ONE;
                                                    s1ap_close_mme_conn.mme_id[OAM_ZERO]= oam_s1ap_link_status_ind.mme_id;

                                                    OAM_LOG(OAM,OAM_DETAILED,"S1AP num active mme =%d",oam_prov_req.oam_l3_req.mme_data.num_mme_id);
                                                    /* SPR 21738 Fix Start */
                                                    if (oam_prov_req.oam_l3_req.mme_data.num_mme_id == OAM_ONE)
                                                    {
                                                        if(OAM_S1_LINK_DOWN_SET == flag_for_s1_link) 
                                                        {
                                                            OAM_LOG(OAM,OAM_DETAILED,"Sending  reestab mme_conn to to s1ap");
                                                            if(OAM_FAILURE == oam_s1ap_il_send_s1ap_oam_reestab_mme_conn(
                                                                        (s1ap_oam_reestab_mme_conn_t *)&s1ap_close_mme_conn,
                                                                        OAM_MODULE_ID, RRC_MODULE_ID, transid, cid))
                                                            {
                                                                OAM_LOG(OAM,OAM_ERROR,"Error in function oam_s1ap_il_send_s1ap_oam_close_mme_conn: error code");
                                                                OAM_FUN_EXIT_TRACE ();
                                                                return OAM_FAILURE;
                                                            }
                                                        }
                                                        oam_maintain_system_state(OAM_INITIALIZATION_COMPLETE);
                                                        oam_prov_req.system_status.op_state= ENODEB_OP_STATE_ENABLED;
                                                        oam_prov_req.system_status.rftx_status = OAM_TRUE;
                                                        if((cell_to_be_started_by_operator == RRM_TRUE) &&  
                                                                (OAM_ERROR_RETURN_VAL == oam_get_min_rrm_cell_config_idx(CELL_STOP)))
                                                        {
                                                            if(OAM_FAILURE == oam_start_all_cells(p_api_buf, msg_len))
                                                            {
                                                                OAM_LOG(OAM, OAM_ERROR, "Could not send RRM_OAM_CELL_START_REQ for all cells");
                                                                return OAM_FAILURE;
                                                            }  
                                                        }  
                                                        flag_for_s1_link = OAM_S1_LINK_UP_SET;
                                                        /* SPR 21738 Fix End */
                                                        /* CSR 00058746 Fix END*/ 
                                                        /* SPR 1248 FIX END */
                                                    }
                                                }
                                                else if (OAM_S1AP_LINK_DOWN == oam_s1ap_link_status_ind.status)
                                                {
                                                    /* Cov CID 56394 Fix */
                                                    oam_counter_t counter_1 = OAM_ZERO;
                                                    oam_counter_t counter_2 = OAM_ZERO;

                                                    OAM_LOG(OAM,OAM_DETAILED,"S1AP Link Down Received for mme id %d",oam_s1ap_link_status_ind.mme_id);
                                                    for (counter_1 = OAM_ZERO; counter_1 < oam_prov_req.oam_l3_req.mme_data.num_mme_id; counter_1++)
                                                    {
                                                        if(oam_prov_req.oam_l3_req.mme_data.mme_id[counter_1] == oam_s1ap_link_status_ind.mme_id)
                                                            break;  
                                                    }
                                                    /* SPR 15882 START */
                                                    for (counter_2 = counter_1; counter_2 < oam_prov_req.oam_l3_req.mme_data.num_mme_id - OAM_ONE; counter_2++)
                                                    {
                                                        /* Shift all present MME ID to thier left array index */
                                                        oam_prov_req.oam_l3_req.mme_data.mme_id[counter_2] 
                                                            = oam_prov_req.oam_l3_req.mme_data.mme_id[counter_2 + OAM_ONE]; 
                                                        /* SPR 15882 END */
                                                    }              
                                                    /* SPR 14335 Start*/
                                                    if (oam_prov_req.oam_l3_req.mme_data.num_mme_id >= OAM_ONE)
                                                    {
                                                        oam_prov_req.oam_l3_req.mme_data.num_mme_id--;
                                                    }
                                                    /* SPR 14335 End*/

                                                    OAM_LOG(OAM,OAM_DETAILED,"S1AP num active mme =%d",oam_prov_req.oam_l3_req.mme_data.num_mme_id);

                                                    if (oam_prov_req.oam_l3_req.mme_data.num_mme_id < OAM_ONE)
                                                    {
                                                        /* SPR 21738 Fix Start */
                                                        flag_for_s1_link = OAM_S1_LINK_DOWN_SET;
                                                        if(OAM_ERROR_RETURN_VAL == oam_get_min_rrm_cell_config_idx(CELL_START))
                                                        { 
                                                            if(OAM_FAILURE == oam_stop_all_cells(p_api_buf, msg_len))
                                                            {
                                                                OAM_LOG(OAM,OAM_ERROR,"Failed to stop all cells");
                                                                return OAM_FAILURE;
                                                            }


                                                            /* SPR 21738 Fix End */
                                                        }
                                                        /* SPR 21738 Fix Start */
                                                    }
                                                    /* SPR 21738 Fix End */
                                                    s1ap_close_mme_conn.mme_count=OAM_ONE;
                                                    s1ap_close_mme_conn.mme_id[OAM_ZERO]= oam_s1ap_link_status_ind.mme_id;              
                                                    /* SPR 22116 Fix +- */
                                                }
                                                oam_fetch_sctp_data_from_l3_s1ap();
                                            } 
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Failed to parse S1AP_OAM_S1AP_LINK_STATUS_IND");
                                                return OAM_FAILURE;
                                            }
                                            break;
                                        }
        case S1AP_OAM_PROVISION_RESP:
                                        OAM_LOG(OAM, OAM_INFO, "Received S1AP_OAM_PROVISION_RESP from L3");
                                        p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;

                                        retVal = oam_cm_fsm_process_event(p_api_buf,
                                                p_cm_cntxt,
                                                &error_code);

                                        if (OAM_SUCCESS == retVal) {
                                            OAM_LOG(OAM, OAM_DETAILED,
                                                    "Successfully sent S1AP_OAM_PROVISION_RESP to FSM");
                                        }
                                        else {
                                            OAM_LOG(OAM, OAM_ERROR,
                                                    "Failed to send S1AP_OAM_PROVISION_RESP to FSM");
                                        }

                                        if (oam_prov_req.system_status.event_ongoing &
                                                OAM_FSM_INIT_TIME_USR_REQ_ONGOING) {
                                            oam_prov_req.system_status.event_ongoing &=
                                                ~OAM_FSM_INIT_TIME_USR_REQ_ONGOING;
                                            if (OAM_SUCCESS == retVal) {
                                                err_string = OAM_NULL;
                                                err_str_size = OAM_ZERO;
                                                usr_error_code = OAM_ZERO;
                                                usr_resp = OAM_RESULT_SUCCESS;
                                            }
                                            else {
                                                oam_get_err_string_n_err_code(error_code,
                                                        &usr_error_code,
                                                        &err_string);
                                                err_str_size = oam_strlen(err_string) + OAM_ONE;
                                                usr_resp = OAM_RESULT_FAILURE;
                                            }

                                            tcb_found = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                                                    &tcb_data.usr_req_trans_id,
                                                    &tcb_data.usr_intf_src_id,
                                                    &tcb_data.p_orig_xml_parent,
                                                    &tcb_data.p_usr_msg_xml_parent,
                                                    &tcb_data.p_parent_xml_struct_addr);

                                            if (OAM_SUCCESS == tcb_found) {
                                                oam_construct_n_send_set_resp_to_usr(usr_resp,
                                                        usr_error_code,
                                                        (UInt8*)err_string,
                                                        err_str_size,
                                                        OAM_VERSION_ID,
                                                        OAM_MODULE_ID,
                                                        tcb_data.usr_intf_src_id,
                                                        tcb_data.usr_req_trans_id,
                                                        OAM_ZERO, OAM_ZERO,
                                                        &error_code);
                                                oam_update_xml_dom(layer_resp,
                                                        tcb_data.p_orig_xml_parent,
                                                        tcb_data.p_usr_msg_xml_parent,
                                                        tcb_data.p_parent_xml_struct_addr);
                                            }
                                            else {
                                                OAM_LOG(OAM, OAM_WARNING,
                                                        "XML DOM can't be updated as TCB is not found");
                                            }
                                        }
                                        break;

        case S1AP_OAM_GET_SCTP_STATUS_RESP:
                                        {
                                            oam_s1ap_get_sctp_status_resp_t *p_oam_s1ap_get_sctp_status_resp;

                                            if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_s1ap_get_sctp_status_resp_t),(void*)&p_oam_s1ap_get_sctp_status_resp, &error_code))
                                            {  
                                                OAM_LOG(OAM, OAM_ERROR,
                                                        "Memory allocation to p_oam_s1ap_get_sctp_status_resp failed"
                                                        " with Error Code:%d",
                                                        error_code);
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;               
                                            }

                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                            length_read= OAM_ZERO;

                                            OAM_LOG(OAM,OAM_DETAILED, "Received S1AP_OAM_GET_SCTP_STATUS_RESP from l3");


                                            if(OAM_SUCCESS== oam_rrc_il_parse_s1ap_oam_get_sctp_status_resp(p_oam_s1ap_get_sctp_status_resp,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE, 
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        &length_read))
                                            {
                                                if ((OAM_SUCCESS == p_oam_s1ap_get_sctp_status_resp->response) && 
                                                        (S1AP_OAM_MME_STATUS_PARAMS_LIST_PRESENT & p_oam_s1ap_get_sctp_status_resp->bitmask))
                                                {
                                                    oam_populate_correct_s1ap_sctp_response(p_oam_s1ap_get_sctp_status_resp);
                                                }    
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, 
                                                        "Failed to parse S1AP_OAM_GET_SCTP_STATUS_RESP");
                                                /* Coverity ID : 72205 Fix Start*/
                                                oam_mem_free(p_oam_s1ap_get_sctp_status_resp,&error_code);
                                                /* Coverity ID : 72205 Fix End*/
                                                return OAM_FAILURE;
                                            }
                                            /* Coverity ID : 72205 Fix Start*/
                                            oam_mem_free(p_oam_s1ap_get_sctp_status_resp,&error_code);
                                            /* Coverity ID : 72205 Fix End*/
                                        }
                                        break;

                                        /********************************PM_CODE**************************************/
                                        /* CSR 00058587 Fix Start */ 
        case S1AP_OAM_STATUS_RESP:
                                        /* CSR 00058587 Fix End */ 
#ifndef OAM_UT_FRAMEWORK
                                        if(OAM_FAILURE == oam_process_tcb_for_layer_resp(
                                                    p_api_buf,&trans_id,&dest_id))
                                        {
                                            OAM_FUN_EXIT_TRACE();
                                            return OAM_FAILURE;
                                        }
#endif
                                        oam_s1ap_handle_stats_resp(p_api_buf,trans_id,dest_id,&error_code);
                                        break;
                                        /********************************PM_CODE**************************************/

        case X2AP_OAM_INIT_IND:
                                        OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_OAM_INIT_IND from l3");
                                        p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;
                                        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&error_code))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Successfully sent X2AP_OAM_PROVISION_REQ to FSM");
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Failed to send X2AP_OAM_PROVISION_REQ to FSM");
                                            return OAM_FAILURE;
                                        }
                                        break;

        case X2AP_OAM_LINK_UP_IND:
                                        /* SPR-16334 START */
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_OAM_LINK_UP_IND from l3");
                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                            length_read= OAM_ZERO;

#ifndef OAM_SON_ENABLE
                                            oam_global_enb_id_t oam_enbID = {OAM_ZERO};
#endif
                                            oam_x2ap_x2_link_up_t oam_x2ap_x2_link_up;
                                            if (OAM_SUCCESS == oam_rrc_il_parse_x2ap_oam_x2_link_up(&oam_x2ap_x2_link_up,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        &length_read))
                                            {
#ifdef ENDC_ENABLED
                                                /* MENB CHANGES - START */
                                                if ( X2AP_OAM_X2_LINK_UP_ENB_ID_PRESENT &
                                                        oam_x2ap_x2_link_up.bitmask )
                                                {
                                                    oam_prov_req.oam_l3_req.peer_gnb_data.bitmask |= OAM_GB_ENB_ID_PRESENT;
                                                    /* MENB CHANGES - END */
#endif

                                                    oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb++;
                                                    oam_memcpy(&(oam_prov_req.oam_l3_req.peer_enb_data.eNB_id[oam_prov_req.oam_l3_req.
                                                                peer_enb_data.num_peer_enb - OAM_ONE]),
                                                            &(oam_x2ap_x2_link_up.peer_enb_gb_id),
                                                            sizeof(x2_gb_enb_id_t)); 

                                                    oam_memcpy(&(oam_prov_req.oam_l3_req.peer_enb_data.enb_comm_info[oam_prov_req.oam_l3_req.
                                                                peer_enb_data.num_peer_enb - OAM_ONE]),
                                                            &(oam_x2ap_x2_link_up.enb_comm_info),
                                                            sizeof(x2_enb_comm_info_t)); 

                                                    oam_fetch_sctp_data_from_l3_x2ap();
#ifndef OAM_SON_ENABLE
                                                    if(OAM_SUCCESS == 
                                                            oam_send_x2ap_enb_config_update_req_at_link_up(oam_prov_req.oam_l3_req.peer_enb_data))
                                                    {
                                                        OAM_LOG(OAM,OAM_DETAILED, 
                                                                "Sent eNB Config Update request at X2AP_OAM_LINK_UP_IND for eNB ID:");
                                                        oam_x2_convert_l3_enbid_to_oam_enbid(
                                                                &oam_prov_req.oam_l3_req.peer_enb_data.eNB_id[oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb - OAM_ONE],
                                                                &oam_enbID);
                                                        oam_print_enb_id(&oam_enbID); 
                                                    }
                                                    else
                                                    {
                                                        OAM_LOG(OAM,OAM_ERROR, 
                                                                "Unable to Send eNB Config Update request at X2AP_OAM_LINK_UP_IND for eNB ID:"); 
                                                        oam_x2_convert_l3_enbid_to_oam_enbid(
                                                                &oam_prov_req.oam_l3_req.peer_enb_data.eNB_id[oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb - OAM_ONE],
                                                                &oam_enbID);
                                                        oam_print_enb_id(&oam_enbID); 

                                                    }
#endif
#ifdef ENDC_ENABLED
                                                    /* MENB CHANGES - START */
                                                }
                                                else if ( X2AP_OAM_X2_LINK_UP_GNB_ID_PRESENT &
                                                        oam_x2ap_x2_link_up.bitmask )
                                                {
                                                    oam_prov_req.oam_l3_req.peer_gnb_data.bitmask |= OAM_GB_GNB_ID_PRESENT;
                                                    oam_prov_req.oam_l3_req.peer_gnb_data.num_peer_enb++;
                                                    oam_memcpy(&(oam_prov_req.oam_l3_req.peer_gnb_data.gNB_id[oam_prov_req.oam_l3_req.
                                                                peer_gnb_data.num_peer_enb - OAM_ONE]),
                                                            &(oam_x2ap_x2_link_up.peer_gnb_gb_id),
                                                            sizeof(x2_gb_gnb_id_t)); 

                                                    oam_memcpy(&(oam_prov_req.oam_l3_req.peer_gnb_data.enb_comm_info[oam_prov_req.oam_l3_req.
                                                                peer_gnb_data.num_peer_enb - OAM_ONE]),
                                                            &(oam_x2ap_x2_link_up.enb_comm_info),
                                                            sizeof(x2_enb_comm_info_t)); 

                                                    oam_fetch_sctp_data_from_l3_x2ap();
                                                    // config update
                                                }
                                                /* MENB CHANGES - END */
#endif
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Failed to parse X2AP_OAM_LINK_UP_IND");
                                                return OAM_FAILURE;
                                            }
                                        }
                                        /* SPR-16334 END */

                                        break;


        case X2AP_OAM_LINK_DOWN_IND:
                                        OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_OAM_LINK_DOWN_IND from l3");
                                        length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                        length_read= OAM_ZERO;

                                        oam_x2ap_x2_link_down_t oam_x2ap_x2_link_down; 
                                        if (OAM_SUCCESS == oam_rrc_il_parse_x2ap_oam_x2_link_down(&oam_x2ap_x2_link_down,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                    &length_read))
                                        {


                                            oam_counter_t counter_1 = OAM_ZERO;
                                            oam_counter_t counter_2 = OAM_ZERO;
#ifdef ENDC_ENABLED
                                            /* MENB CHANGES - START */
                                            if ( X2AP_OAM_X2_LINK_DOWN_ENB_GB_ID_PRESENT &
                                                    oam_x2ap_x2_link_down.bitmask )
                                            {
                                                /* MENB CHANGES - END */
#endif
                                                for (counter_1 = OAM_ZERO; counter_1 < oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb; counter_1++)
                                                {
                                                    if(OAM_ZERO == oam_memcmp(&(oam_prov_req.oam_l3_req.peer_enb_data.eNB_id[oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb - OAM_ONE]),
                                                                &(oam_x2ap_x2_link_down.peer_enb_gb_id),sizeof(x2_gb_enb_id_t)))
                                                        break;
                                                }

                                                for (counter_2 = counter_1; counter_2 < oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb; counter_2++)
                                                {
                                                    /* AUT BUG FIX start*/
                                                    if( counter_2 != OAM_ZERO)
                                                    {

                                                        oam_prov_req.oam_l3_req.peer_enb_data.eNB_id[counter_2 - 1] = oam_prov_req.oam_l3_req.peer_enb_data.eNB_id[counter_2]; 
                                                    }        
                                                    /* AUT BUG FIX end*/

                                                }        
                                                oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb--;
#ifdef ENDC_ENABLED
                                                /* MENB CHANGES - START */
                                            }
                                            else if ( X2AP_OAM_X2_LINK_DOWN_GNB_GB_ID_PRESENT &
                                                oam_x2ap_x2_link_down.bitmask )
                                            {
                                                for (counter_1 = OAM_ZERO; counter_1 < oam_prov_req.oam_l3_req.peer_gnb_data.num_peer_enb; counter_1++)
                                                {
                                                    if(OAM_ZERO == oam_memcmp(&(oam_prov_req.oam_l3_req.peer_gnb_data.eNB_id[oam_prov_req.oam_l3_req.peer_gnb_data.num_peer_enb - OAM_ONE]),
                                                                &(oam_x2ap_x2_link_down.peer_gnb_gb_id),sizeof(x2_gb_gnb_id_t)))
                                                        break;
                                                }

                                                for (counter_2 = counter_1; counter_2 < oam_prov_req.oam_l3_req.peer_gnb_data.num_peer_enb; counter_2++)
                                                {
                                                    if( counter_2 != OAM_ZERO)
                                                    {

                                                        oam_prov_req.oam_l3_req.peer_gnb_data.gNB_id[counter_2 - 1] = oam_prov_req.oam_l3_req.peer_gnb_data.gNB_id[counter_2]; 
                                                    }        
                                                }        
                                                oam_prov_req.oam_l3_req.peer_gnb_data.num_peer_enb--;
                                            }
                                            /* MENB CHANGES - END */
#endif

                                            oam_fetch_sctp_data_from_l3_x2ap();
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Failed to parse X2AP_OAM_LINK_DOWN_IND");
                                            return OAM_FAILURE;
                                        }
                                        break;

                                        /* SPR-16334 START */
#ifndef OAM_SON_ENABLE
        case X2AP_ENB_CONFIG_UPDATE_RES:
                                        OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_ENB_CONFIG_UPDATE_RES from l3");
                                        length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                        length_read= OAM_ZERO;
                                        oam_x2ap_enb_config_update_resp_t oam_enb_config_update_res = {OAM_ZERO};
                                        oam_global_enb_id_t oam_enbid;

                                        if (OAM_SUCCESS == (oam_return_et)oam_parse_x2ap_enb_config_update_resp(
                                                    &oam_enb_config_update_res,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                    &length_read))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, 
                                                    "Successfully parsed X2AP_ENB_CONFIG_UPDATE_RES from l3");
                                            if (X2AP_OAM_MACRO_ENB_ID_PRESENT & oam_enb_config_update_res.enb2_gb_id.enb_id.presence_bitmask)
                                            {           
                                                oam_enbid.enb_type = OAM_MACRO_ENB;
                                                oam_memcpy(&oam_enbid.enb_id,
                                                        oam_enb_config_update_res.enb2_gb_id.enb_id.macro_enb_id.eNB_id,
                                                        MACRO_ENB_ID_OCTET_SIZE);
                                            }       
                                            else if (X2AP_OAM_HOME_ENB_ID_PRESENT & oam_enb_config_update_res.enb2_gb_id.enb_id.presence_bitmask)
                                            {
                                                oam_enbid.enb_type = OAM_HOME_ENB;
                                                oam_memcpy(&oam_enbid.enb_id,
                                                        oam_enb_config_update_res.enb2_gb_id.enb_id.home_enb_id.eNB_id,
                                                        HOME_ENB_ID_OCTET_SIZE);
                                            }       

                                            if(oam_enb_config_update_res.response == 0)
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, 
                                                        "Failure response X2AP_ENB_CONFIG_UPDATE_RES received for eNB [eNB Id: 0x%x]" ,
                                                        (UInt32)oam_enbid.enb_id);
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, 
                                                        "Success response X2AP_ENB_CONFIG_UPDATE_RES received for eNB [eNB Id: 0x%x]",
                                                        (UInt32)oam_enbid.enb_id);
                                            }

                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_ERROR, "Failed to parse X2AP_ENB_CONFIG_UPDATE_RES");
                                        }

                                        break;
        case X2AP_ADD_ENB_RES:
                                        OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_ADD_ENB_RES from l3");
                                        length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                        length_read= OAM_ZERO;
                                        oam_x2ap_add_enb_res_t oam_add_enb_res = {OAM_ZERO};

                                        if(oam_prov_req.system_status.event_ongoing & OAM_X2AP_ENB_ADD_ONGOING)
                                        {
                                            /* BCOM Compiltaion Fix */
                                            trans_id_resp = get_word_from_header((UInt8 *)p_api_buf);
                                            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id( 
                                                        trans_id_resp, &trans_id, &dest_id))
                                                /* BCOM Compiltaion Fix */
                                            {
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;
                                            }
                                        }
                                        if (OAM_SUCCESS == (oam_return_et)oam_parse_x2ap_add_enb_res(&oam_add_enb_res,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                    &length_read))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Successfully parsed X2AP_ADD_ENB_RES from l3");
                                            if (X2AP_FAILURE_ENB_ADD_LIST_PRESENT &
                                                    oam_add_enb_res.bitmask)
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "X2AP_ADD_ENB_RES Failure for:");
                                                oam_process_add_resp_list(&oam_add_enb_res.failure_enb_list, OAM_FAILURE, trans_id, dest_id);
                                            }                   
                                            if (X2AP_SUCCESS_ENB_ADD_LIST_PRESENT &
                                                    oam_add_enb_res.bitmask)
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "X2AP_ADD_ENB_RES Success for:");
                                                oam_process_add_resp_list(&oam_add_enb_res.success_enb_list, OAM_SUCCESS, trans_id, dest_id);
                                            }
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_WARNING, "Failed to parse X2AP_ADD_ENB_RES");
                                            oam_prov_req.system_status.event_ongoing &= (~OAM_X2AP_ENB_ADD_ONGOING);
                                            /*coverity 109021 fix start*/
                                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                    OAM_ERR_INTERNAL_ERROR, (UInt8 *) "X2AP_ADD_ENB_RES Fail", 
                                                    oam_strlen("X2AP_ADD_ENB_RES Fail")+ OAM_ONE,
                                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                                    dest_id, trans_id,OAM_ZERO,
                                                    OAM_ZERO,&p_err);
                                            /*coverity 109021 fix end*/
                                        }
                                        break;
        case X2AP_DEL_ENB_RES:
                                        length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                        length_read= OAM_ZERO;
                                        oam_x2ap_delete_enb_res_t oam_del_enb_res = {OAM_ZERO};

                                        if(oam_prov_req.system_status.event_ongoing & OAM_X2AP_ENB_DEL_ONGOING)
                                        {
                                            /* BCOM Compiltaion Fix */
                                            trans_id_resp = get_word_from_header((UInt8 *)p_api_buf);
                                            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id( 
                                                        trans_id_resp, &trans_id, &dest_id))
                                                /* BCOM Compiltaion Fix */
                                            {
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;
                                            }
                                            oam_prov_req.system_status.event_ongoing &= ~(OAM_X2AP_ENB_DEL_ONGOING);
                                        }
                                        if (OAM_SUCCESS == (oam_return_et)oam_parse_x2ap_delete_enb_res(&oam_del_enb_res,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                    &length_read))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Successfully parsed X2AP_DEL_ENB_RES from l3");
                                            if(OAM_SUCCESS == oam_del_enb_res.response )
                                            {    
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                        OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id,OAM_ZERO,
                                                        OAM_ZERO,&p_err);
                                            }        
                                            else
                                            {
                                                /*coverity 109021 fix start*/
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR, (UInt8 *) "Failure received from RRC", 
                                                        oam_strlen("Failure received from RRC")+ OAM_ONE,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id,OAM_ZERO,
                                                        OAM_ZERO,&p_err);
                                                /*coverity 109021 fix end*/
                                            }
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_WARNING, "Failed to parse X2AP_ADD_ENB_RES");
                                            /*coverity 109021 fix start*/
                                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                    OAM_ERR_INTERNAL_ERROR, (UInt8 *) "X2AP_DEL_ENB_RES Fail", 
                                                    oam_strlen("X2AP_DEL_ENB_RES Fail")+ OAM_ONE,
                                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                                    dest_id, trans_id,OAM_ZERO,
                                                    OAM_ZERO,&p_err);
                                            /*coverity 109021 fix end*/
                                        }
                                        break;
#endif
                                        /* SPR-16334 END */


        case X2AP_OAM_PROVISION_RESP:
                                        OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_OAM_PROVISION_RESP from l3");
                                        p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;

                                        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,p_cm_cntxt,&error_code))
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Successfully sent X2AP_OAM_PROVISION_RESP to FSM");
                                            /* SPR 22925 Fix + */
#ifndef NMM_INTG_L1_3_8_4_4
                                            /*SPR_15574 Fix Start*/
#ifdef OAM_SON_ENABLE
                                            if((oam_prov_req.system_status.is_nmm_enabled) &&
                                                    (OAM_FALSE == oam_prov_req.oam_tr069_req.connect_to_iHeMS) &&
                                                    (OAM_FALSE == g_oam_nmm_scan_first_time))
                                            {
                                                OAM_LOG(OAM, OAM_DETAILED, "NMM is enabled, sending SON_OAM_SET_NW_SCAN_CONFIG_CMD");
                                                oam_son_send_son_oam_set_nw_scan_config_cmd(
                                                        &oam_prov_req.oam_son_req.nw_scan_config,
                                                        OAM_MODULE_ID,
                                                        SON_MODULE_ID,
                                                        oam_get_new_trans_id(),
                                                        oam_prov_req.cell_cntxt.curr_cell_cid);

                                            }
                                            /* Trigger ICIC feature when eNodeB is not connected to iHeMS */
                                            /*+ SPR 18390*/
                                            OAM_LOG(OAM,OAM_DETAILED, "earfcn_list_size %d pci_list_size %d scan_on_boot %d,is_nmm_enabled %d ",
                                                    oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.earfcn_list_size,
                                                    oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list_size,
                                                    oam_prov_req.oam_son_req.temp_values.scan_on_boot,
                                                    oam_prov_req.system_status.is_nmm_enabled);
                                            /* Start: CSR 00058940 */                
                                            if (OAM_ONE < oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req.earfcn_list_size)
                                            {
                                                /*End: CSR 00058940 */                        
                                                /*son career freq dl tx req*/

                                                if (OAM_SUCCESS ==
                                                        oam_son_send_son_oam_carrier_freq_and_dl_tx_power_req(
                                                            &oam_prov_req.oam_son_req.
                                                            earfcn_pci_selection[OAM_ZERO].oam_son_carrier_freq_and_dl_tx_power_req,
                                                            OAM_MODULE_ID,
                                                            SON_MODULE_ID,
                                                            oam_get_new_trans_id(),
                                                            oam_prov_req.cell_cntxt.curr_cell_cid))
                                                {
                                                    OAM_LOG(OAM,OAM_DETAILED, "successfully sent SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_REQ");
                                                    /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                                                    /* SPR 18540 FIX START*/
                                                    oam_prov_req.system_status.event_ongoing |= OAM_SON_CARRIER_FREQ_ONGOING;
                                                    /* SPR 18540 FIX END*/
                                                    if( OAM_FAILURE == oam_maintain_tcb_with_timer(oam_get_new_trans_id(),OAM_SUB_MODULE_SON,
                                                                OAM_TRANS_SON,msg_len,p_api_buf))
                                                    {
                                                        /* BCOM Compiltaion Fix */
                                                        trans_id_resp = get_word_from_header((UInt8 *)p_api_buf);
                                                        if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id( 
                                                                    trans_id_resp, &trans_id, &dest_id))
                                                            /* BCOM Compiltaion Fix */
                                                        {
                                                            OAM_FUN_EXIT_TRACE();
                                                            return OAM_FAILURE;
                                                        }
                                                    }
                                                    /*- SPR 18390*/
#endif
                                                    /* SPR 9620 CHANGE END */
                                                }
                                                else
                                                {
                                                    OAM_LOG(OAM,OAM_DETAILED, "Failed to send SON_OAM_CARRIER_FREQ_AND_DL_UL_POWER_SELECTION_REQ");
                                                    /* Start: CSR 00058940 */
                                                    return OAM_FAILURE;
                                                }
                                            }
                                            /*+ SPR 18393*/
                                            /* Spr 17753 Changes Start */

                                            else if ((OAM_ONE < oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list_size) &&
                                                    (OAM_TRUE == oam_prov_req.system_status.is_nmm_enabled))
                                                /* Spr 17753 Changes End */
                                            {
                                                initialisation_flag |= INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK;
                                                if (OAM_ONE < oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req.pci_list_size)
                                                {
                                                    if(OAM_SUCCESS == 
                                                            oam_son_send_son_oam_pci_selection_req(&(oam_prov_req.oam_son_req.earfcn_pci_selection[OAM_ZERO].oam_son_pci_selection_req),
                                                                OAM_MODULE_ID, SON_MODULE_ID, trans_id, oam_prov_req.cell_cntxt.curr_cell_cid))
                                                    {
                                                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_SELECTION_REQ sent Successfully!!");
                                                        /* SPR 9620 CHANGE START */  
#ifndef OAM_UT_FRAMEWORK
                                                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                                                                    OAM_TRANS_SON,msg_len,p_api_buf))
                                                        {
                                                            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                                                            /* Coverity_99557 Fix Start */
                                                            return  OAM_FAILURE;
                                                            /* Coverity_99557 Fix End */
                                                        }
#endif
                                                        /* SPR 9620 CHANGE END */
                                                    }
                                                    else
                                                    {
                                                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PCI_SELECTION_REQ sent Failure");
                                                        return OAM_FAILURE;
                                                    }
                                                }
                                                else
                                                {
                                                    initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;
                                                }
                                            }

                                            /*check if scan_on_boot is enabled then trigger NW scan*/
                                            else if((OAM_TRUE == oam_prov_req.oam_son_req.temp_values.scan_on_boot) &&
                                                    (OAM_TRUE == oam_prov_req.system_status.is_nmm_enabled))
                                                /*SPR_16048 Fix End*/
                                            {
                                                initialisation_flag |= INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK;
                                                initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;

                                                /*SPR_16636 Fix start*/
                                                if(OAM_TRUE == oam_prov_req.oam_igd_params.rem_lte_params.scan_periodically)
                                                {
                                                    if(OAM_SUCCESS == \
                                                            oam_son_send_son_oam_periodic_nw_scan_req(&(oam_prov_req.oam_son_req.periodic_nw_scan),
                                                                OAM_MODULE_ID,SON_MODULE_ID,oam_get_new_trans_id(),OAM_ZERO))
                                                    {
                                                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PERIODIC_NW_SCAN_REQ sent Successfully!!");
                                                    }
                                                    else
                                                    {
                                                        OAM_LOG(OAM, OAM_DETAILED, "SON_OAM_PERIODIC_NW_SCAN_REQ sent Failure");
                                                        return OAM_FAILURE;
                                                    }
                                                }
                                                else
                                                {
                                                    /*SPR_16636 Fix end*/
                                                    if(OAM_SUCCESS == \
                                                            oam_son_send_son_oam_nw_scan_req(&(oam_prov_req.oam_son_req.nw_scan),
                                                                OAM_MODULE_ID,SON_MODULE_ID,oam_get_new_trans_id(),OAM_ZERO))
                                                    {
                                                        OAM_LOG(OAM,OAM_DETAILED, "SON_NW_SCAN_REQ sent Successfully");
                                                    }
                                                    else
                                                    {
                                                        OAM_LOG(OAM,OAM_ERROR, "SON_NW_SCAN_REQ sent Failuer");
                                                    }
                                                    /*SPR_16636 Fix start*/
                                                }
                                                /*SPR_16636 Fix end*/
                                            }


                                            /*SPR_15770 Fix end*/
                                            /* SPR 20788 FIXED START */           
                                            else if(((OAM_ZERO == oam_prov_req.oam_tr069_req.tr069_mode) &&
                                                        (ENODEB_ADMIN_STATE_UNLOCKED == oam_prov_req.system_status.admin_state)) || 
                                                    ((ENODEB_ADMIN_STATE_LOCKED == oam_prov_req.system_status.admin_state) && 
                                                     (ENODEB_ADMIN_STATE_UNLOCKED == local_prov_req.system_status.admin_state))|| 
                                                    ((ENODEB_ADMIN_STATE_UNLOCKED == oam_prov_req.system_status.admin_state) &&
                                                     (ENODEB_ADMIN_STATE_UNLOCKED == local_prov_req.system_status.admin_state)&&
                                                     (OAM_ONE == oam_prov_req.oam_tr069_req.tr069_mode)))
                                            {
                                                OAM_LOG(OAM, OAM_INFO, "lock-unlock unlock-unlock");
                                                /* SPR 20788 FIXED END */            
                                                initialisation_flag |= INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK;
                                                initialisation_flag |= INIT_TIME_PCI_SELECTION_MASK;

                                                if ((LOWER_LAYERS_PROVISIONING_MASK & initialisation_flag) &&
                                                        (INIT_TIME_PCI_SELECTION_MASK & initialisation_flag) &&
                                                        (INIT_TIME_CARRIER_FREQ_AND_POWER_SELECTION_MASK & initialisation_flag))
                                                {                
                                                    init_time_startup = OAM_ZERO;   
                                                    UInt16    gen_trans_id = OAM_ZERO;
                                                    UInt8 cell_cnt = OAM_ZERO;
                                                    for (cell_cnt = OAM_ZERO;cell_cnt < oam_prov_req.num_cells_configured; ++cell_cnt) {
                                                        p_rrm_cell_config = &RRM_PROV_REQ.oam_rrm_cell_config_req[cell_cnt];

                                                        /*SPR 20908 Start*/
                                                        /*SPR 21206 Start*/
                                                            if((l2_comm_info[p_rrm_cell_config->operator_info.associated_layer2_inst].init_flag & EGTPU_OAM_INIT_CNF)
                                                                    &&(l2_comm_info[p_rrm_cell_config->operator_info.associated_layer2_inst].init_flag & MAC_OAM_INIT_CNF)
                                                                    &&(l2_comm_info[p_rrm_cell_config->operator_info.associated_layer2_inst].init_flag & RLC_OAM_INIT_CNF )
                                                                    &&(l2_comm_info[p_rrm_cell_config->operator_info.associated_layer2_inst].init_flag & PDCP_OAM_INIT_CNF))
                                                            {
                                                                /*SPR 21206 End*/
                                                                OAM_LOG(OAM, OAM_DETAILED, "Sending Cell Config to RRM for cell index  %d",cell_cnt);
                                                                retVal =
                                                                    oam_handle_initial_admin_state_unlocked((UInt8 *)INVALID_ARGUMENT,p_rrm_cell_config,
                                                                            &gen_trans_id);
                                                            }
                                                            else
                                                            {
                                                                OAM_LOG(OAM, OAM_DETAILED, "INIT not received from all l2 sub modules for cell index = %d",cell_cnt);
                                                            }
                                                        /*SPR 20908 End*/
                                                        /*Coverity_99556 Fix Start */
                                                        if(OAM_FAILURE == retVal)
                                                        {
                                                            OAM_LOG(OAM,OAM_ERROR, "Failed in oam_handle_initial_admin_state_unlocked");
                                                            return OAM_FAILURE; 
                                                        }
                                                        /* Coverity_99556 Fix End */
                                                    }
                                                }
                                            }
                                            /*- SPR 18393*/
#endif
                                            /*SPR_15574 Fix End*/ 
#endif
                                            /* SPR 22925 Fix - */

                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Failed to send X2AP_OAM_PROVISION_RESP to FSM");
                                            return OAM_FAILURE;
                                        }
                                        break;
        case X2AP_OAM_GET_SCTP_STATUS_RESP:
                                        {
                                            oam_x2ap_get_sctp_status_resp_t *p_oam_x2ap_get_sctp_status_resp;
                                            if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_x2ap_get_sctp_status_resp_t),(void*)&p_oam_x2ap_get_sctp_status_resp, &error_code))
                                            {
                                                OAM_LOG(OAM, OAM_ERROR,
                                                        "Memory allocation to p_oam_x2ap_get_sctp_status_resp failed"
                                                        " with Error Code:%d",
                                                        error_code);
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;               
                                            } 
                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                            length_read = OAM_ZERO;

                                            OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_OAM_GET_SCTP_STATUS_RESP from l3");


                                            if(OAM_SUCCESS== oam_rrc_il_parse_x2ap_oam_get_sctp_status_resp(p_oam_x2ap_get_sctp_status_resp,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        &length_read))
                                            {
                                                if ((OAM_SUCCESS == p_oam_x2ap_get_sctp_status_resp->response) &&  (X2AP_OAM_GLOBAL_ENB_STATUS_PARAMS_LIST_PRESENT & p_oam_x2ap_get_sctp_status_resp->bitmask)) 
                                                {
                                                    oam_populate_correct_x2ap_sctp_response(p_oam_x2ap_get_sctp_status_resp);  
                                                }   
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, 
                                                        "Failed to parse X2AP_OAM_GET_SCTP_STATUS_RESP");
                                                /* Coverity ID : 72206 Fix Start*/
                                                oam_mem_free(p_oam_x2ap_get_sctp_status_resp,&error_code);
                                                /* Coverity ID : 72206 Fix Start*/
                                                return OAM_FAILURE;
                                            }
                                            /* Coverity ID : 72206 Fix Start*/
                                            oam_mem_free(p_oam_x2ap_get_sctp_status_resp,&error_code);
                                            /* Coverity ID : 72206 Fix Start*/
                                        }
                                        break;

                                        /* EMBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
        case M2AP_OAM_INIT_IND:
                                        OAM_LOG(OAM, OAM_DETAILED, "Received M2AP_INIT_LAYER_IND from l3");
                                        p_cm_cntxt->event = OAM_CM_EV_LAYER_REQ;

                                        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,
                                                    p_cm_cntxt,
                                                    &error_code))
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED, "Successfully sent "
                                                    "m2ap_oam_init_config_req to FSM");
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Failed to send "
                                                    "m2ap_oam_init_config_req to FSM");
                                            return OAM_FAILURE;
                                        }
                                        break;

        case M2AP_OAM_PROVISION_RESP:
                                        OAM_LOG(OAM, OAM_DETAILED, "Received M2AP_INIT_LAYER_CNF from L3");
                                        p_cm_cntxt->event = OAM_CM_EV_LAYER_RES;

                                        if (OAM_SUCCESS == oam_cm_fsm_process_event(p_api_buf,
                                                    p_cm_cntxt,
                                                    &error_code))
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED,
                                                    "Successfully sent M2AP init cnf to FSM");
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Failed to send M2AP init cnf to FSM");
                                            return OAM_FAILURE;
                                        }
                                        break;

        case M2AP_OAM_CONFIG_UPDATE_RESP:
                                        OAM_LOG(OAM, OAM_DETAILED,
                                                "Received M2AP_OAM_CONFIG_UPDATE_RESP from RRC");
#ifndef OAM_UT_FRAMEWORK
                                        retVal = oam_process_tcb_for_layer_resp_ext(p_api_buf,
                                                &tcb_data.usr_req_trans_id,
                                                &tcb_data.usr_intf_src_id,
                                                &tcb_data.p_orig_xml_parent,
                                                &tcb_data.p_usr_msg_xml_parent,
                                                &tcb_data.p_parent_xml_struct_addr);

                                        if (OAM_SUCCESS == retVal)
                                        {
                                            tcb_found_1 = OAM_TRUE;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Failed to fetch TCB details");
                                        }

#endif
                                        retVal = oam_mem_alloc(sizeof(m2ap_oam_config_update_resp_t),
                                                (void**)&p_m2ap_config_update_resp,
                                                &error_code);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed");
                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            err_str_size = oam_strlen(err_string) + OAM_ONE;
                                            usr_resp = OAM_RESULT_FAILURE;

                                            if (tcb_found_1)
                                            {
                                                oam_construct_n_send_set_resp_to_usr(usr_resp,
                                                        usr_error_code,
                                                        (UInt8*)err_string,
                                                        err_str_size,
                                                        OAM_VERSION_ID,
                                                        OAM_MODULE_ID,
                                                        tcb_data.usr_intf_src_id,
                                                        tcb_data.usr_req_trans_id,
                                                        OAM_ZERO, OAM_ZERO,
                                                        &error_code);
                                            }
                                            break;
                                        }

                                        oam_memset(p_m2ap_config_update_resp, OAM_ZERO,
                                                sizeof(m2ap_oam_config_update_resp_t));

                                        length_read = OAM_ZERO;
                                        length_left = get_word_from_header((UInt8*)p_api_buf +
                                                OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                        p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                                        retVal = oam_rrc_il_parse_m2ap_oam_config_update_resp(
                                                p_m2ap_config_update_resp,
                                                p_api_buf,
                                                length_left,
                                                &length_read);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Parsing Failed in "
                                                    "M2AP_OAM_CONFIG_UPDATE_RESP");

                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            err_str_size = oam_strlen(err_string) + OAM_ONE;
                                            usr_resp = OAM_RESULT_FAILURE;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED, "Parsing Successful in "
                                                    "M2AP_OAM_CONFIG_UPDATE_RESP");

                                            if (M2AP_SUCCESS == p_m2ap_config_update_resp->response)
                                            {
                                                layer_resp = OAM_SUCCESS;
                                                OAM_LOG(OAM, OAM_INFO, "Success response received in "
                                                        "M2AP_OAM_CONFIG_UPDATE_RESP");
                                                err_string = OAM_NULL;
                                                err_str_size = OAM_ZERO;
                                                usr_error_code = OAM_ZERO;
                                                usr_resp = OAM_RESULT_SUCCESS;
                                                /* Updating the user modified values in the strucutre */
                                                oam_memcpy(&M2AP_PROV_REQ, &LOCAL_M2AP_PROV_REQ,
                                                        sizeof(oam_m2ap_provision_req_t));
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM, OAM_ERROR, "Failure response received in "
                                                        "M2AP_OAM_CONFIG_UPDATE_RESP"
                                                        " with error code: %d",
                                                        p_m2ap_config_update_resp->m2ap_oam_cause);

                                                err_string = oam_m2ap_resp_code_to_str(
                                                        p_m2ap_config_update_resp->m2ap_oam_cause);

                                                layer_resp = OAM_FAILURE;
                                                err_str_size = oam_strlen(err_string) + OAM_ONE;
                                                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                                                usr_resp = OAM_RESULT_FAILURE;
                                            }
                                        }

                                        if (tcb_found_1) {
                                            oam_update_xml_dom(layer_resp,
                                                    tcb_data.p_orig_xml_parent,
                                                    tcb_data.p_usr_msg_xml_parent,
                                                    tcb_data.p_parent_xml_struct_addr);

                                            oam_construct_n_send_set_resp_to_usr(usr_resp,
                                                    usr_error_code,
                                                    (UInt8*)err_string,
                                                    err_str_size,
                                                    OAM_VERSION_ID,
                                                    OAM_MODULE_ID,
                                                    tcb_data.usr_intf_src_id,
                                                    tcb_data.usr_req_trans_id,
                                                    OAM_ZERO, OAM_ZERO,
                                                    &error_code);
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_WARNING,
                                                    "XML DOM can't be updated as TCB is not found");
                                        }

                                        oam_mem_free(p_m2ap_config_update_resp, &error_code);
                                        break;

        case M2AP_OAM_MCE_LINK_STATUS_IND:
                                        OAM_LOG(OAM, OAM_INFO,
                                                "Received M2AP_OAM_MCE_LINK_STATUS_IND from M2AP");

                                        retVal = oam_mem_alloc(sizeof(m2ap_oam_mce_link_status_ind_t),
                                                (void**)&p_m2ap_mce_link_status_ind,
                                                &error_code);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed");
                                            break;
                                        }

                                        oam_memset(p_m2ap_mce_link_status_ind, OAM_ZERO,
                                                sizeof(m2ap_oam_mce_link_status_ind_t));

                                        length_read = OAM_ZERO;
                                        length_left = get_word_from_header((UInt8*)p_api_buf +
                                                OAM_INTF_HDR_MSG_SIZE_OFFSET);

                                        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                        p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                                        retVal = oam_rrc_il_parse_m2ap_oam_mce_link_status_ind(
                                                p_m2ap_mce_link_status_ind,
                                                p_api_buf,
                                                length_left,
                                                &length_read);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Parsing Failed in "
                                                    "M2AP_OAM_MCE_LINK_STATUS_IND");
                                            oam_mem_free(p_m2ap_mce_link_status_ind, &error_code);
                                            return retVal;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED, "Parsing Successful in "
                                                    "M2AP_OAM_MCE_LINK_STATUS_IND");
                                        }

                                        if (p_m2ap_mce_link_status_ind->m2_link_status)
                                        {
                                            OAM_LOG(OAM, OAM_INFO, "M2AP MCE Link goes up");

                                            OAM_ALARM(RRC_M2AP_CONNECTION_SUCC_ALARM_ID, WARNING,
                                                    NEW_NOTIFICATION,
                                                    COMMUNICATIONS_ALARM,
                                                    UNAVAILABLE,
                                                    EXPEDITED_ALARM,
                                                    "M2AP",
                                                    "MCE Link Up",
                                                    oam_prov_req.cell_cntxt.curr_cell_cid);
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_INFO, "M2AP MCE Link goes down");

                                            OAM_ALARM(RRC_M2AP_CONNECTION_FAIL_ALARM_ID, WARNING,
                                                    NEW_NOTIFICATION,
                                                    COMMUNICATIONS_ALARM,
                                                    UNAVAILABLE,
                                                    EXPEDITED_ALARM,
                                                    "M2AP",
                                                    "MCE Link Down",
                                                    oam_prov_req.cell_cntxt.curr_cell_cid);
                                        }

                                        oam_prov_req.oam_l3_req.oam_m2ap_req.
                                            mce_link_status = p_m2ap_mce_link_status_ind->m2_link_status;

                                        oam_mem_free(p_m2ap_mce_link_status_ind, &error_code);

                                        break;

        case M2AP_OAM_SET_LOG_LEVEL_RESP:
                                        OAM_LOG(OAM, OAM_INFO, "Received M2AP_OAM_SET_LOG_LEVEL_RESP "
                                                "from RRC");
#ifndef OAM_UT_FRAMEWORK
                                        retVal = oam_process_tcb_for_layer_resp(p_api_buf,
                                                &trans_id,
                                                &dest_id);

                                        if (OAM_SUCCESS == retVal)
                                        {
                                            tcb_found_1 = OAM_TRUE;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Failed to fetch TCB details");
                                            OAM_FUN_EXIT_TRACE();
                                            return retVal;
                                        }
#endif

                                        retVal = oam_mem_alloc(sizeof(m2ap_oam_set_log_level_resp_t),
                                                (void**)&p_m2ap_set_log_level_resp,
                                                &error_code);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed");
                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            err_str_size = oam_strlen(err_string) + OAM_ONE;
                                            usr_resp = OAM_RESULT_FAILURE;

                                            if (tcb_found_1)
                                            {
                                                oam_construct_n_send_set_resp_to_usr(usr_resp,
                                                        usr_error_code,
                                                        (UInt8*)err_string,
                                                        err_str_size,
                                                        OAM_VERSION_ID,
                                                        OAM_MODULE_ID,
                                                        dest_id,
                                                        trans_id,
                                                        OAM_ZERO, OAM_ZERO,
                                                        &error_code);
                                            }
                                        }

                                        oam_memset(p_m2ap_set_log_level_resp, OAM_ZERO,
                                                sizeof(m2ap_oam_set_log_level_resp_t));

                                        length_read = OAM_ZERO;
                                        length_left = get_word_from_header((UInt8*)p_api_buf +
                                                OAM_INTF_HDR_MSG_SIZE_OFFSET);

                                        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                        p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                                        retVal = oam_rrc_il_parse_m2ap_oam_set_log_level_resp(
                                                p_m2ap_set_log_level_resp,
                                                p_api_buf,
                                                length_left,
                                                &length_read);

                                        if (OAM_SUCCESS == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED, "Parsing Successful in "
                                                    "M2AP_OAM_SET_LOG_LEVEL_RESP");
                                            if (M2AP_SUCCESS == p_m2ap_set_log_level_resp->response)
                                            {
                                                OAM_LOG(OAM, OAM_INFO, "Success response received in "
                                                        "M2AP_OAM_SET_LOG_LEVEL_RESP");
                                                err_string = OAM_NULL;
                                                err_str_size = OAM_ZERO;
                                                usr_error_code = OAM_ZERO;
                                                usr_resp = OAM_RESULT_SUCCESS;
                                                /* Updating the user modified values in the strucutre */
                                                M2AP_PROV_REQ.log_level = LOCAL_M2AP_PROV_REQ.log_level;
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM, OAM_ERROR, "Failure response received in "
                                                        "M2AP_OAM_SET_LOG_LEVEL_RESP");

                                                err_string = "Internal error";

                                                err_str_size = oam_strlen(err_string) + OAM_ONE;
                                                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                                                usr_resp = OAM_RESULT_FAILURE;
                                            }
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_ERROR, "Parsing Failed in "
                                                    "M2AP_OAM_SET_LOG_LEVEL_RESP");

                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            err_str_size = oam_strlen(err_string) + OAM_ONE;
                                            usr_resp = OAM_RESULT_FAILURE;
                                        }

                                        if (tcb_found_1) {
                                            oam_construct_n_send_set_resp_to_usr(usr_resp,
                                                    usr_error_code,
                                                    (UInt8*)err_string,
                                                    err_str_size,
                                                    OAM_VERSION_ID,
                                                    OAM_MODULE_ID,
                                                    dest_id,
                                                    trans_id,
                                                    OAM_ZERO, OAM_ZERO,
                                                    &error_code);
                                        }

                                        oam_mem_free(p_m2ap_set_log_level_resp, &error_code);
                                        break;
        case M2AP_OAM_GET_LOG_LEVEL_RESP:
                                        OAM_LOG(OAM, OAM_DETAILED,
                                                "Received M2AP_OAM_GET_LOG_LEVEL_RESP from M2AP");
#ifndef OAM_UT_FRAMEWORK
                                        retVal = oam_process_tcb_for_layer_resp(p_api_buf,
                                                &trans_id,
                                                &dest_id);
                                        /* Coverity 93565 Fix Start */
                                        if (OAM_SUCCESS == retVal)
                                        {
                                            tcb_found_1 = OAM_TRUE;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Failed to fetch TCB details");
                                            OAM_FUN_EXIT_TRACE();
                                            return retVal;
                                        }
                                        /* Coverity 93565 Fix End */
#endif

                                        retVal = oam_mem_alloc(sizeof(m2ap_oam_get_log_level_resp_t),
                                                (void**)&p_m2ap_get_log_level_resp,
                                                &error_code);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed");
                                            if (tcb_found_1)
                                            {
                                                oam_construct_n_send_get_resp_to_usr(
                                                        OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        OAM_VERSION,
                                                        OAM_MODULE_ID,dest_id,
                                                        trans_id,
                                                        OAM_ZERO, OAM_ZERO,
                                                        "M2AP FAILURE RESPONSE",
                                                        &error_code
                                                        );
                                                return retVal;
                                            }
                                        }

                                        oam_memset(p_m2ap_get_log_level_resp, OAM_ZERO,
                                                sizeof(m2ap_oam_get_log_level_resp_t));

                                        length_read = OAM_ZERO;
                                        length_left = get_word_from_header((UInt8*)p_api_buf +
                                                OAM_INTF_HDR_MSG_SIZE_OFFSET);

                                        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                        p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                                        retVal = oam_rrc_il_parse_m2ap_oam_get_log_level_resp(
                                                p_m2ap_get_log_level_resp,
                                                p_api_buf,
                                                length_left,
                                                &length_read);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR,
                                                    "Failed to parse M2AP_OAM_GET_LOG_LEVEL_RESP");
                                            oam_construct_n_send_get_resp_to_usr(
                                                    OAM_RESULT_FAILURE,
                                                    OAM_ERR_INTERNAL_ERROR,
                                                    OAM_VERSION,
                                                    OAM_MODULE_ID,dest_id,
                                                    trans_id,
                                                    OAM_ZERO, OAM_ZERO,
                                                    "Internal Error",
                                                    &error_code
                                                    );
                                            oam_mem_free(p_m2ap_get_log_level_resp, &error_code);
                                            OAM_FUN_EXIT_TRACE();
                                            return retVal;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED,
                                                    "Successfully parse M2AP_OAM_GET_LOG_LEVEL_RESP");
                                            if (OAM_FAILURE == oam_mem_alloc((size_x * sizeof(UInt16 *)),(void *)&temp_arr,&error_code))
                                            {
                                                OAM_LOG(OAM,OAM_ERROR,
                                                        "\nError in Memory Allocation with error code %d",
                                                        error_code);
                                                /* Coverity Fix 97676 Start */
                                                oam_mem_free(p_m2ap_get_log_level_resp, &error_code);
                                                /* Coverity Fix 97676 End */
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;
                                            }

                                            for (loop_counter = OAM_ZERO; loop_counter < size_x; loop_counter++)
                                            {
                                                if(OAM_FAILURE == oam_mem_alloc((size_y * sizeof(UInt16)),(void *)&temp_arr[loop_counter],&error_code))
                                                {
                                                    OAM_LOG(OAM,OAM_ERROR,"\nError in Memory Allocation with error code %d",
                                                            error_code);
                                                    for(loop_counter1 = OAM_ZERO ;loop_counter1 < loop_counter;loop_counter1++)
                                                    {
                                                        oam_mem_free(temp_arr[loop_counter1], &error_code);
                                                    }
                                                    oam_mem_free(temp_arr, &error_code);
                                                    /* Coverity Fix 97676 Start */
                                                    oam_mem_free(p_m2ap_get_log_level_resp, &error_code);
                                                    /* Coverity Fix 97676 End */
                                                    OAM_FUN_EXIT_TRACE();
                                                    return OAM_FAILURE;
                                                }
                                                oam_memset(temp_arr[loop_counter], 0x00, (size_y * sizeof(UInt16)));
                                            }
                                            oam_sprintf((char *)temp_arr[str_count++],
                                                    "%s=%d",
                                                    "M2AP Log Level:",
                                                    p_m2ap_get_log_level_resp->
                                                    response);
                                            oam_construct_n_send_gpv_response((UInt8 *)"Show.Log.Level",
                                                    temp_arr,
                                                    str_count,
                                                    trans_id,
                                                    &error_code,
                                                    dest_id,
                                                    OAM_ZERO,OAM_ZERO);
                                            for(loop_counter1 = OAM_ZERO ;loop_counter1 < loop_counter;loop_counter1++)
                                            {
                                                oam_mem_free(temp_arr[loop_counter1], &error_code);
                                            }
                                            oam_mem_free(temp_arr, &error_code);
                                        }
                                        oam_mem_free(p_m2ap_get_log_level_resp, &error_code);
                                        OAM_FUN_EXIT_TRACE();
                                        return retVal;
                                        break;

        case M2AP_OAM_GET_STAT_RESP:
                                        /* SPR 18484 Fix Start */
                                        OAM_LOG(OAM, OAM_DETAILED,
                                                "Received M2AP_OAM_GET_STAT_RESP from M2AP");
                                        /* SPR 18484 Fix End */
#ifndef OAM_UT_FRAMEWORK
                                        retVal = oam_process_tcb_for_layer_resp(p_api_buf,
                                                &trans_id,
                                                &dest_id);
                                        /* Coverity 93565 Fix Start */
                                        if (OAM_SUCCESS == retVal)
                                        {
                                            tcb_found_1 = OAM_TRUE;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Failed to fetch TCB details");
                                            OAM_FUN_EXIT_TRACE();
                                            return retVal;
                                        }
                                        /* Coverity 93565 Fix End */
#endif

                                        retVal = oam_mem_alloc(sizeof(m2ap_oam_get_stat_resp_t),
                                                (void**)&p_m2ap_get_stat_resp,
                                                &error_code);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed");
                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            err_str_size = oam_strlen(err_string) + OAM_ONE;
                                            usr_resp = OAM_RESULT_FAILURE;

                                            if (tcb_found_1)
                                            {
                                                oam_construct_n_send_get_resp_to_usr(
                                                        /* Coverity 97681 Fix Start */
                                                        usr_resp,
                                                        /* Coverity 97681 Fix End */
                                                        /* Coverity 97679 Fix Start */
                                                        err_str_size,
                                                        /* Coverity 97679 Fix End */
                                                        OAM_VERSION,
                                                        OAM_MODULE_ID,dest_id,
                                                        trans_id,
                                                        OAM_ZERO, OAM_ZERO,
                                                        "Internal Error",
                                                        &error_code
                                                        );
                                            }
                                        }

                                        oam_memset(p_m2ap_get_stat_resp, OAM_ZERO,
                                                sizeof(m2ap_oam_get_stat_resp_t));

                                        length_read = OAM_ZERO;
                                        length_left = get_word_from_header((UInt8*)p_api_buf +
                                                OAM_INTF_HDR_MSG_SIZE_OFFSET);

                                        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                        p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                                        retVal = oam_rrc_il_parse_m2ap_oam_get_stat_resp(
                                                p_m2ap_get_stat_resp,
                                                p_api_buf,
                                                length_left,
                                                &length_read);

                                        if (OAM_SUCCESS == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED,
                                                    "Successfully parse M2AP_OAM_GET_STAT_RESP");
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR,
                                                    "Failed to parse M2AP_OAM_GET_STAT_RESP");

                                            oam_mem_free(p_m2ap_get_stat_resp, &error_code);
                                            OAM_FUN_EXIT_TRACE();
                                            return retVal;
                                        }


                                        retVal = oam_handle_m2ap_get_stat_resp(p_m2ap_get_stat_resp, 
                                                trans_id,
                                                dest_id,
                                                &error_code);
                                        if (OAM_SUCCESS == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED,
                                                    "OAM M2AP GET STAT RESP Handling :SUCCESS");
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR,
                                                    "OAM M2AP GET STAT RESP Handling :FAILED");
                                            error_code = NO_ERROR;
                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            err_str_size = oam_strlen(err_string) + OAM_ONE;
                                            usr_resp = OAM_RESULT_FAILURE;

                                            if (tcb_found_1)
                                            {
                                                oam_construct_n_send_get_resp_to_usr(
                                                        /* Coverity 97681 Fix Start */
                                                        usr_resp,
                                                        /* Coverity 97681 Fix End */
                                                        /* Coverity 97679 Fix Start */
                                                        err_str_size,
                                                        /* Coverity 97679 Fix End */
                                                        OAM_VERSION,
                                                        OAM_MODULE_ID,dest_id,
                                                        trans_id,
                                                        OAM_ZERO, OAM_ZERO,
                                                        "No Data to Display",
                                                        &error_code
                                                        );
                                            }
                                        }

                                        oam_mem_free(p_m2ap_get_stat_resp, &error_code);
                                        break;
        case M2AP_OAM_ALARM_NOTIFICATION_IND:
                                        OAM_LOG(OAM, OAM_DETAILED,
                                                "Received M2AP_OAM_ALARM_NOTIFICATION_IND from M2AP");


                                        retVal = oam_mem_alloc(sizeof(m2ap_oam_alarm_notification_ind_t),
                                                (void**)&p_m2ap_notif_ind,
                                                &error_code);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed with "
                                                    "error cause %s", err_string);

                                            break;
                                        }

                                        oam_memset(p_m2ap_notif_ind, OAM_ZERO,
                                                sizeof(m2ap_oam_alarm_notification_ind_t));

                                        length_read = OAM_ZERO;
                                        length_left = get_word_from_header((UInt8*)p_api_buf +
                                                OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                        p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                                        retVal = oam_rrc_il_parse_m2ap_oam_alarm_notification_ind(
                                                p_m2ap_notif_ind,
                                                p_api_buf,
                                                length_left,
                                                &length_read);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Parsing Failed in "
                                                    "M2AP_OAM_ALARM_NOTIFICATION_IND");
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED, "Parsing Successful in "
                                                    "M2AP_OAM_ALARM_NOTIFICATION_IND");

                                            oam_handle_m2ap_alarm_ind(p_m2ap_notif_ind);
                                        }


                                        oam_mem_free(p_m2ap_notif_ind, &error_code);
                                        break;
        case M2AP_OAM_SESSION_DETAILS_RESP:
                                        OAM_LOG(OAM, OAM_DETAILED,
                                                "Received M2AP_OAM_SESSION_DETAILS_RESP from M2AP");
                                        /* 7.0 OAM_SSI Fix Start-End */
#ifndef OAM_UT_FRAMEWORK
                                        retVal = oam_process_tcb_for_layer_resp(p_api_buf,
                                                &trans_id,
                                                &dest_id);
                                        /* Coverity 93565 Fix Start */
                                        if (OAM_SUCCESS == retVal)
                                        {
                                            tcb_found_1 = OAM_TRUE;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Failed to fetch TCB details");
                                            OAM_FUN_EXIT_TRACE();
                                            return retVal;
                                        }
                                        /* Coverity 93565 Fix End */
#endif

                                        retVal = oam_mem_alloc(sizeof(m2ap_oam_session_details_resp_t),
                                                (void**)&p_m2ap_session_details_resp,
                                                &error_code);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed");
                                            if (tcb_found_1)
                                            {
                                                oam_construct_n_send_get_resp_to_usr(
                                                        OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        OAM_VERSION,
                                                        OAM_MODULE_ID,dest_id,
                                                        trans_id,
                                                        OAM_ZERO, OAM_ZERO,
                                                        "M2AP FAILURE RESPONSE",
                                                        &error_code
                                                        );
                                                return retVal;
                                            }
                                        }

                                        oam_memset(p_m2ap_session_details_resp, OAM_ZERO,
                                                sizeof(m2ap_oam_session_details_resp_t));

                                        length_read = OAM_ZERO;
                                        length_left = get_word_from_header((UInt8*)p_api_buf +
                                                OAM_INTF_HDR_MSG_SIZE_OFFSET);

                                        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                        p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                                        retVal = oam_rrc_il_parse_m2ap_oam_session_details_resp(
                                                p_m2ap_session_details_resp,
                                                p_api_buf,
                                                length_left,
                                                &length_read);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR,
                                                    "Failed to parse M2AP_OAM_SESSION_DETAILS_RESP");
                                            oam_construct_n_send_get_resp_to_usr(
                                                    OAM_RESULT_FAILURE,
                                                    OAM_ERR_INTERNAL_ERROR,
                                                    OAM_VERSION,
                                                    OAM_MODULE_ID,dest_id,
                                                    trans_id,
                                                    OAM_ZERO, OAM_ZERO,
                                                    "Internal Error",
                                                    &error_code
                                                    );
                                            oam_mem_free(p_m2ap_session_details_resp, &error_code);
                                            OAM_FUN_EXIT_TRACE();
                                            return retVal;
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED,
                                                    "Successfully parse M2AP_OAM_SESSION_DETAILS_RESP");

                                            if (OAM_FAILURE == oam_mem_alloc((size_x * sizeof(UInt16 *)),(void *)&temp_arr,&error_code))
                                            {
                                                OAM_LOG(OAM,OAM_ERROR,
                                                        "\nError in Memory Allocation with error code %d",
                                                        error_code);
                                                /* Coverity Fix 97680 Start */
                                                oam_mem_free(p_m2ap_session_details_resp, &error_code);
                                                /* Coverity Fix 97680 End */
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;
                                            }

                                            for (loop_counter = OAM_ZERO; loop_counter < size_x; loop_counter++)
                                            {
                                                if(OAM_FAILURE == oam_mem_alloc((size_y * sizeof(UInt16)),(void *)&temp_arr[loop_counter],&error_code))
                                                {
                                                    OAM_LOG(OAM,OAM_ERROR,"\nError in Memory Allocation with error code %d",
                                                            error_code);
                                                    for(loop_counter1 = OAM_ZERO ;loop_counter1 < loop_counter;loop_counter1++)
                                                    {
                                                        oam_mem_free(temp_arr[loop_counter1], &error_code);
                                                    }
                                                    oam_mem_free(temp_arr, &error_code);
                                                    /* Coverity Fix 97680 Start */
                                                    oam_mem_free(p_m2ap_session_details_resp, &error_code);
                                                    /* Coverity Fix 97680 End */
                                                    OAM_FUN_EXIT_TRACE();
                                                    return OAM_FAILURE;
                                                }
                                                oam_memset(temp_arr[loop_counter], 0x00, (size_y * sizeof(UInt16)));
                                            }

                                            oam_sprintf((char *)temp_arr[str_count++],
                                                    "%s=%d",
                                                    "Number 0f Sessions",
                                                    p_m2ap_session_details_resp->
                                                    session_count);
                                            for (loop_counter = OAM_ZERO;loop_counter < 
                                                    (p_m2ap_session_details_resp->session_count);
                                                    loop_counter++)
                                            {

                                                oam_sprintf((char *)temp_arr[str_count++],
                                                        "%s=%lu",
                                                        "ENB M2AP MBMS ID",
                                                        p_m2ap_session_details_resp->
                                                        session_id_list[loop_counter].
                                                        enb_m2ap_mbms_id);

                                                oam_sprintf((char *)temp_arr[str_count++],
                                                        "%s=%lu",
                                                        "MCE M2AP MBMS ID", 
                                                        p_m2ap_session_details_resp->
                                                        session_id_list[loop_counter].
                                                        mce_m2ap_mbms_id);
                                            }


                                            oam_construct_n_send_gpv_response((UInt8 *)"MBMS.Show.SessionList",
                                                    temp_arr,
                                                    str_count,
                                                    trans_id,
                                                    &error_code,
                                                    dest_id,
                                                    OAM_ZERO,OAM_ZERO);

                                            for(loop_counter1 = OAM_ZERO ;loop_counter1 < loop_counter;loop_counter1++)
                                            {
                                                oam_mem_free(temp_arr[loop_counter1], &error_code);
                                            }
                                            oam_mem_free(temp_arr, &error_code);

                                        }
                                        oam_mem_free(p_m2ap_session_details_resp, &error_code);

                                        break;
        case M2AP_OAM_RESET_RESP:
                                        OAM_LOG(OAM, OAM_INFO, "Received M2AP_OAM_RESET_RESP "
                                                "from RRC");
#ifndef OAM_UT_FRAMEWORK
                                        retVal = oam_process_tcb_for_layer_resp(p_api_buf,
                                                &trans_id,
                                                &dest_id);

                                        if (OAM_SUCCESS == retVal)
                                        {
                                            /* Coverity 93570 Fix Start */
                                            tcb_found_1 = OAM_TRUE;
                                            /* Coverity 93570 Fix End */
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Failed to fetch TCB details");
                                            OAM_FUN_EXIT_TRACE();
                                            return retVal;
                                        }
#endif

                                        retVal = oam_mem_alloc(sizeof(m2ap_oam_reset_resp_t),
                                                (void**)&p_m2ap_reset_resp,
                                                &error_code);

                                        if (OAM_FAILURE == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed");
                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            err_str_size = oam_strlen(err_string) + OAM_ONE;
                                            usr_resp = OAM_RESULT_FAILURE;

                                            if (tcb_found_1)
                                            {
                                                oam_construct_n_send_set_resp_to_usr(usr_resp,
                                                        usr_error_code,
                                                        (UInt8*)err_string,
                                                        err_str_size,
                                                        OAM_VERSION_ID,
                                                        OAM_MODULE_ID,
                                                        dest_id,
                                                        trans_id,
                                                        OAM_ZERO, OAM_ZERO,
                                                        &error_code);
                                            }
                                        }

                                        oam_memset(p_m2ap_reset_resp, OAM_ZERO,
                                                sizeof(m2ap_oam_reset_resp_t));

                                        length_read = OAM_ZERO;
                                        length_left = get_word_from_header((UInt8*)p_api_buf +
                                                OAM_INTF_HDR_MSG_SIZE_OFFSET);

                                        length_left -= LOWER_LAYER_INTERFACE_HEADER_SIZE;
                                        p_api_buf += LOWER_LAYER_INTERFACE_HEADER_SIZE;

                                        retVal = oam_rrc_il_parse_m2ap_oam_reset_resp(
                                                p_m2ap_reset_resp,
                                                p_api_buf,
                                                length_left,
                                                &length_read);

                                        if (OAM_SUCCESS == retVal)
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED, "Parsing Successful in "
                                                    "M2AP_OAM_RESET_RESP");
                                            if (M2AP_SUCCESS == p_m2ap_reset_resp->response)
                                            {
                                                OAM_LOG(OAM, OAM_INFO, "Success response received in "
                                                        "M2AP_OAM_RESET_RESP");
                                                err_string = OAM_NULL;
                                                err_str_size = OAM_ZERO;
                                                usr_error_code = OAM_ZERO;
                                                usr_resp = OAM_RESULT_SUCCESS;
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM, OAM_ERROR, "Failure response received in "
                                                        "M2AP_OAM_RESET_RESP with err code:%d",
                                                        p_m2ap_reset_resp->m2ap_oam_cause);

                                                err_string = "Internal error";

                                                err_str_size = oam_strlen(err_string) + OAM_ONE;
                                                usr_error_code = OAM_ERR_INTERNAL_ERROR;
                                                usr_resp = OAM_RESULT_FAILURE;
                                            }
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_ERROR, "Parsing Failed in "
                                                    "M2AP_OAM_RESET_RESP");

                                            oam_get_err_string_n_err_code(error_code, &usr_error_code,
                                                    &err_string);
                                            err_str_size = oam_strlen(err_string) + OAM_ONE;
                                            usr_resp = OAM_RESULT_FAILURE;
                                        }

                                        if (tcb_found_1) {
                                            oam_construct_n_send_set_resp_to_usr(usr_resp,
                                                    usr_error_code,
                                                    (UInt8*)err_string,
                                                    err_str_size,
                                                    OAM_VERSION_ID,
                                                    OAM_MODULE_ID,
                                                    dest_id,
                                                    trans_id,
                                                    OAM_ZERO, OAM_ZERO,
                                                    &error_code);
                                        }

                                        oam_mem_free(p_m2ap_reset_resp, &error_code);
                                        break;
#endif
                                        /* EMBMS Changes End */
                                        /* SPR_13116_CHANGE_START */
                                        /*SPR 13617 START*/
        case RRC_OAM_GET_LOG_LEVEL_RESP:
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Received RRC_OAM_GET_LOG_LEVEL_RESP from RRC");

                                            OAM_LOG(OAM, OAM_DETAILED, "Trans_id received is = %d", trans_id);
                                            oam_rrc_get_log_level_resp_t rrc_get_log_level_resp;
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            length_left = get_word_from_header((UInt8*)p_api_buf +
                                                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                            /* SPR 13116 REVIEW COMMENTS FIX END */
                                            length_read= OAM_ZERO;
                                            retVal = oam_rrc_il_parse_rrc_oam_get_log_level_resp(&rrc_get_log_level_resp,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    &length_read);
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            if(OAM_FAILURE == retVal)
                                                /* SPR 13116 REVIEW COMMENTS FIX END */
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "Parsing Failed in RRC_OAM_GET_LOG_LEVEL_RESP");
                                                return OAM_FAILURE;
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Parsing Successful in RRC_OAM_GET_LOG_LEVEL_RESP ");
                                            }

                                            retVal = oam_l3_get_loglevel_resp(&rrc_get_log_level_resp,p_api_buf);
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            if(OAM_FAILURE == retVal)
                                                /* SPR 13116 REVIEW COMMENTS FIX END */
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "Failed in RRC_OAM_GET_LOG_LEVEL_RESP");
                                                return OAM_FAILURE;
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Successful in RRC_OAM_GET_LOG_LEVEL_RESP");
                                            }

                                        }
                                        break;
                                        /*SPR 13617 END*/
                                        /* SPR_13116_CHANGE_END */
        case S1AP_OAM_GET_LOG_LEVEL_RESP:
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Received S1AP_OAM_GET_LOG_LEVEL_RESP from S1AP");

                                            OAM_LOG(OAM, OAM_DETAILED, "Trans_id received is = %d", trans_id);
                                            oam_s1ap_get_log_level_resp_t s1ap_get_log_level_resp;
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            length_left = get_word_from_header((UInt8*)p_api_buf +
                                                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                            /* SPR 13116 REVIEW COMMENTS FIX END */
                                            length_read= OAM_ZERO;
                                            retVal = oam_rrc_il_parse_s1ap_oam_get_log_level_resp(&s1ap_get_log_level_resp,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    &length_read);
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            if(OAM_FAILURE == retVal)
                                                /* SPR 13116 REVIEW COMMENTS FIX END */
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "Parsing Failed in S1AP_OAM_GET_LOG_LEVEL_RESP");
                                                return OAM_FAILURE;
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Parsing Successful in S1AP_OAM_GET_LOG_LEVEL_RESP ");
                                            }

                                            retVal = oam_l3_s1ap_get_loglevel_resp(&s1ap_get_log_level_resp,p_api_buf);
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            if(OAM_FAILURE == retVal)
                                                /* SPR 13116 REVIEW COMMENTS FIX END */
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "Failed in S1AP_OAM_GET_LOG_LEVEL_RESP");
                                                return OAM_FAILURE;
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Successful in S1AP_OAM_GET_LOG_LEVEL_RESP");
                                            }

                                        }
                                        break;
        case X2AP_OAM_GET_LOG_LEVEL_RESP:
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_OAM_GET_LOG_LEVEL_RESP from X2AP");

                                            OAM_LOG(OAM, OAM_DETAILED, "Trans_id received is = %d", trans_id);
                                            oam_x2ap_get_log_level_resp_t x2ap_get_log_level_resp;
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            length_left = get_word_from_header((UInt8*)p_api_buf +
                                                    OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                            /* SPR 13116 REVIEW COMMENTS FIX END */
                                            length_read= OAM_ZERO;
                                            retVal = oam_rrc_il_parse_x2ap_oam_get_log_level_resp(&x2ap_get_log_level_resp,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    &length_read);
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            if(OAM_FAILURE == retVal)
                                                /* SPR 13116 REVIEW COMMENTS FIX END */
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "Parsing Failed in X2AP_OAM_GET_LOG_LEVEL_RESP");
                                                return OAM_FAILURE;
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Parsing Successful in X2AP_OAM_GET_LOG_LEVEL_RESP ");
                                            }

                                            retVal = oam_l3_x2ap_get_loglevel_resp(&x2ap_get_log_level_resp,p_api_buf);
                                            /* SPR 13116 REVIEW COMMENTS FIX START */
                                            if(OAM_FAILURE == retVal)
                                                /* SPR 13116 REVIEW COMMENTS FIX END */
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "Failed in X2AP_OAM_GET_LOG_LEVEL_RESP");
                                                return OAM_FAILURE;
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Successful in X2AP_OAM_GET_LOG_LEVEL_RESP");
                                            }

                                        }
                                        break;


        case RRC_OAM_SET_LOG_LEVEL_RESP:
                                        {
                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                            length_read= OAM_ZERO;
                                            UInt16 tcb_detail= get_word_from_header(p_api_buf + OAM_ZERO);
                                            UInt32 bitmask = OAM_ZERO;
                                            rrc_oam_set_log_level_resp_t rrc_oam_set_log_level_resp = {OAM_ZERO};
                                            UInt16 trans_id_resp=OAM_ZERO;
                                            UInt8 *p_req_msg = OAM_NULL;
                                            UInt32 temp_tcb = tcb_detail;
                                            oam_struct_t        *node = OAM_NULL;
                                            if(OAM_SUCCESS==oam_rrc_il_parse_rrc_oam_set_log_level_resp(&rrc_oam_set_log_level_resp,p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        &length_read))
                                            {
                                                node=oam_tcb_get_detail(&temp_tcb);
                                                if(node)
                                                {
                                                    p_req_msg = node->oam_tcb_context;
                                                    dest_id = get_word_from_header((UInt8*)(p_req_msg) + OAM_TWO);
                                                    if (OAM_FAILURE == rrc_oam_set_log_level_resp.response)
                                                    {
#ifndef OAM_UT_FRAMEWORK
                                                        if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                        {
                                                            OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");      
                                                        }
#endif
                                                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                                OAM_ERR_INTERNAL_ERROR,
                                                                (UInt8 *) "set log level response failure from RRC",oam_strlen("set log level response failure from RRC")+1,
                                                                OAM_VERSION_ID, OAM_MODULE_ID,
                                                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                                &error_code);
                                                    }
                                                    else 
                                                    {          
                                                        oam_tcb_update_bitmask(tcb_detail,OAM_TRANS_RRC,&bitmask);
                                                        if(bitmask == 0)
                                                        {
#ifndef OAM_UT_FRAMEWORK
                                                            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                            {
                                                                OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                                            }
#endif
                                                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                                    OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                                                    dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                                    &error_code);
                                                        }
                                                        else
                                                        {
                                                            OAM_LOG(OAM,OAM_DETAILED, "Received RRC_OAM_SET_LOG_LEVEL_RESP:SUCCESS from RRC for system command,waiting for response from other layers");
                                                        }
                                                    }
                                                }
                                            } 
                                            else                            
                                            {
#ifndef OAM_UT_FRAMEWORK
                                                if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                {
                                                    OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                                }
#endif
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        (UInt8 *) "set log level parsing failed",oam_strlen("set log level parsing failed")+1,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }
                                        }

                                        break;
        case S1AP_OAM_SET_LOG_LEVEL_RESP:
                                        {
                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                            length_read= OAM_ZERO;
                                            UInt16 tcb_detail= get_word_from_header(p_api_buf + OAM_ZERO);
                                            UInt32 bitmask = OAM_ZERO;
                                            s1ap_oam_set_log_level_resp_t s1ap_oam_set_log_level_resp = {OAM_ZERO};
                                            UInt16 trans_id_resp=OAM_ZERO;
                                            UInt8 *p_req_msg = OAM_NULL;
                                            UInt32 temp_tcb = tcb_detail;
                                            oam_struct_t        *node = OAM_NULL;
                                            if(OAM_SUCCESS==oam_rrc_il_parse_s1ap_oam_set_log_level_resp(&s1ap_oam_set_log_level_resp,p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        &length_read))
                                            {
                                                node=oam_tcb_get_detail(&temp_tcb);
                                                if(node)
                                                {
                                                    p_req_msg = node->oam_tcb_context;
                                                    dest_id = get_word_from_header((UInt8*)(p_req_msg) + OAM_TWO);
                                                    if (OAM_FAILURE == s1ap_oam_set_log_level_resp.response)
                                                    {
#ifndef OAM_UT_FRAMEWORK
                                                        if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                        {
                                                            OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");      
                                                        }
#endif
                                                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                                OAM_ERR_INTERNAL_ERROR,
                                                                (UInt8 *) "set log level response failure from s1ap",oam_strlen("set log level response failure from S1AP")+1,
                                                                OAM_VERSION_ID, OAM_MODULE_ID,
                                                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                                &error_code);
                                                    }
                                                    else 
                                                    {          
                                                        oam_tcb_update_bitmask(tcb_detail,OAM_TRANS_S1AP,&bitmask);
                                                        if(bitmask == 0)
                                                        {
#ifndef OAM_UT_FRAMEWORK
                                                            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                            {
                                                                OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                                            }
#endif
                                                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                                    OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                                                    dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                                    &error_code);
                                                        }
                                                        else
                                                        {
                                                            OAM_LOG(OAM,OAM_DETAILED, "Received S1AP_OAM_SET_LOG_LEVEL_RESP:SUCCESS from S1AP for system command,waiting for response from other layers");
                                                        }
                                                    }
                                                }
                                            } 
                                            else                            
                                            {
#ifndef OAM_UT_FRAMEWORK
                                                if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                {
                                                    OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                                }
#endif
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        (UInt8 *) "set log level parsing failed",oam_strlen("set log level parsing failed")+1,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }
                                        }

                                        break;
        case X2AP_OAM_SET_LOG_LEVEL_RESP:
                                        {
                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_INTF_HDR_MSG_SIZE_OFFSET);
                                            length_read= OAM_ZERO;
                                            UInt16 tcb_detail= get_word_from_header(p_api_buf + OAM_ZERO);
                                            UInt32 bitmask = OAM_ZERO;
                                            x2ap_oam_set_log_level_resp_t x2ap_oam_set_log_level_resp = {OAM_ZERO};
                                            UInt16 trans_id_resp=OAM_ZERO;
                                            UInt8 *p_req_msg = OAM_NULL;
                                            UInt32 temp_tcb = tcb_detail;
                                            oam_struct_t        *node = OAM_NULL;
                                            if(OAM_SUCCESS==oam_rrc_il_parse_x2ap_oam_set_log_level_resp(&x2ap_oam_set_log_level_resp,p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        &length_read))
                                            {
                                                node=oam_tcb_get_detail(&temp_tcb);
                                                if(node)
                                                {
                                                    p_req_msg = node->oam_tcb_context;
                                                    dest_id = get_word_from_header((UInt8*)(p_req_msg) + OAM_TWO);
                                                    if (OAM_FAILURE == x2ap_oam_set_log_level_resp.response)
                                                    {
#ifndef OAM_UT_FRAMEWORK
                                                        if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                        {
                                                            OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");      
                                                        }
#endif
                                                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                                OAM_ERR_INTERNAL_ERROR,
                                                                (UInt8 *) "set log level response failure from s1ap",oam_strlen("set log level response failure from S1AP")+1,
                                                                OAM_VERSION_ID, OAM_MODULE_ID,
                                                                dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                                &error_code);
                                                    }
                                                    else 
                                                    {          
                                                        oam_tcb_update_bitmask(tcb_detail,OAM_TRANS_S1AP,&bitmask);
                                                        if(bitmask == 0)
                                                        {
#ifndef OAM_UT_FRAMEWORK
                                                            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                            {
                                                                OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                                            }
#endif
                                                            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                                    OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                                    OAM_VERSION_ID, OAM_MODULE_ID,
                                                                    dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                                    &error_code);
                                                        }
                                                        else
                                                        {
                                                            OAM_LOG(OAM,OAM_DETAILED, "Received X2AP_OAM_SET_LOG_LEVEL_RESP:SUCCESS from X2AP for system command,waiting for response from other layers");
                                                        }
                                                    }
                                                }
                                            } 
                                            else                            
                                            {
#ifndef OAM_UT_FRAMEWORK
                                                if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                                {
                                                    OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                                }
#endif
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        (UInt8 *) "set log level parsing failed",oam_strlen("set log level parsing failed")+1,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }
                                        }

                                        break;

        case RRC_OAM_CELL_TRAFFIC_TRACE_START_ERROR_IND:
                                        trace_start = OAM_ZERO;
                                        break; 
        case RRC_OAM_TRACE_FILE_TRANSFER_START_IND:
                                        {
                                            msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
                                            length_read = OAM_ZERO;
                                            oam_rrc_trace_file_transfer_start_ind_t oam_rrc_trace_file_transfer_start_ind;
                                            if(OAM_SUCCESS==oam_rrc_il_parse_rrc_oam_trace_file_transfer_start_ind(&oam_rrc_trace_file_transfer_start_ind,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        msg_size - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        &length_read))
                                            {
                                                OAM_LOG(OAM, OAM_DETAILED, " Received TRACE_FILE_TRANSFER_START_IND Success");
                                                oam_system("mkdir cell_trace_file");
                                                /*SPR 15196 start*/
                                                char cpfilenamecmd[250]="";
                                                /*SPR 15196 end*/
                                                oam_snprintf(cpfilenamecmd,sizeof(cpfilenamecmd),"mv %s cell_trace_file/",oam_rrc_trace_file_transfer_start_ind.trace_file.file_name);     

                                                oam_system(cpfilenamecmd);
                                                OAM_LOG(OAM, OAM_DETAILED, " Cell Trace File moved successfully");
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM, OAM_ERROR, " Received TRACE_FILE_TRANSFER_START_IND Fails");
                                            }

                                        }       
                                        break;
        case RRC_OAM_TRACE_START_ERROR_IND:
                                        {
                                            msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
                                            length_read = OAM_ZERO;
                                            /*SPR 21587 Start*/
                                            oam_rrc_trace_start_error_ind_t *p_oam_rrc_trace_start_error_ind; 
                                            retVal =
                                                oam_mem_alloc(sizeof(oam_rrc_trace_start_error_ind_t),
                                                        (void**)&p_oam_rrc_trace_start_error_ind, &error_code);
                                            if (OAM_FAILURE == retVal) {
                                                OAM_LOG(OAM, OAM_ERROR, "Memory allocation failed "
                                                        "with Error Code: %d", error_code);
                                                return OAM_FAILURE; 
                                            }    
                                            /*SPR 21587 End*/
                                            if(OAM_SUCCESS==oam_rrc_il_parse_rrc_oam_trace_start_error_ind(p_oam_rrc_trace_start_error_ind,p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        msg_size - LOWER_LAYER_INTERFACE_HEADER_SIZE,&length_read))
                                            {
                                                OAM_LOG(OAM, OAM_DETAILED, " Received RRC_OAM_TRACE_START_ERROR_IND: Success");
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM, OAM_ERROR, " Received RRC_OAM_TRACE_START_ERROR_IND: Fails");
                                                /* CID Fix 115506 +*/
                                                oam_mem_free(p_oam_rrc_trace_start_error_ind, &error_code);
                                                return OAM_FAILURE;
                                                /* CID Fix 115506 -*/
                                            }
                                            /* CID Fix 115506 +*/
                                            oam_mem_free(p_oam_rrc_trace_start_error_ind, &error_code);
                                            /* CID Fix 115506 -*/
                                        }
                                        break;
        case RRC_OAM_GET_CELL_STATS_RESP:
                                        if(OAM_SUCCESS == oam_handle_rrc_stats_n_reset_req(p_api_buf))
                                        {
                                            OAM_LOG(OAM, OAM_DETAILED, " Received RRC_OAM_GET_CELL_STATS_RESP: Success");
                                        }
                                        break;
        case RRC_OAM_RRC_CONNECTION_STATS_IND:
        case RRC_OAM_ERAB_STATS_IND:
        case RRC_OAM_HANDOVER_STATS_IND:
        case RRC_OAM_PAGING_STATS_IND:
        case RRC_OAM_UE_ASSOC_S1_CONN_STATS_IND:
        case RRC_OAM_IRAT_MOBILITY_STATS_IND:
                                        if(OAM_FAILURE == oam_rrc_kpi_stats_inds_handling(p_api_buf))
                                        {
                                            OAM_LOG(OAM,OAM_ERROR,
                                                    "Error handling RRC KPI api_id[%d]",api_id);
                                            OAM_FUN_EXIT_TRACE();
                                            return OAM_FAILURE;
                                        }
                                        break;
        case RRC_OAM_CONFIG_STATS_RESP:
                                        {
                                            /* Coverity Fix 79020 Start */
                                            /* Code Deleted */
                                            /* Coverity Fix 79020 End */
                                            /*SPR 17777 fix*/
                                            if(OAM_FAILURE == oam_hdle_rrc_config_resp(p_api_buf))
                                            {
                                                OAM_LOG(OAM,OAM_ERROR,
                                                        "Error handling RRC_OAM_CONFIG_STATS_RESP");
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;
                                            }
                                            break;
                                        }
        case S1AP_OAM_ENB_CONFIG_UPDATE_RESPONSE:
                                        /* SPR_20467_FIX_START */
                                        OAM_LOG(OAM, OAM_INFO,"Received S1AP_OAM_ENB_CONFIG_UPDATE_RESPONSE, Active MME %d, trans_id %d",
                                                oam_prov_req.oam_l3_req.mme_data.num_mme_id,trans_id);
                                        /* SPR_20467_FIX_END */
                                        msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
                                        length_read = OAM_ZERO;
                                        s1ap_oam_enb_config_update_response_t s1ap_oam_enb_config_update_response; 
                                        /* SPR_20467_FIX_START */
                                        trans_id_resp = get_word_from_header((UInt8 *)p_api_buf);

                                        p_cell_local_plmnlist_data =
                                            &LOCAL_RRM_PROV_REQ.plmnlist_data[cell_config_idx];
                                        p_cell_plmnlist_data =
                                            &RRM_PROV_REQ.plmnlist_data[cell_config_idx];
                                        /* SPR_20467_FIX_END */

                                        /* SPR 16567 START */
                                        if(OAM_SUCCESS == oam_rrc_il_parse_s1ap_oam_enb_config_update_response(&s1ap_oam_enb_config_update_response,
                                                    p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    msg_size - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                    &length_read))
                                        {
                                            /* SPR_20467_FIX_START */
                                            //Store the s1ap_oam_enb_config_update_response for each connected mme
                                            if(oam_prov_req.system_status.event_ongoing & OAM_CELL_PLMNLIST_CONFIG_ONGOING) 
                                            {
                                                oam_s1ap_ecu_resp_data_t *p_oam_s1ap_ecu_resp_data = OAM_NULL;
                                                p_oam_s1ap_ecu_resp_data = oam_process_tcb_for_ecu_resp(p_oam_s1ap_ecu_resp_data,p_api_buf,0);

                                                if(OAM_NULL == p_oam_s1ap_ecu_resp_data)
                                                {
                                                    OAM_LOG(OAM, OAM_ERROR, "p_oam_s1ap_ecu_resp_data is NULL");
                                                    return OAM_FAILURE;
                                                }    
                                                switch (s1ap_oam_enb_config_update_response.response)
                                                {
                                                    case OAM_ENB_CONFIG_UPDATE_SUCCESS:
                                                    {
                                                        OAM_LOG(OAM,OAM_DETAILED,"OAM_ENB_CONFIG_UPDATE_SUCCESS Response rcvd for MME ID %d",
                                                                s1ap_oam_enb_config_update_response.mme_id);

                                                        current_enb_config_count = OAM_ZERO;
                                                        p_oam_s1ap_ecu_resp_data->mme_id_response_cnt++;
                                                        p_oam_s1ap_ecu_resp_data->ecu_success_resp_received = OAM_ECU_SUCCESS_RECEIVED;
                                                        p_oam_s1ap_ecu_resp_data->ecu_resp_received[s1ap_oam_enb_config_update_response.mme_id] =  
                                                            OAM_ECU_SUCCESS_RECEIVED;
                                                        break;
                                                    }

                                                    case OAM_ENB_CONFIG_UPDATE_FAILURE_TIMER_EXPIRY:
                                                    {
                                                        OAM_LOG(OAM, OAM_ERROR,
                                                                "Received OAM_ENB_CONFIG_UPDATE_FAILURE_TIMER_EXPIRY for MME Id %d",
                                                                s1ap_oam_enb_config_update_response.mme_id);
                                                        p_oam_s1ap_ecu_resp_data->ecu_resp_received[s1ap_oam_enb_config_update_response.mme_id] =  
                                                            OAM_ECU_FAILURE_TIMER_EXPIRY;
                                                        break;
                                                    }

                                                    case OAM_ENB_CONFIG_UPDATE_FAILURE:
                                                    case OAM_ENB_CONFIG_MSG_DECODE_FAILURE:
                                                    case OAM_ENB_CONFIG_UPDATE_INTERNAL_ERROR:
                                                    case OAM_ENB_CONFIG_UPDATE_INVALID_RESP:
                                                    case OAM_ENB_CONFIG_UPDATE_FAILURE_INVALID_MME_ID:
                                                    {
                                                        OAM_LOG(OAM, OAM_ERROR,
                                                                "Received failure from L3, enb_config_update_response.response %d for MME ID %d",
                                                                s1ap_oam_enb_config_update_response.response,
                                                                s1ap_oam_enb_config_update_response.mme_id);
                                                        p_oam_s1ap_ecu_resp_data->mme_id_response_cnt++;
                                                        p_oam_s1ap_ecu_resp_data->ecu_resp_received[s1ap_oam_enb_config_update_response.mme_id] = 
                                                            OAM_ECU_FAILURE_RECEIVED;
                                                        break; 
                                                    }
                                                    default:
                                                    {
                                                        OAM_LOG(OAM, OAM_ERROR,
                                                                "Received invalid response from L3, enb_config_update_response.response %d for MME ID %d",
                                                                s1ap_oam_enb_config_update_response.response,
                                                                s1ap_oam_enb_config_update_response.mme_id);
                                                        break;
                                                    }    
                                                }

                                                if(p_oam_s1ap_ecu_resp_data->mme_id_response_cnt == oam_prov_req.oam_l3_req.mme_data.num_mme_id)
                                                {
                                                    ecu_resp_recvd_for_all_mme = OAM_TRUE;
                                                    p_oam_s1ap_ecu_resp_data->mme_id_response_cnt = 0;
                                                }   
                                                else
                                                {
                                                    break;
                                                } 

                                                OAM_LOG(OAM, OAM_DETAILED,"ecu_resp_recvd_for_all_mme %d, ecu_success_resp_recieved %d",
                                                        ecu_resp_recvd_for_all_mme,p_oam_s1ap_ecu_resp_data->ecu_success_resp_received);
                                                if(ecu_resp_recvd_for_all_mme)
                                                {
                                                    OAM_LOG(OAM,OAM_DETAILED,"Stopping Timer %p for enb config update, Response rcvd for MME ID %d",
                                                            oam_prov_req.system_status.timer_id,
                                                            s1ap_oam_enb_config_update_response.mme_id);

                                                    if (OAM_SUCCESS != oam_stop_timer(oam_prov_req.system_status.timer_id))
                                                    {
                                                        OAM_LOG(OAM, OAM_ERROR, "Error returned while stopping the enb config update timer\n");
                                                        OAM_FUN_EXIT_TRACE();
                                                        return OAM_FAILURE;
                                                    }
                                                    else
                                                    {
                                                        OAM_LOG(OAM, OAM_INFO, "enb_config_update timer stopped, Timer Id %p\n",
                                                                oam_prov_req.system_status.timer_id);
                                                    }
                                                    /* OAM trigger S1AP_OAM_CLOSE_MME_CONN to all those MMEs 
                                                     * which have sent failure, in case it has received success 
                                                     * from atleast one of the connected MME */
                                                    for(loop_counter=OAM_ZERO;loop_counter<oam_prov_req.oam_l3_req.mme_data.num_mme_id;loop_counter++)
                                                    {
                                                        mme_id = oam_prov_req.oam_l3_req.mme_data.mme_id[loop_counter];
                                                        if( ( (OAM_TRUE == p_oam_s1ap_ecu_resp_data->old_ecu_sent_flag) &&
                                                                    (OAM_ECU_FAILURE_RECEIVED == p_oam_s1ap_ecu_resp_data->ecu_resp_received[mme_id]) ) ||
                                                                ( (OAM_FALSE == p_oam_s1ap_ecu_resp_data->old_ecu_sent_flag) &&
                                                                  (oam_prov_req.oam_l3_req.mme_data.num_mme_id > OAM_ONE) &&
                                                                  ((OAM_ZERO < p_oam_s1ap_ecu_resp_data->ecu_success_resp_received) && 
                                                                   (OAM_ECU_FAILURE_RECEIVED == p_oam_s1ap_ecu_resp_data->ecu_resp_received[mme_id])) ) )
                                                        {
                                                            s1ap_close_mme_conn.mme_id[s1ap_close_mme_conn.mme_count]= mme_id;              
                                                            s1ap_close_mme_conn.mme_count++;
                                                            send_s1ap_oam_close_mme_conn_req = OAM_TRUE;

                                                            OAM_LOG(OAM,OAM_DETAILED,"Received failure from L3 for ECU for mme_id %d",mme_id);

                                                            oam_counter_t counter_1 = OAM_ZERO;
                                                            oam_counter_t counter_2 = OAM_ZERO;

                                                            for (counter_1 = OAM_ZERO; counter_1 < oam_prov_req.oam_l3_req.mme_data.num_mme_id; counter_1++)
                                                            {
                                                                if(oam_prov_req.oam_l3_req.mme_data.mme_id[counter_1] == mme_id)
                                                                    break;  
                                                            }
                                                            for (counter_2=counter_1;counter_2 < oam_prov_req.oam_l3_req.mme_data.num_mme_id - OAM_ONE;counter_2++)
                                                            {
                                                                /* Shift all present MME ID to thier left array index */
                                                                oam_prov_req.oam_l3_req.mme_data.mme_id[counter_2] 
                                                                    = oam_prov_req.oam_l3_req.mme_data.mme_id[counter_2 + OAM_ONE]; 
                                                            }              
                                                            if (oam_prov_req.oam_l3_req.mme_data.num_mme_id >= OAM_ONE)
                                                            {
                                                                num_failure_mmeId++;
                                                            }

                                                            OAM_LOG(OAM,OAM_DETAILED,"S1AP num active mme =%d",oam_prov_req.oam_l3_req.mme_data.num_mme_id);

                                                        }
                                                        else if( (OAM_ONE == oam_prov_req.oam_l3_req.mme_data.num_mme_id) &&
                                                                (OAM_ECU_FAILURE_RECEIVED == p_oam_s1ap_ecu_resp_data->ecu_resp_received[mme_id]) )
                                                        {
                                                            OAM_LOG(OAM,OAM_DETAILED,"Received failure for ECU from L3, single MME connected");
                                                            ecu_failure_received = OAM_TRUE;
                                                        }
                                                        else if( (oam_prov_req.oam_l3_req.mme_data.num_mme_id > OAM_ONE) &&
                                                                ((OAM_ZERO == p_oam_s1ap_ecu_resp_data->ecu_success_resp_received) && 
                                                                 (OAM_ECU_FAILURE_RECEIVED == p_oam_s1ap_ecu_resp_data->ecu_resp_received[mme_id])) )
                                                        {
                                                            temp_count++;
                                                        }   
                                                    }

                                                    if(OAM_TRUE == send_s1ap_oam_close_mme_conn_req)
                                                    {   
                                                        OAM_LOG(OAM,OAM_DETAILED,"Received failure from L3 for ECU, Sending close mme conn to s1ap to MME_CNT %d",
                                                                s1ap_close_mme_conn.mme_count);

                                                        if(num_failure_mmeId)
                                                        {
                                                            oam_prov_req.oam_l3_req.mme_data.num_mme_id -= num_failure_mmeId;
                                                        }    

                                                        if(OAM_FAILURE == oam_s1ap_il_send_s1ap_oam_close_mme_conn(
                                                                    &s1ap_close_mme_conn,
                                                                    OAM_MODULE_ID,
                                                                    RRC_MODULE_ID,
                                                                    transid,
                                                                    oam_prov_req.cell_cntxt.curr_cell_cid))
                                                        {
                                                            OAM_LOG(OAM,OAM_WARNING,"Error in function oam_s1ap_il_send_s1ap_oam_close_mme_conn");
                                                            OAM_FUN_EXIT_TRACE ();
                                                            return retVal;
                                                        }
                                                        else
                                                        {
                                                            OAM_LOG(OAM,OAM_INFO,"Succesfully send oam_s1ap_il_send_s1ap_oam_close_mme_conn");
                                                        }
                                                        if (oam_prov_req.oam_l3_req.mme_data.num_mme_id < OAM_ONE)
                                                        {
                                                            for(loop_counter1 = OAM_ZERO;
                                                                    loop_counter1 < oam_prov_req.num_cells_configured;
                                                                    ++loop_counter1) {
                                                                p_rrm_cell_config =
                                                                    &RRM_CELL_CONFIG(loop_counter1);
                                                                cid =
                                                                    oam_extract_cid_from_eutran_cellidentity(
                                                                            p_rrm_cell_config->global_cell_info.
                                                                            eutran_global_cell_id.cell_identity);
                                                                p_cell_status = oam_get_cell_cntxt_status(cid);

                                                                if(p_cell_status == OAM_NULL) /*Cov CID 62498 Fix*/
                                                                    continue;

                                                                if ((p_cell_status->cell_state & OAM_CELL_ACTIVE))
                                                                { 
                                                                    OAM_LOG(OAM, OAM_INFO,
                                                                            "Sending cell stop for CID: %d to rrm as no s1 link is active",
                                                                            cid);
                                                                    retVal =
                                                                        oam_rrm_send_rrm_oam_cell_stop_req(
                                                                                ((rrm_oam_cell_stop_req_t *)
                                                                                 &(p_rrm_cell_config->
                                                                                     global_cell_info.
                                                                                     eutran_global_cell_id)),
                                                                                OAM_MODULE_ID,
                                                                                RRM_MODULE_ID,
                                                                                transid, cid);
                                                                    if (OAM_FAILURE == retVal)
                                                                    {
                                                                        OAM_LOG(OAM,OAM_ERROR,
                                                                                "Error in function oam_send_cell_stop_req");						
                                                                        OAM_FUN_EXIT_TRACE ();
                                                                        return retVal;
                                                                    } 
                                                                    else{
                                                                        OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_CELL_STOP_REQ Successfully sent");
#ifndef OAM_UT_FRAMEWORK
                                                                        if( OAM_FAILURE == oam_maintain_tcb_with_timer(transid,OAM_SUB_MODULE_RRM,
                                                                                    OAM_TRANS_RRM,msg_len,p_api_buf))
                                                                        {
                                                                            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
                                                                            retVal = OAM_FAILURE;
                                                                        }
#endif
                                                                    }
                                                                }
                                                                else 
                                                                {
                                                                    OAM_LOG(OAM,OAM_DETAILED,"Cell Stop for cell identity %d, \
                                                                            Cannot be triggerd as CELL Stopped By USER",cid);
                                                                }
                                                            }
                                                        }
                                                    }

                                                    OAM_LOG(OAM,OAM_DETAILED,"S1AP num active mme %d",oam_prov_req.oam_l3_req.mme_data.num_mme_id);
                                                    if( (OAM_FALSE == p_oam_s1ap_ecu_resp_data->old_ecu_sent_flag) &&
                                                            (p_oam_s1ap_ecu_resp_data->ecu_success_resp_received > OAM_ZERO) )
                                                    {
                                                        UInt8 cnt = 0;
                                                        retVal =
                                                            oam_mem_alloc(sizeof(oam_rrm_cell_reconfig_req_t),
                                                                    (void**)&p_cell_reconfig_req, &error_code);

                                                        if (OAM_FAILURE == retVal) {
                                                            OAM_LOG(OAM, OAM_ERROR,
                                                                    "Memory allocation to p_cell_reconfig_req failed"
                                                                    " with Error Code:%d",
                                                                    error_code);
                                                            return OAM_FAILURE; 
                                                        }

                                                        oam_copy_config_to_reconfig((oam_rrm_cell_config_req_t *)
                                                                (&(LOCAL_RRM_PROV_REQ.oam_rrm_cell_config_req[cell_config_idx])),p_cell_reconfig_req);

                                                        for(cnt = 0; cnt < RRM_OAM_MAX_NUM_PLMNS; ++cnt) {

                                                            if(p_cell_local_plmnlist_data->
                                                                    plmn_entries[cnt].is_primary) {
                                                                break;
                                                            }
                                                        }

                                                        if(cnt == RRM_OAM_MAX_NUM_PLMNS) 
                                                        {
                                                            OAM_LOG(OAM, OAM_WARNING,
                                                                    "No primary PLMNID found, request will "
                                                                    "not be sent to RRM!!");
                                                            p_cell_plmnlist_data->plmnlist_cache_idx =
                                                                p_cell_local_plmnlist_data->plmnlist_query_idx + 1;
                                                            oam_memcpy(&p_cell_plmnlist_data->plmnlist_cache,
                                                                    &p_cell_local_plmnlist_data->
                                                                    plmn_entries[p_cell_local_plmnlist_data->plmnlist_query_idx],
                                                                    sizeof(oam_rrm_plmn_data_t));

                                                            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf, &trans_id,
                                                                        &dest_id))
                                                            {
                                                                OAM_LOG(OAM, OAM_WARNING,"Deletion from TCB failed");
                                                                /* Coverity 109471 Fix Start */
                                                                oam_mem_free(p_cell_reconfig_req, &error_code);
                                                                /* Coverity 109471 Fix End */
                                                                return OAM_FAILURE;
                                                            }

                                                            oam_construct_n_send_set_resp_to_usr(
                                                                    OAM_RESULT_SUCCESS,
                                                                    OAM_ZERO, OAM_NULL,
                                                                    OAM_ZERO,
                                                                    OAM_VERSION_ID,
                                                                    OAM_MODULE_ID,
                                                                    dest_id,
                                                                    trans_id,
                                                                    OAM_ZERO, OAM_ZERO,
                                                                    &error_code);
                                                            /* SPR 21449 Fix Start */
                                                            oam_mem_free(p_cell_reconfig_req, &error_code);  
                                                            /* SPR 21449 Fix End */

                                                            break;
                                                        }

                                                        if(OAM_SUCCESS != oam_rrm_send_rrm_oam_cell_reconfig_req(
                                                                    p_cell_reconfig_req,
                                                                    OAM_MODULE_ID,
                                                                    RRM_MODULE_ID,
                                                                    tcb_transaction_id,
                                                                    oam_prov_req.cell_cntxt.curr_cell_cid))
                                                        {
                                                            OAM_LOG(OAM, OAM_ERROR,
                                                                    "Failed to send RRM_OAM_CELL_RECONFIG_REQ message to RRM");
                                                        }
                                                        else {
                                                            OAM_LOG(OAM, OAM_DETAILED,
                                                                    "Successfully send RRM_OAM_CELL_RECONFIG_REQ message to RRM");
                                                        }
                                                        oam_mem_free(p_cell_reconfig_req, &error_code);
                                                    }

                                                    if(temp_count == oam_prov_req.oam_l3_req.mme_data.num_mme_id)
                                                    {
                                                        /* OAM received failure from all the MMEs , OAM send failure to UI */
                                                        ecu_failure_received = OAM_TRUE;
                                                    }

                                                    OAM_LOG(OAM,OAM_DETAILED,"ecu_failure_received %d",ecu_failure_received);

                                                    if(ecu_failure_received)  
                                                    {    
                                                        if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf, &trans_id,
                                                                    &dest_id))
                                                        {
                                                            OAM_LOG(OAM, OAM_WARNING,"Deletion from TCB failed");
                                                            return OAM_FAILURE;
                                                        }

                                                        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                                OAM_ERR_INTERNAL_ERROR,
                                                                (UInt8 *) "s1ap_oam_ECU_response failure",
                                                                oam_strlen("s1ap_oam_ECU_response failure")+1,
                                                                OAM_VERSION_ID, OAM_MODULE_ID,
                                                                dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                                                                &error_code);
                                                    }
                                                    oam_tcb_delete(&trans_id_resp);
                                                }
                                            }
                                            else
                                            {    
                                                /* SPR_20467_FIX_END */
                                                switch (s1ap_oam_enb_config_update_response.response)
                                                {
                                                    case OAM_ENB_CONFIG_UPDATE_SUCCESS:
                                                    {
                                                        OAM_LOG(OAM,OAM_DETAILED,"Stopping Timer for enb config update");
                                                        if (OAM_SUCCESS != oam_stop_timer(oam_prov_req.system_status.timer_id))
                                                        {
                                                            OAM_LOG(OAM, OAM_ERROR, "Error returned while stopping the enb config update timer\n");
                                                            OAM_FUN_EXIT_TRACE();
                                                            return OAM_FAILURE;
                                                        }
                                                        else
                                                        {
                                                            OAM_LOG(OAM, OAM_INFO, "enb_config_update timer stopped\n");
                                                        }
                                                        current_enb_config_count = OAM_ZERO;
                                                    }
                                                    break;

                                                    case OAM_ENB_CONFIG_UPDATE_FAILURE_TIMER_EXPIRY:
                                                    {
                                                        if (oam_send_enb_config_update() != OAM_SUCCESS)
                                                        {
                                                            OAM_LOG(OAM, OAM_WARNING, "Failed to send enb config update");
                                                        }
                                                        else
                                                        {
                                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                                            if(OAM_NULL != (oam_prov_req.system_status.timer_id =
                                                                        oam_start_new_timer(OAM_SUB_MODULE_MIH,
                                                                            OAM_MODULE_ID,
                                                                            OAM_ENB_CONFIG_UPDATE_TIMER,
                                                                            OAM_USER_INTF_RESP_TIMEOUT_S * OAM_THOUSAND,
                                                                            p_api_buf,
                                                                            length_left,
                                                                            OAM_FALSE)))
                                                            {
                                                                OAM_LOG(OAM,OAM_INFO,"Layers Config Timer started successfully");
                                                            }
                                                        }
                                                    }
                                                    break;

                                                    default:
                                                    OAM_LOG(OAM,OAM_DETAILED,"Received failure from L3 for s1ap_oam_enb_config_update_response %d\
                                                            No retry will be performed",s1ap_oam_enb_config_update_response.response);
                                                    break;
                                                }
                                                /* SPR_20467_FIX_START */
                                            }
                                            /* SPR_20467_FIX_END */
                                        }
                                        else
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED,"Received damaged s1ap_oam_enb_config_update_response from L3");
                                        }
                                        /* SPR 16567 END */
                                        break;

        case RRC_OAM_ADD_LGW_RESP:
                                        {
                                            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                                            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                                                break;
                                            }
#endif
                                            /* SPR 9620 CHANGE END */

                                            oam_rrc_lgw_enable = OAM_TRUE ;
                                            UInt16 trans_id_resp = get_word_from_header((UInt8*)(p_api_buf));
                                            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                            {
                                                OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                            }
                                            OAM_LOG(OAM, OAM_INFO, "Received RRC_OAM_ADD_LGW_RESP ");
                                            msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
                                            length_read = OAM_ZERO;
                                            oam_rrc_add_lgw_resp_t oam_rrc_add_lgw_resp = {OAM_ZERO};
                                            if(OAM_FAILURE == oam_rrc_il_parse_rrc_oam_add_lgw_resp(&oam_rrc_add_lgw_resp,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        msg_size - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        &length_read))
                                            {
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        (UInt8 *) "Internal Error",oam_strlen("Internal Error")+1,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }

                                            else
                                            {
                                                if(OAM_SUCCESS == oam_rrc_add_lgw_resp.response)
                                                {
                                                    OAM_LOG(OAM, OAM_DETAILED, "LGW Added Successfully");
                                                }
                                                else
                                                {
                                                    OAM_LOG(OAM, OAM_DETAILED, "RRC_OAM_ADD_LGW_RESP, LGW not Added ");
                                                }

                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                        OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }
                                        }
                                        break;

        case RRC_OAM_DELETE_LGW_RESP:

                                        {
                                            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                                            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                                                break;
                                            }
#endif
                                            /* SPR 9620 CHANGE END */

                                            oam_rrc_lgw_enable = OAM_FALSE;
                                            UInt16 trans_id_resp = get_word_from_header((UInt8*)(p_api_buf));
                                            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                            {
                                                OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                            }
                                            OAM_LOG(OAM, OAM_INFO, "Received RRC_OAM_DELETE_LGW_RESP");

                                            msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
                                            length_read = OAM_ZERO;

                                            oam_rrc_delete_lgw_resp_t oam_rrc_delete_lgw_resp = {OAM_ZERO};

                                            if(OAM_FAILURE == oam_rrc_il_parse_rrc_oam_delete_lgw_resp(&oam_rrc_delete_lgw_resp,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        msg_size - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        &length_read))
                                            {
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        (UInt8 *) "Internal Error",oam_strlen("Internal Error")+1,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }

                                            else
                                            {
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                        OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                        &error_code);

                                            }
                                        }
                                        break;

                                        /* CSR 00051709 Change Start */
        case  S1AP_OAM_MME_INFO :
                                        {
                                            s1ap_oam_mme_info_t oam_s1ap_mme_info = {OAM_ZERO};
                                            /* SPR-9485 START */

                                            /* SPR-16334 START */
                                            oam_return_et ret = OAM_SUCCESS;
                                            oam_bool_et  isDelta = OAM_FALSE;
#ifdef OAM_SON_ENABLE
                                            local_oam_anr_gu_group_info_t local_oam_anr_gu_group_info = {OAM_ZERO};
                                            oam_son_anr_gu_group_id_config_req_t oam_son_anr_gu_group_id_config_req = {OAM_ZERO};
                                            /* BCOM Compiltaion Fix */
                                            UInt16 cell_index = OAM_ZERO;
                                            /* BCOM Compiltaion Fix */
#else
                                            local_oam_gu_group_id_list_t local_oam_gu_group_id_list = {OAM_ZERO};
                                            oam_x2ap_enb_config_update_req_t ecu_req = {OAM_ZERO};
#endif
                                            SInt8  mme_index = -1;
                                            /* BCOM Compiltaion Fix */

                                            /* SPR-16334 END */

                                            /* SPR-9485 START */
                                            msg_size = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
                                            length_read = OAM_ZERO;

                                            OAM_LOG(OAM, OAM_INFO, 
                                                    "Received S1AP_OAM_MME_INFO");

                                            if(OAM_SUCCESS == oam_rrc_il_parse_s1ap_oam_mme_info((s1ap_oam_mme_info_t *)&oam_s1ap_mme_info,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        msg_size  - LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        &length_read))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, 
                                                        "Successfully Parsed S1AP_OAM_MME_INFO");
                                                /* SPR-9485 START */
#ifdef OAM_SON_ENABLE
                                                createCurrGrpIdList(&local_oam_anr_gu_group_info, 
                                                        /*Coverity 66604 Fix Start*/
                                                        &oam_s1ap_mme_info.mme_info.served_gummei_info);
                                                /*Coverity 66604 Fix END*/

                                                /* SPR-16334 START */
                                                isDelta = getDelta(&local_oam_anr_gu_group_info,
                                                        &oam_son_anr_gu_group_id_config_req,
                                                        /*Coverity 66605 Fix Start*/
                                                        &oam_s1ap_mme_info,
                                                        /*Coverity 66605 Fix Start*/
                                                        &mme_index);
#else
                                                createCurrGrpIdList(&local_oam_gu_group_id_list,
                                                        /*Coverity 66604 Fix Start*/
                                                        &oam_s1ap_mme_info.mme_info.served_gummei_info);
                                                /*Coverity 66604 Fix End*/

                                                isDelta = getDelta(&local_oam_gu_group_id_list,
                                                        &ecu_req,
                                                        /*Coverity 66605 Fix Start*/
                                                        &oam_s1ap_mme_info,
                                                        /*Coverity 66605 Fix Start*/
                                                        &mme_index);
#endif
                                                /* SPR-16334 END */
                                                if(OAM_TRUE == isDelta)
                                                {
                                                    OAM_LOG(OAM, OAM_DETAILED, 
                                                            "Difference found in add/delete list of group_id");
                                                }
                                                else
                                                {
                                                    OAM_LOG(OAM, OAM_DETAILED, 
                                                            "S1AP_OAM_MME_INFO, No Difference found in add/delete listi of group_id");
                                                }
                                                /*Coverity 66603 Fix Start */
                                                ret = addUpdateMMEInfo((s1ap_oam_mme_info_t *)&oam_s1ap_mme_info, mme_index);
                                                /*Coverity 66603 Fix Start */
                                                if(OAM_SUCCESS == ret)
                                                {
                                                    OAM_LOG(OAM, OAM_DETAILED, 
                                                            "Successfully added/updated MME info");
                                                }
                                                else
                                                {
                                                    OAM_LOG(OAM, OAM_DETAILED, 
                                                            "S1AP_OAM_MME_INFO, Unable to add/update MME info");
                                                }

                                                /* SPR-16334 START */
                                                if((OAM_TRUE == isDelta) && 
                                                        (OAM_SUCCESS == ret))
                                                {
#ifdef OAM_SON_ENABLE
                                                    if(OAM_FAILURE == oam_son_send_son_oam_anr_gu_group_id_config_req
                                                            (&oam_son_anr_gu_group_id_config_req, 
                                                             OAM_MODULE_ID,
                                                             SON_MODULE_ID, 
                                                             trans_id,
                                                             cell_index)) 
                                                    {
                                                        OAM_LOG(OAM, OAM_ERROR, 
                                                                "Failure in sending SON_OAM_ANR_GU_GROUP_ID_CONFIG_REQ");
                                                    }
                                                    else
                                                    {
                                                        OAM_LOG(OAM, OAM_DETAILED, 
                                                                "Successfully sent SON_OAM_ANR_GU_GROUP_ID_CONFIG_REQ");
                                                    }
#else
                                                    /* send list for all enb with link up */
                                                    ecu_req.bitmask |= X2AP_SERVED_CELLS_TO_MODIFY_LIST_PRESENT;   
                                                    if(OAM_SUCCESS == oam_update_list_all_enb(&ecu_req))
                                                    {    
                                                        oam_update_serving_enb_info(&ecu_req);
                                                        if(OAM_FAILURE == oam_send_x2ap_enb_config_update_req(&ecu_req))
                                                        {
                                                            OAM_LOG(OAM, OAM_ERROR,
                                                                    "Failure in sending X2AP_ENB_CONFIG_UPDATE_REQ");
                                                        }
                                                        else
                                                        {
                                                            OAM_LOG(OAM, OAM_DETAILED,
                                                                    "Successfully sent X2AP_ENB_CONFIG_UPDATE_REQ");
                                                        }
                                                    }
#endif
                                                }

                                                /* SPR-16334 END */

                                            }			/* SPR-9485 END */
                                        }

                                        break;
        case S1AP_ADD_MME_RES:
                                        {
                                            /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
                                            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id, &trans_id_resp, &dest_id))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                                                break;
                                            }
#endif
                                            /* SPR 9620 CHANGE END */

                                            oam_s1ap_add_mme_res_t oam_s1ap_add_mme_resp ={OAM_ZERO};

                                            /* SPR 11090 Change Start*/
                                            if(OAM_FAILURE == oam_process_tcb_for_layer_resp(p_api_buf,&trans_id_resp,&dest_id))
                                            {
                                                OAM_LOG(OAM,OAM_WARNING, "Deletion from TCB failed");
                                                return OAM_FAILURE;

                                            }
                                            /* SPR 11090 Change End*/
                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                            length_read= OAM_ZERO;

                                            if(OAM_SUCCESS==oam_parse_s1ap_add_mme_res(&oam_s1ap_add_mme_resp,p_api_buf +
                                                        LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        (SInt32 *)&length_read))
                                            {

                                                OAM_LOG(OAM,OAM_DETAILED,"Successfully Parsed S1AP_ADD_MME_RES");
                                                if(OAM_SUCCESS == oam_s1ap_add_mme_resp.response) 
                                                {
                                                    OAM_LOG(OAM,OAM_DETAILED,"Sending Success Resp To User");
                                                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                                                            OAM_ZERO,(UInt8 *)OAM_NULL,OAM_ZERO,
                                                            OAM_VERSION_ID, OAM_MODULE_ID,
                                                            dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                            &error_code);

                                                }
                                                else 
                                                {          
                                                    OAM_LOG(OAM,OAM_DETAILED,"S1AP_ADD_MME_RES, Sending Failure Resp To User");
                                                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                            OAM_ERR_INTERNAL_ERROR,
                                                            (UInt8 *) "Internal Error",oam_strlen("Internal Error")+1,
                                                            OAM_VERSION_ID, OAM_MODULE_ID,
                                                            dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                            &error_code);
                                                }
                                                g_flag_add_mme_sent = OAM_FALSE; 
                                            } 
                                            else                            
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED,"S1AP_ADD_MME_RES, Sending Failure Resp To User");
                                                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        (UInt8 *) "Internal Error",oam_strlen("Internal Error")+1,
                                                        OAM_VERSION_ID, OAM_MODULE_ID,
                                                        dest_id, trans_id_resp, OAM_ZERO, OAM_ZERO,
                                                        &error_code);


                                            }
                                            oam_memcpy(&oam_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,
                                                    &local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,OAM_MAX_MME_LIST_LEN);
                                        }
                                        break;
        case RRC_OAM_RESET_CELL_STATS_RESP:
                                        {
                                            if(OAM_FAILURE == oam_handle_rrc_reset_resp(p_api_buf, &error_code))
                                            {
                                                OAM_LOG(OAM, OAM_DETAILED, "Failure in oam_handle_rrc_reset_resp function.");
                                                OAM_FUN_EXIT_TRACE();
                                                return OAM_FAILURE;    
                                            }
                                        }
                                        break;    

                                        /* LWA changes start*/
                                        /* LWA changes end*/
                                        /*spr 22474 start*/
        case RRC_OAM_GET_DEBUG_INFO_RESP:
                                        {
                                            OAM_LOG(OAM,OAM_DETAILED, "Received RRC_OAM_GET_DEBUG_INFO_RESP from RRC");
                                            rrc_oam_get_debug_info_resp_t oam_rrc_get_debug_info_resp;
                                            oam_memset(&oam_rrc_get_debug_info_resp, 0x00, sizeof(rrc_oam_get_debug_info_resp_t));
                                            UInt16 dst_id = OAM_ZERO;
                                            trans_id_resp = get_word_from_header((UInt8 *)p_api_buf);
                                            UInt8 **str_arr = OAM_NULL;/* stores the strings[line][text] to be printed */
                                            UInt8 size_x = OAM_ZERO; /* Counts the number of strings to be printed */
                                            if(OAM_FAILURE == oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id(trans_id_resp, &trans_id, &dst_id))
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "oam_stop_timer_and_delete_tcb_entry_get_tid_and_dest_id_via_trans_id function failed");
                                                return OAM_FAILURE;
                                            }
                                            length_left = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                                            length_read= OAM_ZERO;

#ifndef OAM_UT_FRAMEWORK
                                            if(OAM_SUCCESS == oam_rrc_il_parse_rrc_oam_get_debug_info_resp(&oam_rrc_get_debug_info_resp,
                                                        p_api_buf + LOWER_LAYER_INTERFACE_HEADER_SIZE,
                                                        length_left - LOWER_LAYER_INTERFACE_HEADER_SIZE ,
                                                        &length_read))
                                            {
                                                OAM_LOG(OAM,OAM_DETAILED, "Successfully Parsed RRC_OAM_GET_DEBUG_INFO_RESP");
                                                if(oam_rrc_get_debug_info_resp.response == OAM_SUCCESS)
                                                {
                                                    OAM_LOG(OAM,OAM_DETAILED, "RRC_OAM_GET_DEBUG_INFO_RESP Success");
                                                    size_x = oam_get_l3_debug_info_prints(&oam_rrc_get_debug_info_resp,&str_arr);
                                                    if (size_x)
                                                    {
                                                        oam_construct_n_send_gpv_response((UInt8 *)"Debug.Get.L3.RRC", str_arr, size_x,
                                                                trans_id_resp, &error_code, dst_id, OAM_ZERO, OAM_ZERO);
                                                    }
                                                    else
                                                    {
                                                        OAM_LOG(OAM,OAM_ERROR,"Received error in response from RRC in RRC_OAM_GET_DEBUG_INFO_RESP %u %u",
                                                                oam_rrc_get_debug_info_resp.response, size_x);

                                                        oam_construct_n_send_get_resp_to_usr(
                                                                OAM_RESULT_FAILURE,
                                                                OAM_ERR_INTERNAL_ERROR,
                                                                OAM_VERSION,
                                                                OAM_MODULE_ID,dst_id,
                                                                trans_id_resp,
                                                                OAM_ZERO,OAM_ZERO,"RRC LAYER FAILURE RESPONSE",
                                                                &error_code
                                                                );
                                                    }

                                                }
                                                else
                                                {
                                                    OAM_LOG(OAM,OAM_DETAILED,"RRC_OAM_GET_DEBUG_INFO_RESP failed with error code %d",
                                                            oam_rrc_get_debug_info_resp.fail_cause);
                                                    oam_construct_n_send_get_resp_to_usr(
                                                            OAM_RESULT_FAILURE,
                                                            OAM_ERR_INTERNAL_ERROR,
                                                            OAM_VERSION,
                                                            OAM_MODULE_ID,dst_id,
                                                            trans_id_resp,
                                                            OAM_ZERO,OAM_ZERO,"RRC LAYER FAILURE RESPONSE",
                                                            &error_code
                                                            );

                                                }
                                            }
                                            else
                                            {
                                                OAM_LOG(OAM,OAM_ERROR, "Parsing of RRC_OAM_GET_DEBUG_INFO_RESP failed");
                                                oam_construct_n_send_get_resp_to_usr(
                                                        OAM_RESULT_FAILURE,
                                                        OAM_ERR_INTERNAL_ERROR,
                                                        OAM_VERSION,
                                                        OAM_MODULE_ID,dst_id,
                                                        trans_id_resp,
                                                        OAM_ZERO,OAM_ZERO,"RRC LAYER FAILURE RESPONSE",
                                                        &error_code
                                                        );
                                            }
#endif
                                            break;
                                        }
                                        /*spr 22474 end*/


        default:
                                        {
                                            OAM_LOG(OAM,OAM_WARNING,"Invalid api_id %d received in rrc Msg Handler!!!",api_id );
                                            return OAM_FAILURE;
                                        }
    }

    OAM_FUN_EXIT_TRACE();
    /* SPR 21449 Fix Start */
    /* Code Removed */
    /* SPR 21449 Fix End */
    return OAM_SUCCESS;
}

/******************************************************************************
 * Function Name  : oam_populate_correct_x2ap_sctp_response 
 * Inputs         : p_oam_x2ap_get_sctp_status_resp 
 * Outputs        : none
 * Returns        : none 
 * Description    : 
 ******************************************************************************/
void
    oam_populate_correct_x2ap_sctp_response
(
 oam_x2ap_get_sctp_status_resp_t *p_oam_x2ap_get_sctp_status_resp      
 )
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 initial_sctp_count = OAM_ZERO;
    oam_counter_t counter = OAM_ZERO;
    /* SPR 15882 START */
    oam_counter_t indx = OAM_ZERO;

    initial_sctp_count = MAX_NUM_MME + oam_prov_req.oam_l3_req.sctp_params.current_no_of_x2ap_conns;

    if(initial_sctp_count >= MAX_PEER_ENB)
    {
        OAM_LOG(OAM,OAM_WARNING,"Max number of X2AP sctp associtions reached");
        return;
    }

    for(indx = OAM_ZERO; 
            indx < p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.num_peer_enb;
            indx++)
    {
        /* First search the entry in the list by comparing ip and port*/
        for (counter = MAX_NUM_MME; counter < initial_sctp_count; counter++)
        {
            if(
                    (!oam_strcmp(
                                 (char *)&oam_prov_req.oam_l3_req.sctp_params.
                                 sctp_assoc_params[counter].primary_peer_addr,
                                 (char *)&p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.
                                 staus_params[indx].primary_peer_addr)) &&
                    (oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].local_port ==
                     p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.
                     staus_params[indx].local_port) 
              )
            {
                /* matching sctp assoc. entry found; Update its status */
                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].status = 
                    p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].status; 

                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].in_streams = 
                    p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].in_streams;

                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].out_streams = 
                    p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].out_streams;

                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].start_time.tv_sec= 
                    p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].start_time.tv_sec;

                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].start_time.tv_usec= 
                    p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].start_time.tv_usec;

                OAM_LOG(OAM,OAM_DETAILED,"Updated the sctp entry at index  : %u",counter);
                break;

            }
        }/* end of internal for loop */

        if(counter == initial_sctp_count)
        {
            /* No matching entry has been found, ADD a new entry */

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].status = 
                p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].status; 

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].in_streams = 
                p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].in_streams;

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].out_streams = 
                p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].out_streams;

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].local_port = 
                p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].local_port;

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].start_time.tv_sec= 
                p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].start_time.tv_sec;

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].start_time.tv_usec= 
                p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].start_time.tv_usec;

            oam_strcpy((Char8*)oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].primary_peer_addr, 
                    (Char8*)p_oam_x2ap_get_sctp_status_resp->x2ap_oam_gb_enb_status_params_list.staus_params[indx].primary_peer_addr);

            oam_prov_req.oam_l3_req.sctp_params.current_no_of_x2ap_conns++;
            initial_sctp_count++;

            OAM_LOG(OAM,OAM_DETAILED,"Added a new SCTP assoc. entry at index: %u",counter);
        }

    }
    /* SPR 15882 END */

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name  : oam_populate_correct_x2ap_sctp_response 
 * Inputs         : p_oam_x2ap_get_sctp_status_resp 
 * Outputs        : none
 * Returns        : none 
 * Description    : 
 ******************************************************************************/
void
    oam_populate_correct_s1ap_sctp_response
(
 oam_s1ap_get_sctp_status_resp_t *p_oam_s1ap_get_sctp_status_resp           
 )
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 initial_sctp_count = OAM_ZERO;
    oam_counter_t counter = OAM_ZERO;
    /* SPR 15882 START */

    oam_counter_t indx = OAM_ZERO;

    initial_sctp_count = oam_prov_req.oam_l3_req.sctp_params.current_no_of_s1ap_conns;

    if(initial_sctp_count >= MAX_NUM_MME)
    {
        OAM_LOG(OAM,OAM_WARNING,"Max number of S1AP sctp associtions reached");
        return;
    }

    for(indx = OAM_ZERO; 
            indx < p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.num_mme_id;
            indx++)
    {
        /* First search the entry in the list by comparing ip and port*/
        for (counter = OAM_ZERO; counter < initial_sctp_count; counter++)
        {
            if(
                    (!oam_strcmp(
                                 (char *)&oam_prov_req.oam_l3_req.sctp_params.
                                 sctp_assoc_params[counter].primary_peer_addr,
                                 (char *)&p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.
                                 staus_params[indx].primary_peer_addr)) &&
                    (oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].local_port ==
                     p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.
                     staus_params[indx].local_port) 
              )
            {
                /* matching sctp assoc. entry found; Update its status */
                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].status = 
                    p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].status; 

                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].in_streams = 
                    p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].in_streams;

                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].out_streams = 
                    p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].out_streams;

                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].start_time.tv_sec= 
                    p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].start_time.tv_sec;

                oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].start_time.tv_usec= 
                    p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].start_time.tv_usec;

                OAM_LOG(OAM,OAM_DETAILED,"Updated the entry for mme_id : %u",
                        p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].mme_id);
                break;

            }
        }/* end of internal for loop */

        if(counter == initial_sctp_count)
        {
            /* No matching entry has been found, ADD a new entry */

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].status = 
                p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].status; 

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].in_streams = 
                p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].in_streams;

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].out_streams = 
                p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].out_streams;

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].local_port = 
                p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].local_port;

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].start_time.tv_sec= 
                p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].start_time.tv_sec;

            oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].start_time.tv_usec= 
                p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].start_time.tv_usec;

            oam_strcpy((Char8*)oam_prov_req.oam_l3_req.sctp_params.sctp_assoc_params[counter].primary_peer_addr, 
                    (Char8*)p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].primary_peer_addr);

            oam_prov_req.oam_l3_req.sctp_params.current_no_of_s1ap_conns++;
            initial_sctp_count++;

            OAM_LOG(OAM,OAM_DETAILED,"Added a new entry for mme_id : %u at index: %u",
                    p_oam_s1ap_get_sctp_status_resp->s1ap_oam_mme_status_params_list.staus_params[indx].mme_id,
                    counter);
        }

    }
    /* SPR 15882 END */

    OAM_FUN_EXIT_TRACE();
}

/* LWA changes start*/
/* LWA changes end*/

/* SPR-16334 START */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_IPV6Addr
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter IPV6Addr
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE  
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_IPV6Addr
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter loop %d p_cell_reconfig_req: %p", loop, p_cell_reconfig_req);
    local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.peer_enb_comm_info[0].bitmask |= X2_ENB_COMM_INFO_IPV6_IP_ADDR_PRESENT;
}
/* SPR-16334 END */




/******************************************************************************
 *   FUNCTION NAME: set_bitmask_PMax
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_PMax
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    set_bitmask_idle_mode_intra_freq_params(loop, p_cell_reconfig_req);
    (((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info).mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_P_MAX_SIB1_PRESENT;
    (((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info).mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_P_MAX_SIB3_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_SIntraSearch
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter SIntraSearch
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS: 
 *            
 ******************************************************************************/
void
    set_bitmask_SIntraSearch
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    set_bitmask_idle_mode_intra_freq_params(loop, p_cell_reconfig_req);
    (((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info).mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_S_INTRA_SEARCH_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_SNonIntraSearch
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter SNonIntraSearch
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_SNonIntraSearch
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    set_bitmask_idle_mode_intra_freq_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask |=  RRM_OAM_S_NON_INTRA_SEARCH_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ShortDRXCycle
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter ShortDRXCycle
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_ShortDRXCycle
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_mac_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.bitmask |=
        RRM_OAM_MAC_LAYER_PARAM_DRX_PRESENT; 
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].bitmask |= RRM_OAM_SHORT_DRX_CYCLE_PRESENT;     
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_speed_state_param
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter TEvaluation
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void 
    set_bitmask_speed_state_param
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.bitmask |= RRM_OAM_SPEED_STATE_PARAMS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_rlc_layer_param_srb
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter Tevaluation
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_rlc_layer_param_srb
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_RLC_LAYER_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.rlc_layer_params.rlc_layer_param_srb[OAM_ZERO].bitmask |= RRM_OAM_SRB_INFO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_rlc_layer_param_srb_2
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter Tevaluation
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_rlc_layer_param_srb_2
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_RLC_LAYER_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.rlc_layer_params.rlc_layer_param_srb[1].bitmask |= RRM_OAM_SRB_INFO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_idle_mode_intra_freq_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_idle_mode_intra_freq_params
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.bitmask |=
        RRM_OAM_IDLE_MODE_MOBILITY_INTRA_FREQ_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME:set_bitmask_intra_f_spd_st_factor
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter speed scale factor 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_intra_f_spd_st_factor
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    set_bitmask_idle_mode_intra_freq_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask |= RRM_OAM_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT;
    OAM_FUN_EXIT_TRACE();
}



/******************************************************************************
 *   FUNCTION NAME: set_bitmask_access_mgmt_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_access_mgmt_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= 
        RRM_OAM_RRM_ACCESS_MGMT_PARAMS_PRESENT;
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_access_mgmt_param_csg_id
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS:      void
 ******************************************************************************/
void
    set_bitmask_access_mgmt_param_csg_id
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    /* calling function to set the bitmask of its parent
       nodes bitmask to get reach on leaf node*/
    set_bitmask_access_mgmt_prms(loop, p_cell_reconfig_req);

    /* set the bitmask for csg id in  */
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->access_mgmt_params.bitmask |= RRM_OAM_CSG_ID_PRESENT;

    OAM_FUN_EXIT_TRACE();

}

/*SPR_6719 */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_irat_geran_cell_res_pri 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_irat_geran_cell_res_pri
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_inter_rat_geran_prms(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.carrier_freq_info_list.carrier_list[OAM_ZERO].common_info.present_bitmask|= RRM_OAM_CARRIER_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_inter_rat_eutran_to_geran_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_inter_rat_eutran_to_geran_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.bitmask |=
        RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_inter_rat_geran_speed_scale_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_inter_rat_geran_speed_scale_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_inter_rat_eutran_to_geran_prms(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.geran_reselection_params.bitmask |= RRM_OAM_T_RESELECTION_GERAN_SPEED_SCALE_FACTOR_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_inter_rat_geran_prms 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_inter_rat_geran_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_inter_rat_eutran_to_geran_prms(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_geran_params.bitmask |=
        RRM_OAM_GERAN_CARRIER_FREQ_PARAMETER;

    OAM_FUN_EXIT_TRACE();
}

/*SPR_6719 */

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_inter_rat_utra_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_inter_rat_utra_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.bitmask |= 
        RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.bitmask |=
        RRM_OAM_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_q_rx_lev_min_offset
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_q_rx_lev_min_offset
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    set_bitmask_idle_mode_intra_freq_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.bitmask |= 
        RRM_OAM_Q_RX_LEV_MIN_OFFSET_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_p_max
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_p_max
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_inter_freq_params_list.idle_mode_mobility_inter_freq_params[OAM_ZERO].bitmask |= RRM_OAM_P_MAX_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_message_size_group_a
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_preamble_info
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_mac_layer_params_rach(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.bitmask |= 
        RRM_OAM_RA_PREABLE_GROUPA_INFO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mod_period_coeff
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_mod_period_coeff
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_ADDL_SIB2_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= RRM_OAM_MODIFICATION_PERIOD_COEFF_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/*SPR 13970 FIX Start*/

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ac_barring_info
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_ac_barring_info
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_ADDL_SIB2_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= RRM_OAM_BARRING_INFO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ac_barring_for_mo_signalling
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_ac_barring_for_mo_signalling
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ac_barring_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask |= RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ac_barring_for_mo_data
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_ac_barring_for_mo_data
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ac_barring_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask |= RRM_OAM_AC_BARRING_MO_DATA_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ssac_barring_for_mmtel_voice_r9
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/

void
    set_bitmask_ssac_barring_for_mmtel_voice_r9
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ac_barring_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask |= RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.bitmask |= RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT;

    OAM_FUN_EXIT_TRACE();
}




/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ssac_barring_for_mmtel_video_r9
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/

void
    set_bitmask_ssac_barring_for_mmtel_video_r9
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ac_barring_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask |=                                RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.ssac_barring_r9.bitmask |=                RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ac_barring_for_csfb_r10
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/

void
    set_bitmask_ac_barring_for_csfb_r10
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_ADDL_SIB2_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.presence_bitmask |= RRM_OAM_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG;

    OAM_FUN_EXIT_TRACE();
}

/*SPR 13970 FIX End*/
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_operator
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_operator
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_default_paging_cycle
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_default_paging_cycle
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_ADDL_SIB2_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= RRM_OAM_DEFAULT_PAGING_CYCLE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_nB
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_nB
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    cell_config_idx = oam_get_rrm_cell_config_idx(
            oam_prov_req.cell_cntxt.curr_cell_cid);
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }


    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_ADDL_SIB2_INFO_PRESENT;
    local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].operator_info.sib_2_info.radio_res_config_common_sib.bitmask |=    RRM_OAM_NB_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_phy_layer_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_phy_layer_params
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_PHY_LAYER_PARAMS_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_earfcnul
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_earfcnul
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_RF_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.rf_params.rf_configurations.bitmask |= RRM_OAM_RF_CONFIGURATION_UL_EARFCN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_adl_sib_2
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_adl_sib_2
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_ADDL_SIB2_INFO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ul_cy_pre_len
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_ul_cy_pre_len
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_ADDL_SIB2_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.sib_2_info.radio_res_config_common_sib.bitmask |= RRM_OAM_UL_CYCLIC_PREFIX_LEN_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_common_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_common_params
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_common_params.bitmask |= RRM_OAM_SPEED_STATE_PARAMS_PRESENT;



    OAM_FUN_EXIT_TRACE();
}

/***************************************************************************
 * FUNCTION NAME:      oam_validate_one_element 
 * DESCRIPTION  :      This function will check for validation of parameter
 * Inputs       :      loop : index of the parameter in parameter table
 *              :      value: value to be validated
 *              :      index: the instance-id of the parameter, in case
 *                     of multi-instance parametrs
 * Output       :      p_p_orig_parent: current parent-child relationship of
 *                     the parameters requested by user representated
 *                     in xmlNode
 *              :      p_p_req_parent: the pointer to pointer to the xml
 *                     parent of the parameter being validated
 *              :      p_p_p_xml_struct_addr: This is the pointer to the
 *                     field parameter_parent in the parameter table in 
 *                     question
 * RETURNS      :      If the input value is valid returns
 *                     OAM_SUCCESS else returns OAM_FAILURE
 ***************************************************************************/
oam_return_et
oam_validate_one_element(UInt16 loop,
        UInt8 *p_value,
        xmlNode **p_p_orig_parent,
        xmlNode **p_p_req_parent,
        xmlNode ***p_p_p_xml_struct_addr,
        /* SPR 18930  FIX START */
        UInt8 index,
        UInt8 cid)
/* SPR 18930  FIX END  */
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 14153 FIX START */
    /* CODE DELETED */
    /* SPR 14153 FIX END */
    xmlChar *p_param_val = OAM_NULL;
    xmlNode *p_xml_node = OAM_NULL;
    /* SPR 13291 FIX START */
    /* SPR 18930  FIX START */
    //oam_bool_et new_child = OAM_FALSE;
    /* SPR 18930  FIX END */
    xmlNode *p_orig_xml_node = OAM_NULL;
    /* SPR 18930  FIX START */
    //xmlNode *p_prev = OAM_NULL;
    /* SPR 18930  FIX END */
    /* SPR 13291 FIX END */
    oam_return_et retVal = OAM_FAILURE;
    oam_bool_et node_found = OAM_FALSE; 
    UInt8 inst_id_val = OAM_ZERO;
    xmlNode **temp = OAM_NULL;
    /* SPR 18930  FIX START  */
    //UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    /* SPR 18930  FIX END  */
    XML_struct_cell_config *p_cellconfig_xml_st = OAM_NULL;
    SInt32 offset = OAM_ZERO;
    /* SPR 18930  FIX START */
    /* SPR 14152 FIX START */
    //oam_bool_et flag_new_parent = OAM_FALSE;
    /* SPR 14152 FIX END */
    /* SPR 18930  FIX END */

    /*SPR 21272  Fixed Start */
    UInt8 i = 1;

    /*SPR 21272 Fixed End */

    const xmlChar *parent_name = OAM_NULL;

    /* Spr 15596 Fix Start */
    if (!p_p_req_parent || !p_p_orig_parent ||
            /* Spr 15596 Fix End */
            !p_p_p_xml_struct_addr) {
        OAM_LOG(OAM, OAM_WARNING, "Null pointer error");

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    /* Coverity 64730 Changes Start */
    if (!(*p_p_req_parent) && !(*p_p_orig_parent)) {
        if (g_parameter_map_element[loop].parameter_mode &
                OAM_IS_CELL_SPEC_PARAM) {
            /* Point to base address of immediate parent of the parameter */
            temp = g_parameter_map_element[loop].xml_parameter_parent;

            OAM_LOG(OAM,OAM_DETAILED, "parent address =%p",temp);
            /* point to base address of CellConfig structure */
            /* spr_21013_fix_start */
            p_cellconfig_xml_st = &xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig;
            /* spr_21013_fix_end */

            /* Calculate offset of the actual parameter parent from 
             * CellConfig structure */
            offset = (UInt8*)temp - (UInt8*)p_cellconfig_xml_st;

            /* Find pointer to CellConfig xml structure corresponding to
             * current cell-id */
            p_cellconfig_xml_st = oam_get_xml_cellconfig_node(cid);
            OAM_LOG(OAM, OAM_DETAILED, "cid = %u, offset = %u ",cid,offset);

            if (!p_cellconfig_xml_st) {
                OAM_LOG(OAM, OAM_WARNING, "XML Cell data not found");

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }

            temp = (xmlNode**)((UInt8*)p_cellconfig_xml_st + offset);
        }
        else {
            temp = (g_parameter_map_element[loop].xml_parameter_parent);
        }

        *p_p_p_xml_struct_addr = temp;

        /* (*temp) now points to the immediate xml parent of the parameter in
         * question, or first parent of the list of parents if the parameter
         * in question is multi-instace object*/

        if(!temp || !(*temp)) {
            OAM_LOG(OAM, OAM_DETAILED,
                    "Parameter path for XML not defined, "
                    "validation can't continue.");

            OAM_FUN_EXIT_TRACE();
            return retVal;
        }

        *p_p_orig_parent = *temp;

        if (g_parameter_map_element[loop].
                parameter_mode & MULTI_INSTANCE_PARAM) {
            parent_name = (*p_p_orig_parent)->name;

            while (*p_p_orig_parent &&
                    xmlStrEqual(parent_name, (*p_p_orig_parent)->name)) {
                p_xml_node = oam_xml_find_tag((*p_p_orig_parent)->children,
                        (xmlChar*)"X_VENDOR_INSTANCE_ID");
                if(p_xml_node != OAM_NULL) {	
                    p_param_val = xmlNodeGetContent(p_xml_node);
                    inst_id_val = oam_atoi((Char8*)p_param_val);
                    /* SPR 13291 FIX START */
                    xmlFree(p_param_val);
                    /* SPR 13291 FIX END */

                    if (inst_id_val == index) {
                        node_found = OAM_TRUE;
                        break;
                    }
                }
                /* Move to next instance of object */
                /* SPR 13376 FIX START */
                *p_p_orig_parent = ((*p_p_orig_parent)->next);
                /* SPR 13376 FIX END */
            }

            /*SPR 21272  Fixed Start */
            if(OAM_FALSE == node_found) {
                *p_p_orig_parent  = *(g_parameter_map_element[loop].xml_parameter_parent);
                for(i = OAM_ONE; i < index; ++i) {
                    if (OAM_NULL == *p_p_orig_parent) {
                        OAM_LOG(OAM, OAM_WARNING, "Node not found in xml");
                        retVal = OAM_SUCCESS;
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }
                    *p_p_orig_parent = ((*p_p_orig_parent)->next);
                }
            }
        }


        *p_p_req_parent = oam_xmlCopyNode(*p_p_orig_parent, 1);
    }
    /*SPR 21272  Fixed End */


    /* Coverity 64730 Changes End */ 
    if(!g_parameter_map_element[loop].tag_name) {
        OAM_LOG(OAM, OAM_DETAILED, "Parameter path for XML not defined, "
                "validation can't continue.");

        OAM_FUN_EXIT_TRACE();
        return retVal;
    }

    if (!oam_schema_valid_ctxt) {
        OAM_LOG(OAM, OAM_WARNING, "oam_schema_valid_ctxt = NULL");

        OAM_FUN_EXIT_TRACE();
        return retVal;
    }


    /*finding pointer to node*/
    /* Coverity ID : 66589 Fix Start*/
    if (OAM_NULL != *(p_p_req_parent)) 
    { 
        p_xml_node = oam_xml_find_tag((*p_p_req_parent)->children,
                (xmlChar*)g_parameter_map_element[loop].tag_name);
    }
    /* Coverity ID : 66589 Fix End */

    /* SPR 13291 FIX START */
    if (OAM_NULL != *(p_p_orig_parent)) /* Coverity 81806 Fix */ 
    {
        p_orig_xml_node = oam_xml_find_tag((*p_p_orig_parent)->children,
                (xmlChar*)g_parameter_map_element[loop].tag_name);
    }
    /* SPR 13291 FIX END */

    if (!p_xml_node) {
        OAM_LOG(OAM, OAM_WARNING, "Parameter not found");
        retVal = OAM_FAILURE;

        OAM_FUN_EXIT_TRACE();
        return retVal;
    }


    /* SPR 13291 FIX START */
    /* SPR 16603 Fix Start */
    /*Store the old value of node present in the dom so that 
     * in case of failure recieved from lower layer its old value can be reverted to*/ 
    p_param_val = xmlNodeGetContent(p_orig_xml_node);
    /* SPR 16603 Fix End */

    /*setting new content of the node*/
    xmlNodeSetContent(p_orig_xml_node, p_value);

    /* SPR 14153 FIX START */
    retVal = oam_validate_tr196_schema(&oam_prov_req.system_status.p_xml_doc);
    if (OAM_SUCCESS == retVal) {
        OAM_LOG(OAM, OAM_DETAILED,
                "value %s of \"%s\" validated successfully",
                p_value, p_xml_node->name);
        /* SPR 14153 FIX END */

        /* SPR 13291 FIX START */
        /* Set this new value to the temporary node for backup, and
         * which is used later */
        xmlNodeSetContent(p_xml_node, p_value);

        /*SPR 21619 Start*/ 
        if((p_param_val!=OAM_NULL) && ('\0'==*p_param_val))
        {
            xmlFree(p_param_val);
            /* SPR 14476 START */

            p_param_val = xmlNodeGetContent(p_orig_xml_node);
            /* SPR 14476 END */
            /* SPR 13291 FIX END */
        }
        else if(p_param_val == OAM_NULL)
        {
            p_param_val = xmlNodeGetContent(p_orig_xml_node);
        }
        /*SPR 21619 End*/ 

        retVal = OAM_SUCCESS;
    }
    else {
        /* SPR 14153 FIX START */
        /* CODE DELETED */
        /* SPR 14153 FIX END */

        /*SPR 21272  Fixed Start */

        xmlNodeSetContent(p_xml_node, p_value);
        retVal = OAM_SUCCESS;


        //		xmlFreeNode(*p_p_req_parent);

        /*SPR 21272  Fixed End */

    }
    /* SPR 19221: CID 64730 Fix Start */ 
    /* Revert back any changes in original subtree */
    xmlNodeSetContent(p_orig_xml_node, p_param_val);
    /* SPR 14476 START */

    /*  coverity 93912/93915 fix start */
    /* code removed */
    /*  coverity 93912/93915 fix end */

    /* SPR 14476 END */
    /* SPR 19221: CID 64730 Fix END */ 

    /* Free the temporary memory */
    xmlFree(p_param_val);
    /* SPR 13291 FIX END */
    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/* SPR_19279_START */
/******************************************************************************
 *   FUNCTION NAME: validate_plmnlist_enable
 *   DESCRIPTION  : This function will check for validation of parameter
 *   Inputs       : Enable : parameter value
 *                  loop : loop value for future reference
 *   Output       : NONE
 *              
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
oam_return_et
    validate_plmnlist_enable
(
 UInt8 *parmeter_value,
 int loop,
 UInt8* index
 )
{
    OAM_FUN_ENTRY_TRACE();
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d, index ", loop,index);
    oam_return_et retVal = OAM_SUCCESS;
    oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
    oam_rrm_cell_plmnlist_data_t *p_cell_local_plmnlist_data = OAM_NULL;

    UInt8 curr_cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    SInt8 cell_config_idx = oam_get_cell_plmnlist_data_idx(curr_cid);

    /* Coverity 109475 + */
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return OAM_FAILURE;
    }
    /* Coverity 109475 - */

    p_cell_local_plmnlist_data =
        &LOCAL_RRM_PROV_REQ.plmnlist_data[cell_config_idx];
    p_cell_plmnlist_data =
        &RRM_PROV_REQ.plmnlist_data[cell_config_idx];

    UInt8 query_idx = p_cell_local_plmnlist_data->plmnlist_query_idx;
    /* SPR 19977 Fix Start*/
    oam_bool_et plmn_enable = (oam_bool_et)*parmeter_value;
    /* SPR 19977 Fix End*/

    if(p_cm_cntxt->state == OAM_CM_ST_ACTIVE)
    {
        if(plmn_enable == OAM_FALSE)
        {
            /* Check if the Primary PLMN is being disabled */
            if((p_cell_plmnlist_data->plmn_entries[query_idx].enable == OAM_TRUE)&& 
                    (p_cell_plmnlist_data->plmn_entries[query_idx].is_primary == OAM_TRUE))
            {
                OAM_LOG(OAM,OAM_WARNING,"Operation to disable primary PLMN cannot be allowed");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
        else /* Enable is set to True */
        {
            OAM_LOG(OAM,OAM_DETAILED,"In %s, plmn_enable %d GLOBAL curr_plmn_entries %d, query_idx %d",
                    __FUNCTION__,plmn_enable,RRM_PROV_REQ.plmnlist_data[cell_config_idx].curr_plmn_entries,query_idx);
            /* Check if the PLMN being enabled is
             * already present as an enabled entry */
            /* Check If Enable is set to TRUE for a
             * Primary PLMN at runtime (SPV after cell unlocked)*/
            if((p_cell_plmnlist_data->plmn_entries[query_idx].enable == OAM_FALSE) &&
                    (p_cell_plmnlist_data->plmn_entries[query_idx].is_primary == OAM_TRUE))
            {
                OAM_LOG(OAM,OAM_WARNING,"Operation to enable another primary PLMN cannot be allowed");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }

        }
    }
    else/* CM state is inactive */
    {
        if(plmn_enable == OAM_FALSE)
        {
            /* Check if the Primary PLMN is being disabled */
            if((p_cell_plmnlist_data->plmn_entries[query_idx].enable == OAM_TRUE)&& 
                    (p_cell_plmnlist_data->plmn_entries[query_idx].is_primary == OAM_TRUE))
            {
                OAM_LOG(OAM,OAM_INFO,"Primary PLMN is being disabled, "
                        "One Primary PLMN must be enabled before eNB Unlock");
                g_is_Primary_PLMN_present = OAM_FALSE;
            }
        }
        else /* Enable = 1 in SPV */
        {
            if(((p_cell_plmnlist_data->plmn_entries[query_idx].enable == OAM_FALSE)&&
                        (p_cell_plmnlist_data->plmn_entries[query_idx].is_primary == OAM_TRUE)))
            {
                if(g_is_Primary_PLMN_present == OAM_FALSE)
                {
                    /* SPV to Enable 1 Primary PLMN recieved */
                    g_is_Primary_PLMN_present = OAM_TRUE;
                }
                else
                {
                    OAM_LOG(OAM,OAM_WARNING,"Operation to enable more than 1 primary PLMN is not allowed");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
            }
        }
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/******************************************************************************
 *   FUNCTION NAME: validate_plmnlist_isprimary
 *   DESCRIPTION: This function will check for validation of parameter
 *   Inputs       : isPrimary : parameter value
 *                  loop : loop value for future reference
 *   Output       : NONE
 *              
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
oam_return_et
    validate_plmnlist_isprimary
(
 UInt8 *parmeter_value,
 int loop,
 UInt8* index
 )
{
    OAM_FUN_ENTRY_TRACE();
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d, index ", loop,index);
    oam_return_et retVal = OAM_SUCCESS;
    /* Coverity 109472 + - Code Removed */
    UInt8 curr_cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    UInt8 idx = OAM_ZERO;
    /* Coverity 109472 + */
    SInt8 cell_config_idx = oam_get_cell_plmnlist_data_idx(curr_cid);
    /* Coverity 109472 - */
    oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
    oam_rrm_cell_plmnlist_data_t *p_cell_local_plmnlist_data = OAM_NULL;

    /* Coverity 109470 + */
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return OAM_FAILURE;
    }
    /* Coverity 109470 - */

    p_cell_local_plmnlist_data =
        &LOCAL_RRM_PROV_REQ.plmnlist_data[cell_config_idx];
    p_cell_plmnlist_data =
        &RRM_PROV_REQ.plmnlist_data[cell_config_idx];

    UInt8 query_idx = p_cell_local_plmnlist_data->plmnlist_query_idx;
    /* SPR 19977 Fix Start*/
    oam_bool_et plmn_isPrimary = (oam_bool_et)*parmeter_value;
    /* SPR 19977 Fix End*/

    if(p_cm_cntxt->state == OAM_CM_ST_ACTIVE)
    {
        /* Check if the Enabled Primary PLMN is being changed */
        if((p_cell_plmnlist_data->plmn_entries[query_idx].enable == OAM_TRUE)&& 
                (p_cell_plmnlist_data->plmn_entries[query_idx].is_primary == OAM_TRUE) &&
                plmn_isPrimary == OAM_FALSE)
        {
            OAM_LOG(OAM,OAM_WARNING,"Operation to change primary PLMN cannot be allowed");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        /* Check if an Enabled PLMN is being made Primary */
        if((p_cell_plmnlist_data->plmn_entries[query_idx].enable == OAM_TRUE)&& 
                (p_cell_plmnlist_data->plmn_entries[query_idx].is_primary == OAM_FALSE) &&
                plmn_isPrimary == OAM_TRUE)
        {
            OAM_LOG(OAM,OAM_WARNING,"Operation to make other PLMN IsPrimary cannot be allowed");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        for(idx = OAM_ZERO;idx < RRM_PROV_REQ.plmnlist_data[cell_config_idx].curr_plmn_entries; idx++)
        {
            if( ((p_cell_plmnlist_data->plmn_entries[idx].enable == OAM_TRUE) &&
                        (p_cell_plmnlist_data->plmn_entries[idx].is_primary == OAM_TRUE)) &&
                    /* SPR 19977 Fix Start*/
                    ((plmn_isPrimary == OAM_TRUE)&&(idx != query_idx)) && 
                    (p_cell_local_plmnlist_data->plmn_entries[query_idx].enable == OAM_TRUE))
                /* SPR 19977 Fix End*/
            {
                OAM_LOG(OAM,OAM_WARNING,"Operation to enable another primary PLMN cannot be allowed");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
    }
    else
    {
        /* Check if the Enabled Primary PLMN is being changed */
        if((p_cell_plmnlist_data->plmn_entries[query_idx].enable == OAM_TRUE)&& 
                (p_cell_plmnlist_data->plmn_entries[query_idx].is_primary == OAM_TRUE) &&
                plmn_isPrimary == OAM_FALSE)
        {
            OAM_LOG(OAM,OAM_INFO,"IsPrimary status of the primary PLMN changed "
                    "One Primary PLMN must be present before eNB UNLOCK");
            g_is_Primary_PLMN_present = OAM_FALSE;
        }
        /* Check if an Enabled PLMN is being made Primary */
        if((p_cell_plmnlist_data->plmn_entries[query_idx].enable == OAM_TRUE)&& 
                (p_cell_plmnlist_data->plmn_entries[query_idx].is_primary == OAM_FALSE) &&
                plmn_isPrimary == OAM_TRUE)
        {
            if(OAM_FALSE == g_is_Primary_PLMN_present)
            {
                /* 1 PLMN made Primary */
                g_is_Primary_PLMN_present = OAM_TRUE;
            }
            else
            {
                OAM_LOG(OAM,OAM_WARNING,"Operation to make more than 1 PLMN Primary cannot be allowed");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }
    }
    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/******************************************************************************
 *   FUNCTION NAME: validate_plmnlist_plmnid
 *   DESCRIPTION: This function will check for validation of parameter
 *   Inputs       : PLMNID : parameter value
 *                  loop : loop value for future reference
 *   Output       : NONE
 *              
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
oam_return_et
validate_plmnlist_plmnid
(
 /* SPR 19977 Fix Start*/
 rrm_oam_cell_plmn_info_t *parmeter_value,
 /* SPR 19977 Fix End*/
 int loop,
 UInt8* index
 )
{
    OAM_FUN_ENTRY_TRACE();
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d, index ", loop,index);
    oam_return_et retVal = OAM_SUCCESS;
    /* Coverity 109460 + - Code Removed */
    UInt8 curr_cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    /* Coverity 109460 + */
    SInt8 cell_config_idx = oam_get_cell_plmnlist_data_idx(curr_cid);
    /* Coverity 109460 - */

    /* Coverity 109471 + */
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return OAM_FAILURE;
    }
    /* Coverity 109471 - */

    oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
    p_cell_plmnlist_data =
        &RRM_PROV_REQ.plmnlist_data[cell_config_idx];

    UInt8 idx = OAM_ZERO;
    for(idx = OAM_ZERO;idx < RRM_PROV_REQ.plmnlist_data[cell_config_idx].curr_plmn_entries; idx++)
    {
        /* SPR 19977 Fix Start*/
        if((p_cell_plmnlist_data->plmn_entries[idx].enable == OAM_TRUE)
                &&(p_cell_plmnlist_data->is_valid_bitmap & (1 << idx)))
        {
            if(OAM_ZERO == (oam_memcmp((void *)&RRM_PROV_REQ.plmnlist_data[cell_config_idx].plmn_entries[idx].plmn_id,
                            (void *)parmeter_value,
                            sizeof(rrm_oam_cell_plmn_info_t))))
                /* SPR 19977 Fix End*/
            {
                OAM_LOG(OAM,OAM_WARNING,"PLMNID recieved in SPV is duplicate");
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
        }

    }
    OAM_FUN_EXIT_TRACE();
    return retVal;
}
/* SPR_19279_END */

/* SPR 11001 FIX START */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_overload_action
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_load_config_overload_action
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].over_load_lvl_act.
        bitmask |= RRM_OAM_ACTION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_overload_lvl_prcnt
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_load_config_overload_lvl_prcnt
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].over_load_lvl_act.
        bitmask |= RRM_OAM_PERCNTG_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/*bug_13969_start */
/******************************************************************************
 *   FUNCTION NAME:set_bitmask_load_config_midload_eligible_ue 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS     :  NONE
 ******************************************************************************/

    void set_bitmask_load_config_midload_eligible_ue
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_MID_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].mid_load_lvl_act.
        bitmask |= RRM_OAM_EICIC_LOAD_CONFIG_PRESENT;
    p_req->serv_enb_cell_info[OAM_ZERO].mid_load_lvl_act.
        eicic_load_config.bitmask |= RRM_OAM_ELIGIBLE_UE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME:set_bitmask_load_config_overload_eligible_ue 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS     : NONE 
 ******************************************************************************/

    void set_bitmask_load_config_overload_eligible_ue
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].over_load_lvl_act.
        bitmask |= RRM_OAM_EICIC_LOAD_CONFIG_PRESENT;
    p_req->serv_enb_cell_info[OAM_ZERO].over_load_lvl_act.
        eicic_load_config.bitmask |= RRM_OAM_ELIGIBLE_UE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_highload_eligible_ue 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS     : NONE 
 ******************************************************************************/

    void set_bitmask_load_config_highload_eligible_ue
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].high_load_lvl_act.
        bitmask |= RRM_OAM_EICIC_LOAD_CONFIG_PRESENT;
    p_req->serv_enb_cell_info[OAM_ZERO].high_load_lvl_act.
        eicic_load_config.bitmask |= RRM_OAM_ELIGIBLE_UE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME:set_bitmask_load_config_midload_abs_pattern 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS      : NONE 
 ******************************************************************************/

    void set_bitmask_load_config_midload_abs_pattern
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_MID_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].mid_load_lvl_act.
        bitmask |=  RRM_OAM_EICIC_LOAD_CONFIG_PRESENT;
    p_req->serv_enb_cell_info[OAM_ZERO].mid_load_lvl_act.
        eicic_load_config.bitmask |= RRM_OAM_ABS_PATTERN_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_overload_abs_pattern 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS      : NONE 
 ******************************************************************************/

    void set_bitmask_load_config_overload_abs_pattern
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].over_load_lvl_act.
        bitmask |=  RRM_OAM_EICIC_LOAD_CONFIG_PRESENT;
    p_req->serv_enb_cell_info[OAM_ZERO].over_load_lvl_act.
        eicic_load_config.bitmask |= RRM_OAM_ABS_PATTERN_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME:set_bitmask_load_config_highload_abs_pattern
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS      : NONE
 ******************************************************************************/

    void set_bitmask_load_config_highload_abs_pattern
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].high_load_lvl_act.
        bitmask |=  RRM_OAM_EICIC_LOAD_CONFIG_PRESENT;
    p_req->serv_enb_cell_info[OAM_ZERO].high_load_lvl_act.
        eicic_load_config.bitmask |= RRM_OAM_ABS_PATTERN_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/*bug_13969_end */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_highload_lvl_prcnt
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_load_config_highload_lvl_prcnt
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].high_load_lvl_act.
        bitmask |= RRM_OAM_PERCNTG_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_highload_action
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_load_config_highload_action
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].high_load_lvl_act.
        bitmask |= RRM_OAM_ACTION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_midload_action
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_load_config_midload_action
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_MID_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].mid_load_lvl_act.
        bitmask |= RRM_OAM_ACTION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_midload_lvl_prcnt
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_load_config_midload_lvl_prcnt
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;

    p_req->serv_enb_cell_info[OAM_ZERO].
        bitmask |= RRM_OAM_MID_LOAD_LVL_ACT_PRESENT;

    p_req->serv_enb_cell_info[OAM_ZERO].mid_load_lvl_act.
        bitmask |= RRM_OAM_PERCNTG_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/* SPR 11001 FIX END */

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_irat_cell_res_pri
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_irat_cell_res_pri
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_inter_rat_utra_prms(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.idle_mode_mobility_inter_rat_utra_params.irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[OAM_ZERO].bitmask |= RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_drx_short_cy_timer
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_drx_short_cy_timer
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_mac_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.bitmask |=
        RRM_OAM_MAC_LAYER_PARAM_DRX_PRESENT; 
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[OAM_ZERO].bitmask |=  RRM_OAM_SHORT_DRX_CYCLE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ncl_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_ncl_params
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    cell_config_idx = oam_get_rrm_cell_config_idx(
            oam_prov_req.cell_cntxt.curr_cell_cid);
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }


    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.ncl_params.bitmask |= RRM_OAM_LTE_NCL_PRESENT;
    local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].ran_info.bitmask |= RRM_OAM_NCL_PARAMS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_connected_mode_mob
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/

void
    set_bitmask_connected_mode_mob
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_connected_mode_irat
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/

void
    set_bitmask_connected_mode_irat
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_mob(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.bitmask |= 
        RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_b2_threshold_1rsrp
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/



void
    set_bitmask_b2_threshold_1rsrp
(
 int loop,
 void  * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRM_OAM_B2_THRESHOLD_1RSRP_PRESENT;
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_b2_threshold_1rsrq
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/

void
    set_bitmask_b2_threshold_1rsrq
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRM_OAM_B2_THRESHOLD_1RSRQ_PRESENT;
}

/* SPR 13020 END */

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_irat_b1_th_utra_rscp
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_irat_b1_th_utra_rscp
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRMCM_RMIF_B1_THRESHOLD_UTRA_RSCP_PRESENT;
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_b1_th_utra_ecn0
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_b1_th_utra_ecn0
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRMCM_RMIF_B1_THRESHOLD_UTRA_ECN0_PRESENT;
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_b1_th_geran
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_b1_th_geran
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRMCM_RMIF_B1_THRESHOLD_GERAN_PRESENT;
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_b2_th_2u_rscp
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_b2_th_2u_rscp
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRMCM_RMIF_B1_THRESHOLD_2UTRA_RSCP_PRESENT;
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_b2_th_2u_ecn0
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_b2_th_2u_ecn0
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRMCM_RMIF_B1_THRESHOLD_2UTRA_ECN0_PRESENT;
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_b2_th_2geran
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_b2_th_2geran
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRMCM_RMIF_B1_THRESHOLD_2GERAN_PRESENT;

}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_b2_th_2cdma
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_b2_th_2cdma
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= RRM_OAM_B2_THRESHOLD_2CDMA_PRESENT;

}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_cell_ind_offset
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_cell_ind_offset
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ncl_params(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.ncl_params.lte_ncl.intra_freq_cells[OAM_ZERO].bitmask |= RRM_OAM_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_rstx_power
 * *   DESCRIPTION:
 * *      This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : NONE
 * *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 * *                                      OAM_SUCCESS else return OAM_FAILURE
 * ******************************************************************************/
void
    set_bitmask_rstx_power
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ncl_params(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.ncl_params.lte_ncl.intra_freq_cells[OAM_ZERO].bitmask |= RRM_OAM_INTRA_FREQ_R_STX_POWER_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 *   FUNCTION NAME: set_bitmask_epc_info
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_epc_info(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_cell_reconfig_req_t *p_req = p_cell_reconfig_req;
    p_req->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/* eICIC_PHASE_1_2_CHANGES_START */

#ifdef OAM_SON_ENABLE
/*SPR 14554 start*/
/****************************************************************************
 *   FUNCTION NAME:set_bitmask_cell_info_max_abs_usage_threshold 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS      : NONE
 *                                      
 ******************************************************************************/
    void 
set_bitmask_cell_info_max_abs_usage_threshold(int loop, void *p_serving_cell)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    son_cell_t *serving_cell = p_serving_cell;
    serving_cell->bitmask |= SON_CELL_ABS_USAGE_THRESHOLD_RANGE;
    serving_cell->abs_usage_threshold.bitmask |= SON_CELL_MAX_ABS_USAGE_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_cell_info_max_abs_usage_threshold 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS      : NONE
 *                       
 ******************************************************************************/
    void 
set_bitmask_cell_info_min_abs_usage_threshold(int loop, void *p_serving_cell)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    son_cell_t *serving_cell = p_serving_cell;
    serving_cell->bitmask |= SON_CELL_ABS_USAGE_THRESHOLD_RANGE;
    serving_cell->abs_usage_threshold.bitmask |= SON_CELL_MIN_ABS_USAGE_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();


}
/*SPR 14554 end*/
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_neighbour_default_config_nr_status
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_neighbour_default_config_nr_status(int loop, void *p_neighbor_default_config_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_neighbor_default_config_req_t *default_config = p_neighbor_default_config_req;
    default_config->bitmask |= SON_OAM_ANR_NBR_DEF_NR_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_neighbour_default_config_ho_status
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_neighbour_default_config_ho_status(int loop, void *p_neighbor_default_config_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_neighbor_default_config_req_t *default_config = p_neighbor_default_config_req;
    default_config->bitmask |= SON_OAM_ANR_NBR_DEF_HO_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_neighbour_default_config_x2_status
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_neighbour_default_config_x2_status(int loop, void *p_neighbor_default_config_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_neighbor_default_config_req_t *default_config = p_neighbor_default_config_req;
    default_config->bitmask |= SON_OAM_ANR_NBR_DEF_X2_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_neighbour_default_config_csg_cell_intf_scheme
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_neighbour_default_config_csg_cell_intf_scheme(int loop, void *p_neighbor_default_config_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_neighbor_default_config_req_t *default_config = p_neighbor_default_config_req;
    default_config->bitmask |= SON_OAM_ANR_CSG_DEF_SCHEME_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_neighbour_default_config_pico_cell_intf_scheme
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_neighbour_default_config_pico_cell_intf_scheme(int loop, void *p_neighbor_default_config_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_neighbor_default_config_req_t *default_config = p_neighbor_default_config_req;
    default_config->bitmask |= SON_OAM_ANR_PICO_DEF_SCHEME_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME:set_bitmask_neighbour_default_config_macro_cell_intf_scheme 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_neighbour_default_config_macro_cell_intf_scheme(int loop, void *p_neighbor_default_config_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_neighbor_default_config_req_t *default_config = p_neighbor_default_config_req;
    default_config->bitmask |= SON_OAM_ANR_MACRO_DEF_SCHEME_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

#endif
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_eicic_info
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_eicic_info(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        bitmask |= RRM_OAM_EICIC_INFO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_eicic_provision_type 
 *   DESCRIPTION:
 *      This function will check for validation of parameter eICICProvisionType 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_eicic_provision_type(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_eicic_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_EICIC_PROVISIONED_TYPE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/*SPR 14165 start*/
/*Deleted Rsrp,Rsrq*/
/*SPR 14165 end*/

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_eligible_ue
 *   DESCRIPTION:
 *      This function will check for validation of parameter rsrq
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_eligible_ue(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_eicic_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_EICIC_ELIGIBLE_UE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_num_abs_report 
 *   DESCRIPTION:
 *      This function will check for validation of parameter num_abs_repor 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_num_abs_report(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_ABS_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.bitmask |= RRM_OAM_NUM_ABS_REPORT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_abs_usage_low_threshold 
 *   DESCRIPTION:
 *      This function will check for validation of parameter AbsUsageLowThreshold 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_abs_usage_low_threshold(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_ABS_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.bitmask |= RRM_OAM_ABS_USAGE_LOW_THRESHOLD_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_abs_usage_high_threshold 
 *   DESCRIPTION:
 *      This function will check for validation of parameter AbsUsageHighThreshold 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_abs_usage_high_threshold(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_ABS_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.bitmask |= RRM_OAM_ABS_USAGE_HIGH_THRESHOLD_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_low_load_abs_pattern 
 *   DESCRIPTION:
 *      This function will check for validation of parameter LowLoadAbsPattern 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_low_load_abs_pattern(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_ABS_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.bitmask |= RRM_OAM_ABS_PATTERN_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.abs_pattern.bitmask |= RRM_OAM_LOW_LOAD_ABS_PATTERN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/*SPR 14180 start*/
/********************************************************************************
 *   FUNCTION NAME: set_bitmask_victim_meas_subset
 *   DESCRIPTION:
 *      This function will check for validation of parameter VictimMeasSubset 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
    void
set_bitmask_victim_meas_subset(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_ABS_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.bitmask |= RRM_OAM_ABS_PATTERN_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.abs_pattern.bitmask |= RRM_OAM_VICTIM_MEAS_SUBSET_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/*SPR 14180 end*/

/********************************************************************************
 *   FUNCTION NAME: set_bitmask_victim_abs_pattern 
 *   DESCRIPTION:
 *      This function will check for validation of parameter VictimAbsPattern 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
    void
set_bitmask_victim_abs_pattern(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_ABS_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.bitmask |= RRM_OAM_ABS_PATTERN_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.abs_info.abs_pattern.bitmask |= RRM_OAM_VICTIM_ABS_PATTERN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_mac_eicic_meas_report_periodicity 
 *   DESCRIPTION:
 *      This function will check for validation 
 *                     of parameter MacEicicMeasReportPeriodicity 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_mac_eicic_meas_report_periodicity(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_EICIC_TIMER_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.eicic_timer_info.bitmask |= RRM_OAM_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_aggressor_sel_timer 
 *   DESCRIPTION:
 *      This function will check for validation 
 *                     of parameter AggressorSelTimer 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_aggressor_sel_timer(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_EICIC_TIMER_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.eicic_timer_info.bitmask |= RRM_OAM_AGGRESSOR_SEL_TIMER_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_load_information_guard_timer 
 *   DESCRIPTION:
 *      This function will check for validation 
 *                     of parameter LoadInformationGuardTimer 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_load_information_guard_timer(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_EICIC_TIMER_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.eicic_timer_info.bitmask |= RRM_OAM_LOAD_INFORMATION_GUAURD_TIMER_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_load_information_collation_timer 
 *   DESCRIPTION:
 *      This function will check for validation 
 *                     of parameter LoadInformationCollationTimer 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_load_information_collation_timer(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_eicic_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_EICIC_TIMER_INFO_PRESENT;

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.eicic_timer_info.bitmask |= RRM_OAM_LOAD_INFORMATION_COLLATION_TIMER;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_dl_sinr_threshold_low_mark 
 *   DESCRIPTION:
 *      This function will check for validation of parameter DlSinrThreshLowMark 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_dl_sinr_threshold_low_mark(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_eicic_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_DL_SINR_THRESHOLD_LOW_MARK_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: set_bitmask_dl_sinr_threshold_high_mark 
 *   DESCRIPTION:
 *      This function will check for validation of parameter DlSinrThreshHighMark 
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_dl_sinr_threshold_high_mark(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_eicic_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.
        eicic_info.bitmask |= RRM_OAM_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/* eICIC_PHASE_1_2_CHANGES_END */
/* LTE_OAM_CA_PARAMETER_SUPPORT */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_is_ca_eligible
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_is_ca_eligible
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_IS_CA_ELIGIBLE_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_num_of_report
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_num_of_report
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |=  RRM_OAM_NUM_OF_REPORT_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ca_applicable_bitrate_dl
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_ca_applicable_bitrate_dl
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |=  RRM_OAM_CA_APPLICABLE_BITRATE_DL_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_is_masa
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_is_masa
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |=  RRM_OAM_IS_MASA_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_scell_deactivation_timer
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_scell_deactivation_timer
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |=  RRM_OAM_SCELL_DEACTIVATION_TIMER_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_calcualtion_window_size
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_load_calcualtion_window_size
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_disparity_threshold
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_load_disparity_threshold
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_LOAD_DISPARITY_THRESHOLD_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mcs_diff_threshold
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_mcs_diff_threshold
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_MCS_DIFF_THRESHOLD_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_prb_usage_water_mark
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_prb_usage_water_mark
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_PRB_USAGE_WATER_MARK_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_dl_deact_command_thresh
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_dl_deact_command_thresh
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_DL_DEACT_COMMAND_THRESH_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_dl_deact_mcs_low_thresh
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_dl_deact_mcs_low_thresh
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_DL_DEACT_MCS_LOW_THRESH_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_dl_qload_up_threshold
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void

    set_bitmask_dl_qload_up_threshold
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_DL_Q_LOAD_UP_THRESH_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_dl_qload_low_threshold
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_dl_qload_low_threshold
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_DL_Q_LOAD_LOW_THRESH_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_act_deact_trigger_count_threshold
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_act_deact_trigger_count_threshold
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;


    OAM_FUN_EXIT_TRACE();
}
/* SPR 16422 START */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_cqi_validity_timer
 *   DESCRIPTION:
 *                 This function will set bitmask for parameter PMax
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS:
 *
 ******************************************************************************/
void
    set_bitmask_cqi_validity_timer
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.ca_mac_scheduler_params.bitmask |= RRM_OAM_CQI_VALIDITY_TIMER_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.ca_config.bitmask |= RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_CA_CONFIG_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/* SPR 16422 END */

/* LTE_OAM_CA_PARAMETER_SUPPORT */


/****************************************************************************
 *   FUNCTION NAME: set_bitmask_epc_info_general
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_epc_info_general(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_cell_reconfig_req_t *p_req = p_cell_reconfig_req;
    set_bitmask_epc_info(loop, p_req);
    p_req->epc_info.epc_params.bitmask |= RRM_OAM_GENERAL_EPC_PARAMS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_eaid 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
    void
set_bitmask_eaid(int loop, void *p_cell_reconfig_req)
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_cell_reconfig_req_t *p_req = p_cell_reconfig_req;
    set_bitmask_epc_info_general(loop, p_req);
    p_req->epc_info.epc_params.general_epc_params.
        bitmask |= RRM_OAM_EMERGENCY_AREA_ID_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_phy_layer_param_prs 
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_phy_layer_param_prs
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req); 
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |= RRM_OAM_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_pdsch
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_pdsch

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_PDSCH_CONFIG_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_srs_max_up_pts
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_srs_max_up_pts

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    set_bitmask_physical_layer_params_srs(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.physical_layer_param_srs.bitmask |=
        RRM_OAM_SRS_MAX_UP_PTS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_srs
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_srs

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.physical_layer_param_srs.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT; 
    /* SPR 11105 FIX END */

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_prach
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_prach

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_pucch_tdd_ack_nack
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_pucch_tdd_ack_nack

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    set_bitmask_physical_layer_params_pucch(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.physical_layer_param_pucch.
        bitmask |= RRM_OAM_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_pucch_cqi_sinr_value
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_pucch_cqi_sinr_value

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    set_bitmask_physical_layer_params_pucch(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.physical_layer_param_pucch.
        bitmask |= RRM_OAM_PUCCH_CQI_SINR_VAL_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_pucch
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_pucch

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_pusch
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_pusch

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_ul_reference_signal_power
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_ul_reference_signal_power

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_UL_REF_SIG_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_ul_power_control
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_ul_power_control

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_UL_POWER_CTRL_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}




/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_prs
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_prs

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_addl_physical_layer_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
    void set_bitmask_physical_layer_params_addl_physical_layer_params
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.addl_physical_layer_params.bitmask |=
        RRM_OAM_ADDITIONAL_PHYSICAL_LAYER_PARAM_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_addl_physical_layer_pucch_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_addl_physical_layer_pucch_params

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    set_bitmask_physical_layer_params_addl_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.addl_physical_layer_params.
        addl_pucch_parameters.bitmask |= RRM_OAM_ADDITIONAL_PUCCH_PARAMS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_addl_physical_layer_pusch_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_addl_physical_layer_pusch_params

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    set_bitmask_physical_layer_params_addl_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.addl_physical_layer_params.
        bitmask |= RRM_OAM_ADDITIONAL_PUSCH_PARAMS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_addl_physical_layer_ul_reference_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_addl_physical_layer_ul_reference_params

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    set_bitmask_physical_layer_params_addl_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.addl_physical_layer_params.
        addtl_ul_reference_signal_params.bitmask |= RRM_OAM_ADDITIONAL_UL_REF_SIGNAL_PARAMS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params_tdd_frame_structure
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params_tdd_frame_structure

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    set_bitmask_physical_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=
        RRM_OAM_PHYSICAL_LAYER_PARAM_TDD_FRAME_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_physical_layer_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_physical_layer_params

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |=
        RRM_OAM_PHY_LAYER_PARAMS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mac_layer_params_ul_sync_loss_timer
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_mac_layer_params_ul_sync_loss_timer

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_mac_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.bitmask |=
        RRM_OAM_UL_SYNC_LOSS_TIMER_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mac_layer_params_n_gap
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_mac_layer_params_n_gap

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_mac_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.bitmask |=
        RRM_OAM_N_GAP_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}





/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mac_layer_params_drx
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_mac_layer_params_drx

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_mac_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.bitmask |=
        RRM_OAM_MAC_LAYER_PARAM_DRX_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mac_layer_params_rach
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_mac_layer_params_rach

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_mac_layer_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mac_layer_params.bitmask |=
        RRM_OAM_MAC_LAYER_PARAM_RACH_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mac_layer_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_mac_layer_params

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |=
        RRM_OAM_MAC_LAYER_PARAMS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_rlc_layer_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_rlc_layer_params

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |=
        RRM_OAM_RLC_LAYER_PARAMS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_rrc_timers_and_constants_timers
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_rrc_timers_and_constants_timers

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_rrc_timers_and_constants(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.rrc_timers_and_constants.bitmask |=
        RRM_OAM_RRC_TIMERS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_rrc_timers_and_constants_constants
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_rrc_timers_and_constants_constants

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_rrc_timers_and_constants(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.rrc_timers_and_constants.bitmask |=
        RRM_OAM_RRC_CONSTANTS_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}



/******************************************************************************
 *   FUNCTION NAME: set_bitmask_rrc_timers_and_constants
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void set_bitmask_rrc_timers_and_constants

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);

    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_RRC_TIMERS_CONST_PARAMS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}



/******************************************************************************
 *   FUNCTION NAME: set_bitmask_group_assignment_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 **************************************************************************/
void
    set_bitmask_group_assignment_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.addl_physical_layer_params.
        addtl_ul_reference_signal_params.bitmask |= RRM_OAM_GROUP_ASSIGMENT_PUSCH_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_cyclic_shift_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_cyclic_shift_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req); 
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.addl_physical_layer_params.
        addtl_ul_reference_signal_params.bitmask |= RRM_OAM_UL_REFER_SIGNAL_PUSCH_CYCLIC_SHIFT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_delta_pucch_format_1_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_delta_pucch_format_1_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_POWER_CONTROL_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.bitmask |= RRM_OAM_POWER_CONTROL_ENABLE_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.rrm_power_control_enable.
        bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_1_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_delta_pucch_format_1b_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_delta_pucch_format_1b_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_POWER_CONTROL_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.bitmask |= RRM_OAM_POWER_CONTROL_ENABLE_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.rrm_power_control_enable.
        bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_1B_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_delta_pucch_format_2_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_delta_pucch_format_2_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_POWER_CONTROL_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.bitmask |= RRM_OAM_POWER_CONTROL_ENABLE_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.rrm_power_control_enable.
        bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_2_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_delta_pucch_format_2b_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_delta_pucch_format_2b_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_POWER_CONTROL_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.bitmask |= RRM_OAM_POWER_CONTROL_ENABLE_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *) p_cell_reconfig_req)->operator_info.rrm_power_control_params.rrm_power_control_enable.
        bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_2B_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_delta_pucch_format_2a_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_delta_pucch_format_2a_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_POWER_CONTROL_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.bitmask |= RRM_OAM_POWER_CONTROL_ENABLE_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.rrm_power_control_enable.
        bitmask |= RRM_OAM_DELTA_F_PUCCH_FORMAT_2A_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_delta_preamble_msg_3_prms
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_delta_preamble_msg_3_prms
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_operator(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_POWER_CONTROL_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.bitmask |= RRM_OAM_POWER_CONTROL_ENABLE_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.rrm_power_control_params.rrm_power_control_enable.
        bitmask |= RRM_OAM_DELTA_PREAMBLE_MSG_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ran_info
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_ran_info
(
 int loop,
 void * p_cell_reconfig_req	
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_RAN_INFO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_ran_info
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_ran_info_rf_params
(
 int loop,
 void * p_cell_reconfig_req	
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_RAN_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_RF_PARAMS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/* SPR 13501 FIX START */
void
    set_bitmask_operator_info
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    OAM_FUN_ENTRY_TRACE();
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT; 

    OAM_FUN_EXIT_TRACE();
}

void
    set_bitmask_dynamic_icic_info_params
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    set_bitmask_operator_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

void
    set_bitmask_dl_resorce_partition_info
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    set_bitmask_operator_info(loop, p_cell_reconfig_req);
    set_bitmask_dynamic_icic_info_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.dynamic_icic_info.bitmask |= RRM_OAM_DL_RESOURCE_PARTITON_INFO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

void
    set_bitmask_cell_edge_region_dl
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    set_bitmask_operator_info(loop, p_cell_reconfig_req);
    set_bitmask_dynamic_icic_info_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.dynamic_icic_info.bitmask |= RRM_OAM_DL_RESOURCE_PARTITON_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.dynamic_icic_info.dl_resource_partition_info.bitmask |= RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

void
    set_bitmask_ul_resorce_partition_info
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    set_bitmask_operator_info(loop, p_cell_reconfig_req);
    set_bitmask_dynamic_icic_info_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.dynamic_icic_info.bitmask |= RRM_OAM_UL_RESOURCE_PARTITION_INFO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

void
    set_bitmask_cell_edge_region_ul
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    set_bitmask_operator_info(loop, p_cell_reconfig_req);
    set_bitmask_dynamic_icic_info_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.dynamic_icic_info.bitmask |= RRM_OAM_UL_RESOURCE_PARTITION_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.dynamic_icic_info.ul_resource_partition_info.bitmask |= RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/* SPR 13501 FIX END */

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_n1cs_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_n1cs_params
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_RAN_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.bitmask |=RRM_OAM_ADDITIONAL_PHYSICAL_LAYER_PARAM_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.addl_physical_layer_params.bitmask |=RRM_OAM_ADDITIONAL_PUCCH_PARAMS_PRESENT; 
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.addl_physical_layer_params.addl_pucch_parameters.bitmask |=RRM_OAM_N1_CS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * Function Name  : oam_handle_control_command_req 
 * Description    : This function handles the control command of TR069  
 * Inputs         : p_api_buf :Pointer to message Buffer
 *                  msg_len : Length of message
 *                  src_module_id : Source Module Identifier 
 * Output         : None 
 * Returns        : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
oam_return_et
    oam_handle_control_command_req
(
 void *p_api_buf
 )
{
    char	 	*p_api_buf_temp = p_api_buf;
    char		*p_start_param_list = OAM_NULL;
    UInt16 		len_of_admin_info = OAM_ZERO; 
    UInt16		cmd_name_len = OAM_ZERO;
    UInt8 		num_of_params = OAM_ZERO;
    oam_bool_et		entry_found = OAM_FALSE;
    oam_counter_t 	loop_counter = OAM_ZERO;
    Char8 		*comp_string = OAM_NULL;
    UInt8 		cmd_name[OAM_HUNDRED];
    /* coverity 35896 */
    OAM_FUN_ENTRY_TRACE();

    /* Increment the pointer to start of API Payload */
    p_api_buf_temp += OAM_MGMT_INTF_HEADER_SIZE;

    /* Decoding total length of parent + all children */
    /* length of input string is at 0 position in p_api_buf_temp*/

    len_of_admin_info  = get_word_from_header((UInt8*)(p_api_buf_temp)); 
    OAM_LOG(OAM,OAM_DETAILED,"Length of Admin Info in Control Command  == %d",
            len_of_admin_info);

    /* Points to start of parameter list */
    p_start_param_list = p_api_buf_temp ;
    p_start_param_list+= len_of_admin_info;

    /* Move the pointer to start of command name */
    p_api_buf_temp+= OAM_TWO*sizeof(UInt16); /* Move past the length and reserved field */   

    /* Calculate length of command name */
    cmd_name_len = len_of_admin_info - (OAM_TWO *sizeof(UInt8) +OAM_THREE*sizeof(UInt16) + sizeof(UInt32));

    oam_memcpy(cmd_name,p_api_buf_temp,cmd_name_len);

    /* Get no of parameters */
    oam_memcpy(&num_of_params,p_api_buf_temp+ cmd_name_len,sizeof(UInt8));


    /* Extract the comparison string, 
     * For e.g.: AdminControlCommand=Shutdown 
     * AdminControlCommand=Restart
     * AdminControlCommand=FactoryReset
     * AdminControlCommand=InitiateConfiguration * */

    /*Coverity Fix after comments*/
    comp_string = oam_strtok((char *)cmd_name,"=");
    OAM_LOG(OAM, OAM_DETAILED, " Comp string value [%s] ", comp_string);
    comp_string = oam_strtok(NULL, "=");
    if(OAM_NULL == comp_string)
    {
        OAM_LOG(OAM, OAM_WARNING, "Tokenized string is NULL");
        return OAM_FAILURE; 
    }
    for(loop_counter = OAM_ZERO; loop_counter < OAM_MAX_NO_OF_COMMANDS; ++loop_counter) {
        /* coverity 35432 */
        if(OAM_ZERO == oam_strncasecmp(comp_string, (Char8*)cmd_map_element[loop_counter].cmd_name, (sizeof(cmd_map_element[loop_counter].cmd_name))))
        {
#ifdef OAM_SON_ENABLE
            if((loop_counter == OAM_ONE) && g_oam_nmm_scan_first_time == OAM_TRUE) {
                UInt16 tran_id = oam_get_new_trans_id();
                UInt16 msg_len = get_word_from_header((UInt8 *)p_api_buf + OAM_EIGHT);
                if (OAM_FAILURE == oam_son_send_son_oam_nw_scan_req(
                            &(oam_prov_req.oam_son_req.nw_scan),
                            OAM_MODULE_ID,
                            SON_MODULE_ID,
                            tran_id,
                            oam_prov_req.cell_cntxt.curr_cell_cid))
                {
                    oam_memset(&(oam_prov_req.oam_igd_params.nw_scan_status),OAM_ZERO,sizeof(oam_nw_scan_status_t));
                    /*OAM_REVIEW_CHANGES*/
                    oam_memcpy(&(oam_prov_req.oam_igd_params.nw_scan_status.scan_status),oam_nw_scan_status[OAM_ZERO],OAM_THIRTY_TWO);
                    /*OAM_REVIEW_CHANGES*/
                    oam_memcpy(&(local_prov_req.oam_igd_params.nw_scan_status),&(oam_prov_req.oam_igd_params.nw_scan_status),sizeof(oam_nw_scan_status_t)); 
                    OAM_LOG(OAM, OAM_ERROR, "Failed to send SON_OAM_NW_SCAN_REQ");

                    cmd_map_element[loop_counter].callback(p_api_buf,num_of_params,(UInt8 *)p_start_param_list);
                    /* Call the corresponding callback */
                    entry_found = OAM_TRUE;
                    break;
                }
                oam_memset(&(oam_prov_req.oam_igd_params.nw_scan_status),OAM_ZERO,sizeof(oam_nw_scan_status_t));
                /*OAM_REVIEW_CHANGES*/
                oam_memcpy(&(oam_prov_req.oam_igd_params.nw_scan_status.scan_status),oam_nw_scan_status[OAM_ONE],OAM_THIRTY_TWO);
                /*OAM_REVIEW_CHANGES*/
                oam_memcpy(&(local_prov_req.oam_igd_params.nw_scan_status),&(oam_prov_req.oam_igd_params.nw_scan_status),sizeof(oam_nw_scan_status_t)); 
                if(OAM_NULL != (oam_prov_req.system_status.timer_id = oam_start_new_timer(OAM_SUB_MODULE_MIH, OAM_MODULE_ID,
                                OAM_TR069_INIT_NMM_TIMER_TYPE, OAM_TR069_INIT_NMM_TIMEOUT_DURATION * OAM_THOUSAND,
                                p_api_buf, msg_len, OAM_FALSE)))
                {
                    OAM_LOG(OAM,OAM_INFO,"Layers Config Timer started successfully");
                }
                else
                {
                    OAM_LOG(OAM,OAM_ERROR,"Failed to start Layers Config Timer");
                    cmd_map_element[loop_counter].callback(p_api_buf,num_of_params,(UInt8 *)p_start_param_list);
                    /* Call the corresponding callback */
                    entry_found = OAM_TRUE;
                    break;
                }
                oam_memcpy(nmm_tmp_str,p_api_buf,msg_len);
                oam_maintain_internal_tcb(tran_id,OAM_TRANS_SON,msg_len,p_api_buf); 
                entry_found = OAM_TRUE;
                break;
            }
#endif
            cmd_map_element[loop_counter].callback(p_api_buf,num_of_params,(UInt8 *)p_start_param_list);
            /* Call the corresponding callback */
            entry_found = OAM_TRUE;
            break;

        }
    }

    if(OAM_FALSE == entry_found)
    {
        OAM_LOG(OAM,OAM_WARNING,"Command not found in command table");
        UInt16 trans_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_ZERO);
        UInt16 dest_id  = get_word_from_header((UInt8*)(p_api_buf) + OAM_TWO); /* Src ID is Now Destination ID */
        oam_send_control_cmd_resp(trans_id,dest_id,OAM_RESULT_FAILURE,OAM_ERR_INVALID_PARAM_NAME,(UInt8 *)"Command not found");
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;

}

/******************************************************************************
 * Function Name  : oam_handle_shutdown_cmd 
 * Description    : This function handles the shutdown command
 * Inputs         : param_len : Length of parameter Info  
 *                  p_param_list : Pointer to start of parameter list
 * Output         : None
 * Returns        : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
oam_return_et
    oam_handle_shutdown_cmd
(
 void      *p_api_buf,
 UInt16 param_len,
 UInt8 *p_param_list
 )
{
    UInt8 status = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;
    /* Coverity FIX 35895 */
    oam_error_code_et error_code = NO_ERROR;
    UInt8 err_string[STR_LEN_80]={OAM_ZERO};
    /* Spr 12880 Fix Start*/
    UInt8 CellId = OAM_INVALID_CELL_ID;
    /* Spr 12880 Fix End*/
    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %u and %p", param_len, p_param_list);
    static UInt16 transaction_id;
    static UInt16 dest_id;
    status = OAM_RESULT_SUCCESS;

    /* Coverity 108803 + */
    if( (OAM_NULL != p_api_buf) &&
            ((shutdown_flag != OAM_TRUE)&&(OAM_TRUE == oam_prov_req.system_status.cell_setup_complete)) )
        /* Coverity 108803 - */
    {
        if (OAM_ZERO == admin_cmd_restart_flag)
        {
            admin_cmd_restart_flag = OAM_SDM_SHUTDOWN;
        }
        transaction_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_ZERO);
        dest_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_HDR_SRC_ID_OFFSET);
        OAM_LOG(OAM, OAM_DETAILED, "SHUTDOWN COMMAND CALLED. Sending Cell Block Request to RRM for shutdown OAM");
        transaction_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_ZERO);
        if(OAM_FAILURE == oam_handle_rrm_cell_block_for_shutdown(transaction_id,p_api_buf))
        {
            OAM_LOG(OAM, OAM_ERROR, "Sending RRM_OAM_CELL_BLOCK_REQ Failed");
        }
        shutdown_flag = OAM_TRUE;
    }
    else if((shutdown_flag == OAM_TRUE)||(OAM_FALSE == oam_prov_req.system_status.cell_setup_complete))
    {
        shutdown_flag = OAM_TRUE;
        /* SPR 12731 Fix Start */
        /* Performing Log Archival and Uploading to FTP Server */ 
        if(OAM_SUCCESS == oam_collect_logs())
        {
            OAM_LOG(OAM, OAM_DETAILED, "Saving all Logs files");
        }
        /* SPR 15366 START */
        /*SPR 20928 Fix Start */
        oam_pm_handle_shutdown_command(oam_prov_req.cell_cntxt.curr_cell_cid);
        /*SPR 20928 Fix End */
        /* SPR 15366 END */ 
        /* SPR 12731 Fix End */

        /* Coverity 108803 + */
        if( (OAM_NULL != p_api_buf) &&
                (oam_prov_req.system_status.cell_setup_complete == OAM_FALSE) ) 
            /* Coverity 108803 - */
        {
            transaction_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_ZERO);
            dest_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_TWO);

        }
        OAM_LOG(OAM, OAM_INFO, "shuting down OAM !!!");

        retVal = oam_qcli_maintain_parameter_persistance("BOTH",
                &error_code);
        if (OAM_FAILURE == retVal) {
            OAM_ALARM(CONFIG_FILE_PERSISTENCE_FAILURE_ALARM_ID,
                    MAJOR, NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                    SOFTWARE_ERROR, EXPEDITED_ALARM,
                    /* Spr 12880 Fix Start*/
                    "Configuration File Persistence Failure", OAM_NULL,CellId);
            /* Spr 12880 Fix End*/
        }

        /* This Function shall be implmented as part of Platform 
         * Related Services Activity */ 
        oam_port_process_shutdown();

        /* SPR 15366 START */
        /* Code Removed */
        /* Cleanup/Shutdown Request is not sent to
         * lower layers as shutdown/cleanup is not
         * supported at all the lower layers */
        /* SPR 15366 END */
        /* SPR 17777 fix */
        retVal = oam_cleanup_layers(transaction_id);
        if (OAM_FAILURE == retVal) {
            status = OAM_RESULT_FAILURE;
        }
        /* SPR FIX 11961 End */
        /*SPR 11488 FIX END*/
        if(dest_id != OAM_SDM_MODULE_ID) {
            retVal = oam_send_control_cmd_resp(transaction_id,
                    dest_id,
                    status,
                    OAM_ZERO,
                    err_string);
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Sending control command response to user failed");

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
        }

        if (OAM_SDM_UPGRADE == admin_cmd_restart_flag) {
            retVal = oam_send_sdm_ack_upgrade_start();
            if (OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR, "oam_send_sdm_ack_upgrade_start returned FAILURE");

                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
        }
        else if ((OAM_RESTART_VAL == admin_cmd_restart_flag) ||
                (OAM_FACTORY_RESET_VAL == admin_cmd_restart_flag) ||
                (OAM_SDM_SHUTDOWN == admin_cmd_restart_flag))	{
            oam_construct_n_send_sdm_command_req(admin_cmd_restart_flag);
        }
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/******************************************************************************
 * Function Name  : oam_handle_restart_cmd 
 * Description    : This function handles the resatrt command
 * Inputs         : param_len : Length of parameter Info  
 *                  p_param_list : Pointer to start of parameter list
 * Output         : None
 * Returns        : OAM_SUCCESS/OAM_FAILURE 
 *******************************************************************************/
oam_return_et
    oam_handle_restart_cmd
(
 void      *p_api_buf,
 UInt16 param_len,
 UInt8 *p_param_list
 )
{


    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %u and %p",param_len, p_param_list );

    OAM_LOG(OAM,OAM_DETAILED,"RESTART COMMAND CALLED");

    /* Shutdown fun to be provided from cm module returning SUCCESS AND FAILURE */	

    flag_shutdown_for_soft_upgrade = OAM_TRUE;
    admin_cmd_restart_flag = OAM_RESTART_VAL;
    if (OAM_FAILURE == oam_handle_shutdown_cmd(p_api_buf,OAM_ZERO,OAM_NULL))
    {
        OAM_LOG(OAM,OAM_ERROR,"Failed to Handle Shutdown Req");

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;

}

/******************************************************************************
 * * Function Name  : oam_handle_factoryreset_cmd 
 * * Description    : This function handles the factoryreset command
 * * Inputs         : param_len : Length of parameter Info  
 * *                  p_param_list : Pointer to start of parameter list
 * * Output         : None
 * * Returns        : OAM_SUCCESS/OAM_FAILURE 
 * ******************************************************************************/
oam_return_et
    oam_handle_factory_reset_cmd
(
 void      	*p_api_buf,
 UInt16 	num_of_params,
 UInt8 	*p_param_list
 )
{
    UInt8 param_name[STR_LEN_128]={OAM_ZERO};
    UInt16 len_addi_param = OAM_ZERO;

    UInt8 index = OAM_ZERO;

    OAM_FUN_ENTRY_TRACE();
    OAM_LOG(OAM,OAM_DETAILED,"FACTORY RESET COMMAND CALLED");


    if(num_of_params <=OAM_FOUR)
    {
        for(index= OAM_ZERO ; index < num_of_params ; index++)
        {
            len_addi_param  = get_word_from_header((UInt8*)(p_param_list));


            OAM_LOG(OAM,OAM_DETAILED,"Length of Additional parameter  == %d",
                    len_addi_param);
            p_param_list +=OAM_FOUR;

            oam_memset(param_name, OAM_ZERO, STR_LEN_128);
            oam_memcpy(param_name, p_param_list, len_addi_param -OAM_FOUR );
            p_param_list += len_addi_param -OAM_FOUR;

        }
    }
    else
    {	
        OAM_LOG(OAM, OAM_WARNING, "Incorrect no of arguments");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }


    /* Call wrapper function to reboot the machine */
    /* This function is never expected to return as */
    /*  it shall actually shutdown the system */
    /* This function shall be implemented as part of CM */

    admin_cmd_restart_flag = OAM_FACTORY_RESET_VAL;
    flag_shutdown_for_soft_upgrade = OAM_TRUE;
    if (OAM_FAILURE == oam_handle_shutdown_cmd(p_api_buf,OAM_ZERO,OAM_NULL))
    { 
        OAM_LOG(OAM,OAM_ERROR,"Failed to Handle Shutdown Req");

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/******************************************************************************
 * * Function Name  : oam_construct_n_send_sdm_command_req 
 * * Description    : This function construct and send the command to SDM for 
 * 			factoryReset and restart command
 * * Inputs         :
 * *                  admin_cmd_restart_flag : for restart or factoryReset indication
 * * Output         : None
 * * Returns        : OAM_SUCCESS/OAM_FAILURE 
 * ******************************************************************************/
    oam_return_et
oam_construct_n_send_sdm_command_req(
        UInt8  	admin_cmd_restart_flag 
        )
{
    UInt16 trans_id = OAM_ZERO ;
    oam_error_code_et p_err_code = NO_ERROR;
    UInt16 payload_len = OAM_ZERO;
    UInt8 *p_payload = OAM_NULL;
    UInt8 *p_msg = OAM_NULL;
    UInt32 curr_pos = OAM_ZERO;
    UInt16 msg_len = OAM_CSPL_HDR_SIZE + OAM_MGMT_INTF_HEADER_SIZE;

    trans_id = oam_get_new_trans_id();

    payload_len = OAM_MAX_COMM_REQ_INFO_BLOCK ; /*  Flag + 3 Reserved  */
    msg_len += payload_len;

    p_msg = oam_msg_mem_get(msg_len);
    p_payload = p_msg;
    if(PNULL == p_msg || PNULL == p_payload)
    {
        OAM_LOG(OAM,OAM_ERROR, "Memory allocation to p_msg failed");
        p_err_code = OAM_MALLOC_FAIL;
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    /* Fill CSPL header */
    oam_construct_api_header(p_payload, OAM_VERSION_ID, OAM_MODULE_ID,
            OAM_SDM_MODULE_ID, OAM_SDM_COMMAND_REQ, msg_len); /* To verify the api id of  OAM SDM COMMAND REQ */

    /*Move the pointer upto CSPL Header length*/ 
    p_payload += OAM_CSPL_HDR_SIZE;

    /* Fill interface header */
    oam_construct_interface_api_header(p_payload, trans_id,
            OAM_MODULE_ID, OAM_SDM_MODULE_ID,
            OAM_SDM_COMMAND_REQ,
            (msg_len - OAM_CSPL_HDR_SIZE),
            oam_prov_req.cell_cntxt.curr_cell_cid);

    /* Move the pointer upto management interface header */
    p_payload += OAM_MGMT_INTF_HEADER_SIZE;

    if (admin_cmd_restart_flag == OAM_RESTART_VAL)
    {
        *(p_payload + curr_pos++) = OAM_RESTART_VAL;
    }
    else if(admin_cmd_restart_flag == OAM_FACTORY_RESET_VAL)
    {
        /*fill the value for FactoryReset(2)*/
        *(p_payload + curr_pos++) = OAM_FACTORY_RESET_VAL;
    }	

    else if(admin_cmd_restart_flag == OAM_SDM_SHUTDOWN)
    {
        /*fill the value for Shutdown(4)*/
        *(p_payload + curr_pos++) = OAM_SDM_SHUTDOWN;
    }	
    *(p_payload + curr_pos++) = OAM_ZERO; 
    *(p_payload + curr_pos++) = OAM_ZERO; 
    *(p_payload + curr_pos++) = OAM_ZERO; 

    /* Send message to SDM Module*/
    if(OAM_FAILURE == oam_send_message(p_msg, OAM_SDM_MODULE_ID,&p_err_code))
    {
        OAM_LOG(OAM,OAM_ERROR,"Error in Sending message to SDM Module with error code %d",
                p_err_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/******************************************************************************
 * * Function Name  : oam_handle_intit_config_cmd 
 * * Description    : This function handles the inti_config command
 * * Inputs         : p_api_buf : pointer to api buf
 * *		      param_len : Length of parameter Info  
 * *                  p_param_list : Pointer to start of parameter list
 * * Output         : None
 * * Returns        : OAM_SUCCESS/OAM_FAILURE 
 * ******************************************************************************/
oam_return_et
    oam_handle_init_config_cmd
(
 void      	*p_api_buf,
 UInt16 	num_of_params,
 UInt8 	*p_param_list
 )
{
    UInt8 status = OAM_ZERO;
    UInt8 err_string[STR_LEN_80]={OAM_ZERO};


    OAM_FUN_ENTRY_TRACE();
    OAM_LOG(OAM,OAM_DETAILEDALL,"INIT CONFIG COMMAND CALLED, unused parameterr %u and %p", num_of_params, p_param_list);


    UInt32 counter = OAM_ZERO;
    UInt16 transaction_id = OAM_ZERO;
    counter += OAM_TR069_INTF_HEADER_SIZE;

    transaction_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_ZERO);

    OAM_LOG(OAM,OAM_INFO,"Trans_id: %d",transaction_id);

    if(OAM_TRUE == oam_prov_req.system_status.cell_setup_complete)
    {
        OAM_LOG(OAM,OAM_WARNING,"Cell setup is complete, Returning failure");
        UInt16 trans_id = get_word_from_header((UInt8*)(p_api_buf) + OAM_ZERO);
        UInt16 dest_id  = get_word_from_header((UInt8*)(p_api_buf) + OAM_INTF_HDR_SRC_ID_OFFSET);  
        if(OAM_FAILURE == oam_send_control_cmd_resp(
                    trans_id,dest_id,status,OAM_ZERO,(UInt8*)err_string))
        {
            OAM_LOG(OAM,OAM_DETAILED,"Error in sending Response");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/******************************************************************************
 * Function Name  : oam_send_control_cmd_resp 
 * Description    : This function constructs the response to the control 
 *                  command request 
 * Inputs         : status : Indicates success and failure
 *                  error_code : Indicates type of Error 
 *                  err_string : Description of Error 
 * Output         : None 
 * Returns        : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
oam_return_et
    oam_send_control_cmd_resp
(
 UInt16 trans_id,
 UInt16 dest_id,
 UInt8 status,
 UInt16 error_code,
 UInt8 *err_string
 )
{
    UInt8 *p_api_msg = OAM_NULL;
    UInt8 *p_msg = OAM_NULL;
    UInt16 msg_length = OAM_ZERO,err_string_len = OAM_ZERO;
    /* coverity 41332 */
    oam_error_code_et err_code = NO_ERROR;
    UInt8  error_str[STR_LEN_80] = {OAM_ZERO};

    OAM_FUN_ENTRY_TRACE();


    err_string_len = oam_strlen((char *)err_string);

    msg_length +=OAM_TR069_INTF_HEADER_SIZE + OAM_CSPL_HDR_SIZE;
    msg_length += sizeof(UInt8);
    msg_length += sizeof(UInt16);
    msg_length += sizeof(UInt16);
    msg_length += sizeof(UInt16);
    msg_length += sizeof(UInt8);
    msg_length += err_string_len;

    if(OAM_ZERO != err_string_len)
        msg_length += OAM_ONE; 

    if(OAM_FAILURE == oam_mem_alloc(msg_length,(void*)&p_msg, &err_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_msg failed"
                " with Error Code:%d",
                err_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    p_api_msg = p_msg;

    /* encode the CSPL header in the message */
    oam_construct_api_header(p_api_msg,OAM_VERSION,OAM_MODULE_ID,
            dest_id,
            OAM_CONTROL_COMMAND_RESP,msg_length);

    p_api_msg += OAM_CSPL_HDR_SIZE;

    /* encode API header in message*/
    oam_construct_mgmt_api_hdr((UInt8 *)p_api_msg,
            trans_id,
            OAM_MODULE_ID,
            dest_id,
            OAM_CONTROL_COMMAND_RESP,
            (msg_length - OAM_CSPL_HDR_SIZE),
            /*SPR 17777 fix*/
            OAM_ZERO);

    p_api_msg = p_api_msg + OAM_TR069_INTF_HEADER_SIZE;

    /* Pack NULL Character also in error string */
    if(OAM_ZERO != err_string_len)
    {

        /* Coverity Fixes */
        oam_strncpy((char *)error_str,(char *)err_string , oam_strlen((char *)err_string));
        error_str[err_string_len]=OAM_ZERO;
        err_string_len += OAM_ONE;
    }

    encode_get_params_resp_ctrl_blk((char *)p_api_msg,
            status,error_code,OAM_ZERO,OAM_ZERO,err_string_len,(char *)error_str);

    if(OAM_FAILURE == oam_send_message(p_msg,dest_id,&err_code))
    {
        OAM_LOG(OAM,OAM_ERROR,"Error in sending message : %d",err_code);
        OAM_FUN_EXIT_TRACE(); 
        return OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE(); 
    return OAM_SUCCESS;
}

/******************************************************************************
 * Function Name  : oam_get_tr069_msg_length 
 * Description    : This function calculates length of message for Initial 
 *                  configuration Request
 * Inputs         : p_oam_tr069_init_req : Pointer to structure type 
 *                   
 * Output         : msg_length 
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 ******************************************************************************/
    oam_length_t
oam_get_tr069_msg_length(
        oam_init_tr069_params_t *p_oam_tr069_init_req,
        oam_device_info_t 	*p_oam_device_info
        )
{
    OAM_FUN_ENTRY_TRACE();
    UInt16 msg_length = OAM_ZERO;
    char buff[OAM_TEN] = {OAM_ZERO};
    msg_length += sizeof(UInt8) +OAM_THREE*sizeof(UInt8);

    /* SPR 17880 START */
    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"Username=") + OAM_ONE;
    msg_length += strlen((char *)oam_prov_req.oam_tr069_req.tr069_init_params.Username);;
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"Password=") + OAM_ONE;
    msg_length += strlen((char *)oam_prov_req.oam_tr069_req.tr069_init_params.Password);;
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    snprintf(buff , sizeof(buff), "%d" , oam_prov_req.oam_tr069_req.tr069_init_params.EnableCWMP);
    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"EnableCWMP=") + OAM_ONE;
    msg_length += strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"PeriodicInformEnable=") + OAM_ONE;
    msg_length += OAM_ONE;
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    snprintf(buff , sizeof(buff), "%d" , oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformInterval);
    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"PeriodicInformInterval=") + OAM_ONE;
    msg_length += strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"PeriodicInformTime=") + OAM_ONE;
    msg_length += strlen((char *)oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"ConnectionRequestUsername=") + OAM_ONE;
    msg_length += strlen((char *)oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"ConnectionRequestPassword=") + OAM_ONE;
    msg_length += strlen((char *)oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    snprintf(buff , sizeof(buff), "%d" , oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryMinimumWaitInterval);
    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"CWMPRetryMinimumWaitInterval=") + OAM_ONE;
    msg_length += strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    snprintf(buff , sizeof(buff), "%d" , oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryIntervalMultiplier);
    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"CWMPRetryIntervalMultiplier=") + OAM_ONE;
    msg_length += strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += strlen((char *)OAM_PARENT_NODE_MGNT_SRVR);
    msg_length += strlen((char *)"ConnectionRequestURL=") + OAM_ONE;
    msg_length += strlen((char *)oam_prov_req.oam_tr069_req.tr069_init_params.ConReqURL);
    msg_length += sizeof(UInt16) + sizeof(UInt16);
    /* SPR 17880 END */

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_GATEWAY); 
    msg_length += oam_strlen((char *)"SecGWServer1=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_tr069_init_req->serving_sec_gw_server1);
    msg_length += sizeof(UInt16) + sizeof(UInt16);


    msg_length += oam_strlen((char *)OAM_PARENT_NODE_GATEWAY); 
    msg_length += oam_strlen((char *)"SecGWServer2=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_tr069_init_req->serving_sec_gw_server2);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_GATEWAY); 
    msg_length += oam_strlen((char *)"SecGWServer3=") + OAM_ONE/* For Null Char */; 
    msg_length+= oam_strlen((char *)p_oam_tr069_init_req->serving_sec_gw_server3);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_MGNT_SRVR); 
    msg_length += oam_strlen("URL=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_tr069_init_req->serving_hems_address);
    msg_length += sizeof(UInt16) + sizeof(UInt16);


    msg_length += oam_strlen((char *)OAM_PARENT_NODE_MGNT_SRVR); 
    msg_length += oam_strlen("X_VENDOR_IHEMS_URL=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_tr069_init_req->initial_hems_address);
    msg_length += sizeof(UInt16) + sizeof(UInt16);


    msg_length += oam_strlen((char *)OAM_PARENT_NODE_GATEWAY); 
    msg_length += oam_strlen((char *)"X_VENDOR_HENBIPADDRESS=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_tr069_init_req->henb_self_address);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_DEVICE_INFO); 
    msg_length += oam_strlen((char *)"Manufacturer=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_device_info->Manufacturer);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_DEVICE_INFO); 
    msg_length += oam_strlen((char *)"ManufacturerOUI=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_device_info->ManufacturerOUI);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_DEVICE_INFO); 
    msg_length += oam_strlen((char *)"ProductClass=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_device_info->ProductClass);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_DEVICE_INFO); 
    msg_length += oam_strlen((char *)"SerialNumber=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_device_info->SerialNumber);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_DEVICE_INFO); 
    msg_length += oam_strlen((char *)"HardwareVersion=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_device_info->HardwareVersion);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    msg_length += oam_strlen((char *)OAM_PARENT_NODE_DEVICE_INFO); 
    msg_length += oam_strlen((char *)"SoftwareVersion=") + OAM_ONE/* For Null Char */; 
    msg_length += oam_strlen((char *)p_oam_device_info->SoftwareVersion);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    /* Cell config crypto changes  */

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    oam_snprintf(buff , sizeof(buff), "%d" ,
            oam_prov_req.oam_igd_params.tunnel_params.
            oam_crypto_profile[OAM_ZERO].Enable);
    msg_length += oam_strlen((char *)OAM_PARENT_NODE_CRYPTO);
    msg_length += oam_strlen((char *)"Enable=") + OAM_ONE/* For Null Char */;
    msg_length += oam_strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    oam_snprintf(buff , sizeof(buff), "%s" ,
            oam_prov_req.oam_igd_params.tunnel_params.
            oam_crypto_profile[OAM_ZERO].AuthMethod);
    msg_length += oam_strlen((char *)OAM_PARENT_NODE_CRYPTO);
    msg_length += oam_strlen((char *)"AuthMethod=") + OAM_ONE/* For Null Char */;
    msg_length += oam_strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    oam_snprintf(buff ,sizeof(buff), "%d" ,
            oam_prov_req.oam_igd_params.tunnel_params.
            oam_crypto_profile[OAM_ZERO].IKERekeyLifetime);
    msg_length += oam_strlen((char *)OAM_PARENT_NODE_CRYPTO);
    msg_length += oam_strlen((char *)"IKERekeyLifetime=") + OAM_ONE/* For Null Char */;
    msg_length += oam_strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    oam_snprintf(buff ,sizeof(buff), "%d" ,
            oam_prov_req.oam_igd_params.tunnel_params.
            oam_crypto_profile[OAM_ZERO].IPsecRekeyLifetimeTime);
    msg_length += oam_strlen((char *)OAM_PARENT_NODE_CRYPTO);
    msg_length += oam_strlen((char *)"IPsecRekeyLifetimeTime=") + OAM_ONE/* For Null Char */;
    msg_length += oam_strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    oam_snprintf(buff , sizeof(buff), "%d" , oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].DPDTimer);
    msg_length += oam_strlen((char *)OAM_PARENT_NODE_CRYPTO);
    msg_length += oam_strlen((char *)"DPDTimer=") + OAM_ONE/* For Null Char */;
    msg_length += oam_strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    oam_snprintf(buff ,sizeof(buff), "%d" , oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].NATTKeepaliveTimer);
    msg_length += oam_strlen((char *)OAM_PARENT_NODE_CRYPTO);
    msg_length += oam_strlen((char *)"NATTKeepaliveTimer=") + OAM_ONE/* For Null Char */;
    msg_length += oam_strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    oam_memset(buff, OAM_ZERO, sizeof(buff));
    oam_snprintf(buff ,sizeof(buff), "%s" , oam_prov_req.oam_igd_params.nw_scan_status.last_scan_time);
    msg_length += oam_strlen((char *)OAM_PARENT_NODE_REM);
    msg_length += oam_strlen((char *)"LastScanTime=") + OAM_ONE/* For Null Char */;
    msg_length += oam_strlen((char *)buff);
    msg_length += sizeof(UInt16) + sizeof(UInt16);

    OAM_FUN_EXIT_TRACE();
    return  msg_length;
}



/******************************************************************************
 * Function Name : oam_tr_069_compose_message 
 * Description   : This function constructs the message for 
 *                 Initial Configuration Request
 * Inputs        : p_buffer : Pointer to message buffer
 *                 p_oam_tr069_init_req : Pointer to structure type 
 *                 oam_init_tr069_req_t  
 * Output        : None
 * Returns       : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
void
    oam_tr_069_compose_message
(
 UInt8 *p_buffer, 
 oam_init_tr069_params_t *p_oam_tr069_init_req,
 oam_device_info_t 		*p_oam_device_info		
 )
{
    OAM_FUN_ENTRY_TRACE();
    UInt16 resvd1 = OAM_ZERO;
    UInt8  resvd7 = OAM_ZERO;
    UInt32 resvd2 = OAM_ZERO;
    UInt32 resvd3 = OAM_ZERO;
    UInt32 resvd4 = OAM_ZERO;
    UInt32 resvd5 = OAM_ZERO;
    UInt32 resvd6 = OAM_ZERO;
    /* SPR 16568 FIX START */
    UInt8 no_of_params = 31;
    /* SPR 16568 FIX END */
    Char8 string[STR_LEN_128]={OAM_ZERO}, buff[OAM_TEN]={OAM_ZERO};
    UInt16 param_len = OAM_ZERO;
    UInt16 pack_param_len = OAM_ZERO;
    UInt32 curr_pos = OAM_ZERO;
    /* SPR 17880 START */
    UInt8 param_val[128] = {0};
    param_val[0] = '\0';
    /* SPR 17880 END */

    OAM_FUN_ENTRY_TRACE();

    /*packing number of parameters*/
    *(p_buffer + curr_pos++) = no_of_params;
    /*packing reserved field*/    
    *(p_buffer + curr_pos++) = (resvd1 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd1 & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd7;

    /*packing length of parameters*/

    /* SPR 17880 START */
    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"Username=");
    strncat(string,(char *)oam_prov_req.oam_tr069_req.tr069_init_params.Username, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;

    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"Password=");
    strncat(string,(char *)oam_prov_req.oam_tr069_req.tr069_init_params.Password, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"EnableCWMP=");
    sprintf((char *)param_val, "%d", oam_prov_req.oam_tr069_req.tr069_init_params.EnableCWMP);
    strncat(string,(char *)param_val, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"PeriodicInformEnable=");
    sprintf((char *)param_val, "%d", oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformEnable);
    strncat(string,(char *)param_val, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"PeriodicInformInterval=");
    sprintf((char *)param_val, "%d", oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformInterval);
    strncat(string,(char *)param_val, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"PeriodicInformTime=");
    strncat(string,(char *)oam_prov_req.oam_tr069_req.tr069_init_params.PeriodicInformTime, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"ConnectionRequestUsername=");
    strncat(string,(char *)oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestUsername, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"ConnectionRequestPassword=");
    strncat(string,(char *)oam_prov_req.oam_tr069_req.tr069_init_params.ConnectionRequestPassword, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"CWMPRetryMinimumWaitInterval=");
    sprintf((char *)param_val, "%d", oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryMinimumWaitInterval);
    strncat(string,(char *)param_val, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"CWMPRetryIntervalMultiplier=");
    sprintf((char *)param_val, "%d", oam_prov_req.oam_tr069_req.tr069_init_params.CWMPRetryIntervalMultiplier);
    strncat(string,(char *)param_val, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;

    /*packing length of parameters*/
    param_len = OAM_ZERO;


    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,(char *)"ConnectionRequestURL=");
    strncat(string,(char *)oam_prov_req.oam_tr069_req.tr069_init_params.ConReqURL, sizeof(string) - OAM_ONE);
    param_len = strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;// For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;

    /*packing length of parameters*/
    param_len = OAM_ZERO;
    /* SPR 17880 END */

    /*Coverity Fix */

    oam_strcpy((char *)string, OAM_PARENT_NODE_GATEWAY);
    oam_strcat((char *)string,(char *)"SecGWServer1=");
    oam_strncat(string,(char *)p_oam_tr069_init_req->serving_sec_gw_server1, sizeof(string) - OAM_ONE);
    param_len = oam_strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd2 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd2 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;

    /*packing length of parameters*/
    param_len = OAM_ZERO;

    /* Coverity Fixes */

    oam_strcpy((char *)string, OAM_PARENT_NODE_GATEWAY);
    oam_strcat((char *)string,(char *)"SecGWServer2=");
    oam_strncat(string,(char *)p_oam_tr069_init_req->serving_sec_gw_server2, sizeof(string) - OAM_ONE);
    param_len = oam_strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd3 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd3 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;

    /*packing length of parameters*/
    param_len = OAM_ZERO;

    oam_strcpy((char *)string, OAM_PARENT_NODE_GATEWAY);
    oam_strcat((char *)string,(char *)"SecGWServer3=");
    oam_strncat(string,(char *)p_oam_tr069_init_req->serving_sec_gw_server3, sizeof(string) - OAM_ONE);
    param_len = oam_strlen((char*)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*Packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd4 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd4 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string,param_len);
    curr_pos +=param_len;

    /*packing length*/
    param_len = OAM_ZERO;

    oam_memset(string, OAM_ZERO, sizeof(string));
    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,"URL=");
    oam_strncat((char *)string,(char *)p_oam_tr069_init_req->serving_hems_address, sizeof(string)- oam_strlen((char*)string));

    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd5 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd5 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;


    /*packing length*/
    param_len = OAM_ZERO;

    oam_memset(string, OAM_ZERO, sizeof(string));
    oam_strcpy((char *)string, OAM_PARENT_NODE_MGNT_SRVR);
    oam_strcat((char *)string,"X_VENDOR_IHEMS_URL=");
    oam_strncat((char *)string,(char *)p_oam_tr069_init_req->initial_hems_address, sizeof(string)- oam_strlen((char*)string));

    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;/* For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd5 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd5 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;



    /*packing length*/
    param_len = OAM_ZERO;

    oam_strcpy((char *)string, OAM_PARENT_NODE_GATEWAY);
    oam_strcat((char *)string,"X_VENDOR_HENBIPADDRESS=");
    oam_strncat((char *)string,(char *)p_oam_tr069_init_req->henb_self_address , sizeof(string) -OAM_ONE );

    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;/* For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;


    /*packing length*/
    param_len = OAM_ZERO;
    oam_strcpy((char *)string, OAM_PARENT_NODE_DEVICE_INFO);
    oam_strcat((char *)string,"Manufacturer=");
    oam_strcat((char *)string,(char *)p_oam_device_info->Manufacturer);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;

    /*packing length*/
    param_len = OAM_ZERO;
    oam_strcpy((char *)string, OAM_PARENT_NODE_DEVICE_INFO);
    oam_strcat((char *)string,"ManufacturerOUI=");
    oam_strcat((char *)string,(char *)p_oam_device_info->ManufacturerOUI);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;

    /*packing length*/
    param_len = OAM_ZERO;
    oam_strcpy((char *)string, OAM_PARENT_NODE_DEVICE_INFO);
    oam_strcat((char *)string,"ProductClass=");
    oam_strcat((char *)string,(char *)p_oam_device_info->ProductClass);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;

    /*packing length*/
    param_len = OAM_ZERO;
    oam_strcpy((char *)string, OAM_PARENT_NODE_DEVICE_INFO);
    oam_strcat((char *)string,"SerialNumber=");
    oam_strcat((char *)string,(char *)p_oam_device_info->SerialNumber);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;

    /*packing length*/
    param_len = OAM_ZERO;
    oam_strcpy((char *)string, OAM_PARENT_NODE_DEVICE_INFO);
    oam_strcat((char *)string,"HardwareVersion=");
    oam_strcat((char *)string,(char *)p_oam_device_info->HardwareVersion);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;

    /*packing length*/
    param_len = OAM_ZERO;
    oam_strcpy((char *)string, OAM_PARENT_NODE_DEVICE_INFO);
    oam_strcat((char *)string,"SoftwareVersion=");
    oam_strcat((char *)string,(char *)p_oam_device_info->SoftwareVersion);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);      
    curr_pos +=param_len;

    /* Code changes start */

    /*packing length*/
    param_len = OAM_ZERO;
    oam_memset(buff, OAM_ZERO, OAM_TEN);
    oam_snprintf(buff ,sizeof(buff), "%d",
            oam_prov_req.oam_igd_params.tunnel_params.
            oam_crypto_profile[OAM_ZERO].Enable);
    oam_strcpy((char *)string, OAM_PARENT_NODE_CRYPTO);
    oam_strcat((char *)string,"Enable=");
    oam_strcat((char *)string,(char *)buff);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);
    curr_pos +=param_len;
    oam_memset(buff, OAM_ZERO, OAM_TEN);

    /*packing length*/
    param_len = OAM_ZERO;
    oam_strcpy((char *)string, OAM_PARENT_NODE_CRYPTO);
    oam_strcat((char *)string,"AuthMethod=");
    oam_strcat((char *)string,
            (Char8*)oam_prov_req.oam_igd_params.tunnel_params.
            oam_crypto_profile[OAM_ZERO].AuthMethod);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);
    curr_pos +=param_len;

    /*packing length*/
    param_len = OAM_ZERO;

    oam_snprintf(buff , sizeof(buff),"%d" ,
            oam_prov_req.oam_igd_params.tunnel_params.
            oam_crypto_profile[OAM_ZERO].IKERekeyLifetime);
    oam_strcpy((char *)string, OAM_PARENT_NODE_CRYPTO);
    oam_strcat((char *)string,"IKERekeyLifetime=");
    oam_strcat((char *)string,(char *)buff);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);
    curr_pos +=param_len;
    oam_memset(buff, OAM_ZERO, OAM_TEN);

    /*packing length*/
    param_len = OAM_ZERO;
    oam_snprintf(buff ,sizeof(buff), "%d",
            oam_prov_req.oam_igd_params.tunnel_params.
            oam_crypto_profile[OAM_ZERO].IPsecRekeyLifetimeTime);
    oam_strcpy((char *)string, OAM_PARENT_NODE_CRYPTO);
    oam_strcat((char *)string,"IPsecRekeyLifetimeTime=");
    oam_strcat((char *)string,(char *)buff);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);
    curr_pos +=param_len;
    oam_memset(buff, OAM_ZERO, OAM_TEN);

    /*packing length*/
    param_len = OAM_ZERO;
    oam_snprintf(buff ,sizeof(buff), "%d" , oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[0].DPDTimer);
    oam_strcpy((char *)string, OAM_PARENT_NODE_CRYPTO);
    oam_strcat((char *)string,"DPDTimer=");
    oam_strcat((char *)string,(char *)buff);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);
    curr_pos +=param_len;
    oam_memset(buff, OAM_ZERO, OAM_TEN);

    /*packing length*/
    param_len = OAM_ZERO;
    oam_snprintf(buff ,sizeof(buff), "%d" , oam_prov_req.oam_igd_params.tunnel_params.oam_crypto_profile[OAM_ZERO].NATTKeepaliveTimer);
    oam_strcpy((char *)string, OAM_PARENT_NODE_CRYPTO);
    oam_strcat((char *)string,"NATTKeepaliveTimer=");
    oam_strcat((char *)string,(char *)buff);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;/* For resvd and length feild */
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);
    curr_pos +=param_len;
    oam_memset(buff, OAM_ZERO, OAM_TEN);


    /*packing length*/
    param_len = OAM_ZERO;
    oam_snprintf(buff , sizeof(buff),"%s" , oam_prov_req.oam_igd_params.nw_scan_status.last_scan_time);
    oam_strcpy((char *)string, OAM_PARENT_NODE_REM);
    oam_strcat((char *)string,"LastScanTime=");
    oam_strcat((char *)string,(char *)buff);
    param_len = oam_strlen((char *)string);
    string[param_len] = OAM_ZERO;
    param_len += OAM_ONE; /* For NULL character */
    pack_param_len = param_len +OAM_FOUR;
    *(p_buffer + curr_pos++) = (pack_param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = pack_param_len & OAM_ALL_8_BIT_SET;

    /*packing reserved field*/
    *(p_buffer + curr_pos++) = (resvd6 >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++) = resvd6 & OAM_ALL_8_BIT_SET;

    /*packing string*/
    if(param_len!= OAM_ZERO)
        oam_memcpy(p_buffer + curr_pos,string,param_len);
    curr_pos +=param_len;
    oam_memset(buff, OAM_ZERO, OAM_TEN);

    OAM_FUN_EXIT_TRACE();

    return;
}

/******************************************************************************
 * Function Name : oam_handle_tr_069_init_config_req 
 * Description   : This function handles the initial configuration request 
 *                 from TR069
 * Inputs        : p_oam_tr069_init_req : Pointer to message Buffer
 *                 src_module_id : Source module Identifier
 *                 transaction_id : Transaction Identifier
 *                 p_error_code  : Pointer to Error Code
 * Output        : None
 * Returns       : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
oam_return_et
    oam_send_tr_069_init_config_req
(
 oam_init_tr069_params_t *p_oam_tr069_init_req,
 UInt16                  src_module_id,
 UInt16                  transaction_id,
 oam_error_code_et       *p_error_code,
 oam_device_info_t       *p_oam_device_info						
 )
{
    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %u", src_module_id);
    UInt8 *p_msg= OAM_NULL, *p_api_msg= OAM_NULL;
    UInt16 msg_length = OAM_ZERO;


    /* If connection is with iHEMS, send 0.0.0.0 in management server URL */
    if(OAM_TRUE == oam_prov_req.oam_tr069_req.connect_to_iHeMS)
    {
        oam_strcpy((char*)p_oam_tr069_init_req->serving_hems_address,"0.0.0.0");
    }

    msg_length = oam_get_tr069_msg_length(p_oam_tr069_init_req, p_oam_device_info);
    msg_length += OAM_CSPL_HDR_SIZE + OAM_TR069_INTF_HEADER_SIZE;

    if(OAM_FAILURE == oam_mem_alloc(msg_length,(void*)&p_msg,p_error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_msg failed"
                " with Error Code:%d",
                *p_error_code);
        return OAM_FAILURE;
    }
    oam_memset(p_msg, OAM_ZERO, msg_length);
    p_api_msg = p_msg;
    /* encode the CSPL header in the message */
    oam_construct_api_header(p_api_msg,OAM_VERSION,OAM_MODULE_ID,
            TR069_MODULE_ID,
            TR069_OAM_CONFIG_REQ,msg_length);

    p_api_msg += OAM_CSPL_HDR_SIZE;

    /* encode API header in message*/
    oam_construct_mgmt_api_hdr((UInt8 *)p_api_msg,
            transaction_id,
            OAM_MODULE_ID,
            TR069_MODULE_ID,
            TR069_OAM_CONFIG_REQ,
            msg_length - OAM_CSPL_HDR_SIZE,
            /*SPR 17777 fix*/
            OAM_ZERO);

    p_api_msg = p_api_msg + OAM_TR069_INTF_HEADER_SIZE ;
    oam_tr_069_compose_message(p_api_msg,p_oam_tr069_init_req, p_oam_device_info);


    if(OAM_FAILURE == oam_send_message(p_msg,TR069_MODULE_ID,p_error_code))
    {
        OAM_LOG(OAM,OAM_DETAILED,"Failed to send message : %d",*p_error_code);         
        OAM_FUN_EXIT_TRACE(); 
        return OAM_FAILURE;
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;


}


/******************************************************************************
 * Function Name : oam_proceed_with_init_flow 
 * Description   : This function resumes execution in the normal mode 
 *                 without TR069  
 * Inputs        : None
 * Output        : None
 * Return        : None 
 ******************************************************************************/
    oam_return_et
oam_proceed_with_init_flow(SInt32 g_no_of_arguments,
        Char8 **g_list_of_init_arguments)
{

    OAM_FUN_ENTRY_TRACE();
    oam_return_et retVal = OAM_SUCCESS;
    oam_sim_error_info_et start_error = SIM_NO_ERROR;

    /*SPR 21889 Start*/
    /* Code removed */
    /*SPR 21889 End */

    /*SPR 21889 Start*/
    retVal = oam_startup_init(&start_error);
    /*SPR 21889 End */

    if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_CRITICAL, "Startup failed cause %u", start_error);
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}




/******************************************************************************
 * Function Name : oam_handle_cell_block_response 
 * Description   : This function handles cell block response
 * Inputs        : p_api_buf,p_error_code 
 * Output        : None
 * Return        : None 
 ******************************************************************************/
oam_return_et
    oam_handle_cell_block_response
(
 oam_rrm_cell_block_resp_t *p_resp,
 oam_error_code_et   *p_error_code
 )
{
    oam_return_et    ret_val = OAM_FAILURE;

    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %p", p_error_code);

    /* Check Event */
    if(oam_prov_req.system_status.event_ongoing & OAM_RRM_CELL_BLOCK_REQ_MASK)
    {
        if(p_resp->response == RRM_SUCCESS) {
            OAM_LOG(OAM, OAM_INFO, "Success response received from RRM");
            /*Fill Structure*/

            ret_val = oam_inform_value_change_event(OAM_ZERO,
                    OAM_ZERO,
                    TR069_MODULE_ID);
            if(OAM_FAILURE == ret_val) {
                OAM_LOG(OAM, OAM_WARNING, "Failed to send the "
                        "value-change inform indication to TR069 agent");
                ret_val = OAM_SUCCESS;
            }

            /*Take backup of Admin State Parameter*/
            oam_prov_req.system_status.admin_state = 
                local_prov_req.system_status.admin_state;
        }
        else {
            OAM_LOG(OAM, OAM_INFO, "Failure response received from RRM");
            ret_val = OAM_FAILURE;
        }
    }/* End of if(oam_prov_req ...... */

    OAM_FUN_EXIT_TRACE();
    return ret_val;
}

/******************************************************************************
 * Function Name : oam_handle_admin_state_unlocked
 * Description   : This function handle admin state. 
 * Inputs        : p_api_buf
 * Output        : None
 * Return        : None 
 ******************************************************************************/
oam_return_et 
    oam_handle_admin_state_unlocked
(
 UInt8   *p_api_buf
 )
{
    oam_return_et          ret_val = OAM_SUCCESS;
    /* coverity 35892 */
    oam_error_code_et      err = NO_ERROR;
    /* Spr 10926 Fix Start */  
    UInt16   trans_id = OAM_ZERO;
    UInt16   dest_id = OAM_ZERO;
    oam_bool_et   set_response = OAM_TRUE;
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    oam_cell_status_t *p_cell_status = OAM_NULL;
    UInt8 loop_counter = OAM_ZERO;
    UInt8 cid = OAM_ZERO;
    cell_config_idx = oam_get_rrm_cell_config_idx(
            oam_prov_req.cell_cntxt.curr_cell_cid);
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return OAM_FAILURE;
    }

    UInt8 msg_len = get_word_from_header((UInt8*)(p_api_buf) + OAM_EIGHT);
    oam_rrm_cell_config_req_t *p_rrm_cell_config = OAM_NULL; 

    OAM_FUN_ENTRY_TRACE();

    OAM_LOG(OAM, OAM_INFO, "Admin State is Unlocked");

    trans_id = get_word_from_header((UInt8 *)p_api_buf);
    dest_id = get_word_from_header((UInt8 *)p_api_buf + OAM_TWO);

    ret_val = oam_maintain_tcb(tcb_transaction_id,
            OAM_TRANS_RRM,
            msg_len, p_api_buf);

    for(loop_counter = OAM_ZERO;
            loop_counter < oam_prov_req.num_cells_configured;
            ++loop_counter) {
        p_rrm_cell_config =
            &RRM_CELL_CONFIG(loop_counter);
        cid =
            oam_extract_cid_from_eutran_cellidentity(
                    p_rrm_cell_config->global_cell_info.
                    eutran_global_cell_id.cell_identity);
        p_cell_status = oam_get_cell_cntxt_status(cid);
        /*COVERITY FIX 62498*/
        if (p_cell_status == OAM_NULL)
        {
            OAM_LOG(OAM, OAM_WARNING,
                    "No cell found for cell identity %d",cid);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;

        }
        if(!(p_cell_status->cell_state & OAM_CELL_ACTIVE)){
            /*SPR 19771 FIXED START*/
            if((p_cell_status->cell_event & OAM_USER_TRIGGERED_STOP))
                /*SPR 19771 FIXED END*/
            {
                OAM_LOG(OAM, OAM_INFO,
                        "Sending cell start for CID: %d",
                        cid);

                if(OAM_FAILURE == oam_rrm_send_rrm_oam_cell_start_req((rrm_oam_cell_start_req_t *)
                            (&(OWN_CELL_CGI(loop_counter))),
                            OAM_MODULE_ID, RRM_MODULE_ID, tcb_transaction_id, oam_prov_req.cell_cntxt.curr_cell_cid))
                {

                    OAM_LOG(OAM,OAM_ERROR,"Error in function oam_rrm_send_rrm_oam_cell_start_req");
                    /* CID 63820 FIX START */
                    set_response = OAM_FALSE;
                    ret_val = OAM_FAILURE;
                    /* CID 63820 FIX END */
                }
                user_trigger_admin_state_lock_unlock_flag = OAM_TRUE;
            }
            else
            {
                OAM_LOG(OAM,OAM_DETAILED,"Cell CID :%d stopped by operator so not started",cid);
            }
            /*BUG 1248 FIX END*/
        }
    }

    /* CID 63820 FIX START */
    if(OAM_FALSE == set_response) {
        /* Send set parameters response from here only */
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                OAM_ERR_INTERNAL_ERROR,
                (UInt8*)"Internal Error",
                oam_strlen("Internal_Error")+OAM_ONE,
                OAM_VERSION_ID, OAM_MODULE_ID,
                dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                &err);
    }
    /* CID 63820 FIX END */

    OAM_FUN_EXIT_TRACE();
    return ret_val;
    /* Spr 10926 Fix End */  
}

#ifdef OAM_SON_ENABLE
/******************************************************************************
 * Function Name : oam_maintain_nmm_parameter_persistence 
 * Description   : This function for maintaining parameter persistence. 
 * Inputs        : args
 * Output        : None
 * Return        : None 
 ******************************************************************************/
/* + SPR 17439 */
void oam_maintain_nmm_parameter_persistence(void)
{
    /* - SPR 17439 */
    UInt8 cp_cmd[OAM_CMD_SIZE]={OAM_ZERO};
    UInt8 backup_file_name[BKP_FILE_NAME_SIZE]={OAM_ZERO},timestamp[TIMESTAMP_SIZE]={OAM_ZERO};
    FILE   *file_ptr = OAM_NULL;

    OAM_FUN_ENTRY_TRACE();
    /* Coverity Fixes */


    oam_strncpy((char *)backup_file_name, OAM_NMM_SCAN_DATA_FILE, sizeof(backup_file_name));
    oam_strncat((char *)backup_file_name,"_bak_" , sizeof(backup_file_name ) - OAM_ONE);


    oam_fetch_current_timestamp((char *)timestamp);

    oam_strncat((char *)backup_file_name,(char *)timestamp  ,sizeof(backup_file_name ) -OAM_ONE );
    oam_strncat((char *)backup_file_name,(char *)timestamp ,  sizeof(backup_file_name ) -OAM_ONE );
    /* Copy eNodeB Data Model file as backup */

    oam_strncpy((char*)cp_cmd,"mv ../cfg/", sizeof(cp_cmd));
    oam_strncat((char*)cp_cmd,OAM_NMM_SCAN_DATA_FILE , sizeof(cp_cmd) -OAM_ONE );
    oam_strncat((char*)cp_cmd," ../cfg/",  sizeof(cp_cmd) - OAM_ONE);
    oam_strncat((char*)cp_cmd,(char *)backup_file_name ,  sizeof(cp_cmd) - OAM_ONE);
    oam_system((char *)cp_cmd);

    /* Dump data to TR-196 based file */
    /* coverity 35433 */	
    file_ptr = fopen(OAM_NMM_SCAN_DATA_FILE, "w+");
    if(OAM_NULL == file_ptr)
    {
        OAM_LOG(OAM,OAM_WARNING,"Unable to Open file %s", OAM_NMM_SCAN_DATA_FILE);
        OAM_FUN_EXIT_TRACE();
        return;
    }

    if(OAM_NULL != oam_prov_req.system_status.p_nw_scan_result_file)
    {
        OAM_LOG(OAM,OAM_INFO,"Taking Dump of %s based XML File for parameter persistence", OAM_NMM_SCAN_DATA_FILE);
        xmlDocFormatDump(file_ptr,oam_prov_req.system_status.p_nw_scan_result_file, OAM_ONE);
    }
    else
    {
        OAM_LOG(OAM,OAM_WARNING,"%s XML Doc pointer is NULL, Parameters not persistent", OAM_NMM_SCAN_DATA_FILE);
    }
    OAM_FCLOSE(file_ptr);

    OAM_FUN_EXIT_TRACE();
    return;
}
#endif



/******************************************************************************
 * Function Name : oam_maintain_parameter_persistence 
 * Description   : This function for maintaining parameter persistence. 
 * Inputs        : NONE
 * Output        : None
 * Return        : None 
 ******************************************************************************/
/* + SPR 17439 */
void oam_maintain_parameter_persistence(void)
{
    /* - SPR 17439 */
    Char8  timestamp[TIMESTAMP_SIZE] = {OAM_ZERO};
    Char8  bkp_file_name_tr196[BKP_FILE_NAME_SIZE] = {OAM_ZERO};
    SInt32 buf_size = OAM_ZERO;
    Char8 *bkp_suffix = "_bak_";
    SInt32 bkp_suffix_len = oam_strlen(bkp_suffix);
    Char8 *file_extn = ".xml";
    Char8 src[OAM_CMD_SIZE] = {OAM_ZERO};
    Char8 dst[OAM_CMD_SIZE] = {OAM_ZERO};
    Char8 *cfg_dir_path = OAM_CFG_DIR_PATH_RELATIVE_TO_BIN_DIR;

    FILE   *file_ptr = OAM_NULL;
#define OAM_MAINTAIN_SPACE_INDENTATION  1

    OAM_FUN_ENTRY_TRACE();
    /* Coverity Fixes */


    /* Prepare back-up file name for TR196 parameters */
    buf_size = BKP_FILE_NAME_SIZE - 1;
    oam_strncpy(bkp_file_name_tr196, OAM_TR196_XML_FILENAME, buf_size);
    buf_size -= oam_strlen(OAM_TR196_XML_FILENAME);

    oam_strncat(bkp_file_name_tr196, bkp_suffix, buf_size);
    buf_size -= bkp_suffix_len;

    oam_fetch_current_timestamp(timestamp);

    oam_strncat(bkp_file_name_tr196, timestamp, buf_size);
    buf_size -= oam_strlen(timestamp);

    oam_strncat(bkp_file_name_tr196, file_extn, buf_size);

    /* Now the backup file name is like:
       eNodeB_Data_Model_TR_196_based_bak_<timestamp>.xml
       */

    buf_size = OAM_CMD_SIZE - 1;
    oam_strncpy(src, cfg_dir_path, buf_size);
    buf_size -= oam_strlen(cfg_dir_path);

    oam_strncat(src, OAM_TR196_XML_FILENAME_WITH_EXT, buf_size);

    buf_size = OAM_CMD_SIZE - 1;
    oam_strncpy(dst, cfg_dir_path, buf_size);
    buf_size -= oam_strlen(cfg_dir_path);

    oam_strncat(dst, bkp_file_name_tr196, buf_size);


    /* Execute the mv command to rename the existing cfg file to
     * backup file name
     */
    oam_mv(src, dst);


    /* Dump data to TR-196 based file */
    file_ptr = oam_fopen(src, "w");
    /* coverity 35434 */
    if(!file_ptr) {
        OAM_LOG(OAM, OAM_WARNING, "Unable to open output file %s",
                OAM_TR196_XML_FILENAME_WITH_EXT);
        OAM_FUN_EXIT_TRACE();
        return;
    }

    if(oam_prov_req.system_status.p_xml_doc)
    {
        OAM_LOG(OAM, OAM_INFO, "Saving running configuration for TR196 "
                "parameters into file %s", bkp_file_name_tr196);

        xmlDocFormatDump(file_ptr,
                oam_prov_req.system_status.p_xml_doc,
                OAM_MAINTAIN_SPACE_INDENTATION);
    }
    else {
        OAM_LOG(OAM, OAM_WARNING, "TR196 based XML Doc pointer is NULL");
    }

    oam_fclose(file_ptr);

#ifdef OAM_SON_ENABLE
    /*+SPR 18853 FIX*/
    if((oam_prov_req.system_status.is_nmm_enabled)
            && (OAM_TRUE == oam_prov_req.oam_son_req.temp_values.scan_on_boot))
        /*-SPR 18853 FIX*/
    {
        /*SPR_16048 Fix Start*/
        /* Code removed */
        /*SPR_16048 Fix End*/
    }
#endif

    OAM_FUN_EXIT_TRACE();
    return;
}

/******************************************************************************
 * Function Name : oam_qcli_save_current_config 
 * Description   : This function for saving qcli current configuration. 
 * Inputs        : p_buf,p_error_code,trans_id,dest_id 
 * Output        : p_error_code: error code in case of failures
 * Return        : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
oam_return_et
    oam_qcli_save_current_config
(
 UInt8             *p_buf,
 oam_error_code_et *p_error_code,
 UInt16            trans_id,
 UInt8             dest_id
 )
{
    Char8 param_val_pair[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
    UInt8 param_name_len = OAM_ZERO;
    oam_length_t param_info_blk_len = OAM_ZERO;
    Char8 *value = OAM_NULL;
    UInt8 *p_offset = p_buf;
    oam_return_et retVal = OAM_FAILURE;

    OAM_FUN_ENTRY_TRACE();

    if (!p_buf || !p_error_code) {
        OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");

        OAM_FUN_EXIT_TRACE();
        return retVal;
    }

    *p_error_code = NO_ERROR;

    param_info_blk_len = get_word_from_header(p_offset);
    param_name_len = param_info_blk_len - OAM_DWORD_SIZE_IN_BYTE;
    p_offset += OAM_DWORD_SIZE_IN_BYTE;

    oam_memcpy(param_val_pair, p_offset, param_name_len);

    value = oam_strtok(param_val_pair, "=");

    value = oam_strtok(OAM_NULL, "=");

    if (OAM_NULL == value) {
        OAM_LOG(OAM, OAM_WARNING,
                "XML file name for saving configuration of is missing");
        *p_error_code = OAM_SET_PARAMETER_INPUT_INCORRECT;
    }
    else {
        OAM_LOG(OAM, OAM_INFO,
                "Saving configuration of %s xml file(s)", value);

        retVal = oam_qcli_maintain_parameter_persistance(value,
                p_error_code);
        if(OAM_SUCCESS == retVal) {
            OAM_LOG(OAM,OAM_INFO,"Parameters Persistance Successful");
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                    OAM_ZERO,
                    OAM_NULL, OAM_ZERO,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dest_id, trans_id,
                    OAM_ZERO, OAM_ZERO,
                    p_error_code);
        }
    }

    /* coverity 36182 */
    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/****************************************************************************
 * Function Name : oam_qcli_maintain_parameter_persistance 
 * Description   : This function saves configuration for given cfg file(s)
 * Inputs        : cfg_filename(both means both of the cfg files viz.
 *                 eNodeB_Data_Model_TR_196_based.xml, and 
 *                 Proprietary_eNodeB_Data_Model.xml
 * Output        : p_err: error code in case of failures
 * Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
    oam_return_et
oam_qcli_maintain_parameter_persistance(Char8 *cfg_filename,
        oam_error_code_et *p_err)
{
    FILE   *file_ptr_tr196 = OAM_NULL;
    FILE   *file_ptr_prop = OAM_NULL;
    Char8  bkp_file_name_prop[BKP_FILE_NAME_SIZE] = {OAM_ZERO};
    Char8  timestamp[TIMESTAMP_SIZE] = {OAM_ZERO};
    Char8  bkp_file_name_tr196[BKP_FILE_NAME_SIZE] = {OAM_ZERO};
    SInt32 buf_size = OAM_ZERO;
    oam_return_et retVal = OAM_FAILURE;

    Char8 *cli_bkp_suffix = "_cli_bak_";
    SInt32 cli_bkp_suffix_len = oam_strlen(cli_bkp_suffix);
    Char8 *file_extn = ".xml";
    Char8 src_tr196[OAM_CMD_SIZE] = {OAM_ZERO};
    Char8 dst_tr196[OAM_CMD_SIZE] = {OAM_ZERO};
    Char8 src_prop[OAM_CMD_SIZE] = {OAM_ZERO};
    Char8 dst_prop[OAM_CMD_SIZE] = {OAM_ZERO};
    Char8 *cfg_dir_path = OAM_CFG_DIR_PATH_RELATIVE_TO_BIN_DIR;
#define OAM_MAINTAIN_SPACE_INDENTATION  1

    OAM_FUN_ENTRY_TRACE();

    if (!p_err) {
        OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");
        OAM_FUN_EXIT_TRACE();
        return retVal;
    }

    *p_err = NO_ERROR;

    /* Prepare backup file names once for output configuration */
    oam_fetch_current_timestamp(timestamp);

    /* Prepare back-up file name for TR196 parameters */
    buf_size = BKP_FILE_NAME_SIZE - 1;
    oam_strncpy(bkp_file_name_tr196, OAM_TR196_XML_FILENAME, buf_size);
    buf_size -= oam_strlen(OAM_TR196_XML_FILENAME);

    oam_strncat(bkp_file_name_tr196, cli_bkp_suffix, buf_size);
    buf_size -= cli_bkp_suffix_len;

    oam_strncat(bkp_file_name_tr196, timestamp, buf_size);
    buf_size -= oam_strlen(timestamp);

    oam_strncat(bkp_file_name_tr196, file_extn, buf_size);

    /* Prepare back-up file name for proprietary parameters */
    buf_size = BKP_FILE_NAME_SIZE - 1;
    oam_strncpy(bkp_file_name_prop, OAM_PROPRIETARY_XML_FILENAME, buf_size);
    buf_size -= oam_strlen(OAM_PROPRIETARY_XML_FILENAME);

    oam_strncat(bkp_file_name_prop, cli_bkp_suffix, buf_size);
    buf_size -= cli_bkp_suffix_len;

    oam_strncat(bkp_file_name_prop, timestamp, buf_size);
    buf_size -= oam_strlen(timestamp);

    oam_strncat(bkp_file_name_prop, file_extn, buf_size);


    /* Prepare src and dst for the TR-196, and Proprietary xml files */
    buf_size = OAM_CMD_SIZE - 1;
    oam_strncpy(src_tr196, cfg_dir_path, buf_size);
    buf_size -= oam_strlen(cfg_dir_path);
    oam_strncat(src_tr196, OAM_TR196_XML_FILENAME_WITH_EXT, buf_size);

    buf_size = OAM_CMD_SIZE - 1;
    oam_strncat(dst_tr196, cfg_dir_path, buf_size);
    buf_size -= oam_strlen(cfg_dir_path);
    oam_strncat(dst_tr196, bkp_file_name_tr196, buf_size);

    buf_size = OAM_CMD_SIZE - 1;
    oam_strncpy(src_prop, cfg_dir_path, buf_size);
    buf_size -= oam_strlen(cfg_dir_path);
    oam_strncat(src_prop, OAM_PROPRIETARY_XML_FILENAME_WITH_EXT, buf_size);

    buf_size = OAM_CMD_SIZE - 1;
    oam_strncat(dst_prop, cfg_dir_path, buf_size);
    buf_size -= oam_strlen(cfg_dir_path);
    oam_strncat(dst_prop, bkp_file_name_prop, buf_size);



    /* Dump data to TR-196 file */
    if(!oam_strcmp(cfg_filename, OAM_TR196_XML_FILENAME_WITH_EXT)) {
        oam_mv(src_tr196, dst_tr196);

        file_ptr_tr196 = oam_fopen(src_tr196, "w");
        if(!file_ptr_tr196) {
            OAM_LOG(OAM, OAM_WARNING, "Unable to open output file %s",
                    bkp_file_name_tr196);
            *p_err = OAM_FILE_OPERATION_ERR;
        }
        else {
            OAM_LOG(OAM, OAM_INFO, "Saving running configuration for TR196 "
                    "parameters into file %s", bkp_file_name_tr196);
            xmlDocFormatDump(file_ptr_tr196,
                    oam_prov_req.system_status.p_xml_doc,
                    OAM_MAINTAIN_SPACE_INDENTATION);

            retVal = OAM_SUCCESS;
        }
    }
    else if(!oam_strcmp(cfg_filename,
                OAM_PROPRIETARY_XML_FILENAME_WITH_EXT)) {
        oam_mv(src_prop, dst_prop);

        file_ptr_prop = oam_fopen(src_prop, "w");
        /* coverity 35435 */
        if(!file_ptr_prop) {
            OAM_LOG(OAM, OAM_WARNING, "Unable to open output file %s",
                    bkp_file_name_prop);
            *p_err = OAM_FILE_OPERATION_ERR;
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Saving running configuration for Propietry "
                    "parameters into file %s", bkp_file_name_prop);

            xmlDocFormatDump(file_ptr_prop,
                    oam_prov_req.system_status.p_propriety_xml_doc,
                    OAM_MAINTAIN_SPACE_INDENTATION);

            retVal = OAM_SUCCESS;
        }
    }
    /* Dump data to TR-196 & NON-TR file */
    else if(!oam_strcmp(cfg_filename, "BOTH")) {
        oam_mv(src_tr196, dst_tr196);
        oam_mv(src_prop, dst_prop);

        file_ptr_tr196 = oam_fopen(src_tr196, "w");
        file_ptr_prop = oam_fopen(src_prop, "w");

        if(!file_ptr_tr196 || !file_ptr_prop) {
            if (!file_ptr_tr196) {
                OAM_LOG(OAM, OAM_WARNING, "Unable to open output file %s",
                        bkp_file_name_tr196);
            }

            if (!file_ptr_prop) {
                OAM_LOG(OAM, OAM_WARNING, "Unable to open output file %s",
                        bkp_file_name_prop);
            }

            *p_err = OAM_FILE_OPERATION_ERR;
        }
        else {
            OAM_LOG(OAM, OAM_INFO,
                    "Saving running configuration for both Propietry "
                    "and TR196 parameters into files %s and %s "
                    "respectively", bkp_file_name_prop,
                    bkp_file_name_tr196);

            xmlDocFormatDump(file_ptr_prop,
                    oam_prov_req.system_status.p_propriety_xml_doc,
                    OAM_MAINTAIN_SPACE_INDENTATION);

            xmlDocFormatDump(file_ptr_tr196,
                    oam_prov_req.system_status.p_xml_doc,
                    OAM_MAINTAIN_SPACE_INDENTATION);

            retVal = OAM_SUCCESS;
        }
    }

    /* Closing open files */
    if (file_ptr_tr196) {
        oam_fclose(file_ptr_tr196);
    }

    if (file_ptr_prop) {
        oam_fclose(file_ptr_prop);
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}


/******************************************************************************
 * Function Name : oam_save_current_logs 
 * Description   : This function is for saving logs of L2/L3/RRM/SON/OAM. 
 * Inputs        : p_buf,p_error_code,trans_id,dest_id 
 * Output        : None
 * Return        : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
oam_return_et
    oam_save_current_logs
(
 UInt8             *p_buf,
 oam_error_code_et *p_error_code,
 UInt16            trans_id,
 UInt8             dest_id
 )
{
    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %p", p_buf);

    if (!oam_prov_req.oam_params.oam_log_archival_supported)
    {
        OAM_LOG(OAM,OAM_INFO,"Log Archival Not Supported In Proprietary Xml - Please enable flag:OAM_Support_Log_Archival");
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                OAM_ERR_INTERNAL_ERROR,
                (UInt8 *)"Log Archival Not Supported In Proprietary Xml: Please enable flag OAM_Support_Log_Archival",
                oam_strlen("Log Archival Not Supported In Proprietary Xml: Please enable flag:OAM_Support_Log_Archival")+OAM_ONE,
                OAM_VERSION_ID, OAM_MODULE_ID,
                dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                p_error_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    if(OAM_FAILURE == oam_collect_logs())
    {
        OAM_LOG(OAM,OAM_INFO,"Log Archival Command Failed");
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                OAM_ERR_INTERNAL_ERROR,
                (UInt8 *)"Log Archival Command Failed",oam_strlen("Log Archival Command Failed")+OAM_ONE,
                OAM_VERSION_ID, OAM_MODULE_ID,
                dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                p_error_code);

        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;
    }
    else
    {
        OAM_LOG(OAM,OAM_INFO,"Saved Current Logs of OAM/L2/L3/RRM/SON. Log Archival Command Successful");
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                OAM_ZERO,
                OAM_NULL,OAM_ZERO,
                OAM_VERSION_ID, OAM_MODULE_ID,
                dest_id, trans_id, OAM_ZERO, OAM_ZERO,
                p_error_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;
    }
    /* coverity 41369 */

}
/******************************************************************************
 * Function Name : create_log_time_stamp
 * Description   : This function is for create log time stamp  of L2/L3/RRM/SON/OAM.
 * Inputs        : timer_buff
 * Output        : None
 * Return        : OAM_SUCCESS/OAM_FAILURE
 ******************************************************************************/

    oam_return_et create_log_time_stamp
(
 UInt8 * timer_buff
 )
{
    const struct tm *tm_ptr = OAM_NULL;                           /*COVERITY_FIX_1.0*/
    size_t len;
    time_t now;
    now = OAM_TIME ( OAM_NULL );
    tm_ptr = OAM_LOCALTIME ( &now );
    if(OAM_NULL == tm_ptr)
    {
        OAM_LOG(OAM,OAM_WARNING,"tm_ptr is NULL");
        OAM_FUN_EXIT_TRACE();                                    /*COVERITY_FIX_1.0*/
        return OAM_FAILURE;                                     /*COVERITY_FIX_1.0*/
    }                                                           /*COVERITY_FIX_1.0*/
    else                                                        /*COVERITY_FIX_1.0*/
    {                                                           /*COVERITY_FIX_1.0*/
        len = strftime ((char *)timer_buff, TIME_SIZE, "%d_%m_%Y_%I-%M-%S", tm_ptr );
    }
    if(len == OAM_ZERO)
        return OAM_FAILURE;
    else
        return OAM_SUCCESS;
}

/******************************************************************************
 *  FUNCTION NAME: oam_upload_archive_files_to_ftp_server
 *  DESCRIPTION  : This function oam upload archive files to ftp server
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : filename,curl_error_code
 *  Output       :
 *  RETURNS: OAM_TRUE/OAM_FALSE
 ******************************************************************************/
    oam_return_et
oam_upload_archive_files_to_ftp_server(Char8* p_filename,
        UInt32 *curl_error_code)
{
    Char8  filename[OAM_ARCHIVE_FILE_NAME_MAX_SIZE] = {0};
    oam_nms_ftp_server_params_t p_oam_nms_ftp_server_params_t;

    /* KLOCWORK warning fix start */
    oam_strncpy((char*)filename, (const char *)p_filename, sizeof(filename));
    /* KLOCWORK warning fix end */

    oam_memset((void*)&p_oam_nms_ftp_server_params_t, OAM_ZERO, sizeof(oam_nms_ftp_server_params_t));

    /* SPR 12731 Fix Start */
    oam_strncpy((char *)p_oam_nms_ftp_server_params_t.ftp_server_url, 
            (const char *)oam_prov_req.oam_nms_ftp_server_params.ftp_server_url, 
            (oam_strlen((const char *)oam_prov_req.oam_nms_ftp_server_params.ftp_server_url))+1);

    oam_strncpy((char *)p_oam_nms_ftp_server_params_t.ftp_server_username, 
            (const char *)oam_prov_req.oam_nms_ftp_server_params.ftp_server_username, 
            (oam_strlen((const char* )oam_prov_req.oam_nms_ftp_server_params.ftp_server_username))+1);

    oam_strncpy((char *)p_oam_nms_ftp_server_params_t.ftp_server_password, 
            (const char *)oam_prov_req.oam_nms_ftp_server_params.ftp_server_password, 
            (oam_strlen((const char *)oam_prov_req.oam_nms_ftp_server_params.ftp_server_password))+1);

    oam_strncpy((char *)p_oam_nms_ftp_server_params_t.local_download_upload_path, 
            (const char *)"./", (oam_strlen((const char *)"./"))+1);
    /* SPR 12731 Fix End */

    if(OAM_FAILURE == oam_file_upload_to_server(&p_oam_nms_ftp_server_params_t,filename, curl_error_code))
    {
        OAM_LOG(OAM, OAM_WARNING, "oam_file_upload_to_server failed for %s", filename);
        OAM_FUN_EXIT_TRACE();
        /*SPR 20928 Fix Start*/
        return OAM_FAILURE;
        /*SPR 20928 Fix End*/
    }
    return OAM_SUCCESS;
}


/******************************************************************************
 * Function Name : oam_collect_logs 
 * Description   : This function collects logs of the system
 * Inputs        : None
 * Output        : None
 * Return        : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
    oam_return_et 
oam_collect_logs()
{
    UInt8   i = OAM_ZERO;
    oam_return_et ret = OAM_SUCCESS;

    oam_bool_et wait_for_agnet = OAM_FALSE;

    for (i = OAM_ZERO; i < OAM_MAX_NUM_L2_INSTANCE; i++)
    {
        if (l2_comm_info[i].init_flag)
        {
            if (OAM_FAILURE != oam_trigger_agent_fsm(OAM_NULL, OAM_AGENT_EVENT_GET_LOGS_REQ, i))
            {
                wait_for_agnet = OAM_TRUE;
            }
        }
    }

    if (OAM_FALSE == wait_for_agnet)
    {
        ret = oam_perform_log_archival();
    }

    return ret;
}

/******************************************************************************
 * Function Name : oam_perform_log_archival 
 * Description   : This function for maintaining logs of RRM/SON/L2/L3/OAM
 * Inputs        : None
 * Output        : None
 * Return        : OAM_SUCCESS/OAM_FAILURE 
 ******************************************************************************/
/* + SPR 17439 */
    oam_return_et
oam_perform_log_archival(void)
{
    /* - SPR 17439 */
    /* Cov CID 62091 fix*/
    OAM_FUN_ENTRY_TRACE();
    Char8  cmd[OAM_CP_CMD_SIZE]={OAM_ZERO};
    Char8  mk_cmd[OAM_CMD_SIZE]={OAM_ZERO};
    Char8  backup_folder_name[BKP_FILE_NAME_SIZE]={OAM_ZERO};
    UInt32  curl_error_code = OAM_ZERO;
    Char8  curl_error_msg[OAM_CURL_ERROR_MSG_ZIZE] = {OAM_ZERO};	
    /* coverity 54907 */
    UInt8 timer_buff[TIME_SIZE] ={OAM_ZERO};	
    /* Spr 12880 Fix Start*/
    UInt8 CellId = OAM_INVALID_CELL_ID;  
    /* Spr 12880 Fix End*/
    /* SPR 12731 Fix Start */

    if (!oam_prov_req.oam_nms_ftp_server_params.Enable)
    {
        OAM_LOG(OAM,OAM_INFO,"Cannot support Log Archival as FTP is disabled");
        return OAM_SUCCESS;
    }
    /* SPR 12731 Fix End */

    if (oam_prov_req.oam_params.oam_log_archival_supported)
    {
        create_log_time_stamp(timer_buff);

        /* Dump log file of OAM */
        oam_strncpy(backup_folder_name,"eNodeB_log_archive_",sizeof("eNodeB_log_archive_"));
        oam_strncat(backup_folder_name,(char*)timer_buff,oam_strlen((char*)timer_buff));

        oam_strncpy(mk_cmd,"mkdir ",sizeof("mkdir "));
        oam_strncat(mk_cmd,backup_folder_name,oam_strlen(backup_folder_name)+OAM_ONE);
        oam_system(mk_cmd);

        /*SPR 16945 Fixed Start*/
        oam_snprintf(cmd, sizeof(cmd),
                "cp agent_*_logs.tgz *.log* AlarmLog*.csv MAC_RLC_REGION*.bin"
                " RLC_PDCP_REGION*.bin MAC_LP_THD_REGION*.bin %s", backup_folder_name);
        /*SPR 16946 Fixed End*/

        OAM_LOG(OAM,OAM_INFO,"Copy command: %s", cmd);

        if(-1 ==  oam_system(cmd))
        {
            OAM_ALARM(LOG_ARCHIVE_FAILURE_ALARM_ID, MAJOR,
                    NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                    UNAVAILABLE, EXPEDITED_ALARM,
                    /* Spr 12880 Fix Start*/
                    "Log Archival Command failed", OAM_NULL,CellId);
            /* Spr 12880 Fix End*/
            return OAM_FAILURE;
        }

        oam_snprintf(cmd, sizeof(cmd), "tar -cvzf %s.tgz %s",
                backup_folder_name, backup_folder_name);
        if(-1 == oam_system(cmd))
        {
            OAM_LOG(OAM,OAM_INFO,"System Command for making tar failed\n");
            OAM_ALARM(LOG_ARCHIVE_FAILURE_ALARM_ID, MAJOR,
                    NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                    UNAVAILABLE, EXPEDITED_ALARM,
                    /* Spr 12880 Fix Start*/
                    "Log Archival Command failed", OAM_NULL,CellId);
            /* Spr 12880 Fix End*/
            return OAM_FAILURE;
        }

        oam_snprintf(cmd, sizeof(cmd), "%s.tgz", backup_folder_name);

        /* SPR 12731 Fix Code Removed */
        if (OAM_SUCCESS != oam_upload_archive_files_to_ftp_server(cmd, &curl_error_code))
        {
            oam_sprintf(curl_error_msg, "Log Archive Upload failed, Libcurl error code: %d", curl_error_code);
            oam_snprintf(cmd, sizeof(cmd), "rm -rf %s %s.tgz agent_*_logs.tgz",
                    backup_folder_name, backup_folder_name);
            if(-1 == oam_system(cmd))
            {
                OAM_LOG(OAM,OAM_INFO,"System Command for removing directory failed\n");
            }
            /*Raise Alarm*/
            OAM_ALARM(ARCHIVED_LOG_UPLOAD_FAILURE_ALARM_ID, MAJOR,
                    NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                    COMMUNICATIONS_TRANSMIT_FAILURE, EXPEDITED_ALARM,
                    /* Spr 12880 Fix Start*/
                    curl_error_msg, OAM_NULL,CellId);
            /* Spr 12880 Fix End*/
            return OAM_FAILURE;
        }
        oam_snprintf(cmd, sizeof(cmd), "rm -rf %s %s.tgz agent_*_logs.tgz",
                backup_folder_name, backup_folder_name);
        if(-1 == oam_system(cmd))
        {
            OAM_LOG(OAM,OAM_INFO,"System Command for removing directory failed\n");
            OAM_ALARM(LOG_ARCHIVE_FAILURE_ALARM_ID, MAJOR,
                    NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                    UNAVAILABLE, EXPEDITED_ALARM,
                    /* Spr 12880 Fix Start*/
                    "Log Archival Command failed", OAM_NULL,CellId);
            /* Spr 12880 Fix End*/
            return OAM_FAILURE;
        }        
    }
    else
    {
        OAM_LOG(OAM,OAM_INFO,"Log Archieve is not enabled");
    }

    /* Shutdown is triggered and all logs are collected */
    if (OAM_TRUE == shutdown_flag)
    {
        oam_killall();
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/******************************************************************************
 * Function Name : oam_update_tr069_params 
 * Description   : This function for updating tr069 parameters 
 * Inputs        : none 
 * Output        : none
 * Return        : none 
 ******************************************************************************/
/* + SPR 17439 */
void oam_update_tr069_params(void)
{
    /* - SPR 17439 */
    OAM_FUN_ENTRY_TRACE();

    /* Update the TR069 params in actual provisioning structure from local copy */
    oam_memcpy(&(oam_prov_req.oam_tr069_req.tr069_init_params),
            &(local_prov_req.oam_tr069_req.tr069_init_params),
            sizeof(oam_init_tr069_params_t));

    OAM_FUN_EXIT_TRACE();
    return;
}
#ifdef OAM_SON_ENABLE
/******************************************************************************
 * Function Name : oam_send_es_enable_req 
 * Description   : Sends the enable request 
 * Inputs        : EnergySavingControl,ActiveUECountIntervalSeconds,ActiveUECountThreshold 
 * Output        : 
 * Return        : 
 ******************************************************************************/
oam_return_et
    oam_send_es_enable_req
(
 SInt8 cell_arr_idx,
 UInt8  EnergySavingControl,
 UInt16 ActiveUECountIntervalSeconds,
 UInt8  ActiveUECountThreshold,
 void *p_api_buf, 
 UInt16 msg_len 
 )
{
    /* coverity 63615 */
    oam_son_es_enable_req_t oam_son_es_enable_req = {OAM_ZERO};
    UInt16 trans_id = OAM_ZERO;
    oam_return_et ret_val=OAM_SUCCESS;
    oam_memcpy(&oam_son_es_enable_req.srv_cgi,
            &SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi,
            sizeof(son_intra_rat_global_cell_id_t));

    oam_son_es_enable_req.bitmask |= SON_ES_ENABLE_SRV_CGI_PRESENT;


    oam_son_es_enable_req.interval = ActiveUECountIntervalSeconds;
    oam_son_es_enable_req.threshold_value = ActiveUECountThreshold;

    SON_PROV_REQ.oam_energy_saving_config[cell_arr_idx].
        ActiveUECountIntervalSeconds = ActiveUECountIntervalSeconds;

    SON_PROV_REQ.oam_energy_saving_config[cell_arr_idx].
        ActiveUECountThreshold = ActiveUECountThreshold;
    SON_PROV_REQ.oam_energy_saving_config[cell_arr_idx].EnergySavingControl
        = EnergySavingControl;

    trans_id = oam_get_new_trans_id();


    ret_val= oam_son_send_son_oam_es_enable_req(&oam_son_es_enable_req,
            OAM_MODULE_ID,
            SON_MODULE_ID,
            trans_id,
            oam_prov_req.cell_cntxt.curr_cell_cid);
#ifndef OAM_UT_FRAMEWORK
    if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                OAM_TRANS_SON,msg_len,p_api_buf))
    {
        OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
        return OAM_FAILURE;
    }

#endif
    return ret_val;
}

/******************************************************************************
 * Function Name : oam_send_es_disable_req 
 * Description   : Sends the disable request 
 * Inputs        : EnergySavingControl
 * Output        : 
 * Return        : 
 ******************************************************************************/
    oam_return_et
oam_send_es_disable_req(SInt8 cell_arr_idx, UInt8 EnergySavingControl,
        void *p_api_buf, 
        UInt16 msg_len)
{
    /* coverity 63614 */
    oam_son_es_disable_req_t oam_son_es_disable_req = {OAM_ZERO};
    UInt16 trans_id = OAM_ZERO;

    oam_memcpy(&oam_son_es_disable_req.srv_cgi,
            &SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).src_cgi,
            sizeof(son_intra_rat_global_cell_id_t));

    oam_son_es_disable_req.bitmask |= SON_ES_DISABLE_SRV_CGI_PRESENT;

    SON_PROV_REQ.oam_energy_saving_config[cell_arr_idx].EnergySavingControl
        = EnergySavingControl;

    trans_id = oam_get_new_trans_id();

    /* SPR 9620 CHANGE START */
    if(OAM_FAILURE == oam_son_send_son_oam_es_disable_req(&oam_son_es_disable_req,
                OAM_MODULE_ID,
                SON_MODULE_ID,
                trans_id,
                oam_prov_req.cell_cntxt.curr_cell_cid))
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to send SON_OAM_ES_DISABLE_REQ ");
        return OAM_FAILURE;
    }
    else
    {
        OAM_LOG(OAM, OAM_DETAILED, "Successfully sent SON_OAM_ES_DISABLE_REQ ");
#ifndef OAM_UT_FRAMEWORK
        if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_SON,
                    OAM_TRANS_SON,msg_len,p_api_buf))
        {
            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
            return OAM_FAILURE;
        }
#endif
    }
    return OAM_SUCCESS;
    /* SPR 9620 CHANGE END */

}

/******************************************************************************
 * Function Name : oam_send_es_cell_switch_on_req 
 * Description   : Sends the cell switch on request 
 * Inputs        : CellSwitchStatus 
 * Output        : 
 * Return        : 
 ******************************************************************************/
oam_return_et
    oam_send_es_cell_switch_on_req
(
 SInt8 cell_arr_idx,
 UInt8 CellSwitchStatus,
 void *p_api_buf, 
 UInt16 msg_len
 )
{
    oam_son_es_cell_switch_on_req_t  oam_son_es_cell_switch_on_req;
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %u and %d", CellSwitchStatus, cell_arr_idx);
    cell_config_idx = oam_get_rrm_cell_config_idx(
            oam_prov_req.cell_cntxt.curr_cell_cid);
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return OAM_FAILURE;
    }


    oam_son_es_cell_switch_on_req.srv_cgi.plmn_id.mcc[OAM_ZERO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.
        epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mcc[OAM_ZERO];
    oam_son_es_cell_switch_on_req.srv_cgi.plmn_id.mcc[OAM_ONE]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.
        epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mcc[OAM_ONE];
    oam_son_es_cell_switch_on_req.srv_cgi.plmn_id.mcc[OAM_TWO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.
        epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mcc[OAM_TWO];
    oam_son_es_cell_switch_on_req.srv_cgi.plmn_id.num_mnc_digit=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.
        epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.num_mnc_digit;
    oam_son_es_cell_switch_on_req.srv_cgi.plmn_id.mnc[OAM_ZERO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.
        epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mnc[OAM_ZERO];
    oam_son_es_cell_switch_on_req.srv_cgi.plmn_id.mnc[OAM_ONE]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.
        epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mnc[OAM_ONE];
    oam_son_es_cell_switch_on_req.srv_cgi.plmn_id.mnc[OAM_TWO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.
        epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mnc[OAM_TWO];
    oam_son_es_cell_switch_on_req.srv_cgi.cell_identity[OAM_ZERO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
        eutran_global_cell_id.cell_identity[OAM_ZERO];
    oam_son_es_cell_switch_on_req.srv_cgi.cell_identity[OAM_ONE]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
        eutran_global_cell_id.cell_identity[OAM_ONE];
    oam_son_es_cell_switch_on_req.srv_cgi.cell_identity[OAM_TWO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
        eutran_global_cell_id.cell_identity[OAM_TWO];
    oam_son_es_cell_switch_on_req.srv_cgi.cell_identity[OAM_THREE]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
        eutran_global_cell_id.cell_identity[OAM_THREE];

    UInt16 trans_id = oam_get_new_trans_id();
#ifndef OAM_UT_FRAMEWORK
    oam_maintain_tcb(trans_id,OAM_TRANS_SON,msg_len,p_api_buf);
#endif
    return oam_son_send_son_oam_es_cell_switch_on_req(
            &oam_son_es_cell_switch_on_req,
            OAM_MODULE_ID,
            SON_MODULE_ID,
            trans_id,
            oam_prov_req.cell_cntxt.curr_cell_cid);
}

/******************************************************************************
 * Function Name : oam_send_es_cell_switch_off_req 
 * Description   : Sends the cell switch off request 
 * Inputs        : CellSwitchStatus,CellSwitchOffMode 
 * Output        : 
 * Return        : 
 ******************************************************************************/
oam_return_et
    oam_send_es_cell_switch_off_req
(
 SInt8 cell_arr_idx,
 UInt8 CellSwitchStatus,
 UInt8 CellSwitchOffMode,
 void *p_api_buf, 
 UInt16 msg_len
 )
{
    oam_son_es_cell_switch_off_req_t  oam_son_es_cell_switch_off_req;
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %u", CellSwitchStatus);
    cell_config_idx = oam_get_rrm_cell_config_idx(
            oam_prov_req.cell_cntxt.curr_cell_cid);
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return OAM_FAILURE;
    }


    oam_son_es_cell_switch_off_req.srv_cgi.plmn_id.mcc[OAM_ZERO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mcc[OAM_ZERO];

    oam_son_es_cell_switch_off_req.srv_cgi.plmn_id.mcc[OAM_ONE]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mcc[OAM_ONE];

    oam_son_es_cell_switch_off_req.srv_cgi.plmn_id.mcc[OAM_TWO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mcc[OAM_TWO];

    oam_son_es_cell_switch_off_req.srv_cgi.plmn_id.num_mnc_digit=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.num_mnc_digit;

    oam_son_es_cell_switch_off_req.srv_cgi.plmn_id.mnc[OAM_ZERO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mnc[OAM_ZERO];

    oam_son_es_cell_switch_off_req.srv_cgi.plmn_id.mnc[OAM_ONE]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mnc[OAM_ONE];

    oam_son_es_cell_switch_off_req.srv_cgi.plmn_id.mnc[OAM_TWO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].epc_info.epc_params.general_epc_params.plmn_list[OAM_ZERO].plmn_info.mnc[OAM_TWO];

    oam_son_es_cell_switch_off_req.srv_cgi.cell_identity[OAM_ZERO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.cell_identity[OAM_ZERO];

    oam_son_es_cell_switch_off_req.srv_cgi.cell_identity[OAM_ONE]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.cell_identity[OAM_ONE];

    oam_son_es_cell_switch_off_req.srv_cgi.cell_identity[OAM_TWO]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.cell_identity[OAM_TWO];

    oam_son_es_cell_switch_off_req.srv_cgi.cell_identity[OAM_THREE]=oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id.cell_identity[OAM_THREE];
    /* coverity 41333 */
    oam_son_es_cell_switch_off_req.switch_off_mode=(son_cell_switch_off_mode_et)CellSwitchOffMode;
    oam_prov_req.oam_son_req.oam_energy_saving_config[cell_arr_idx].CellSwitchOffMode=CellSwitchOffMode;

    UInt16 trans_id = oam_get_new_trans_id();
#ifndef OAM_UT_FRAMEWORK
    oam_maintain_tcb(trans_id,OAM_TRANS_SON,msg_len,p_api_buf);
#endif
    return oam_son_send_son_oam_es_cell_switch_off_req(
            &oam_son_es_cell_switch_off_req,
            OAM_MODULE_ID,
            SON_MODULE_ID,
            trans_id,
            oam_prov_req.cell_cntxt.curr_cell_cid);
}


/******************************************************************************
 * Function Name : set_bitmask_son_anr_meas_bandwidth 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_meas_bandwidth
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_ALLOW_MEAS_BW_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

#endif


/* SPR 11001 FIX START */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_serving_cell
 *   DESCRIPTION:
 *     This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *   OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
void
    set_bitmask_load_config_serving_cell
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;
    p_req->bitmask |= RRM_OAM_LOAD_RPT_INTRVL_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_load_config_neighbor_cell
 *   DESCRIPTION:
 *    This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *   OAM_SUCCESS else return OAM_FAILURE
 * ******************************************************************************/
void
    set_bitmask_load_config_neighbor_cell
(
 int loop,
 void * p_load_config
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_rrm_load_config_req_t *p_req = p_load_config;
    p_req->bitmask |= RRM_OAM_NCL_LOAD_IND_INTRVL_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/* SPR 11001 FIX END */


#ifdef OAM_SON_ENABLE
/******************************************************************************
 * Function Name : set_bitmask_son_anr_presence_antenna_port 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_presence_antenna_port
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_PRESENCE_ANTENNA_PORT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_neighbor_cell_config 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_neighbor_cell_config
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_NBR_CELL_CONFIG_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_offset_frequency 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_offset_frequency
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_OFFSET_FREQ_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_q_rx_lev_min 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_q_rx_lev_min
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_Q_RX_LEV_MIN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_p_max 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_p_max
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_P_MAX_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_t_reselection 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_t_reselection
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_RESELECTION_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * Function Name : set_bitmask_son_anr_t_reselection_sf 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_t_reselection_sf
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_RESELECTION_SF_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_threshX_high 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_threshX_high
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_CELL_THRESH_HIGH_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_threshX_low 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_threshX_low
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_CELL_THRESH_LOW_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_cell_reselection_priority 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_cell_reselection_priority
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_CELL_RESELECTION_PRIORITY_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_q_qualmin_r9 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_q_qualmin_r9
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_Q_QUAL_MIN_R9;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_threshx_highq_r9 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_threshx_highq_r9
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_THRESHX_HIGH_Q_R9;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_threshx_lowq_r9 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_threshx_lowq_r9
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_THRESHX_LOW_Q_R9;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * Function Name : set_bitmask_son_anr_open_pci_range 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_open_pci_range
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_INTER_FREQ_OPEN_PCI_RANGE_PRESENT ;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_closed_pci_range 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_closed_pci_range
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_INTER_FREQ_CLOSED_PCI_RANGE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_hybrid_pci_range 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_son_anr_hybrid_pci_range
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_INTER_FREQ_HYBRID_PCI_RANGE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_offset_frequency 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_offset_frequency
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_FDD_OFFSET_FREQ_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_tdd_offset_frequency
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_tdd_offset_frequency
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_tdd_list[idx].
        bitmask |= SON_MC_UTRAN_TDD_OFFSET_FREQ_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_cell_reselection_priority 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_cell_reselection_priority
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_FDD_CELL_RESELECTION_PRIORITY_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * Function Name : set_bitmask_utra_tdd_cell_reselection_priority 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_tdd_cell_reselection_priority
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_tdd_list[idx].
        bitmask |= SON_MC_UTRAN_TDD_CELL_RESELECTION_PRIORITY_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_threshX_high 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_threshX_high
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_FDD_THRESH_HIGH_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_tdd_threshX_high 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_tdd_threshX_high
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_tdd_list[idx].
        bitmask |= SON_MC_UTRAN_TDD_THRESH_HIGH_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_threshX_low 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_threshX_low
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_FDD_THRESH_LOW_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_tdd_threshX_low 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_tdd_threshX_low
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_tdd_list[idx].
        bitmask |= SON_MC_UTRAN_TDD_THRESH_LOW_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_q_rx_lev_min 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_q_rx_lev_min
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_FDD_Q_RX_LEV_MIN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_tdd_q_rx_lev_min 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_tdd_q_rx_lev_min
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_tdd_list[idx].
        bitmask |= SON_MC_UTRAN_TDD_Q_RX_LEV_MIN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_p_max
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_p_max
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_FDD_P_MAX_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_utra_tdd_p_max
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_tdd_p_max
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_tdd_list[idx].
        bitmask |= SON_MC_UTRAN_TDD_P_MAX_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_q_qual_min
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_q_qual_min
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_FDD_Q_QUAL_MIN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_threshx_highq_r9
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_threshx_highq_r9
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_THRESHX_HIGH_Q_R9;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * Function Name : set_bitmask_utra_fdd_threshx_lowq_r9
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_fdd_threshx_lowq_r9
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.utran_fdd_list[idx].
        bitmask |= SON_MC_UTRAN_THRESHX_LOW_Q_R9;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * Function Name : set_bitmask_utra_t_reselection
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_t_reselection
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.bitmask |= SON_UTRAN_RESELECTION_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * Function Name : set_bitmask_utra_t_reselection_sf 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
void
    set_bitmask_utra_t_reselection_sf
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;

    p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
        utran_config_list.bitmask |= SON_UTRAN_RESELECTION_SF_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *  FUNCTION NAME: set_bitmask_inter_utran_neighbor
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_inter_utran_neighbor
(
 int loop, 
 void * p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    ((oam_son_nr_add_req_t *)p_son_nr_add_req)->nr_list.inter_rat_nr_list[OAM_ZERO].bitmask |= SON_INTER_UTRAN_NEIGHBOR;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *  FUNCTION NAME: set_bitmask_son_mro_modify_config_param_req_mro_mode
 *  DESCRIPTION  : This function will set the bitmask for mro modify config
 *                 param structure
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_son_mro_modify_config_param_req_mro_mode
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.bitmask |= SON_MRO_MODE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *  FUNCTION NAME: set_bitmask_son_mro_modify_config_param_req_mro_param
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_son_mro_modify_config_param_req_mro_param
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    p_req->eutran_config_params.bitmask |= SON_MRO_PARAM_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *  FUNCTION NAME: set_bitmask_mro_ho_failure_accumulation_duration
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_mro_ho_failure_accumulation_duration
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.
        bitmask |= SON_MRO_HO_FAILURE_ACCUMULATION_DURATION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *  FUNCTION NAME: set_bitmask_son_mro_modify_config_param_req_delta_cio
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *                 delta_cio element
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_son_mro_modify_config_param_req_delta_cio
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.bitmask |= SON_MRO_DELTA_CIO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *  FUNCTION NAME: set_bitmask_mro_trigger_optimization_ho_attempts
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *                 mro_trigger_optimization_ho_attempts element
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * ******************************************************************************/
void
    set_bitmask_mro_trigger_optimization_ho_attempts
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.
        bitmask |= SON_MRO_HO_ATTEMPTS_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 *  FUNCTION NAME: set_bitmask_mro_trigger_analysis_ho_failure_rate
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *                 mro_trigger_analysis_ho_failure_rate element
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_mro_trigger_analysis_ho_failure_rate
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.
        bitmask |= SON_MRO_HO_OPTIMIZATION_START_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *  FUNCTION NAME: set_bitmask_mro_ho_fail_rate_for_optimization
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *                 mro_ho_fail_rate element
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_mro_ho_fail_rate_for_optimization
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.
        bitmask |= SON_MRO_HO_FAIL_RATE_FOR_OPTIMIZATION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *  FUNCTION NAME: set_bitmask_mro_ho_fail_rate
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *                 mro_ho_fail_rate element
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_mro_ho_fail_rate
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.
        bitmask |= SON_MRO_HO_OPTIMIZATION_STOP_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 *  FUNCTION NAME: set_bitmask_mro_default_ttt
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *                 default_ttt element
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_mro_default_ttt
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.bitmask |= SON_MRO_TTT_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *  FUNCTION NAME: set_bitmask_son_mro_modify_config_param_req_delta_ttt
 *  DESCRIPTION  : This function will set the bitmask for mro modify config 
 *                 param structure
 *                 delta_ttt element
 *  Inputs       : loop : loop value for future reference
 *  Output       : pointer to oam_son_mro_modify_config_params_req_t
 *  RETURNS      : none
 * **************************************************************************/
void
    set_bitmask_son_mro_modify_config_param_req_delta_ttt
(
 int loop,
 void * p_mro_modify_config_params_req
 )
{
    oam_son_mro_modify_config_params_req_t
        *p_req = p_mro_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->eutran_config_params.bitmask |= SON_MRO_DELTA_TTT_PRESENT;
    OAM_FUN_EXIT_TRACE();
}



/******************************************************************************
 * *  FUNCTION NAME: set_bitmask_intra_pci 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_intra_pci
(
 int loop,
 void * p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_PCI_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/*eICIC_PHASE_1_2_CHANGES_START */
/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_intra_rat_min_abs_usage_threshold 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_min_abs_usage_threshold
(
 int loop,
 void * p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;


    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_EICIC_INFO_PRESENT;
    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].eicic_info.
        bitmask |= SON_CELL_ABS_USAGE_THRESHOLD_PRESENT;
    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].eicic_info.abs_usage_threshold.
        bitmask |= SON_CELL_MIN_ABS_USAGE_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_intra_rat_max_abs_usage_threshold 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_max_abs_usage_threshold
(
 int loop,
 void * p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;


    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_EICIC_INFO_PRESENT;
    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].eicic_info.
        bitmask |= SON_CELL_ABS_USAGE_THRESHOLD_PRESENT;
    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].eicic_info.abs_usage_threshold.
        bitmask |= SON_CELL_MAX_ABS_USAGE_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_intra_rat_interference_scheme
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_interference_scheme
(
 int loop,
 void * p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_EICIC_INFO_PRESENT;
    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].eicic_info.
        bitmask |= SON_CELL_INTF_SCHEME_TYPE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/*eICIC_PHASE_1_2_CHANGES_END */

/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_intra_cell_specific_offset
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_intra_cell_specific_offset
(
 int loop,
 void * p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_CELL_OFFSET_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_intra_rat_tac
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_tac
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_TAC_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_intra_rat_plmn_id
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_plmn_id
(
 int loop,
 void *p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_PLMN_ID_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_intra_rat_csg_id 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_csg_id
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_INTRA_CSG_ID_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_intra_rat_earfcn 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_earfcn
(
 int loop,
 void *p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_req = p_son_nr_add_req;
    UInt8 idx = p_req->nr_list_query_idx;

    p_req->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_EARFCN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_intra_rat_ul_earfcn 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_ul_earfcn
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_UL_EARFCN_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_intra_ho_status
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_intra_ho_status
(
 int loop,
 void *p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_ENABLE_HO_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_intra_rat_rsrp 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_rsrp
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_RSRP_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_intra_rat_rsrq 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_rsrq
(
 int loop,
 void *p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_RSRQ_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_intra_rat_nr_status 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_nr_status
(
 int loop,
 void *p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_ENABLE_NR_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_intra_rat_suspected_pci 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_intra_rat_suspected_pci
(
 int loop,
 void *p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        intra_rat_nr_list[idx].bitmask |= SON_SUSPECT_PCI_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_inter_rat_pci 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_pci
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_req = p_son_nr_add_req;
    UInt8 idx = p_req->nr_list_query_idx;

    /* RT SPR 9019 FIX START */
    /* Cov CID 63597 Fix */    
    SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
    cell_config_idx = oam_get_rrm_cell_config_idx(
            oam_prov_req.cell_cntxt.curr_cell_cid);
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }
    oam_rrm_cell_config_req_t *p_rrm_cell_config = &oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx];
    /* Cov CID 63597 Fix */    


    UInt16 uarfcn = 0;
    /* SPR-13586 START */
    if(p_req->inter_rat_umts_entry_bitmap & (1 << idx)) {
        /* SPR-13586 END */
        uarfcn = p_req->oam_son_nr_add_req.
            nr_list.inter_rat_nr_list[idx].utran_neighbor.uarfcn;
    }
    else {
        uarfcn = p_req->oam_son_nr_add_req.nr_list.inter_rat_nr_list[idx].
            utran_neighbor.uarfcn;
    }

    oam_freq_type_et freq_found = oam_find_arfcn_in_available_freqs(uarfcn,
            OAM_ARFCN_UTRAN, p_rrm_cell_config);

    if(OAM_UTRAN_FREQ_FDD == freq_found) {
        p_req->oam_son_nr_add_req.nr_list.inter_rat_nr_list[idx].
            utran_neighbor.pci.
            bitmask = SON_PCI_FDD_PRESENT;
    }
    /*SPR_18437_START*/
    else if (OAM_UTRAN_FREQ_TDD == freq_found){
        p_req->oam_son_nr_add_req.nr_list.inter_rat_nr_list[idx].utran_neighbor.pci.
            bitmask = SON_PCI_TDD_PRESENT;
    }    
    else 
    {  
        OAM_LOG(OAM,OAM_DETAILED,"UARFCN Freq not configured");
        p_req->oam_son_nr_add_req.nr_list.inter_rat_nr_list[idx].utran_neighbor.pci.
            bitmask = OAM_ZERO;
    }
    /*SPR_18437_END*/
    p_req->oam_son_nr_add_req.nr_list.inter_rat_nr_list[idx].utran_neighbor.
        bitmask |= SON_UTRAN_PCI_PRESENT;

    /* RT SPR 9019 FIX END */
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_inter_rat_pci_tdd 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_pci_tdd
(
 int loop,
 void * p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.pci.bitmask = OAM_ZERO;
    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.pci.bitmask |= SON_PCI_TDD_PRESENT;
    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |= SON_UTRAN_PCI_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_inter_rat_cso 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_cso
(
 int loop,
 void *p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |= SON_UTRAN_CSO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_inter_rat_lac 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_lac
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |= SON_UTRAN_LAC_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_inter_rat_rac 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_rac
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |= SON_UTRAN_RAC_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_inter_rat_plmn_id
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_plmn_id
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |=
        SON_UTRAN_PLMN_ID_PRESENT;
    OAM_FUN_EXIT_TRACE();
}



/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_inter_rat_csg_id
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_csg_id
(
 int loop,
 void *p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |=
        SON_UTRAN_CSG_ID_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_inter_uarfcn
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_inter_uarfcn
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |=
        SON_UTRAN_UARFCN_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_inter_rat_rscp
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_rscp
(
 int loop,
 void * p_son_nr_add_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |= SON_UTRAN_RSCP_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME: set_bitmask_add_req_inter_rat_ecno 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_ecno
(
 int loop,
 void * p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |= SON_UTRAN_ECNO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_inter_rat_nr_status 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_nr_status
(
 int loop,
 void * p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |=
        SON_UTRAN_ENABLE_NR_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_add_req_inter_rat_ho_status 
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_add_req_inter_rat_ho_status
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].utran_neighbor.bitmask |=
        SON_UTRAN_ENABLE_HO_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/* SPR-13586 START */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_nr_geran_ho_status
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_nr_geran_ho_status
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].geran_neighbor.bitmask |=
        SON_GERAN_ENABLE_HO_STATUS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_nr_geran_nr_status
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_nr_geran_nr_status
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].geran_neighbor.bitmask |=
        SON_GERAN_ENABLE_NR_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME:set_bitmask_son_nr_geran_rssi 
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_nr_geran_rssi
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].geran_neighbor.bitmask |=
        SON_GERAN_RSSI_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME:set_bitmask_son_nr_geran_rac
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_nr_geran_rac
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].geran_neighbor.bitmask |=
        SON_GERAN_RAC_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME:set_bitmask_son_nr_geran_bsic
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_nr_geran_bsic
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].geran_neighbor.bitmask |=
        SON_GERAN_PCI_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME:set_bitmask_son_nr_geran_cell_spec_offset
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_nr_geran_cell_spec_offset
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].geran_neighbor.bitmask |=
        SON_GERAN_CSO_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME:set_bitmask_son_nr_geran_arfcn
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_nr_geran_arfcn
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].geran_neighbor.bitmask |=
        SON_GERAN_ARFCN_BAND_IND_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME:set_bitmask_son_nr_geran_band_ind
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_nr_geran_band_ind
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.
        inter_rat_nr_list[idx].geran_neighbor.bitmask |=
        SON_GERAN_ARFCN_BAND_IND_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/* SPR-13586 END */


/******************************************************************************
 * *   FUNCTION NAME:set_bitmask_autonomous_switch_off
 * *  DESCRIPTION  : This function will check for validation of parameter
 * *  Inputs       : loop : loop value for future reference
 * *  Output       : none
 * *  RETURNS      : none
 * ******************************************************************************/

void
    set_bitmask_autonomous_switch_off_load
(
 int loop,
 void *p_es_autonomous_switch_off_config_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_oam_es_autonomous_switch_off_config_req_t *p_req =
        p_es_autonomous_switch_off_config_req;

    p_req->bitmask |= SON_OAM_AUTO_SWITCH_OFF_LOAD_LEVEL;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 ** *   FUNCTION NAME:set_bitmask_autonomous_switch_off_active
 ** *  DESCRIPTION  : This function will check for validation of parameter
 ** *  Inputs       : loop : loop value for future reference
 ** *  Output       : none
 ** *  RETURNS      : none
 ** ******************************************************************************/

void
    set_bitmask_autonomous_switch_off_active
(
 int loop,
 void *p_es_autonomous_switch_off_config_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_oam_es_autonomous_switch_off_config_req_t *p_req =
        p_es_autonomous_switch_off_config_req;

    p_req->bitmask |= SON_OAM_AUTO_SWITCH_OFF_UE_COUNT;

    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 ** *   FUNCTION NAME:set_bitmask_autonomous_switch_off_both
 ** *  DESCRIPTION  : This function will check for validation of parameter
 ** *  Inputs       : loop : loop value for future reference
 ** *  Output       : none
 ** *  RETURNS      : none
 ** ******************************************************************************/

void
    set_bitmask_autonomous_switch_off_both
(
 int loop,
 void *p_es_autonomous_switch_off_config_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_oam_es_autonomous_switch_off_config_req_t *p_req =
        p_es_autonomous_switch_off_config_req;

    p_req->bitmask |= SON_OAM_AUTO_SWITCH_OFF_LOAD_LEVEL;
    p_req->bitmask |= SON_OAM_AUTO_SWITCH_OFF_UE_COUNT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_nr_enb_add_tnl_address_ipv4
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_nr_enb_tnl_address_ipv4
(
 int loop,
 void * p_nbr_enb_list 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    /* Set the bitmask */
    int size = ((son_neighbor_enb_info_t *)p_nbr_enb_list)->enb_tnl_address_list_size;
    ((son_neighbor_enb_info_t *)p_nbr_enb_list)->bitmask |= SON_ANR_ENB_TNL_ADD_LIST_PRESENT;
    ((son_neighbor_enb_info_t *)p_nbr_enb_list)->enb_tnl_address_list[size].bitmask |= IPV4_ADD_PRESENT;
    ((son_neighbor_enb_info_t *)p_nbr_enb_list)->enb_tnl_address_list_size += OAM_ONE;

    OAM_FUN_EXIT_TRACE();
}
/* SPR 11519 CHANGE START */
/******************************************************************************
 *  FUNCTION NAME: set_bitmask_mlb_modify_mlb_mode 
 *  DESCRIPTION  : This function will set the bitmask for mlb modify attribute
 *                 of minmum frequency
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none
 * ******************************************************************************/

    void set_bitmask_mlb_modify_mlb_mode
(
 int loop,
 void * p_mlb_modify_config_params_req
 )
{
    oam_son_mlb_modify_attributes_req_t
        *p_req = p_mlb_modify_config_params_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->bitmask |= SON_OAM_MLB_MODE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/*SPR 11519 CHANGE END */

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mlb_eutra_q_offset_config_q_offset_min
 *  DESCRIPTION  : This function will set the bitmask for mlb modify attribute
 *                 of minmum frequency
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none
 * ******************************************************************************/
void
    set_bitmask_mlb_eutra_q_offset_config_q_offset_min
(
 int loop,
 void * p_mlb_modify_attr_req
 )
{
    oam_son_mlb_modify_attributes_req_t *p_req = p_mlb_modify_attr_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    p_req->bitmask |= SON_OAM_MLB_EUTRA_Q_OFFSET_CONFIG_PRESENT;
    p_req->eutra_q_offset_config.bitmask |= SON_OAM_MLB_Q_OFF_MIN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_mlb_eutra_q_offset_config_q_offset_max
 *  DESCRIPTION  : This function will set the bitmask for mlb modify attribute 
 *                 of maximum frequency
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none
 * ******************************************************************************/
void
    set_bitmask_mlb_eutra_q_offset_config_q_offset_max
(
 int loop,
 void * p_mlb_modify_attr_req
 )
{
    oam_son_mlb_modify_attributes_req_t *p_req = p_mlb_modify_attr_req;
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    p_req->bitmask |= SON_OAM_MLB_EUTRA_Q_OFFSET_CONFIG_PRESENT;
    p_req->eutra_q_offset_config.bitmask |= SON_OAM_MLB_Q_OFF_MAX_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_modify_pci_confusion_cfg_suspect_pci_threshold 
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_modify_pci_confusion_cfg_suspect_pci_threshold
(
 int loop,
 void * p_oam_son_anr_modify_pci_confusion_cfg_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_modify_pci_confusion_cfg_req_t *p_req = p_oam_son_anr_modify_pci_confusion_cfg_req; 

    p_req->pci_confusion_cfg.bitmask |= SON_SUSPECT_PCI_THRESHOLD_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_modify_removal_attributes_no_activity_interval
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_modify_removal_attributes_no_activity_interval
(
 int loop,
 void * p_oam_son_anr_modify_removal_attributes_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_modify_removal_attributes_req_t *p_req = p_oam_son_anr_modify_removal_attributes_req; 
    p_req->removal_criteria.bitmask |= SON_NO_ACTIVITY_INTERVAL_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_modify_removal_attributes_handover_failure_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_modify_removal_attributes_handover_failure_threshold
(
 int loop,
 void * p_oam_son_anr_modify_removal_attributes_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_modify_removal_attributes_req_t *p_req = p_oam_son_anr_modify_removal_attributes_req; 
    p_req->removal_criteria.bitmask |= SON_FAILED_HO_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_modify_removal_attributes_timeout_no_nr_neighbors
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
set_bitmask_son_anr_modify_removal_attributes_timeout_no_nr_neighbors
(
 int loop,
 void *  p_oam_son_anr_modify_removal_attributes_req

 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_modify_removal_attributes_req_t *p_req = p_oam_son_anr_modify_removal_attributes_req;
    p_req->removal_criteria.bitmask |= SON_TIMEOUT_NO_NR_NEIGHBORS;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_modify_pci_confusion_cfg_clear_suspect_pci_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_anr_modify_pci_confusion_cfg_clear_suspect_pci_threshold
(
 int loop,
 void * p_oam_son_anr_modify_pci_confusion_cfg_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_modify_pci_confusion_cfg_req_t *p_req = p_oam_son_anr_modify_pci_confusion_cfg_req; 
    p_req->pci_confusion_cfg.bitmask |= SON_CLEAR_SUSPECT_PCI_THRESHOLD_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/* SPR 20653 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_modify_attribute_ue_throughput_dl_anr_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_anr_modify_attribute_ue_throughput_dl_anr_threshold
(
 int loop,
 void * p_oam_son_anr_modify_attribute_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_modify_attribute_req_t *p_req = p_oam_son_anr_modify_attribute_req; 
    p_req->anr_attribute.bitmask |= SON_MODIFY_DL_ANR_THRESHOLD_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_modify_attribute_ue_throughput_ul_anr_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_anr_modify_attribute_ue_throughput_ul_anr_threshold
(
 int loop,
 void * p_oam_son_anr_modify_attribute_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_modify_attribute_req_t *p_req = p_oam_son_anr_modify_attribute_req; 
    p_req->anr_attribute.bitmask |= SON_MODIFY_UL_ANR_THRESHOLD_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/* SPR 20653 Fix End */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_nr_enb_tac
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_nr_enb_tac
(
 int loop,
 void * p_nbr_enb_list
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    /* Set the bitmask */
    ((son_neighbor_enb_info_t *)p_nbr_enb_list)->bitmask |= SON_ANR_ENB_TAC_PRESENT;

    ((son_neighbor_enb_info_t *)p_nbr_enb_list)->tac_list_size = OAM_ONE;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_nr_enb_x2_status
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_nr_enb_x2_status
(
 int loop,
 void *p_nbr_enb_list 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    /* Set the bitmask */
    ((son_neighbor_enb_info_t *)p_nbr_enb_list)->bitmask |= SON_ANR_ENB_X2_HO_STATUS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_nr_enb_x2_connection_status
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_nr_enb_x2_connection_status
(
 int loop,
 void * p_nbr_enb_list 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    /* Set the bitmask */
    ((son_neighbor_enb_info_t *)p_nbr_enb_list)->bitmask |= SON_ANR_ENB_CUR_X2_CONN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_ue_count
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_ue_count
(
 int loop,
 void * p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable; 
    p_req->bitmask |= SON_UE_CNT_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_reporting_interval
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_reporting_interval
(
 int loop,
 void * p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable;
    p_req->bitmask |= 
        SON_REPORTNG_INTERVAL_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_limited_mode
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_limited_mode
(
 int loop,
 void * p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    oam_son_anr_enable_req_t *p_req = p_anr_enable;    
    p_req->bitmask |= 
        SON_LIMITED_MODE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_no_act_int
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_no_act_int
(
 int loop,
 void * p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable;
    p_req->bitmask |= 
        SON_REMOVAL_CRITERIA_PRESENT;
    p_req->removal_criteria.bitmask |= 
        SON_NO_ACTIVITY_INTERVAL_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_ho_failure_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_ho_failure_threshold
(
 int loop,
 void * p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable;
    p_req->bitmask |= 
        SON_REMOVAL_CRITERIA_PRESENT;
    p_req->removal_criteria.bitmask |= 
        SON_FAILED_HO_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_timeout_no_nr_neighbors
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_timeout_no_nr_neighbors
(
 int loop,
 void * p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable;
    p_req->bitmask |= 
        SON_REMOVAL_CRITERIA_PRESENT;
    p_req->removal_criteria.bitmask |= 
        SON_TIMEOUT_NO_NR_NEIGHBORS;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_suspect_pci_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_suspect_pci_threshold
(
 int loop,
 void * p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable; 
    p_req->bitmask |= 
        SON_PCI_CONFUSION_CFG_PRESENT;
    p_req->pci_confusion_cfg.bitmask |= 
        SON_SUSPECT_PCI_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}



/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_clear_suspect_pci_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_clear_suspect_pci_threshold
(
 int loop,
 void *p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable;
    p_req->bitmask |= 
        SON_PCI_CONFUSION_CFG_PRESENT;
    p_req->pci_confusion_cfg.bitmask |= 
        SON_CLEAR_SUSPECT_PCI_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/* SPR 20653 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_ue_throughput_dl_anr_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_ue_throughput_dl_anr_threshold
(
 int loop,
 void *p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable;
    p_req->bitmask |= 
        SON_UE_THROUGHPUT_DL_ANR_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_anr_enable_ue_throughput_ul_anr_threshold
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void
    set_bitmask_son_anr_enable_ue_throughput_ul_anr_threshold
(
 int loop,
 void *p_anr_enable 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_anr_enable_req_t *p_req = p_anr_enable;
    p_req->bitmask |= 
        SON_UE_THROUGHPUT_UL_ANR_THRESHOLD_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/* SPR 20653 Fix End */
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_nw_scan_plmn_list
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_nw_scan_plmn_list
(
 int loop,
 void * p_cell_reconfig_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);
    local_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.bitmask |=
        SON_NW_SCAN_PLMN_ID_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_nw_scan_meas_bandwidth_per_earfcn
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_nw_scan_meas_bandwidth_per_earfcn
(
 int loop,
 void * p_nw_scan_meas_bw 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    /*SPR 12001 FIX START*/
    son_start_intra_rat_scan_req_t *p_req = p_nw_scan_meas_bw;
    p_req->bitmask |=
        SON_MEAS_BANDWINDTH_PER_EARFCN_PRESENT;
    /*SPR 12001 FIX END*/
    OAM_FUN_EXIT_TRACE();
}

/*SPR 12001 FIX START*/
/******************************************************************************
 **   FUNCTION NAME: set_bitmask_son_nw_scan_pci_list
 **  DESCRIPTION  : This function will check for validation of parameter
 **  Inputs       : loop : loop value for future reference
 **  Output       : none
 **  RETURNS      : none
 ** ******************************************************************************/
void
    set_bitmask_son_nw_scan_pci_list
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);
    local_prov_req.oam_son_req.temp_values.temp_bitmask |=
        OAM_TEMP_PCI_LIST_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/*SPR 12001 FIX END*/


/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_nw_scan_meas_bandwidth
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_nw_scan_meas_bandwidth
(
 int loop,
 void * p_cell_reconfig_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);
    local_prov_req.oam_son_req.nw_scan.start_intra_rat_scan_req.bitmask |=
        SON_MEAS_BANDWINDTH_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: oam_nw_scan_set_bitmask_earfcn_dl_list
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    oam_nw_scan_set_bitmask_earfcn_dl_list
(
 int loop,
 void * p_cell_reconfig_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

    local_prov_req.oam_son_req.temp_values.temp_bitmask |= OAM_TEMP_EARFCN_LIST_PRESENT;
    set_bitmask_son_nw_scan_meas_bandwidth_per_earfcn(loop, p_cell_reconfig_req);
    OAM_FUN_EXIT_TRACE();
}

/* OAM BCOM Code Comment Changes Start */

/******************************************************************************
 *   FUNCTION NAME: oam_nw_scan_set_bitmask_carrier_ch_width
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none
 * ******************************************************************************/
void
    oam_nw_scan_set_bitmask_carrier_ch_width
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();

    local_prov_req.oam_son_req.temp_values.temp_bitmask |= OAM_TEMP_CARRIER_ARFCN_DL_PRESENT;
    set_bitmask_son_nw_scan_meas_bandwidth_per_earfcn(loop, p_cell_reconfig_req);
    OAM_FUN_EXIT_TRACE();
}

/* OAM BCOM Code Comment Changes End */

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_nr_del_from_rem_list_intra
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_nr_del_from_rem_list_intra
(
 int loop,
 void * p_cell_reconfig_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);
    local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO].bitmask |=
        SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_nr_del_from_rem_list_utran
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_nr_del_from_rem_list_utran
(
 int loop,
 void * p_cell_reconfig_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);
    local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO].bitmask |=
        SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT;
    local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO].
        inter_rat_global_cell_id.bitmask |= SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT;
    local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO].
        inter_rat_global_cell_id.utran_geran_global_cell_id.rat_type = SON_UTRAN_CELL;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_son_nr_del_from_rem_list_geran
 *  DESCRIPTION  : This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : none
 *  RETURNS      : none 
 * ******************************************************************************/
void 
    set_bitmask_son_nr_del_from_rem_list_geran
(
 int loop,
 void * p_cell_reconfig_req 
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);
    local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO].bitmask |=
        SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT;
    local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO].
        inter_rat_global_cell_id.bitmask |= SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT;
    local_prov_req.oam_son_req.nr_delete_from_remove_list.trgt_cgi_list[OAM_ZERO].
        inter_rat_global_cell_id.utran_geran_global_cell_id.rat_type = SON_GERAN_CELL;
    OAM_FUN_EXIT_TRACE();
}



#endif
/******************************************************************************
 * Function Name : oam_send_sdm_start_upgrade_req 
 * Description   : This function is used to send Upgrade Req to SDM  
 * Inputs        : p_data
 * Output        : None
 * Return        : OAM_SUCCESS\OAM_FAILURE 
 ******************************************************************************/
oam_return_et 
    oam_send_sdm_start_upgrade_req
(
 UInt8 *p_data
 ) 
{
    /* Coverity 107176 + */
    oam_error_code_et error_code = NO_ERROR;
    /* Coverity 107176 - */
    oam_timer_t  timer;
    /*SPR 18134 FIXED START*/
    UInt8* p_msg = OAM_NULL;
    /*SPR 18134 FIXED END*/
    /* coverity 35900 */
    oam_return_et ret_val = OAM_SUCCESS;
    UInt16 msg_size = OAM_ZERO;
    /* Spr 12880 Fix Start*/
    UInt8 CellId = OAM_INVALID_CELL_ID;
    /* Spr 12880 Fix End*/
    OAM_FUN_ENTRY_TRACE();

    msg_size = get_word_from_header((UInt8*)(p_data) + OAM_EIGHT);

    if (g_upgrade_req_retry_counter!= SDM_STOP_TIMER)
    {
        /*SPR 18134 FIXED START*/
        /* Coverity 107176 + */
        if(OAM_FAILURE == oam_mem_alloc(msg_size,(void*)&p_msg,&error_code))
            /* Coverity 107176 - */
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Memory allocation to p_msg failed"
                    " with Error Code:%d",
                    error_code);
            /*SPR 19444 FIXED START */
            /* Coverity 107176 + */
            oam_mem_free(p_data, &error_code);
            /* Coverity 107176 - */
            /*SPR 19444 FIXED END */
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
        oam_memcpy(p_msg,p_data,msg_size); 
        /*SPR 18134 FIXED END*/

        if(g_upgrade_req_retry_counter< MAX_RETRY_SEND_UPGRADE_REQ)
        {
            /* Coverity 107176 + */
            if(OAM_SUCCESS == oam_send_message(p_data,OAM_SDM_MODULE_ID,&error_code)) 
                /* Coverity 107176 - */
            {
                OAM_LOG(OAM,OAM_INFO,"Sending Upgrade Required message to SDM");
                g_upgrade_req_retry_counter++;
            }  
            else
            {  
                OAM_LOG(OAM,OAM_ERROR,"Error in Sending Upgrade Required message to SDM.");
                /* Coverity 72395 + - Code Removed */
                /* Coverity 107176_107179 + */
                oam_mem_free(p_msg, &error_code);
                /* Coverity 107176_107179 - */
                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;
            }
            /*SPR 18134 FIXED START*/
            timer = oam_start_new_timer(OAM_SUB_MODULE_SDM,QCLI_INTERFACE_MODULE_ID,OAM_SDM_TIMER_TYPE,OAM_SDM_TIMEOUT * OAM_THOUSAND,
                    (void*)p_msg,msg_size,(oam_bool_et)OAM_ZERO);
            if (OAM_NULL == timer)
            {
                /* Coverity 107176 + */
                oam_mem_free(p_data, &error_code);
                /* Coverity 107176 - */
                /* Coverity 107179 + */
                oam_mem_free(p_msg, &error_code);
                /* Coverity 107179 - */
                p_data = OAM_NULL;
                ret_val = OAM_FAILURE;
            }
            /*SPR 18134 FIXED END*/

        }
        else
        {
            /*Raise Alarm to notify TR and CLI for indicating that SDM is not responding*/
            OAM_LOG(OAM,OAM_WARNING,"Raising Alarm to notify TR and CLI, that SDM is not responding");
            OAM_ALARM(OAM_SDM_SHUTDOWN_FAILURE_ALARM_ID, 5, NOTIFY_NEW_ALARM,
                    PROCESSING_ERROR_ALARM, UNAVAILABLE,
                    REPORT_MECHANISM_UNDEFINED,
                    /* Spr 12880 Fix Start*/
                    "SDM not responding", OAM_NULL,CellId);
            /* Spr 12880 Fix End*/

            g_upgrade_req_retry_counter= OAM_ZERO;
            /* Coverity 107176 + */
            /*SPR 19444 FIXED START */
            oam_mem_free(p_data, &error_code);
            /*SPR 19444 FIXED END */
            /* Coverity 107179 + */
            oam_mem_free(p_msg, &error_code);
            /* Coverity 107179 - */
            /* Coverity 107176 - */
        }
    }
    /*SPR 19444 FIXED START */
    else
    {
        /* Coverity 107176 + */
        oam_mem_free(p_data, &error_code);
        /* Coverity 107176 - */
    }   
    /*SPR 19444 FIXED END */
    OAM_FUN_EXIT_TRACE();
    return ret_val;
}

/******************************************************************************
 * Function Name : oam_handle_sdm_upgrade_start_response	 
 * Description   : This function handle  SDM shutdown request. 
 * Inputs        : p_msg
 * Output        : None
 * Return        : OAM_SUCCESS\OAM_FAILURE 
 ******************************************************************************/
oam_return_et
    oam_handle_sdm_upgrade_start_response
(
 void *p_msg
 )
{

    oam_return_et     ret_val = OAM_SUCCESS; 
    UInt8 status = OAM_ZERO;  

    OAM_FUN_ENTRY_TRACE();
    status = *((U8 *)p_msg);

    if(OAM_RESULT_SUCCESS == status)
    {
        g_upgrade_req_retry_counter= SDM_STOP_TIMER;

        flag_shutdown_for_soft_upgrade = OAM_TRUE;
        admin_cmd_restart_flag = OAM_SDM_UPGRADE;
        if (OAM_FAILURE == oam_handle_shutdown_cmd(p_msg,OAM_ZERO,OAM_NULL))
        {
            OAM_LOG(OAM,OAM_ERROR,"Failed to Handle Shutdown Req");

            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }
    }
    else
    {
        OAM_LOG(OAM,OAM_WARNING,"Failure in Upgrade Start Received from SDM.");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    } 

    OAM_FUN_EXIT_TRACE();  /* Coverity FIX 36181 */
    return ret_val; 
}

/****************************************************************************
 * Function Name : oam_construct_sdm_start_upgrade_req 
 * Description   : This function constructs start upgrade request message 
 *                 for SDM
 * Inputs        : p_payload,file_size,file_type,file_des_len,file_name_len,
 *                 file_name,file_desi,msg_size
 * Output        : None
 * Return        : None 
 ******************************************************************************/
void *
oam_construct_sdm_start_upgrade_req
(   
 UInt32  file_size,
 UInt8   file_type,
 UInt8   file_des_len,
 UInt16  file_name_len,
 UInt8*  file_name,
 UInt8*  file_des,
 UInt16  *msg_size
 )
{

    UInt32  resvd1=OAM_ZERO;
    UInt8   resvd3= OAM_ZERO;
    UInt16  resvd2=OAM_ZERO,resvd4=OAM_ZERO,resvd5=OAM_ZERO;
    UInt16  resvd6 = OAM_ZERO,resvd7 = OAM_ZERO;
    UInt16  resvd8 = OAM_ZERO,resvd9 = OAM_ZERO;
    UInt8 num_of_params =OAM_FOUR;
    UInt8 oui[OAM_HUNDRED] = {OAM_ZERO};
    Char8 product_class[OAM_HUNDRED] = {OAM_ZERO};
    UInt8 sw_version [OAM_HUNDRED]= {OAM_ZERO};
    UInt8 hw_version[OAM_HUNDRED] = {OAM_ZERO};
    UInt16 counter = OAM_ZERO;
    UInt16 length = OAM_ZERO;
    UInt8* p_msg = OAM_NULL;
    UInt8* p_payload = OAM_NULL;
    UInt16 trans_id = OAM_ZERO; 
    /* coverity 35895 */ 
    oam_error_code_et error_code = NO_ERROR;

    OAM_FUN_ENTRY_TRACE();

    trans_id = oam_get_new_trans_id(); 

    *msg_size+=sizeof(UInt16)+sizeof(UInt16); /* reserved Field */
    *msg_size+=sizeof(UInt32)   
        +oam_strlen((char *)oam_prov_req.oam_igd_params.device_info_params.ManufacturerOUI);
    *msg_size+=sizeof(UInt32)
        +oam_strlen((char *)oam_prov_req.oam_igd_params.device_info_params.ProductClass);
    *msg_size+=sizeof(UInt32)
        +oam_strlen((char *)oam_prov_req.oam_igd_params.device_info_params.HardwareVersion);
    *msg_size+=sizeof(UInt32)	       
        +oam_strlen((char *)oam_prov_req.oam_igd_params.device_info_params.SoftwareVersion);
    *msg_size+=oam_strlen("ManufacturerOUI=")+oam_strlen("ProductClass=")+oam_strlen("HardwareVersion=")+oam_strlen("SoftwareVersion=");      	       
    *msg_size+= OAM_SEVEN*sizeof(UInt8); 

    if(OAM_FAILURE == oam_mem_alloc(*msg_size,(void*)&p_msg,&error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_msg failed"
                " with Error Code:%d",
                error_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_NULL;
    }

    oam_memset(p_msg,OAM_ZERO,*msg_size);

    p_payload = p_msg;

    oam_construct_api_header(p_payload,OAM_VERSION,OAM_MODULE_ID,OAM_SDM_MODULE_ID,
            OAM_SDM_REQUEST_UPGRADE_START,*msg_size);

    p_payload += OAM_CSPL_HDR_SIZE;

    oam_construct_mgmt_api_hdr(p_payload, trans_id, OAM_MODULE_ID,
            OAM_SDM_MODULE_ID,OAM_SDM_REQUEST_UPGRADE_START,
            /*SPR 17777 fix*/
            *msg_size-OAM_CSPL_HDR_SIZE, OAM_ZERO);

    p_payload = p_payload + OAM_MGMT_INTF_HEADER_SIZE;

    p_payload[OAM_ZERO]    =  (UInt8)(((UInt32 )resvd1) >> OAM_TWENTY_FOUR);
    p_payload[OAM_ONE]    =  (UInt8)(((UInt32 )resvd1) >> OAM_SIXTEEN);
    p_payload[OAM_TWO]    =  (UInt8)(((UInt32 )resvd1) >> OAM_EIGHT);
    p_payload[OAM_THREE]    =  (UInt8)(((UInt32 )resvd1));

    p_payload[OAM_FOUR]    =  (UInt8)(((UInt32 )file_type));

    p_payload[OAM_FIVE]    =  (UInt8)(((UInt32 )resvd2));
    p_payload[OAM_SIX]    =  (UInt8)(((UInt32 )resvd2)); 
    p_payload[OAM_SEVEN]    =  (UInt8)(((UInt32 )resvd3));

    p_payload[OAM_EIGHT]    =  (UInt8)(((UInt32 )file_size) >> OAM_TWENTY_FOUR);
    p_payload[OAM_NINE]    =  (UInt8)(((UInt32 )file_size) >> OAM_SIXTEEN);
    p_payload[OAM_TEN]    =  (UInt8)(((UInt32 )file_size) >> OAM_EIGHT);
    p_payload[OAM_ELEVEN]    =  (UInt8)(((UInt32 )file_size));

    p_payload[OAM_TWELVE]    =  (UInt8)(((UInt32 )file_name_len) >> OAM_EIGHT);
    p_payload[OAM_THIRTEEN]    =  (UInt8)(((UInt32 )file_name_len));

    p_payload[OAM_FOURTEEN]    =  (UInt8)(((UInt32 )resvd4) >> OAM_EIGHT);
    p_payload[OAM_FIFTEEN]    =  (UInt8)(((UInt32 )resvd4));

    oam_memcpy(p_payload + OAM_SIXTEEN,file_name,file_name_len);

    p_payload[OAM_SIXTEEN +file_name_len]    =  (UInt8)(((UInt32 )file_des_len));

    p_payload[OAM_SEVENTEEN +file_name_len]    =  (UInt8)(((UInt32 )resvd5));
    p_payload[OAM_EIGHTEEN +file_name_len]    =  (UInt8)(((UInt32 )resvd5)); 
    p_payload[OAM_NINTEEN +file_name_len]    =  (UInt8)(((UInt32 )resvd6));

    oam_memcpy(p_payload+ OAM_TWENTY +file_name_len,file_des,file_des_len);
    /*Add additional Device Info parametersi*/

    counter = OAM_TWENTY + file_name_len+file_des_len;  

    p_payload[counter++]= num_of_params;

    p_payload[counter++] =  (UInt8)(((UInt32 )resvd5));
    p_payload[counter++] =  (UInt8)(((UInt32 )resvd5));
    p_payload[counter++] =  (UInt8)(((UInt32 )resvd5));

    length = oam_strlen((char *)oam_prov_req.oam_igd_params.device_info_params.ManufacturerOUI)
        +oam_strlen("ManufacturerOUI="); 

    p_payload[counter++]=(UInt8)(((UInt32 )length) >> OAM_EIGHT);
    p_payload[counter++]=(UInt8)(((UInt32 )length));

    p_payload[counter++]    =  (UInt8)(((UInt32 )resvd6) >> OAM_EIGHT);
    p_payload[counter++]    =  (UInt8)(((UInt32 )resvd6));

    oam_strcpy((char *)oui,"ManufacturerOUI=");
    oam_strcat((char *)oui,(char *)oam_prov_req.oam_igd_params.device_info_params.ManufacturerOUI);
    oam_memcpy(&p_payload[counter],oui,length);
    counter += length;   

    length = oam_strlen((char *)oam_prov_req.oam_igd_params.device_info_params.ProductClass)
        +oam_strlen("ProductClass="); 


    p_payload[counter++]=(UInt8)(((UInt32 )length) >> OAM_EIGHT);
    p_payload[counter++]=(UInt8)(((UInt32 )length));

    p_payload[counter++]    =  (UInt8)(((UInt32 )resvd7) >> OAM_EIGHT);
    p_payload[counter++]    =  (UInt8)(((UInt32 )resvd7));

    oam_strcpy(product_class,"ProductClass="); 
    oam_strcat(product_class, (Char8*)oam_prov_req.oam_igd_params.
            device_info_params.ProductClass);
    oam_memcpy(&p_payload[counter],product_class,length);
    counter += length;

    length = oam_strlen((char *)oam_prov_req.oam_igd_params.device_info_params.HardwareVersion)
        +oam_strlen("HardwareVersion=");

    p_payload[counter++]=(UInt8)(((UInt32 )length) >> OAM_EIGHT);
    p_payload[counter++]=(UInt8)(((UInt32 )length));

    p_payload[counter++]    =  (UInt8)(((UInt32 )resvd8) >> OAM_EIGHT);
    p_payload[counter++]    =  (UInt8)(((UInt32 )resvd8));

    oam_strcpy((char *)hw_version,"HardwareVersion=");
    oam_strcat((char *)hw_version,(char *)oam_prov_req.oam_igd_params.device_info_params.HardwareVersion);

    oam_memcpy(&p_payload[counter],hw_version,length);
    counter += length;

    length = oam_strlen((char *)oam_prov_req.oam_igd_params.device_info_params.SoftwareVersion)
        +oam_strlen("SoftwareVersion=");

    p_payload[counter++]=(UInt8)(((UInt32 )length) >> OAM_EIGHT);
    p_payload[counter++]=(UInt8)(((UInt32 )length));

    p_payload[counter++]    =  (UInt8)(((UInt32 )resvd9) >> OAM_EIGHT);
    p_payload[counter++]    =  (UInt8)(((UInt32 )resvd9));

    oam_strcpy((char *)sw_version,"SoftwareVersion=");
    oam_strcat((char *)sw_version,(char *)oam_prov_req.oam_igd_params.device_info_params.SoftwareVersion);
    oam_memcpy(&p_payload[counter],sw_version,length);
    counter += length;

    OAM_FUN_EXIT_TRACE(); /* Coverity FIX 36180 */
    return p_msg;

}
/**************************************************************************
 *  Function Name  : oam_handle_sdm_polling_req 
 *  Description    : This function handles polling from SDM
 *  Inputs         : p_msg
 *  Output         : None
 *  Return         : OAM_SUCCESS/OAM_FAILURE 
 **************************************************************************/

oam_return_et
    oam_handle_sdm_polling_req
(
 char *p_msg
 )
{
    OAM_FUN_ENTRY_TRACE();

    oam_error_code_et *p_err = OAM_ZERO;
    UInt8 *p_buffer, *p_buf = OAM_NULL;
    UInt16 msg_size =OAM_ZERO;
    /* coverity 35897 */
    oam_error_code_et p_error_code = NO_ERROR;
    UInt32 counter = OAM_ZERO;
    UInt16 loop_counter = OAM_ZERO;

    UInt16 trans_id = OAM_ZERO;

    oam_is_sdm_alive  = OAM_TRUE;

    msg_size += OAM_CSPL_HDR_SIZE+OAM_MGMT_INTF_HEADER_SIZE;
    msg_size += sizeof(UInt32)+(g_oam_sim_t.max_no_process * sizeof(UInt16));
    trans_id = get_word_from_header((UInt8*)(p_msg) + OAM_ZERO);   

    if(OAM_FAILURE == oam_mem_alloc(msg_size,(void *)&p_buffer,&p_error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_buffer failed"
                " with Error Code:%d",
                p_error_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    oam_memset(p_buffer , OAM_ZERO , msg_size);

    p_buf = p_buffer;

    oam_construct_api_header(p_buf,OAM_VERSION,OAM_MODULE_ID,OAM_SDM_MODULE_ID,
            OAM_SDM_POLLING_RESP,msg_size);

    p_buf = p_buf + OAM_CSPL_HDR_SIZE;

    oam_construct_mgmt_api_hdr(p_buf, trans_id, OAM_MODULE_ID,
            OAM_SDM_MODULE_ID,OAM_SDM_POLLING_RESP,
            /*SPR 17777 fix*/
            msg_size-OAM_CSPL_HDR_SIZE, OAM_ZERO);

    /*Increment p_buf*/
    p_buf += OAM_MGMT_INTF_HEADER_SIZE;

    p_buf[counter] = g_oam_sim_t.max_no_process;
    counter+=sizeof(UInt8);

    /* Incrementing Counter For Reserved Field */
    counter+=sizeof(UInt8);
    counter+=sizeof(UInt8);
    counter+=sizeof(UInt8);

    for(loop_counter = OAM_ZERO;loop_counter<g_oam_sim_t.max_no_process;loop_counter++)
    {
        p_buf[counter]=(UInt8)(((UInt32)g_oam_sim_t.p_info[loop_counter].pid) >> OAM_EIGHT);
        counter+=sizeof(UInt8);
        p_buf[counter]=(UInt8)((UInt32)g_oam_sim_t.p_info[loop_counter].pid);
        counter+=sizeof(UInt8);
    }

    if(OAM_SUCCESS != oam_send_message(p_buffer,OAM_SDM_MODULE_ID,p_err)) 
    {
        OAM_LOG(OAM,OAM_ERROR,"Error in Sending Polling responce message to SDM");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}

/**************************************************************************
 *  Function Name : oam_check_file_integerity 
 *  Description   : This function used verify the checksum of file
 *  Inputs        : file_name
 *  Output        : None
 *  Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
oam_return_et
    oam_check_file_integerity
(
 UInt8 *file_name
 )
{
    UInt8 untar_cmd[INTEGRITY_CHK_CMD_SZ]={OAM_ZERO},sys_cmd[INTEGRITY_CHK_CMD_SZ]={OAM_ZERO};
    /* Bug 16507 Fix Start */   	
    /* UInt8 buff[INTEGRITY_CHK_BUF_SZ],buff2[INTEGRITY_CHK_BUF_SZ]; */
    UInt8 buff2[INTEGRITY_CHK_BUF_SZ];
    /* Bug 16507 Fix End */
    UInt16 file_name_length = OAM_ZERO;
    /* Bug 16507 Fix Start */
    /* FILE  *temp_checksum_ptr =OAM_NULL; */
    /* Bug 16507 Fix End */
    FILE  *checksum_ptr =OAM_NULL;
    UInt8 read_buf[INTEGRITY_CHK_BUF_SZ];   
    UInt8 *checksum = OAM_NULL;
    UInt8 *base_file_name =OAM_NULL;
    UInt8 temp_file_name[INTEGRITY_FILE_NAME_SZ]= {OAM_ZERO};
    OAM_FUN_ENTRY_TRACE();
    /*SPR 17008 Fixed Start*/
    oam_return_et ret_Val = OAM_FAILURE;
    /*SPR 17008 Fixed End */

    /* Extract tar file for integrity check */
    oam_snprintf((char *)untar_cmd,INTEGRITY_CHK_CMD_SZ,"tar -xvzf %s",file_name);
    oam_system((char *)untar_cmd);

    base_file_name = (UInt8 *)OAM_STRRCHR((char *)file_name,'/')+ OAM_ONE; /*extracting base file name from path */
    oam_strcpy((char *)temp_file_name,(char *)base_file_name);
    file_name_length = oam_strlen((char *)temp_file_name);
    temp_file_name[file_name_length - OAM_THREE]=OAM_ZERO; /* removing .gz extension from file name */
    /*SPR 17008 Fixed Start*/
    ret_Val  =  validate_download_file_name(temp_file_name);
    if(ret_Val == OAM_FAILURE){
        OAM_LOG (OAM,OAM_WARNING,"File name validation failed");
        /* Send Failure if validation failed */
        return OAM_FAILURE;

    }
    else{
        OAM_LOG (OAM,OAM_DETAILED,"File name validation successfully");
        /* Send Failure if validation failed */
    }
    /*SPR 17008 Fixed End*/

    checksum_ptr = oam_fopen("checksum.txt","r+");  /* open cheksum.txt file */
    if (checksum_ptr ==OAM_NULL)
    {
        OAM_LOG(OAM,OAM_WARNING,"Unable to opent file for checksum computation");
        OAM_FUN_EXIT_TRACE();

        return OAM_FAILURE;
    }
    /* Bug 16507 Fix Start */
    /*	temp_checksum_ptr = oam_fopen("temp_checksum.txt","w+"); */
    /*	if (temp_checksum_ptr ==OAM_NULL)
        {
        OAM_LOG(OAM,OAM_ERROR,"Unable to opent file for temp checksum computation");
        OAM_FUN_EXIT_TRACE();
        OAM_FCLOSE(checksum_ptr); 
        return OAM_FAILURE;
        } */
    /* Bug 16507 Fix End */
    while (OAM_FGETS((char *)read_buf,INTEGRITY_CHK_BUF_SZ,checksum_ptr))
    {
        OAM_LOG(OAM,OAM_DETAILED," %s",read_buf);
        if(snscanf((const char *)read_buf,sizeof(read_buf),"CHECKSUM=%s",buff2) > OAM_ZERO )
        {
            OAM_LOG(OAM,OAM_DETAILED,"Checksum Value read from checksum.txt = %s",buff2);
            break;
        }
    }
    /* Bug 16507 Fix Start */
    /* oam_snprintf((char *)sys_cmd,INTEGRITY_CHK_CMD_SZ,"md5sum %s > temp_checksum.txt",temp_file_name); */ 
    /* Bug 16507 Fix End */
    oam_system((char *)sys_cmd);

    /* Bug 16507 Fix Start */
    /* OAM_FGETS((char *)buff,INTEGRITY_CHK_BUF_SZ,temp_checksum_ptr);
       checksum = (UInt8 *)oam_strtok((char *)buff," ");   */ 
    /* Bug 16507 Fix End */
    checksum = (UInt8 *)oam_strtok((char *)buff2," ");
    OAM_LOG(OAM,OAM_DETAILED,"Checksum Value calculated from downloaded file = %s",checksum);

    OAM_FCLOSE(checksum_ptr);
    /* Bug 16507 Fix Start */
    /* OAM_FCLOSE(temp_checksum_ptr); */
    /* Bug 16507 Fix End  */

    oam_strcpy((char *)file_name,(char *)temp_file_name);

    /* Bug 16507 Fix Start */
    /*	if (STD_ERROR == oam_remove ("temp_checksum.txt"))
        {
        OAM_LOG (OAM,OAM_ERROR,"Error in Removing temporary checksum file");
        } */
    /* Bug 16507 Fix End */ 

    if (STD_ERROR == oam_remove ("checksum.txt"))
    {
        OAM_LOG (OAM,OAM_ERROR,"Error in Removing downloaded checksum file");
    }

    OAM_FUN_EXIT_TRACE();

    if(OAM_ZERO == (oam_strcmp((char *)checksum,(char *)buff2)))
    {
        OAM_LOG (OAM,OAM_DETAILED,"File integrity check is succesfull");
        /* Send Success if Checksum is matching */
        return OAM_SUCCESS;
    }
    else
    {    
        OAM_LOG (OAM,OAM_WARNING,"File integrity check failed");
        /* Send Failure if Checksum failed */  
        return OAM_FAILURE;
    }

}

/**************************************************************************
 *  Function Name : oam_alloc_n_copy_api_buf 
 *  Description   : This function used verify the checksum of file
 *  Inputs        : p_api_buf_dest,p_api_buf_src 
 *  Output        : None
 *  Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
oam_return_et
    oam_alloc_n_copy_api_buf
(
 void **p_p_api_buf_dest,
 void *p_api_buf_src
 )
{
    UInt16 length = OAM_ZERO;
    /* coverity 35894 */
    oam_error_code_et errorCode = NO_ERROR;

    if ((OAM_NULL == p_api_buf_src) || (OAM_NULL == *p_p_api_buf_dest))
    {
        return OAM_FAILURE;
    }

    length = get_word_from_header((UInt8 *)p_api_buf_src + OAM_SEVEN);

    if (OAM_FAILURE == oam_mem_alloc(length + OAM_TWO, p_p_api_buf_dest, &errorCode))
    {
        return OAM_FAILURE;
    }

    oam_memcpy(*p_p_api_buf_dest, p_api_buf_src, length);

    return OAM_SUCCESS;

}
/**************************************************************************
 *  Function Name : oam_send_sdm_ack_upgrade_start 
 *  Description   : This function used verify the checksum of file
 *  Inputs        : None 
 *  Output        : None
 *  Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
    oam_return_et
oam_send_sdm_ack_upgrade_start(void)
{
    UInt8 *p_sdm_buf= OAM_NULL;
    OAM_FUN_ENTRY_TRACE();
    /* coverity 35897 */
    oam_error_code_et p_error_code = NO_ERROR;
    UInt16 trans_id = oam_get_new_trans_id();
    UInt16 msg_size = OAM_CSPL_HDR_SIZE+OAM_HEADER_SIZE;

    /*Send ACK to SDM for indicating that all layers are killed and now OAM should be killed by SDM */
    /*This message contains Header Information only and No Payload */
    /*Allocate memory to p_sdm_buf*/ 
    if(OAM_FAILURE == oam_mem_alloc(msg_size,(void *)&p_sdm_buf,&p_error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_sdm_buf failed"
                " with Error Code:%d",
                p_error_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    oam_memset(p_sdm_buf,OAM_ZERO,msg_size);

    oam_construct_api_header(p_sdm_buf,OAM_VERSION,OAM_MODULE_ID,OAM_SDM_MODULE_ID,
            OAM_SDM_ACK_UPGRADE_START,msg_size);
    /*SPR 17777 fix*/
    oam_construct_mgmt_api_hdr(p_sdm_buf+OAM_CSPL_HDR_SIZE,trans_id,OAM_MODULE_ID,
            OAM_SDM_MODULE_ID,OAM_SDM_ACK_UPGRADE_START,OAM_HEADER_SIZE,OAM_ZERO);

    /*Send ACK message to SDM */ 
    if(OAM_SUCCESS == oam_send_message(p_sdm_buf,OAM_SDM_MODULE_ID,&p_error_code)) 
    {
        OAM_LOG(OAM,OAM_INFO,"Sending ACK message to SDM for OAM Shutdown");
    }
    else
    {
        OAM_LOG(OAM,OAM_ERROR,"Error in Sending ACK message to SDM.");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;

}

#ifdef OAM_SON_ENABLE
/**************************************************************************
 *  Function Name : oam_save_params_in_dom 
 *  Description   : This function used verify the checksum of file
 *  Inputs        : None 
 *  Output        : None
 *  Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
/* + SPR 17439 */
oam_return_et oam_save_params_in_dom(void)
{
    /* - SPR 17439 */
    oam_counter_t loop = OAM_ZERO;    
    oam_return_et validate_return = OAM_FAILURE;
    UInt16 max_element = oam_find_global_table_size(g_parameter_map_element);
    Char8 temp_string_element[OAM_MAX_STR_LEN] = "";

    xmlNode *p_orig_parent = OAM_NULL;
    xmlNode *p_req_parent = OAM_NULL;
    xmlNode **p_p_xml_struct_addr = OAM_NULL;
    OAM_FUN_ENTRY_TRACE();
    /*Loop through the parameter database */
    for(loop= OAM_ZERO;loop < max_element; loop++)
    {
        switch(g_parameter_map_element[loop].parameter_type)
        {
            case UINT8_TYPE:
            {
                oam_snprintf(temp_string_element, sizeof(temp_string_element),"%d",
                        *(UInt8*)g_parameter_map_element[loop].param_base_addr);
            }
            break;
            case UINT16_TYPE:
            {
                oam_snprintf(temp_string_element,sizeof(temp_string_element), "%d",
                        *(UInt16*)g_parameter_map_element[loop].param_base_addr);
            }
            break;
            case UINT32_TYPE:
            {
                oam_snprintf(temp_string_element,sizeof(temp_string_element),  "%d",
                        *(UInt32*)g_parameter_map_element[loop].param_base_addr);
            }
            break;
            case ASCII_STRING_TYPE:
            {
                oam_strncpy(temp_string_element, 
                        (Char8*)g_parameter_map_element[loop].param_base_addr, (OAM_MAX_STR_LEN-OAM_ONE));
            }
            break;
            case SINT8_TYPE:
            {
                oam_snprintf(temp_string_element,sizeof(temp_string_element), "%d",
                        *(SInt8*)g_parameter_map_element[loop].param_base_addr);
            }
            break;
            case SINT16_TYPE:
            {
                oam_snprintf(temp_string_element,sizeof(temp_string_element), "%d",
                        *(SInt16*)g_parameter_map_element[loop].param_base_addr);
            }
            break;
        }

        if (!(g_parameter_map_element[loop].parameter_mode &
                    OAM_IGNORE_VALIDATION)) {
            validate_return = 
                oam_validate_one_element(loop, (UInt8*)temp_string_element,
                        &p_orig_parent, &p_req_parent,
                        /* SPR 18930  FIX START  */
                        &p_p_xml_struct_addr, OAM_ONE, oam_prov_req.cell_cntxt.curr_cell_cid);
            /* SPR 18930  FIX END  */
        }
        else {
            OAM_LOG(OAM, OAM_INFO, "Ignoring schema validation of %s",
                    g_parameter_map_element[loop].parameter_name);
            validate_return = OAM_SUCCESS;
        }

        if (OAM_FAILURE == validate_return) {
            OAM_LOG(OAM, OAM_WARNING, "Validation of parameter %s failed",
                    g_parameter_map_element[loop].parameter_name);
            break;
        }
    }

    if (OAM_SUCCESS == validate_return) {
        OAM_LOG(OAM, OAM_INFO, "Updating xml tree");
        oam_update_xml_dom(OAM_SUCCESS, p_orig_parent,
                p_req_parent,
                p_p_xml_struct_addr);
    }

    OAM_FUN_EXIT_TRACE();
    return validate_return;
}

/*SPR_16048 Fix Start*/
/**************************************************************************
 *  Function Name : oam_add_new_cell_nodes 
 *  Description   : For adding new cell node
 *  Inputs        : p_start_node,start_index 
 *  Output        : None
 *  Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
void 
    oam_add_new_cell_nodes
(
 xmlNode* p_start_node, 
 UInt16 start_index
 )
{
    UInt16 node_counter = start_index;
    UInt16 plmnid_counter = OAM_ZERO;
    xmlNode* p_current_node = p_start_node;
    xmlNode* p_cell_node = OAM_NULL;
    xmlNode* p_rf_node = OAM_NULL;
    xmlNode* p_bcch_node = OAM_NULL;
    xmlNode* p_plmn_list_node = OAM_NULL;
    Char8 temp_str[OAM_MAX_STR_LEN] = "";
    OAM_FUN_ENTRY_TRACE();

    for(;node_counter < oam_prov_req.oam_igd_params.nw_scan_status.num_cell_entry;
            node_counter++)
    {
        p_cell_node = xmlNewChild((xmlNode *)(p_current_node), 
                OAM_NULL, (xmlChar *)"Cell", (xmlChar *)OAM_NULL);
        p_rf_node = xmlNewChild((xmlNode *)(p_cell_node),
                OAM_NULL, (xmlChar *)"RF", (xmlChar *)OAM_NULL);
        p_bcch_node = xmlNewChild((xmlNode *)(p_cell_node),
                OAM_NULL, (xmlChar *)"BCCH", (xmlChar *)OAM_NULL);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].carrier_earfcn);
        xmlNewChild((xmlNode *)(p_rf_node),OAM_NULL, (xmlChar *)"EUTRACarrierARFCN", 
                (xmlChar *)&temp_str);
        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].rssi);
        xmlNewChild((xmlNode *)(p_rf_node),OAM_NULL, (xmlChar *)"RSSI",
                (xmlChar *)&temp_str); 

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].phy_cell_id);
        xmlNewChild((xmlNode *)(p_rf_node),NULL, (xmlChar *)"PhyCellID",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].rsrp);
        xmlNewChild((xmlNode *)(p_rf_node),OAM_NULL, (xmlChar *)"RSRP",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].rsrq);
        xmlNewChild((xmlNode *)(p_rf_node),OAM_NULL, (xmlChar *)"RSRQ",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.dl_bandwidth);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"DLBandwidth",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.ul_bandwidth);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"ULBandwidth",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.rx_tx_power);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"RSTxPower",
                (xmlChar *)&temp_str);


        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.tac);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"TAC",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.cell_identity);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"CellID",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.csg_identity);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"CSGIdentity",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.cell_barred);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"CellBarred",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.csg_indication);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"CSGIndication",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str),"%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.max_plmn_entry);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"MaxPLMNListEntries",
                (xmlChar *)&temp_str);

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str, sizeof(temp_str),"%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.num_plm_entry);
        xmlNewChild((xmlNode *)(p_bcch_node),OAM_NULL, (xmlChar *)"PLMNListNumberOfEntries",
                (xmlChar *)&temp_str);

        for(plmnid_counter = OAM_ZERO; plmnid_counter < oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.num_plm_entry;
                plmnid_counter++)
        {
            p_plmn_list_node = xmlNewChild((xmlNode *)(p_bcch_node),
                    OAM_NULL, (xmlChar *)"PLMNList", (xmlChar *)OAM_NULL);
            xmlNewChild((xmlNode *)(p_plmn_list_node),OAM_NULL, (xmlChar *)"PLMNID",
                    (xmlChar *)oam_prov_req.oam_son_req.
                    oam_nw_scan_result.oam_cell_discover[node_counter].oam_bcch_data.
                    oam_plmn_list[plmnid_counter].plmnid);
            oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
            oam_snprintf(temp_str,sizeof(temp_str), "%d", plmnid_counter); 
            xmlNewChild((xmlNode *)(p_plmn_list_node),OAM_NULL, (xmlChar *)"X_VENDOR_INSTANCE_ID", 
                    (xmlChar *)&temp_str);
            p_plmn_list_node = OAM_NULL;
        }

        oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
        oam_snprintf(temp_str,sizeof(temp_str), "%d", node_counter); 
        xmlNewChild((xmlNode *)(p_cell_node),OAM_NULL, (xmlChar *)"X_VENDOR_INSTANCE_ID", 
                (xmlChar *)&temp_str);
    }

    OAM_FUN_EXIT_TRACE();
    return;
}
/*SPR_16048 Fix End*/

/**************************************************************************
 *  Function Name : oam_update_cell_node 
 *  Description   : For update cell node
 *  Inputs        : p_node,index 
 *  Output        : None
 *  Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
oam_return_et 
    oam_update_cell_node
(
 xmlNode* p_node, UInt16 index
 )
{
    UInt16 plmnid_counter = OAM_ZERO;
    OAM_FUN_ENTRY_TRACE();
    Char8 temp_str[OAM_MAX_STR_LEN] = "";
    xmlNode* p_rf_node = OAM_NULL;
    xmlNode* p_bcch_node = OAM_NULL;
    xmlNode* p_plmn_list_node = OAM_NULL;
    xmlNode* p_temp_node = OAM_NULL;
    oam_return_et validate_return = OAM_SUCCESS;
    /*finding pointer to node*/

    p_rf_node = oam_xml_find_tag((xmlNode *) p_node, (xmlChar *)"RF");
    if (OAM_NULL == p_rf_node)
    {
        validate_return = OAM_FAILURE;
        OAM_LOG(OAM, OAM_WARNING, "Tag RF Not found in existing cell entry!!");
    }
    else
    {

        p_temp_node = oam_xml_find_tag((xmlNode *) p_rf_node->children, (xmlChar *)"EUTRACarrierARFCN");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag EUTRACarrierARFCN Not found in existing cell.RF entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].carrier_earfcn);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);

        p_temp_node = oam_xml_find_tag((xmlNode *) p_rf_node->children, (xmlChar *)"RSSI");
        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag RSSI Not found in existing cell.RF entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str),"%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].rssi);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);

        p_temp_node = oam_xml_find_tag((xmlNode *) p_rf_node->children, (xmlChar *)"PhyCellID");
        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag PhyCellID Not found in existing cell.RF entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].phy_cell_id);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);

        p_temp_node = oam_xml_find_tag((xmlNode *) p_rf_node->children, (xmlChar *)"RSRP");
        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag RSRP Not found in existing cell.RF entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].rsrp);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);

        p_temp_node = oam_xml_find_tag((xmlNode *) p_rf_node->children, (xmlChar *)"RSRQ");
        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag RSRQ Not found in existing cell.RF entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].rsrq);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);
    }

    p_bcch_node = oam_xml_find_tag((xmlNode *) p_node, (xmlChar *)"BCCH");
    if (OAM_NULL == p_bcch_node)
    {
        validate_return = OAM_FAILURE;
        OAM_LOG(OAM, OAM_WARNING, "Tag BCCH Not found in existing cell entry!!");
    }
    else
    {

        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"DLBandwidth");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag DLBandwidth Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.dl_bandwidth);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);


        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"ULBandwidth");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag ULBandwidth Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.ul_bandwidth);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);


        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"RSTxPower");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag RSTxPower Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.rx_tx_power);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);



        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"TAC");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag TAC Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.tac);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);



        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"CellID");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag CellID Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str, sizeof(temp_str),"%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.cell_identity);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);



        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"CSGIdentity");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag CSGIdentity Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.csg_identity);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);



        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"CellBarred");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag CellBarred Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str),"%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.cell_barred);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);



        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"CSGIndication");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag CSGIndication Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str, sizeof(temp_str),"%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.csg_indication);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);



        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"MaxPLMNListEntries");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag MaxPLMNListEntries Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str, sizeof(temp_str),"%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.max_plmn_entry);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);


        p_temp_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"PLMNListNumberOfEntries");

        if (OAM_NULL == p_temp_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag PLMNListNumberOfEntries Not found in existing cell.bcch entry!!");
        }

        oam_snprintf(temp_str,sizeof(temp_str), "%d", oam_prov_req.oam_son_req.
                oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.num_plm_entry);
        xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
        oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);

        p_plmn_list_node = oam_xml_find_tag((xmlNode *) p_bcch_node->children, (xmlChar *)"PLMNList");
        if (OAM_NULL == p_plmn_list_node)
        {
            validate_return = OAM_FAILURE;
            OAM_LOG(OAM, OAM_WARNING, "Tag PLMNList Not found in existing cell entry!!");
        }
        else
        {

            while((p_plmn_list_node != OAM_NULL) &&( plmnid_counter < oam_prov_req.oam_son_req.
                        oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.num_plm_entry))
            {

                p_temp_node = oam_xml_find_tag((xmlNode *)p_plmn_list_node->children , (xmlChar *)"PLMNID");

                if (OAM_NULL == p_temp_node)
                {
                    validate_return = OAM_FAILURE;
                    OAM_LOG(OAM, OAM_WARNING, "Tag PLMNID Not found in existing cell.bcch entry!!");
                }
                /*SPR_16048 Fix Start*/
                snprintf(temp_str, OAM_MAX_STR_LEN, "%s",
                        oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.oam_plmn_list[plmnid_counter].plmnid);

                /*SPR_16048 Fix End*/

                xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
                oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);
                /*SPR_16048 Fix Start*/
                p_temp_node = oam_xml_find_tag((xmlNode *)p_plmn_list_node->children , (xmlChar *)"CellReservedForOperatorUse");

                if (OAM_NULL == p_temp_node)
                {
                    validate_return = OAM_FAILURE;
                    OAM_LOG(OAM, OAM_WARNING, "Tag CellReservedForOperatorUse Not found in existing cell.bcch entry!!");
                }
                oam_memset(temp_str, OAM_ZERO, OAM_MAX_STR_LEN);
                snprintf(temp_str, OAM_MAX_STR_LEN, "%d",oam_prov_req.oam_son_req.oam_nw_scan_result.oam_cell_discover[index].oam_bcch_data.
                        oam_plmn_list[plmnid_counter].cell_reserver_for_operator_use);

                xmlNodeSetContent(p_temp_node,(xmlChar*)temp_str);
                oam_memset(temp_str,OAM_ZERO,OAM_MAX_STR_LEN);
                /*SPR_16048 Fix End*/

                p_plmn_list_node = p_plmn_list_node->next;
                plmnid_counter++;

            }
        }


    }

    OAM_FUN_EXIT_TRACE();
    return validate_return;
}

/**************************************************************************
 *  Function Name : oam_save_nw_scan_results_rf_bcch_params_in_dom 
 *  Description   : For save new scan results of rf bcch parameters 
 *  Inputs        : p_node,index 
 *  Output        : None
 *  Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
/* + SPR 17439 */
    oam_return_et 
oam_save_nw_scan_results_rf_bcch_params_in_dom(void)
{
    /* - SPR 17439 */
    oam_return_et validate_return = (oam_return_et)OAM_SUCCESS;
    xmlNode *p_temp_node = OAM_NULL;
    xmlNode *p_current_node = OAM_NULL;
    UInt16 node_counter = OAM_ZERO;
    /*SPR_16048 Fix Start*/
    xmlNode *p_local = OAM_NULL;
    /*SPR_16048 Fix End*/
    OAM_FUN_ENTRY_TRACE();
    /*+ SPR 18391*/
    /* spr_21013_fix_start */
    p_current_node = xml_struct_tr196_g.FAPService[OAM_ZERO].LTE_5;
    /* spr_21013_fix_end */
    g_parameter_map_element = &g_parameter_son_nw_scan_results_rf[OAM_ZERO];

    if(p_current_node)
        p_temp_node = oam_xml_find_tag(p_current_node->children, (UInt8*)"Cell");

    for(node_counter = 0;node_counter < oam_prov_req.oam_igd_params.nw_scan_status.num_cell_entry;
            node_counter++ )
    {
        if(OAM_NULL == p_temp_node)
        {
            oam_add_new_cell_nodes(p_current_node, node_counter);
            break;
        }
        else
        {
            validate_return = oam_update_cell_node(p_temp_node->children, node_counter);
            if (OAM_FAILURE == validate_return)
            {
                OAM_LOG(OAM, OAM_WARNING, "Failed to update node in dom tree!!");
                break;
            }
        }
        p_temp_node = p_temp_node->next;
        /*- SPR 18391*/
    }


    /*SPR_16048 Fix Start*/
    while(p_temp_node)
    {
        p_local = p_temp_node->next;
        xmlUnlinkNode((xmlNode *)(p_temp_node));
        xmlFreeNode((xmlNode *)(p_temp_node));
        /* Move to next instance of object */
        p_temp_node = p_local;
    }

    /* Update  Dom*/
    UInt8 count = OAM_ZERO;
    /* spr_21013_fix_start */
    xmlNode *p_node = xml_struct_tr196_g.FAPService[OAM_ZERO].Cell[OAM_ZERO];
    for(count= OAM_ZERO ; (( count < oam_prov_req.oam_igd_params.nw_scan_status.num_cell_entry) &&
                (OAM_NULL != (xmlNode*)p_node)); count++)
    {
        xml_struct_tr196_g.FAPService[OAM_ZERO].Cell[count] = (xmlNode*)p_node;
        p_node = (((xmlNode *)p_node)->next);
    }
    if(OAM_ZERO == count)
    {
        xml_struct_tr196_g.FAPService[OAM_ZERO].Cell[OAM_ZERO] = OAM_NULL;
        /* spr_21013_fix_end */
    }

    /*SPR_16048 Fix End*/

    OAM_FUN_EXIT_TRACE();
    return validate_return;

}


/**************************************************************************
 *  Function Name : oam_save_nw_scan_results_in_dom 
 *  Description   : For save new scan results of parameters 
 *  Inputs        : None 
 *  Output        : None
 *  Return        : OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
/* + SPR 17439 */
oam_return_et oam_save_nw_scan_results_in_dom(void)
{
    /* - SPR 17439 */
    /* save scan status params */
    oam_return_et validate_return = OAM_FAILURE;
    OAM_FUN_ENTRY_TRACE();

    g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO];
    validate_return = oam_save_params_in_dom();
    if (OAM_SUCCESS != validate_return)
    {
        OAM_LOG(OAM, OAM_WARNING, "oam_save_params_in_dom returned failure for "
                "son_nw_scan_status parameters!!");
    }

    validate_return =  oam_save_nw_scan_results_rf_bcch_params_in_dom(); 
    if (OAM_SUCCESS != validate_return)
    {
        OAM_LOG(OAM, OAM_WARNING, "oam_save_nw_scan_results_rf_bcch_params_in_dom"
                " returned failure for son_nw_scan_results_rf parameters!!");
    }
    /* Ensure persistence of parameters */
    oam_maintain_parameter_persistence();

    OAM_FUN_EXIT_TRACE();
    return validate_return;
}
#endif
/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_x2ap_prov
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   X2AP_PROVISION_INFO is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_x2ap_prov
(
 int loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);

    local_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.bitmask |= RRC_X2AP_PROVISION_INFO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_s1ap_sctp_conf_param 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SCTP_CONF_INFO is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_s1ap_sctp_conf_param
(
 int loop,
 void *p_cell_reconfig_req
 )   
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, p_cell_reconfig_req);

    local_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.bitmask |= S1AP_OAM_SCTP_CONF_INFO_PRESENT ;

    OAM_FUN_EXIT_TRACE();
}
#ifdef OAM_SON_ENABLE
/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_intra_rat_cm_cio 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_CM_CELL_OFFSET is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_intra_rat_cm_cio
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_CM_CELL_OFFSET_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_intra_rat_broadcast_status 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_BROADCAST_STATUS is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_intra_rat_broadcast_status
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_BROADCAST_STATUS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_intra_rat_access_mode 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_ACCESS_MODE is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_intra_rat_access_mode
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_ACCESS_MODE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_intra_rat_root_sequence_index 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_PRACH_CONFIGURATION_PRESENT is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_intra_rat_root_sequence_index 
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_intra_rat_zero_correlation_zone_config 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_PRACH_CONFIGURATION_PRESENT is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_intra_rat_zero_correlation_zone_config
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_intra_rat_high_speed_flag
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_PRACH_CONFIGURATION_PRESENT is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_intra_rat_high_speed_flag 
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
    UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_intra_rat_prach_frequency_offset 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_PRACH_CONFIGURATION_PRESENT is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_intra_rat_prach_frequency_offset
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_req = p_son_nr_add_req;
    UInt8 idx = p_req->nr_list_query_idx;

    p_req->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_PRACH_CONFIGURATION_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_intra_rat_prach_configuration_index 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_PRACH_CONFIG_INDEX_PRESENT is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_intra_rat_prach_configuration_index
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_req = p_son_nr_add_req;
    UInt8 idx = p_req->nr_list_query_idx;

    p_req->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].
        bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
    p_req->oam_son_nr_add_req.nr_list.intra_rat_nr_list[idx].prach_config.
        bitmask |= SON_PRACH_CONFIG_INDEX_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_inter_rat_access_mode 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_UTRAN_ACCESS_MODE is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_inter_rat_access_mode
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_req = p_son_nr_add_req;
    UInt8 idx = p_req->nr_list_query_idx;

    p_req->oam_son_nr_add_req.nr_list.inter_rat_nr_list[idx].
        utran_neighbor.bitmask |= SON_UTRAN_ACCESS_MODE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_inter_rat_ps_ho_supported 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_UTRAN_PS_HO_SUPPORTED is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_inter_rat_ps_ho_supported
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_req = p_son_nr_add_req;
    UInt8 idx = p_req->nr_list_query_idx;

    p_req->oam_son_nr_add_req.nr_list.inter_rat_nr_list[idx].
        utran_neighbor.bitmask |= SON_UTRAN_PS_HO_SUPPORT_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_inter_rat_voip_capable 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SON_UTRAN_VOIP_CAPABLE is present.
 * *   Inputs        : loop : loop value for future reference
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
    void set_bitmask_add_req_inter_rat_voip_capable
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_cell_neighbourlist_info_t *p_req = p_son_nr_add_req;
    UInt8 idx = p_req->nr_list_query_idx;

    p_req->oam_son_nr_add_req.nr_list.inter_rat_nr_list[idx].
        utran_neighbor.bitmask |= SON_UTRAN_VOIP_CAPABLE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

#endif

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_connected_mode_mob_common_params_for_eutra 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   COMMON_PARAMS_FOR_EUTRA is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_connected_mode_mob_common_params_for_eutra
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_connected_mode_mob(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.bitmask |= 
        RRM_OAM_COMMON_PARAMS_FOR_EUTRA_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_mobility_params 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   MOBILITY_LAYER_PARAMS is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_mobility_params
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_idle_mode_mobility_params 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   IDLE_MODE_MOBILITY_PARAMS is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_idle_mode_mobility_params
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_ran_info(loop, p_cell_reconfig_req);
    set_bitmask_mobility_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.bitmask |= RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: set_bitmask_idle_mode_common_params
 *   DESCRIPTION:
 *      This function will check for validation of parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 ******************************************************************************/
void
    set_bitmask_idle_mode_common_params
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.bitmask |=
        RRM_OAM_IDLE_MODE_MOBILITY_COMMON_PARAMS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_common_param_speed_state_params 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   SPEED_STATE_PARAMS is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_common_param_speed_state_params
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_idle_mode_mobility_params(loop, p_cell_reconfig_req);
    set_bitmask_idle_mode_common_params(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.mobility_params.idle_mode_mobility_params.
        idle_mode_mobility_common_params.bitmask |= RRM_OAM_SPEED_STATE_PARAMS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_irat_meas_quant_utra_fdd 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   MEAS_QUANUTRA_FDD is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_irat_meas_quant_utra_fdd
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= 
        RRM_OAM_MEAS_QUANUTRA_FDD_PRESENT;
}
/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_irat_meas_quant_utra_tdd 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   MEAS_QUANUTRA_TDD is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_irat_meas_quant_utra_tdd
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= 
        RRM_OAM_MEAS_QUANUTRA_TDD_PRESENT;
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_irat_q_offset_cdma2000 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                    Q_OFFSET_CDMA is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_irat_q_offset_cdma2000
(
 int                          loop,
 void  *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= 
        RRM_OAM_Q_OFFSET_CDMA_PRESENT;
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_irat_meas_quan_cdma2000 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   MEAS_QUANTITY_CDMA2000 is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_irat_meas_quan_cdma2000
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= 
        RRM_OAM_MEAS_QUANTITY_CDMA2000_PRESENT;
}

/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_add_req_inter_rat_access_mode 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   B1_THRESHOLD_CDMA2000 is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_irat_b1_thresh_cdma2000
(
 int                          loop,
 void *p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_connected_mode_irat(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.connected_mode_mobility_params.irat.bitmask |= 
        /*OAM_REVIEW_CHANGES*/
        RRM_OAM_B1_THRESHOLD_CDMA2000_PRESENT;
    /*OAM_REVIEW_CHANGES*/
}

/*OAM_REVIEW_CHANGES*/
/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_ran_info_rf_params_ul_bw 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   RF_CONFIGURATION_UL_BW is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_ran_info_rf_params_ul_bw
(
 int                          loop,
 void *p_cell_reconfig_req	
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_RAN_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_RF_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.rf_params.rf_configurations.bitmask |= 
        RRM_OAM_RF_CONFIGURATION_UL_BW_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/*OAM_REVIEW_CHANGES*/
/******************************************************************************
 * *   FUNCTION NAME : set_bitmask_ran_info_s1ap_params 
 * *   DESCRIPTION   : This function will set bitmask to indicate that 
 * *                   S1AP_PARAMS is present.
 * *   Inputs        : loop : loop value for future reference
 * *                   p_cell_reconfig_req : pointer to cell_reconfig req  
 * *   Output        : NONE
 * *   RETURNS       : NONE 
 ******************************************************************************/
void
    set_bitmask_ran_info_s1ap_params
(
 int                          loop,
 void *p_cell_reconfig_req	
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_RAN_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_S1AP_PARAMS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: oam_log_load_config_info
 *  DESCRIPTION  : This function will check for oam log load config info
 *  Inputs       : load_info
 *  Output       : none
 *  RETURNS      : none
 * ******************************************************************************/
#ifndef OAM_SON_ENABLE
void oam_log_load_config_info(rrm_cell_load_info_t *load_info)
{
    UInt8 str[LOAD_CONFIG_INFOSTR_SIZE];
    UInt8 temp_str[LOAD_CONFIG_INFOSTR_SIZE];

    oam_strcpy((char*)str, "Mcc::");
    oam_sprintf((char*)temp_str, "%d%d%d", load_info->g_cell_id.primary_plmn_id.mcc[OAM_ZERO], load_info->g_cell_id.primary_plmn_id.mcc[OAM_ONE],
            load_info->g_cell_id.primary_plmn_id.mcc[OAM_TWO]);
    oam_strncat((char*)str, (char*)temp_str, MAX_MCC_DIGITS);

    oam_strcat((char*)str, " Mnc::");
    oam_sprintf((char*)temp_str, "%d%d%d", load_info->g_cell_id.primary_plmn_id.mnc[OAM_ZERO], load_info->g_cell_id.primary_plmn_id.mnc[OAM_ONE],
            load_info->g_cell_id.primary_plmn_id.mnc[OAM_TWO]);
    oam_strncat((char*)str, (char*)temp_str, load_info->g_cell_id.primary_plmn_id.num_mnc_digit);
    oam_strcat((char*)str, " CellId::");
    oam_sprintf((char*)temp_str, "%d%d%d%d", load_info->g_cell_id.cell_identity[OAM_ZERO], load_info->g_cell_id.cell_identity[OAM_ONE], 
            load_info->g_cell_id.cell_identity[OAM_TWO], load_info->g_cell_id.cell_identity[OAM_THREE]);
    oam_strncat((char*)str,(char*)temp_str, MAX_CELL_IDENTITY_OCTETS);

    OAM_LOG(OAM,OAM_DETAILED, "%s", str);

    if (RRM_OAM_HW_LOAD_PRESENT == (RRM_OAM_HW_LOAD_PRESENT & load_info->bitmask))
    {
        OAM_LOG(OAM,OAM_DETAILED, "Hardware Load Level DL::%d, Hardware Load Level UL::%d", load_info->hw_load.dl, load_info->hw_load.ul);
    }
    if (RRM_OAM_S1_TNL_LOAD_PRESENT == (RRM_OAM_S1_TNL_LOAD_PRESENT & load_info->bitmask))
    {
        OAM_LOG(OAM,OAM_DETAILED, "S1 TNL Load Level DL::%d, S1 TNL Load Level UL::%d", 
                load_info->s1_tnl_load.dl, load_info->s1_tnl_load.ul);
    }
    if (RRM_OAM_RRS_LOAD_PRESENT == (RRM_OAM_RRS_LOAD_PRESENT & load_info->bitmask))
    { 
        OAM_LOG(OAM,OAM_DETAILED, "RRS Load Gbr Prb Usage in DL::%d, RRS Load Gbr Prb Usage in UL::%d, RRS Load Non Gbr Prb Usage in DL::%d, RRS Load Non Gbr Prb Usage in UL::%d, RRS Load Total PRB Usage DL::%d,  RRS Load Total PRB Usage UL::%d", 
                load_info->rrs.dl_gbr_prb_usage,load_info->rrs.ul_gbr_prb_usage,
                load_info->rrs.dl_non_gbr_prb_usage,load_info->rrs.ul_non_gbr_prb_usage,
                load_info->rrs.dl_total_prb_usage,load_info->rrs.ul_total_prb_usage);
    }
    if(RRM_OAM_COMP_LOAD_PRESENT == (RRM_OAM_COMP_LOAD_PRESENT & load_info->bitmask))
    {
        OAM_LOG(OAM,OAM_DETAILED, "Load Capacity in DL::%d, Load Capacity in UL::%d", 
                load_info->comp_avl_cap_grp.dl_comp_avl_cap.cap_val,
                load_info->comp_avl_cap_grp.ul_comp_avl_cap.cap_val);
        if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT == 
                (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & load_info->comp_avl_cap_grp.dl_comp_avl_cap.bitmask))
        {
            OAM_LOG(OAM,OAM_DETAILED, "Load Capacity Class Value in DL::%d, Load Capacity Class Value in UL::%d", 
                    load_info->comp_avl_cap_grp.dl_comp_avl_cap.cell_cap_class_val,
                    load_info->comp_avl_cap_grp.ul_comp_avl_cap.cell_cap_class_val);
        }
    }
}
#endif

#ifdef OAM_SON_ENABLE
/******************************************************************************
 *  FUNCTION NAME: oam_son_fill_earfcn_array
 *  DESCRIPTION:
 *      This function fills the earfcn array using start_value and 
 *      num_earfcn values
 *  Inputs       : p_earfcn_array, start_value, num_earfcn 
 *  Output       : p_earfcn_array 
 *  RETURNS: num_earfcn - number of earfcns generated
 ******************************************************************************/

UInt16 oam_son_fill_earfcn_array
(
 /* Start: CSR 00053250 */
 son_meas_bandwidth_pci_per_earfcn_t *p_earfcn_array,
 /*End: CSR 00053250 end */ 
 UInt16 start_value,
 UInt16 num_earfcn
 )
{
    UInt16 earfcn_count  = OAM_ZERO;

    OAM_FUN_ENTRY_TRACE();

    for (earfcn_count  = OAM_ZERO; (earfcn_count < num_earfcn); earfcn_count++)
    {
        p_earfcn_array[earfcn_count].earfcn = start_value + earfcn_count;
        if(OAM_SON_MAX_VALUE_EARFCN == p_earfcn_array[earfcn_count].earfcn)
        {
            OAM_LOG(OAM, OAM_DETAILED, "EARFCN Values truncated!!");
            break;
        }
        p_earfcn_array[earfcn_count].meas_bandwidth_for_earfcn =
            OAM_SON_NW_SCAN_MEAS_BW_VALUE;
    }

    OAM_FUN_EXIT_TRACE();
    return earfcn_count;
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_eutran_gap_offset_gp0 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
    void set_bitmask_son_anr_eutran_gap_offset_gp0
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;

    p_son_req->oam_son_anr_meas_config_req.
        bitmask |= SON_ANR_MEAS_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.
        bitmask |= SON_ANR_EUTRAN_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.eutran_gap_config.
        bitmask |= SON_ANR_SETUP_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.eutran_gap_config.
        setup_gap_config.bitmask |= SON_ANR_GAP_OFFSET_GP0_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * Function Name : set_bitmask_son_anr_eutran_gap_offset_gp1
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
    void set_bitmask_son_anr_eutran_gap_offset_gp1
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;

    p_son_req->oam_son_anr_meas_config_req.
        bitmask |= SON_ANR_MEAS_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.
        bitmask |= SON_ANR_EUTRAN_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.eutran_gap_config.
        bitmask |= SON_ANR_SETUP_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.eutran_gap_config.
        setup_gap_config.bitmask |= SON_ANR_GAP_OFFSET_GP1_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 * Function Name : set_bitmask_son_anr_utran_gap_offset_gp0 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/

    void set_bitmask_son_anr_utran_gap_offset_gp0
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;

    p_son_req->oam_son_anr_meas_config_req.
        bitmask |= SON_ANR_MEAS_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.
        bitmask |= SON_ANR_UTRAN_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.
        utran_gap_config.bitmask |= SON_ANR_SETUP_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.
        utran_gap_config.setup_gap_config.
        bitmask |= SON_ANR_GAP_OFFSET_GP0_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name : set_bitmask_son_anr_utran_gap_offset_gp1
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ******************************************************************************/
    void set_bitmask_son_anr_utran_gap_offset_gp1
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;

    p_son_req->oam_son_anr_meas_config_req.
        bitmask |= SON_ANR_MEAS_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.
        meas_gap_config.bitmask |= SON_ANR_UTRAN_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.
        utran_gap_config.bitmask |= SON_ANR_SETUP_GAP_CONFIG_PRESENT;

    p_son_req->oam_son_anr_meas_config_req.meas_gap_config.
        utran_gap_config.setup_gap_config.
        bitmask |= SON_ANR_GAP_OFFSET_GP1_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_son_anr_cm_offset_freq 
 * Description   : This function will check for validation of parameter 
 * Inputs        : loop, cell_reconfig_req 
 * Output        : none
 * Return        : none
 ****************************************************************************/
    void set_bitmask_son_anr_cm_offset_freq
(
 int loop,
 void * p_son_inter_freq_carr_params
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
    UInt8 idx = p_son_req->query_index;

    p_son_req->oam_son_anr_meas_config_req.eutran_config_list[idx].
        bitmask |= SON_MC_EUTRAN_CM_OFFSET_FREQ_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

#endif

/******************************************************************************
 *  FUNCTION NAME: oam_check_load_perctg
 *  DESCRIPTION:
 *      This function checks the load percentage order 
 *      
 *  Inputs       : load_percntg_over, load_percntg_high, load_percntg_mid 
 *  Output       : 
 *  RETURNS: OAM_TRUE/OAM_FALSE
 ******************************************************************************/


    oam_bool_et oam_check_load_perctg
(
 UInt8 load_percntg_over,
 UInt8 load_percntg_high,
 UInt8 load_percntg_mid
 )
{
    oam_bool_et ret_val = OAM_TRUE;

    OAM_FUN_ENTRY_TRACE();
    if( OAM_ZERO != load_percntg_high )
    {
        if( load_percntg_high <= load_percntg_mid )
        {
            ret_val = OAM_FALSE;
        }
    }
    if( OAM_ZERO != load_percntg_over )
    {
        if(load_percntg_over <= load_percntg_high )
        {
            ret_val = OAM_FALSE;
        }
        else if (load_percntg_over <= load_percntg_mid)
        {
            ret_val = OAM_FALSE;
        }
    }
    OAM_FUN_EXIT_TRACE();
    return ret_val;
}





/******************************************************************************
 *  FUNCTION NAME: oam_verify_load_cfg_req_from_rrm
 *  DESCRIPTION  : This function verifies the presence of load config parameters presence 
 *      
 *  Inputs       : p_srv_cell_info 
 *  Output       : 
 *  RETURNS: OAM_TRUE/OAM_FALSE
 ******************************************************************************/


    oam_bool_et oam_verify_load_cfg_req_from_rrm
(
 rrm_oam_serving_enb_cell_info_t *p_srv_cell_info
 )
{

    oam_bool_et ret_val = OAM_TRUE;
    UInt8           over_load = OAM_ZERO;
    UInt8           high_load = OAM_ZERO;
    UInt8           mid_load = OAM_ZERO;

    OAM_FUN_ENTRY_TRACE();
    if( (p_srv_cell_info->bitmask & RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT) ||
            (p_srv_cell_info->bitmask & RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT) ||
            (p_srv_cell_info->bitmask & RRM_OAM_MID_LOAD_LVL_ACT_PRESENT) )
    {
        if( RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->bitmask )
        {
            over_load = p_srv_cell_info->over_load_lvl_act.load_perctg;
        }
        if( RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->bitmask )
        {
            high_load = p_srv_cell_info->high_load_lvl_act.load_perctg;
        }
        if( RRM_OAM_MID_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->bitmask )
        {
            mid_load = p_srv_cell_info->mid_load_lvl_act.load_perctg;
        }
        ret_val = oam_check_load_perctg( over_load, high_load, mid_load );
    }
    OAM_FUN_EXIT_TRACE();
    return ret_val;
}
/******************************************************************************
 *  FUNCTION NAME: oam_handle_internal_shutdown
 *  DESCRIPTION  : This function oam handle internal shutdown
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : None
 *  Output       : None
 *  RETURNS: OAM_TRUE/OAM_FALSE
 ******************************************************************************/
oam_return_et
    oam_handle_internal_shutdown
(
)
{
    /* coverity 35895 */	
    oam_error_code_et error_code = NO_ERROR;
    oam_return_et retVal = OAM_SUCCESS;
    OAM_FUN_ENTRY_TRACE();
    UInt16 transaction_id = oam_get_new_trans_id();
    /* Spr 12880 Fix Start*/
    UInt8 CellId = OAM_INVALID_CELL_ID;
    /* Spr 12880 Fix End*/
    /*SPR 11480 FIX START*/
    /*global flag(shutdown_flag) removed (moved to oam_hm.c)*/
    /*SPR 11480 FIX END*/

    retVal = oam_collect_logs();
    if(OAM_SUCCESS == retVal) {
        OAM_LOG(OAM, OAM_INFO, "Saving all Logs files");
    }
    else {
        OAM_LOG(OAM, OAM_WARNING, "Log archival failure");
    }

    /* SPR 15366 START */
    oam_pm_handle_shutdown_command(oam_prov_req.cell_cntxt.curr_cell_cid);  //FIXXXX
    /* SPR 15366 END */ 

    retVal = oam_qcli_maintain_parameter_persistance("BOTH", &error_code);
    if (OAM_FAILURE == retVal) {
        OAM_ALARM(CONFIG_FILE_PERSISTENCE_FAILURE_ALARM_ID, MAJOR,
                NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                SOFTWARE_ERROR, EXPEDITED_ALARM,
                "Configuration File Persistence Failure", OAM_NULL,CellId);
    }

    /* This Function shall be implmented as part of Platform 
     * Related Services Activity */ 
    oam_port_process_shutdown();
    /* SPR 17777 fix */
    retVal = oam_cleanup_layers(transaction_id);

    oam_reset_reason_code(OAM_HEALTH_CHECK_FAILURE);

    OAM_FUN_EXIT_TRACE();
    return retVal;
}
/******************************************************************************
 *  FUNCTION NAME: oam_update_device_info
 *  DESCRIPTION  : This function oam update device info
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : string,value
 *  Output       : None
 *  RETURNS: None
 ******************************************************************************/
void oam_update_device_info(char* string, char* value)
{
    xmlNode *p_xml_node = OAM_NULL;
    xmlNode *temp = xml_struct_tr196_g.DeviceInfo;

    /*finding pointer to node*/
    p_xml_node = oam_xml_find_tag(temp->children,
            (xmlChar*)string);
    if(OAM_NULL == oam_schema_valid_ctxt || OAM_NULL == p_xml_node) {
        OAM_LOG(OAM, OAM_WARNING, "oam_schema_valid_ctxt = NULL or "
                "p_xml_node =  NULL, so is resulting into failure");

        OAM_FUN_EXIT_TRACE();
    }

    /* Enabling this code for parameter persistence */ 
    /*setting content of the node*/
    xmlNodeSetContent(p_xml_node, (xmlChar*)value);

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *  FUNCTION NAME: oam_send_rrc_add_lgw_req
 *  DESCRIPTION  : This function oam update device info
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : p_oam_rrc_add_lgw_req,src_module_id,trans_id
 *  Output       : None
 *  RETURNS: OAM_FAILURE/OAM_SUCCESS
 ******************************************************************************/
oam_return_et
oam_send_rrc_add_lgw_req
(
 oam_rrc_add_lgw_req_t *p_oam_rrc_add_lgw_req,
 UInt16                src_module_id,
 UInt16                trans_id,
 void                  *p_api_buf,
 UInt16                msg_len

 )
{
    OAM_FUN_ENTRY_TRACE();


    if(OAM_FAILURE == oam_rrc_il_send_rrc_oam_add_lgw_req(
                p_oam_rrc_add_lgw_req,
                src_module_id,
                RRC_MODULE_ID,
                trans_id,
                oam_prov_req.cell_cntxt.curr_cell_cid))
    {
        OAM_LOG(OAM, OAM_ERROR, "sending RRC_OAM_ADD_LGW_REQ failed, cell_index=%d",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    else
    {
        OAM_LOG(OAM, OAM_DETAILED, "RRC_OAM_ADD_LGW_REQ Successfully sent");
        /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
        if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
                    OAM_TRANS_RRC,msg_len,p_api_buf))
        {
            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
            return OAM_FAILURE;
        }
#endif
        /* SPR 9620 CHANGE END */
    }


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/******************************************************************************
 *  FUNCTION NAME: oam_send_rrc_delete_lgw_req
 *  DESCRIPTION  : This function oam update device info
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : p_oam_rrc_add_lgw_req,src_module_id,trans_id
 *  Output       : None
 *  RETURNS: OAM_FAILURE/OAM_SUCCESS
 ******************************************************************************/

oam_return_et
    oam_send_rrc_delete_lgw_req
(
 oam_rrc_delete_lgw_req_t *p_oam_rrc_delete_lgw_req,
 UInt16                src_module_id,
 UInt16                trans_id,
 void                  *p_api_buf,
 UInt16                msg_len
 )
{
    OAM_FUN_ENTRY_TRACE();
    oam_error_code_et p_error_code = NO_ERROR;

    if(OAM_FAILURE == oam_rrc_il_send_rrc_oam_delete_lgw_req(
                p_oam_rrc_delete_lgw_req,
                src_module_id,
                RRC_MODULE_ID,
                trans_id,
                oam_prov_req.cell_cntxt.curr_cell_cid))
    {
        OAM_LOG(OAM, OAM_ERROR, "sending RRC_OAM_DELETE_LGW_REQ failed");
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE, OAM_ERR_REQUEST_DENIED,
                (UInt8 *)"Request For LGW DELETE Failed",
                oam_strlen("Request For LGW DELETE Failed") + 1,
                OAM_VERSION_ID, 
                OAM_MODULE_ID,
                resp_destination_id,
                trans_id, 
                OAM_ZERO, 
                OAM_ZERO,
                &p_error_code);

        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    else
    {
        OAM_LOG(OAM, OAM_DETAILED, "RRC_OAM_DELETE_LGW_REQ Successfully sent");
        /* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
        if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
                    OAM_TRANS_RRC,msg_len,p_api_buf))
        {
            OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
            return OAM_FAILURE;
        }
#endif
        /* SPR 9620 CHANGE END */
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;

}

/******************************************************************************
 *  FUNCTION NAME: oam_send_lgw_add_req
 *  DESCRIPTION  : This function oam update device info
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : p_oam_rrc_add_lgw_req,src_module_id,trans_id
 *  Output       : None
 *  RETURNS: OAM_FAILURE/OAM_SUCCESS
 ******************************************************************************/
oam_return_et
    oam_send_lgw_add_req
(
 oam_rrc_add_lgw_req_t *p_oam_rrc_add_lgw_req,
 char *value,
 UInt16 trans_id,
 void *p_api_buf,
 UInt16 msg_len
 )
{
    OAM_FUN_EXIT_TRACE();
    oam_error_code_et p_error_code = NO_ERROR;
    if(oam_isValidIp4((UInt8 *)value) || oam_isValidIp6((UInt8 *)value))
    {
        struct in_addr addr;

        oam_memset(&addr,0,sizeof(struct in_addr)); /*Coverity Fix 66680*/
        if(oam_isValidIp4((UInt8 *)value))
        {
            p_oam_rrc_add_lgw_req->bitmask |= RRC_OAM_ADD_LGW_IPV4_ADDR_PRESENT;
            /*Coverity CID 62077 Fix Start */
            if (OAM_ZERO == oam_inet_aton(value, &addr))
            {
                OAM_LOG(OAM, OAM_DETAILED, "Error while converting the address");
                return OAM_FAILURE; 
            }  
            /*Coverity CID 62077 Fix End*/
            oam_memcpy((void*)p_oam_rrc_add_lgw_req->ip_addr, (const void*)&addr, sizeof(UInt32));
        }
        else
        {
            p_oam_rrc_add_lgw_req->bitmask |= RRC_OAM_ADD_LGW_IPV6_ADDR_PRESENT;
            OAM_INET_PTON(AF_INET6, (const char *)value, (void *)p_oam_rrc_add_lgw_req->ipv6_addr);

        }
        oam_send_rrc_add_lgw_req(p_oam_rrc_add_lgw_req, OAM_MODULE_ID, trans_id,p_api_buf,msg_len );

    }
    else
    {
        OAM_LOG(OAM, OAM_DETAILED, "Invalid Ip Address recieved for LGW request");
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                OAM_ERR_REQUEST_DENIED,(UInt8 *)"Invalid Ip address",oam_strlen("Invalid Ip address") + 1,
                OAM_VERSION_ID, OAM_MODULE_ID,
                resp_destination_id, trans_id, OAM_ZERO, OAM_ZERO,
                &p_error_code);

    }


    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;

}
/***************************************************************************
 *   FUNCTION NAME: set_bitmask_phy_layer_param_prs_muting_configuration_two 
 *   DESCRIPTION:
 *   This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
void
    set_bitmask_phy_layer_param_prs_muting_configuration_two
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_phy_layer_param_prs(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_PHY_LAYER_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_TWO_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/***************************************************************************
 *   FUNCTION NAME: set_bitmask_phy_layer_param_prs_muting_configuration_four 
 *   DESCRIPTION:
 *   This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
void
    set_bitmask_phy_layer_param_prs_muting_configuration_four
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_phy_layer_param_prs(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_PHY_LAYER_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_FOUR_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/***************************************************************************
 *   FUNCTION NAME: set_bitmask_phy_layer_param_prs_muting_configuration_eight 
 *   DESCRIPTION:
 *   This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
void
    set_bitmask_phy_layer_param_prs_muting_configuration_eight
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_phy_layer_param_prs(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_PHY_LAYER_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_EIGHT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/***************************************************************************
 *   FUNCTION NAME: set_bitmask_phy_layer_param_prs_muting_configuration_sixteen 
 *   DESCRIPTION:
 *   This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
void
    set_bitmask_phy_layer_param_prs_muting_configuration_sixteen
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    set_bitmask_phy_layer_param_prs(loop, p_cell_reconfig_req);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.bitmask |= RRM_OAM_PHY_LAYER_PARAMS_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/***************************************************************************
 *   FUNCTION NAME: set_bitmask_eutran_access_point_pos 
 *   DESCRIPTION:
 *   This function will check for validation of parameter
 *   Inputs       : loop : loop value for future reference
 *   Output       : NONE
 *   RETURNS: OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *******************************************************************************/
void
    set_bitmask_eutran_access_point_pos
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->bitmask |= RRM_OAM_OPERATOR_INFO_PRESENT;
    ((oam_rrm_cell_reconfig_req_t *)p_cell_reconfig_req)->operator_info.bitmask |= RRM_OAM_EUTRAN_ACCESS_POINT_POS_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

#ifdef OAM_SON_ENABLE
/******************************************************************************
 *  FUNCTION NAME: oam_send_rach_opt_enable_req
 *  DESCRIPTION  : This function oam send rach opt enable req
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : serving_list_size,trans_id
 *  Output       : None
 *  RETURNS: OAM_FAILURE/OAM_SUCCESS
 ******************************************************************************/
oam_return_et
    oam_send_rach_opt_enable_req
(
 UInt8 serving_list_size,
 UInt16 trans_id
 )
{
    OAM_FUN_ENTRY_TRACE();
    oam_counter_t temp_srv_cgi_cnt;
    oam_son_rach_opt_enable_req_t oam_son_rach_opt_enable_req = {OAM_ZERO};

    if(OAM_ZERO != serving_list_size)
    {
        oam_son_rach_opt_enable_req.bitmask |= SON_RACH_OPT_ENABLE_SRV_CGI_PRESENT;
        /* for loop included for future provision */
        for (temp_srv_cgi_cnt = OAM_ZERO; temp_srv_cgi_cnt < serving_list_size; temp_srv_cgi_cnt++)
        {
            oam_memcpy(&(oam_son_rach_opt_enable_req.srv_cgi),
                    /*SPR 21702 Start*/
                    &(oam_prov_req.oam_son_req.oam_son_cell_info_ind[temp_srv_cgi_cnt].serving_cell[OAM_ZERO].src_cgi),
                    /*SPR 21702 Start*/
                    sizeof(son_intra_rat_global_cell_id_t));
        }
    }

    if(OAM_FAILURE == oam_son_send_son_oam_rach_opt_enable_req(
                &oam_son_rach_opt_enable_req,
                OAM_MODULE_ID,
                SON_MODULE_ID,
                trans_id,
                oam_prov_req.cell_cntxt.curr_cell_cid))
    {
        OAM_LOG(OAM, OAM_ERROR, "oam failed to send SON_OAM_RACH_OPT_ENABLE_REQ");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
/******************************************************************************
 *  FUNCTION NAME: oam_send_rach_opt_desable_req
 *  DESCRIPTION  : This function oam send rach opt enable req
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : serving_list_size,trans_id
 *  Output       : None
 *  RETURNS: OAM_FAILURE/OAM_SUCCESS
 ******************************************************************************/

oam_return_et
    oam_send_rach_opt_disable_req
(
 UInt8 serving_list_size,
 UInt16 trans_id
 )
{
    OAM_FUN_ENTRY_TRACE();
    oam_counter_t temp_srv_cgi_cnt;
    oam_son_rach_opt_disable_req_t oam_son_rach_opt_disable_req = {OAM_ZERO};

    if(OAM_ZERO != serving_list_size)
    {
        oam_son_rach_opt_disable_req.bitmask |= SON_RACH_OPT_DISABLE_SRV_CGI_PRESENT;
        /* for loop included for future provision */
        for (temp_srv_cgi_cnt = OAM_ZERO; temp_srv_cgi_cnt < serving_list_size; temp_srv_cgi_cnt++)
        {
            oam_memcpy(&(oam_son_rach_opt_disable_req.srv_cgi),
                    /*SPR 21702 Start*/
                    &(oam_prov_req.oam_son_req.oam_son_cell_info_ind[temp_srv_cgi_cnt].serving_cell[OAM_ZERO].src_cgi),
                    /*SPR 21702 End*/
                    sizeof(son_intra_rat_global_cell_id_t));
        }
    }

    if(OAM_FAILURE == oam_son_send_son_oam_rach_opt_disable_req(
                &oam_son_rach_opt_disable_req,
                OAM_MODULE_ID,
                SON_MODULE_ID,
                trans_id,
                oam_prov_req.cell_cntxt.curr_cell_cid))
    {
        OAM_LOG(OAM, OAM_ERROR, "oam failed to send SON_OAM_RACH_OPT_DISABLE_REQ");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;

}
/******************************************************************************
 *  FUNCTION NAME: oam_send_rach_opt_modify_req
 *  DESCRIPTION  : This function oam send rach opt modify req
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : rach_opt_mode,trans_id
 *  Output       : None
 *  RETURNS: OAM_FAILURE/OAM_SUCCESS
 ******************************************************************************/

oam_return_et
    oam_send_rach_opt_modify_req
(
 UInt8 rach_opt_mode,
 UInt16 trans_id
 )
{
    OAM_FUN_ENTRY_TRACE();

    /* coverity 53561 */
    oam_son_rach_opt_modify_rach_optmode_req_t oam_son_rach_opt_modify_rach_optmode_req;

    oam_memset(&oam_son_rach_opt_modify_rach_optmode_req, OAM_ZERO, sizeof(oam_son_rach_opt_modify_rach_optmode_req_t));

    /* coverity 53560 */
    oam_son_rach_opt_modify_rach_optmode_req.rachopt_mode = (son_mode_et)rach_opt_mode;

    if(OAM_FAILURE == oam_son_send_son_oam_rach_opt_modify_rach_optmode_req(
                &oam_son_rach_opt_modify_rach_optmode_req,
                OAM_MODULE_ID,
                SON_MODULE_ID,
                trans_id,
                oam_prov_req.cell_cntxt.curr_cell_cid))
    {
        OAM_LOG(OAM, OAM_ERROR, "sending SON_OAM_RACH_OPT_MODIFY_RACH_OPTMODE_REQ failed");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;
}
#endif

/******************************************************************************
 * Function Name  : oam_partial_path_plmnlist_fill_params 
 * Inputs         : 
 * Outputs        : 
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : this function handles the PLMNLIST parameter for partial path 
 *******************************************************************************/
    oam_return_et
oam_partial_path_plmnlist_fill_params(UInt8 *num_params,
        UInt8 *max_multi_obj_cnt)
{
    OAM_FUN_ENTRY_TRACE();
    /* COV CID: 64253 FIX START */
    SInt8 arr_idx = OAM_ZERO;
    /* COV CID: 64253 FIX END */
    UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;


    arr_idx = oam_get_cell_plmnlist_data_idx(cid);
    if(OAM_ERROR_RETURN_VAL == arr_idx) {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                cid);
        return OAM_FAILURE;
    }

    g_parameter_map_element = g_parameter_TR_PLMNList_element;
    *num_params = ARRSIZE(g_parameter_TR_PLMNList_element);
    *max_multi_obj_cnt =
        RRM_PROV_REQ.plmnlist_data[arr_idx].curr_plmn_entries;

    OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
            "PLMNList.");
    if((*num_params) * (*max_multi_obj_cnt) > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)
    {
        OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
                "response are greater than the maximum limit allowed, "
                "sending an error response.");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;;
    }
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;;
}

#ifdef OAM_SON_ENABLE
/******************************************************************************
 * Function Name  : oam_partial_path_neighborlist_inuse 
 * Inputs         :
 * Outputs        :
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : this function handles the Rem Lte for partial path 
 *******************************************************************************/
    oam_return_et
oam_partial_path_neighborlist_inuse(char *temp_payload ,UInt8 *p_temp_buf, UInt16 curr_pos , UInt16 *resp_len , UInt16  *num_parameters )
{
	OAM_FUN_ENTRY_TRACE();
	UInt8  loop = OAM_ZERO;
	UInt8 inst_num = OAM_ZERO;
	UInt8 bit_num = OAM_ZERO;

	char par_dot_param[MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH]= {0}; //CID 147320 
	char param_val_pair[PARAM_VAL_PAIR_MAX_LEN];
	UInt16 param_info_len = OAM_ZERO;
	UInt16  param_val_pair_len = OAM_ZERO;
	UInt8  retVal = OAM_ZERO;
	oam_error_code_et p_error_code = NO_ERROR;
	char par_name[MAX_PARENT_NAME_LENGTH];
	char param_val_pair_remlte[MAX_PARENT_NAME_LENGTH + 50];
	UInt8 max_multi_obj_cnt = OAM_ZERO;
	UInt8 num_params = OAM_ZERO;
	UInt8 multi_obj_cnt = OAM_ZERO;
	Char8 *parameter_token = OAM_NULL;
	UInt8 param_name_len = OAM_ZERO;

    /* SPR 15374 START */
    UInt8 inst_digit_count = OAM_ZERO;
    /* SPR 15374 END*/

	SInt8 cell_config_idx = OAM_ZERO;

	cell_config_idx = oam_get_son_neigh_list_in_use_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}



	/* get parameter value from OAM database */
	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.LTECellNumberOfEntries");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
    }

	param_name_len = oam_strlen(par_dot_param);
	p_temp_buf += param_name_len;
	param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
	param_info_len = param_val_pair_len + OAM_FOUR;
	*(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
	*(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
	*(temp_payload + curr_pos++) = OAM_ZERO;
	*(temp_payload + curr_pos++) = OAM_ZERO;
	oam_memcpy((temp_payload + curr_pos),
			param_val_pair, param_val_pair_len);
	*resp_len += param_info_len;
	curr_pos += param_val_pair_len;
	*num_parameters = OAM_ONE;
	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.MaxLTECellEntries");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
    }

	param_name_len = oam_strlen(par_dot_param);
	p_temp_buf += param_name_len;
	param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
	param_info_len = param_val_pair_len + OAM_FOUR;
	*(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
	*(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
	*(temp_payload + curr_pos++) = OAM_ZERO;
	*(temp_payload + curr_pos++) = OAM_ZERO;
	oam_memcpy((temp_payload + curr_pos),
			param_val_pair, param_val_pair_len);
	*resp_len += param_info_len;
	curr_pos += param_val_pair_len;
	*num_parameters = *num_parameters + OAM_ONE;


	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.UMTSNumberOfEntries");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
    }

	param_name_len = oam_strlen(par_dot_param);
	p_temp_buf += param_name_len;
	param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
	param_info_len = param_val_pair_len + OAM_FOUR;
	*(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
	*(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
	*(temp_payload + curr_pos++) = OAM_ZERO;
	*(temp_payload + curr_pos++) = OAM_ZERO;
	oam_memcpy((temp_payload + curr_pos),
			param_val_pair, param_val_pair_len);
	*resp_len += param_info_len;
	curr_pos += param_val_pair_len;
	*num_parameters = *num_parameters + OAM_ONE;


	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.MaxUMTSEntries");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_TR_element[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
    }

	param_name_len = oam_strlen(par_dot_param);
	p_temp_buf += param_name_len;
	param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
	param_info_len = param_val_pair_len + OAM_FOUR;
	*(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
	*(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
	*(temp_payload + curr_pos++) = OAM_ZERO;
	*(temp_payload + curr_pos++) = OAM_ZERO;
	oam_memcpy((temp_payload + curr_pos),
			param_val_pair, param_val_pair_len);
	*resp_len += param_info_len;
	curr_pos += param_val_pair_len;
	*num_parameters = *num_parameters + OAM_ONE;


	oam_memset(par_name, OAM_ZERO, MAX_PARENT_NAME_LENGTH);
/* spr_21013_fix_start */
	oam_strcpy(par_name,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.LTECell.");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_name);

	g_parameter_map_element = g_param_intra_rat_neigh_list_in_use;

	num_params = ARRSIZE(g_param_intra_rat_neigh_list_in_use);

	max_multi_obj_cnt = SON_PROV_REQ.neigh_list_in_use[cell_config_idx].nrt_info.nr_list.
		intra_rat_nr_list_size;


	if(num_params * max_multi_obj_cnt > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)
	{
		OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
				"response are greater than the maximum limit allowed, "
				"sending an error response.");

		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;

	}

	OAM_LOG(OAM,OAM_DETAILED,"Number of parameters in GPV partial path for neighborlistinuse num_params ::%d ", num_params );

	/**** Get Parameter's Info ****/ 
	while(multi_obj_cnt++ < max_multi_obj_cnt){
/*SPR 22442 Fix Start*/
		for(bit_num = inst_num; bit_num < SON_MAX_NO_INTRA_RAT_NEIGHBOUR_CELLS;
/*SPR 22442 Fix End*/
				++bit_num) {
			if(SON_PROV_REQ.neigh_list_in_use[cell_config_idx].
					intra_rat_neigh_valid_bitmap & (OAM_ONE << bit_num)) {
				inst_num = bit_num + OAM_ONE;
				break;
			}
		}

		for(loop = OAM_ZERO; loop < num_params; ++loop) {
			oam_memset(par_dot_param, OAM_ZERO,
					(MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH));

			/* Actual handling for partial parent GPV */
			oam_strncpy(par_dot_param, par_name, oam_strlen(par_name));

            /* SPR 15374 START */
            if(inst_num < 10)
                inst_digit_count=1;
            else
                inst_digit_count=2;

            oam_snprintf(par_dot_param + oam_strlen(par_name), inst_digit_count + OAM_THREE,
                    "[%d]", inst_num);
            /* SPR 15374 END */

			oam_snprintf(par_dot_param + oam_strlen(par_name),OAM_FOUR,
					"[%d]", inst_num);
			parameter_token =
				OAM_STRRCHR(g_parameter_map_element[loop].
						parameter_name, '.');
			if(parameter_token) {
				oam_memcpy(par_dot_param + oam_strlen(par_dot_param),
						parameter_token, oam_strlen(parameter_token));
			}

			OAM_LOG(OAM,OAM_DETAILED,"par dot param   ::%s ", par_dot_param );
			retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
			if(OAM_ZERO == retVal)
			{

				OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}

			oam_sprintf(param_val_pair_remlte, "LTECell.[%d].%s",inst_num , param_val_pair); 

			p_temp_buf += param_name_len;
			param_val_pair_len = oam_strlen(param_val_pair_remlte) + OAM_ONE;
			param_info_len = param_val_pair_len + OAM_FOUR;
			*(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
			*(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
			*(temp_payload + curr_pos++) = OAM_ZERO;
			*(temp_payload + curr_pos++) = OAM_ZERO;
			oam_memcpy((temp_payload + curr_pos),
					param_val_pair_remlte, param_val_pair_len);
			*resp_len += param_info_len;
			curr_pos += param_val_pair_len;
		}
	};

	if(OAM_ZERO != max_multi_obj_cnt)
		*num_parameters = *num_parameters + (num_params * (multi_obj_cnt-1));


	oam_memset(par_name, OAM_ZERO, MAX_PARENT_NAME_LENGTH);
/* spr_21013_fix_start */
	oam_strcpy(par_name,"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.UMTS.");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_name);

	g_parameter_map_element = g_param_inter_rat_neigh_list_in_use;
	/* Resset the multi object count here */
	multi_obj_cnt = OAM_ZERO;
	num_params = ARRSIZE(g_param_inter_rat_neigh_list_in_use);
	max_multi_obj_cnt = SON_PROV_REQ.neigh_list_in_use[cell_config_idx].nrt_info.nr_list.
		inter_rat_nr_list_size;

	OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
			"inter-RAT NeighborListInUse.");


	if(num_params * max_multi_obj_cnt > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)
	{
		OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
				"response are greater than the maximum limit allowed, "
				"sending an error response.");

		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;

	}

	/****************/
	/* cov cid 54866 fix*/
	while(multi_obj_cnt++ < max_multi_obj_cnt){
		/* Determine the instance number for the parent.
		 * Code should be added here for evaluation instance number
		 * of the parent */
/*SPR 22442 Fix Start*/
		for(bit_num = inst_num; bit_num < SON_MAX_NO_UMTS_NEIGHBOUR_CELLS;
/*SPR 22442 Fix End*/
				++bit_num) {

			/* SPR-13586 START */
			if(SON_PROV_REQ.neigh_list_in_use[cell_config_idx].
					inter_rat_umts_neigh_valid_bitmap & (OAM_ONE << bit_num)) {
				/* SPR-13586 END */
				inst_num = bit_num + OAM_ONE;
				break;
			}
		}
		for(loop = OAM_ZERO; loop < num_params; ++loop) {
			oam_memset(par_dot_param, OAM_ZERO,
					(MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH));

			/* Actual handling for partial parent GPV */
			oam_strncpy(par_dot_param, par_name, oam_strlen(par_name));

			oam_snprintf(par_dot_param + oam_strlen(par_name),OAM_FOUR, 
					"[%d]", inst_num);

            /* SPR 15374 START */
            if(inst_num < 10)
                inst_digit_count=1;
            else
                inst_digit_count=2;

            oam_snprintf(par_dot_param + oam_strlen(par_name), inst_digit_count + OAM_THREE,
                    "[%d]", inst_num);
            /* SPR 15374 END */

			parameter_token =
				OAM_STRRCHR(g_parameter_map_element[loop].
						parameter_name, '.');
			if(parameter_token) {
				oam_memcpy(par_dot_param + oam_strlen(par_dot_param),
						parameter_token, oam_strlen(parameter_token));
			}

			OAM_LOG(OAM,OAM_DETAILED,"par dot param   ::%s ", par_dot_param );
			retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
			if(OAM_ZERO == retVal)
			{

				OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}


			oam_sprintf(param_val_pair_remlte, "InterRATCell.UMTS.[%d].%s",inst_num , param_val_pair); 

			p_temp_buf += param_name_len;
			param_val_pair_len = oam_strlen(param_val_pair_remlte) + OAM_ONE;
			param_info_len = param_val_pair_len + OAM_FOUR;
			*(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
			*(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
			*(temp_payload + curr_pos++) = OAM_ZERO;
			*(temp_payload + curr_pos++) = OAM_ZERO;
			oam_memcpy((temp_payload + curr_pos),
					param_val_pair_remlte, param_val_pair_len);
			*resp_len += param_info_len;
			curr_pos += param_val_pair_len;
		}
	};

	if(OAM_ZERO != max_multi_obj_cnt)
		*num_parameters = *num_parameters + (num_params * (multi_obj_cnt - 1));

	OAM_LOG(OAM,OAM_DETAILED,"Number of parameters in GPV partial path for neighborlistinuse ::%d ",*num_parameters );

	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;

}
/******************************************************************************
 * Function Name  : oam_partial_path_rem_lte 
 * Inputs         :
 * Outputs        :
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : this function handles the Rem Lte for partial path 
 *******************************************************************************/
	oam_return_et
oam_partial_path_rem_lte(char *temp_payload ,UInt8 *p_temp_buf, UInt16 curr_pos , UInt16 *resp_len , UInt16  *num_parameters )
{
	OAM_FUN_ENTRY_TRACE();
	UInt8  loop = OAM_ZERO;
	UInt8 inst_num = OAM_ZERO;
	char par_dot_param[MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH]= {0};  //CID 147323
	char param_val_pair[PARAM_VAL_PAIR_MAX_LEN];
	UInt16 param_info_len = OAM_ZERO;
	UInt16  param_val_pair_len = OAM_ZERO;
	UInt8 retVal = OAM_FAILURE;
	oam_error_code_et p_error_code = NO_ERROR;
	char par_name[MAX_PARENT_NAME_LENGTH];
	char par_name_plmn[MAX_PARENT_NAME_LENGTH];
	UInt8 max_multi_obj_cnt = OAM_ZERO;
    /*  coverity 71245 fix start */
    UInt16 num_params = OAM_ZERO;
    /*  coverity 71245 fix end */

    /*  coverity 71246 fix start */
    UInt16 num_params_1 = OAM_ZERO;
    /*  coverity 71246 fix end */

    /*  coverity 71247 fix start */
    UInt16 num_params_2 = OAM_ZERO;
    /*  coverity 71247 fix end */

    /*  coverity 71248 fix start */
    UInt16 num_params_plmn = OAM_ZERO;
    /*  coverity 71248 fix end */

	UInt8 multi_obj_cnt = OAM_ZERO;
	UInt8 multi_obj_cnt_plmn = OAM_ZERO;
	Char8 *parameter_token = OAM_NULL;
	UInt8 param_name_len = OAM_ZERO;
	char param_val_pair_remlte[PARAM_VAL_PAIR_MAX_LEN + 50 ];
	UInt8 var_num_cells = OAM_ZERO; 

	/* get parameter value from OAM database */
	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.[1].InServiceHandling");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
    }
    else
    {
        param_name_len = oam_strlen(par_dot_param);
        p_temp_buf += param_name_len;
        param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
        param_info_len = param_val_pair_len + OAM_FOUR;
        *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
        *(temp_payload + curr_pos++) = OAM_ZERO;
        *(temp_payload + curr_pos++) = OAM_ZERO;
        oam_memcpy((temp_payload + curr_pos),
                param_val_pair, param_val_pair_len);
        *resp_len += param_info_len;
        curr_pos += param_val_pair_len;
        *num_parameters = OAM_ONE;
    }
	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanOnBoot");
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
    }
    else
    {
        param_name_len = oam_strlen(par_dot_param);
        p_temp_buf += param_name_len;
        param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
        param_info_len = param_val_pair_len + OAM_FOUR;
        *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
        *(temp_payload + curr_pos++) = OAM_ZERO;
        *(temp_payload + curr_pos++) = OAM_ZERO;
        oam_memcpy((temp_payload + curr_pos),
                param_val_pair, param_val_pair_len);
        *resp_len += param_info_len;
        curr_pos += param_val_pair_len;
        *num_parameters = *num_parameters + OAM_ONE;
    }

	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanPeriodically");
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
    }
    else
    {
        param_name_len = oam_strlen(par_dot_param);
        p_temp_buf += param_name_len;
        param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
        param_info_len = param_val_pair_len + OAM_FOUR;
        *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
        *(temp_payload + curr_pos++) = OAM_ZERO;
        *(temp_payload + curr_pos++) = OAM_ZERO;
        oam_memcpy((temp_payload + curr_pos),
                param_val_pair, param_val_pair_len);
        *resp_len += param_info_len;
        curr_pos += param_val_pair_len;
        *num_parameters = *num_parameters + OAM_ONE;
    }

	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.PeriodicInterval");
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
    }
    else
    {
        param_name_len = oam_strlen(par_dot_param);
        p_temp_buf += param_name_len;
        param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
        param_info_len = param_val_pair_len + OAM_FOUR;
        *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
        *(temp_payload + curr_pos++) = OAM_ZERO;
        *(temp_payload + curr_pos++) = OAM_ZERO;
        oam_memcpy((temp_payload + curr_pos),
                param_val_pair, param_val_pair_len);
        *resp_len += param_info_len;
        curr_pos += param_val_pair_len;
        *num_parameters = *num_parameters + OAM_ONE;
    }


	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.PeriodicTime");
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
    }
    else
    {
        param_name_len = oam_strlen(par_dot_param);
        p_temp_buf += param_name_len;
        param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
        param_info_len = param_val_pair_len + OAM_FOUR;
        *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
        *(temp_payload + curr_pos++) = OAM_ZERO;
        *(temp_payload + curr_pos++) = OAM_ZERO;
        oam_memcpy((temp_payload + curr_pos),
                param_val_pair, param_val_pair_len);
        *resp_len += param_info_len;
        curr_pos += param_val_pair_len;
        *num_parameters = *num_parameters + OAM_ONE;
    }
	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.REMPLMNList");
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
    }
    else
    {
        param_name_len = oam_strlen(par_dot_param);
        p_temp_buf += param_name_len;
        param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
        param_info_len = param_val_pair_len + OAM_FOUR;
        *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
        *(temp_payload + curr_pos++) = OAM_ZERO;
        *(temp_payload + curr_pos++) = OAM_ZERO;
        oam_memcpy((temp_payload + curr_pos),
                param_val_pair, param_val_pair_len);
        *resp_len += param_info_len;
        curr_pos += param_val_pair_len;
        *num_parameters = *num_parameters + OAM_ONE;
    }
	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.REMBandList");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
    }
    else
    {
        param_name_len = oam_strlen(par_dot_param);
        p_temp_buf += param_name_len;
        param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
        param_info_len = param_val_pair_len + OAM_FOUR;
        *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
        *(temp_payload + curr_pos++) = OAM_ZERO;
        *(temp_payload + curr_pos++) = OAM_ZERO;
        oam_memcpy((temp_payload + curr_pos),
                param_val_pair, param_val_pair_len);
        *resp_len += param_info_len;
        curr_pos += param_val_pair_len;
        *num_parameters = *num_parameters + OAM_ONE;
    }

	oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
/* spr_21013_fix_start */
	oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.EUTRACarrierARFCNDLList");
/* spr_21013_fix_end */
	OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
	g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
	retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
    if(OAM_ZERO == retVal)
    {
        OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
    }
    else
    {
        param_name_len = oam_strlen(par_dot_param);
        p_temp_buf += param_name_len;
        param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
        param_info_len = param_val_pair_len + OAM_FOUR;
        *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
        *(temp_payload + curr_pos++) = OAM_ZERO;
        *(temp_payload + curr_pos++) = OAM_ZERO;
        oam_memcpy((temp_payload + curr_pos),
                param_val_pair, param_val_pair_len);
        *resp_len += param_info_len;
        curr_pos += param_val_pair_len;
        *num_parameters = *num_parameters + OAM_ONE;
    }
        oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
        /* spr_21013_fix_start */
        oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanTimeout");
        /* spr_21013_fix_end */
        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
        g_parameter_map_element = &g_parameter_son_nw_scan_req[OAM_ZERO];
        retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
        if(OAM_ZERO == retVal)
        {
            OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        }
        else
        {
            param_name_len = oam_strlen(par_dot_param);
            p_temp_buf += param_name_len;
            param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
            param_info_len = param_val_pair_len + OAM_FOUR;
            *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
            *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
            *(temp_payload + curr_pos++) = OAM_ZERO;
            *(temp_payload + curr_pos++) = OAM_ZERO;
            oam_memcpy((temp_payload + curr_pos),
                    param_val_pair, param_val_pair_len);
            *resp_len += param_info_len;
            curr_pos += param_val_pair_len;
            *num_parameters = *num_parameters + OAM_ONE;
        }


        oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
        /* spr_21013_fix_start */
        oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.ScanStatus");
        /* spr_21013_fix_end */
        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
        g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO];
        retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
        if(OAM_ZERO == retVal)
        {
            OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        }
        else
        {
            param_name_len = oam_strlen(par_dot_param);
            p_temp_buf += param_name_len;
            param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
            param_info_len = param_val_pair_len + OAM_FOUR;
            *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
            *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
            *(temp_payload + curr_pos++) = OAM_ZERO;
            *(temp_payload + curr_pos++) = OAM_ZERO;
            oam_memcpy((temp_payload + curr_pos),
                    param_val_pair, param_val_pair_len);
            *resp_len += param_info_len;
            curr_pos += param_val_pair_len;
            *num_parameters = *num_parameters + OAM_ONE;
        }
        oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
        /* spr_21013_fix_start */
        oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.ErrorDetails");
        /* spr_21013_fix_end */
        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
        g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO];
        retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
        if(OAM_ZERO == retVal)
        {
            OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        }
        else
        {
            param_name_len = oam_strlen(par_dot_param);
            p_temp_buf += param_name_len;
            param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
            param_info_len = param_val_pair_len + OAM_FOUR;
            *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
            *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
            *(temp_payload + curr_pos++) = OAM_ZERO;
            *(temp_payload + curr_pos++) = OAM_ZERO;
            oam_memcpy((temp_payload + curr_pos),
                    param_val_pair, param_val_pair_len);
            *resp_len += param_info_len;
            curr_pos += param_val_pair_len;
            *num_parameters = *num_parameters + OAM_ONE;
        }

        oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
        /* spr_21013_fix_start */
        oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.LastScanTime");
        /* spr_21013_fix_end */
        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
        g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO];
        retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
        if(OAM_ZERO == retVal)
        {
            OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        }
        else
        {
            param_name_len = oam_strlen(par_dot_param);
            p_temp_buf += param_name_len;
            param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
            param_info_len = param_val_pair_len + OAM_FOUR;
            *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
            *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
            *(temp_payload + curr_pos++) = OAM_ZERO;
            *(temp_payload + curr_pos++) = OAM_ZERO;
            oam_memcpy((temp_payload + curr_pos),
                    param_val_pair, param_val_pair_len);
            *resp_len += param_info_len;
            curr_pos += param_val_pair_len;
            *num_parameters = *num_parameters + OAM_ONE;
        }


        oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
        /* spr_21013_fix_start */
        oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.MaxCellEntries");
        /* spr_21013_fix_end */
        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
        g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO];
        retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
        if(OAM_ZERO == retVal)
        {
            OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        }
        else
        {
            param_name_len = oam_strlen(par_dot_param);
            p_temp_buf += param_name_len;
            param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
            param_info_len = param_val_pair_len + OAM_FOUR;
            *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
            *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
            *(temp_payload + curr_pos++) = OAM_ZERO;
            *(temp_payload + curr_pos++) = OAM_ZERO;
            oam_memcpy((temp_payload + curr_pos),
                    param_val_pair, param_val_pair_len);
            *resp_len += param_info_len;
            curr_pos += param_val_pair_len;
            *num_parameters = *num_parameters + OAM_ONE;
        }

        oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
        /* spr_21013_fix_start */
        oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.CellNumberOfEntries");
        /* spr_21013_fix_end */
        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
        g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO];
        retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
        if(OAM_ZERO == retVal)
        {
            OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        }
        else
        {
            param_name_len = oam_strlen(par_dot_param);
            p_temp_buf += param_name_len;
            param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
            param_info_len = param_val_pair_len + OAM_FOUR;
            *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
            *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
            *(temp_payload + curr_pos++) = OAM_ZERO;
            *(temp_payload + curr_pos++) = OAM_ZERO;
            oam_memcpy((temp_payload + curr_pos),
                    param_val_pair, param_val_pair_len);
            *resp_len += param_info_len;
            curr_pos += param_val_pair_len;
            *num_parameters = *num_parameters + OAM_ONE;
        }

        Char8 *str = OAM_NULL;
        str =OAM_STRRCHR(param_val_pair,'=') + OAM_ONE;
        UInt8 num_cells = oam_atoi(str);

        oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
        /* spr_21013_fix_start */
        oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.MaxCarrierMeasEntries");
        /* spr_21013_fix_end */
        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
        g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO];
        retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
        if(OAM_ZERO == retVal)
        {
            OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        }
        else
        {
            param_name_len = oam_strlen(par_dot_param);
            p_temp_buf += param_name_len;
            param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
            param_info_len = param_val_pair_len + OAM_FOUR;
            *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
            *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
            *(temp_payload + curr_pos++) = OAM_ZERO;
            *(temp_payload + curr_pos++) = OAM_ZERO;
            oam_memcpy((temp_payload + curr_pos),
                    param_val_pair, param_val_pair_len);
            *resp_len += param_info_len;
            curr_pos += param_val_pair_len;
            *num_parameters = *num_parameters + OAM_ONE;
        }

        oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
        /* spr_21013_fix_start */
        oam_strcpy(par_dot_param,"InternetGatewayDevice.Services.FAPService.REM.LTE.CarrierMeasNumberOfEntries");
        /* spr_21013_fix_end */
        OAM_LOG(OAM, OAM_DETAILED, "par_dot_param = %s", par_dot_param);
        g_parameter_map_element = &g_parameter_son_nw_scan_status[OAM_ZERO];
        retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
        if(OAM_ZERO == retVal)
        {
            OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
        }
        else
        {
            param_name_len = oam_strlen(par_dot_param);
            p_temp_buf += param_name_len;
            param_val_pair_len = oam_strlen(param_val_pair) + OAM_ONE;
            param_info_len = param_val_pair_len + OAM_FOUR;
            *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
            *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
            *(temp_payload + curr_pos++) = OAM_ZERO;
            *(temp_payload + curr_pos++) = OAM_ZERO;
            oam_memcpy((temp_payload + curr_pos),
                    param_val_pair, param_val_pair_len);
            *resp_len += param_info_len;
            curr_pos += param_val_pair_len;
            *num_parameters = *num_parameters + OAM_ONE;
        }
        str = OAM_NULL;
        str =OAM_STRRCHR(param_val_pair,'=') + OAM_ONE;
        UInt8 num_carrier_meas = oam_atoi(str);
        max_multi_obj_cnt = num_cells;

        /**** Get Parameter's Info ****/ 
        while(multi_obj_cnt++ < max_multi_obj_cnt){

            inst_num+=OAM_ONE;
            oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
            /* spr_21013_fix_start */
            oam_sprintf(par_name,"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.RF.");
            /* spr_21013_fix_end */
            g_parameter_map_element = g_parameter_son_nw_scan_results_rf;
            num_params = ARRSIZE(g_parameter_son_nw_scan_results_rf);
            if(num_params   > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)
            {
                OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
                        "response are greater than the maximum limit allowed, "
                        "sending an error response.");

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;

            }

            for(loop = OAM_ZERO; loop < num_params; ++loop) {
                oam_memset(par_dot_param, OAM_ZERO,
                        (MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH));

                /* Actual handling for partial parent GPV */
                oam_strncpy(par_dot_param, par_name, oam_strlen(par_name));

                oam_snprintf(par_dot_param + oam_strlen(par_name),OAM_FOUR,
                        "[%d]", inst_num);
                parameter_token =
                    OAM_STRRCHR(g_parameter_map_element[loop].
                            parameter_name, '.');
                if(parameter_token) {
                    oam_memcpy(par_dot_param + oam_strlen(par_dot_param),
                            parameter_token, oam_strlen(parameter_token));
                }

                oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
                retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
                if(OAM_ZERO == retVal)
                {

                    OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                    break;
                }

                oam_sprintf(param_val_pair_remlte, "Cell.[%d].RF.%s",inst_num  , param_val_pair); 


                p_temp_buf += param_name_len;
                param_val_pair_len = oam_strlen(param_val_pair_remlte) + OAM_ONE;
                param_info_len = param_val_pair_len + OAM_FOUR;
                *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
                *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
                *(temp_payload + curr_pos++) = OAM_ZERO;
                *(temp_payload + curr_pos++) = OAM_ZERO;
                oam_memcpy((temp_payload + curr_pos),
                        param_val_pair_remlte, param_val_pair_len);
                *resp_len += param_info_len;
                curr_pos += param_val_pair_len;
            }

            /* BCCH */
            oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
            /* spr_21013_fix_start */
            oam_sprintf(par_name,"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.");
            /* spr_21013_fix_end */
            g_parameter_map_element_bcch = g_parameter_son_nw_scan_results_bcch;
            num_params_1 = ARRSIZE(g_parameter_son_nw_scan_results_bcch);
            if(num_params_1   > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)
            {
                OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
                        "response are greater than the maximum limit allowed, "
                        "sending an error response.");

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;

            }

            for(loop = OAM_ZERO; loop < num_params_1; ++loop) {
                oam_memset(par_dot_param, OAM_ZERO,
                        (MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH));

                /* Actual handling for partial parent GPV */
                oam_strncpy(par_dot_param, par_name, oam_strlen(par_name));

                oam_snprintf(par_dot_param + oam_strlen(par_name),OAM_FOUR,
                        "[%d]", inst_num);
                parameter_token =
                    OAM_STRRCHR(g_parameter_map_element_bcch[loop].
                            parameter_name, '.');
                if(parameter_token) {
                    oam_memcpy(par_dot_param + oam_strlen(par_dot_param),
                            parameter_token, oam_strlen(parameter_token));
                }

                oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
                retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
                if(OAM_ZERO == retVal)
                {

                    OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                    break;
                }

                oam_sprintf(param_val_pair_remlte, "Cell.[%d].BCCH.%s",inst_num, param_val_pair); 
                p_temp_buf += param_name_len;
                param_val_pair_len = oam_strlen(param_val_pair_remlte) + OAM_ONE;
                param_info_len = param_val_pair_len + OAM_FOUR;
                *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
                *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
                *(temp_payload + curr_pos++) = OAM_ZERO;
                *(temp_payload + curr_pos++) = OAM_ZERO;
                oam_memcpy((temp_payload + curr_pos),
                        param_val_pair_remlte, param_val_pair_len);
                *resp_len += param_info_len;
                curr_pos += param_val_pair_len;


                /* Block Start for Plmnlist */
                if(oam_strstr(param_val_pair_remlte,"PLMNListNumberOfEntries"
                            )) 
                {
                    oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
                    /* spr_21013_fix_start */
                    oam_sprintf(par_name_plmn,"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.BCCH.PLMNList.");
                    /* spr_21013_fix_end */
                    UInt8  var_loop = OAM_ZERO;
                    Char8 *ptr_str = OAM_NULL;
                    ptr_str =OAM_STRRCHR(param_val_pair_remlte,'=') + OAM_ONE;
                    var_num_cells = oam_atoi(ptr_str);
                    if(OAM_ZERO != var_num_cells)
                    {
                        OAM_LOG(OAM, OAM_DETAILED, "OAM GET PARAM IN PLMNLIST");

                        g_parameter_map_element = g_parameter_son_nw_scan_results_bcch_plmnlist;
                        num_params_plmn = ARRSIZE(g_parameter_son_nw_scan_results_bcch_plmnlist);
                        if(num_params_plmn   > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)
                        {
                            OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
                                    "response are greater than the maximum limit allowed, "
                                    "sending an error response.");

                            OAM_FUN_EXIT_TRACE();
                            return OAM_FAILURE;

                        }

                        do{
                            for(var_loop = OAM_ZERO; var_loop < num_params_plmn; ++var_loop) {
                                oam_memset(par_dot_param, OAM_ZERO,
                                        (MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH));

                                /* Actual handling for partial parent GPV */
                                oam_strncpy(par_dot_param, par_name_plmn, oam_strlen(par_name_plmn));

                                oam_snprintf(par_dot_param + oam_strlen(par_name_plmn),OAM_FOUR, 
                                        "[%d]", inst_num);
                                parameter_token =
                                    OAM_STRRCHR(g_parameter_map_element[var_loop].
                                            parameter_name, '.');
                                if(parameter_token) {
                                    oam_memcpy(par_dot_param + oam_strlen(par_dot_param),
                                            parameter_token, oam_strlen(parameter_token));
                                }

                                oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
                                retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
                                if(OAM_ZERO == retVal)
                                {

                                    OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
                                    OAM_FUN_EXIT_TRACE();
                                    return OAM_FAILURE;
                                    break;
                                }
                                oam_sprintf(param_val_pair_remlte, "Cell.[%d].BCCH.PLMNList.[%d].%s",inst_num ,(num_params_plmn + OAM_ONE), param_val_pair); 
                                p_temp_buf += param_name_len;
                                param_val_pair_len = oam_strlen(param_val_pair_remlte) + OAM_ONE;
                                param_info_len = param_val_pair_len + OAM_FOUR;
                                *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
                                *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
                                *(temp_payload + curr_pos++) = OAM_ZERO;
                                *(temp_payload + curr_pos++) = OAM_ZERO;
                                oam_memcpy((temp_payload + curr_pos),
                                        param_val_pair_remlte, param_val_pair_len);
                                *resp_len += param_info_len;
                                curr_pos += param_val_pair_len;

                            }
                        }while(++multi_obj_cnt_plmn < var_num_cells );

                    }
                }
            }

        };
        if(OAM_ZERO != max_multi_obj_cnt)
            *num_parameters = *num_parameters + var_num_cells + ((num_params + num_params_1)* (multi_obj_cnt-1));

        OAM_LOG(OAM, OAM_DETAILED, "Carrier Meas partial path ");

        max_multi_obj_cnt = num_carrier_meas;
        multi_obj_cnt = OAM_ZERO;
        inst_num = OAM_ZERO;
        /**** Get Parameter's Info ****/ 
        do {

            inst_num+=OAM_ONE;
            /*Carrier Meas  */
            oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
            /* spr_21013_fix_start */
            oam_sprintf(par_name,"InternetGatewayDevice.Services.FAPService.REM.LTE.Cell.[1].CarrierMeas.");
            /* spr_21013_fix_end */
            g_parameter_map_element = g_parameter_son_rem_lte_carrierMeas;
            num_params_2 = ARRSIZE(g_parameter_son_rem_lte_carrierMeas);
            if(num_params_2   > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)
            {
                OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
                        "response are greater than the maximum limit allowed, "
                        "sending an error response.");

                OAM_FUN_EXIT_TRACE();
                return OAM_FAILURE;

            }

            for(loop = OAM_ZERO; loop < num_params_2; ++loop) {
                oam_memset(par_dot_param, OAM_ZERO,
                        (MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH));

                /* Actual handling for partial parent GPV */
                oam_strncpy(par_dot_param, par_name, oam_strlen(par_name));

                oam_snprintf(par_dot_param + oam_strlen(par_name),OAM_FOUR, 
                        "[%d]", inst_num);
                parameter_token =
                    OAM_STRRCHR(g_parameter_map_element[loop].
                            parameter_name, '.');
                if(parameter_token) {
                    oam_memcpy(par_dot_param + oam_strlen(par_dot_param),
                            parameter_token, oam_strlen(parameter_token));
                }

                oam_memset(param_val_pair, OAM_ZERO, PARAM_VAL_PAIR_MAX_LEN);
                retVal = oam_get_param_value(par_dot_param, param_val_pair, &p_error_code);
                if(OAM_ZERO == retVal)
                {
                    OAM_LOG(OAM, OAM_WARNING, "OAM GET PARAM RETURNED FAILURE");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                    break;
                }

                oam_sprintf(param_val_pair_remlte, "CarrierMeas.[%d].%s",inst_num, param_val_pair); 
                p_temp_buf += param_name_len;
                param_val_pair_len = oam_strlen(param_val_pair_remlte) + OAM_ONE;
                param_info_len = param_val_pair_len + OAM_FOUR;
                *(temp_payload + curr_pos++) = (param_info_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
                *(temp_payload + curr_pos++) = (param_info_len & OAM_ALL_8_BIT_SET);
                *(temp_payload + curr_pos++) = OAM_ZERO;
                *(temp_payload + curr_pos++) = OAM_ZERO;
                oam_memcpy((temp_payload + curr_pos),
                        param_val_pair_remlte, param_val_pair_len);
                *resp_len += param_info_len;
                curr_pos += param_val_pair_len;
            }

        }while(++multi_obj_cnt < max_multi_obj_cnt);

        *num_parameters = *num_parameters + (num_params_2* num_carrier_meas);
        OAM_LOG(OAM,OAM_DETAILED,"Number of parameters in GPV partial path for REM LTE ::%d ",*num_parameters );

        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;

    }

/*  coverity 86727 fix start */
/*****************************************************************
 *FUNCTION NAME: rrm_oam_preamble_init_rec_target_pow_mapping
 *DESCRIPTION  : This function maps the ra_preambles_group_a
 *
 *Inputs       :
 *Output       :
 *RETURNS      :
 ***********************************************************************/
rrm_oam_preamble_init_rec_target_pow_et rrm_oam_preamble_init_rec_target_pow_mapping(
       son_preamble_init_rec_target_pow_et  in_preamble_init_rec_target_pow)
{
    switch(in_preamble_init_rec_target_pow)
    {
    case SON_OAM_PREAMBLE_POWER_DBM_120:
        return RRM_OAM_PREAMBLE_POWER_DBM_120;
    case SON_OAM_PREAMBLE_POWER_DBM_118:
        return RRM_OAM_PREAMBLE_POWER_DBM_118;
    case SON_OAM_PREAMBLE_POWER_DBM_116:
        return RRM_OAM_PREAMBLE_POWER_DBM_116;
    case SON_OAM_PREAMBLE_POWER_DBM_114:
        return RRM_OAM_PREAMBLE_POWER_DBM_114;
    case SON_OAM_PREAMBLE_POWER_DBM_112:
        return RRM_OAM_PREAMBLE_POWER_DBM_112;
    case SON_OAM_PREAMBLE_POWER_DBM_110:
        return RRM_OAM_PREAMBLE_POWER_DBM_110;
    case SON_OAM_PREAMBLE_POWER_DBM_108:
        return RRM_OAM_PREAMBLE_POWER_DBM_108;
    case SON_OAM_PREAMBLE_POWER_DBM_106:
        return RRM_OAM_PREAMBLE_POWER_DBM_106;
    case SON_OAM_PREAMBLE_POWER_DBM_104:
        return RRM_OAM_PREAMBLE_POWER_DBM_104;
    case SON_OAM_PREAMBLE_POWER_DBM_102:
        return RRM_OAM_PREAMBLE_POWER_DBM_102;
    case SON_OAM_PREAMBLE_POWER_DBM_100:
        return RRM_OAM_PREAMBLE_POWER_DBM_100;
    case SON_OAM_PREAMBLE_POWER_DBM_98:
        return RRM_OAM_PREAMBLE_POWER_DBM_98;
    case SON_OAM_PREAMBLE_POWER_DBM_96:
        return RRM_OAM_PREAMBLE_POWER_DBM_96;
    case SON_OAM_PREAMBLE_POWER_DBM_94:
        return RRM_OAM_PREAMBLE_POWER_DBM_94;
    case SON_OAM_PREAMBLE_POWER_DBM_92:
        return RRM_OAM_PREAMBLE_POWER_DBM_92;
    case SON_OAM_PREAMBLE_POWER_DBM_90:
        return RRM_OAM_PREAMBLE_POWER_DBM_90;
    default:
    /*  coverity 96482 fix start */
        return RRM_OAM_PREAMBLE_POWER_UNDEFINED;
    /*  coverity 96482 fix end */
    }
}
/*  coverity 86727 fix end */

/*  coverity 86733 fix start */
/*****************************************************************
 *FUNCTION NAME: rrm_oam_ra_preambles_group_a_mapping
 *DESCRIPTION  : This function maps the ra_preambles_group_a
 *
 *Inputs       :
 *Output       :
 *RETURNS      :
 ***********************************************************************/
rrm_oam_ra_preambles_group_a_size_et rrm_oam_ra_preambles_group_a_mapping(
        son_oam_ra_preambles_group_a_size_et in_ra_preambles_group_a)
{
    switch(in_ra_preambles_group_a)
    {
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N4:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N4;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N8:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N8;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N16:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N16;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N20:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N20;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N24:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N24;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N28:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N28;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N32:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N32;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N36:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N36;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N40:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N40;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N44:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N44;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N48:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N48;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N52:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N52;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N56:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N56;
        case SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N60:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N60;
        default:
            return RRM_OAM_RA_PREAMBLE_GROUP_A_UNDEFINED;
    }
}
/*  coverity 86733 fix end */

/*  coverity 86734 fix start */
/*****************************************************************
 *FUNCTION NAME: rrm_oam_number_of_ra_preambles_mapping
 *DESCRIPTION  : This function maps the ra_preambles_group_a
 *
 *Inputs       :
 *Output       :
 *RETURNS      :
 ***********************************************************************/
rrm_oam_ra_preamble_count_et rrm_oam_number_of_ra_preambles_mapping(
        son_oam_ra_preamble_count_et in_number_of_ra_preambles)
{

    switch(in_number_of_ra_preambles)
    {
        case SON_OAM_RA_PREAMBLE_COUNT_N4:
            return RRM_OAM_RA_PREAMBLE_COUNT_N4;
        case SON_OAM_RA_PREAMBLE_COUNT_N8:
            return RRM_OAM_RA_PREAMBLE_COUNT_N8;
        case SON_OAM_RA_PREAMBLE_COUNT_N12:
            return RRM_OAM_RA_PREAMBLE_COUNT_N12;
        case SON_OAM_RA_PREAMBLE_COUNT_N16:
            return RRM_OAM_RA_PREAMBLE_COUNT_N16;
        case SON_OAM_RA_PREAMBLE_COUNT_N20:
            return RRM_OAM_RA_PREAMBLE_COUNT_N20;
        case SON_OAM_RA_PREAMBLE_COUNT_N24:
            return RRM_OAM_RA_PREAMBLE_COUNT_N24;
        case SON_OAM_RA_PREAMBLE_COUNT_N28:
            return RRM_OAM_RA_PREAMBLE_COUNT_N28;
        case SON_OAM_RA_PREAMBLE_COUNT_N32:
            return RRM_OAM_RA_PREAMBLE_COUNT_N32;
        case SON_OAM_RA_PREAMBLE_COUNT_N36:
            return RRM_OAM_RA_PREAMBLE_COUNT_N36;
        case SON_OAM_RA_PREAMBLE_COUNT_N40:
            return RRM_OAM_RA_PREAMBLE_COUNT_N40;
        case SON_OAM_RA_PREAMBLE_COUNT_N44:
            return RRM_OAM_RA_PREAMBLE_COUNT_N44;
        case SON_OAM_RA_PREAMBLE_COUNT_N48:
            return RRM_OAM_RA_PREAMBLE_COUNT_N48;
        case SON_OAM_RA_PREAMBLE_COUNT_N52:
            return RRM_OAM_RA_PREAMBLE_COUNT_N52;
        case SON_OAM_RA_PREAMBLE_COUNT_N56:
            return RRM_OAM_RA_PREAMBLE_COUNT_N56;
        case SON_OAM_RA_PREAMBLE_COUNT_N60:
            return RRM_OAM_RA_PREAMBLE_COUNT_N60;
        case SON_OAM_RA_PREAMBLE_COUNT_N64:
            return RRM_OAM_RA_PREAMBLE_COUNT_N64;
        default:
            return RRM_OAM_RA_PREAMBLE_COUNT_UNDEFINED;
    }
}
/*  coverity 86734 fix end */

/******************************************************************************
 *  FUNCTION NAME: oam_set_son_parameter_update_for_reconfig
 *  DESCRIPTION  : This function oam set son parameter update forreconfig
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : oam_son_rach_opt_parameter_update_req,p_oam_rrm_cell_reconfig_req
 *  Output       : p_oam_rrm_cell_reconfig_req 
 *  RETURNS      :None 
 ******************************************************************************/

void oam_set_son_parameter_update_for_reconfig
( 
 oam_son_rach_opt_parameter_update_req_t oam_son_rach_opt_parameter_update_req ,
 oam_rrm_cell_reconfig_req_t *p_oam_rrm_cell_reconfig_req
 )
{
	OAM_FUN_ENTRY_TRACE();

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_NUM_OF_RA_PREAMBLES_PRESENT)
	{
		p_oam_rrm_cell_reconfig_req->ran_info.mac_layer_params.
			mac_layer_param_rach.preamble_info.
			number_of_ra_preambles	= 
			/*Coverity FIX 54319 */
            /*  coverity 86734 fix start */
			rrm_oam_number_of_ra_preambles_mapping(oam_son_rach_opt_parameter_update_req.update_param.
			number_of_ra_preambles);		
            /*  coverity 86734 fix end */
	}

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PREAMBLE_INIT_RCVD_TGT_PWR_PRESENT )
	{
		p_oam_rrm_cell_reconfig_req->ran_info.mac_layer_params.
			mac_layer_param_rach.preamble_initial_received_target_power = 
			/*Coverity FIX 54318 */
/*  coverity 82727 fix start */
			rrm_oam_preamble_init_rec_target_pow_mapping(oam_son_rach_opt_parameter_update_req.update_param.
			preamble_initial_rcvd_target_power);
/*  coverity 82727 fix end */
	}

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_SIZE_OF_RA_GROUP_A_PRESENT )
	{
		p_oam_rrm_cell_reconfig_req->ran_info.mac_layer_params.
			mac_layer_param_rach.preamble_info.
			ra_preamble_groupA_info.size_of_ra_group_a = 
			/*Coverity FIX 54320 */
            /*  coverity 86733 fix start */
			rrm_oam_ra_preambles_group_a_mapping(oam_son_rach_opt_parameter_update_req.update_param.
			size_of_ra_group_a);		
            /*  coverity 86733 fix end */
	}

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_ROOT_SEQ_IDX_PRESENT )
	{
		p_oam_rrm_cell_reconfig_req->ran_info.
			physical_layer_params.physical_layer_param_prach.
			root_sequence_index = 
			oam_son_rach_opt_parameter_update_req.update_param.
			root_sequence_index;
	}	

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PRACH_FREQ_OFFSET_PRESENT )
	{
		p_oam_rrm_cell_reconfig_req->ran_info.
			physical_layer_params.physical_layer_param_prach.
			frequency_offset = 
			oam_son_rach_opt_parameter_update_req.update_param.
			prach_frequency_offset;
	}

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PRACH_CONFIG_IDX_PRESENT )
	{
		p_oam_rrm_cell_reconfig_req->ran_info.
			physical_layer_params.physical_layer_param_prach.
			configuration_index = 
			oam_son_rach_opt_parameter_update_req.update_param.
			prach_configuration_index;
	}
	OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *  FUNCTION NAME: oam_set_son_parameter_update_for_cell_info
 *  DESCRIPTION  : This function oam set son parameter update for cell info
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : oam_son_rach_opt_parameter_update_req,p_oam_rrm_cell_info_ind
 *  Output       : None
 *  RETURNS: OAM_FAILURE/OAM_SUCCESS
 ******************************************************************************/
void oam_set_son_parameter_update_for_cell_info
( 
 oam_son_rach_opt_parameter_update_req_t oam_son_rach_opt_parameter_update_req ,
 oam_son_cell_info_ind_t *p_oam_son_cell_info_ind  
 )
{
	/* Cov 54867 Fix*/
	OAM_FUN_ENTRY_TRACE();

	oam_counter_t temp_src_cgi_cnt = OAM_ZERO;

	/*SPR 21702 Start*/
       /*In oam_son_cell_info_ind only one serving cell info present so this
       loop execute only once.*/
        
        for (temp_src_cgi_cnt = OAM_ZERO; temp_src_cgi_cnt <
			OAM_ONE;
			temp_src_cgi_cnt++)
	{
	/*SPR 21702 End*/

		if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_NUM_OF_RA_PREAMBLES_PRESENT)
		{
			p_oam_son_cell_info_ind->serving_cell[temp_src_cgi_cnt].number_of_ra_preambles = 	
				oam_son_rach_opt_parameter_update_req.update_param.
				number_of_ra_preambles;		
		}

		if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PREAMBLE_INIT_RCVD_TGT_PWR_PRESENT )
		{
			p_oam_son_cell_info_ind->serving_cell[temp_src_cgi_cnt].preamble_initial_rcvd_target_power = 	
				oam_son_rach_opt_parameter_update_req.update_param.
				preamble_initial_rcvd_target_power;		
		}

		if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_SIZE_OF_RA_GROUP_A_PRESENT )
		{
			p_oam_son_cell_info_ind->serving_cell[temp_src_cgi_cnt].size_of_ra_group_a = 	
				oam_son_rach_opt_parameter_update_req.update_param.
				size_of_ra_group_a;		
		}

		if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_ROOT_SEQ_IDX_PRESENT )
		{
			p_oam_son_cell_info_ind->serving_cell[temp_src_cgi_cnt].prach_config.root_sequence_index = 	
				oam_son_rach_opt_parameter_update_req.update_param.
				root_sequence_index;
		}	

		if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PRACH_FREQ_OFFSET_PRESENT )
		{
			p_oam_son_cell_info_ind->serving_cell[temp_src_cgi_cnt].prach_config.prach_frequency_offset  = 	
				oam_son_rach_opt_parameter_update_req.update_param.
				prach_frequency_offset;
		}

		if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PRACH_CONFIG_IDX_PRESENT )
		{
			p_oam_son_cell_info_ind->serving_cell[temp_src_cgi_cnt].prach_config.prach_configuration_index  = 	
				oam_son_rach_opt_parameter_update_req.update_param.
				prach_configuration_index;
		}
	}
	OAM_FUN_EXIT_TRACE();
}


/******************************************************************************
 *  FUNCTION NAME: oam_set_bitmask_for_son_parameter_update_req
 *  DESCRIPTION  : This function oam set bitmask for son parameter update req
 *  trigger point is SNMP or CLI.
 *
 *  Inputs       : oam_son_rach_opt_parameter_update_req 
 *  Output       : p_oam_rrm_cell_config_req  
 *  RETURNS      : None
 ******************************************************************************/

void 
oam_set_bitmask_for_son_parameter_update_req
(
 oam_rrm_cell_reconfig_req_t *p_oam_rrm_cell_config_req,
 oam_son_rach_opt_parameter_update_req_t oam_son_rach_opt_parameter_update_req 
 )
{
	OAM_FUN_ENTRY_TRACE();

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_NUM_OF_RA_PREAMBLES_PRESENT)
	{
		p_oam_rrm_cell_config_req->bitmask |= 
			RRM_OAM_RAN_INFO_PRESENT; 	
		p_oam_rrm_cell_config_req->ran_info.bitmask |= 
			RRM_OAM_MAC_LAYER_PARAMS_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.mac_layer_params.bitmask |= 
			RRM_OAM_MAC_LAYER_PARAM_RACH_PRESENT;

	}

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PREAMBLE_INIT_RCVD_TGT_PWR_PRESENT )
	{
		p_oam_rrm_cell_config_req->bitmask |=
			RRM_OAM_RAN_INFO_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.bitmask |= 
			RRM_OAM_MAC_LAYER_PARAMS_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.mac_layer_params.bitmask |= 
			RRM_OAM_MAC_LAYER_PARAM_RACH_PRESENT;

	}

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_SIZE_OF_RA_GROUP_A_PRESENT )
	{
		p_oam_rrm_cell_config_req->bitmask |=
			RRM_OAM_RAN_INFO_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.bitmask |= 
			RRM_OAM_MAC_LAYER_PARAMS_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.mac_layer_params.bitmask |= 
			RRM_OAM_MAC_LAYER_PARAM_RACH_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.mac_layer_params.mac_layer_param_rach.
			preamble_info.bitmask |=
			RRM_OAM_RA_PREABLE_GROUPA_INFO_PRESENT; 
	}

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_ROOT_SEQ_IDX_PRESENT )
	{
		p_oam_rrm_cell_config_req->bitmask |=
			RRM_OAM_RAN_INFO_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.bitmask |= 
			RRM_OAM_PHY_LAYER_PARAMS_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.physical_layer_params.bitmask |= 
			RRM_OAM_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT;
	}	

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PRACH_FREQ_OFFSET_PRESENT )
	{
		p_oam_rrm_cell_config_req->bitmask |=
			RRM_OAM_RAN_INFO_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.bitmask |= 
			RRM_OAM_PHY_LAYER_PARAMS_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.physical_layer_params.bitmask |= 
			RRM_OAM_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT;
	}

	if(oam_son_rach_opt_parameter_update_req.update_param.bitmask & SON_UPDATE_PRACH_CONFIG_IDX_PRESENT )
	{
		p_oam_rrm_cell_config_req->bitmask |=
			RRM_OAM_RAN_INFO_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.bitmask |= 
			RRM_OAM_PHY_LAYER_PARAMS_PRESENT;
		p_oam_rrm_cell_config_req->ran_info.physical_layer_params.bitmask |= 
			RRM_OAM_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT;
	}

	OAM_FUN_EXIT_TRACE();
}

/* RT SPR 8154 FIX START */

/****************************************************************************
 * Function Name : set_bitmask_son_geran_t_reselection
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/

	void
set_bitmask_son_geran_t_reselection(int    loop,
		void *p_req)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_local_req =
		(oam_son_inter_freq_carrier_t*)p_req;
	oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
		&p_local_req->oam_son_anr_meas_config_req;

	p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
		bitmask |= SON_MC_GERAN_RESELECTION_PRESENT;

	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_son_geran_t_reselection_sf
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
	void
set_bitmask_son_geran_t_reselection_sf(int   loop,
		void *p_req)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_local_req =
		(oam_son_inter_freq_carrier_t*)p_req;
	oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req =
		&p_local_req->oam_son_anr_meas_config_req;

	p_son_anr_meas_config_req->other_rat_config_list.geran_config_list.
		bitmask |= SON_MC_GERAN_RESELECTION_SF_PRESENT;

	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_son_geran_qrxlevmin
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
void
set_bitmask_son_geran_qrxlevmin
(
 int  loop,
 void * p_son_inter_freq_carr_params
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].
		bitmask |= SON_GERAN_CFI_Q_RX_LEV_MIN_PRESENT;

	OAM_FUN_EXIT_TRACE();
}



/****************************************************************************
 * Function Name : set_bitmask_son_geran_ncc_permitted
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/

void
set_bitmask_son_geran_ncc_permitted
(
 int  loop,
 void * p_son_inter_freq_carr_params
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].
		bitmask |= SON_GERAN_CFI_NCC_PERMITTED_PRESENT;

	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_son_geran_pmax_geran
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/

	void
set_bitmask_son_geran_pmax_geran(int                          loop,
		void * p_son_inter_freq_carr_params)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].
		bitmask |= SON_GERAN_CFI_MAX_ALLOWED_TRANS_PWR_PRESENT;

	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_son_geran_cell_reselection_priority
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/

void
set_bitmask_son_geran_cell_reselection_priority
(
 int                     loop,
 void * p_son_inter_freq_carr_params
 )
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].
		bitmask |= SON_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT;

	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_son_geran_threshX_low
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
	void
set_bitmask_son_geran_threshX_low(int                          loop,
		void * p_son_inter_freq_carr_params)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].
		bitmask |= SON_GERAN_CFI_THRESH_LOW_PRESENT;

	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_son_geran_threshX_high
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/

	void
set_bitmask_son_geran_threshX_high(int                          loop,
		void * p_son_inter_freq_carr_params)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].
		bitmask |= SON_GERAN_CFI_THRESH_HIGH_PRESENT;

	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_son_geran_arfcn_spacing
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/
	void
set_bitmask_son_geran_arfcn_spacing(int                          loop,
		void * p_son_inter_freq_carr_params)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].geran_car_freqs.
		following_arfcns.bitmask |= SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT;

	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_son_geran_arfcn_bitmap
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/

	void
set_bitmask_son_geran_arfcn_bitmap(int                          loop,
		void * p_son_inter_freq_carr_params)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].geran_car_freqs.
		following_arfcns.bitmask |= SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT;

	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 * Function Name : set_bitmask_son_geran_offset_freq
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ***************************************************************************/

	void
set_bitmask_son_geran_offset_freq(int                          loop,
		void *p_son_inter_freq_carr_params)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].
		bitmask |= SON_GERAN_CFI_OFFSET_FREQ_PRESENT;

	OAM_FUN_EXIT_TRACE();
}


/****************************************************************************
 * Function Name : set_bitmask_son_geran_exp_arfcn_list
 * Description   : This function will check for validation of parameter
 * Inputs        : loop, cell_reconfig_req
 * Output        : none
 * Return        : none
 ****************************************************************************/

	void
set_bitmask_son_geran_exp_arfcn_list(int                          loop,
		void * p_son_inter_freq_carr_params)
{
	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);
	oam_son_inter_freq_carrier_t *p_son_req = p_son_inter_freq_carr_params;
	UInt8 idx = p_son_req->query_index;

	p_son_req->oam_son_anr_meas_config_req.other_rat_config_list.
		geran_config_list.geran_freq_info_list[idx].geran_car_freqs.
		following_arfcns.bitmask |= SON_MC_GERAN_EXP_ARFCN_SET_PRESENT;

	OAM_FUN_EXIT_TRACE();
}

#endif
/* RT SPR 8154 FIX END */ 
/* CSR 00051709 Change Start*/
/******************************************************************************
 *  FUNCTION NAME: oam_mme_ip_analysis 
 *  DESCRIPTION  : This function analys the close/add MME connecton's IP 
 *      
 *  Inputs       : mme_ip_addr
 *  Output       : 
 *  RETURNS: OAM_SUCCESS/OAM_FAILURE
 ******************************************************************************/
oam_return_et 
oam_mme_ip_analysis(
		oam_s1SigLinkServerList_t * oam_add_mme_req,
		oam_s1SigLinkServerList_t * oam_close_mme_req, 
		oam_s1SigLinkServerList_t * oam_reestablish_mme_req)
{
	UInt8 temp_str[1000] = {OAM_ZERO};
	UInt8 new_list_counter=OAM_ZERO;
	UInt8 add_counter=OAM_ZERO;
	UInt8 close_counter=OAM_ZERO;
	UInt8 reestablish_counter=OAM_ZERO;
	UInt8 old_ip_loop_cntr = OAM_ZERO;
	UInt8 new_ip_loop_cntr= OAM_ZERO;
	UInt8 *new_ip_list[16]={OAM_NULL};
	UInt8 *temp_ip_list=OAM_NULL;
	UInt8 flag_found = OAM_ZERO;
	OAM_FUN_ENTRY_TRACE();

	OAM_LOG(OAM, OAM_DETAILED, "Analyzing Weather MME Needs to ADD/REESTBLISG or Close");

	oam_strncpy((char *)temp_str,(char *)local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList,sizeof(local_prov_req.oam_igd_params.fap_control_params.S1SigLinkServerList));
	temp_ip_list = temp_str;
	new_ip_list[new_list_counter] = (UInt8 *)oam_strtok((char *)temp_ip_list,",");
	while(new_ip_list[new_list_counter])
	{
		new_ip_list[++new_list_counter]=(UInt8 *)oam_strtok(OAM_NULL,",");
	}
	/* For loop to find close and reestablish mme info */   
	for(old_ip_loop_cntr = OAM_ZERO;(old_ip_loop_cntr < oam_siglink_server_info.num_ip_addr); old_ip_loop_cntr++)
	{
		flag_found = OAM_ZERO; 
		for(new_ip_loop_cntr = OAM_ZERO;(new_ip_loop_cntr < new_list_counter && new_ip_loop_cntr < 16);new_ip_loop_cntr++)
		{
			if(oam_strcmp((char *)new_ip_list[new_ip_loop_cntr],(char *)oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].ip_addr)==OAM_ZERO)
			{      
				if(oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].status == OAM_ADD_MME)
				{
					flag_found++; 
					break;
				}
				else if(oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].status == OAM_CLOSE_MME)
				{
					flag_found++; 
					oam_strcpy((char *)oam_reestablish_mme_req->oam_mme_info[reestablish_counter].ip_addr,
							(char *)oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].ip_addr);
					reestablish_counter++;
					oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].status = OAM_ADD_MME;
					oam_reestablish_mme_req->num_ip_addr++;
					break;
				}
			}
		}
		if(flag_found == OAM_ZERO)
		{
			if(oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].status  != OAM_CLOSE_MME)
			{ 
				oam_strcpy((char *)oam_close_mme_req->oam_mme_info[close_counter].ip_addr,
						(char *)oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].ip_addr);
				oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].status = OAM_CLOSE_MME;
				oam_close_mme_req->num_ip_addr++;
				close_counter++;
			}
		}
	}
	/* For loop to find add mme info */
	for(new_ip_loop_cntr = OAM_ZERO;(new_ip_loop_cntr < new_list_counter && new_ip_loop_cntr < 16);new_ip_loop_cntr++)
	{
		flag_found = OAM_ZERO;
		for(old_ip_loop_cntr = OAM_ZERO;(old_ip_loop_cntr < oam_siglink_server_info.num_ip_addr); old_ip_loop_cntr++)
		{   
			if(oam_strcmp((char *)oam_siglink_server_info.oam_mme_info[old_ip_loop_cntr].ip_addr,(char *)new_ip_list[new_ip_loop_cntr])==OAM_ZERO)
			{
				flag_found++; 
				break;
			}
		}  
		if(flag_found == OAM_ZERO)
		{
			oam_strcpy((char *)oam_add_mme_req->oam_mme_info[add_counter].ip_addr,(char *)new_ip_list[new_ip_loop_cntr]);
			add_counter++;
			oam_add_mme_req->num_ip_addr++;
			/* Adding Entry in Global MME Context also */ 
			oam_siglink_server_info.num_ip_addr++;
			oam_strcpy((char *)oam_siglink_server_info.oam_mme_info[oam_siglink_server_info.num_ip_addr-OAM_ONE].ip_addr,
					(char *)new_ip_list[new_ip_loop_cntr]);
			oam_siglink_server_info.oam_mme_info[oam_siglink_server_info.num_ip_addr-OAM_ONE].status = OAM_ADD_MME;
		}
	}
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS; 
}
/******************************************************************************
 * *  FUNCTION NAME: oam_handle_add_mme_req 
 * *  DESCRIPTION  : This function uesd to handle add mme_req 
 * *      
 * *  Inputs       : oam_add_mme_req 
 * *  Output       : 
 * *  RETURNS: OAM_SUCCESS/OAM_FAILURE
 * ******************************************************************************/
	oam_return_et
oam_handle_add_mme_req(oam_s1SigLinkServerList_t * oam_add_mme_req, UInt16 trans_id,UInt16 msg_len,UInt8 *p_api_buf)
{
	OAM_FUN_ENTRY_TRACE();

	UInt8 index = OAM_ZERO;
	oam_s1ap_add_mme_req_t oam_s1ap_add_mme_req = {0};

	oam_s1ap_add_mme_req.num_mme = oam_add_mme_req->num_ip_addr; 
	for(index = OAM_ZERO; index < oam_add_mme_req->num_ip_addr; index++)
	{
		if(oam_isValidIp4((UInt8 *)oam_add_mme_req->oam_mme_info[index].ip_addr)==OAM_ONE)
		{
			oam_strcpy((char *)oam_s1ap_add_mme_req.mme_comm_info_arr[index].ip_addr[OAM_ZERO].ip_addr,
					(char *)oam_add_mme_req->oam_mme_info[index].ip_addr);   
			oam_s1ap_add_mme_req.mme_comm_info_arr[index].num_ip_addr++;
			OAM_LOG(OAM, OAM_DETAILED, "MME IP:%s is Valid Ipv4 type",oam_add_mme_req->oam_mme_info[index].ip_addr); 
			OAM_LOG(OAM, OAM_DETAILED, "Sending ADD MME For IP:%s",oam_add_mme_req->oam_mme_info[index].ip_addr); 
		}
		else if (oam_isValidIp6((UInt8 *)oam_add_mme_req->oam_mme_info[index].ip_addr)==OAM_ONE) 
		{
			oam_strcpy((char *)oam_s1ap_add_mme_req.mme_comm_info_arr[index].ipv6_addr[OAM_ZERO].ipv6_addr,
					(char *)oam_add_mme_req->oam_mme_info[index].ip_addr);  
			oam_s1ap_add_mme_req.mme_comm_info_arr[index].num_ipv6_addr++; 
			oam_s1ap_add_mme_req.mme_comm_info_arr[index].bitmask |= MME_COMM_INFO_IPV6_NUM_ADDR_PRESENT;
			oam_strcpy((char *)oam_s1ap_add_mme_req.mme_comm_info_arr[index].ip_addr[OAM_ZERO].ip_addr,"127.0.0.1");
			oam_s1ap_add_mme_req.mme_comm_info_arr[index].num_ip_addr++; 
			OAM_LOG(OAM, OAM_DETAILED, "MME IP:%s is Valid Ipv6 type",oam_add_mme_req->oam_mme_info[index].ip_addr); 
			OAM_LOG(OAM, OAM_DETAILED, "Sending ADD MME For IP:%s",oam_add_mme_req->oam_mme_info[index].ip_addr); 
		}
		else 
		{
			OAM_LOG(OAM,OAM_DETAILED,"Invalid IP Received");
			return OAM_FAILURE;
		}  
		/*Filling Mendatory Para With Default Value Populated from cfg File */
		oam_s1ap_add_mme_req.mme_comm_info_arr[index].num_streams = oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.
			s1apInfo.mme_comm_info[OAM_ZERO].num_streams; 
		oam_s1ap_add_mme_req.mme_comm_info_arr[index].port= oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.
			s1apInfo.mme_comm_info[OAM_ZERO].port;
		oam_s1ap_add_mme_req.mme_comm_info_arr[index].rel_of_mme = oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
			mme_comm_info[OAM_ZERO].rel_of_mme; 
	}

	OAM_LOG(OAM, OAM_DETAILED, "Sending S1AP_ADD_MME_REQ to RRC");
	if(OAM_FAILURE == oam_s1apCommon_send_s1ap_add_mme_req(
				&oam_s1ap_add_mme_req,
				OAM_MODULE_ID,
				RRC_MODULE_ID,
				trans_id,
				oam_prov_req.cell_cntxt.curr_cell_cid))
	{
		OAM_LOG(OAM,OAM_ERROR,"Error in sending S1AP_ADD_MME_REQ To RRC, cell_index = %d",
                oam_prov_req.cell_cntxt.curr_cell_cid);
		OAM_FUN_EXIT_TRACE ();
		return OAM_FAILURE;
	}
	else
	{
		OAM_LOG(OAM, OAM_DETAILED, "S1AP_ADD_MME_REQ Successfully sent");
		/* SPR 9620 CHANGE START */
#ifndef OAM_UT_FRAMEWORK
		if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRC,
					OAM_TRANS_RRC,msg_len,p_api_buf))
		{
			OAM_LOG(OAM, OAM_DETAILED, " Failed to maintain TCB ");
			return OAM_FAILURE;
		}
#endif
		/* SPR 9620 CHANGE END */
	}

	g_flag_add_mme_sent = OAM_TRUE;
	OAM_FUN_EXIT_TRACE();

	return OAM_SUCCESS;
}
/************************************************************************
 * *  FUNCTION NAME: oam_handle_reestablish_mme_conn_req 
 * *  DESCRIPTION  : This function uesd to handle reestablish mme 
 * *      
 * *  Inputs       : oam_s1ap_reestablish_mme_req 
 * *  Output       : 
 * *  RETURNS: OAM_SUCCESS/OAM_FAILURE
 * **********************************************************************/

	oam_return_et
oam_handle_reestablish_mme_conn_req(oam_s1SigLinkServerList_t * oam_s1ap_reestablish_mme_req)
{
	/* Cov Cid 62090 Fix */
	OAM_FUN_ENTRY_TRACE();

	UInt8 index = OAM_ZERO; 
	UInt8 index_1 = OAM_ZERO; 
	UInt8 transid = OAM_ZERO;
	oam_s1ap_reestab_mme_conn_t s1ap_reestab_mme_conn = {OAM_ZERO};
	for(index = OAM_ZERO; index < oam_s1ap_reestablish_mme_req->num_ip_addr;index++)
	{
		for(index_1= OAM_ZERO; index_1 < g_oam_connected_mme_info.num_mme;index_1++)
		{
			if(oam_strcmp((char *)oam_s1ap_reestablish_mme_req->oam_mme_info[index].ip_addr,
						(char *)g_oam_connected_mme_info.oam_s1ap_mme_info[index_1].ip_addr)==OAM_ZERO)
			{
				s1ap_reestab_mme_conn.mme_id[s1ap_reestab_mme_conn.mme_count] = 
					g_oam_connected_mme_info.oam_s1ap_mme_info[index_1].mme_id;
				break;
			}
		}
		OAM_LOG(OAM, OAM_DETAILED,"Sending Reestablish MME for IP:%s",oam_s1ap_reestablish_mme_req->oam_mme_info[index].ip_addr); 
	}
	s1ap_reestab_mme_conn.mme_count= oam_s1ap_reestablish_mme_req->num_ip_addr;
	OAM_LOG(OAM, OAM_DETAILED, "IP Received is Already ADDED Earlier Sending MME Restablishment Connection req to RRC");

	if(OAM_FAILURE == oam_s1ap_il_send_s1ap_oam_reestab_mme_conn(
				&s1ap_reestab_mme_conn,
				OAM_MODULE_ID,
				RRC_MODULE_ID,
				transid,
				oam_prov_req.cell_cntxt.curr_cell_cid))
	{
		OAM_LOG(OAM,OAM_ERROR,"Error in sending S1AP_OAM_REESTAB_MME_CONN Request To RRC");
		OAM_FUN_EXIT_TRACE ();
		return OAM_FAILURE;
	}
	OAM_FUN_EXIT_TRACE ();
	return OAM_SUCCESS;
}
/************************************************************************
 * *  FUNCTION NAME: oam_handle_close_mme_req
 * *  DESCRIPTION  : This function uesd to handle reestablish mme 
 * *      
 * *  Inputs       : oam_s1ap_close_mme_req 
 * *  Output       : 
 * *  RETURNS: OAM_SUCCESS/OAM_FAILURE
 * **********************************************************************/
	oam_return_et
oam_handle_close_mme_req(oam_s1SigLinkServerList_t * oam_s1ap_close_mme_req)
{
	UInt8 index = OAM_ZERO;
	UInt8 transid = OAM_ZERO;
	UInt8 index_1=OAM_ZERO;

	OAM_FUN_ENTRY_TRACE();
	oam_s1ap_close_mme_conn_t s1ap_close_mme_conn = {OAM_ZERO}; /* COV CID 57696 FIX*/

	for(index = OAM_ZERO; index < oam_s1ap_close_mme_req->num_ip_addr; index++)
	{
		for(index_1= OAM_ZERO; index_1 < g_oam_connected_mme_info.num_mme;index_1++)
		{
			if(oam_strcmp((char *)oam_s1ap_close_mme_req->oam_mme_info[index].ip_addr,
						(char *)g_oam_connected_mme_info.oam_s1ap_mme_info[index_1].ip_addr)==OAM_ZERO)
			{
				s1ap_close_mme_conn.mme_id[s1ap_close_mme_conn.mme_count] = g_oam_connected_mme_info.oam_s1ap_mme_info[index_1].mme_id;
				break;
			}

		}
		OAM_LOG(OAM,OAM_DETAILED,"Sending S1AP_OAM_CLOSE_MME_CONN Request for IP:%s",oam_s1ap_close_mme_req->oam_mme_info[index].ip_addr); 
	}
	s1ap_close_mme_conn.mme_count = oam_s1ap_close_mme_req->num_ip_addr;
	OAM_LOG(OAM, OAM_DETAILED, "Sending S1AP_OAM_CLOSE_MME_CONN Request to MME Which Not contain in SPV");

	if (OAM_FAILURE ==oam_s1ap_il_send_s1ap_oam_close_mme_conn(
				&s1ap_close_mme_conn,
				OAM_MODULE_ID,
				RRC_MODULE_ID,
				transid,
				oam_prov_req.cell_cntxt.curr_cell_cid))
	{
		OAM_LOG(OAM,OAM_ERROR,"Error in sending S1AP_OAM_CLOSE_MME_CONN Request To RRC");
		OAM_FUN_EXIT_TRACE ();
		return OAM_FAILURE;
	}
	OAM_FUN_EXIT_TRACE ();/* Coverity CID 62089 Fix*/
	return OAM_SUCCESS;
} 
/* CSR 00051709 Change End*/

/* SPR 13542 START */
/************************************************************************
 * *  FUNCTION NAME: oam_update_s1ap_enb_config
 * *  DESCRIPTION  : This function update the enb_config_info
 * *  Inputs       :
 * *  Output       :
 * *  RETURNS      : OAM_SUCCESS/OAM_FAILURE
 * **********************************************************************/
/* + SPR 17439 */
	oam_return_et
oam_update_s1ap_enb_config(void)
{
/* - SPR 17439 */
	/* Coverity 69690 Fix Start */
	oam_return_et ret_Val = OAM_FAILURE;
	UInt8 index = OAM_ZERO;
    /* SPR_19279_START */
    UInt8 plmn_idx = OAM_ZERO;
    UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    /* SPR 19977 Fix START */
    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(cid);
    if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
	    OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
			    cid);
	    return  OAM_FAILURE;
    }
    /* SPR 19977 Fix End  */
    /* SPR_19279_END */
	bc_plmn_list_t local_bc_plmnList = {OAM_ZERO};

	OAM_FUN_ENTRY_TRACE();

	/* Check if eNBName has been updated */

	/* SPR 12901 START */
	/* SPR 18866 START */
	if (oam_strncmp((void *)&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.enb_name,
				(void *)&local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].access_mgmt_params.hnb_name,
				oam_strlen((char *)local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].access_mgmt_params.hnb_name)) != OAM_ZERO)
	/* SPR 18866 END */
	{
		OAM_LOG(OAM,OAM_DETAILED,"Updating ENBName");
		oam_memset(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.enb_name,
				OAM_ZERO,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.enb_name));
	/* SPR 18866 START */

		oam_memcpy((void *)&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.enb_name,
				(void *)&local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].access_mgmt_params.hnb_name,
				oam_strlen((char *)local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].access_mgmt_params.hnb_name));
	/* SPR 18866 END */

		local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |= S1AP_OAM_ENB_CONFIG_UPDATE_ENB_NAME_PRESENT;
		ret_Val = OAM_SUCCESS;
	}

	/* SPR 12901 END*/

	/* Check if TAC has been updated */
	if (oam_memcmp((void *)&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].tac,
				(void *)&local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].epc_info.epc_params.general_epc_params.tac,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].tac)))

	{
		OAM_LOG(OAM,OAM_DETAILED,"Updating TAC");
		oam_memset(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].tac,
				OAM_ZERO,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].tac));

		oam_memcpy((void *)&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].tac,
				(void *)&local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].epc_info.epc_params.general_epc_params.tac,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].tac));

		local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |= S1AP_OAM_ENB_CONFIG_UPDATE_TA_LIST_PRESENT;
		ret_Val = OAM_SUCCESS;
	}
	/* Check if CSGID has been updated */
	if (oam_memcmp((void *)&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.csg_ids[OAM_ZERO].csg_id,
				(void *)&local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].access_mgmt_params.csg_id,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.csg_ids[OAM_ZERO].csg_id)))

	{
		OAM_LOG(OAM,OAM_DETAILED,"Updating CSGID");
		oam_memset(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.csg_ids[OAM_ZERO].csg_id,
				OAM_ZERO,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.csg_ids[OAM_ZERO].csg_id));

		oam_memcpy((void *)&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.csg_ids[OAM_ZERO].csg_id,
				(void *)&local_prov_req.oam_rrm_req.oam_rrm_cell_config_req[OAM_ZERO].access_mgmt_params.csg_id,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.csg_id_list.csg_ids[OAM_ZERO].csg_id));

		local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |= S1AP_OAM_ENB_CONFIG_UPDATE_CSG_ID_LIST_PRESENT;
		ret_Val = OAM_SUCCESS;
	}
	/* Check if PLMNList has been updated */


    /* SPR_19279_START */
    /* SPR 19977 Fix START */
        for(index = OAM_ZERO; index < oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].curr_plmn_entries; index++)
	{
		if((oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].is_valid_bitmap)&(1<< index)&&
                  (oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries[index].enable==OAM_ONE))
	{
			oam_update_plmnlist_from_mcc_mnc(&oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries[index].plmn_id,plmn_idx,&(local_bc_plmnList));
    /* SPR 19977 Fix End */
			plmn_idx++;
		}
	}

	local_bc_plmnList.num_bplmn = plmn_idx;
    /* SPR_19279_END */

	if(oam_memcmp(&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list,
				(void *)&local_bc_plmnList,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list)))
	{
		OAM_LOG(OAM,OAM_DETAILED,"Updating PLMNList");
		oam_memset(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity,
				OAM_ZERO,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity));
		oam_memcpy((void *)&local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list,
				(void *)&local_bc_plmnList,
				sizeof(local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list));

    /* SPR_19279_START */
		local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.num_bplmn =
			plmn_idx;
    /* SPR_19279_END */

		local_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.bitmask |= S1AP_OAM_ENB_CONFIG_UPDATE_TA_LIST_PRESENT;
		ret_Val = OAM_SUCCESS;
	}

	OAM_FUN_EXIT_TRACE ();
	return ret_Val;
	/* Coverity 69690 Fix End */
}
/* SPR 13542 END */



/************************************************************************
 * *  FUNCTION NAME: oam_update_enb_config_info_from_current_mme_list
 * *  DESCRIPTION  : This function update the enb_config_info from current mme list 
 * *      
 * *  Inputs       :  
 * *  Output       : 
 * *  RETURNS      :
 * **********************************************************************/

/* + SPR 17439 */
void oam_update_enb_config_info_from_current_mme_list(void)
{
/* - SPR 17439 */
	oam_memset(&oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.s1ap_oam_mme_id_list,0,sizeof(oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.s1ap_oam_mme_id_list));
	int loop=OAM_ZERO,loop2=OAM_ZERO,list_counter=OAM_ZERO;
	for(loop=OAM_ZERO;loop<oam_siglink_server_info.num_ip_addr;loop++)
	{
		if(oam_siglink_server_info.oam_mme_info[loop].status==OAM_ADD_MME)
		{
			for(loop2=OAM_ZERO;loop2<g_oam_connected_mme_info.num_mme;loop2++)
			{
				if(oam_strcmp((char *)oam_siglink_server_info.oam_mme_info[loop].ip_addr,(char *)g_oam_connected_mme_info.oam_s1ap_mme_info[loop2].ip_addr)==OAM_ZERO)
				{
					oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.s1ap_oam_mme_id_list.mme_id[list_counter++]=g_oam_connected_mme_info.oam_s1ap_mme_info[loop2].mme_id;

				}
			}   
		}
	}
	oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.s1ap_oam_mme_id_list.num_mme_id=list_counter;	
}
/* SPR 9678 Fix Start */
#ifdef OAM_SON_ENABLE
/*  coverity 86725 fix start */
/*****************************************************************
 *FUNCTION NAME: son_oam_ra_preambles_group_a_mapping
 *DESCRIPTION  : This function maps the ra_preambles_group_a
 *
 *Inputs       :
 *Output       :
 *RETURNS      :
 ***********************************************************************/
son_oam_ra_preambles_group_a_size_et son_oam_ra_preambles_group_a_mapping(
        rrm_oam_ra_preambles_group_a_size_et in_ra_preambles_group_a)
{
    switch(in_ra_preambles_group_a)
    {
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N4:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N4;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N8:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N8;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N12;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N16:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N16;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N20:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N20;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N24:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N24;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N28:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N28;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N32:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N32;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N36:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N36;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N40:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N40;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N44:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N44;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N48:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N48;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N52:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N52;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N56:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N56;
        case RRM_OAM_RA_PREAMBLE_GROUP_A_SIZE_N60:
            return SON_OAM_RA_PREAMBLE_GROUP_A_SIZE_N60;
        default:
            return SON_OAM_RA_PREAMBLE_GROUP_A_UNDEFINED;
    }
}
/*  coverity 86725 fix end */

/*  coverity 86730 fix start */
/*****************************************************************
 *FUNCTION NAME: son_oam_number_of_ra_preambles_mappingg
 *DESCRIPTION  : This function maps the ra_preambles_group_a
 *
 *Inputs       :
 *Output       :
 *RETURNS      :
 ***********************************************************************/
son_oam_ra_preamble_count_et son_oam_number_of_ra_preambles_mapping(
        rrm_oam_ra_preamble_count_et in_number_of_ra_preambles)
{

    switch(in_number_of_ra_preambles)
    {
        case RRM_OAM_RA_PREAMBLE_COUNT_N4:
            return SON_OAM_RA_PREAMBLE_COUNT_N4;
        case RRM_OAM_RA_PREAMBLE_COUNT_N8:
            return SON_OAM_RA_PREAMBLE_COUNT_N8;
        case RRM_OAM_RA_PREAMBLE_COUNT_N12:
            return SON_OAM_RA_PREAMBLE_COUNT_N12;
        case RRM_OAM_RA_PREAMBLE_COUNT_N16:
            return SON_OAM_RA_PREAMBLE_COUNT_N16;
        case RRM_OAM_RA_PREAMBLE_COUNT_N20:
            return SON_OAM_RA_PREAMBLE_COUNT_N20;
        case RRM_OAM_RA_PREAMBLE_COUNT_N24:
            return SON_OAM_RA_PREAMBLE_COUNT_N24;
        case RRM_OAM_RA_PREAMBLE_COUNT_N28:
            return SON_OAM_RA_PREAMBLE_COUNT_N28;
        case RRM_OAM_RA_PREAMBLE_COUNT_N32:
            return SON_OAM_RA_PREAMBLE_COUNT_N32;
        case RRM_OAM_RA_PREAMBLE_COUNT_N36:
            return SON_OAM_RA_PREAMBLE_COUNT_N36;
        case RRM_OAM_RA_PREAMBLE_COUNT_N40:
            return SON_OAM_RA_PREAMBLE_COUNT_N40;
        case RRM_OAM_RA_PREAMBLE_COUNT_N44:
            return SON_OAM_RA_PREAMBLE_COUNT_N44;
        case RRM_OAM_RA_PREAMBLE_COUNT_N48:
            return SON_OAM_RA_PREAMBLE_COUNT_N48;
        case RRM_OAM_RA_PREAMBLE_COUNT_N52:
            return SON_OAM_RA_PREAMBLE_COUNT_N52;
        case RRM_OAM_RA_PREAMBLE_COUNT_N56:
            return SON_OAM_RA_PREAMBLE_COUNT_N56;
        case RRM_OAM_RA_PREAMBLE_COUNT_N60:
            return SON_OAM_RA_PREAMBLE_COUNT_N60;
        case RRM_OAM_RA_PREAMBLE_COUNT_N64:
            return SON_OAM_RA_PREAMBLE_COUNT_N64;
        default:
            return SON_OAM_RA_PREAMBLE_COUNT_UNDEFINED;
    }

}
/*  coverity 86730 fix end */

/*  coverity 86731 fix start */
/*****************************************************************
 *FUNCTION NAME: son_preamble_initial_received_target_power_mapping
 *DESCRIPTION  : This function maps the ra_preambles_group_a
 *
 *Inputs       :
 *Output       :
 *RETURNS      :
 ***********************************************************************/
son_preamble_init_rec_target_pow_et son_preamble_initial_received_target_power_mapping(
        rrm_oam_preamble_init_rec_target_pow_et in_preamble_initial_received_target_power)
{
    switch(in_preamble_initial_received_target_power)
    {
        case RRM_OAM_PREAMBLE_POWER_DBM_120:
            return SON_OAM_PREAMBLE_POWER_DBM_120;
        case RRM_OAM_PREAMBLE_POWER_DBM_118:
            return SON_OAM_PREAMBLE_POWER_DBM_118;
        case RRM_OAM_PREAMBLE_POWER_DBM_116:
            return SON_OAM_PREAMBLE_POWER_DBM_116;
        case RRM_OAM_PREAMBLE_POWER_DBM_114:
            return SON_OAM_PREAMBLE_POWER_DBM_114;
        case RRM_OAM_PREAMBLE_POWER_DBM_112:
            return SON_OAM_PREAMBLE_POWER_DBM_112;
        case RRM_OAM_PREAMBLE_POWER_DBM_110:
            return SON_OAM_PREAMBLE_POWER_DBM_110;
        case RRM_OAM_PREAMBLE_POWER_DBM_108:
            return SON_OAM_PREAMBLE_POWER_DBM_108;
        case RRM_OAM_PREAMBLE_POWER_DBM_106:
            return SON_OAM_PREAMBLE_POWER_DBM_106;
        case RRM_OAM_PREAMBLE_POWER_DBM_104:
            return SON_OAM_PREAMBLE_POWER_DBM_104;
        case RRM_OAM_PREAMBLE_POWER_DBM_102:
            return SON_OAM_PREAMBLE_POWER_DBM_102;
        case RRM_OAM_PREAMBLE_POWER_DBM_100:
            return SON_OAM_PREAMBLE_POWER_DBM_100;
        case RRM_OAM_PREAMBLE_POWER_DBM_98:
            return SON_OAM_PREAMBLE_POWER_DBM_98;
        case RRM_OAM_PREAMBLE_POWER_DBM_96:
            return SON_OAM_PREAMBLE_POWER_DBM_96;
        case RRM_OAM_PREAMBLE_POWER_DBM_94:
            return SON_OAM_PREAMBLE_POWER_DBM_94;
        case RRM_OAM_PREAMBLE_POWER_DBM_92:
            return SON_OAM_PREAMBLE_POWER_DBM_92;
        case RRM_OAM_PREAMBLE_POWER_DBM_90:
            return SON_OAM_PREAMBLE_POWER_DBM_90;
        default:
        /*  coverity 96483 fix start */
            return SON_OAM_PREAMBLE_POWER_UNDEFINED;
        /*  coverity 96483 fix end */
    }
}
/*  coverity 86731 fix end */

/*****************************************************************
 *FUNCTION NAME: oam_update_son_cell_info_ind_af_reconfig 
 *DESCRIPTION  : This function updates the son cell info 
 *   
 *Inputs       :  
 *Output       : 
 *RETURNS      :
 ***********************************************************************/
oam_return_et oam_update_son_cell_info_ind_af_reconfig(UInt16 idx, UInt8 cell_config_idx)
{
	OAM_FUN_ENTRY_TRACE();

	son_cell_t *p_cell = &SON_CELL_INFO_IND_SERVING_CELL(idx);
	rrm_oam_cell_config_req_t *p_cell_config_req =
		&RRM_CELL_CONFIG(cell_config_idx);
	oam_return_et ret_val  = OAM_SUCCESS;

	p_cell->pci = p_cell_config_req->ran_info.rf_params.
		rf_configurations.phy_cell_id;

	oam_memcpy(p_cell->tac,
			p_cell_config_req->epc_info.epc_params.general_epc_params.tac,
			RRM_OAM_MAX_NUM_TAC_OCTETS);

	oam_memcpy(p_cell->src_cgi.cell_identity,
			p_cell_config_req->global_cell_info.
			eutran_global_cell_id.cell_identity,
			MAX_CELL_IDENTITY_OCTETS);

    /* SPR_19279_START */
    oam_memcpy(&p_cell->src_cgi.plmn_id,
            &p_cell_config_req->global_cell_info.
            eutran_global_cell_id.primary_plmn_id,
            sizeof(rrm_oam_cell_plmn_info_t));
    /* SPR_19279_END */

	/* SPR 12214 FIX START */
	if (p_cell_config_req->ran_info.rf_params.rf_configurations.
			bitmask & RRM_OAM_RF_CONFIGURATION_UL_EARFCN_PRESENT) {
		p_cell->choice_eutra_mode.fdd_info.ul_earfcn =
			p_cell_config_req->ran_info.rf_params.rf_configurations.ul_earfcn;

		p_cell->choice_eutra_mode.fdd_info.dl_earfcn =
	    p_cell_config_req->ran_info.rf_params.rf_configurations.dl_earfcn;

		p_cell->choice_eutra_mode.fdd_info.dl_trnsmission_bdwidth =
			p_cell_config_req->ran_info.rf_params.rf_configurations.
			dl_bandwidth;
	}
	else {
		p_cell->choice_eutra_mode.tdd_info.earfcn =
		p_cell_config_req->ran_info.rf_params.rf_configurations.dl_earfcn;

		p_cell->choice_eutra_mode.tdd_info.trnsmission_bdwidth =
			p_cell_config_req->ran_info.rf_params.
			rf_configurations.dl_bandwidth;

		p_cell->choice_eutra_mode.tdd_info.subframe_assn =
			p_cell_config_req->ran_info.physical_layer_params.
			physical_layer_param_tdd_frame_structure.sub_frame_assignment;

		p_cell->choice_eutra_mode.tdd_info.special_subframe_info.
			special_subframe_patterns =
			p_cell_config_req->ran_info.
			physical_layer_params.
			physical_layer_param_tdd_frame_structure.
			special_sub_frame_patterns;
	}
	/* SPR 12214 FIX END */
	oam_memcpy(p_cell->csg_identity,
			p_cell_config_req->access_mgmt_params.
			csg_id,SON_CSG_ID_OCTET_SIZE);
	/* coverity 61066 */

    /*  coverity 86371 fix start */
	p_cell-> preamble_initial_rcvd_target_power =
		son_preamble_initial_received_target_power_mapping(p_cell_config_req->ran_info.
		mac_layer_params.
		mac_layer_param_rach.preamble_initial_received_target_power);
    /*  coverity 86371 fix end */

	/* coverity 61067 */
	p_cell->size_of_ra_group_a =
    /*  coverity 86725 fix start */
		son_oam_ra_preambles_group_a_mapping(p_cell_config_req->ran_info.
		mac_layer_params.mac_layer_param_rach.preamble_info.
		ra_preamble_groupA_info.size_of_ra_group_a);
    /*  coverity 86725 fix end */

	p_cell->prach_config.root_sequence_index = p_cell_config_req->ran_info.
		physical_layer_params.physical_layer_param_prach.root_sequence_index;

	p_cell->prach_config.zero_correlation_zone_config =
		p_cell_config_req->ran_info.physical_layer_params.
		physical_layer_param_prach.zero_correlation_zone_config;

	p_cell->prach_config.high_speed_flag = p_cell_config_req->ran_info.
		physical_layer_params.
		physical_layer_param_prach.high_speed_flag;

	p_cell->prach_config.prach_frequency_offset = p_cell_config_req->ran_info.
		physical_layer_params.
		physical_layer_param_prach.frequency_offset;

	/* coverity 61065 */

    /*  coverity 86730 fix start */
	p_cell->number_of_ra_preambles =
		son_oam_number_of_ra_preambles_mapping(p_cell_config_req->
		ran_info.mac_layer_params.
		mac_layer_param_rach.preamble_info.number_of_ra_preambles);
    /*  coverity 86730 fix end */
    
	p_cell->pusch_hopping_offset = p_cell_config_req->ran_info.
		physical_layer_params.physical_layer_param_pusch.hopping_offset;

	/*SPR 14154 start*/
	/*SPR 14554 start*/
	/*deleted*/
	/*SPR 14554 end*/
	/*SPR 14154 end*/


	OAM_FUN_EXIT_TRACE();

	return ret_val;
}



#endif
/* SPR 9678 Fix End*/

/* BUG 1080 FIX START */
/************************************************************************
 *FUNCTION NAME: oam_admin_state_changed
 *DESCRIPTION  : This function update the admin state and 
 *                            sends the cell block request to RRM
 *Inputs       : src_module_id,transaction_id 
 *Output       : NONE
 *RETURNS      :OAM_SUCCESS / OAM_FAILURE
 *************************************************************************/

oam_return_et oam_admin_state_changed(
		U16                 src_module_id,  /* Source module identifier */
		U16                 transaction_id  /* Interface transaction identifier */
		)
{
	/* Cov CID 62472 Fix */
	SInt8 cell_config_idx = OAM_ERROR_RETURN_VAL;
	cell_config_idx = oam_get_rrm_cell_config_idx(
			oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}
	OAM_FUN_ENTRY_TRACE();
	oam_rrm_cell_block_req_t    oam_rrm_cell_block={OAM_ZERO};

	OAM_LOG(OAM, OAM_INFO, "Admin State Changed from Unlocked to Locked");

	oam_rrm_cell_block.bitmask = OAM_ZERO;

	oam_memcpy(&(oam_rrm_cell_block.global_cell_id),
			&(oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.eutran_global_cell_id),
			sizeof(oam_rrm_cell_block.global_cell_id));

	oam_rrm_cell_block.cell_block_priority = (rrm_oam_cell_block_priority_et)OAM_ZERO; /* High Priority */

	if(OAM_FAILURE == oam_rrm_send_rrm_oam_cell_block_req(
				&oam_rrm_cell_block,
				src_module_id,
				RRM_MODULE_ID,
				transaction_id,
				oam_prov_req.cell_cntxt.curr_cell_cid))
	{
		OAM_LOG(OAM, OAM_ERROR, "Sending RRM_OAM_CELL_BLOCK_REQ Failed");
		OAM_FUN_EXIT_TRACE ();
		return OAM_FAILURE;
	}
	OAM_FUN_EXIT_TRACE ();
	return OAM_SUCCESS;
}

#ifdef OAM_SON_ENABLE
/************************************************************************
 *FUNCTION NAME: oam_update_son_mro_config_params
 *DESCRIPTION  : This function updates the static copy of oam_prov_req
 *               for mro_modify_config_params_req structure when a success
 *               response is received from SON in API:
 *               SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP
 *Inputs       : directly uses the global strucutres hence no direct inputs
 *Output       : NONE
 *RETURNS      : NONE
 *************************************************************************/
	void
oam_update_son_mro_config_params(son_intra_rat_global_cell_id_t *p_srv_cgi)
{
	UInt8 idx = OAM_ZERO;
	oam_son_mro_modify_config_params_req_t
		*p_master_struct = &SON_PROV_REQ.mro_modify_config_params_req[0];
	oam_son_mro_modify_config_params_req_t
		*p_local_struct = &LOCAL_SON_PROV_REQ.mro_modify_config_params_req[0];

	while (idx < oam_prov_req.num_cells_configured) {
		if (!oam_memcmp(p_srv_cgi, &p_local_struct->srv_cgi,
					sizeof(son_intra_rat_global_cell_id_t))) {
			oam_memcpy(&p_master_struct->srv_cgi,
					&p_local_struct->srv_cgi,
					sizeof(son_intra_rat_global_cell_id_t));

			p_master_struct->eutran_config_params.
				bitmask |= p_local_struct->eutran_config_params.bitmask;

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_MODE_PRESENT) {
				p_master_struct->eutran_config_params.mro_mode =
					p_local_struct->eutran_config_params.mro_mode;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_PARAM_PRESENT) {
				p_master_struct->eutran_config_params.mro_param =
					p_local_struct->eutran_config_params.mro_param;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_HO_FAILURE_ACCUMULATION_DURATION_PRESENT) {
				p_master_struct->eutran_config_params.
					mro_ho_failure_accumulation_duration =
					p_local_struct->eutran_config_params.
					mro_ho_failure_accumulation_duration;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_DELTA_CIO_PRESENT) {
				p_master_struct->eutran_config_params.delta_cio =
					p_local_struct->eutran_config_params.delta_cio;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_HO_ATTEMPTS_THRESHOLD_PRESENT) {
				p_master_struct->eutran_config_params.
					mro_ho_attempts_threshold =
					p_local_struct->eutran_config_params.
					mro_ho_attempts_threshold;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_HO_OPTIMIZATION_START_THRESHOLD_PRESENT) {
				p_master_struct->eutran_config_params.
					mro_ho_optimization_start_threshold =
					p_local_struct->eutran_config_params.
					mro_ho_optimization_start_threshold;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_HO_OPTIMIZATION_STOP_THRESHOLD_PRESENT) {
				p_master_struct->eutran_config_params.
					mro_ho_optimization_stop_threshold =
					p_local_struct->eutran_config_params.
					mro_ho_optimization_stop_threshold;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_HO_FAIL_RATE_FOR_OPTIMIZATION_PRESENT) {
				p_master_struct->eutran_config_params.
					mro_ho_fail_rate_for_optimization =
					p_local_struct->eutran_config_params.
					mro_ho_fail_rate_for_optimization;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_TTT_PRESENT) {
				p_master_struct->eutran_config_params.ttt =
					p_local_struct->eutran_config_params.ttt;
			}

			if (p_local_struct->eutran_config_params.
					bitmask & SON_MRO_DELTA_TTT_PRESENT) {
				p_master_struct->eutran_config_params.delta_ttt =
					p_local_struct->eutran_config_params.delta_ttt;
			}

			OAM_LOG(OAM, OAM_DETAILED, "MRO config paramters updated");
			break;
		}

		++p_local_struct;
		++idx;
	}
}

/************************************************************************
 *FUNCTION NAME: oam_update_son_mlb_config_params
 *DESCRIPTION  : This function updates the static copy of oam_prov_req
 *               for mlb_modify_attributes_req structure when a success
 *               response is received from SON in API:
 *               SON_OAM_MRO_MODIFY_CONFIG_PARAM_RESP
 *Inputs       : directly uses the global strucutres hence no direct inputs
 *Output       : NONE
 *RETURNS      : NONE
 *************************************************************************/
	void
oam_update_son_mlb_config_params(son_intra_rat_global_cell_id_t *p_srv_cgi)
{
	UInt8 idx = OAM_ZERO;
	oam_son_mlb_modify_attributes_req_t
		*p_master_struct = &SON_PROV_REQ.mlb_modify_attributes_req[0];
	oam_son_mlb_modify_attributes_req_t
		*p_local_struct = &LOCAL_SON_PROV_REQ.mlb_modify_attributes_req[0];

	while (idx < oam_prov_req.num_cells_configured) {
		if (!oam_memcmp(p_srv_cgi, &p_local_struct->srv_cgi,
					sizeof(son_intra_rat_global_cell_id_t))) {
			oam_memcpy(&p_master_struct->srv_cgi,
					&p_local_struct->srv_cgi,
					sizeof(son_intra_rat_global_cell_id_t));

			p_master_struct->bitmask |= p_local_struct->bitmask;

			if (p_local_struct->bitmask &
					SON_OAM_MLB_EUTRA_Q_OFFSET_CONFIG_PRESENT) {
				p_master_struct->eutra_q_offset_config.
					bitmask |= p_local_struct->eutra_q_offset_config.bitmask;

				if (p_local_struct->eutra_q_offset_config.
						bitmask & SON_OAM_MLB_Q_OFF_MIN_PRESENT) {
					p_master_struct->eutra_q_offset_config.q_offset_min =
						p_local_struct->eutra_q_offset_config.q_offset_min;
				}

				if (p_local_struct->eutra_q_offset_config.
						bitmask & SON_OAM_MLB_Q_OFF_MAX_PRESENT) {
					p_master_struct->eutra_q_offset_config.q_offset_max =
						p_local_struct->eutra_q_offset_config.q_offset_max;
				}
			}

			if (p_local_struct->bitmask & SON_OAM_MLB_MODE_PRESENT) {
				p_master_struct->mlb_mode = p_local_struct->mlb_mode;
			}

			OAM_LOG(OAM, OAM_DETAILED, "MLB config paramters updated");

			break;
		}

		++p_local_struct;
		++idx;
	}
}
#endif

/************************************************************************
 *FUNCTION NAME: oam_get_cell_state_string 
 *DESCRIPTION  : This Function Return the cell state string
 *Inputs       : current cell_state  
 *Output       : char * 
 *RETURNS      : cell state string
 *************************************************************************/
/* COV Cid 63715 Fix */
	Char8 *
oam_get_cell_state_string(UInt32 cell_state)
{
	OAM_FUN_ENTRY_TRACE ();
	if(OAM_CELL_ACTIVE & cell_state)
	{
		OAM_FUN_EXIT_TRACE ();
		return "ACTIVE"; 
	}
	else if(OAM_CELL_STOP & cell_state)
	{
		OAM_FUN_EXIT_TRACE ();
		return "STOP"; 
	}
	else if (OAM_CELL_IDLE & cell_state)
	{
		OAM_FUN_EXIT_TRACE ();
		return "IDEAL"; 
	}
	else
	{
		OAM_LOG (OAM, OAM_WARNING, "cell state passed is not valid.");
		OAM_FUN_EXIT_TRACE ();
		return "Invalid";
	}
}


/* SPR 11001 FIX START */
/************************************************************************
 *FUNCTION NAME: oam_get_err_string_n_err_code 
 *DESCRIPTION  : This Function takes internal error code as oam_error_code_et
 *               and returns corresponding user friendly error string and
 *               error code
 *Inputs       : err_code
 *Output       : usr_err_code,
 *               err_str
 *RETURNS      : NONE
 *************************************************************************/
void oam_get_err_string_n_err_code(oam_error_code_et err_code,
		/* SPR 11001 FIX END */
		UInt16 *usr_err_code,
		Char8 **err_str)
{
	UInt16 idx = 0;

	for (idx = 0; idx < OAM_MAX_NUM_INTERNAL_ERR_CODE; ++idx) {
		if (err_code == ERROR_STR[idx].internal_err_code) {
			*err_str =  ERROR_STR[idx].err_str;
			*usr_err_code = ERROR_STR[idx].usr_err_code;
			break;
		}
	}

	if (idx == OAM_MAX_NUM_INTERNAL_ERR_CODE) {
		*err_str = "Internal error";
		*usr_err_code = OAM_ERR_INTERNAL_ERROR;
	}
}

/* SPR 11001 FIX START */
/************************************************************************
 *FUNCTION NAME: oam_commit_local_load_config_data 
 *DESCRIPTION  : This Function commits all the updated local load config
 *               data after a success response is received from RRM for
 *               RRM_OAM_LOAD_CONFIG_REQ
 *Inputs       : p_local_req
 *Output       : NONE
 *RETURNS      : NONE
 *************************************************************************/
void oam_commit_local_load_config_data(oam_rrm_load_config_req_t *p_local_req)
{

	OAM_FUN_ENTRY_TRACE();
	UInt8 idx = OAM_ZERO;
	UInt8 num_cells = OAM_ZERO;

	if (p_local_req->bitmask & RRM_OAM_NCL_LOAD_IND_INTRVL_PRESENT) {
		RRM_PROV_REQ.oam_load_config_req.ncl_load_ind_intrvl =
			p_local_req->ncl_load_ind_intrvl;
		RRM_PROV_REQ.oam_load_config_req.
			bitmask |= RRM_OAM_NCL_LOAD_IND_INTRVL_PRESENT;
	}

	if (p_local_req->bitmask & RRM_OAM_LOAD_RPT_INTRVL_PRESENT) {
		RRM_PROV_REQ.oam_load_config_req.load_rpt_intrvl =
			p_local_req->load_rpt_intrvl;
		RRM_PROV_REQ.oam_load_config_req.
			bitmask |= RRM_OAM_LOAD_RPT_INTRVL_PRESENT;
	}

	if (p_local_req->bitmask & RRM_OAM_LOAD_CHK_PRDCTY_PRESENT) {
		RRM_PROV_REQ.oam_load_config_req.load_chk_periodicity =
			p_local_req->load_chk_periodicity;
		RRM_PROV_REQ.oam_load_config_req.
			bitmask |= RRM_OAM_LOAD_CHK_PRDCTY_PRESENT;
	}

	if (p_local_req->bitmask & RRM_OAM_HIGH_ACT_RPT_LMT_PRESENT) {
		RRM_PROV_REQ.oam_load_config_req.high_actn_repeat_lmt =
			p_local_req->high_actn_repeat_lmt;
		RRM_PROV_REQ.oam_load_config_req.
			bitmask |= RRM_OAM_HIGH_ACT_RPT_LMT_PRESENT;
	}
    /* SPR 20653 Fix Start */
	if (p_local_req->bitmask & RRM_OAM_TNL_LOAD_SUPPORT_FLAG_PRESENT) {
		RRM_PROV_REQ.oam_load_config_req.tnl_load_support_flag =
			p_local_req->tnl_load_support_flag;
		RRM_PROV_REQ.oam_load_config_req.
			bitmask |= RRM_OAM_TNL_LOAD_SUPPORT_FLAG_PRESENT;
	}

	if (p_local_req->bitmask & RRM_OAM_HW_LOAD_SUPPORT_FLAG_PRESENT) {
		RRM_PROV_REQ.oam_load_config_req.hw_load_support_flag =
			p_local_req->hw_load_support_flag;
		RRM_PROV_REQ.oam_load_config_req.
			bitmask |= RRM_OAM_HW_LOAD_SUPPORT_FLAG_PRESENT;
	}
    /* SPR 20653 Fix End */
	num_cells = p_local_req->num_enb_cells; 

	for ( ; num_cells && idx < RRM_PROV_REQ.oam_load_config_req.num_enb_cells;
			++idx) {
		if (!oam_memcmp(&p_local_req->serv_enb_cell_info[0].global_cell_id,
					&RRM_PROV_REQ.oam_load_config_req.
					serv_enb_cell_info[idx].global_cell_id,
					sizeof(rrm_oam_eutran_global_cell_id_t))) {
			oam_memcpy(&RRM_PROV_REQ.oam_load_config_req.
					serv_enb_cell_info[idx],
					&p_local_req->serv_enb_cell_info[0],
					sizeof(rrm_oam_serving_enb_cell_info_t));
		}
	}

	OAM_FUN_EXIT_TRACE();
}

/* SPR_19279_START */
/******************************************************************************
 * Function Name  : oam_handle_plmnlist_retrieve_req 
 * Inputs         : dst_id   : destination id of the user module
 *                : trans_id : transaction ID to be send to user module
 * Outputs        : 
 * Returns        : OAM_SUCCESS / OAM_FAILURE
 * Description    : handles PLMNLIST_RETRIEVE request and send response to user
 *******************************************************************************/
oam_return_et
oam_handle_plmnlist_retrieve_req
(
 UInt16             dst_id,
 UInt16             resp_trans_id
)
{
    OAM_FUN_ENTRY_TRACE();
/* spr_21013_fix_start */
    Char8 parent_name[] = {"InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC.PLMNList"};
/* spr_21013_fix_end */
    UInt8 start_index = OAM_ZERO;
    UInt8 end_index = OAM_ZERO;
    UInt16 num_plmn_entries = OAM_ZERO;
    UInt16 count = OAM_ZERO;
    UInt16 param_cnt = OAM_ZERO;
    Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
    Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
    oam_error_code_et err = NO_ERROR;
    oam_return_et retVal = OAM_FAILURE;
	SInt8 arr_idx = OAM_ZERO;
	UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;

	arr_idx = oam_get_cell_plmnlist_data_idx(cid);
	oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;

    /* Coverity 109473 + */
	if(OAM_ERROR_RETURN_VAL == arr_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
			           oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}
    /* Coverity 109473 - */

	p_cell_plmnlist_data =
				&RRM_PROV_REQ.plmnlist_data[arr_idx];


	if(OAM_ERROR_RETURN_VAL == arr_idx) 
    {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         cid);
		return OAM_FAILURE;
	}
	
    num_plmn_entries = RRM_PROV_REQ.plmnlist_data[arr_idx].curr_plmn_entries;

	OAM_LOG(OAM, OAM_DETAILED,"num_plmn_entries %d ",num_plmn_entries);

    for(count = OAM_ZERO; count < 4 * RRM_OAM_MAX_NUM_PLMNS; ++count) {
        retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                (void**)&param_list[count], &err);

        if(OAM_FAILURE == retVal) 
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "Memory allocation to param_list failed"
                    " with Error Code:%d",
                    err);
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;
        }

        oam_memset(param_list[count], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
    }

    /* Coverity 109474 + */
    /* SPR 19977 Fix Start*/
    for(count = OAM_ZERO; count <RRM_OAM_MAX_NUM_PLMNS ; ++count) {
    /* SPR 19977 Fix End*/
    /* Coverity 109474 - */
        if(p_cell_plmnlist_data->is_valid_bitmap & (1 << count)) 
        {    
            /* Populate PLMN-ID */
            oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
           /* SPR 19977 Fix Start*/
            oam_generate_plmnid(temp_param,
                    &(RRM_PROV_REQ.plmnlist_data[arr_idx].plmn_entries[count].plmn_id));
            oam_snprintf(param_list[param_cnt],MAX_PARAMETER_NAME_LENGTH,
                    "[%d]PLMNID=%s", count+1, temp_param);
            OAM_LOG(OAM, OAM_DETAILED, "PLMNID of cell[%d]: %s, global num_plmn_entries %d, global bitmap %0x, Enable [%d]", count + OAM_ONE,
                    temp_param,num_plmn_entries,p_cell_plmnlist_data->is_valid_bitmap,
                    RRM_PROV_REQ.plmnlist_data[arr_idx].plmn_entries[count].enable);
            param_cnt++;
            /* Populate Cell-Identity */
            oam_snprintf(param_list[param_cnt],MAX_PARAMETER_NAME_LENGTH,
                    "[%d]Enable=%d", count+1, RRM_PROV_REQ.plmnlist_data[arr_idx].plmn_entries[count].enable);
            param_cnt++;

            oam_snprintf(param_list[param_cnt],MAX_PARAMETER_NAME_LENGTH,
                    "[%d]isPrimary=%d", count+1, RRM_PROV_REQ.plmnlist_data[arr_idx].plmn_entries[count].is_primary);
            param_cnt++;

            oam_snprintf(param_list[param_cnt],MAX_PARAMETER_NAME_LENGTH,
                    "[%d]CellReservedForOperatorUse=%d", count+1, RRM_PROV_REQ.plmnlist_data[arr_idx].plmn_entries[count].reserve_operator_use);
            param_cnt++;
           /* SPR 19977 Fix End*/
            OAM_LOG(OAM, OAM_DETAILED, "param_cnt ",param_cnt);
        }
    }

    retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
            (UInt8**)param_list,
            param_cnt, resp_trans_id,
            &err, dst_id,
            start_index, end_index);
    if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Error in sending response to user with error code: %d",
                err);
    }

    for(count = OAM_ZERO; count < 4 * RRM_OAM_MAX_NUM_PLMNS; ++count) {
        retVal = oam_mem_free(param_list[count], &err);
        if (OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_WARNING,
                    "Error in memory free with error code: %d", err);

        }
    }

    return retVal;
}
/* SPR_19279_END */

#ifdef OAM_SON_ENABLE
/* SPR 11001 FIX END */
/* Start: SPR 10567 */
/******************************************************************************
 * Function Name  : oam_handle_son_nr_retrieve_eutran
 * Inputs         : dst_id   : destination id of the user module
 *                : trans_id : transaction ID to be send to user module
 *                : p_err    : Pointer to error variable
 * Outputs        : 
 * Returns        : OAM_SUCCESS / OAM_FAILURE
 * Description    : handles NR_RETIEVE request and send response to user
 *******************************************************************************/
oam_return_et
oam_handle_son_nr_retrieve_eutran
(
 UInt16             dst_id,
 UInt16             trans_id,
 oam_error_code_et  *p_err
 )
{
	OAM_FUN_ENTRY_TRACE();
	Char8 parent_name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
	UInt8 neighbor_array_idx = OAM_ZERO;
	UInt8 parameter_array_idx = OAM_ZERO;
	UInt8 num_plmn = OAM_ZERO;
	UInt8 num_neighbor = OAM_ZERO;
	Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	UInt8 num_of_param = OAM_ZERO;
	UInt8 start_index = OAM_ONE; 
	UInt8 end_index = OAM_ZERO;
	Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
	UInt32 value = OAM_ZERO;
	UInt16 parent_name_len = OAM_ZERO; 
	oam_return_et retVal = OAM_FAILURE;
	UInt64 plmnid = OAM_ZERO;
	UInt64 cid = OAM_ZERO;
    /*  coverity 85183 fix start */
	UInt8 instance = OAM_ZERO;
    /*  coverity 85183 fix end */

	UInt64 plmnid_atoi = OAM_ZERO;
	xmlNode *temp = NULL;
	xmlNode *p_xml_node = NULL;
	xmlNode *p_xml_node1 = NULL;
	xmlNode *p_xml_node2 = NULL;
	xmlChar *p_param_val = OAM_NULL;
	SInt8 cell_idx = oam_get_son_cell_nr_list_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

	if(OAM_ERROR_RETURN_VAL == cell_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}


    /* Spr 15438 Fix Start */
    UInt32 cid_value = OAM_ZERO;
	oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;
	p_son_nr_add = &SON_NR_ADD_REQ(cell_idx);
    /* Spr 15438 Fix End */

	parent_name_len =
/* spr_21013_fix_start */
		oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig"
				".LTE.RAN.NeighborList.LTECell") + OAM_ONE;
	oam_strncpy(parent_name, "InternetGatewayDevice.Services.FAPService."
/* spr_21013_fix_end */
			"CellConfig.LTE.RAN.NeighborList.LTECell",
			parent_name_len);

	end_index = SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list_size;

	OAM_LOG(OAM, OAM_DETAILED," total number of params %d ",end_index);

    /*SPR 19513 FIXED START */
/*SPR 22442 Fix Start*/
	for(num_neighbor = OAM_ZERO; ((num_neighbor < end_index) && (num_neighbor < SON_MAX_NO_INTRA_RAT_NEIGHBOUR_CELLS) && (neighbor_array_idx < SON_MAX_NO_INTRA_NBR_CELLS));) {
/*SPR 22442 Fix End*/
    /*SPR 19513 FIXED END */
		if ((SON_NEIGHBORLIST_INFO(cell_idx).intra_rat_nr_entry_bitmap) & (OAM_ONE << neighbor_array_idx))
        {
            /* Populate PLMN-ID */
            oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
            oam_generate_plmnid(temp_param, &(SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].nbr_cgi.plmn_id));

            /* Spr 15438 Fix Start */
            /* Code removed */

            /*  coverity 94788 fix start */
            /* code removed */
            /*  coverity 94788 fix end */

            oam_cmn_convert_byte_string_to_integer(
                    p_son_nr_add->nr_list.intra_rat_nr_list[neighbor_array_idx].nbr_cgi.cell_identity,
                    OAM_FOUR,
                    &cid_value,
                    OAM_MAX_INT_BITSTRING_SIZE - OAM_CELL_ID_BITSTRING_SIZE);


            /* Spr 15438 Fix End */		
            /* SPR 18930  FIX START */
            /* SPR 18930  FIX END */
            plmnid_atoi = oam_atoi((Char8*)temp_param);

            /* Populate Cell-Identity */
            oam_decode_bit_stream_into_eutran_cellidentity(
                    SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].nbr_cgi.
                    cell_identity,&value);

            /* SPR 18930  FIX START */

            OAM_LOG(OAM, OAM_DETAILED," plmnid %s cid %d ",temp_param ,value);
            /*  Instance id match code starts here */

            /* spr_21013_fix_start */
            temp = xml_struct_tr196_g.FAPService[cell_idx].CellConfig.LTECell[OAM_ZERO];
            /* spr_21013_fix_end */
            while(OAM_NULL != temp) {
                p_xml_node = oam_xml_find_tag(temp->children,
                        (xmlChar*)"PLMNID");
                if(p_xml_node != OAM_NULL) {	
                    p_param_val = xmlNodeGetContent(p_xml_node);
                    plmnid  = oam_atoi((Char8*)p_param_val);

                    if(plmnid_atoi == plmnid) {

                        p_xml_node1 = oam_xml_find_tag(temp->children,
                                (xmlChar*)"CID");
                        if(p_xml_node1 != OAM_NULL) {	
                            p_param_val = xmlNodeGetContent(p_xml_node1);
                            cid  = oam_atoi((Char8*)p_param_val);

                            OAM_LOG(OAM, OAM_DETAILED,"populated plmn %d cid %d plmnid_atoi %d value =%d",plmnid,cid,plmnid_atoi,value);
                            if (value == cid) {

                                p_xml_node2 = oam_xml_find_tag(temp->children,
                                        (xmlChar*)"X_VENDOR_INSTANCE_ID");
                                if(p_xml_node1 != OAM_NULL) {	
                                    p_param_val = xmlNodeGetContent(p_xml_node2);
                                    instance  = oam_atoi((Char8*)p_param_val);
                                    OAM_LOG(OAM, OAM_DETAILED,"IN LTE CELL Instance id corresponding to plmn %s cid %d is --: %d",temp_param ,value, instance);
                                    break;
                                }
                            }
                        }
                    }
                }
                /* Move to next instance of object */
                temp = (temp)->next;
            }

            /* Spr 15438 Fix Start */
            retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                    (void**)&param_list[parameter_array_idx], p_err);
            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to param_list failed"
                        " with Error Code:%d",
                        *p_err);
                OAM_FUN_EXIT_TRACE(); 
                return retVal;
            }
            oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

            oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                    /* SPR 18930  FIX END */
                    "Enable=%d", SON_NEIGHBORLIST_INFO(cell_idx).eutran_nbr_ctxt[neighbor_array_idx].enable);
            /* SPR 18930  FIX START */
            /*  coverity 85183 fix end */

            retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                    (void**)&param_list[parameter_array_idx], p_err);
            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to param_list failed"
                        " with Error Code:%d",
                        *p_err);
                OAM_FUN_EXIT_TRACE(); 
                return retVal;
            }
            oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

            /*  coverity 85183 fix start */
            oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                    /* SPR 18930  FIX START */
                    "MustInclude=%d", SON_NEIGHBORLIST_INFO(cell_idx).eutran_nbr_ctxt[neighbor_array_idx].must_include);
            /* SPR 18930  FIX END */
            /*  coverity 85183 fix end */

            retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                    (void**)&param_list[parameter_array_idx], p_err);
            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to param_list failed"
                        " with Error Code:%d",
                        *p_err);
                OAM_FUN_EXIT_TRACE(); 
                return retVal;
            }

            oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

            oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                    "PLMNID=%s", temp_param); 


            /* Populate Cell-Identity */

            retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                    (void**)&param_list[parameter_array_idx], p_err);
            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to param_list failed"
                        " with Error Code:%d",
                        *p_err);
                OAM_FUN_EXIT_TRACE(); 
                return retVal;
            }
            oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

            oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                    "CID=%d", cid_value);
            /* Spr 15438 Fix End */

            /* Populate PCI If present */
            if(SON_PCI_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }
                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "PhyCellID=%d",
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].pci);
            }

            if(SON_CELL_OFFSET_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate cell_specific_offset If present */

                oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
                oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
                        "%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].
                        cell_specific_offset);

                oam_search_integer_to_interger_for_get(temp_param,
                        RAN_NeighborList_LTECell_QOffset[OAM_ZERO], 31);

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }
                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "QOffset=%s", temp_param);
            }

            if(SON_TAC_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate tac If present */
                /*SPR 11315 Fix*/

                oam_cmn_convert_byte_string_to_short(
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].tac,
                        &value,OAM_MAX_SHORT_INT_BITSTRING_SIZE - OAM_TAC_BIT_STRING_SIZE);
                /*SPR 11315 end*/

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }

                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_TAC=%d", value);
            }

            if(SON_PLMN_ID_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate PLMN ID count If present */

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_NUM_PLMN_ID=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].num_plmn_id);

                /* Populate PLMN ID List If present */

                for(num_plmn = OAM_ZERO;
                        num_plmn < SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].num_plmn_id;
                        ++num_plmn) {
                    oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
                    oam_generate_plmnid(temp_param,
                            &(SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].plmn_id[num_plmn]));

                    retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                            (void**)&param_list[parameter_array_idx], p_err);
                    if(OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Memory allocation to param_list failed"
                                " with Error Code:%d",
                                *p_err);
                        OAM_FUN_EXIT_TRACE(); 
                        return retVal;
                    }
                    oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                            MAX_PARAMETER_NAME_LENGTH);

                    oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                            "X_VENDOR_PLMN_ID[%d]=%s", num_plmn + OAM_ONE,
                            temp_param);
                }
            }

            if(SON_INTRA_CSG_ID_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate csg_identity If present */
                oam_cmn_convert_csgid_to_integer(
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].csg_identity,
                        OAM_FOUR, &value);

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }

                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "X_VENDOR_CSG_IDENTITY=%d", value);
            }

            if(SON_EARFCN_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate earfcn If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }

                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "EUTRACarrierARFCN=%d",
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].earfcn);
            }

            if(SON_RSRP_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate rsrp If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }

                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_RSRP=%d",
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].rsrp);
            }

            if(SON_RSRQ_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate rsrq If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }

                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_RSRQ=%d",
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].rsrq);
            }

            if(SON_ENABLE_NR_STATUS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate nr_status If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }

                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_NR_STATUS=%d",
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].nr_status);
            }

            if(SON_ENABLE_HO_STATUS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate ho_status If present */
                oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
                oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
                        "%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].ho_status);
                oam_search_integer_to_interger_for_get(temp_param,
                        NR_Blacklisted[OAM_ZERO], 2);

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }

                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "Blacklisted=%s", temp_param);
            }

            if(SON_ENABLE_X2_STATUS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate x2_status If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "X_VENDOR_X2_STATUS=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].x2_status);

            }

            if(SON_EUTRAN_NR_HO_STATS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate handovers_attempted If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_HANDOVERS_ATTEMPTED=%d",
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].
                        handover_stats.handovers_attempted);

                /* Populate handovers_succesful If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "X_VENDOR_HANDOVERS_SUCCESFUL=%d",
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].
                        handover_stats.handovers_succesful);

                /* Populate handovers_failed If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE(); 
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "X_VENDOR_HANDOVERS_FAILED=%d",
                        SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].
                        handover_stats.handovers_failed);
            }

            if(SON_SUSPECT_PCI_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate suspected_pci If present */
                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_SUSPECTED_PCI=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].suspected_pci);
            }


            if(SON_CM_CELL_OFFSET_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate CIO If present */
                oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
                oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH,
                        "%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].
                        cm_cell_specific_offset);

                oam_search_integer_to_interger_for_get(temp_param,
                        RAN_NeighborList_LTECell_CIO[OAM_ZERO], 31);

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "CIO=%s", temp_param);
            }

            if(SON_BROADCAST_STATUS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate broadcast status If present */

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "X_VENDOR_BROADCAST_STATUS=%s", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].broadcast_status ?
                        "Enabled" : "Disabled");
            }

            if(SON_ACCESS_MODE_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate access mode If present */

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_ACCESS_MODE=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].access_mode);
            }

            if(SON_PRACH_CONFIGURATION_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {
                /* Populate Prach_Configuration ParameterIf present */

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "X_VENDOR_PRACH_ROOT_SEQUENCE_INDEX=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].prach_config.root_sequence_index);

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "X_VENDOR_PRACH_ZERO_CORRELATION_ZONE_CONFIG=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].prach_config.zero_correlation_zone_config);

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "X_VENDOR_PRACH_HIGH_SPEED_FLAG=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].prach_config.high_speed_flag);

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }


                oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                        MAX_PARAMETER_NAME_LENGTH);

                oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                        "X_VENDOR_PRACH_FREQUENCY_OFFSET=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].prach_config.prach_frequency_offset);

                retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                        (void**)&param_list[parameter_array_idx], p_err);
                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to param_list failed"
                            " with Error Code:%d",
                            *p_err);
                    OAM_FUN_EXIT_TRACE();
                    return retVal;
                }

                if(SON_PRACH_CONFIG_INDEX_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].prach_config.bitmask){
                    oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                            MAX_PARAMETER_NAME_LENGTH);

                    oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
                            "X_VENDOR_PRACH_CONFIGURATION_INDEX=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                            intra_rat_nr_list[neighbor_array_idx].prach_config.prach_configuration_index);

                    retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                            (void**)&param_list[parameter_array_idx], p_err);
                    if(OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Memory allocation to param_list failed"
                                " with Error Code:%d",
                                *p_err);
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }
                }
            }
            /*eICIC_PHASE_1_2_CHANGES_START */
            if(SON_EICIC_INFO_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                    intra_rat_nr_list[neighbor_array_idx].bitmask) {

                if(SON_CELL_INTF_SCHEME_TYPE_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].eicic_info.bitmask) {
                    retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                            (void**)&param_list[parameter_array_idx], p_err);
                    if(OAM_FAILURE == retVal) {
                        OAM_LOG(OAM, OAM_ERROR,
                                "Memory allocation to param_list failed"
                                " with Error Code:%d",
                                *p_err);
                        OAM_FUN_EXIT_TRACE();
                        return retVal;
                    }


                    oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                            MAX_PARAMETER_NAME_LENGTH);

                    oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                            "X_VENDOR_INTERFERENCE_SCHEME=%d", SON_NEIGHBORLIST_INFO(cell_idx).
                            oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].
                            eicic_info.interference_scheme);
                }

                if(SON_CELL_ABS_USAGE_THRESHOLD_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                        intra_rat_nr_list[neighbor_array_idx].eicic_info.bitmask) {
                    if(SON_CELL_MIN_ABS_USAGE_THRESHOLD_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                            intra_rat_nr_list[neighbor_array_idx].eicic_info.abs_usage_threshold.bitmask) {
                        retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                                (void**)&param_list[parameter_array_idx], p_err);
                        if(OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Memory allocation to param_list failed"
                                    " with Error Code:%d",
                                    *p_err);
                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }


                        oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                                MAX_PARAMETER_NAME_LENGTH);

                        oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                                "X_VENDOR_MIN_ABS_USAGE_THRESHOLD=%d", SON_NEIGHBORLIST_INFO(cell_idx).
                                oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].
                                eicic_info.abs_usage_threshold.min_abs_usage_threshold);

                    }
                    if(SON_CELL_INTF_SCHEME_TYPE_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
                            intra_rat_nr_list[neighbor_array_idx].eicic_info.bitmask) {
                        retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                                (void**)&param_list[parameter_array_idx], p_err);
                        if(OAM_FAILURE == retVal) {
                            OAM_LOG(OAM, OAM_ERROR,
                                    "Memory allocation to param_list failed"
                                    " with Error Code:%d",
                                    *p_err);
                            OAM_FUN_EXIT_TRACE();
                            return retVal;
                        }


                        oam_memset(param_list[parameter_array_idx], OAM_ZERO,
                                MAX_PARAMETER_NAME_LENGTH);

                        oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                                "X_VENDOR_MAX_ABS_USAGE_THRESHOLD=%d", SON_NEIGHBORLIST_INFO(cell_idx).
                                oam_son_nr_add_req.nr_list.intra_rat_nr_list[neighbor_array_idx].
                                eicic_info.abs_usage_threshold.max_abs_usage_threshold);
                    }

                }

            }
            /*eICIC_PHASE_1_2_CHANGES_END*/
            /* Changes for returning intance id corresponding to the neighors  */	

            retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                    (void**)&param_list[parameter_array_idx], p_err);
            if(OAM_FAILURE == retVal) {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to param_list failed"
                        " with Error Code:%d",
                        *p_err);
                OAM_FUN_EXIT_TRACE(); 
                return retVal;
            }

            oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

            oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
    /* SPR 18930  FIX START */
                    "X_VENDOR_INSTANCE_ID=%d",neighbor_array_idx+1);
    /* SPR 18930  FIX END */
            instance++; 
            num_neighbor++;
            neighbor_array_idx++;
        }
		else
		{
			neighbor_array_idx++;
		}    
	}

	num_of_param = parameter_array_idx;

	retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
			(UInt8**)param_list,
			num_of_param, trans_id,
			p_err, dst_id,
			start_index, end_index);

	for(neighbor_array_idx = OAM_ZERO; neighbor_array_idx < parameter_array_idx; ++neighbor_array_idx) {
		retVal = oam_mem_free(param_list[neighbor_array_idx], p_err);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"Error in memory free with error code: %d", *p_err);

		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/******************************************************************************
 * Function Name  : oam_handle_son_nr_retrieve_utran
 * Inputs         : dst_id   : destination id of the user module
 *                : trans_id : transaction ID to be send to user module
 *                : p_err    : Pointer to error variable
 * Outputs        : 
 * Returns        : OAM_SUCCESS / OAM_FAILURE
 * Description    : handles NR_RETIEVE request and send response to user
 *******************************************************************************/
oam_return_et
oam_handle_son_nr_retrieve_utran
(
 UInt16             dst_id,
 UInt16             trans_id,
 oam_error_code_et  *p_err
 )
{
	OAM_FUN_ENTRY_TRACE();
	Char8 parent_name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
	UInt8 neighbor_array_idx = OAM_ZERO;
	UInt8 parameter_array_idx = OAM_ZERO;
	UInt8 num_plmn = OAM_ZERO;
	UInt8 num_neighbor = OAM_ZERO;
	Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	UInt8 num_of_param = OAM_ZERO;
	UInt8 start_index = OAM_ONE; 
	UInt8 end_index = OAM_ZERO;
	Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
	UInt32 value = OAM_ZERO;
	UInt16 parent_name_len = OAM_ZERO; 
	oam_return_et retVal = OAM_FAILURE;
	UInt64 plmnid = OAM_ZERO;
	UInt64 cid = OAM_ZERO;
	SInt32 rncid = OAM_ZERO;
	UInt16 out_cid = OAM_ZERO;
	UInt16 out_rncid = OAM_ZERO;
	UInt32 instance = OAM_ZERO;
	UInt64 plmnid_atoi = OAM_ZERO;
	xmlNode *temp = NULL;
	xmlNode *p_xml_node = NULL;
	xmlNode *p_xml_node1 = NULL;
	xmlNode *p_xml_node2 = NULL;
	xmlChar *p_param_val = OAM_NULL;
	SInt8 cell_idx = oam_get_son_cell_nr_list_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

	if(OAM_ERROR_RETURN_VAL == cell_idx) {
		OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	parent_name_len =
/* spr_21013_fix_start */
		oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig"
				".LTE.RAN.NeighborList.InterRATCell.UMTS") + OAM_ONE;
	oam_strncpy(parent_name, "InternetGatewayDevice.Services.FAPService."
/* spr_21013_fix_end */
			"CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS",
			parent_name_len);

	/* SPR-13586 START */
    /* SPR 18930  FIX START */
	end_index = SON_NR_LIST(cell_idx).inter_rat_nr_list_size;
    /* SPR 18930  FIX END */
	/* SPR-13586 END */

	/* Populate PLMN-ID */
	/* SPR 12932 FIX START */
	/* SPR-13586 START */
/*SPR 22442 Fix Start*/
	for(num_neighbor = OAM_ZERO; ((num_neighbor < end_index) && (num_neighbor < SON_MAX_NO_UMTS_NEIGHBOUR_CELLS) && (neighbor_array_idx < SON_MAX_NO_UMTS_NEIGHBOUR_CELLS));) {
/*SPR 22442 Fix End*/
		if (((SON_NEIGHBORLIST_INFO(cell_idx).inter_rat_umts_entry_bitmap) & (OAM_ONE << neighbor_array_idx)) && 
				((SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].bitmask) & (SON_INTER_UTRAN_NEIGHBOR)) )
			/* SPR 12932 FIX END */
		{
			/* SPR-13586 END */
			oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
			oam_generate_plmnid(temp_param, &(SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.nbr_cgi.plmn_id));

            /* SPR 18930  FIX START */
            /* Code Removed */
            /* SPR 18930  FIX END */
			plmnid_atoi = oam_atoi((Char8*)temp_param);

			/* RT SPR 8627 FIX START */
			oam_extract_cid_from_utran_cell_identity(&out_cid,
					SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.nbr_cgi.
					cell_identity);
			/* RT SPR 8627 FIX END */

            /* SPR 18930  FIX START */
            /* Code Removed */
            /* SPR 18930  FIX END */
			/* RT SPR 8627 FIX START */
			oam_extract_rncid_from_utran_cell_identity(&out_rncid,
					SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.nbr_cgi.
					cell_identity);

            /* SPR 18930  FIX START */
            /* Code Removed */
            /* SPR 18930  FIX END */
			/* Maching the instance number corresponding to the neighbors */
            /* spr_21013_fix_start */
			temp = xml_struct_tr196_g.FAPService[cell_idx].CellConfig.UMTS[OAM_ZERO];
            /* spr_21013_fix_end */
			while(OAM_NULL != temp) {
				p_xml_node = oam_xml_find_tag(temp->children,
						(xmlChar*)"PLMNID");
				if(p_xml_node != OAM_NULL) 
				{	
					p_param_val = xmlNodeGetContent(p_xml_node);
					plmnid  = oam_atoi((Char8*)p_param_val);
					if(plmnid_atoi == plmnid) 
					{
						p_xml_node1 = oam_xml_find_tag(temp->children,
								(xmlChar*)"CID");
						if(p_xml_node1 != OAM_NULL) 
						{	
							p_param_val = xmlNodeGetContent(p_xml_node1);
							cid  = oam_atoi((Char8*)p_param_val);
							if (out_cid == cid) 
							{
								/* RT SPR 8627 FIX START */
								p_xml_node1 =
									oam_xml_find_tag(temp->children,
											(xmlChar*)"RNCID");
								if(p_xml_node1) 
								{   
									p_param_val =
										xmlNodeGetContent(p_xml_node1);

									rncid = oam_atoi((Char8*)p_param_val);
									if(out_rncid == rncid) 
									{
										/* RT SPR 8627 FIX END */
										p_xml_node2 = oam_xml_find_tag(temp->children,
												(xmlChar*)"X_VENDOR_INSTANCE_ID");
										if(p_xml_node1 != OAM_NULL) 
										{   
											p_param_val = xmlNodeGetContent(p_xml_node2);
											instance  = oam_atoi((Char8*)p_param_val);
											OAM_LOG(OAM, OAM_DETAILED,"In UMTS Instance id corresponding to plmn %s cid %d is --: %d",temp_param ,value, instance);
											break;
										}
										/* RT SPR 8627 FIX START */
									}
									/* RT SPR 8627 FIX END */
								}
							}
						}
					}
				}
				/* Move to next instance of object */
				temp = (temp)->next;
			}

            /* Spr 15612  Fix Start*/
        /* Coverity CID 85442 Fix Start */
            /* SPR 18930  FIX START */
            /* Code Removed */
            /* SPR 18930  FIX START */
		retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
				(void**)&param_list[parameter_array_idx], p_err);
		if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
                    "Memory allocation to param_list failed"
                    " with Error Code:%d",
					*p_err);
			OAM_FUN_EXIT_TRACE(); 
			return retVal;
		}
		oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

		oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
            /* SPR 18930  FIX START */
				"Enable=%d", SON_NEIGHBORLIST_INFO(cell_idx).utran_nbr_ctxt[neighbor_array_idx].enable);
            /* SPR 18930  FIX START */

		retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
				(void**)&param_list[parameter_array_idx], p_err);
		if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
                    "Memory allocation to param_list failed"
                    " with Error Code:%d",
					*p_err);
			OAM_FUN_EXIT_TRACE(); 
			return retVal;
		}
		oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

		oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
            /* SPR 18930  FIX START */
				"MustInclude=%d",SON_NEIGHBORLIST_INFO(cell_idx).utran_nbr_ctxt[neighbor_array_idx].must_include);
            /* SPR 18930  FIX START */
        /* Coverity CID 85442 Fix Start */
		retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
				(void**)&param_list[parameter_array_idx], p_err);
		if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
                    "Memory allocation to param_list failed"
                    " with Error Code:%d",
					*p_err);
			OAM_FUN_EXIT_TRACE(); 
			return retVal;
		}
		oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

		oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
				"PLMNID=%s", temp_param);

       
        retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
                (void**)&param_list[parameter_array_idx], p_err);
        if(OAM_FAILURE == retVal) {
            OAM_LOG(OAM, OAM_ERROR,
                    "Memory allocation to param_list failed"
                    " with Error Code:%d",
                    *p_err);
            OAM_FUN_EXIT_TRACE(); 
            return retVal;
        }
        oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

        oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                "CID=%d", out_cid);
 
		retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
				(void**)&param_list[parameter_array_idx], p_err);
		if(OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR,
                    "Memory allocation to param_list failed"
                    " with Error Code:%d",
					*p_err);
			OAM_FUN_EXIT_TRACE(); 
			return retVal;
		}
		oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

		oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
                        "RNCID=%d", out_rncid);
        /* Coverity CID 85442 Fix End */

/* Spr 15612  Fix End*/

			if(SON_UTRAN_PCI_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate PCI If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				/* RT SPR 8627 FIX START */
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"PCPICHScramblingCode=%d",
						SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
						utran_neighbor.pci.pci_fdd);
				/* RT SPR 8627 FIX END */
			}

			if(SON_UTRAN_CSO_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate cell_specific_offset If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_CELL_SPECIFIC_OFFSET=%d",
						SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						cell_specific_offset);
			}

			if(SON_UTRAN_LAC_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate lac If present */
                /* SPR 22398 Fix Start */
                /*SPR 21757 Fixed Start*/
				oam_cmn_convert_bytes_to_integer_for_LAC(
						SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.lac,
						&value);
                /* SPR 22398 Fix End */
                /*SPR 21757 Fixed End*/
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"LAC=%d", value);
			}

			if(SON_UTRAN_RAC_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate rac If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"RAC=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
						utran_neighbor.rac);
			}

			if(SON_UTRAN_PLMN_ID_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate PLMN ID If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_NUM_PLMN_ID=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.num_plmn_id);


				/* Populate PLMN ID List If present */
				for(num_plmn = OAM_ZERO;
						num_plmn < SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						num_plmn_id; ++num_plmn) {
					oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
					oam_generate_plmnid(temp_param,
							&(SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
								utran_neighbor.plmn_id[num_plmn]));

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[parameter_array_idx], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}
					oam_memset(param_list[parameter_array_idx], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_PLMN_ID[%d]=%s", num_plmn + OAM_ONE,
							temp_param);
				}
			}
			/* SPR-12433 Start */
			if((SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask & SON_UTRAN_ACCESS_MODE_PRESENT) &&
					(SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					 inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
					 access_mode != SON_OPEN))
			{
				if(SON_UTRAN_CSG_ID_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
					/* Populate csg_identity If present */
					oam_cmn_convert_csgid_to_integer(SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
							inter_rat_nr_list[neighbor_array_idx].utran_neighbor.csg_identity,
							OAM_FOUR, &value);

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[parameter_array_idx], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}

					oam_memset(param_list[parameter_array_idx], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_CSG_IDENTITY=%d", value);
				}
			}
			/* SPR-12433 End */
			if(SON_UTRAN_UARFCN_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate uarfcn If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
						"UARFCNDL=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
						utran_neighbor.uarfcn);
			}

			if(SON_UTRAN_RSCP_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate rscp If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_RSCP=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.rscp);
			}

			if(SON_UTRAN_ECNO_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate ecno If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_ECNO=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.ecno);
			}

			if(SON_UTRAN_ENABLE_NR_STATUS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate nr_status If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_NR_STATUS=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.nr_status);
			}

			if(SON_UTRAN_ENABLE_HO_STATUS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate ho_status If present */
				oam_memset(temp_param , OAM_ZERO , MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
						"%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
						utran_neighbor.ho_status); 
				/* SPR 13179 FIX START */
				/* Code removed */
				/* SPR 13179 FIX END */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HO_STATUS=%s", temp_param);
			}

			if(SON_UTRAN_NR_HO_STATS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate handovers_attempted If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HANDOVERS_ATTEMPTED=%d",
						SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						handover_stats.handovers_attempted);

				/* Populate handovers_succesful If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HANDOVERS_SUCCESFUL=%d",
						SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						handover_stats.handovers_succesful);

				/* Populate handovers_failed If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HANDOVERS_FAILED=%d",
						SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						handover_stats.handovers_failed);
			}


			if(SON_UTRAN_ACCESS_MODE_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_ACCESS_MODE=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.access_mode);
			}

			/* Changes for returning intance id corresponding to the neighors  */	
                        /* SPR 19221: CID 107895 Fix Start */
		    retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
					    "Memory allocation to param_list failed"
					    " with Error Code:%d",
						*p_err);
				OAM_FUN_EXIT_TRACE(); 
				return retVal;
			}

			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
					"X_VENDOR_INSTANCE_ID=%d",neighbor_array_idx+1); 
                        /* SPR 19221: CID 107895 Fix End */
			num_neighbor++;
			neighbor_array_idx++;

		} 
		/* End of if(...SON_INTER_UTRAN_NEIGHBOR) */
		else
		{
			neighbor_array_idx++;
			continue;
		}

	}/* End of for loop */


	num_of_param = parameter_array_idx;

	retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
			(UInt8**)param_list,
			num_of_param, trans_id,
			p_err, dst_id,
			start_index, end_index);

	for(neighbor_array_idx = OAM_ZERO; neighbor_array_idx < parameter_array_idx; ++neighbor_array_idx) {
		retVal = oam_mem_free(param_list[neighbor_array_idx], p_err);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"Error in memory free with error code: %d", *p_err);

		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/* SPR-13586 START */
/***************************************************************************
 * Function Name  : oam_handle_son_nr_retrieve_geran
 * Inputs         : dst_id   : destination id of the user module
 *                : trans_id : transaction ID to be send to user module
 *                : p_err    : Pointer to error variable
 * Outputs        : 
 * Returns        : OAM_SUCCESS / OAM_FAILURE
 * Description    : handles NR_RETIEVE request and send response to user
 ***************************************************************************/
oam_return_et
oam_handle_son_nr_retrieve_geran
(
 UInt16             dst_id,
 UInt16             trans_id,
 oam_error_code_et  *p_err
 )
{
	/* Coverity 69689 Fix Start */
	OAM_FUN_ENTRY_TRACE();
	Char8 parent_name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
	UInt8 neighbor_array_idx= OAM_ZERO;
	UInt8 parameter_array_idx = OAM_ZERO;
	UInt8 num_neighbor= OAM_ZERO;
	Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	UInt8 num_of_param = OAM_ZERO;
	UInt8 start_index = OAM_ONE;
	UInt8 end_index = OAM_ZERO;
	Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
	UInt16 parent_name_len = OAM_ZERO;
	oam_return_et retVal = OAM_FAILURE;
	UInt8 out_bsic = OAM_ZERO;
	UInt16 out_lac = OAM_ZERO;
	UInt16 out_ci = OAM_ZERO;
	UInt64 plmnid_atoi = OAM_ZERO;
	Char8 *parameter_value;
	SInt8 cell_idx = oam_get_son_cell_nr_list_idx(oam_prov_req.cell_cntxt.curr_cell_cid);
	/* Coverity 69687 Fix Start */
	if(OAM_ERROR_RETURN_VAL == cell_idx) 
	{
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	retVal = oam_mem_alloc(STR_LEN_128,
			(void**)&parameter_value, p_err);
	if(OAM_FAILURE == retVal) 
	{
		OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to parameter_value failed"
                " with Error Code:%d",
				*p_err);
		return retVal;
	}   
	/* Coverity 69687 Fix End */
    /*coverity 109007 fix start */
	parent_name_len =
/* spr_21013_fix_start */
		strlen("InternetGatewayDevice.Services.FAPService.CellConfig"
				".LTE.RAN.NeighborList.InterRATCell.GSM") + OAM_ONE;
    /*coverity 109007 fix end */
	strncpy(parent_name, "InternetGatewayDevice.Services.FAPService."
/* spr_21013_fix_end */
			"CellConfig.LTE.RAN.NeighborList.InterRATCell.GSM",
			parent_name_len);
	/*bug_14898_start*/
	if (cell_idx < OAM_ZERO)
	{
		OAM_LOG(OAM, OAM_WARNING,
				"Invalid cell_index");
	    /*+-coverity_85860_fix*/
		oam_mem_free(parameter_value, p_err);
		/* Coverity ID : 85860 Fix End*/

		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;

	}
	/*bug_14898_end*/

	end_index = SON_NEIGHBORLIST_INFO(cell_idx).inter_rat_gsm_list_size;


	for(num_neighbor = OAM_ZERO;
/*SPR 22442 Fix Start*/
			((num_neighbor < end_index) && (num_neighbor < SON_MAX_NO_GERAN_NEIGHBOUR_CELLS) && (neighbor_array_idx < SON_MAX_NO_GERAN_NEIGHBOUR_CELLS)); ) {
/*SPR 22442 Fix End*/
		if (((SON_NEIGHBORLIST_INFO(cell_idx).inter_rat_gsm_entry_bitmap) & (OAM_ONE << neighbor_array_idx)) &&
				((SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].bitmask) &                (SON_INTER_GERAN_NEIGHBOR)) )
		{    
			/* Populate PLMN-ID */
			oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
			oam_generate_plmnid(temp_param,
					&(SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].
						geran_neighbor.nbr_cgi.plmn_id));

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);

				/* Coverity ID : 85860 Fix Start*/
				for (neighbor_array_idx = OAM_ZERO;
						neighbor_array_idx < parameter_array_idx;
						++neighbor_array_idx) 
				{
					oam_mem_free(param_list[neighbor_array_idx], p_err);
				}
				/*+-coverity_86855_fix*/
				oam_mem_free(parameter_value, p_err);
				/* Coverity ID : 85860 Fix End*/
				OAM_FUN_EXIT_TRACE();
				return retVal;
			}

			oam_memset(param_list[parameter_array_idx], OAM_ZERO,
					MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"PLMNID=%s", temp_param);

			plmnid_atoi = oam_atoi((Char8*)temp_param);

			oam_extract_lac_from_cell_identity(&out_lac,
					SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.nbr_cgi.cell_identity);

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);

				/* Coverity ID : 85860 Fix Start*/
				for (neighbor_array_idx = OAM_ZERO;
						neighbor_array_idx < parameter_array_idx;
						++neighbor_array_idx) 
				{
					oam_mem_free(param_list[neighbor_array_idx], p_err);
				}
				/*+-coverity_86855_fix*/
				oam_mem_free(parameter_value, p_err);
				/* Coverity ID : 85860 Fix End*/
				OAM_FUN_EXIT_TRACE();
				return retVal;
			}

			oam_memset(param_list[parameter_array_idx], OAM_ZERO,
					MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"LAC=%d", out_lac);

			oam_extract_ci_from_cell_identity(&out_ci,
					SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.nbr_cgi.cell_identity);

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);

				/* Coverity ID : 85860 Fix Start*/
				for (neighbor_array_idx = OAM_ZERO;
						neighbor_array_idx < parameter_array_idx;
						++neighbor_array_idx) 
				{
					oam_mem_free(param_list[neighbor_array_idx], p_err);
				}
				/*+-coverity_86855_fix*/
				oam_mem_free(parameter_value, p_err);
				/* Coverity ID : 85860 Fix End*/
				OAM_FUN_EXIT_TRACE();
				return retVal;
			}
			oam_memset(param_list[parameter_array_idx], OAM_ZERO,
					MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
					"CI=%d", out_ci);

			/* SPR-13586 START */
			/* code removed */
			/* SPR-13586 END */

			if(SON_GERAN_PCI_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate PCI If present */

#ifdef OAM_SON_ENABLE /* +- SPR 13917 fix */
				oam_extract_value_from_bsic(&out_bsic,
						&SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].
						geran_neighbor.pci);
#endif /* +- SPR 13917 fix */                


				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);

					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
				    /*+-coverity_86855_fix*/	
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"BSIC=%d",
						out_bsic);
			}

			if(SON_GERAN_ARFCN_BAND_IND_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate band_ind If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);

					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
				    /*+-coverity_86855_fix*/	
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				oam_sprintf((Char8 *)parameter_value,"%d",
						SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].geran_neighbor.band_ind);    
				oam_search_string_to_integer_for_get(parameter_value,
						&SON_GSM_BANDINDICATOR[OAM_ZERO],
						OAM_SON_GSM_BANDINDICATOR_TBL_NUM_ROWS);
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"BandIndicator=%s",
						parameter_value);
			}

			if(SON_GERAN_ARFCN_BAND_IND_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate arfcn If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);

					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
				    /*+-coverity_86855_fix*/	
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"BCCHARFCN=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].geran_neighbor.arfcn);
			}

			if(SON_GERAN_ENABLE_NR_STATUS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate nr_status If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);

					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
				    /*+-coverity_86855_fix*/	
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_NR_STATUS=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
						geran_neighbor.nr_status);
			}

			if(SON_GERAN_ENABLE_HO_STATUS_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].geran_neighbor.bitmask) {
				/* Populate X_VENDOR_HO_STATUS If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);

					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
				 	/*+-coverity_86855_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HO_STATUS=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].geran_neighbor.ho_status);
			}

			if(SON_GERAN_RAC_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].geran_neighbor.bitmask) {
				/* Populate rac If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);

					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
					/*+-coverity_86855_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_RAC=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].geran_neighbor.rac);
			}

			if(SON_GERAN_CSO_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
					inter_rat_nr_list[neighbor_array_idx].geran_neighbor.bitmask) {
				/* Populate cell_specific_offset If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);

					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
					/*+-coverity_86855_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_CELL_SPECIFIC_OFFSET=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
						geran_neighbor.cell_specific_offset);
			}

			if(SON_GERAN_RSSI_PRESENT & SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate rssi If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
                    /*+-coverity_86855_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_RSSI=%d", SON_NEIGHBORLIST_INFO(cell_idx).oam_son_nr_add_req.nr_list.
						inter_rat_nr_list[neighbor_array_idx].geran_neighbor.rssi);
			}


			/* Changes for returning intance id corresponding to the neighors  */
			/* SPR-13586 START */
			if(plmnid_atoi)
			{

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);

					/* Coverity ID : 85860 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
				    /*+-coverity_86855_fix*/	
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85860 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_INSTANCE_ID=%d",(neighbor_array_idx+1));
			}
			/* SPR-13586 END */
			num_neighbor++;
			neighbor_array_idx++;

		} /* End of if(...SON_INTER_GERAN_NEIGHBOR) */
		else {

			neighbor_array_idx++;
			continue;
		}
	}/* End of for loop */


	num_of_param = parameter_array_idx;


	retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
			(UInt8**)param_list,
			num_of_param, trans_id,
			p_err, dst_id,
			start_index, end_index);

	for (neighbor_array_idx = OAM_ZERO;
			neighbor_array_idx < parameter_array_idx;
			++neighbor_array_idx) {
		retVal = oam_mem_free(param_list[neighbor_array_idx], p_err);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"Error in memory free with error code: %d", *p_err);

		}
	}
	/* Coverity ID : 85860 Fix Start*/
	oam_mem_free(parameter_value, p_err);
	/* Coverity ID : 85860 Fix End*/
	OAM_FUN_EXIT_TRACE();
	return retVal;
	/* Coverity 69689 Fix End */
}


/* SPR-13586 END */

/******************************************************************************
 * Function Name  : oam_handle_son_nliu_retrieve_eutran
 * Inputs         : dst_id   : destination id of the user module
 *                : trans_id : transaction ID to be send to user module
 *                : p_err    : Pointer to error variable
 * Outputs        : 
 * Returns        : OAM_SUCCESS / OAM_FAILURE
 * Description    : handles NLIU_RETIEVE request and send response to user
 *******************************************************************************/
oam_return_et
oam_handle_son_nliu_retrieve_eutran
(
 UInt16             dst_id,
 UInt16             trans_id,
 oam_error_code_et  *p_err
 )
{
	OAM_FUN_ENTRY_TRACE();
	Char8 parent_name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
	UInt8 neighbor_array_idx = OAM_ZERO;
	UInt8 parameter_array_idx = OAM_ZERO;
	UInt8 num_plmn = OAM_ZERO;
	UInt8 num_neighbor = 0;
	Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	UInt8 num_of_param = OAM_ZERO;
	UInt8 start_index = OAM_ONE; 
	UInt8 end_index = OAM_ZERO;
	Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
	UInt32 value = OAM_ZERO;
	UInt16 parent_name_len = OAM_ZERO; 
	oam_return_et retVal = OAM_FAILURE;
	UInt64 plmnid = OAM_ZERO;
	UInt64 cid = OAM_ZERO;
	UInt32 instance = OAM_ZERO;
	UInt64 plmnid_atoi = OAM_ZERO;
	xmlNode *temp = NULL;
	xmlNode *p_xml_node = NULL;
	xmlNode *p_xml_node1 = NULL;
	xmlNode *p_xml_node2 = NULL;
	xmlChar *p_param_val = OAM_NULL;
	SInt8 cell_idx = oam_get_son_neigh_list_in_use_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

	if(OAM_ERROR_RETURN_VAL == cell_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}

	parent_name_len =
/* spr_21013_fix_start */
		oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig"
				".LTE.RAN.NeighborListInUse.LTECell") + OAM_ONE;
	oam_strncpy(parent_name, "InternetGatewayDevice.Services.FAPService."
/* spr_21013_fix_end */
			"CellConfig.LTE.RAN.NeighborListInUse.LTECell",
			parent_name_len);

    /* SPR 18930  FIX START */
	end_index = NRT_INFO(cell_idx).nr_list.intra_rat_nr_list_size;
    /* SPR 18930  FIX END */

	OAM_LOG(OAM, OAM_DETAILED," total number of params %d ",end_index);

/*SPR 22442 Fix Start*/
	for(num_neighbor = OAM_ZERO; ((num_neighbor < end_index) && (num_neighbor < SON_MAX_NO_INTRA_RAT_NEIGHBOUR_CELLS));) {
/*SPR 22442 Fix End*/
		if (SON_PROV_REQ.neigh_list_in_use[cell_idx].intra_rat_neigh_valid_bitmap & (OAM_ONE << neighbor_array_idx))
		{
			/* Populate PLMN-ID */
			oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
			oam_generate_plmnid(temp_param, &(NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].nbr_cgi.plmn_id));

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				OAM_FUN_EXIT_TRACE(); 
				return retVal;
			}

			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"PLMNID=%s", temp_param); 

			plmnid_atoi = oam_atoi((Char8*)temp_param);

			/* Populate Cell-Identity */
			oam_decode_bit_stream_into_eutran_cellidentity(NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].nbr_cgi.
					cell_identity,&value);

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				OAM_FUN_EXIT_TRACE(); 
				return retVal;
			}
			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"CID=%d", value);

			OAM_LOG(OAM, OAM_DETAILED," plmnid %s cid %d ",temp_param ,value);
			/*  Instance id match code starts here */

            /* spr_21013_fix_start */
			temp = xml_struct_tr196_g.FAPService[cell_idx].CellConfig.LTECell[OAM_ZERO];
            /* spr_21013_fix_end */
			while(OAM_NULL != temp) {
				p_xml_node = oam_xml_find_tag(temp->children,
						(xmlChar*)"PLMNID");
				if(p_xml_node != OAM_NULL) {	
					p_param_val = xmlNodeGetContent(p_xml_node);
					plmnid  = oam_atoi((Char8*)p_param_val);
					if(plmnid_atoi == plmnid) {

						p_xml_node1 = oam_xml_find_tag(temp->children,
								(xmlChar*)"CID");
						if(p_xml_node1 != OAM_NULL) {	
							p_param_val = xmlNodeGetContent(p_xml_node1);
							cid  = oam_atoi((Char8*)p_param_val);

							if (value == cid) {

								p_xml_node2 = oam_xml_find_tag(temp->children,
										(xmlChar*)"X_VENDOR_INSTANCE_ID");
								if(p_xml_node1 != OAM_NULL) {	
									p_param_val = xmlNodeGetContent(p_xml_node2);
									instance  = oam_atoi((Char8*)p_param_val);
									OAM_LOG(OAM, OAM_DETAILED,"IN LTE CELL Instance id corresponding to plmn %s cid %d is --: %d",temp_param ,value, instance);
									break;
								}
							}
						}
					}
				}
				/* Move to next instance of object */
				temp = (temp)->next;
			}


			/* Populate PCI If present */
			if(SON_PCI_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"PhyCellID=%d",
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].pci);
			}

			if(SON_CELL_OFFSET_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate cell_specific_offset If present */

				oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
						"%d", NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].
						cell_specific_offset);

				oam_search_integer_to_interger_for_get(temp_param,
						RAN_NeighborList_LTECell_QOffset[OAM_ZERO], 31);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"QOffset=%s", temp_param);
			}

			if(SON_TAC_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate tac If present */
				/*SPR 11315 start*/
				/*SPR 11315 Fix*/
				/*SPR 11315 Fix*/

				oam_cmn_convert_byte_string_to_short(
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].tac,
						&value,OAM_MAX_SHORT_INT_BITSTRING_SIZE - OAM_TAC_BIT_STRING_SIZE);
				/*SPR 11315 end*/
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_TAC=%d", value);
			}

			if(SON_PLMN_ID_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate PLMN ID count If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_NUM_PLMN_ID=%d", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].num_plmn_id);

				/* Populate PLMN ID List If present */

				for(num_plmn = OAM_ZERO;
						num_plmn < NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].num_plmn_id;
						++num_plmn ) {
					oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
					oam_generate_plmnid(temp_param,
							&(NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].plmn_id[num_plmn]));

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[parameter_array_idx], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}
					oam_memset(param_list[parameter_array_idx], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_PLMN_ID[%d]=%s", num_plmn + OAM_ONE,
							temp_param);
				}
			}

			if(SON_INTRA_CSG_ID_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate csg_identity If present */
				oam_cmn_convert_csgid_to_integer(
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].csg_identity,
						OAM_FOUR, &value);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_CSG_IDENTITY=%d", value);
			}

			if(SON_EARFCN_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate earfcn If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"EUTRACarrierARFCN=%d",
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].earfcn);
			}

			if(SON_RSRP_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate rsrp If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_RSRP=%d",
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].rsrp);
			}

			if(SON_RSRQ_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate rsrq If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_RSRQ=%d",
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].rsrq);
			}

			if(SON_ENABLE_NR_STATUS_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate nr_status If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_NR_STATUS=%d",
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].nr_status);
			}

			if(SON_ENABLE_HO_STATUS_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate ho_status If present */
				oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
						"%d", NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].ho_status);
				oam_search_integer_to_interger_for_get(temp_param,
						NR_Blacklisted[OAM_ZERO], 2);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"Blacklisted=%s", temp_param);
			}

			if(SON_ENABLE_X2_STATUS_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate x2_status If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_X2_STATUS=%d", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].x2_status);

			}

			if(SON_EUTRAN_NR_HO_STATS_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate handovers_attempted If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HANDOVERS_ATTEMPTED=%d",
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].
						handover_stats.handovers_attempted);

				/* Populate handovers_succesful If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_HANDOVERS_SUCCESFUL=%d",
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].
						handover_stats.handovers_succesful);

				/* Populate handovers_failed If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_HANDOVERS_FAILED=%d",
						NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].
						handover_stats.handovers_failed);
			}

			if(SON_SUSPECT_PCI_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate suspected_pci If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_SUSPECTED_PCI=%d", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].suspected_pci);
			}


			if(SON_CM_CELL_OFFSET_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate CIO If present */
				oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH,
						"%d", NRT_INFO(cell_idx).nr_list.intra_rat_nr_list[neighbor_array_idx].
						cm_cell_specific_offset);

				oam_search_integer_to_interger_for_get(temp_param,
						RAN_NeighborList_LTECell_CIO[OAM_ZERO], 31);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"CIO=%s", temp_param);
			}

			if(SON_BROADCAST_STATUS_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate broadcast status If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_BROADCAST_STATUS=%s", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].broadcast_status ?
						"Enabled" : "Disabled");
			}

			if(SON_ACCESS_MODE_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate access mode If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_ACCESS_MODE=%d", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].access_mode);
			}

			if(SON_PRACH_CONFIGURATION_PRESENT & NRT_INFO(cell_idx).nr_list.
					intra_rat_nr_list[neighbor_array_idx].bitmask) {
				/* Populate Prach_Configuration ParameterIf present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_PRACH_ROOT_SEQUENCE_INDEX=%d", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].prach_config.root_sequence_index);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_PRACH_ZERO_CORRELATION_ZONE_CONFIG=%d", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].prach_config.zero_correlation_zone_config);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_PRACH_HIGH_SPEED_FLAG=%d", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].prach_config.high_speed_flag);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_PRACH_FREQUENCY_OFFSET=%d", NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].prach_config.prach_frequency_offset);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				if(SON_PRACH_CONFIG_INDEX_PRESENT & NRT_INFO(cell_idx).nr_list.
						intra_rat_nr_list[neighbor_array_idx].prach_config.bitmask){
					oam_memset(param_list[parameter_array_idx], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
							"X_VENDOR_PRACH_CONFIGURATION_INDEX=%d\n", NRT_INFO(cell_idx).nr_list.
							intra_rat_nr_list[neighbor_array_idx].prach_config.prach_configuration_index);

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[parameter_array_idx], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE();
						return retVal;
					}
				}

			}
			/* SPR 12951 Fix: Code Removed*/
			num_neighbor++;
			neighbor_array_idx++;
		}
		else
		{
			neighbor_array_idx++;
			continue;

		}
	}
	num_of_param = parameter_array_idx;

	retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
			(UInt8**)param_list,
			num_of_param, trans_id,
			p_err, dst_id,
			start_index, end_index);

	for(neighbor_array_idx = OAM_ZERO; neighbor_array_idx < parameter_array_idx; ++neighbor_array_idx) {
		retVal = oam_mem_free(param_list[neighbor_array_idx], p_err);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"Error in memory free with error code: %d", *p_err);

		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/******************************************************************************
 * Function Name  : oam_handle_son_nliu_retrieve_utran
 * Inputs         : dst_id   : destination id of the user module
 *                : trans_id : transaction ID to be send to user module
 *                : p_err    : Pointer to error variable
 * Outputs        : 
 * Returns        : OAM_SUCCESS / OAM_FAILURE
 * Description    : handles NLIU_RETIEVE request and send response to user
 *******************************************************************************/
oam_return_et
oam_handle_son_nliu_retrieve_utran
(
 UInt16             dst_id,
 UInt16             trans_id,
 oam_error_code_et  *p_err
 )
{
	OAM_FUN_ENTRY_TRACE();
	Char8 parent_name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
	UInt8 neighbor_array_idx= OAM_ZERO;
	UInt8 parameter_array_idx = OAM_ZERO;
	UInt8 num_plmn = OAM_ZERO;
	UInt8 num_neighbor= OAM_ZERO;
	Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	UInt8 num_of_param = OAM_ZERO;
	UInt8 start_index = OAM_ONE; 
	UInt8 end_index = OAM_ZERO;
	Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
	UInt32 value = OAM_ZERO;
	UInt16 parent_name_len = OAM_ZERO; 
	oam_return_et retVal = OAM_FAILURE;
	UInt64 plmnid = OAM_ZERO;
	UInt64 cid = OAM_ZERO;
	SInt32 rncid = OAM_ZERO;
	UInt16 out_cid = OAM_ZERO;
	UInt16 out_rncid = OAM_ZERO;
	UInt32 instance = OAM_ZERO;
	UInt64 plmnid_atoi = OAM_ZERO;
	xmlNode *temp = NULL;
	xmlNode *p_xml_node = NULL;
	xmlNode *p_xml_node1 = NULL;
	xmlNode *p_xml_node2 = NULL;
	xmlChar *p_param_val = OAM_NULL;
	SInt8 cell_idx = oam_get_son_serving_cell_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

	if(OAM_ERROR_RETURN_VAL == cell_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		return OAM_FAILURE;
	}


	parent_name_len =
/* spr_21013_fix_start */
		oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig"
				".LTE.RAN.NeighborList.InterRATCell.UMTS") + OAM_ONE;
	oam_strncpy(parent_name, "InternetGatewayDevice.Services.FAPService."
/* spr_21013_fix_end */
			"CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS",
			parent_name_len);


	/* SPR-13586 START */
    /* SPR 18930  FIX START */
    /*SPR 22442 Fix Start*/
	end_index = SON_PROV_REQ.neigh_list_in_use[cell_idx].inter_rat_umts_neigh_size;
    /*SPR 22442 Fix End*/
    /* SPR 18930  FIX START */
	/* SPR-13586 END */


    /*SPR 22442 Fix Start*/
	for(num_neighbor = OAM_ZERO; ((num_neighbor < end_index) && (num_neighbor < SON_MAX_NO_UMTS_NEIGHBOUR_CELLS));) {
    /*SPR 22442 Fix End*/

		/* SPR-13586 START */
		if (SON_PROV_REQ.neigh_list_in_use[cell_idx].inter_rat_umts_neigh_valid_bitmap & (OAM_ONE << neighbor_array_idx))
		{
			/* SPR-13586 END */
			/* Populate PLMN-ID */
			oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
			oam_generate_plmnid(temp_param, &(NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.nbr_cgi.plmn_id));

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				OAM_FUN_EXIT_TRACE(); 
				return retVal;
			}

			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"PLMNID=%s", temp_param); 

			plmnid_atoi = oam_atoi((Char8*)temp_param);

			/* RT SPR 8627 FIX START */
			oam_extract_cid_from_utran_cell_identity(&out_cid,
					NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.nbr_cgi.
					cell_identity);
			/* RT SPR 8627 FIX END */

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				OAM_FUN_EXIT_TRACE(); 
				return retVal;
			}
			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"CID=%d", out_cid);

			/* RT SPR 8627 FIX START */
			oam_extract_rncid_from_utran_cell_identity(&out_rncid,
					NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.nbr_cgi.
					cell_identity);

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				OAM_FUN_EXIT_TRACE(); 
				return retVal;
			}
			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"RNCID=%d", out_rncid);

			/* Maching the instance number corresponding to the neighbors */
            /* spr_21013_fix_start */
			temp = xml_struct_tr196_g.FAPService[OAM_ZERO].CellConfig.UMTS[cell_idx];
            /* spr_21013_fix_end */
			while(OAM_NULL != temp) {
				p_xml_node = oam_xml_find_tag(temp->children,
						(xmlChar*)"PLMNID");
				if(p_xml_node != OAM_NULL) 
				{	
					p_param_val = xmlNodeGetContent(p_xml_node);
					plmnid  = oam_atoi((Char8*)p_param_val);
					if(plmnid_atoi == plmnid) 
					{
						p_xml_node1 = oam_xml_find_tag(temp->children,
								(xmlChar*)"CID");
						if(p_xml_node1 != OAM_NULL) 
						{	
							p_param_val = xmlNodeGetContent(p_xml_node1);
							cid  = oam_atoi((Char8*)p_param_val);
							if (out_cid == cid) 
							{
								/* RT SPR 8627 FIX START */
								p_xml_node1 =
									oam_xml_find_tag(temp->children,
											(xmlChar*)"RNCID");
								if(p_xml_node1) 
								{   
									p_param_val =
										xmlNodeGetContent(p_xml_node1);

									rncid = oam_atoi((Char8*)p_param_val);
									if(out_rncid == rncid) 
									{
										/* RT SPR 8627 FIX END */
										p_xml_node2 = oam_xml_find_tag(temp->children,
												(xmlChar*)"X_VENDOR_INSTANCE_ID");
										if(p_xml_node1 != OAM_NULL) 
										{   
											p_param_val = xmlNodeGetContent(p_xml_node2);
											instance  = oam_atoi((Char8*)p_param_val);
											OAM_LOG(OAM, OAM_DETAILED,"In UMTS Instance id corresponding to plmn %s cid %d is --: %d",temp_param ,value, instance);
											break;
										}
										/* RT SPR 8627 FIX START */
									}
									/* RT SPR 8627 FIX END */
								}
							}
						}
					}
				}
				/* Move to next instance of object */
				temp = (temp)->next;
			}

			if(SON_UTRAN_PCI_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate PCI If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				/* RT SPR 8627 FIX START */
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"PCPICHScramblingCode=%d",
						NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
						utran_neighbor.pci.pci_fdd);
				/* RT SPR 8627 FIX END */
			}

			if(SON_UTRAN_CSO_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate cell_specific_offset If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_CELL_SPECIFIC_OFFSET=%d",
						NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						cell_specific_offset);
			}

			if(SON_UTRAN_LAC_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate lac If present */
                /* SPR 22398 Fix Start */
                /*SPR 21757 Fixed Start*/
				oam_cmn_convert_bytes_to_integer_for_LAC(
						NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.lac,
						&value);
                /*SPR 21757 Fixed End*/
                /* SPR 22398 Fix End */ 
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"LAC=%d", value);
			}

			if(SON_UTRAN_RAC_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate rac If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"RAC=%d", NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
						utran_neighbor.rac);
			}

			if(SON_UTRAN_PLMN_ID_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate PLMN ID If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_NUM_PLMN_ID=%d", NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.num_plmn_id);


				/* Populate PLMN ID List If present */
				for(num_plmn  = OAM_ZERO;
						num_plmn < NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						num_plmn_id; ++num_plmn) {
					oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
					oam_generate_plmnid(temp_param,
							&(NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
								utran_neighbor.plmn_id[num_plmn]));

					retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
							(void**)&param_list[parameter_array_idx], p_err);
					if(OAM_FAILURE == retVal) {
						OAM_LOG(OAM, OAM_ERROR,
								"Memory allocation to param_list failed"
								" with Error Code:%d",
								*p_err);
						OAM_FUN_EXIT_TRACE(); 
						return retVal;
					}
					oam_memset(param_list[parameter_array_idx], OAM_ZERO,
							MAX_PARAMETER_NAME_LENGTH);

					oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
							"X_VENDOR_PLMN_ID[%d]=%s", num_plmn + OAM_ONE,
							temp_param);
				}
			}

			if(SON_UTRAN_CSG_ID_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate csg_identity If present */
				oam_cmn_convert_csgid_to_integer(NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.csg_identity,
						OAM_FOUR, &value);

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_CSG_IDENTITY=%d", value);
			}

			if(SON_UTRAN_UARFCN_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate uarfcn If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
						"UARFCNDL=%d", NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
						utran_neighbor.uarfcn);
			}

			if(SON_UTRAN_RSCP_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate rscp If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_RSCP=%d", NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.rscp);
			}

			if(SON_UTRAN_ECNO_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					utran_neighbor.bitmask) {
				/* Populate ecno If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_ECNO=%d", NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.ecno);
			}

			if(SON_UTRAN_ENABLE_NR_STATUS_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate nr_status If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH, 
						"X_VENDOR_NR_STATUS=%d", NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.nr_status);
			}

			if(SON_UTRAN_ENABLE_HO_STATUS_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate ho_status If present */
				oam_memset(temp_param , OAM_ZERO , MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(temp_param,MAX_PARAMETER_NAME_LENGTH, 
						"%d", NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
						utran_neighbor.ho_status); 
				/* SPR 13179 FIX START */
				/* Code removed */
				/* SPR 13179 FIX END */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HO_STATUS=%s", temp_param);
			}

			if(SON_UTRAN_NR_HO_STATS_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				/* Populate handovers_attempted If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HANDOVERS_ATTEMPTED=%d",
						NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						handover_stats.handovers_attempted);

				/* Populate handovers_succesful If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HANDOVERS_SUCCESFUL=%d",
						NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						handover_stats.handovers_succesful);

				/* Populate handovers_failed If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE(); 
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HANDOVERS_FAILED=%d",
						NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].utran_neighbor.
						handover_stats.handovers_failed);
			}


			if(SON_UTRAN_ACCESS_MODE_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].utran_neighbor.bitmask) {
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_ACCESS_MODE=%d", NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].utran_neighbor.access_mode);
			}
			/* SPR 12951 Fix:Code Removed */
			num_neighbor++;
			neighbor_array_idx++;

		} /* End of if(...SON_INTER_UTRAN_NEIGHBOR) */
		else
		{

			neighbor_array_idx++;
			continue;

		}    

	}/* End of for loop */


	num_of_param = parameter_array_idx;

	retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
			(UInt8**)param_list,
			num_of_param, trans_id,
			p_err, dst_id,
			start_index, end_index);

	for(neighbor_array_idx = OAM_ZERO; neighbor_array_idx < parameter_array_idx; ++neighbor_array_idx) {
		retVal = oam_mem_free(param_list[neighbor_array_idx], p_err);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"Error in memory free with error code: %d", *p_err);

		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}
/* SPR-13586 START */

/******************************************************************************
 * Function Name  : oam_handle_son_nliu_retrieve_geran
 * Inputs         : dst_id   : destination id of the user module
 *                : trans_id : transaction ID to be send to user module
 *                : p_err    : Pointer to error variable
 * Outputs        : 
 * Returns        : OAM_SUCCESS / OAM_FAILURE
 * Description    : handles NLIU_RETIEVE request and send response to user
 *******************************************************************************/

oam_return_et
oam_handle_son_nliu_retrieve_geran
(
 UInt16             dst_id,
 UInt16             trans_id,
 oam_error_code_et  *p_err
 )
{
	/* Coverity 69688 Changes Start */
	OAM_FUN_ENTRY_TRACE();
	Char8 parent_name[MAX_PARENT_NAME_LENGTH] = {OAM_ZERO};
	UInt8 neighbor_array_idx= OAM_ZERO;
	UInt8 parameter_array_idx = OAM_ZERO;
	UInt8 num_neighbor= OAM_ZERO;
	Char8 temp_param[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	UInt8 num_of_param = OAM_ZERO;
	UInt8 start_index = OAM_ONE;
	UInt8 end_index = OAM_ZERO;
	Char8 *param_list[MAX_NUM_PARAMS_ALLOWED_GPV_RESP] = {OAM_NULL};
	UInt16 parent_name_len = OAM_ZERO;
	oam_return_et retVal = OAM_FAILURE;
	UInt8 out_bsic = OAM_ZERO;
	UInt16 out_lac = OAM_ZERO;
	UInt16 out_ci = OAM_ZERO;
	Char8 *parameter_value;

	retVal = oam_mem_alloc(STR_LEN_128,
			(void**)&parameter_value, p_err);
	/* Coverity 69686 Changes Start */
	if(OAM_FAILURE == retVal) 
	{
		OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to parameter_value failed"
                " with Error Code:%d",
				*p_err);
		OAM_FUN_EXIT_TRACE();
		return retVal;
	}   

	SInt8 cell_idx = oam_get_son_serving_cell_idx(oam_prov_req.cell_cntxt.curr_cell_cid);
	if(OAM_ERROR_RETURN_VAL == cell_idx) 
	{
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         oam_prov_req.cell_cntxt.curr_cell_cid);
		/* Coverity ID : 85862 Fix Start*/
		oam_mem_free(parameter_value, p_err);
		/* Coverity ID : 85862 Fix End*/
		OAM_FUN_EXIT_TRACE();
		retVal = OAM_FAILURE;
		return retVal;
	}
	/* Coverity 69686 Changes End */
    /*coverity 109020 fix start */
	parent_name_len =
/* spr_21013_fix_start */
		oam_strlen("InternetGatewayDevice.Services.FAPService.CellConfig"
				".LTE.RAN.NeighborListInUse.InterRATCell.GSM") + OAM_ONE;
	 oam_strncpy(parent_name, "InternetGatewayDevice.Services.FAPService."
/* spr_21013_fix_end */
			"CellConfig.LTE.RAN.NeighborListInUse.InterRATCell.GSM",
			parent_name_len);
    /*coverity 109020 fix end */
	/*bug_14901_start*/
	if (cell_idx < OAM_ZERO)
	{
		OAM_LOG(OAM, OAM_WARNING,
				"Invalid cell_index");
		/* Coverity ID : 85862 Fix Start*/
		oam_mem_free(parameter_value, p_err);
		/* Coverity ID : 85862 Fix End*/
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;

	}
	/*bug_14901_end*/

	end_index = SON_PROV_REQ.neigh_list_in_use[cell_idx].inter_rat_gsm_neigh_size;


/*SPR 22442 Fix Start*/
	for(num_neighbor = OAM_ZERO; ((num_neighbor < end_index) && (num_neighbor < SON_MAX_NO_GERAN_NEIGHBOUR_CELLS) && (neighbor_array_idx < SON_MAX_NO_GERAN_NEIGHBOUR_CELLS));) {
/*SPR 22442 Fix End*/

		if (((SON_PROV_REQ.neigh_list_in_use[cell_idx].inter_rat_gsm_neigh_valid_bitmap) & (OAM_ONE << neighbor_array_idx)))
		{
			/* Populate PLMN-ID */
			oam_memset(temp_param, OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);
			oam_generate_plmnid(temp_param, &(NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].geran_neighbor.nbr_cgi.plmn_id));

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				/* Coverity ID : 85862 Fix Start*/
				for (neighbor_array_idx = OAM_ZERO;
						neighbor_array_idx < parameter_array_idx;
						++neighbor_array_idx) 
				{
					oam_mem_free(param_list[neighbor_array_idx], p_err);
				}   
                /*+-coverity_86856*_fix*/
				oam_mem_free(parameter_value, p_err);
				/* Coverity ID : 85862 Fix End*/
				OAM_FUN_EXIT_TRACE();
				return retVal;
			}

			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"PLMNID=%s", temp_param);

			oam_extract_lac_from_cell_identity(&out_lac,
					NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.nbr_cgi.
					cell_identity);

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				/* Coverity ID : 85862 Fix Start*/
				for (neighbor_array_idx = OAM_ZERO;
						neighbor_array_idx < parameter_array_idx;
						++neighbor_array_idx) 
				{
					oam_mem_free(param_list[neighbor_array_idx], p_err);
				}
                /*+-coverity_86856*_fix*/
				oam_mem_free(parameter_value, p_err);
				/* Coverity ID : 85862 Fix End*/
				OAM_FUN_EXIT_TRACE();
				return retVal;
			}
			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"LAC=%d", out_lac);

			oam_extract_ci_from_cell_identity(&out_ci,
					NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.nbr_cgi.
					cell_identity);

			retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
					(void**)&param_list[parameter_array_idx], p_err);
			if(OAM_FAILURE == retVal) {
				OAM_LOG(OAM, OAM_ERROR,
						"Memory allocation to param_list failed"
						" with Error Code:%d",
						*p_err);
				/* Coverity ID : 85862 Fix Start*/
				for (neighbor_array_idx = OAM_ZERO;
						neighbor_array_idx < parameter_array_idx;
						++neighbor_array_idx) 
				{
					oam_mem_free(param_list[neighbor_array_idx], p_err);
				}   
                /*+-coverity_86856*_fix*/
				oam_mem_free(parameter_value, p_err);
				/* Coverity ID : 85862 Fix End*/
				OAM_FUN_EXIT_TRACE();
				return retVal;
			}
			oam_memset(param_list[parameter_array_idx], OAM_ZERO, MAX_PARAMETER_NAME_LENGTH);

			oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
					"CI=%d", out_ci);

			if(SON_GERAN_PCI_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate PCI If present */

#ifdef OAM_SON_ENABLE /* +- SPR 13917 fix */
				oam_extract_value_from_bsic(&out_bsic,
						&NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].
						geran_neighbor.pci);

#endif /* +- SPR 13917 fix */                

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					/* Coverity ID : 85862 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}   
                    /*+-coverity_86856*_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85862 Fix End*/
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"BSIC=%d",
						out_bsic);
			}

			if(SON_GERAN_ARFCN_BAND_IND_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate band_ind If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					/* Coverity ID : 85862 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
                    /*+-coverity_86856*_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85862 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}
				oam_sprintf((Char8 *)parameter_value,"%d",
						NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].geran_neighbor.band_ind);
				oam_search_string_to_integer_for_get(parameter_value,
						&SON_GSM_BANDINDICATOR[OAM_ZERO],
						OAM_SON_GSM_BANDINDICATOR_TBL_NUM_ROWS);
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"BandIndicator=%s",
						parameter_value);

			}

			if(SON_GERAN_ARFCN_BAND_IND_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate arfcn If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					/* Coverity ID : 85862 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
					/*+-coverity_86856*_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85862 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
/*SPR 22398 Fix Start*/
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"BCCHARFCN=%d", NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].geran_neighbor.arfcn);
/*SPR 22398 Fix End*/
			}

			if(SON_GERAN_ENABLE_NR_STATUS_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate nr_status If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					/* Coverity ID : 85862 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
					/*+-coverity_86856*_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85862 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}
				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_NR_STATUS=%d", NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
						geran_neighbor.nr_status);
			}

			if(SON_GERAN_ENABLE_HO_STATUS_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].geran_neighbor.bitmask) {
				/* Populate X_VENDOR_HO_STATUS If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					/* Coverity ID : 85862 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}   
					/*+-coverity_86856*_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85862 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}


				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_HO_STATUS=%d", NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].geran_neighbor.ho_status);

			}

			if(SON_GERAN_RAC_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].geran_neighbor.bitmask) {
				/* Populate rac If present */

				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					/* Coverity ID : 85862 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
					/*+-coverity_86856*_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85862 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_RAC=%d", NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].geran_neighbor.rac);
			}

			if(SON_GERAN_CSO_PRESENT & NRT_INFO(cell_idx).nr_list.
					inter_rat_nr_list[neighbor_array_idx].geran_neighbor.bitmask) {
				/* Populate cell_specific_offset If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					/* Coverity ID : 85862 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
					/*+-coverity_86856*_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85862 Fix End*/
					OAM_FUN_EXIT_TRACE();
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);
				oam_snprintf(param_list[parameter_array_idx++], MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_CELL_SPECIFIC_OFFSET=%d", NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
						geran_neighbor.cell_specific_offset);
			}

			if(SON_GERAN_RSSI_PRESENT & NRT_INFO(cell_idx).nr_list.inter_rat_nr_list[neighbor_array_idx].
					geran_neighbor.bitmask) {
				/* Populate rssi If present */
				retVal = oam_mem_alloc(MAX_PARAMETER_NAME_LENGTH,
						(void**)&param_list[parameter_array_idx], p_err);
				if(OAM_FAILURE == retVal) {
					OAM_LOG(OAM, OAM_ERROR,
							"Memory allocation to param_list failed"
							" with Error Code:%d",
							*p_err);
					OAM_FUN_EXIT_TRACE();
					/* Coverity ID : 85862 Fix Start*/
					for (neighbor_array_idx = OAM_ZERO;
							neighbor_array_idx < parameter_array_idx;
							++neighbor_array_idx) 
					{
						oam_mem_free(param_list[neighbor_array_idx], p_err);
					}
					/*+-coverity_86856*_fix*/
					oam_mem_free(parameter_value, p_err);
					/* Coverity ID : 85862 Fix End*/
					return retVal;
				}

				oam_memset(param_list[parameter_array_idx], OAM_ZERO,
						MAX_PARAMETER_NAME_LENGTH);

				oam_snprintf(param_list[parameter_array_idx++],MAX_PARAMETER_NAME_LENGTH,
						"X_VENDOR_RSSI=%d", NRT_INFO(cell_idx).nr_list.
						inter_rat_nr_list[neighbor_array_idx].geran_neighbor.rssi);
			}


			num_neighbor++;
			neighbor_array_idx++;

		} /* End of if(...SON_INTER_GERAN_NEIGHBOR) */
		else
		{

			neighbor_array_idx++;
			continue;

		}

	}/* End of for loop */


	num_of_param = parameter_array_idx;

	retVal = oam_construct_n_send_gpv_response((UInt8*)parent_name,
			(UInt8**)param_list,
			num_of_param, trans_id,
			p_err, dst_id,
			start_index, end_index);

	for(neighbor_array_idx = OAM_ZERO; neighbor_array_idx < parameter_array_idx; ++neighbor_array_idx) {
		retVal = oam_mem_free(param_list[neighbor_array_idx], p_err);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_WARNING,
					"Error in memory free with error code: %d", *p_err);

		}
	}

	OAM_FUN_EXIT_TRACE();
	/* Coverity ID : 85862 Fix Start*/
	oam_mem_free(parameter_value, p_err);
	/* Coverity ID : 85862 Fix End*/

	return retVal;
	/* Coverity 69688 Changes End */
}

/* SPR-13586 END */

void oam_update_usr_added_neigh_to_nliu(UInt16 nliu_arr_idx,
		UInt16 nl_arr_idx)
{
	oam_son_anr_updated_nrt_info_t *p_local_nliu =
		&LOCAL_NRT_INFO(nliu_arr_idx);
	oam_son_nr_add_req_t *p_local_nr_list = &LOCAL_SON_NR_ADD_REQ(nl_arr_idx);
	UInt16 added_nbr_idx =
		LOCAL_SON_NEIGHBORLIST_INFO(nl_arr_idx).nr_list_query_idx;


	oam_memset(p_local_nliu, OAM_ZERO, sizeof(oam_son_anr_updated_nrt_info_t));
	oam_memcpy(&p_local_nliu->src_cgi,
			&p_local_nr_list->src_cgi,
			sizeof(son_intra_rat_global_cell_id_t));


	if(p_local_nr_list->nr_list.intra_rat_nr_list_size) {
		oam_memcpy(&p_local_nliu->nr_list.intra_rat_nr_list[0],
				&p_local_nr_list->nr_list.intra_rat_nr_list[added_nbr_idx],
				sizeof(son_intra_rat_neighbor_info_t));

		++p_local_nliu->nr_list.intra_rat_nr_list_size;
	}

	if (p_local_nr_list->nr_list.inter_rat_nr_list_size) {
		oam_memcpy(&p_local_nliu->nr_list.inter_rat_nr_list[0],
				&p_local_nr_list->nr_list.inter_rat_nr_list[added_nbr_idx],
				sizeof(son_inter_rat_neighbor_info_t));

		++p_local_nliu->nr_list.inter_rat_nr_list_size;
	}


	p_local_nliu->nrt_op = SON_NRT_OP_ADD;

	oam_son_update_neigh_list_in_use(nliu_arr_idx);
}

void oam_update_usr_updateded_neigh_to_nliu(UInt16 nliu_arr_idx,
		UInt16 nl_arr_idx)
{
	UInt16 idx = OAM_ZERO;
	oam_son_anr_updated_nrt_info_t *p_local_nliu =
		&LOCAL_NRT_INFO(nliu_arr_idx);
	oam_son_anr_updated_nrt_info_t *p_nliu = &NRT_INFO(nliu_arr_idx);
	oam_son_nr_add_req_t *p_local_nr_list = &LOCAL_SON_NR_ADD_REQ(nl_arr_idx);
	UInt16 nliu_idx = OAM_ZERO,
	       nliu_inter_idx = OAM_ZERO;

	UInt16 added_nbr_idx =
		LOCAL_SON_NEIGHBORLIST_INFO(nl_arr_idx).nr_list_query_idx;

	oam_memset(p_local_nliu, OAM_ZERO, sizeof(oam_son_anr_updated_nrt_info_t));

	oam_memcpy(&p_local_nliu->src_cgi,
			&p_local_nr_list->src_cgi,
			sizeof(son_intra_rat_global_cell_id_t));

	if(p_local_nr_list->nr_list.intra_rat_nr_list_size) {
		for(idx =0; idx < p_nliu->nr_list.intra_rat_nr_list_size; ++idx ) {
			if(!oam_memcmp(&p_nliu->nr_list.intra_rat_nr_list[idx].nbr_cgi,
						&p_local_nr_list->nr_list.
						intra_rat_nr_list[added_nbr_idx].nbr_cgi,
						sizeof(son_intra_rat_global_cell_id_t))) {
				oam_memcpy(
						&p_local_nliu->nr_list.intra_rat_nr_list[nliu_idx++],
						&p_local_nr_list->nr_list.
						intra_rat_nr_list[added_nbr_idx],
						sizeof(son_intra_rat_neighbor_info_t));


				++p_local_nliu->nr_list.intra_rat_nr_list_size;
			}
		}
	}
	/* SPR-13586 START */

	if(p_local_nr_list->nr_list.inter_rat_nr_list_size) {
		if(oam_prov_req.system_status.event_ongoing & OAM_SON_UPD_NR_UMTS_ONGOING)
		{    
/*SPR 22442 Fix Start*/
			for(idx =0; idx < SON_MAX_NO_UMTS_NEIGHBOUR_CELLS; ++idx ) {
/*SPR 22442 Fix End*/
				if(!oam_memcmp(&p_nliu->nr_list.inter_rat_nr_list[idx].
							utran_neighbor.nbr_cgi,
							&p_local_nr_list->nr_list.
							inter_rat_nr_list[added_nbr_idx].
							utran_neighbor.nbr_cgi,
							sizeof(son_utran_geran_global_cell_id_t))) {
					oam_memcpy(&p_local_nliu->nr_list.inter_rat_nr_list[nliu_inter_idx].utran_neighbor,
							&p_local_nr_list->nr_list.
							inter_rat_nr_list[added_nbr_idx].utran_neighbor,
							sizeof(son_utran_neighbor_info_t));
					p_local_nliu->nr_list.inter_rat_nr_list[nliu_inter_idx].bitmask |= SON_INTER_UTRAN_NEIGHBOR;
					/* SPR 14297 Fix Start */
					++p_local_nliu->nr_list.inter_rat_nr_list_size;
					break;
					/* SPR 14297 Fix End */
				}
			} 
		}
		if(oam_prov_req.system_status.event_ongoing & OAM_SON_UPD_NR_GSM_ONGOING)
		{    
/*SPR 22442 Fix Start*/
			for(idx =0; idx < SON_MAX_NO_GERAN_NEIGHBOUR_CELLS; ++idx ) {
/*SPR 22442 Fix End*/
				if(!oam_memcmp(&p_nliu->nr_list.inter_rat_nr_list[idx].
							geran_neighbor.nbr_cgi,
							&p_local_nr_list->nr_list.
							inter_rat_nr_list[added_nbr_idx].
							geran_neighbor.nbr_cgi,
							sizeof(son_utran_geran_global_cell_id_t))) {
					oam_memcpy(&p_local_nliu->nr_list.inter_rat_nr_list[nliu_inter_idx].geran_neighbor,
							&p_local_nr_list->nr_list.
							inter_rat_nr_list[added_nbr_idx].geran_neighbor,
							sizeof(son_geran_neighbor_info_t));
					p_local_nliu->nr_list.inter_rat_nr_list[nliu_inter_idx].bitmask |= SON_INTER_GERAN_NEIGHBOR;

					++p_local_nliu->nr_list.inter_rat_nr_list_size;
					break;
				}
			} 
		}
		/* SPR-13586 END */
	}


	p_local_nliu->nrt_op = SON_NRT_OP_UPDATE;

	oam_son_update_neigh_list_in_use(nliu_arr_idx);
}


void oam_update_intra_rat_nr(son_intra_rat_neighbor_info_t *p_to,
		son_intra_rat_neighbor_info_t *p_from)
{
	UInt32 bitmask = OAM_ZERO;
	UInt16 cnt = OAM_ZERO;
	bitmask = p_from->bitmask;

	if(bitmask & SON_PCI_PRESENT) {
		p_to->bitmask |= SON_PCI_PRESENT;

		p_to->pci = p_from->pci;
	}

	if(bitmask & SON_CELL_OFFSET_PRESENT) {
		p_to->bitmask |= SON_CELL_OFFSET_PRESENT;

		p_to->cell_specific_offset = p_from->cell_specific_offset;
	}

	if(bitmask & SON_TAC_PRESENT) {
		p_to->bitmask |= SON_TAC_PRESENT;

		oam_memcpy(p_to->tac, p_from->tac, SON_TAC_OCTET_SIZE);
	}

	if(bitmask & SON_PLMN_ID_PRESENT) {
		p_to->bitmask |= SON_PLMN_ID_PRESENT;

		p_to->num_plmn_id = p_from->num_plmn_id;
		for(cnt = OAM_ZERO;
				cnt < p_to->num_plmn_id; ++cnt) {
			oam_memcpy(p_to->plmn_id, p_from->plmn_id,
					sizeof(son_cell_plmn_info_t));
		}
	}

	if(bitmask & SON_INTRA_CSG_ID_PRESENT) {
		p_to->bitmask |= SON_INTRA_CSG_ID_PRESENT;

		oam_memcpy(p_to->csg_identity, p_from->csg_identity,
				SON_CSG_ID_OCTET_SIZE);
	}

	if(bitmask & SON_EARFCN_PRESENT) {
		p_to->bitmask |= SON_EARFCN_PRESENT;

		p_to->earfcn = p_from->earfcn;
	}

	if(bitmask & SON_RSRP_PRESENT) {
		p_to->bitmask |= SON_RSRP_PRESENT;

		p_to->rsrp = p_from->rsrp;
	}

	if(bitmask & SON_RSRQ_PRESENT) {
		p_to->bitmask |= SON_RSRQ_PRESENT;

		p_to->rsrq = p_from->rsrq;
	}

	if(bitmask & SON_ENABLE_NR_STATUS_PRESENT) {
		p_to->bitmask |= SON_ENABLE_NR_STATUS_PRESENT;

		p_to->nr_status = p_from->nr_status;
	}

	if(bitmask & SON_ENABLE_HO_STATUS_PRESENT) {
		p_to->bitmask |= SON_ENABLE_HO_STATUS_PRESENT;

		p_to->ho_status = p_from->ho_status;
	}

	if(bitmask & SON_ENABLE_X2_STATUS_PRESENT) {
		p_to->bitmask |= SON_ENABLE_X2_STATUS_PRESENT;

		p_to->x2_status = p_from->x2_status;
	}

	if(bitmask & SON_EUTRAN_NR_HO_STATS_PRESENT) {
		p_to->bitmask |= SON_EUTRAN_NR_HO_STATS_PRESENT;

		oam_memcpy(&p_to->handover_stats, &p_from->handover_stats,
				sizeof(son_neighbor_handover_stats_t));
	}

	if(bitmask & SON_SUSPECT_PCI_PRESENT) {
		p_to->bitmask |= SON_SUSPECT_PCI_PRESENT;

		p_to->suspected_pci = p_from->suspected_pci;
	}

	/* OAM_2.3 SI SPR_559 CHANGES START */
	if(bitmask & SON_CM_CELL_OFFSET_PRESENT) {
		p_to->bitmask |= SON_CM_CELL_OFFSET_PRESENT;

		p_to->cm_cell_specific_offset = p_from->cm_cell_specific_offset;
	}
	/* OAM_2.3 SI SPR_559 CHANGES END */

	/*SPR 14380 start*/
	if (bitmask & SON_EICIC_INFO_PRESENT)
	{
		p_to->bitmask |= SON_EICIC_INFO_PRESENT;
		if(p_from->eicic_info.bitmask
				&
				SON_CELL_INTF_SCHEME_TYPE_PRESENT)
		{
			p_to->eicic_info.bitmask
				|=
				SON_CELL_INTF_SCHEME_TYPE_PRESENT;
			p_to->eicic_info.interference_scheme
				=
				p_from->eicic_info.interference_scheme;
		}
		if (p_from->eicic_info.bitmask
				&
				SON_CELL_ABS_USAGE_THRESHOLD_PRESENT)
		{
			p_to->eicic_info.bitmask
				|=
				SON_CELL_ABS_USAGE_THRESHOLD_PRESENT;
			if (p_from->eicic_info.abs_usage_threshold.bitmask
					&
					SON_CELL_MIN_ABS_USAGE_THRESHOLD_PRESENT)
			{
				p_to->eicic_info.abs_usage_threshold.bitmask
					|=
					SON_CELL_MIN_ABS_USAGE_THRESHOLD_PRESENT;
				p_to->eicic_info.abs_usage_threshold.min_abs_usage_threshold
					=
					p_from->eicic_info.abs_usage_threshold.min_abs_usage_threshold;
			}
			if (p_from->eicic_info.abs_usage_threshold.bitmask
					&
					SON_CELL_MAX_ABS_USAGE_THRESHOLD_PRESENT)
			{
				p_to->eicic_info.abs_usage_threshold.bitmask
					|=
					SON_CELL_MAX_ABS_USAGE_THRESHOLD_PRESENT;

				p_to->eicic_info.abs_usage_threshold.max_abs_usage_threshold
					=
					p_from->eicic_info.abs_usage_threshold.max_abs_usage_threshold;
			}

		}
	}

	/*SPR 14380 end*/

	/* SPR 14321 Fix Start */
	if(bitmask & SON_BROADCAST_STATUS_PRESENT) {
		p_to->bitmask |= SON_BROADCAST_STATUS_PRESENT;

		p_to->broadcast_status = p_from->broadcast_status;
	}
	if(bitmask & SON_ACCESS_MODE_PRESENT) {
		p_to->bitmask |= SON_ACCESS_MODE_PRESENT;

		p_to->access_mode = p_from->access_mode;
	}
	if(bitmask & SON_PRACH_CONFIGURATION_PRESENT)
	{
		p_to->bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
		p_to->prach_config.root_sequence_index =
			p_from->prach_config.root_sequence_index;
		p_to->prach_config.zero_correlation_zone_config
			=
			p_from->prach_config.zero_correlation_zone_config;
		p_to->prach_config.high_speed_flag
			=
			p_from->prach_config.high_speed_flag;
		p_to->prach_config.prach_frequency_offset
			=
			p_from->prach_config.prach_frequency_offset;
		if(p_from->prach_config.bitmask
				&
				SON_PRACH_CONFIG_INDEX_PRESENT)
		{
			p_to->prach_config.bitmask
				|=
				SON_PRACH_CONFIG_INDEX_PRESENT;
			p_to->prach_config.prach_configuration_index
				=
				p_from->prach_config.prach_configuration_index;
		}

	}
	/* SPR 14321 Fix End */

}

/* SPR-13586 SATRT */
void oam_update_inter_rat_nr(son_utran_neighbor_info_t *p_to,
		son_utran_neighbor_info_t *p_from)
{
	UInt32 bitmask = OAM_ZERO;      
	UInt16 cnt = OAM_ZERO;
	bitmask = p_from->bitmask;

	if(bitmask & SON_UTRAN_PCI_PRESENT) {
		p_to->bitmask |= SON_UTRAN_PCI_PRESENT;

		if(p_from->pci.bitmask & SON_PCI_FDD_PRESENT)
		{
			p_to->pci.bitmask |= SON_PCI_FDD_PRESENT;
			p_to->pci.pci_fdd =
				p_from->pci.pci_fdd;
		}

		if(p_from->pci.bitmask & SON_PCI_TDD_PRESENT)
		{
			p_to->pci.bitmask |= SON_PCI_TDD_PRESENT;
			p_to->pci.pci_tdd =
				p_from->pci.pci_tdd;
		}
	}

	if(bitmask & SON_UTRAN_CSO_PRESENT) {
		p_to->bitmask |= SON_UTRAN_CSO_PRESENT;

		p_to->cell_specific_offset =
			p_from->cell_specific_offset;
	}

	if(p_from->bitmask & SON_UTRAN_PLMN_ID_PRESENT) {
		p_to->bitmask |= SON_UTRAN_PLMN_ID_PRESENT;

		p_to->num_plmn_id =
			p_from->num_plmn_id;

		for(cnt = OAM_ZERO;
				cnt < p_to->num_plmn_id; ++cnt) {
			oam_memcpy(
					p_to->plmn_id,
					p_from->plmn_id,
					sizeof(son_cell_plmn_info_t));
		}
	}

	if(bitmask & SON_UTRAN_LAC_PRESENT) {
		p_to->bitmask |= SON_UTRAN_LAC_PRESENT;

		oam_memcpy(p_to->lac,
				p_from->lac,
				SON_LAC_OCTET_SIZE);
	}

	if(bitmask & SON_UTRAN_RAC_PRESENT) {
		p_to->bitmask |= SON_UTRAN_RAC_PRESENT;

		p_to->rac =
			p_from->rac;
	}

	if(bitmask & SON_UTRAN_CSG_ID_PRESENT) {
		p_to->bitmask |= SON_UTRAN_CSG_ID_PRESENT;

		oam_memcpy(p_to->csg_identity,
				p_from->csg_identity,
				SON_CSG_ID_OCTET_SIZE);
	}

	if(bitmask & SON_UTRAN_UARFCN_PRESENT) {
		p_to->bitmask |= SON_UTRAN_UARFCN_PRESENT;

		p_to->uarfcn =
			p_from->uarfcn;
	}

	if(bitmask & SON_UTRAN_RSCP_PRESENT) {
		p_to->bitmask |= SON_UTRAN_RSCP_PRESENT;

		p_to->rscp =
			p_from->rscp;
	}

	if(bitmask & SON_UTRAN_ECNO_PRESENT) {
		p_to->bitmask |= SON_UTRAN_ECNO_PRESENT;

		p_to->ecno =
			p_from->ecno;
	}

	if(bitmask & SON_UTRAN_ENABLE_NR_STATUS_PRESENT) {
		p_to->bitmask |= SON_UTRAN_ENABLE_NR_STATUS_PRESENT;

		p_to->nr_status =
			p_from->nr_status;
	}

	if(bitmask & SON_UTRAN_ENABLE_HO_STATUS_PRESENT) {
		p_to->bitmask |= SON_UTRAN_ENABLE_HO_STATUS_PRESENT;

		p_to->ho_status =
			p_from->ho_status;
	}

	if(bitmask & SON_UTRAN_NR_HO_STATS_PRESENT) {
		p_to->bitmask |= SON_UTRAN_NR_HO_STATS_PRESENT;

		oam_memcpy(&p_to->handover_stats,
				&p_from->handover_stats,
				sizeof(son_neighbor_handover_stats_t));
	}
	if(bitmask & SON_UTRAN_PS_HO_SUPPORT_PRESENT) {
		p_to->bitmask |= SON_UTRAN_PS_HO_SUPPORT_PRESENT;

		p_to->ps_ho_supported =
			(son_bool_et)p_from->ps_ho_supported;
	}
	if(bitmask & SON_UTRAN_PS_HO_SUPPORT_PRESENT) {
		p_to->bitmask |= SON_UTRAN_VOIP_CAPABLE_PRESENT;

		p_to->voip_capable =
			(son_bool_et)p_from->voip_capable;
	}
}
/*End: SPR 10567 */

void oam_update_inter_rat_gsm_nr(son_geran_neighbor_info_t *p_to,
		son_geran_neighbor_info_t *p_from)
{
	UInt32 bitmask = OAM_ZERO;
	bitmask = p_from->bitmask;

	if(bitmask & SON_GERAN_PCI_PRESENT) {
		p_to->bitmask |= SON_GERAN_PCI_PRESENT;

		p_to->pci.ncc =
			p_from->pci.ncc;

		p_to->pci.bscc =
			p_from->pci.bscc;

	}
	if(bitmask & SON_GERAN_CSO_PRESENT) {
		p_to->bitmask |= SON_GERAN_CSO_PRESENT;

		p_to->cell_specific_offset =
			p_from->cell_specific_offset;

	}
	if(bitmask & SON_GERAN_RAC_PRESENT) {
		p_to->bitmask |= SON_GERAN_RAC_PRESENT;

		p_to->rac =
			p_from->rac;

	}
	if(bitmask & SON_GERAN_ARFCN_BAND_IND_PRESENT) {
		p_to->bitmask |= SON_GERAN_ARFCN_BAND_IND_PRESENT;

		p_to->arfcn =
			p_from->arfcn;

	}
	if(bitmask & SON_GERAN_ARFCN_BAND_IND_PRESENT) {
		p_to->bitmask |= SON_GERAN_ARFCN_BAND_IND_PRESENT;

		p_to->band_ind =
			p_from->band_ind;

	}
	if(bitmask & SON_GERAN_RSSI_PRESENT) {
		p_to->bitmask |= SON_GERAN_RSSI_PRESENT;

		p_to->rssi =
			p_from->rssi;

	}
	if(bitmask & SON_GERAN_ENABLE_NR_STATUS_PRESENT) {
		p_to->bitmask |= SON_GERAN_ENABLE_NR_STATUS_PRESENT;

		p_to->nr_status =
			p_from->nr_status;

	}
	if(bitmask & SON_GERAN_ENABLE_HO_STATUS_PRESENT) {
		p_to->bitmask |= SON_GERAN_ENABLE_HO_STATUS_PRESENT;

		p_to->ho_status =
			p_from->ho_status;

	}

}
/* SPR-13586 END */
/* SPR 12200 Fix Start */
#endif
/******************************************************************************
 *   FUNCTION NAME : oam_copy_operator_info_parameter_to_reconfig 
 *   Inputs        : p_rrm_oam_cell_reconf_operator_info,
 *                   p_rrm_oam_cell_conf_operator_info,
 *
 *   DESCRIPTION   : This function used to copy Operator Info 
 *                   parameter from config to reconfig
 *
 *   RETURNS       : Void 
 *
 ******************************************************************************/
void
oam_copy_operator_info_parameter_to_reconfig(
		rrm_oam_operator_info_t *p_rrm_oam_cell_reconf_operator_info, 
		rrm_oam_operator_info_t * p_rrm_oam_cell_conf_operator_info)
{
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_MAC_CONFIG_PRESENT)
	{
		oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->rrm_mac_config,
				(void *)&p_rrm_oam_cell_conf_operator_info->rrm_mac_config,
				sizeof(rrm_oam_rrmc_mac_config_t));
        /* SPR 20653 Fix Start */
		if(p_rrm_oam_cell_reconf_operator_info->rrm_mac_config.bitmask & RRM_OAM_PERIODIC_REPORT_REQUIRED_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_mac_config.periodic_report_required = 
				p_rrm_oam_cell_conf_operator_info->rrm_mac_config.periodic_report_required;
		}
		if(p_rrm_oam_cell_reconf_operator_info->rrm_mac_config.bitmask & RRM_OAM_PERIODIC_REPORT_PERIODICITY_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_mac_config.periodic_report_periodicity = 
				p_rrm_oam_cell_conf_operator_info->rrm_mac_config.periodic_report_periodicity;
		}
		if(p_rrm_oam_cell_reconf_operator_info->rrm_mac_config.bitmask & RRM_OAM_PERIODIC_REPORT_UE_BATCH_SIZE_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_mac_config.periodic_report_ue_batch_size = 
				p_rrm_oam_cell_conf_operator_info->rrm_mac_config.periodic_report_ue_batch_size;
		}
		if(p_rrm_oam_cell_reconf_operator_info->rrm_mac_config.bitmask & RRM_OAM_SAMPLING_NORMAL_TIME)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_mac_config.sampling_normal_time = 
				p_rrm_oam_cell_conf_operator_info->rrm_mac_config.sampling_normal_time;
		}
        /* SPR 20653 Fix Start */
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_PHICH_CONFIG_PRESENT)
	{
		oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->phich_config,
				(void *)&p_rrm_oam_cell_conf_operator_info->phich_config,
				sizeof(rrm_oam_phy_phich_configuration_t));
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ADDL_SIB1_INFO_PRESENT)
	{
		if(p_rrm_oam_cell_reconf_operator_info->sib_1_info.bitmask & RRM_OAM_IMS_EMERGENCY_SUPPORT_R9_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->sib_1_info.ims_emergency_support_r9 = 
				p_rrm_oam_cell_conf_operator_info->sib_1_info.ims_emergency_support_r9;
		}
		if(p_rrm_oam_cell_reconf_operator_info->sib_1_info.bitmask & RRM_OAM_CELL_SELECTION_INFO_R9_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->sib_1_info.cell_selection_info.q_qual_min_r9 = 
				p_rrm_oam_cell_conf_operator_info->sib_1_info.cell_selection_info.q_qual_min_r9;

			if(p_rrm_oam_cell_conf_operator_info->sib_1_info.cell_selection_info.bitmask & RRM_OAM_Q_QUAL_MIN_OFFSET_R9_PRESENT)
			{
				p_rrm_oam_cell_reconf_operator_info->sib_1_info.cell_selection_info.q_qual_min_offset_r9_present= 
					p_rrm_oam_cell_conf_operator_info->sib_1_info.cell_selection_info.q_qual_min_offset_r9_present;

			}
		}
		if(p_rrm_oam_cell_reconf_operator_info->sib_1_info.bitmask & RRM_OAM_SI_WINDOW_SIZE_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->sib_1_info.si_window_length = 
				p_rrm_oam_cell_conf_operator_info->sib_1_info.si_window_length;
		}
		p_rrm_oam_cell_reconf_operator_info->sib_1_info.si_count= 
			p_rrm_oam_cell_conf_operator_info->sib_1_info.si_count;
		oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->sib_1_info.scheduling_info,
				(void *)&p_rrm_oam_cell_conf_operator_info->sib_1_info.scheduling_info,
				sizeof(rrm_oam_scheduling_info_t));
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ADDL_SIB2_INFO_PRESENT)
	{
		oam_copy_sib2_info_parameter_to_reconfig(
				p_rrm_oam_cell_reconf_operator_info,
				p_rrm_oam_cell_conf_operator_info);

	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ADDL_SIB3_INFO_PRESENT)
	{
		oam_copy_sib3_info_parameter_to_reconfig(
				p_rrm_oam_cell_reconf_operator_info,
				p_rrm_oam_cell_conf_operator_info);
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ADDL_SIB4_INFO_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->sib_4_info.csg_id_range.start =
			p_rrm_oam_cell_conf_operator_info->sib_4_info.csg_id_range.start;

		if(p_rrm_oam_cell_reconf_operator_info->sib_4_info.csg_id_range.bitmask 
				& RRM_OAM_CELL_ID_RANGE_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->sib_4_info.csg_id_range.range=
				p_rrm_oam_cell_conf_operator_info->sib_4_info.csg_id_range.range;

		}

	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ADDMISION_CONTROL_INFO_PRESENT)
	{
		oam_copy_radio_admission_control_info_parameter_to_reconfig(
				p_rrm_oam_cell_reconf_operator_info,
				p_rrm_oam_cell_conf_operator_info);
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_POWER_CONTROL_INFO_PRESENT)
	{
		oam_copy_power_control_parameter_to_reconfig(
				p_rrm_oam_cell_reconf_operator_info,
				p_rrm_oam_cell_conf_operator_info);
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_SPS_CRNTI_RANGE_PRESENT)
	{
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->rrm_sps_crnti_range,
				(void*)&p_rrm_oam_cell_conf_operator_info->rrm_sps_crnti_range,
				sizeof(rrm_oam_sps_crnti_range_t));
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ACK_NACK_CQI_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info-> simultaneous_ack_nack_and_cqi =
			p_rrm_oam_cell_conf_operator_info-> simultaneous_ack_nack_and_cqi;
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ADD_PACKET_SCH_PARAMS_PRESENT)
	{
		/*need to further enhance */
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->additional_packet_scheduling_params,
				(void*)&p_rrm_oam_cell_conf_operator_info->additional_packet_scheduling_params,
				sizeof(rrm_oam_adl_pkt_scheduling_params_t));
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ADD_CELL_PARAMS_PRESENT)
	{
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->additional_cell_params,
				(void*)&p_rrm_oam_cell_conf_operator_info->additional_cell_params,
				sizeof(rrm_oam_adl_cell_params_t));
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_LOAD_PARAMS_PRESENT)
	{
		if(p_rrm_oam_cell_reconf_operator_info->load_params.bitmask & RRM_OAM_WAIT_TIME_PRESENT)
		{      
			p_rrm_oam_cell_reconf_operator_info->load_params.wait_time =
				p_rrm_oam_cell_conf_operator_info->load_params.wait_time;
		}
        /* SPR 20653 Fix Start */
		if(p_rrm_oam_cell_reconf_operator_info->load_params.bitmask & RRM_OAM_EXTENDED_WAIT_TIME_PRESENT)
		{      
			p_rrm_oam_cell_reconf_operator_info->load_params.extended_wait_time =
				p_rrm_oam_cell_conf_operator_info->load_params.extended_wait_time;
		}
        /* SPR 20653 Fix End */
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_MIMO_MODE_PARAMS_PRESENT)
	{
		/*need to further enhance */
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->load_params,
				(void*)&p_rrm_oam_cell_conf_operator_info->load_params,
				sizeof(rrm_oam_load_params_t));
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_HO_CONFIGURATION_PRESENT)
	{
		/*need to further enhance */
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->ho_configuration,
				(void*)&p_rrm_oam_cell_conf_operator_info->ho_configuration,
				sizeof(rrm_oam_ho_config_params_t));
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_MEASUREMENT_CONFIG_PRESENT)
	{
		/*need to further enhance */
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->measurement_configuration,
				(void*)&p_rrm_oam_cell_conf_operator_info->measurement_configuration,
				sizeof(rrm_oam_meas_config_t));
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_CELL_CAPACITY_CLASS_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->cell_capacity_class =
			p_rrm_oam_cell_conf_operator_info->cell_capacity_class;

	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_CELL_TYPE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->cell_type=
			p_rrm_oam_cell_conf_operator_info->cell_type;

	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT)
	{
		/*need to further enhance */
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->dynamic_icic_info,
				(void*)&p_rrm_oam_cell_conf_operator_info->dynamic_icic_info,
				sizeof(rrm_oam_dynamic_icic_info_t));
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_EUTRAN_ACCESS_POINT_POS_PRESENT)
	{
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->rrm_eutran_access_point_pos,
				(void*)&p_rrm_oam_cell_conf_operator_info->rrm_eutran_access_point_pos,
				sizeof(rrm_oam_eutran_access_point_pos_t));
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->rrm_ue_scheduling_info.max_ue_scheduled_dl =
			p_rrm_oam_cell_conf_operator_info->rrm_ue_scheduling_info.max_ue_scheduled_dl;

		p_rrm_oam_cell_reconf_operator_info->rrm_ue_scheduling_info.max_ue_scheduled_ul=
			p_rrm_oam_cell_conf_operator_info->rrm_ue_scheduling_info.max_ue_scheduled_ul;

		if(p_rrm_oam_cell_reconf_operator_info->rrm_ue_scheduling_info.bitmask & RRM_OAM_UE_SCHEDULING_HYSTERESIS_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_ue_scheduling_info.ue_scheduling_hysteresis=
				p_rrm_oam_cell_conf_operator_info->rrm_ue_scheduling_info.ue_scheduling_hysteresis;
		}
        /* SPR 20653 Fix Start */
		if(p_rrm_oam_cell_reconf_operator_info->rrm_ue_scheduling_info.bitmask & RRM_OAM_ACTIVE_UE_REPORTS_TIMER_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_ue_scheduling_info.active_ue_reports_timer=
				p_rrm_oam_cell_conf_operator_info->rrm_ue_scheduling_info.active_ue_reports_timer;
		}
        /* SPR 20653 Fix End */
	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_ENABLE_CQI_MASK_R9_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->rrm_enable_cqi_mask_r9=
			p_rrm_oam_cell_conf_operator_info->rrm_enable_cqi_mask_r9;

	}

	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_CA_CONFIG_INFO_PRESENT)
	{
		oam_copy_CA_parameter_to_reconfig(
				p_rrm_oam_cell_reconf_operator_info,
				p_rrm_oam_cell_conf_operator_info);
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_SUBBAND_CQI_PARAM_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->k = p_rrm_oam_cell_conf_operator_info->k;
	}
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_SUBBAND_CQI_PERIODICTY_FACTOR_R10_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->periodicity_factor = p_rrm_oam_cell_conf_operator_info->periodicity_factor;
	}
	/* eICIC_PHASE_1_2_CHANGES_START */
	if(p_rrm_oam_cell_reconf_operator_info->bitmask & RRM_OAM_EICIC_INFO_PRESENT)
	{
		oam_copy_eICIC_parameter_to_reconfig(
				p_rrm_oam_cell_reconf_operator_info,
				p_rrm_oam_cell_conf_operator_info);
	}
	/* eICIC_PHASE_1_2_CHANGES_END */
#ifdef LTE_EMBMS_SUPPORTED
    if (p_rrm_oam_cell_reconf_operator_info->bitmask &
            RRM_OAM_EMBMS_POWER_INFO_PRESENT)
    {
        oam_memcpy(&p_rrm_oam_cell_reconf_operator_info->mbms_power_info,
                &p_rrm_oam_cell_conf_operator_info->mbms_power_info,
                sizeof(rrm_oam_mbms_power_info_t));
    }
#endif

}

/******************************************************************************
 *   FUNCTION NAME : oam_copy_sib2_info_parameter_to_reconfig 
 *   Inputs        : p_rrm_oam_cell_reconf_operator_info,
 *                   p_rrm_oam_cell_conf_operator_info,
 *
 *   DESCRIPTION   : This function used to copy sib2 
 *                   parameter from config to reconfig
 *
 *   RETURNS       : Void 
 *
 ******************************************************************************/

void
oam_copy_sib2_info_parameter_to_reconfig(
		rrm_oam_operator_info_t *p_rrm_oam_cell_reconf_operator_info, 
		rrm_oam_operator_info_t * p_rrm_oam_cell_conf_operator_info)
{

	if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.bitmask 
			& RRM_OAM_MODIFICATION_PERIOD_COEFF_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.modification_period_coeff= 
			p_rrm_oam_cell_conf_operator_info->sib_2_info.radio_res_config_common_sib.modification_period_coeff;

	} 
	if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.bitmask 
			& RRM_OAM_DEFAULT_PAGING_CYCLE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.default_paging_cycle = 
			p_rrm_oam_cell_conf_operator_info->sib_2_info.radio_res_config_common_sib.default_paging_cycle;
	}
	if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.bitmask 
			& RRM_OAM_NB_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.nB= 
			p_rrm_oam_cell_conf_operator_info->sib_2_info.radio_res_config_common_sib.nB;
	}
	if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.bitmask 
			& RRM_OAM_UL_CYCLIC_PREFIX_LEN_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length= 
			p_rrm_oam_cell_conf_operator_info->sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length;

	}
	if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.bitmask 
			& RRM_OAM_BARRING_INFO_PRESENT)
	{
		if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask 
				& RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT)
		{
			oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->sib_2_info.
					radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_signalling,
					(void *)&p_rrm_oam_cell_conf_operator_info->sib_2_info.
					radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_signalling,
					sizeof(rrm_oam_access_class_barring_information_t));
		}
		if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask 
				& RRM_OAM_AC_BARRING_MO_DATA_PRESENT)
		{
			oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->sib_2_info.
					radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data,
					(void *)&p_rrm_oam_cell_conf_operator_info->sib_2_info.
					radio_res_config_common_sib.access_barring_info.ac_barring_for_mo_data,
					sizeof(rrm_oam_access_class_barring_information_t));

		}
		if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask 
				& RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT)
		{
			if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.
					access_barring_info.ssac_barring_r9.bitmask & RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT)
			{
				oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->sib_2_info.
						radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9,
						(void *)&p_rrm_oam_cell_reconf_operator_info->sib_2_info.
						radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9,
						sizeof(rrm_oam_access_class_barring_information_t));

			}
			if(p_rrm_oam_cell_reconf_operator_info->sib_2_info.radio_res_config_common_sib.
					access_barring_info.ssac_barring_r9.bitmask & RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT)
			{
				oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->sib_2_info.
						radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9,
						(void *)&p_rrm_oam_cell_reconf_operator_info->sib_2_info.
						radio_res_config_common_sib.access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9,
						sizeof(rrm_oam_access_class_barring_information_t));
			}

		}
	}
	p_rrm_oam_cell_reconf_operator_info->sib_2_info.additional_spectrum_emission =
		p_rrm_oam_cell_conf_operator_info->sib_2_info.additional_spectrum_emission;

	p_rrm_oam_cell_reconf_operator_info->sib_2_info.time_alignment_timer_common=
		p_rrm_oam_cell_conf_operator_info->sib_2_info.time_alignment_timer_common;

	oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->sib_2_info.ac_barring_for_csfb_r10,
			(void *)&p_rrm_oam_cell_conf_operator_info->sib_2_info.ac_barring_for_csfb_r10,
			sizeof(rrm_oam_access_class_barring_information_t));

}


/******************************************************************************
 *   FUNCTION NAME : oam_copy_sib3_info_parameter_to_reconfig 
 *   Inputs        : p_rrm_oam_cell_reconf_operator_info,
 *                   p_rrm_oam_cell_conf_operator_info,
 *
 *   DESCRIPTION   : This function used to copy sib3 
 *                   parameter from config to reconfig
 *
 *   RETURNS       : Void 
 *
 ******************************************************************************/

void
oam_copy_sib3_info_parameter_to_reconfig(
		rrm_oam_operator_info_t *p_rrm_oam_cell_reconf_operator_info, 
		rrm_oam_operator_info_t * p_rrm_oam_cell_conf_operator_info)
{

	p_rrm_oam_cell_reconf_operator_info->sib_3_info.intra_freq_reselection_info.presence_antenna_port1=
		p_rrm_oam_cell_conf_operator_info->sib_3_info.intra_freq_reselection_info.presence_antenna_port1;

	if(p_rrm_oam_cell_reconf_operator_info->sib_3_info.intra_freq_reselection_info.bitmask 
			& RRM_OAM_MEAS_BW_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->sib_3_info.intra_freq_reselection_info.measurement_bandwidth=
			p_rrm_oam_cell_conf_operator_info->sib_3_info.intra_freq_reselection_info.measurement_bandwidth;
	}  
	if(p_rrm_oam_cell_reconf_operator_info->sib_3_info.bitmask & RRM_OAM_S_INTRA_SEARCH_V920_PRESENT)
	{
		oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->sib_3_info.s_intra_search,
				(void *)&p_rrm_oam_cell_conf_operator_info->sib_3_info.s_intra_search,
				sizeof(rrm_oam_s_intra_search_v920_t)); 
	}
	if(p_rrm_oam_cell_reconf_operator_info->sib_3_info.bitmask & RRM_OAM_S_NON_INTRA_SEARCH_V920_PRESENT)
	{
		oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->sib_3_info.s_non_intra_search,
				(void *)&p_rrm_oam_cell_conf_operator_info->sib_3_info.s_non_intra_search,
				sizeof(rrm_oam_s_non_intra_search_v920_t)); 
	}
	if(p_rrm_oam_cell_reconf_operator_info->sib_3_info.bitmask & RRM_OAM_Q_QUAL_MIN_R9_PRESENT1)
	{
		p_rrm_oam_cell_reconf_operator_info->sib_3_info.q_qual_min_r9 =
			p_rrm_oam_cell_conf_operator_info->sib_3_info.q_qual_min_r9;
	}
	if(p_rrm_oam_cell_reconf_operator_info->sib_3_info.bitmask & RRM_OAM_THRESHOLD_SERVING_LOW_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->sib_3_info.thresh_serving_lowq_r9=
			p_rrm_oam_cell_conf_operator_info->sib_3_info.thresh_serving_lowq_r9;
	}

}

/******************************************************************************
 *   FUNCTION NAME : oam_copy_radio_admission_control_info_parameter_to_reconfig 
 *   Inputs        : p_rrm_oam_cell_reconf_operator_info,
 *                   p_rrm_oam_cell_conf_operator_info,
 *
 *   DESCRIPTION   : This function used to copy radio addmission control
 *                   parameter from config to reconfig
 *
 *   RETURNS       : Void 
 *
 ******************************************************************************/

void
oam_copy_radio_admission_control_info_parameter_to_reconfig(
		rrm_oam_operator_info_t *p_rrm_oam_cell_reconf_operator_info, 
		rrm_oam_operator_info_t * p_rrm_oam_cell_conf_operator_info)
{

	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_NUM_UE_PER_CELL_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.max_num_ue_per_cell =
			p_rrm_oam_cell_conf_operator_info->admission_control_info.max_num_ue_per_cell;  
	}
	p_rrm_oam_cell_reconf_operator_info->admission_control_info.max_sps_ues =
		p_rrm_oam_cell_conf_operator_info->admission_control_info.max_sps_ues; 

	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_NUM_GBR_DRBS_PER_UE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.max_num_gbr_drbs_per_ue=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.max_num_gbr_drbs_per_ue;  
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_NUM_NGBR_DRBS_PER_UE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.max_num_non_gbr_drbs_per_ue=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.max_num_non_gbr_drbs_per_ue;  
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_TOTAL_DL_PRB_BUDGET)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.dl_prb_budget=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.dl_prb_budget;  
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_TOTAL_UL_PRB_BUDGET)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.ul_prb_budget=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.ul_prb_budget;  
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_TOTAL_DL_GBR_PRB_BUDGET)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.dl_prb_budget_gbr=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.dl_prb_budget_gbr;  
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_TOTAL_UL_GBR_PRB_BUDGET)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.ul_prb_budget_gbr=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.ul_prb_budget_gbr;  
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_TOTAL_DL_NGBR_PRB_BUDGET)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.dl_prb_budget_ngbr=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.dl_prb_budget_ngbr;  
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MAX_TOTAL_UL_NGBR_PRB_BUDGET)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.ul_prb_budget_ngbr=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.ul_prb_budget_ngbr;  
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_AVAILABLE_GBR_LIMIT_PRESENT)
	{
		oam_memcpy((void *)&p_rrm_oam_cell_reconf_operator_info->admission_control_info.ul_prb_budget_ngbr,
				(void *)&p_rrm_oam_cell_conf_operator_info->admission_control_info.ul_prb_budget_ngbr,
				sizeof(available_gbr_limit_t));
	}
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_RESOURCE_RESERVED_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.resource_reserved_for_existing_users=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.resource_reserved_for_existing_users;  
	}
	p_rrm_oam_cell_reconf_operator_info->admission_control_info.total_backhaul_capacity=
		p_rrm_oam_cell_conf_operator_info->admission_control_info.total_backhaul_capacity; 

	p_rrm_oam_cell_reconf_operator_info->admission_control_info.capacity_threshold=
		p_rrm_oam_cell_conf_operator_info->admission_control_info.capacity_threshold; 

	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_SPID_TABLE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.spid_table=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.spid_table;  
	}

	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_PREEMPTION_ALLOWED_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.preemption_allowed=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.preemption_allowed;  
	}

	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_PREEMPTION_STATUS_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.preemption_status=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.preemption_status;  
	}

	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_PROXIMITY_IND_STATUS_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.proximity_indication_status=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.proximity_indication_status;  
	}
    /* SPR 20653 Fix Start */
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_SRB_BIT_RATE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.srb_bit_rate=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.srb_bit_rate;  
	}
    
	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_MIN_BITRATE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.minimum_bitrate=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.minimum_bitrate;  
	}

	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_NGBR_THRESHOLD_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.ngbr_threshold=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.ngbr_threshold;  
	}

	if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
			& RRM_OAM_NON_DEFAULT_BEARER_MULTIPLIER_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->admission_control_info.non_default_bearer_multiplier=
			p_rrm_oam_cell_conf_operator_info->admission_control_info.non_default_bearer_multiplier;  
	}
    if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.bitmask
            & RRM_OAM_PRB_ESTIMATION_FACTOR_PRESENT)
    {
        if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.prb_estimation_factor.bitmask
                & RRM_OAM_DL_PRB_PER_BPS_PRESENT)
        {
            p_rrm_oam_cell_reconf_operator_info->admission_control_info.prb_estimation_factor.dl_prb_per_bps=
                p_rrm_oam_cell_conf_operator_info->admission_control_info.prb_estimation_factor.dl_prb_per_bps;  
        }
        if (p_rrm_oam_cell_reconf_operator_info->admission_control_info.prb_estimation_factor.bitmask
                & RRM_OAM_UL_PRB_PER_BPS_PRESENT)
        {
            p_rrm_oam_cell_reconf_operator_info->admission_control_info.prb_estimation_factor.ul_prb_per_bps=
                p_rrm_oam_cell_conf_operator_info->admission_control_info.prb_estimation_factor.ul_prb_per_bps;  
        }
    }
    p_rrm_oam_cell_reconf_operator_info->admission_control_info.max_eicic_ues=
        p_rrm_oam_cell_conf_operator_info->admission_control_info.max_eicic_ues;  
    /* SPR 20653 Fix End */

}

/******************************************************************************
 *   FUNCTION NAME : oam_copy_power_control_parameter_to_reconfig 
 *   Inputs        : p_rrm_oam_cell_reconf_operator_info,
 *                   p_rrm_oam_cell_conf_operator_info,
 *
 *   DESCRIPTION   : This function used to copy power control
 *                   parameter from config to reconfig
 *
 *   RETURNS       : Void 
 *
 ******************************************************************************/
void
oam_copy_power_control_parameter_to_reconfig(
		rrm_oam_operator_info_t *p_rrm_oam_cell_reconf_operator_info, 
		rrm_oam_operator_info_t * p_rrm_oam_cell_conf_operator_info)
{

	if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.bitmask
			& RRM_OAM_POWER_CONTROL_ENABLE_PRESENT)
	{
		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_HARQ_BLER_CLPC_PUCCH_ENABLE_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.harqBlerClpcPucchEnable=
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.rrm_power_control_enable.harqBlerClpcPucchEnable;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_CQI_SINR_CLPC_PUCCH_ENABLE_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.cqiSinrClpcPucchEnable=
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.rrm_power_control_enable.cqiSinrClpcPucchEnable;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_CLPC_PUSCH_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.clpcPuschEnable=
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.rrm_power_control_enable.clpcPuschEnable;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DCI_3_3A_PUCCH_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.dci_3_3a_based_power_control_for_pucch_enable = 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.dci_3_3a_based_power_control_for_pucch_enable;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DCI_3_3A_PUSCH_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.dci_3_3a_based_power_control_for_pusch_enable= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.dci_3_3a_based_power_control_for_pusch_enable;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_CLPC_PUSCH_FREQ_SELECTIVE_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.clpcPuschfreqSelectiveEnable= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.clpcPuschfreqSelectiveEnable;
		}

		p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
			rrm_power_control_enable.pdcchPowOrAggregationEnable= 
			p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
			rrm_power_control_enable.pdcchPowOrAggregationEnable;

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_MCS_ENABLED_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_mcs_enabled= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_mcs_enabled;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_ACCUMULATION_ENABLED_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.accumulation_enabled= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.accumulation_enabled;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_F_PUCCH_FORMAT_1_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_1= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_1;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_F_PUCCH_FORMAT_1B_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_1b= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_1b;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_F_PUCCH_FORMAT_2_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_2= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_2;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_F_PUCCH_FORMAT_2A_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_2a= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_2a;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_F_PUCCH_FORMAT_2B_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_2b= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_2b;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_PREAMBLE_MSG_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_preamble_msg_3= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_preamble_msg_3;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_F_PUCCH_FORMAT_1B_CS_R10_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_1b_cs_r10= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_1b_cs_r10;
		}

		if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_power_control_enable.bitmask &
				RRM_OAM_DELTA_F_PUCCH_FORMAT_3_R10_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_3_r10= 
				p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.
				rrm_power_control_enable.delta_f_pucch_format_3_r10;
		}

	}
    /* SPR 20653 Fix Start */ 
	if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.bitmask
			& RRM_OAM_UL_POWER_CONTROL_DEDICATED_PRESENT)
	{
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.uplink_power_control_dedicated,
				(void*)&p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.uplink_power_control_dedicated,
				sizeof(rrm_oam_uplink_power_control_dedicated_info_t));
    }
    /* SPR 20653 Fix End */ 
	if (p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.bitmask
			& RRM_OAM_TPC_RNTI_RANGE_PRESENT)
	{
		oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->rrm_power_control_params.rrm_tpc_rnti_range,
				(void*)&p_rrm_oam_cell_conf_operator_info->rrm_power_control_params.rrm_tpc_rnti_range,
				sizeof(rrm_oam_tpc_rnti_range_t));
	}
}

/* eICIC_PHASE_1_2_CHANGES_START */
/******************************************************************************
 *   FUNCTION NAME : oam_copy_eICIC_parameter_to_reconfig
 *   Inputs        : p_rrm_oam_cell_reconf_operator_info,
 *                   p_rrm_oam_cell_conf_operator_info,
 *
 *   DESCRIPTION   : This function used to copy eICIC parameters from config to
 *                   reconfig
 *
 *   RETURNS       : Void
 *
 ******************************************************************************/
void
oam_copy_eICIC_parameter_to_reconfig(
		rrm_oam_operator_info_t *p_rrm_oam_cell_reconf_operator_info,
		rrm_oam_operator_info_t * p_rrm_oam_cell_conf_operator_info)
{
	if(p_rrm_oam_cell_reconf_operator_info->eicic_info.bitmask 
			& RRM_OAM_EICIC_PROVISIONED_TYPE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->eicic_info.eicic_provisioned_type=
			p_rrm_oam_cell_conf_operator_info->eicic_info.eicic_provisioned_type;

	}

	if(p_rrm_oam_cell_reconf_operator_info->eicic_info.bitmask 
			& RRM_OAM_EICIC_ELIGIBLE_UE_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->eicic_info.eligible_ue=
			p_rrm_oam_cell_conf_operator_info->eicic_info.eligible_ue;

	}

	if(p_rrm_oam_cell_reconf_operator_info->eicic_info.bitmask
			& RRM_OAM_ABS_INFO_PRESENT)
	{
		if(p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.bitmask 
				& RRM_OAM_NUM_ABS_REPORT_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.num_abs_report=
				p_rrm_oam_cell_conf_operator_info->eicic_info.abs_info.num_abs_report;

		}
		if(p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.bitmask 
				& RRM_OAM_ABS_USAGE_LOW_THRESHOLD_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.abs_usage_low_threshold=
				p_rrm_oam_cell_conf_operator_info->eicic_info.abs_info.abs_usage_low_threshold;

		}
		if(p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.bitmask 
				& RRM_OAM_ABS_USAGE_HIGH_THRESHOLD_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.abs_usage_high_threshold=
				p_rrm_oam_cell_conf_operator_info->eicic_info.abs_info.abs_usage_high_threshold;

		}
		if(p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.bitmask 
				& RRM_OAM_ABS_PATTERN_INFO_PRESENT)
		{
			if(p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.abs_pattern.bitmask 
					& RRM_OAM_LOW_LOAD_ABS_PATTERN_PRESENT)
			{
				oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->eicic_info.
						abs_info.abs_pattern.low_load_abs_pattern,
						(void*)&p_rrm_oam_cell_conf_operator_info->eicic_info.
						abs_info.abs_pattern.low_load_abs_pattern,
						RRM_MAX_PATTERN_BYTE);

			}
			if(p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.abs_pattern.bitmask 
					& RRM_OAM_VICTIM_ABS_PATTERN_PRESENT)
			{
				oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->eicic_info.
						abs_info.abs_pattern.victim_abs_pattern,
						(void*)&p_rrm_oam_cell_conf_operator_info->eicic_info.
						abs_info.abs_pattern.victim_abs_pattern,
						RRM_MAX_PATTERN_BYTE);

			}

			/*SPR 14180 start*/
			if(p_rrm_oam_cell_reconf_operator_info->eicic_info.abs_info.abs_pattern.bitmask
					& RRM_OAM_VICTIM_MEAS_SUBSET_PRESENT)
			{
				oam_memcpy((void*)&p_rrm_oam_cell_reconf_operator_info->eicic_info.
						abs_info.abs_pattern.victim_meas_subset,
						(void*)&p_rrm_oam_cell_conf_operator_info->eicic_info.
						abs_info.abs_pattern.victim_meas_subset,
						RRM_MAX_PATTERN_BYTE);

			}

			/*SPR 14180 end*/

		}
	}
	if(p_rrm_oam_cell_reconf_operator_info->eicic_info.bitmask 
			& RRM_OAM_EICIC_TIMER_INFO_PRESENT)
	{
		if(p_rrm_oam_cell_reconf_operator_info->eicic_info.eicic_timer_info.bitmask 
				& RRM_OAM_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->eicic_info.eicic_timer_info.
				mac_eicic_meas_report_periodicity=p_rrm_oam_cell_conf_operator_info->eicic_info.
				eicic_timer_info.mac_eicic_meas_report_periodicity;

		}
		if(p_rrm_oam_cell_reconf_operator_info->eicic_info.eicic_timer_info.bitmask 
				& RRM_OAM_AGGRESSOR_SEL_TIMER_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->eicic_info.
				eicic_timer_info.aggressor_sel_timer= p_rrm_oam_cell_conf_operator_info->eicic_info.
				eicic_timer_info.aggressor_sel_timer;

		}
		if(p_rrm_oam_cell_reconf_operator_info->eicic_info.eicic_timer_info.bitmask 
				& RRM_OAM_LOAD_INFORMATION_GUAURD_TIMER_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->eicic_info.eicic_timer_info.
				load_information_guard_timer= p_rrm_oam_cell_conf_operator_info->eicic_info.
				eicic_timer_info.load_information_guard_timer;

		}
		if(p_rrm_oam_cell_reconf_operator_info->eicic_info.eicic_timer_info.bitmask 
				& RRM_OAM_LOAD_INFORMATION_COLLATION_TIMER)
		{
			p_rrm_oam_cell_reconf_operator_info->eicic_info.
				eicic_timer_info.load_information_collation_timer= p_rrm_oam_cell_conf_operator_info->eicic_info.
				eicic_timer_info.load_information_collation_timer;

		}
	}
	if(p_rrm_oam_cell_reconf_operator_info->eicic_info.bitmask 
			& RRM_OAM_DL_SINR_THRESHOLD_LOW_MARK_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->eicic_info.dl_sinr_threshold_low_mark=
			p_rrm_oam_cell_conf_operator_info->eicic_info.dl_sinr_threshold_low_mark;

	}
	if(p_rrm_oam_cell_reconf_operator_info->eicic_info.bitmask 
			& RRM_OAM_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->eicic_info.dl_sinr_threshold_high_mark=
			p_rrm_oam_cell_conf_operator_info->eicic_info.dl_sinr_threshold_high_mark;

	}

}

/* eICIC_PHASE_1_2_CHANGES_END */
/******************************************************************************
 *   FUNCTION NAME : oam_copy_CA_parameter_to_reconfig 
 *   Inputs        : p_rrm_oam_cell_reconf_operator_info,
 *                   p_rrm_oam_cell_conf_operator_info,
 *
 *   DESCRIPTION   : This function used to copy ca parameter from config to 
 *                   reconfig
 *
 *   RETURNS       : Void 
 *
 ******************************************************************************/
void
oam_copy_CA_parameter_to_reconfig(
		rrm_oam_operator_info_t *p_rrm_oam_cell_reconf_operator_info, 
		rrm_oam_operator_info_t * p_rrm_oam_cell_conf_operator_info)
{
	if(p_rrm_oam_cell_reconf_operator_info->ca_config.bitmask & RRM_OAM_IS_CA_ELIGIBLE_INFO_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->ca_config.is_ca_eligible=
			p_rrm_oam_cell_conf_operator_info->ca_config.is_ca_eligible;

	}
	if(p_rrm_oam_cell_reconf_operator_info->ca_config.bitmask & RRM_OAM_NUM_OF_REPORT_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->ca_config.num_of_report=
			p_rrm_oam_cell_conf_operator_info->ca_config.num_of_report;

	}
	if(p_rrm_oam_cell_reconf_operator_info->ca_config.bitmask & RRM_OAM_CA_APPLICABLE_BITRATE_DL_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->ca_config.ca_applicable_bitrate_dl=
			p_rrm_oam_cell_conf_operator_info->ca_config.ca_applicable_bitrate_dl;

	}
	if(p_rrm_oam_cell_reconf_operator_info->ca_config.bitmask & RRM_OAM_IS_MASA_INFO_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->ca_config.is_masa=
			p_rrm_oam_cell_conf_operator_info->ca_config.is_masa;

	}
	if(p_rrm_oam_cell_reconf_operator_info->ca_config.bitmask & RRM_OAM_SCELL_DEACTIVATION_TIMER_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->ca_config.scell_deactivation_timer=
			p_rrm_oam_cell_conf_operator_info->ca_config.scell_deactivation_timer;

	}
	if(p_rrm_oam_cell_reconf_operator_info->ca_config.bitmask & RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT)
	{
		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.load_calcualtion_window_size=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.load_calcualtion_window_size;
		}

		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_LOAD_DISPARITY_THRESHOLD_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.load_disparity_threshold=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.load_disparity_threshold;
		}

		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_MCS_DIFF_THRESHOLD_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.mcs_diff_threshold=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.mcs_diff_threshold;
		}

		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_PRB_USAGE_WATER_MARK_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.prb_usage_water_mark=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.prb_usage_water_mark;
		}

		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_DL_DEACT_COMMAND_THRESH_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.dl_deact_command_thresh=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.dl_deact_command_thresh;
		}

		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_DL_DEACT_MCS_LOW_THRESH_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.dl_deact_mcs_low_thresh=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.dl_deact_mcs_low_thresh;
		}

		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_DL_Q_LOAD_UP_THRESH_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.dl_qload_up_threshold=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.dl_qload_up_threshold;
		}

		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_DL_Q_LOAD_LOW_THRESH_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.dl_qload_low_threshold=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.dl_qload_low_threshold;
		}

		if(p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.bitmask 
				& RRM_OAM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT)
		{
			p_rrm_oam_cell_reconf_operator_info->ca_config.ca_mac_scheduler_params.act_deact_trigger_count_threshold=
				p_rrm_oam_cell_conf_operator_info->ca_config.ca_mac_scheduler_params.act_deact_trigger_count_threshold;
		}
	}
	if(p_rrm_oam_cell_reconf_operator_info->ca_config.bitmask & RRM_OAM_CA_ASSOCIATED_LAYER2_INST_FIELD_PRESENT)
	{
		/* SPR 21206 Start */
		p_rrm_oam_cell_reconf_operator_info->associated_layer2_inst=
			p_rrm_oam_cell_conf_operator_info->associated_layer2_inst;
		/* SPR 21206 End */
	}
	if(p_rrm_oam_cell_reconf_operator_info->ca_config.bitmask & RRM_OAM_MEAS_CYCLE_SCELL_PRESENT)
	{
		p_rrm_oam_cell_reconf_operator_info->ca_config.meas_cycle_scell=
			p_rrm_oam_cell_conf_operator_info->ca_config.meas_cycle_scell;
	}

}
/* SPR 12200 Fix */

/****************************************************************************
 *   FUNCTION NAME: oam_validate_cell_specific_access_mode
 *
 *   DESCRIPTION:   This function validates the user input value of access
 *                  mode parameter in case of multi-cell configuration
 *   Inputs       : cell_identity:parameter value
 *                 loop : index of the parameter in parameter table
 *   Output       : NONE
 *
 *   RETURNS:       OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
	oam_return_et
oam_validate_cell_specific_access_mode(UInt8 *p_val, SInt32 loop, UInt8* opt)
{
	oam_return_et retVal = OAM_FAILURE;

	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, opt);

	if (!p_val) {
		OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");
	}
	else if (!oam_strcasecmp((Char8*)p_val, "OpenAccess") ||
			!oam_strcasecmp((Char8*)p_val, "ClosedAccess") ||
			!oam_strcasecmp((Char8*)p_val, "HybridAccess")) {
		retVal = OAM_SUCCESS;
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/****************************************************************************
 *   FUNCTION NAME: oam_validate_cell_specific_max_ues_served
 *
 *   DESCRIPTION:   This function validates the user input value of
 *                 MaxUEsServed parameter in case of multi-cell configuration
 *   Inputs       : cell_identity:parameter value
 *                 loop : index of the parameter in parameter table
 *   Output       : NONE
 *
 *   RETURNS:       OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
	oam_return_et
oam_validate_cell_specific_max_ues_served(UInt8 *p_val,
		SInt32 loop,
		UInt8* opt)
{
	oam_return_et retVal = OAM_FAILURE;
	SInt32 val = OAM_ZERO;

	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, opt);

	if (!p_val) {
		OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");
	}
	else if (oam_isnumber((Char8*)p_val)) {
		val = oam_atoi((Char8*)p_val);

		if (val >= OAM_MAX_UES_SERVED_MIN_VAL ||
				val <= OAM_MAX_UES_SERVED_MAX_VAL) {
			retVal = OAM_SUCCESS;
		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/****************************************************************************
 *   FUNCTION NAME: oam_validate_cell_specific_csgid
 *
 *   DESCRIPTION:   This function validates the user input value of
 *                 CSGID parameter in case of multi-cell configuration
 *   Inputs       : cell_identity:parameter value
 *                 loop : index of the parameter in parameter table
 *   Output       : NONE
 *
 *   RETURNS:       OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
	oam_return_et
oam_validate_cell_specific_csgid(UInt8 *p_val, SInt32 loop, UInt8* opt)
{
	oam_return_et retVal = OAM_FAILURE;
	SInt32 val = OAM_ZERO;

	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, opt);

	if (!p_val) {
		OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");
	}
	else if (oam_isnumber((Char8*)p_val)) {
		val = oam_atoi((Char8*)p_val);

		if (val >= OAM_CSGID_MIN_VAL || val <= OAM_CSGID_MAX_VAL) {
			retVal = OAM_SUCCESS;
		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/****************************************************************************
 *   FUNCTION NAME: oam_validate_cell_specific_max_csg_members
 *
 *   DESCRIPTION:   This function validates the user input value of
 *                MaxCSGMembers parameter in case of multi-cell configuration
 *   Inputs       : cell_identity:parameter value
 *                 loop : index of the parameter in parameter table
 *   Output       : NONE
 *
 *   RETURNS:       OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
	oam_return_et
oam_validate_cell_specific_max_csg_members(UInt8 *p_val,
		SInt32 loop,
		UInt8* opt)
{
	oam_return_et retVal = OAM_FAILURE;
	SInt32 val = OAM_ZERO;

	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, opt);


	if (!p_val) {
		OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");
	}
	else if (oam_isnumber((Char8*)p_val)) {
		val = oam_atoi((Char8*)p_val);

		if (val >= MIN_RRM_CELL_MAXCSGMEMBERS ||
				val <= MAX_RRM_CELL_MAXCSGMEMBERS) {
			retVal = OAM_SUCCESS;
		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}

/****************************************************************************
 *   FUNCTION NAME: oam_validate_cell_specific_max_non_csg_members
 *
 *   DESCRIPTION:   This function validates the user input value of
 *                  MaxNonCSGMembers parameter in case of multi-cell
 *                  configuration
 *   Inputs       : cell_identity:parameter value
 *                 loop : index of the parameter in parameter table
 *   Output       : NONE
 *
 *   RETURNS:       OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
	oam_return_et
oam_validate_cell_specific_max_non_csg_members(UInt8 *p_val,
		SInt32 loop,
		UInt8* opt)
{
	oam_return_et retVal = OAM_FAILURE;
	SInt32 val = OAM_ZERO;

	OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d and %p", loop, opt);


	if (!p_val) {
		OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");
	}
	else if (oam_isnumber((Char8*)p_val)) {
		val = oam_atoi((Char8*)p_val);

		if (val >= MIN_RRM_CELL_MAXNONCSGMEMBERS ||
				val <= MAX_RRM_CELL_MAXNONCSGMEMBERS) {
			retVal = OAM_SUCCESS;
		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}


#ifdef OAM_SON_ENABLE
/****************************************************************************
 *   FUNCTION NAME: oam_validata_send_nw_scan_config_cmd
 *
 *   DESCRIPTION:   This function validates the user input parameters and
 *                  sends SON_OAM_NW_SCAN_CONFIG_CMD to SON
 *   Inputs       : p_param_blk: pointer to buffer for input parameter blocks
 *                  received from user
 *                  num_params: number of parameter blocks in the input
 *                  buffer
 *   Output       : NONE
 *
 *   RETURNS:       OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
	oam_return_et
oam_validata_send_nw_scan_config_cmd(UInt8 *p_param_blk, UInt8 num_params,
		oam_error_code_et *p_err)
{
	OAM_FUN_ENTRY_TRACE();

	oam_return_et retVal = OAM_FAILURE;
	oam_son_set_nw_scan_config_cmd_t *p_api_buf = OAM_NULL;
	UInt8 cnt = OAM_ZERO;
	UInt16 param_info_blk_len = OAM_ZERO;
	UInt16 name_value_pair_len = OAM_ZERO;
	Char8 name_value_pair[MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	Char8 *param_name = OAM_NULL;
	Char8 *param_value = OAM_NULL;
	UInt32 value = OAM_ZERO;
	UInt16 trans_id = OAM_ZERO;
	UInt8 curr_cell_id = oam_prov_req.cell_cntxt.curr_cell_cid;

	if (!p_err) {
		OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}

	OAM_LOG(OAM, OAM_INFO,
			"User request to change network scan behaviour received");

	*p_err = NO_ERROR;

	if (!p_param_blk) {
		OAM_LOG(OAM, OAM_WARNING, "NULL pointer error");
		*p_err = OAM_NULL_POINTER_ERR;

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}


	retVal = oam_mem_alloc(sizeof(oam_son_set_nw_scan_config_cmd_t),
			(void**)&p_api_buf, p_err);

	if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_api_buf failed"
                " with Error Code:%d",
                *p_err);
		*p_err = OAM_MALLOC_FAIL;

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}

	oam_memset(p_api_buf, 0, sizeof(oam_son_set_nw_scan_config_cmd_t));

	for (cnt = OAM_ZERO; cnt < num_params; ++cnt) {
		param_info_blk_len = get_word_from_header(p_param_blk);
		p_param_blk += OAM_WORD_SIZE_IN_BYTE;

		/* Reserved byte */
		p_param_blk += OAM_WORD_SIZE_IN_BYTE;

		name_value_pair_len = param_info_blk_len -
			(OAM_WORD_SIZE_IN_BYTE + OAM_WORD_SIZE_IN_BYTE);

		if (MAX_PARAMETER_NAME_LENGTH > name_value_pair_len) {
			oam_memset(name_value_pair, 0, MAX_PARAMETER_NAME_LENGTH);
			oam_memcpy(name_value_pair, p_param_blk, name_value_pair_len);

			p_param_blk += name_value_pair_len;
		}
		else {
			OAM_LOG(OAM, OAM_WARNING, "Parameter name too long");
			*p_err = OAM_PARAM_NAME_TOO_LONG;
			retVal = OAM_FAILURE;
			break;
		}

		OAM_LOG(OAM, OAM_DETAILED,
				"Parameter received: %s", name_value_pair);

		param_name = oam_strtok(name_value_pair, "=");
		param_value = oam_strtok(OAM_NULL, "=");
		if (param_name && param_value) {
			value = oam_atoi(param_value);

			if (oam_strstr(param_name, "X_VENDOR_FORCEFUL_SCAN_FLAG")) {
				if (value == 0 || value == 1) {
					p_api_buf->force_scan_on_off = value;
				}
				else {
					*p_err = OAM_SET_PARAMETER_INPUT_INCORRECT;
					retVal = OAM_FAILURE;
					break;
				}
			}
			else if (oam_strstr(param_name, "X_VENDOR_SCAN_DATA_TIMEOUT")) {
				p_api_buf->scan_time_interval = value;
			}
			else {
				*p_err = OAM_PARAMETER_NOT_FOUND;
				retVal = OAM_FAILURE;
				break;
			}
		}
	}

	if (OAM_SUCCESS == retVal) {
		trans_id = oam_get_new_trans_id();

		retVal = oam_son_send_son_oam_set_nw_scan_config_cmd(p_api_buf,
				OAM_MODULE_ID,
				SON_MODULE_ID,
				trans_id,
				curr_cell_id);
	}

	oam_mem_free(p_api_buf, p_err);

	OAM_FUN_EXIT_TRACE();
	return retVal;
}
/* BCOM Compiltaion Fix */
#endif
/* BCOM Compiltaion Fix */
/* SPR-9485 START */
/****************************************************************************
 *   FUNCTION NAME: createCurrGrpIdList
 *
 *   DESCRIPTION:   This function creates local list of group_ids per plmn_ids
 as received in mme_info
 *   Inputs       : served_gummei_info
 *   Output       : local_oam_anr_gu_group_info
 *
 *   RETURNS:     : void
 ***************************************************************************/
/* SPR-16334 START */
#ifdef OAM_SON_ENABLE
void createCurrGrpIdList
(
        local_oam_anr_gu_group_info_t *p_local_gu_group_info, 
        /*Coverity 66604 Fix Start*/
        s1ap_served_gummei_info_t *p_served_gummei_info
        /*Coverity 66604 Fix End*/
)
#else
void createCurrGrpIdList
(
        local_oam_gu_group_id_list_t *p_local_gu_group_info,
        /*Coverity 66604 Fix Start*/
        s1ap_served_gummei_info_t *p_served_gummei_info
        /*Coverity 66604 Fix End*/
)
#endif
{
  UInt8             mme_num_served_plmns,
                    mme_num_served_group_ids,
                    loop1,
                    loop2,
                    count = OAM_ZERO,
                    retVal = OAM_SUCCESS;
  Char8 tmp_plmn_identity[MAX_PLMN_ID_BYTES] = {OAM_ZERO},
        temp[OAM_SEVEN] = {0};
  OAM_FUN_ENTRY_TRACE();
  /*Coverity 66604 Fix Start*/
  mme_num_served_plmns = p_served_gummei_info->num_served_plmns;
  mme_num_served_group_ids = p_served_gummei_info->num_served_group_ids;
  /*Coverity 66604 Fix End*/

  p_local_gu_group_info->num_gu_group_id =
    (mme_num_served_plmns * mme_num_served_group_ids);

  if(p_local_gu_group_info->num_gu_group_id > OAM_MAX_ENB_POOLS)
  {
    p_local_gu_group_info->num_gu_group_id = OAM_MAX_ENB_POOLS;
  }
  OAM_LOG(OAM,OAM_DETAILED,
      "Generating Current List of Group IDs");

  /* to create local list received from S1AP_OAM_MME_INFO and stores PLMN in form(mcc, mnc and num_mnc_digit) to be sent to SON/OAM in SON_OAM_ANR_GU_GROUP_ID_CONFIG_REQ */
  /* loop to store one to one mapping of PLMNID and GROUP_ID */
  for(loop1 = OAM_ZERO; (loop1 < mme_num_served_plmns); loop1++)
  {
	  oam_memcpy((void *)tmp_plmn_identity,
			  /*Coverity 66604 Fix Start*/
			  (const void *)p_served_gummei_info->plmn_identity[loop1].plmn_id,MAX_PLMN_ID_BYTES);
	  /*Coverity 66604 Fix End*/
	  oam_memset(temp, OAM_ZERO, OAM_SEVEN);
	  /* to convert plmn from 3 octet to 7 octets */ 
	  oam_decode_plmnid((UInt8 *)tmp_plmn_identity, 
			  temp);
	  for(loop2 = OAM_ZERO; loop2< mme_num_served_group_ids; loop2++)
	  {
		  /* to convert PLMNID in mnc, mcc format */
		  retVal=oam_populate_plmnid(temp,
				  (void *)&p_local_gu_group_info->gu_id_list[count].plmn_id);
		  if(OAM_FAILURE == retVal) {
			  OAM_LOG(OAM, OAM_WARNING, "Population of PLMN-ID failed.");
			  OAM_FUN_EXIT_TRACE();
			  return;
		  }
		  /*Coverity 66604 Fix Start*/
		  oam_memcpy((Char8 *)p_local_gu_group_info->gu_id_list[count].mme_group_id,
				  (const Char8 *)p_served_gummei_info->served_group_id[loop2].mmegi, 
				  OAM_TWO);
		  /*Coverity 66604 Fix End*/
		  count++;
		  if(count == OAM_MAX_ENB_POOLS)
			  break;

		  /* SPR-16334 END */

	  }
	  if(count == SON_MAX_ENB_POOLS)
		  break;
  }
	OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME: getDelta
 *
 *   DESCRIPTION:   This function will identify the need to send add delta list
 and delete delta list of group ids to be sent to SON
 *   Inputs       : local_oam_anr_gu_group_info : local list of group ids for current MME,
oam_s1ap_mme_info           : MME info for current MME received in S1AP_MME_INFO
 *   Output       : oam_son_anr_gu_group_id_config_req : add/delete delta group_id lists
 *   RETURNS:     : isDelta : true if any of(or both) add/delete lists needs to be sent
 ***************************************************************************/

/* SPR-16334 START */
oam_bool_et getDelta
(
#ifdef OAM_SON_ENABLE
 local_oam_anr_gu_group_info_t *p_local_gu_group_info,
 oam_son_anr_gu_group_id_config_req_t *p_gu_group_info,
#else
 local_oam_gu_group_id_list_t *p_local_gu_group_info,
 oam_x2ap_enb_config_update_req_t *p_gu_group_info,
#endif
 /*Coverity 66605 fix Start*/ 
 s1ap_oam_mme_info_t  *p_oam_s1ap_mme_info,
 /*Coverity 66605 fix Start*/ 
 SInt8 *mme_index
)
{

    UInt8             gu_count_add = OAM_ZERO,
                      gu_count_delete = OAM_ZERO;
    UInt8             loop = OAM_ZERO,
                      loop1 = OAM_ZERO,
                      loop2 = OAM_ZERO,
                      loop3 = OAM_ZERO,
                      retVal=OAM_SUCCESS;
    oam_bool_et       found_mme_plmn_group = OAM_FALSE,
                      group_match_found_my_mme = OAM_FALSE,
                      group_match_found_other_mme = OAM_FALSE,
                      isDelta = OAM_FALSE;
    Char8 tmp_plmnid_1[OAM_SEVEN] = {0},
          tmp_plmnid_2[OAM_SEVEN] = {0},
          temp[OAM_SEVEN] = {0};
    /*cov 96911 +*/
    /* searches for all the group_id and plmn_id pairs of all the MMEs info received till now and compares with currently received MME info, if not found then add to add delta list */ 
    for(loop1=OAM_ZERO ;loop1< p_local_gu_group_info->num_gu_group_id;loop1++)
    {
        found_mme_plmn_group = OAM_FALSE;
        oam_memset(tmp_plmnid_1, OAM_ZERO, OAM_SEVEN);
        oam_plmnid_from_mcc_mnc(tmp_plmnid_1,
                &p_local_gu_group_info->gu_id_list[loop1].plmn_id);
        for(loop2=OAM_ZERO ;loop2 < g_oam_connected_mme_info.num_mme;loop2++)
        {
            for(loop3=OAM_ZERO ;loop3< g_oam_connected_mme_info.internal_mme_info[loop2].num_plmn_id_group_id;loop3++)
            {
                oam_memset(tmp_plmnid_2, OAM_ZERO, OAM_SEVEN);
                oam_decode_plmnid((UInt8 *) g_oam_connected_mme_info.internal_mme_info[loop2].plmn_id_per_gp_id[loop3].plmn_id,
                        (Char8*)tmp_plmnid_2);
                if(!oam_strcmp((const char *)tmp_plmnid_1,
                            (const char *)tmp_plmnid_2))
                {
                    if(!oam_memcmp((const void *)p_local_gu_group_info->gu_id_list[loop1].mme_group_id,
                                (const void *)g_oam_connected_mme_info.internal_mme_info[loop2].
                                group_id_per_plmn_id[loop3].mmegi,MMEGI_OCTET_SIZE))
                    {
                        found_mme_plmn_group = OAM_TRUE;
                        break;
                    }
                }
            }
            if(OAM_TRUE == found_mme_plmn_group)
            {
                break;
            }
        }
        if(OAM_FALSE == found_mme_plmn_group)
        {
            OAM_LOG(OAM,OAM_DETAILED,
                    "Adding Group ID to add List");

#ifdef OAM_SON_ENABLE
            p_gu_group_info->bitmask |= 
                SON_OAM_GU_GROUP_ID_TO_ADD_LIST_PRESENT;
            gu_count_add = 
                p_gu_group_info->gu_group_id_to_add_list.num_gu_group_id;
            p_gu_group_info->gu_group_id_to_add_list.num_gu_group_id++;
            oam_memcpy((void *)&p_gu_group_info->gu_group_id_to_add_list.gu_id_list[gu_count_add],
                    (const void *)&p_local_gu_group_info->gu_id_list[loop1], 
                    sizeof(son_gu_group_id_t));
#else
            p_gu_group_info->bitmask |= 
                X2AP_GU_GROUP_ID_TO_ADD_LIST_PRESENT;
            gu_count_add =
                p_gu_group_info->add_gu_id.num_gu_group_id;
            p_gu_group_info->add_gu_id.num_gu_group_id++;
            oam_memcpy((void *)&p_gu_group_info->add_gu_id.gu_id_list[gu_count_add],
                    (const void *)&p_local_gu_group_info->gu_id_list[loop1],
                    sizeof(x2ap_gu_group_id_t));
#endif
        }
    }

    /* Check if the MME info received is for any previously received MME info or for a new MME */ 
    for(loop = OAM_ZERO;loop< g_oam_connected_mme_info.num_mme;loop++)
    {
	    if(!oam_strcmp((char *)g_oam_connected_mme_info.oam_s1ap_mme_info[loop].ip_addr,
				    /*Coverity 66605 fix Start*/ 
				    (char *)p_oam_s1ap_mme_info->ip_addr))
		                    /*Coverity 66605 fix Start*/ 
	    {
		    *mme_index = loop;
		    break;
	    }
    }

    /* if MME info received is updated info of previously received MME info, search for difference previous and current MME status and generate deleted delta list */ 
    if(*mme_index != -1)
    {
        for(loop1=OAM_ZERO;loop1<g_oam_connected_mme_info.internal_mme_info[*mme_index].num_plmn_id_group_id;loop1++)
        {
            group_match_found_my_mme = OAM_FALSE;
            oam_memset(tmp_plmnid_1, OAM_ZERO, OAM_SEVEN);
            oam_decode_plmnid((UInt8 *)g_oam_connected_mme_info.internal_mme_info[*mme_index].plmn_id_per_gp_id[loop1].plmn_id,
                    (Char8*)tmp_plmnid_1);
            for(loop2=OAM_ZERO; loop2<p_local_gu_group_info->num_gu_group_id; loop2++)
            {
                oam_memset(tmp_plmnid_2, OAM_ZERO, OAM_SEVEN);
                oam_plmnid_from_mcc_mnc(tmp_plmnid_2,
                        &p_local_gu_group_info->gu_id_list[loop2].plmn_id);
                if(!oam_strcmp((const char *)tmp_plmnid_1,
                            (const char *)tmp_plmnid_2))
                {
                    if(!oam_memcmp((const void*)p_local_gu_group_info->gu_id_list[loop2].mme_group_id,
                                (const void *)g_oam_connected_mme_info.internal_mme_info[*mme_index].
                                group_id_per_plmn_id[loop1].mmegi, MMEGI_OCTET_SIZE))
                    {
                        group_match_found_my_mme = OAM_TRUE;
                        break;
                    }

                }
            }
            /* if the group_id and plmn_id pair donot match with the same MME, also check if this pair do exist for any other MME, if not only then add the pair to the delete delta list */ 
            if(OAM_FALSE == group_match_found_my_mme)
            {
                for(loop2=OAM_ZERO;loop2 < g_oam_connected_mme_info.num_mme;loop2++)
                {
                    if(loop2 == *mme_index)
                        continue;
                    group_match_found_other_mme = OAM_FALSE;
                    for(loop3=OAM_ZERO; loop3< g_oam_connected_mme_info.internal_mme_info[loop2].num_plmn_id_group_id;loop3++)
                    {
                        if(!oam_strcmp((const char *)g_oam_connected_mme_info.internal_mme_info[*mme_index].
                                    plmn_id_per_gp_id[loop1].plmn_id,
                                    (const char *)g_oam_connected_mme_info.internal_mme_info[loop2].
                                    plmn_id_per_gp_id[loop3].plmn_id))
                        {
                            if(!oam_strcmp((const char *)g_oam_connected_mme_info.internal_mme_info[*mme_index].
                                        group_id_per_plmn_id[loop1].mmegi,
                                        (const char *)g_oam_connected_mme_info.internal_mme_info[loop2].
                                        group_id_per_plmn_id[loop3].mmegi))
                            {
                                group_match_found_other_mme = OAM_TRUE;
                                break;
                            }
                        }
                    }
                }
            }
            if((group_match_found_my_mme == OAM_FALSE) && (group_match_found_other_mme == OAM_FALSE))
            {
                OAM_LOG(OAM,OAM_DETAILED,
                        "Adding Group ID to delete List");

#ifdef OAM_SON_ENABLE
                p_gu_group_info->bitmask |= 
                    SON_OAM_GU_GROUP_ID_TO_DELETE_LIST_PRESENT;
                gu_count_delete = 
                    p_gu_group_info->gu_group_id_to_delete_list.num_gu_group_id;
                p_gu_group_info->gu_group_id_to_delete_list.num_gu_group_id++ ;
                oam_memcpy((void *)&p_gu_group_info->gu_group_id_to_delete_list.gu_id_list[gu_count_delete].mme_group_id,
                        (const void *)&g_oam_connected_mme_info.internal_mme_info[*mme_index].group_id_per_plmn_id[loop1].mmegi,
                        MMEGI_OCTET_SIZE); 
#else
                p_gu_group_info->bitmask |= 
                    X2AP_GU_GROUP_ID_TO_DELETE_LIST_PRESENT;
                gu_count_delete =
                    p_gu_group_info->delete_gu_id.num_gu_group_id;
                p_gu_group_info->delete_gu_id.num_gu_group_id++ ;
                oam_memcpy((void *)&p_gu_group_info->delete_gu_id.gu_id_list[gu_count_delete].mme_group_id,
                        (const void *)&g_oam_connected_mme_info.internal_mme_info[*mme_index].group_id_per_plmn_id[loop1].mmegi,
                        MMEGI_OCTET_SIZE); 

#endif

                oam_memset(temp, OAM_ZERO, OAM_SEVEN);
                oam_decode_plmnid((UInt8 *)g_oam_connected_mme_info.internal_mme_info[*mme_index].plmn_id_per_gp_id[loop1].plmn_id,
                        temp);

#ifdef OAM_SON_ENABLE
                retVal=oam_populate_plmnid(temp,
                        (void *)&p_gu_group_info->gu_group_id_to_delete_list.gu_id_list[gu_count_delete].plmn_id);
#else
                retVal=oam_populate_plmnid(temp,
                        (void *)&p_gu_group_info->delete_gu_id.gu_id_list[gu_count_delete].plmn_id);
#endif

                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_WARNING, "Population of PLMN-ID failed.");
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FALSE;/*cov 87467 +-*/
                }
            }
        }
    }
#ifdef OAM_SON_ENABLE
    if((p_gu_group_info->bitmask & SON_OAM_GU_GROUP_ID_TO_ADD_LIST_PRESENT) ||
            (p_gu_group_info->bitmask & SON_OAM_GU_GROUP_ID_TO_DELETE_LIST_PRESENT))
#else
    if((p_gu_group_info->bitmask & X2AP_GU_GROUP_ID_TO_ADD_LIST_PRESENT) ||
                (p_gu_group_info->bitmask & X2AP_GU_GROUP_ID_TO_DELETE_LIST_PRESENT))

#endif
    {
        isDelta = OAM_TRUE;
    }
    else
    {
        OAM_LOG(OAM,OAM_DETAILED,
                "No Add list and No delete List present for current MME");
        isDelta = OAM_FALSE;
    }

    return isDelta;
    /*cov 96911 -*/

}

/****************************************************************************
 *   FUNCTION NAME: addUpdateMMEInfo
 *
 *   DESCRIPTION:   This function adds new MME info or updates existing MME info
                    to existing local array of all MMEs
 *   Inputs       : oam_s1ap_mme_info           : MME info for current MME received in S1AP_MME_INFO
 *   Output       : g_oam_connected_mme_info    : local array with info of all the connected MME
 *   RETURNS:     : OAM_SUCCESS/OAM_FAILURE
 ***************************************************************************/
/*Coverity 66603 Fix Start */
oam_return_et addUpdateMMEInfo(s1ap_oam_mme_info_t *p_oam_s1ap_mme_info,
                               SInt8 mme_index)
/*Coverity 66603 Fix End */
{
  UInt8     loop1,
            loop2,
            num_mme_index,
            count = OAM_ZERO,
            mme_num_served_plmns,
            mme_num_served_group_ids;

  if(g_oam_connected_mme_info.num_mme < MAX_NUM_MME)
  {
    OAM_LOG(OAM,OAM_DETAILED,
        "FILLING MME INFO IN OAM CONTEXT");

    if(mme_index != -1)
    {
	    /* code for updating mme info */
	    OAM_LOG(OAM,OAM_DETAILED,
			    "Updating MME INFO IN OAM CONTEXT");

	    oam_memset((void *)&g_oam_connected_mme_info.oam_s1ap_mme_info[mme_index],
			    OAM_ZERO,
			    sizeof(s1ap_oam_mme_info_t));
	    /*Coverity 66603 Fix Start */
	    oam_memcpy((char *)&g_oam_connected_mme_info.oam_s1ap_mme_info[mme_index],
			    (char *)p_oam_s1ap_mme_info,
			    sizeof(s1ap_oam_mme_info_t));
	    /*Coverity 66603 Fix End */


	    num_mme_index = mme_index;
    }
    else
    {
	    /* code for add mme info */
	    OAM_LOG(OAM,OAM_DETAILED,
			    "Adding MME INFO IN OAM CONTEXT");
	    g_oam_connected_mme_info.num_mme++;
	    num_mme_index = g_oam_connected_mme_info.num_mme - OAM_ONE;
	    /*Coverity 66603 Fix Start */
	    oam_memcpy((char *)&g_oam_connected_mme_info.oam_s1ap_mme_info[num_mme_index],
			    (char *)p_oam_s1ap_mme_info,sizeof(s1ap_oam_mme_info_t));
	    /*Coverity 66603 Fix End */
    }

    OAM_LOG(OAM,OAM_DETAILED,
        "Adding Group ID and PLMN ID info IN OAM CONTEXT for current MME");

    mme_num_served_plmns = g_oam_connected_mme_info.oam_s1ap_mme_info[num_mme_index].
      mme_info.served_gummei_info.num_served_plmns;
    mme_num_served_group_ids = g_oam_connected_mme_info.oam_s1ap_mme_info[num_mme_index].
      mme_info.served_gummei_info.num_served_group_ids;

    g_oam_connected_mme_info.internal_mme_info[num_mme_index].num_plmn_id_group_id =
      (mme_num_served_plmns * mme_num_served_group_ids);

    if(g_oam_connected_mme_info.internal_mme_info[num_mme_index].num_plmn_id_group_id > OAM_MAX_ENB_POOLS)
    {
      g_oam_connected_mme_info.internal_mme_info[num_mme_index].num_plmn_id_group_id = OAM_MAX_ENB_POOLS;
    }
    for(loop1 = OAM_ZERO; loop1 < mme_num_served_plmns; loop1++)
    {
      for(loop2 = OAM_ZERO;loop2< mme_num_served_group_ids;loop2++)
      {

	      /*Coverity 66603 Fix Start */
	      oam_memcpy(&g_oam_connected_mme_info.internal_mme_info[num_mme_index].plmn_id_per_gp_id[count],
			      &p_oam_s1ap_mme_info->mme_info.served_gummei_info.plmn_identity[loop1], 
			      sizeof(s1ap_plmn_identity_t));
	      /*Coverity 66603 Fix End */
	      /*Coverity 66603 Fix Start */
	      oam_memcpy(&g_oam_connected_mme_info.internal_mme_info[num_mme_index].group_id_per_plmn_id[count],
			      &p_oam_s1ap_mme_info->mme_info.served_gummei_info.served_group_id[loop2], 
			      sizeof(s1ap_served_group_id_t));
	      /*Coverity 66603 Fix End */

	      count++;
	      if(count == OAM_MAX_ENB_POOLS)
		      break;

      }
      if(count == OAM_MAX_ENB_POOLS)
        break;
    }
  }
  else
  {
    OAM_LOG(OAM, OAM_WARNING, 
        "Received Num Mme reached Max Supported entry");
    return OAM_FAILURE;
  }

  return OAM_SUCCESS;
}
/* SPR 15180 Fix Stop */

/* SPR-16334 END */



/* SPR 15238 START */ 
#ifdef OAM_SON_ENABLE
/*******************************************************************************
 *  FUNCTION NAME    : oam_dynamic_nbr_cell_access_mode_pci_validation 
 *  DESCRIPTION      : This function used to calculate the access mode according 
 *                     to the pci ranges and validate the access mode provided by
 *                     the operator
 *  PARAMETERS
 *      IN           : nbr_cell_type, eutra_carrier_arfcn, nbr_index
 *
 *      OUT          : NONE
 *
 *  RETURNS          :  calculated access mode 
*******************************************************************************/
oam_return_et
oam_dynamic_nbr_cell_access_mode_pci_validation(
        oam_eutran_nbr_cell_type_et nbr_cell_type,
        UInt32 eutra_carrier_arfcn,
    /* Spr 15438 Fix Start */
        son_intra_rat_neighbor_info_t *p_req,
    /* Spr 15438 Fix End */
        UInt8 cell_arr_idx)
{
    OAM_FUN_ENTRY_TRACE();
    SInt32 nbr_access_mode = OAM_ZERO;
    SInt32 expected_access_mode = OAM_ZERO;
    SInt32 nbr_pci = OAM_ZERO;
    per_freq_pci_ranges_t per_freq_pci_ranges;
	oam_memset(&per_freq_pci_ranges, 0, sizeof(per_freq_pci_ranges_t));

    /* Spr 15438 Fix Start */
    nbr_pci = p_req->pci; 
    /* Spr 15438 Fix End */

    /* Spr 15438 Fix Start */
    nbr_access_mode = p_req->access_mode; 
    /* Spr 15438 Fix End */

    switch(nbr_cell_type)
    {
        case OAM_INTRA_FREQ_NBR_CELL:
            /* Check AccessMode value based on PCI
             * and PCI ranges for IntraFreq Neighbor Cell */

            if(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).bitmask & 
                        SON_CELL_INTRA_FREQ_OPEN_PCI_RANGE_PRESENT)
            {
                per_freq_pci_ranges.open_pci_start   =  
                    SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).intra_freq_open_pci_range.pci_start;
                per_freq_pci_ranges.open_pci_range   = 
                    /* Coverity 83280 fix start */
                    oam_map_pci_range((rrm_oam_cell_id_range_et)SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).
                                            intra_freq_open_pci_range.pci_range);
                    /* Coverity 83280 fix end */
            }

            if(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).bitmask & 
                        SON_CELL_INTRA_FREQ_CLOSED_PCI_RANGE_PRESENT )
            {
                per_freq_pci_ranges.closed_pci_start =  
                    SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).intra_freq_closed_pci_range.pci_start;
                per_freq_pci_ranges.closed_pci_range =  
                    oam_map_pci_range((rrm_oam_cell_id_range_et)SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).
                                intra_freq_closed_pci_range.pci_range);
            }

            if(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).bitmask & 
                        SON_CELL_INTRA_FREQ_HYBRID_PCI_RANGE_PRESENT)
            {
                per_freq_pci_ranges.hybrid_pci_start =  
                    SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).intra_freq_hybrid_pci_range.pci_start;
                per_freq_pci_ranges.hybrid_pci_range =  
                    /*  coverity 83280 fix start */
                    son_oam_map_pci_range(SON_CELL_INFO_IND_SERVING_CELL(cell_arr_idx).
                                intra_freq_hybrid_pci_range.pci_range);
                    /*  coverity 83280 fix end */
            }

            break;

        case OAM_INTER_FREQ_NBR_CELL:
            /* Check AccessMode value based on PCI
             * and PCI ranges for InterFreq Neighbor Cell */
            {
                UInt16 max_cnt = SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list_size;
                UInt16 freq_indx = OAM_ZERO;
                for(freq_indx = OAM_ZERO; freq_indx < max_cnt; freq_indx++) 
                {

                    if(eutra_carrier_arfcn == 
                            SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].earfcn)
                    {
                        break;
                    }

                }

                if(freq_indx >= max_cnt)
                {
                    OAM_LOG(OAM,OAM_WARNING," InterFreq %d not found in the Added List ", 
                            eutra_carrier_arfcn);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                if( SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].bitmask & 
                            SON_MC_INTER_FREQ_OPEN_PCI_RANGE_PRESENT) 
                {
                    per_freq_pci_ranges.open_pci_start = 
                        SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].
                        inter_freq_open_pci_range.pci_start; 
                    per_freq_pci_ranges.open_pci_range = 
                        oam_map_pci_range((rrm_oam_cell_id_range_et)SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].
                                            inter_freq_open_pci_range.pci_range);
                }

                if( SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].bitmask & 
                            SON_MC_INTER_FREQ_CLOSED_PCI_RANGE_PRESENT) 
                {
                    per_freq_pci_ranges.closed_pci_start = 
                        SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].
                        inter_freq_closed_pci_range.pci_start;
                    per_freq_pci_ranges.closed_pci_range = 
                        oam_map_pci_range((rrm_oam_cell_id_range_et)SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].
                                            inter_freq_closed_pci_range.pci_range);/*cov 94871 +-*/

                }

                if( SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].bitmask & 
                            SON_MC_INTER_FREQ_HYBRID_PCI_RANGE_PRESENT) 
                {
                    per_freq_pci_ranges.hybrid_pci_start = 
                        SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].
                        inter_freq_hybrid_pci_range.pci_start; 
                    per_freq_pci_ranges.hybrid_pci_range = 
                        /*  coverity 94871 fix start */
                        son_oam_map_pci_range(SON_ANR_MEAS_CONFIG_REQ(cell_arr_idx).eutran_config_list[freq_indx].
                                            inter_freq_hybrid_pci_range.pci_range);
                        /*  coverity 94871 fix end */
                }

            }
            break;
        default:
            OAM_LOG(OAM, OAM_WARNING, "Unknown frequency input type");
            OAM_FUN_EXIT_TRACE();
            return OAM_FAILURE;

    }

    if((nbr_pci >= per_freq_pci_ranges.open_pci_start) 
            && (nbr_pci <= per_freq_pci_ranges.open_pci_start + 
                per_freq_pci_ranges.open_pci_range - OAM_ONE))
    {
        expected_access_mode = OAM_OPEN_FEMTO;
    }
    else if((nbr_pci >= per_freq_pci_ranges.closed_pci_start)  
            && (nbr_pci<= per_freq_pci_ranges.closed_pci_start + 
                per_freq_pci_ranges.closed_pci_range - OAM_ONE))
    {
        expected_access_mode = OAM_CLOSED;
    }
    else if((nbr_pci >= per_freq_pci_ranges.hybrid_pci_start)
            && (nbr_pci<= per_freq_pci_ranges.hybrid_pci_start + 
                per_freq_pci_ranges.hybrid_pci_range - OAM_ONE))
    {
        expected_access_mode = OAM_HYBRID;
    }
    else
    {
        expected_access_mode = OAM_OPEN_MACRO;
    }

    if(expected_access_mode != nbr_access_mode)
    {
        OAM_LOG(OAM,OAM_WARNING,
                "Access Mode value does not match with the given pci_ranges"
                " Expected Access Mode value is %d and present is %d"
                " Changing the Access Mode value of nbr to %d ",
                expected_access_mode,nbr_access_mode,
                expected_access_mode);
    /* Spr 15438 Fix Start */
     p_req->access_mode =
                                            (son_access_mode_et)expected_access_mode;
    /* Spr 15438 Fix End */
        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;
    }
    else
    {
        OAM_LOG(OAM,OAM_DETAILED," Access Mode successfully validated for nbr cell");
    }


    /* Spr 15438 Fix Star */
    /* Log Removed */
    /* Spr 15438 Fix End */
    OAM_FUN_EXIT_TRACE();
    return OAM_SUCCESS;

}
#endif
/* SPR 15238 END */ 

/* BCOM Compiltaion Fix */
#ifdef OAM_SON_ENABLE
/* BCOM Compiltaion Fix */
/****************************************************************
 *   FUNCTION NAME: oam_send_init_time_anr_meas_config_req
 *
 *   DESCRIPTION:   This function sends init time ANR measurement
 *                  configuration parameters to SON
 *   Inputs       : Cell ID for which parameters are being sent
 *   Output       : NONE
 *
 *   RETURNS:       OAM_SUCCESS/OAM_FAILURE 
 ****************************************************************/
	oam_return_et
oam_send_init_time_anr_meas_config_req(UInt8 cid)
{
	SInt8 arr_idx = OAM_ZERO;
	SInt8 arr_idx1 = OAM_ZERO;
	oam_return_et retVal = OAM_FAILURE;
	oam_son_inter_freq_carrier_t *p_son_inter_freq_carr_params = OAM_NULL;
	oam_son_anr_meas_config_req_t *p_local_req = OAM_NULL;
	oam_son_anr_meas_config_req_t *p_son_anr_meas_config_req = OAM_NULL;
	oam_error_code_et err = NO_ERROR;
	UInt16 trans_id = OAM_ZERO;
	UInt32 idx = OAM_ZERO;
	UInt32 bitmask = OAM_ZERO;
	/* SPR 13275 FIX START */
	UInt32 num_objs = OAM_ZERO;
	/* SPR 13275 FIX END */

	OAM_FUN_ENTRY_TRACE();

	arr_idx = oam_get_son_inter_freq_carrier_idx(cid);
	if(OAM_ERROR_RETURN_VAL == arr_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         cid);

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}

	arr_idx1 = oam_get_son_serving_cell_idx(cid);
	if(OAM_ERROR_RETURN_VAL == arr_idx1) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
                         cid);

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}

	retVal = oam_mem_alloc(sizeof(oam_son_anr_meas_config_req_t),
			(void**)&p_local_req, &err);

	if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_local_req failed"
                " with Error Code:%d",
                err);

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}

	oam_memset(p_local_req, 0, sizeof(oam_son_anr_meas_config_req_t));

	p_son_inter_freq_carr_params = &SON_INTER_FREQ_CARR_PARAMS(arr_idx);
	p_son_anr_meas_config_req =
		&p_son_inter_freq_carr_params->oam_son_anr_meas_config_req;

	/* Copy serving cell id to local request */
	oam_memcpy(&p_son_anr_meas_config_req->src_cgi,
			&SON_CELL_INFO_IND_SERVING_CELL(arr_idx1).src_cgi,
			sizeof(son_intra_rat_global_cell_id_t));

	/* SPR 13104 FIX START */
	/* Copy serving cell id to local request */
	oam_memcpy(&p_local_req->src_cgi,
			&SON_CELL_INFO_IND_SERVING_CELL(arr_idx1).src_cgi,
			sizeof(son_intra_rat_global_cell_id_t));
	/* SPR 13104 FIX END */

	/* Copy EUTRAN measurement configuration parameter list */
	bitmask = p_son_inter_freq_carr_params->eutran_meas_entry_bitmap;
	/* SPR 13275 FIX START */
	num_objs = p_son_anr_meas_config_req->eutran_config_list_size;
	arr_idx = OAM_ZERO;

	for (idx = OAM_ZERO;
            /* SPR 14651 START */
            (arr_idx < (SInt64)num_objs) && (idx < p_son_inter_freq_carr_params->MaxCarrierEntries); ++idx) {
        /* SPR 13275 FIX END */
        if( (bitmask & (1 << idx)) && (p_son_inter_freq_carr_params->eutran_meas_enable[idx].enable) )
        {
            /* SPR 14651 END */
            oam_memcpy(&p_local_req->eutran_config_list[arr_idx++],
                    &p_son_anr_meas_config_req->eutran_config_list[idx],
                    sizeof(son_meas_config_eutran_t));
        }
        /* SPR 14651 START */
        else
        {
            OAM_LOG(OAM,OAM_INFO,"Skipping Eutran Carrier Instance [%d] as Entry is not Enable",idx + 1);
        }
        /* SPR 14651 END */
    }

    /* SPR 14651 START */
    if(arr_idx)
    {    
        p_local_req->eutran_config_list_size = arr_idx;
    }
    /* SPR 14651 END */

	/* Copy measurement gap configuration parameter */
	p_local_req->bitmask = p_son_anr_meas_config_req->bitmask;

	oam_memcpy(&p_local_req->meas_gap_config,
			&p_son_anr_meas_config_req->meas_gap_config,
			sizeof(son_meas_gap_config_t));

	/* Copy UTRAN FDD measurement configuration parameter list */
	bitmask = p_son_inter_freq_carr_params->utran_fdd_meas_entry_bitmap;
	/* SPR 13275 FIX START */
	num_objs = p_son_anr_meas_config_req->other_rat_config_list.
		utran_config_list.utran_fdd_list_size;
	arr_idx = OAM_ZERO;

	for (idx = OAM_ZERO;
            /* SPR 14651 START */
			(arr_idx < (SInt64)num_objs) && (idx < p_son_inter_freq_carr_params->max_utran_fdd_freq); ++idx) {
		/* SPR 13275 FIX END */
		if( (bitmask & (1 << idx)) && (p_son_inter_freq_carr_params->utran_meas_enable[idx].enable) )
        {    
        /* SPR 14651 END */
			oam_memcpy(&p_local_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[arr_idx++],
					&p_son_anr_meas_config_req->other_rat_config_list.
					utran_config_list.utran_fdd_list[idx],
					sizeof(son_meas_config_utran_fdd_t));
		}
        /* SPR 14651 START */
        else
        {
            OAM_LOG(OAM,OAM_INFO,"Skipping  UTRAN FDD Carrier Instance [%d] as Entry is not Enable",idx + 1);
        } 
        /* SPR 14651 END */
	}

	/* SPR 13330 FIX START */
    /* SPR 14651 START */
    if(arr_idx)
    {    
        p_local_req->other_rat_config_list.utran_config_list.
            utran_fdd_list_size = arr_idx;
    }    
    /* SPR 14651 END */
	/* SPR 13330 FIX END */

	/* Copy UTRAN TDD measurement configuration parameter list */
	/* SPR 13275 FIX START */
	oam_memcpy(&p_local_req->other_rat_config_list.utran_config_list.
			utran_tdd_list,
			&p_son_anr_meas_config_req->other_rat_config_list.
			utran_config_list.utran_tdd_list,
			sizeof(son_meas_config_utran_tdd_t) * SON_MAX_CONFIG_OBJECT);
	/* SPR 13275 FIX END */

	/* SPR 13275 FIX START */
	p_local_req->other_rat_config_list.utran_config_list.
		utran_tdd_list_size = p_son_anr_meas_config_req->other_rat_config_list.
		utran_config_list.utran_tdd_list_size;
	/* SPR 13275 FIX END */

	/* Copy UTRAN measurement configuration reselection parameter  */
	p_local_req->other_rat_config_list.utran_config_list.bitmask = 
		p_son_anr_meas_config_req->other_rat_config_list.
		utran_config_list.bitmask;

	p_local_req->other_rat_config_list.utran_config_list.t_reselection = 
		p_son_anr_meas_config_req->other_rat_config_list.
		utran_config_list.t_reselection;

	oam_memcpy(&p_local_req->other_rat_config_list.utran_config_list.
			t_reselection_sf,
			&p_son_anr_meas_config_req->other_rat_config_list.
			utran_config_list.t_reselection_sf,
			sizeof(son_speed_state_scale_factors_t));

	/* Copy GERAN measurement configuration parameter list */
	bitmask = p_son_inter_freq_carr_params->geran_meas_entry_bitmap;
	num_objs = p_son_anr_meas_config_req->other_rat_config_list.
		geran_config_list.geran_freq_info_list_size;

	arr_idx = OAM_ZERO;

	for (idx = OAM_ZERO;
             /* SPR 14651 START */
			(arr_idx < (SInt64)num_objs) && (idx < p_son_inter_freq_carr_params->max_geran_freq_entries); ++idx) {
		if( (bitmask & (1 << idx)) && (p_son_inter_freq_carr_params->geran_meas_enable[idx].enable) )
        {    
        /* SPR 14651 END */
			oam_memcpy(&p_local_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[arr_idx++],
					&p_son_anr_meas_config_req->other_rat_config_list.
					geran_config_list.geran_freq_info_list[idx],
					sizeof(son_geran_carrier_freq_info_t));
		}
        /* SPR 14651 START */
        else
        {
            OAM_LOG(OAM,OAM_INFO,"Skipping GERAN Carrier Instance [%d] as Entry is not Enable",idx + 1);
        } 
        /* SPR 14651 END */
	}

    /* SPR 14651 START */
    if(arr_idx)
    {     
        p_local_req->other_rat_config_list.geran_config_list.
            geran_freq_info_list_size = arr_idx;
    }    
    /* SPR 14651 END */

	p_local_req->other_rat_config_list.geran_config_list.bitmask = 
		p_son_anr_meas_config_req->other_rat_config_list.
		geran_config_list.bitmask;

	p_local_req->other_rat_config_list.geran_config_list.t_reselection = 
		p_son_anr_meas_config_req->other_rat_config_list.
		geran_config_list.t_reselection;

	oam_memcpy(&p_local_req->other_rat_config_list.geran_config_list.
			t_reselection_sf,
			&p_son_anr_meas_config_req->other_rat_config_list.
			geran_config_list.t_reselection_sf,
			sizeof(son_speed_state_scale_factors_t));


	/* Copy CDMA2000 measurement configuration parameters */
	oam_memcpy(&p_local_req->other_rat_config_list.cdma_config_list,
			&p_son_anr_meas_config_req->other_rat_config_list.cdma_config_list,
			sizeof(son_meas_config_cdma_t));


	trans_id = oam_get_new_trans_id();


	retVal = oam_son_send_son_oam_anr_meas_config_req(p_local_req,
			OAM_MODULE_ID,
			SON_MODULE_ID,
			trans_id, cid);

	if(OAM_FAILURE == retVal) {
		p_son_inter_freq_carr_params->eutran_meas_entry_bitmap = 0;
		p_son_inter_freq_carr_params->utran_fdd_meas_entry_bitmap = 0;
		p_son_inter_freq_carr_params->utran_tdd_meas_entry_bitmap = 0;
		p_son_inter_freq_carr_params->geran_meas_entry_bitmap = 0;
		oam_memset(p_son_anr_meas_config_req, 0,
				sizeof(oam_son_anr_meas_config_req_t));
	}
	/* Coverity ID : 85855 Fix Start*/
	oam_mem_free(p_local_req,&err);
	/* Coverity ID : 85855 Fix End*/
	OAM_FUN_EXIT_TRACE();
	return retVal;
}
/*SPR_15950 Fix Start*/
/*SPR_16048 Fix Start*/
void oam_fill_last_scan_time_format(UInt8 *last_scan_time,oam_time_stamp_t time_stamp)
/*SPR_16048 Fix End*/
{
    UInt8 tempBuf[25];
    oam_memset(tempBuf, OAM_ZERO, 25);
    struct tm* tm_info;
    time_t now = oam_time(OAM_NULL);

    if(time_stamp.month < 10)
    {
        if(time_stamp.day <10)
        {
            oam_sprintf((char *)tempBuf,"%d-0%d-0%d",
                    time_stamp.year,
                    time_stamp.month,
                    time_stamp.day);
        }
        else
        {
            oam_sprintf((char *)tempBuf,"%d-0%d-%d",
                    time_stamp.year,
                    time_stamp.month,
                    time_stamp.day);
        }
    }
    else
    {
        if(time_stamp.day <10)
        {
            oam_sprintf((char *)tempBuf,"%d-%d0-%d",
                    time_stamp.year,
                    time_stamp.month,
                    time_stamp.day);
        }
        else
        {
            oam_sprintf((char *)tempBuf,"%d-%d-%d",
                    time_stamp.year,
                    time_stamp.month,
                    time_stamp.day);
        }
    }
    oam_strcat(last_scan_time, tempBuf);
    oam_memset(tempBuf, OAM_ZERO, 25);

    if(time_stamp.hour < 10)
    {
        if (time_stamp.min < 10)
        {
            if(time_stamp.sec < 10)
            {
                oam_sprintf((char *)tempBuf,"T0%d:0%d:0%d",
                        time_stamp.hour,
                        time_stamp.min,
                        time_stamp.sec);
            }
            else
            {
                oam_sprintf((char *)tempBuf,"T0%d:0%d:%d",
                        time_stamp.hour,
                        time_stamp.min,
                        time_stamp.sec);
            }
        }
        else
        {
            if(time_stamp.sec < 10)
            {
                oam_sprintf((char *)tempBuf,"T0%d:%d:0%d",
                        time_stamp.hour,
                        time_stamp.min,
                        time_stamp.sec);
            }
            else
            {
                oam_sprintf((char *)tempBuf,"T0%d:%d:%d",
                        time_stamp.hour,
                        time_stamp.min,
                        time_stamp.sec);
            }
        }
    }
    else
    {
        if (time_stamp.min < 10)
        {
            if(time_stamp.sec < 10)
            {
                oam_sprintf((char *)tempBuf,"T%d:0%d:0%d",
                        time_stamp.hour,
                        time_stamp.min,
                        time_stamp.sec);
            }
            else
            {
                oam_sprintf((char *)tempBuf,"T%d:0%d:%d",
                        time_stamp.hour,
                        time_stamp.min,
                        time_stamp.sec);
            }
        }
        else
        {
            if(time_stamp.sec < 10)
            {
                oam_sprintf((char *)tempBuf,"T%d:%d:0%d",
                        time_stamp.hour,
                        time_stamp.min,
                        time_stamp.sec);
            }
            else
            {
                oam_sprintf((char *)tempBuf,"T%d:%d:%d",
                        time_stamp.hour,
                        time_stamp.min,
                        time_stamp.sec);
            }
        }
    }
    oam_strcat(last_scan_time, tempBuf);
    oam_memset(tempBuf, OAM_ZERO, 25);

    now++;
    tm_info = oam_gmtime(&now);
    if (NULL != tm_info)
    {

        if(tm_info->tm_gmtoff < 0)
            oam_sprintf((char *)tempBuf,"%c",'-');
        else
            oam_sprintf((char *)tempBuf,"%c",'+');

        if((oam_abs(tm_info->tm_gmtoff)/3600) < 10)
            oam_sprintf(((char *)tempBuf + OAM_ONE),"0%d",(oam_abs(tm_info->tm_gmtoff)/3600));
        else
            oam_sprintf(((char *)tempBuf + OAM_ONE),"%d",(oam_abs(tm_info->tm_gmtoff)/3600));

        if(((oam_abs(tm_info->tm_gmtoff)%3600)/60) < 10)
            oam_sprintf(((char *)tempBuf + OAM_THREE),":0%d",(oam_abs(tm_info->tm_gmtoff)%3600)/60);
        else
            oam_sprintf(((char *)tempBuf + OAM_THREE),":%d",(oam_abs(tm_info->tm_gmtoff)%3600)/60);

        oam_strcat(last_scan_time, tempBuf);
    }
}
/*SPR_15950 Fix End*/

#endif


/****************************************************************************
 *   FUNCTION NAME: oam_check_param_input_validity
 *
 *   DESCRIPTION:   This function checks user input parameters for some
 *                  additional validity rules apart from their xml validation
 *   Inputs       : Fully qualified parameter name (and possibly assigned 
 *                  value pair)
 *                  e.g. in the following format: 
 *                  "ParentName.ParameterName=Value"  for SPV validation or
 *                  "ParentName.ParameterName" for GPV validation
 *   Output       : NONE
 *
 *   RETURNS:       OAM_SUCCESS/OAM_FAILURE 
 ***************************************************************************/
	oam_return_et
oam_check_param_input_validity(Char8 *param_val_pair)
{
	Char8 *param_name = OAM_NULL;
	Char8 *save_ptr = OAM_NULL;
	Char8 buf[MAX_PARENT_NAME_LENGTH + MAX_PARAMETER_NAME_LENGTH] = {OAM_ZERO};
	oam_return_et retVal = OAM_SUCCESS;

	OAM_FUN_ENTRY_TRACE();

	if (!param_val_pair) {
		OAM_LOG(OAM, OAM_WARNING, "Null pointer error");

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}

	oam_strncpy(buf, param_val_pair, sizeof(buf));
	param_name = oam_strtok_r(buf, "=", &save_ptr);

	if (!param_name) {
		OAM_LOG(OAM, OAM_WARNING, "Parameter name is NULL");

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}



	if (oam_strstr(param_name, "HNBName")) {
		if (oam_prov_req.num_cells_configured > 1) {
			OAM_LOG(OAM, OAM_WARNING, "Parameter HNBName is not configurable "
					"in multi-cell setup");
			retVal = OAM_FAILURE;
		}
	}

	OAM_FUN_EXIT_TRACE();
	return retVal;
}


/* BUG_FIXED_12828_END */
#ifdef OAM_SON_ENABLE
oam_return_et oam_send_init_time_nr_add_req(UInt8 src_cell_id)   
{
	/*SPR 15604 START */
	oam_son_anr_updated_nrt_info_t *p_nliu_info = OAM_NULL;
	UInt16 count1 = OAM_ZERO;
	/*SPR 15604 END */

	UInt16 count = OAM_ZERO;
	UInt16 max_count = OAM_ZERO;
	UInt16 max_count1 = OAM_ZERO;
	/* SPR-13586 START */
	UInt16 max_count2 = OAM_ZERO;
	/* SPR-13586 END */
	oam_cell_neighbourlist_info_t *p_cell_neigh_info = OAM_NULL; 
	oam_son_nr_add_req_t *p_son_nr_add_req = OAM_NULL;
	oam_son_nr_add_req_t *p_nr_add_req = OAM_NULL;
	oam_return_et retVal = OAM_FAILURE;
	oam_error_code_et err = NO_ERROR;
        /* SPR 22472 Fix +- */
	UInt16 trans_id = OAM_ZERO;
	/*SPR 15604 START */
	UInt16 intra_rat_idx = OAM_ZERO;
	UInt16 inter_rat_idx = OAM_ZERO;
	SInt16 cgi_found = NOT_FOUND;
	SInt8 cell_idx = src_cell_id;




	p_nliu_info = &NR_LIST_IN_USE(cell_idx).nrt_info;
	UInt16 intra_rat_nr_list_count_nliu = p_nliu_info->nr_list.intra_rat_nr_list_size;
	UInt16 inter_rat_nr_list_count_nliu = p_nliu_info->nr_list.inter_rat_nr_list_size;
	/*SPR 15604 END */


	OAM_FUN_ENTRY_TRACE();

	retVal = oam_mem_alloc(sizeof(oam_son_nr_add_req_t),
			(void**)&p_nr_add_req, &err);

	if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_nr_add_req failed"
                " with Error Code:%d",
                err);

		OAM_FUN_EXIT_TRACE();
		return retVal;
	}

	oam_memset(p_nr_add_req, OAM_ZERO, sizeof(oam_son_nr_add_req_t));
	p_son_nr_add_req = &SON_NR_ADD_REQ(src_cell_id);
	p_cell_neigh_info = &SON_NEIGHBORLIST_INFO(src_cell_id); 

	/* Spr 15438 Fix Start */
	oam_son_nr_add_req_t *p_local_son_nr_add = OAM_NULL;
	p_local_son_nr_add = &LOCAL_SON_NR_ADD_REQ(src_cell_id);
	/* Spr 15438 Fix End */

	oam_memcpy(&(p_nr_add_req->src_cgi), &(p_son_nr_add_req->src_cgi),
			sizeof(son_intra_rat_global_cell_id_t));

	max_count = p_son_nr_add_req->nr_list.intra_rat_nr_list_size;

	/* SPR 18930  FIX START */

	/* SPR-13586 START */
	max_count1 = p_cell_neigh_info->inter_rat_umts_list_size;
	max_count2 = p_cell_neigh_info->inter_rat_gsm_list_size;
	/* SPR-13586 END */

	OAM_LOG(OAM, OAM_DETAILED,
			"intra_rat_nr_list_size %d,inter_rat_umts_list_size %d,inter_rat_gsm_list_size=%d",
            max_count,max_count1,max_count2);

	for(count = OAM_ZERO;  
/*SPR 22442 Fix Start*/
			count < SON_MAX_NO_INTRA_RAT_NEIGHBOUR_CELLS; ++count) {
/*SPR 22442 Fix End*/
		/* Spr 15438 Fix Start */
		if (p_cell_neigh_info->intra_rat_nr_entry_bitmap & (OAM_ONE << count) &&
				(OAM_TRUE == p_cell_neigh_info->eutran_nbr_ctxt[count].enable )&& 
				(OAM_TRUE == p_cell_neigh_info->eutran_nbr_ctxt[count].must_include))
		{
			/* Spr 15438 Fix End */
			oam_memcpy(&(p_nr_add_req->nr_list.intra_rat_nr_list[intra_rat_idx++]),
					&(p_son_nr_add_req->nr_list.intra_rat_nr_list[count]),
					sizeof(son_intra_rat_neighbor_info_t));
            /* SPR 21903 FIXED START */
            p_nr_add_req->nr_list.intra_rat_nr_list[intra_rat_idx].bitmask &= ~SON_ENABLE_X2_STATUS_PRESENT;
            p_nr_add_req->nr_list.intra_rat_nr_list[intra_rat_idx].bitmask &= ~SON_EUTRAN_NR_HO_STATS_PRESENT;
            p_nr_add_req->nr_list.intra_rat_nr_list[intra_rat_idx].bitmask &= ~SON_SUSPECT_PCI_PRESENT;
            /* SPR 21903 FIXED END */

			/* SPR 18930 Fix Start */
                       OAM_LOG(OAM,OAM_DETAILED," filling neighbor cid = %d for addition",
                                    oam_extract_cid_from_eutran_cellidentity(
                              p_son_nr_add_req->nr_list.intra_rat_nr_list[count].nbr_cgi.cell_identity));
			/* SPR 18930 Fix End */
		}
		/* Spr 15438 Fix Start */
		else
		{
			OAM_LOG(OAM, OAM_DETAILED,"skipping IntraRat index  %d"
					" as either Enable or MI is false or Used As DAHO Neighbour", count);
		}    
		/* Spr 15438 Fix End */

	}

	/* SPR-13586 START */ 

	/* SPR 18930  FIX END */
	/*SPR 15604 START */
    OAM_LOG(OAM, OAM_DETAILED,"intra_rat_nr_list_count_nliu = %u",intra_rat_nr_list_count_nliu);
    for(count1 = OAM_ZERO; count1 < intra_rat_nr_list_count_nliu; ++count1){
        cgi_found = oam_cgi_search_in_neigh_list(
                &NR_LIST_IN_USE(cell_idx).nrt_info.nr_list.intra_rat_nr_list[count1].nbr_cgi,
                SON_NR_LIST(src_cell_id).intra_rat_nr_list, 
                SON_NR_LIST(src_cell_id).intra_rat_nr_list_size,
                &SON_NEIGHBORLIST_INFO(src_cell_id).intra_rat_nr_entry_bitmap, 
                OAM_SON_NEIGH_TYPE_INTRA_RAT);
        /*SPR 16372 fix start*/
        //if((cgi_found == NOT_FOUND) && (own_enb_cell == OAM_FALSE)&&
        OAM_LOG(OAM, OAM_DETAILED,"cgi_found = %d, NR_LIST_IN_USE(cell_idx).intra_rat_neigh_valid_bitmap =%u",cgi_found,NR_LIST_IN_USE(cell_idx).intra_rat_neigh_valid_bitmap);
        if((cgi_found == NOT_FOUND)&&
                (NR_LIST_IN_USE(cell_idx).intra_rat_neigh_valid_bitmap & (OAM_ONE << count1)))
        {
            /*SPR 16372 fix stop*/
            oam_memcpy(&(p_nr_add_req->nr_list.
                        intra_rat_nr_list[intra_rat_idx++]),
                    &(p_nliu_info->nr_list.
                        intra_rat_nr_list[count1]),     
                    sizeof(son_intra_rat_neighbor_info_t));
            /* SPR 21903 FIXED START */
            p_nr_add_req->nr_list.intra_rat_nr_list[intra_rat_idx].bitmask &= ~SON_ENABLE_X2_STATUS_PRESENT;
            p_nr_add_req->nr_list.intra_rat_nr_list[intra_rat_idx].bitmask &= ~SON_EUTRAN_NR_HO_STATS_PRESENT;
            p_nr_add_req->nr_list.intra_rat_nr_list[intra_rat_idx].bitmask &= ~SON_SUSPECT_PCI_PRESENT;
            /* SPR 21903 FIXED END */

            /* Marking This Neighbor as Deteceted as it was detected before restart */
            NR_LIST_IN_USE(cell_idx).is_detected_intra_neighbour[count1] =  OAM_TRUE;

	/* SPR 18930  FIX START */
        /*coverity 108804 fix start*/
	   OAM_LOG(OAM,OAM_DETAILED,"filling neighbor cid = %d for addition",
			    oam_extract_cid_from_eutran_cellidentity(
				    p_nliu_info->nr_list.intra_rat_nr_list[count1].nbr_cgi.cell_identity));
        /*coverity 108804 fix end*/
/* SPR 18930  FIX END */
        }  
        else{

            OAM_LOG(OAM, OAM_DETAILED,"skipping LTE Neighbour present in NeighbourlistInUse");

        }          
    }       
	/*SPR 15604 END */

	/* SPR 18930  FIX START */
	p_nr_add_req->nr_list.intra_rat_nr_list_size = intra_rat_idx;
	/* SPR 18930  FIX END */
/*SPR 22442 Fix Start*/
	for(count = OAM_ZERO; count < SON_MAX_NO_UMTS_NEIGHBOUR_CELLS; count++)
/*SPR 22442 Fix End*/
		/* Spr 15612  Fix Start*/
    {
            OAM_LOG(OAM, OAM_DETAILED,"bitmap %x, enable = %d , MustInclude = %d",p_cell_neigh_info->inter_rat_umts_entry_bitmap,
                     p_cell_neigh_info->utran_nbr_ctxt[count].enable, p_cell_neigh_info->utran_nbr_ctxt[count].must_include);
		if (p_cell_neigh_info->inter_rat_umts_entry_bitmap & (1 << count) && 
				(OAM_TRUE == p_cell_neigh_info->utran_nbr_ctxt[count].enable )&& 
				(OAM_TRUE == p_cell_neigh_info->utran_nbr_ctxt[count].must_include)){
			/* Spr 15612  Fix End*/
            OAM_LOG(OAM, OAM_DETAILED,"Copying from count %d  to inter_rat_idx %d", count,inter_rat_idx);
            oam_memcpy(&(p_nr_add_req->nr_list.inter_rat_nr_list[inter_rat_idx].utran_neighbor),
					&(p_son_nr_add_req->nr_list.inter_rat_nr_list[count].utran_neighbor),
					sizeof(son_utran_neighbor_info_t));
            p_nr_add_req->nr_list.inter_rat_nr_list[inter_rat_idx++].bitmask |= SON_INTER_UTRAN_NEIGHBOR;
		}
		/* Spr 15612  Fix Start*/
		else
		{
			OAM_LOG(OAM, OAM_DETAILED,"Skipping Inter rat index  %d"
					" as either Enable or MI is false", count);
		}
		/* Spr 15612  Fix End*/
	}
	/*SPR 15604 START */
	for(count1 = OAM_ZERO; count1 < inter_rat_nr_list_count_nliu; ++count1){

        if (SON_NEIGHBORLISTINUSE_INFO(src_cell_id).inter_rat_umts_neigh_valid_bitmap & (1 << count1))
        {
		cgi_found = oam_cgi_search_in_neigh_list(
				&NR_LIST_IN_USE(cell_idx).nrt_info.nr_list.inter_rat_nr_list[count1].utran_neighbor.nbr_cgi,
				SON_NR_LIST(src_cell_id).inter_rat_nr_list,
				SON_NR_LIST(src_cell_id).inter_rat_nr_list_size,
                    &SON_NEIGHBORLIST_INFO(cell_idx).inter_rat_umts_entry_bitmap,
				OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);

		if(cgi_found == NOT_FOUND){
			oam_memcpy(&(p_nr_add_req->nr_list.
						inter_rat_nr_list[inter_rat_idx++]),
					&(p_nliu_info->nr_list.
						inter_rat_nr_list[count1]),     
					sizeof(son_utran_neighbor_info_t));

                /* Marking This Neighbor as Deteceted as it was detected before restart */
                NR_LIST_IN_USE(cell_idx).is_detected_utran_neighbour[count1] =  OAM_TRUE;
            }  
		}  
		else{

			OAM_LOG(OAM, OAM_DETAILED,"skipping UMTS Neighbour present in NeighbourlistInUse"
					" which is already present in NeighbourList");
		}           
	}       
	/*SPR 15604 END */

/*SPR 22442 Fix Start*/
	for(count = OAM_ZERO;
			count < SON_MAX_NO_GERAN_NEIGHBOUR_CELLS ; ++count) {
/*SPR 22442 Fix End*/
		if (p_cell_neigh_info->inter_rat_gsm_entry_bitmap & (1 << count)) {
			/* SPR 22472 Fix Start */
			oam_memcpy(&(p_nr_add_req->nr_list.inter_rat_nr_list[inter_rat_idx].geran_neighbor),
					&(p_son_nr_add_req->nr_list.inter_rat_nr_list[count].geran_neighbor),
					sizeof(son_geran_neighbor_info_t));
			p_nr_add_req->nr_list.inter_rat_nr_list[inter_rat_idx++].bitmask |= SON_INTER_GERAN_NEIGHBOR; 
			/* SPR 22472 Fix End */
		}
	}
	/* SPR-13586 END */

	/*SPR_20071_START*/
	for(count = OAM_ZERO;
			(count < OAM_SON_MAX_NUM_NEIGHBOR); ++count) {
		if (p_cell_neigh_info->inter_rat_cdma_entry_bitmap & (1 << count)) {
			oam_memcpy(&(p_nr_add_req->nr_list.inter_rat_nr_list[inter_rat_idx++].cdma_neighbor),
					&(p_son_nr_add_req->nr_list.inter_rat_nr_list[count].cdma_neighbor),
					sizeof(son_cdma_neighbor_info_t));
			p_nr_add_req->nr_list.inter_rat_nr_list[inter_rat_idx -1].bitmask |= SON_INTER_CDMA_NEIGHBOR; 
		}
	}
	/*SPR_20071_END*/

	OAM_LOG(OAM, OAM_DETAILED,
			"index = %d", inter_rat_idx);
	p_nr_add_req->nr_list.inter_rat_nr_list_size = inter_rat_idx;

	/* Spr 15438 Fix Start */
	/* Code Removed */
	/* Spr 15438 Fix End */

	/*SPR #14561 Fixed Start*/
	if ((p_nr_add_req->nr_list.intra_rat_nr_list_size || 
				p_nr_add_req->nr_list.inter_rat_nr_list_size) > OAM_ZERO)
	{

		trans_id = oam_get_new_trans_id();

        /* SPR 18930  FIX START  */

		retVal = oam_son_send_son_oam_nr_add_req(p_nr_add_req,
				OAM_MODULE_ID,
				SON_MODULE_ID,
				trans_id,
				src_cell_id);
		if (OAM_FAILURE == retVal) {
			OAM_LOG(OAM, OAM_ERROR, "Failed to send SON_OAM_NR_ADD_REQ");
            /* SPR 18930  FIX START */
            SON_NEIGHBORLIST_INFO(src_cell_id).first_nr_add_state = FIRST_NR_ADD_NOT_REQD;
            /* SPR 18930  FIX END */
		}
		else {
			OAM_LOG(OAM, OAM_INFO,
					"Successfully sent SON_OAM_NR_ADD_REQ");
            /* SPR 18930  FIX START */
            oam_save_nr_add_req_with_trans_id(p_nr_add_req,trans_id,src_cell_id);
            /* SPR 18930  FIX START */
            /* SPR 18930  FIX START */
            SON_NEIGHBORLIST_INFO(src_cell_id).first_nr_add_state = FIRST_NR_ADD_REQ_SENT;
            /* SPR 18930  FIX END */
			/* Spr 15438 Fix Start */
			/* Updating The Local Prov Req With only Sent Value in NR ADD */
			oam_memset(p_local_son_nr_add , OAM_ZERO, sizeof(oam_son_nr_add_req_t));

			oam_memcpy(p_local_son_nr_add,p_nr_add_req,
					sizeof(oam_son_nr_add_req_t));
			/* Spr 15438 Fix End */

		}
	}
	else{

		/* Spr 15438 Fix Start */
		OAM_LOG(OAM, OAM_DETAILED,"Not sending SON_OAM_NR_ADD_REQ because" 
				" intra rat and inter rat list size is zero" );
		/* Spr 15438 Fix End */
		oam_mem_free(p_nr_add_req, &err);
		return OAM_FAILURE;
	}
	/*SPR #14561 Fixed End*/     


	/* SPR 12932 FIX START */
	/* Flushing of cdma and geran neighbors from NR LIST removed */
	/* SPR 12932 FIX END */

	oam_mem_free(p_nr_add_req, &err);

	return OAM_SUCCESS;
}
/* BUG_FIXED_12828_END */
/*SPR 9614 start*/
/***************************************************************************
 * Function Name  : oam_populate_parameter_name
 * Description    : This function generate name of parameter dependign on 
 *				    cause, RAT type and parameter type
 * Inputs         : p_pci_conflict_confusion - pointer to pci conflict/confusion
 *				    type           		     - type of parameter
 * Output			param_name1				 - pointer to buffer for param 1
 *					param_name2				 - pointer to buffer for param 2
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 *****************************************************************************/
oam_return_et
oam_populate_parameter_name
( oam_son_pci_conflict_confusion_ind_t *p_pci_conflict_confusion,
  UInt8 *param_name1,
  UInt8 *param_name2,
  UInt8 type
  )
{
	OAM_FUN_ENTRY_TRACE();
	/*
	 * DESCRIPTION: 
	 * 			type OAM_ONE:   parameter is PLMNID
	 *			type ONE_TWO:   parameter is Cell Identity
	 *			type OAM_THREE: parameter is CDMA XRTT cell identity
	 *			type OAM_FOUR : parameter is CDMA HRPD cell identity
	 */
	switch(p_pci_conflict_confusion->cause)
	{
		case SON_PCI_CONFLICT:
			{
				OAM_LOG(OAM, OAM_INFO, "Populating param name for SON_PCI_CONFLICT");
				if (p_pci_conflict_confusion->src_cgi.bitmask & SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT)
				{
					/** 15013_START CID 66981 **/  
					oam_memset(param_name1, OAM_ZERO, STR_LEN_255);
					/** 15013_END CID 66981 **/  
					oam_memcpy(param_name1, 
                            /* spr_21013_fix_start */
							"FAPService.CellConfig.LTE.", 
							oam_strlen("FAPService.CellConfig.LTE."));
                            /* spr_21013_fix_end */
					if (type == OAM_ONE)
					{
						oam_strcat(param_name1,"EPC.PLMNList[1].PLMNID" );
					}
					if (type == OAM_TWO)
					{
						oam_strcat(param_name1,"RAN.Common.CellIdentity" );
					}
				}
				else if (p_pci_conflict_confusion->src_cgi.bitmask & SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT)
				{
					if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.bitmask &
							SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name1, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type
								== SON_UTRAN_CELL)
						{
							oam_memcpy(param_name1, 
                                    /* spr_21013_fix_start */
									"FAPService.CellConfig.UMTS.", 
                                    /* spr_21013_fix_end */
									oam_strlen("FAPService.{i}.CellConfig.UMTS."));
							if (type == OAM_ONE)
							{
								oam_strcat(param_name1,"CN.PLMNID" );
							}
							if (type == OAM_TWO)
							{
								oam_strcat(param_name1,"RAN.CellID" );
							}
							else if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
									utran_geran_global_cell_id.
									rat_type == SON_GERAN_CELL)
							{
								OAM_LOG(OAM, OAM_INFO,"Serving cell not supported");
								OAM_FUN_EXIT_TRACE();
								return OAM_FAILURE;
							}
						}
						else if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.bitmask &
								SON_CDMA_GLOBAL_CELL_ID_PRESENT)
						{
							/** 15013_START CID 66981 **/  
							oam_memset(param_name1, OAM_ZERO, STR_LEN_255);
							/** 15013_END CID 66981 **/  
							oam_memcpy(param_name1, 
                                    /* spr_21013_fix_start */
									"FAPService.CellConfig.CDMA2000.", 
									oam_strlen("FAPService.CellConfig.CDMA2000."));
                                    /* spr_21013_fix_end */
							if (type == OAM_THREE)
							{
								oam_strcat(param_name1,"OneX.RAN.BaseID" );
							}
							if (type == OAM_FOUR)
							{
								oam_strcat(param_name1,"HRPD.RAN.RF.X_VENDOR_CELLID" );
							}
						}
						else if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.bitmask &
								SON_OTHERS_GLOBAL_CELL_ID_PRESENT)
						{
							OAM_LOG(OAM, OAM_INFO,"Serving cell not supported");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
					}
				}
				if (p_pci_conflict_confusion->cgi_1.bitmask & SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT)
				{
					/** 15013_START CID 66981 **/  
					oam_memset(param_name2, OAM_ZERO, STR_LEN_255);
					/** 15013_END CID 66981 **/  
					oam_memcpy(param_name2, 
                             /* spr_21013_fix_start */
							"FAPService.CellConfig.LTE.RAN.NeighborList.IntraFreqCell.[1]", 
							oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.IntraFreqCell.[1]."));
                            /* spr_21013_fix_end */
					if (type == OAM_ONE)
					{
						oam_strcat(param_name2,"PLMNID");
					}
					if (type == OAM_TWO)
					{
						oam_strcat(param_name2,"CID");
					}
				}
				else if (p_pci_conflict_confusion->cgi_1.bitmask & SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT)
				{
					if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.bitmask &
							SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name2, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type
								== SON_UTRAN_CELL)
						{
							oam_memcpy(param_name2, 
                                    /* spr_21013_fix_start */
									"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS.[1]", 
									oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS.[1]"));
                                    /* spr_21013_fix_end */
							if (type == OAM_ONE)
							{
								oam_strcat(param_name2,"PLMNID");
							}
							if (type == OAM_TWO)
							{
								oam_strcat(param_name2,"CID");
							}
						}
						else if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.utran_geran_global_cell_id.
								rat_type == SON_GERAN_CELL)
						{
							oam_memcpy(param_name2, 
                                    /* spr_21013_fix_start */
									"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.GSM.[1]", 
									oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.GSM.[1]"));
                                    /* spr_21013_fix_end */
							if (type == OAM_ONE)
							{
								oam_strcat(param_name2,"PLMNID");
							}
							if (type == OAM_TWO)
							{
								oam_strcat(param_name2,"CI");
							}
						}
					}
					else if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.bitmask &
							SON_CDMA_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name2, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						oam_memcpy(param_name2, 
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.CDMA2000.[1]", 
								oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.CDMA2000.[1]"));
                                /* spr_21013_fix_end */
						if (type == OAM_THREE || type == OAM_FOUR)
						{
							oam_strcat(param_name2,"CID" );
						}
					}
					else if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.bitmask &
							SON_OTHERS_GLOBAL_CELL_ID_PRESENT)
					{
						/*COVERITY FIX 66981 START*/
						oam_memset(param_name2, OAM_ZERO, STR_LEN_255);
						/*COVERITY FIX 66981 END*/
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
				}
			}
			break;
		case SON_PCI_CONFUSION:
			{
				OAM_LOG(OAM, OAM_INFO, "Populating param name for SON_PCI_CONFUSION");
				if (p_pci_conflict_confusion->cgi_1.bitmask & SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT)
				{
					/** 15013_START CID 66981 **/  
					oam_memset(param_name1, OAM_ZERO, STR_LEN_255);
					/** 15013_END CID 66981 **/  
					oam_memcpy(param_name1, 
                            /* spr_21013_fix_start */
							"FAPService.CellConfig.LTE.RAN.NeighborList.LTECell.[1].", 
							oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.LTECell.[1]."));
                            /* spr_21013_fix_end */
					if (type == OAM_ONE)
					{
						oam_strcat(param_name1,"PLMNID");
					}
					if (type == OAM_TWO)
					{
						oam_strcat(param_name1,"CID");
					}
				}
				else if (p_pci_conflict_confusion->cgi_1.bitmask & SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT)
				{
					if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.bitmask &
							SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name1, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type
								== SON_UTRAN_CELL)
						{
							oam_memcpy(param_name1, 
                                    /* spr_21013_fix_start */
									"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS.[1].", 
									oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList."
										"InterRATCell.UMTS.[1]."));
                                    /* spr_21013_fix_end */
							if (type == OAM_ONE)
							{
								oam_strcat(param_name1,"PLMNID");
							}
							if (type == OAM_TWO)
							{
								oam_strcat(param_name1,"CID");
							}
						}
						else if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.utran_geran_global_cell_id.
								rat_type == SON_GERAN_CELL)
						{
							oam_memcpy(param_name1, 
                                    /* spr_21013_fix_start */
									"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.GSM.[1].", 
									oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.GSM.[1]."));
                                    /* spr_21013_fix_end */
							if (type == OAM_ONE)
							{
								oam_strcat(param_name2,"PLMNID");
							}
							if (type == OAM_TWO)
							{
								oam_strcat(param_name2,"CI");
							}
						}
					}
					else if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.bitmask &
							SON_CDMA_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name1, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						oam_memcpy(param_name1, 
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.CDMA2000.[1].", 
								oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell."
									"CDMA2000.[1]."));
                                /* spr_21013_fix_end */
						if (type == OAM_THREE || type == OAM_FOUR)
						{
							oam_strcat(param_name2,"CID" );
						}
					}
					else if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.bitmask &
							SON_OTHERS_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name1, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
				}
				if (p_pci_conflict_confusion->cgi_2.bitmask & SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT)
				{
					/** 15013_START CID 66981 **/  
					oam_memset(param_name2, OAM_ZERO, STR_LEN_255);
					/** 15013_END CID 66981 **/  
					oam_memcpy(param_name2, 
                            /* spr_21013_fix_start */
							"FAPService.CellConfig.LTE.RAN.NeighborList.LTECell.[2]", 
							oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.LTECell.[2]."));
                            /* spr_21013_fix_end */
					if (type == OAM_ONE)
					{
						oam_strcat(param_name2,"PLMNID");
					}
					if (type == OAM_TWO)
					{
						oam_strcat(param_name2,"CID");
					}
				}
				else if (p_pci_conflict_confusion->cgi_2.bitmask & SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT)
				{
					if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.bitmask &
							SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name2, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type
								== SON_UTRAN_CELL)
						{
							oam_memcpy(param_name2, 
                                    /* spr_21013_fix_start */
									"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS.[2]", 
									oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.UMTS.[2]"));
                                    /* spr_21013_fix_end */
							if (type == OAM_ONE)
							{
								oam_strcat(param_name2,"PLMNID");
							}
							if (type == OAM_TWO)
							{
								oam_strcat(param_name2,"CID");
							}
						}
						else if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.utran_geran_global_cell_id.
								rat_type == SON_GERAN_CELL)
						{
							oam_memcpy(param_name2, 
                                    /* spr_21013_fix_start */
									"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.GSM.[2]", 
									oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.GSM.[2]"));
                                    /* spr_21013_fix_end */
							if (type == OAM_ONE)
							{
								oam_strcat(param_name2,"PLMNID");
							}
							if (type == OAM_TWO)
							{
								oam_strcat(param_name2,"CI");
							}
						}
					}
					else if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.bitmask &
							SON_CDMA_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name2, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						oam_memcpy(param_name2, 
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.CDMA2000.[2]", 
								oam_strlen("FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell.CDMA2000.[2]"));
                                /* spr_21013_fix_end */
						if (type == OAM_THREE || type == OAM_FOUR)
						{
							oam_strcat(param_name2,"CID" );
						}
					}
					else if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.bitmask &
							SON_OTHERS_GLOBAL_CELL_ID_PRESENT)
					{
						/** 15013_START CID 66981 **/  
						oam_memset(param_name2, OAM_ZERO, STR_LEN_255);
						/** 15013_END CID 66981 **/  
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
				}
			}
			break;
		default:
			OAM_LOG(OAM, OAM_WARNING, "received invalid cause %d", p_pci_conflict_confusion->cause);
			return OAM_FAILURE;
	}
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}

/***************************************************************************
 * Function Name  : oam_inform_son_pci_conflict_confusion_ind_hems
 * Description    : This function send the pci conflict/confusion report
 *				    received from SON to HeMS as inform message
 * Inputs         : p_pci_conflict_confusion : pointer to pci conflict/confusion
 *										       report received from SON
 *				    p_error_code		     : pointer to error code
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 *****************************************************************************/
oam_return_et
oam_inform_son_pci_conflict_confusion_ind_hems
(
 oam_son_pci_conflict_confusion_ind_t *p_pci_conflict_confusion,
 oam_error_code_et *p_error_code
 )
{
	oam_inform_api_t *oam_inform_api;
	UInt8 num_of_parents = OAM_ONE;
	UInt8 str_count = OAM_ZERO;
	Char8 plmn_str[OAM_TEN] = {OAM_ZERO};
	UInt32 e_out_cid = OAM_ZERO;
	UInt16 out_cid = OAM_ZERO;
	son_rat_type_et rat = SON_CELL_UNDEFINED;
	UInt8 param1_name_buff[255];
	UInt8 param2_name_buff[255];
    /*coverity 85866 fix start*/
    oam_error_code_et error_code = NO_ERROR;
    /*coverity 85866 fix end*/
	OAM_FUN_ENTRY_TRACE();
	if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_inform_api_t), (void**)&oam_inform_api,
				p_error_code))
	{
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to oam_inform_api failed"
                " with Error Code:%d",
                *p_error_code);
		OAM_FUN_EXIT_TRACE();
		return OAM_FAILURE;
	}
	/* populating Parent name */
	{
		oam_strncpy((char *)oam_inform_api->parent_name,
                /* spr_21013_fix_start */
				"FAPService.CellConfig.LTE.RAN.RF",
				sizeof("FAPService.CellConfig.LTE.RAN.RF"));
                /* spr_21013_fix_end */
	}
	/* populating p_pci_conflict_confusion->cause */
	{
		oam_memset(oam_inform_api->param_list[str_count],
				OAM_ZERO,
				sizeof(oam_inform_api->param_list[str_count]));

		oam_sprintf((char *)oam_inform_api->
				param_list[str_count],
				"%s=%d",
                /* spr_21013_fix_start */
				"FAPService.CellConfig.LTE.RAN.RF.X_VENDOR_CAUSE",
                /* spr_21013_fix_end */
				p_pci_conflict_confusion->cause);
		str_count++;
	}
	/* populating p_pci_conflict_confusion->pci*/
	{
		oam_memset(oam_inform_api->param_list[str_count],
				OAM_ZERO,
				sizeof(oam_inform_api->param_list[str_count]));
		oam_sprintf((char *)oam_inform_api->param_list[str_count],
				"%s=%d",
                /* spr_21013_fix_start */
				"FAPService.CellConfig.LTE.RAN.RF.PhyCellID",
                /* spr_21013_fix_end */
				p_pci_conflict_confusion->pci);
		str_count++;
	}
	if (p_pci_conflict_confusion->src_cgi.bitmask & SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT)
	{
		{
			if (oam_populate_parameter_name(p_pci_conflict_confusion, 
						param1_name_buff, 
						param2_name_buff, 
						OAM_ONE) == OAM_FAILURE)
			{
				OAM_LOG(OAM, OAM_WARNING,
						"cannot report conflict/confusion to HeMS");
                /*coverity 85866 fix start*/
                oam_mem_free(oam_inform_api,&error_code);
                /*coverity 85866 fix end*/
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			oam_memset(oam_inform_api->param_list[str_count],
					OAM_ZERO,
					sizeof(oam_inform_api->param_list[str_count]));
			oam_generate_plmnid(plmn_str, (void *)&p_pci_conflict_confusion->src_cgi.intra_rat_global_cell_id.plmn_id);
			oam_sprintf((char *)oam_inform_api->param_list[str_count],
					"%s=%s",
					param1_name_buff,
					plmn_str);
			str_count++;
		}
		/*populating p_pci_conflict_confusion->src_cgi.intra_rat_global_cell_id.cell_identity*/
		{
			if (oam_populate_parameter_name(p_pci_conflict_confusion, 
						param1_name_buff, 
						param2_name_buff, 
						OAM_TWO) == OAM_FAILURE)
			{
				OAM_LOG(OAM, OAM_WARNING,
						"cannot report conflict/confusion to HeMS");
				OAM_FUN_EXIT_TRACE();
                /*coverity 85866 fix start*/
                oam_mem_free(oam_inform_api,&error_code);
                /*coverity 85866 fix end*/
				return OAM_FAILURE;
			}
			oam_memset(oam_inform_api->param_list[str_count],
					OAM_ZERO,
					sizeof(oam_inform_api->param_list[str_count]));
			oam_cmn_convert_bytes_to_integer(p_pci_conflict_confusion->src_cgi.
					intra_rat_global_cell_id.cell_identity,
					OAM_FOUR,
					&e_out_cid);
			/* SPR-13253 START */
			oam_sprintf((char *)oam_inform_api->param_list[str_count],
					"%s=%d",
					param1_name_buff,
					e_out_cid);
			/* SPR-13253 END */
			str_count++;
		}
	}
	if(p_pci_conflict_confusion->src_cgi.bitmask & SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT)
	{
		rat = p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
			utran_geran_global_cell_id.rat_type;
		{
			if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.bitmask
					& SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT)
			{
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_UTRAN_CELL)
					{

						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.UMTS.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					else if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_GERAN_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.GSM.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					else if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_CDMA_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.CDMA2000.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					str_count++;
				}
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					oam_memset(plmn_str, OAM_ZERO, sizeof(plmn_str));
					oam_generate_plmnid(plmn_str, (void *)&p_pci_conflict_confusion->src_cgi.
							inter_rat_global_cell_id.utran_geran_global_cell_id.plmn_id);
					if (oam_populate_parameter_name(p_pci_conflict_confusion, 
								param1_name_buff, 
								param2_name_buff, 
								OAM_ONE) == OAM_FAILURE)
					{
						OAM_LOG(OAM, OAM_WARNING,
								"cannot report conflict/confusion to HeMS");
						OAM_FUN_EXIT_TRACE();
                        /*coverity 85866 fix start*/
                        oam_mem_free(oam_inform_api,&error_code);
                        /*coverity 85866 fix end*/
						return OAM_FAILURE;
					}
					oam_sprintf((char *)oam_inform_api->param_list[str_count],
							"%s=%s",
							param1_name_buff,
							plmn_str);
					str_count++;
				}
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					oam_memset(&out_cid, OAM_ZERO, sizeof(out_cid));	
					oam_extract_cid_from_utran_cell_identity(&out_cid, p_pci_conflict_confusion->src_cgi.
							inter_rat_global_cell_id.utran_geran_global_cell_id.cell_identity);
					if (oam_populate_parameter_name(p_pci_conflict_confusion, 
								param1_name_buff, 
								param2_name_buff, 
								OAM_TWO) == OAM_FAILURE)
					{
						OAM_LOG(OAM, OAM_WARNING,
								"cannot report conflict/confusion to HeMS");
						OAM_FUN_EXIT_TRACE();
                        /*coverity 85866 fix start*/
                        oam_mem_free(oam_inform_api,&error_code);
                        /*coverity 85866 fix end*/
						return OAM_FAILURE;
					}
					if (rat == SON_UTRAN_CELL || rat == SON_GERAN_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param1_name_buff,
								out_cid);
					}
					str_count++;
				}
			}
			if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.bitmask
					& SON_CDMA_GLOBAL_CELL_ID_PRESENT)
			{
				{
					if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
							cdma_global_cell_id.bitmask & SON_CGI_1X_RTT_PRESENT)
					{
						oam_memset(oam_inform_api->param_list[str_count],
								OAM_ZERO,
								sizeof(oam_inform_api->param_list[str_count]));
						if (oam_populate_parameter_name(p_pci_conflict_confusion, 
									param1_name_buff, 
									param2_name_buff, 
									OAM_THREE) == OAM_FAILURE)
						{
                            /* Coverity ID : 85866 Fix Start*/
							oam_mem_free(oam_inform_api,p_error_code);
							/* Coverity ID : 85866 Fix End*/
							OAM_LOG(OAM, OAM_WARNING,
									"cannot report conflict/confusion to HeMS");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param1_name_buff,
								p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
								cdma_global_cell_id.cell_global_id_1X_RTT);
						str_count++;
					}
				}
				{
					if (p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
							cdma_global_cell_id.bitmask & SON_CGI_HRPD_PRESENT)
					{
						oam_memset(oam_inform_api->param_list[str_count],
								OAM_ZERO,
								sizeof(oam_inform_api->param_list[str_count]));
						if (oam_populate_parameter_name(p_pci_conflict_confusion, 
									param1_name_buff, 
									param2_name_buff, 
									OAM_FOUR) == OAM_FAILURE)
						{
							OAM_LOG(OAM, OAM_WARNING,
									"cannot report conflict/confusion to HeMS");
							/* Coverity ID : 85866 Fix Start*/
							oam_mem_free(oam_inform_api,p_error_code);
							/* Coverity ID : 85866 Fix End*/
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param1_name_buff,
								p_pci_conflict_confusion->src_cgi.inter_rat_global_cell_id.
								cdma_global_cell_id.cell_global_id_HRPD);
						str_count++;
					}
				}
			}
		}
	}

	/* populating p_pci_conflict_confusion->cgi_2.intra_rat_global_cell_id.plmn_id*/
	if (p_pci_conflict_confusion->cgi_2.bitmask & SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT)
	{
		{
			if (oam_populate_parameter_name(p_pci_conflict_confusion, 
						param1_name_buff, 
						param2_name_buff, 
						OAM_ONE) == OAM_FAILURE)
			{
                /* Coverity ID : 85866 Fix Start*/
                oam_mem_free(oam_inform_api,p_error_code);
                /* Coverity ID : 85866 Fix End*/
				OAM_LOG(OAM, OAM_WARNING,
						"cannot report conflict/confusion to HeMS");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			oam_memset(oam_inform_api->param_list[str_count],
					OAM_ZERO,
					sizeof(oam_inform_api->param_list[str_count]));
			oam_generate_plmnid(plmn_str, (void *)&p_pci_conflict_confusion->cgi_2.
					intra_rat_global_cell_id.plmn_id);
			oam_sprintf((char *)oam_inform_api->param_list[str_count],
					"%s=%s",
					param2_name_buff,
					plmn_str);
			str_count++;
		}
		/*populating p_pci_conflict_confusion->cgi_2.intra_rat_global_cell_id.cell_identity*/
		{
			if (oam_populate_parameter_name(p_pci_conflict_confusion, 
						param1_name_buff, 
						param2_name_buff, 
						OAM_TWO) == OAM_FAILURE)
			{
                /* Coverity ID : 85866 Fix Start*/
                oam_mem_free(oam_inform_api,p_error_code);
                /* Coverity ID : 85866 Fix End*/
				OAM_LOG(OAM, OAM_WARNING,
						"cannot report conflict/confusion to HeMS");	
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			oam_memset(oam_inform_api->param_list[str_count],
					OAM_ZERO,
					sizeof(oam_inform_api->param_list[str_count]));

			oam_cmn_convert_bytes_to_integer(p_pci_conflict_confusion->cgi_2.
					intra_rat_global_cell_id.cell_identity,
					OAM_FOUR,
					&e_out_cid);
			/* SPR-13253 START */
			oam_sprintf((char *)oam_inform_api->param_list[str_count],
					"%s=%d",
					param2_name_buff,
					e_out_cid);
			/* SPR-13253 END */
			str_count++;
		}
	}
	if(p_pci_conflict_confusion->cgi_2.bitmask & SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT)
	{
		rat = p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
			utran_geran_global_cell_id.rat_type;
		{
			if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.bitmask
					& SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT)
			{
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_UTRAN_CELL)
					{

						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.UMTS.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					else if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_GERAN_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.GSM.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					else if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_CDMA_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.CDMA2000.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					str_count++;
				}
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					oam_memset(plmn_str, OAM_ZERO, sizeof(plmn_str));
					oam_generate_plmnid(plmn_str, (void *)&p_pci_conflict_confusion->cgi_2.
							inter_rat_global_cell_id.utran_geran_global_cell_id.plmn_id);
					if (oam_populate_parameter_name(p_pci_conflict_confusion, 
								param1_name_buff, 
								param2_name_buff, 
								OAM_ONE) == OAM_FAILURE)
					{
                        /* Coverity ID : 85866 Fix Start*/
                        oam_mem_free(oam_inform_api,p_error_code);
                        /* Coverity ID : 85866 Fix End*/
						OAM_LOG(OAM, OAM_WARNING,
								"cannot report conflict/confusion to HeMS");
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
					oam_sprintf((char *)oam_inform_api->param_list[str_count],
							"%s=%s",
							param2_name_buff,
							plmn_str);
					str_count++;
				}
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					oam_memset(&out_cid, OAM_ZERO, sizeof(out_cid));	
					oam_extract_cid_from_utran_cell_identity(&out_cid, p_pci_conflict_confusion->cgi_2.
							inter_rat_global_cell_id.utran_geran_global_cell_id.cell_identity);
					if (oam_populate_parameter_name(p_pci_conflict_confusion, 
								param1_name_buff, 
								param2_name_buff, 
								OAM_TWO) == OAM_FAILURE)
					{
                        /* Coverity ID : 85866 Fix Start*/
                        oam_mem_free(oam_inform_api,p_error_code);
                        /* Coverity ID : 85866 Fix End*/
						OAM_LOG(OAM, OAM_WARNING,
								"cannot report conflict/confusion to HeMS");
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
					if (rat == SON_UTRAN_CELL || rat == SON_GERAN_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param2_name_buff,
								out_cid);
					}
					str_count++;
				}
			}
			if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.bitmask
					& SON_CDMA_GLOBAL_CELL_ID_PRESENT)
			{
				{
					if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
							cdma_global_cell_id.bitmask & SON_CGI_1X_RTT_PRESENT)
					{
						oam_memset(oam_inform_api->param_list[str_count],
								OAM_ZERO,
								sizeof(oam_inform_api->param_list[str_count]));
						if (oam_populate_parameter_name(p_pci_conflict_confusion, 
									param1_name_buff, 
									param2_name_buff, 
									OAM_THREE) == OAM_FAILURE)
						{
                            /* Coverity ID : 85866 Fix Start*/
                            oam_mem_free(oam_inform_api,p_error_code);
                            /* Coverity ID : 85866 Fix End*/
							OAM_LOG(OAM, OAM_WARNING,
									"cannot report conflict/confusion to HeMS");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param2_name_buff,
								p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
								cdma_global_cell_id.cell_global_id_1X_RTT);
						str_count++;
					}

				}
				{
					if (p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
							cdma_global_cell_id.bitmask & SON_CGI_HRPD_PRESENT)
					{
						oam_memset(oam_inform_api->param_list[str_count],
								OAM_ZERO,
								sizeof(oam_inform_api->param_list[str_count]));
						if (oam_populate_parameter_name(p_pci_conflict_confusion, 
									param1_name_buff, 
									param2_name_buff, 
									OAM_FOUR) == OAM_FAILURE)
						{
                            /* Coverity ID : 85866 Fix Start*/
							oam_mem_free(oam_inform_api,p_error_code);
							/* Coverity ID : 85866 Fix End*/
							OAM_LOG(OAM, OAM_WARNING,
									"cannot report conflict/confusion to HeMS");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param2_name_buff,
								p_pci_conflict_confusion->cgi_2.inter_rat_global_cell_id.
								cdma_global_cell_id.cell_global_id_HRPD);
						str_count++;
					}
				}
			}
		}
	}


	/* populating p_pci_conflict_confusion->cgi_1.intra_rat_global_cell_id.plmn_id*/
	if (p_pci_conflict_confusion->cgi_1.bitmask & SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT)
	{
		{
			if (oam_populate_parameter_name(p_pci_conflict_confusion, 
						param1_name_buff, 
						param2_name_buff, 
						OAM_ONE) == OAM_FAILURE)
			{
                /* Coverity ID : 85866 Fix Start*/
                oam_mem_free(oam_inform_api,p_error_code);
                /* Coverity ID : 85866 Fix End*/
				OAM_LOG(OAM, OAM_WARNING,
						"cannot report conflict/confusion to HeMS");
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			oam_memset(oam_inform_api->param_list[str_count],
					OAM_ZERO,
					sizeof(oam_inform_api->param_list[str_count]));
			oam_generate_plmnid(plmn_str, (void *)&p_pci_conflict_confusion->cgi_1.
					intra_rat_global_cell_id.plmn_id);
			oam_sprintf((char *)oam_inform_api->param_list[str_count],
					"%s=%s",
					param2_name_buff,
					plmn_str);
			str_count++;
		}
		/*populating p_pci_conflict_confusion->cgi_1.intra_rat_global_cell_id.cell_identity*/
		{
			if (oam_populate_parameter_name(p_pci_conflict_confusion, 
						param1_name_buff, 
						param2_name_buff, 
						OAM_TWO) == OAM_FAILURE)
			{
                /* Coverity ID : 85866 Fix Start*/
                oam_mem_free(oam_inform_api,p_error_code);
                /* Coverity ID : 85866 Fix End*/
				OAM_LOG(OAM, OAM_WARNING,
						"cannot report conflict/confusion to HeMS");	
				OAM_FUN_EXIT_TRACE();
				return OAM_FAILURE;
			}
			oam_memset(oam_inform_api->param_list[str_count],
					OAM_ZERO,
					sizeof(oam_inform_api->param_list[str_count]));

			oam_cmn_convert_bytes_to_integer(p_pci_conflict_confusion->cgi_1.
					intra_rat_global_cell_id.cell_identity,
					OAM_FOUR,
					&e_out_cid);
			/* SPR-13253 START */
			oam_sprintf((char *)oam_inform_api->param_list[str_count],
					"%s=%d",
					param2_name_buff,
					e_out_cid);
			/* SPR-13253 END */
			str_count++;
		}
	}
	if(p_pci_conflict_confusion->cgi_1.bitmask & SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT)
	{
		rat = p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
			utran_geran_global_cell_id.rat_type;
		{
			if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.bitmask
					& SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT)
			{
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_UTRAN_CELL)
					{

						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.UMTS.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					else if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_GERAN_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.GSM.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					else if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
							utran_geran_global_cell_id.rat_type == SON_CDMA_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%d",
                                /* spr_21013_fix_start */
								"FAPService.CellConfig.LTE.RAN.NeighborList."
								"InterRATCell.CDMA2000.XVENDOR_RAT_TYPE",
                                /* spr_21013_fix_end */
								p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
								utran_geran_global_cell_id.rat_type);
					}
					str_count++;
				}
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					oam_memset(plmn_str, OAM_ZERO, sizeof(plmn_str));
					oam_generate_plmnid(plmn_str, (void *)&p_pci_conflict_confusion->cgi_1.
							inter_rat_global_cell_id.utran_geran_global_cell_id.plmn_id);
					if (oam_populate_parameter_name(p_pci_conflict_confusion, 
								param1_name_buff, 
								param2_name_buff, 
								OAM_ONE) == OAM_FAILURE)
					{
                        /* Coverity ID : 85866 Fix Start*/
                        oam_mem_free(oam_inform_api,p_error_code);
                        /* Coverity ID : 85866 Fix End*/
						OAM_LOG(OAM, OAM_WARNING,
								"cannot report conflict/confusion to HeMS");
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
					oam_sprintf((char *)oam_inform_api->param_list[str_count],
							"%s=%s",
							param2_name_buff,
							plmn_str);
					str_count++;
				}
				{
					oam_memset(oam_inform_api->param_list[str_count],
							OAM_ZERO,
							sizeof(oam_inform_api->param_list[str_count]));
					oam_memset(&out_cid, OAM_ZERO, sizeof(out_cid));	
					oam_extract_cid_from_utran_cell_identity(&out_cid, p_pci_conflict_confusion->cgi_1.
							inter_rat_global_cell_id.utran_geran_global_cell_id.cell_identity);
					if (oam_populate_parameter_name(p_pci_conflict_confusion, 
								param1_name_buff, 
								param2_name_buff, 
								OAM_TWO) == OAM_FAILURE)
					{
                        /* Coverity ID : 85866 Fix Start*/
                        oam_mem_free(oam_inform_api,p_error_code);
                        /* Coverity ID : 85866 Fix End*/
						OAM_LOG(OAM, OAM_WARNING,
								"cannot report conflict/confusion to HeMS");
						OAM_FUN_EXIT_TRACE();
						return OAM_FAILURE;
					}
					if (rat == SON_UTRAN_CELL || rat == SON_GERAN_CELL)
					{
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param2_name_buff,
								out_cid);
					}
					str_count++;
				}
			}
			if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.bitmask
					& SON_CDMA_GLOBAL_CELL_ID_PRESENT)
			{
				{
					if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
							cdma_global_cell_id.bitmask & SON_CGI_1X_RTT_PRESENT)
					{
						oam_memset(oam_inform_api->param_list[str_count],
								OAM_ZERO,
								sizeof(oam_inform_api->param_list[str_count]));
						if (oam_populate_parameter_name(p_pci_conflict_confusion, 
									param1_name_buff, 
									param2_name_buff, 
									OAM_THREE) == OAM_FAILURE)
						{
                            /* Coverity ID : 85866 Fix Start*/
                            oam_mem_free(oam_inform_api,p_error_code);
                            /* Coverity ID : 85866 Fix End*/
							OAM_LOG(OAM, OAM_WARNING,
									"cannot report conflict/confusion to HeMS");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param2_name_buff,
								p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
								cdma_global_cell_id.cell_global_id_1X_RTT);
						str_count++;
					}

				}
				{
					if (p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
							cdma_global_cell_id.bitmask & SON_CGI_HRPD_PRESENT)
					{
						oam_memset(oam_inform_api->param_list[str_count],
								OAM_ZERO,
								sizeof(oam_inform_api->param_list[str_count]));
						if (oam_populate_parameter_name(p_pci_conflict_confusion, 
									param1_name_buff, 
									param2_name_buff, 
									OAM_FOUR) == OAM_FAILURE)
						{
                            /* Coverity ID : 85866 Fix Start*/
                            oam_mem_free(oam_inform_api,p_error_code);
                            /* Coverity ID : 85866 Fix End*/
							OAM_LOG(OAM, OAM_WARNING,
									"cannot report conflict/confusion to HeMS");
							OAM_FUN_EXIT_TRACE();
							return OAM_FAILURE;
						}
						oam_sprintf((char *)oam_inform_api->param_list[str_count],
								"%s=%s",
								param2_name_buff,
								p_pci_conflict_confusion->cgi_1.inter_rat_global_cell_id.
								cdma_global_cell_id.cell_global_id_HRPD);
						str_count++;
					}
				}
			}
		}
	}


	oam_inform_api->num_of_param=str_count;
	oam_compose_and_send_inform_api((oam_inform_api_t **)&oam_inform_api,
			num_of_parents,(UInt8 *)"pci conflict confusion report\0",TR069_MODULE_ID, OAM_MODULE_ID);
	/* Coverity ID : 85866 Fix Start*/
	oam_mem_free(oam_inform_api,p_error_code);
	/* Coverity ID : 85866 Fix End*/
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}
/*SPR 9614 end*/

/* SPR 14167 FIX START */
/**************************************************************
 * Function Name  : oam_clean_nliu_data
 * Description    : This function cleans NeighborListInUse data
 * Inputs         : cell_arr_idx: array index 
 * Outputs        : none
 * Returns        : none
 *************************************************************/
void oam_clean_nliu_data(UInt8 cell_arr_idx)
{
	/* Resetting temporary data */
	oam_memset(&LOCAL_NRT_INFO(cell_arr_idx), OAM_ZERO,
			sizeof(oam_son_anr_updated_nrt_info_t));
	oam_memset(LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
			last_nrt_upd_time, OAM_ZERO,
			NRT_INFO_MAX_TIMESTAMP_LEN);
	LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		inter_rat_gsm_neigh_size = OAM_ZERO;
	LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		inter_rat_umts_neigh_size = OAM_ZERO;
	LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		inter_rat_gsm_neigh_valid_bitmap = OAM_ZERO;
	LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		inter_rat_umts_neigh_valid_bitmap = OAM_ZERO;
	LOCAL_SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		intra_rat_neigh_valid_bitmap = OAM_ZERO;

	/* Resetting master data */
	oam_memset(&NRT_INFO(cell_arr_idx), OAM_ZERO,
			sizeof(oam_son_anr_updated_nrt_info_t));
	oam_memset(SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].last_nrt_upd_time,
			OAM_ZERO, NRT_INFO_MAX_TIMESTAMP_LEN);
	SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		inter_rat_gsm_neigh_size = OAM_ZERO;
	SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		inter_rat_umts_neigh_size = OAM_ZERO;
	SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		inter_rat_gsm_neigh_valid_bitmap = OAM_ZERO;
	SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		inter_rat_umts_neigh_valid_bitmap = OAM_ZERO;
	SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].
		intra_rat_neigh_valid_bitmap = OAM_ZERO;
}
/* SPR 14167 FIX END */
/* Spr 15438 Fix Start */
/****************************************************************************
 * Function Name : oam_validate_send_son_nr_delete_req
 * Description   : This function first validates the user request for neighbor
 delete request and then it sends the request to SON layer
 * Inputs        : 1. pointer to user Request buffer
 2. pointer to oam_son_nr_delete_req_t structure
 3. transaction ID to send the request for
 *                 
 * Outputs       : p_error_code : Error Code
 * Returns       : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
oam_return_et oam_validate_send_son_nr_delete_req
(
 UInt8     *p_api_buf,
 oam_son_nr_delete_req_t *p_req,
 UInt16                  src_module_id,
 UInt16                  transaction_id,
 UInt8                   cid,
 oam_error_code_et       *p_error_code
 )
{
    OAM_FUN_ENTRY_TRACE();
    SInt16 cgi_found = NOT_FOUND; 
    oam_return_et retVal = OAM_FAILURE;
    UInt8 query_idx =0;
    /* Spr 15438 Fix Start */
    /*  coverity 83449 fix start */
    SInt16 cgi_found_in_nliu; 
    /*  coverity 83449 fix end */
    UInt16 dst_id ;
    UInt32 nr_bit = OAM_ONE;
    /* SPR 18930  FIX START */
	SInt8 nliu_idx = OAM_ZERO;
	SInt8 nr_cell_arr_idx = OAM_ZERO;
    /* SPR 18930  FIX END */
	oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;
	oam_cell_neighbourlist_info_t *p_cell_neigh_info = OAM_NULL; 
    oam_son_anr_updated_nrt_info_t *p_son_nrt_info = OAM_NULL;
    oam_son_anr_updated_nrt_info_t *p_local_son_nrt_info = OAM_NULL;



    /* SPR 18930  FIX START */
	nr_cell_arr_idx = oam_get_son_cell_nr_list_idx(cid);
	nliu_idx = oam_get_son_neigh_list_in_use_idx(cid);
	if((OAM_ERROR_RETURN_VAL == nr_cell_arr_idx) ||
			(OAM_ERROR_RETURN_VAL == nliu_idx))
    {
        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context"
                "[cid=%d , nr_cell_arr_idx=%d, nliu_idx=%d",
                cid,nr_cell_arr_idx,nliu_idx);
        /* Cov CID 107815/14/12/8 Fix Start */
        return OAM_FAILURE;
        /* Cov CID 107815/14/12/8 Fix End */
    }
    /* SPR 18930  FIX END */
    /* Spr 15438 Fix End */
    if(OAM_NULL == p_api_buf || OAM_NULL == p_req ||
            OAM_NULL == p_error_code) {
        OAM_LOG(OAM, OAM_WARNING, "Null pointer passed.");
        OAM_FUN_ENTRY_TRACE();
        return retVal;
    }
/* SPR 18930  FIX START */
	p_local_son_nrt_info = &LOCAL_NRT_INFO(nliu_idx);
	p_son_nrt_info = &NRT_INFO(nliu_idx);
	p_cell_neigh_info = &SON_NEIGHBORLIST_INFO(nr_cell_arr_idx); 
	p_son_nr_add = &SON_NR_ADD_REQ(nr_cell_arr_idx);
    query_idx = LOCAL_SON_PROV_REQ.cell_neighbourlist_info[nr_cell_arr_idx].nr_list_query_idx;
/* SPR 18930  FIX END */
    dst_id = get_word_from_header(p_api_buf + 2);

    /*Coverity fix start : 83447 */
/* SPR-13586 START */
    if(OAM_SON_BIT_1 & p_req->trgt_cgi_list[OAM_ZERO].bitmask) {
/* SPR-13586 END */
        oam_prov_req.oam_son_req.nr_action |= OAM_NR_ACTION_DELETE_EUTRAN;
        /* Delete request for Intra-RAT neighbor received */
        /* SPR 17777 fix */
        OAM_LOG(OAM, OAM_DETAILED,
                "Delete request for Intra-RAT neighbor received, unused parameter %u", src_module_id);
        cgi_found = oam_cgi_search_in_neigh_list(
                &p_req->trgt_cgi_list[OAM_ZERO].intra_rat_global_cell_id,
                p_son_nr_add->nr_list.intra_rat_nr_list,
                p_son_nr_add->nr_list.intra_rat_nr_list_size,
                &p_cell_neigh_info->intra_rat_nr_entry_bitmap,
                OAM_SON_NEIGH_TYPE_INTRA_RAT);
    }
/* SPR-13586 START */
    else{
      if(p_req->trgt_cgi_list[OAM_ZERO].inter_rat_global_cell_id.utran_geran_global_cell_id.rat_type == SON_GERAN_CELL)
      {
       oam_prov_req.oam_son_req.nr_action |= OAM_NR_ACTION_DELETE_GERAN;
        /* Delete request for Inter-RAT neighbor received */
        OAM_LOG(OAM, OAM_DETAILED,
                "Delete request for Inter-RAT neighbor received");
        cgi_found = oam_cgi_search_in_neigh_list(
                &p_req->trgt_cgi_list[OAM_ZERO].inter_rat_global_cell_id.
                utran_geran_global_cell_id,
                p_son_nr_add->nr_list.inter_rat_nr_list,
                p_son_nr_add->nr_list.inter_rat_nr_list_size,
                &p_cell_neigh_info->inter_rat_gsm_entry_bitmap,
                OAM_SON_NEIGH_TYPE_INTER_RAT_GERAN);
      }
      else if(p_req->trgt_cgi_list[OAM_ZERO].inter_rat_global_cell_id.utran_geran_global_cell_id.rat_type == SON_UTRAN_CELL) 
      {
        oam_prov_req.oam_son_req.nr_action |= OAM_NR_ACTION_DELETE_UTRAN;
        /* Delete request for Inter-RAT neighbor received */
        OAM_LOG(OAM, OAM_DETAILED,
                "Delete request for Inter-RAT neighbor received");
        cgi_found = oam_cgi_search_in_neigh_list(
                &p_req->trgt_cgi_list[OAM_ZERO].inter_rat_global_cell_id.
                utran_geran_global_cell_id,
                p_son_nr_add->nr_list.inter_rat_nr_list,
                p_son_nr_add->nr_list.inter_rat_nr_list_size,
                &p_cell_neigh_info->inter_rat_umts_entry_bitmap,
                OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);
    }
    }
/* SPR-13586 END */

    if((NOT_FOUND == cgi_found)  ||
/* SPR 17409 changes start */
            (cgi_found != query_idx)) {
/* SPR 17409 changes end */

        Char8 *err_string = OAM_NULL;
        if(NOT_FOUND == cgi_found)
            err_string = "Neighbor not found";
        else {
            err_string = "CGI-NeighborInstanceID mismatch";
        }

        UInt16 tid = get_word_from_header(p_api_buf);
        UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);

        OAM_LOG(OAM, OAM_WARNING, "%s", err_string);
        oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                OAM_ERR_REQUEST_DENIED,
                (UInt8*)err_string,
                oam_strlen(err_string) + OAM_ONE,
                OAM_VERSION_ID,
                OAM_MODULE_ID, dst_id,
                tid, OAM_ZERO,
                OAM_ZERO, p_error_code);
        retVal = OAM_SUCCESS;
    }
    else {
    /* Spr 15438 Fix Start */
        if(oam_prov_req.oam_son_req.nr_action & OAM_NR_ACTION_DELETE_EUTRAN)
        { 
            cgi_found_in_nliu = oam_cgi_search_in_neigh_list(
                    &p_req->trgt_cgi_list[OAM_ZERO].intra_rat_global_cell_id,
                    p_son_nrt_info->nr_list.intra_rat_nr_list,
                    p_son_nrt_info->nr_list.intra_rat_nr_list_size,
    /* SPR 18930  FIX START */
                    &SON_PROV_REQ.neigh_list_in_use[nliu_idx].intra_rat_neigh_valid_bitmap,
    /* SPR 18930  FIX END */
                    OAM_SON_NEIGH_TYPE_INTRA_RAT);
           
                if(cgi_found_in_nliu == NOT_FOUND)
                {
                    OAM_LOG(OAM, OAM_DETAILED,
                            "Deleting Neighbour from NR List "
                            " NLIU Deletion is not required as Neighbour"
                            " is not present in NLIU");

                    /* Delete From NR List Only */
                    SON_PROV_REQ.nr_action &= ~OAM_NR_ACTION_DELETE_EUTRAN;
                    p_cell_neigh_info->intra_rat_nr_entry_bitmap &=
                        ~(nr_bit << query_idx);
                    /*SPR_16951_START*/
                    /*Code Removed*/
                    /*SPR_16951_END*/
                    OAM_LOG(OAM,OAM_INFO,"Value of intra_rat_nr_entry_bitmap is: %d",
                            p_cell_neigh_info->intra_rat_nr_entry_bitmap);

                    oam_prov_req.oam_son_req.nr_action &= ~OAM_NR_ACTION_DELETE_EUTRAN;
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO,
                            (UInt8*)NULL,
                            OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID, dst_id,
                            transaction_id, OAM_ZERO,
                            OAM_ZERO, p_error_code);

                    return OAM_SUCCESS;
                } 
        } 
        OAM_LOG(OAM, OAM_DETAILED,
                        "Sending SON_OAM_NR_DELETE_REQ To SON");
        /* Spr 15438 Fix End */
        retVal = oam_son_send_son_oam_nr_delete_req(p_req, 
                                                    OAM_MODULE_ID,
                                                    SON_MODULE_ID,
                                                    transaction_id,
                                                    cid);
        /* Spr 15438 Fix Start */

    /* SPR 18930  FIX START */
        oam_memcpy(&p_local_son_nrt_info->src_cgi,
                &(p_cell_neigh_info->oam_son_nr_add_req.src_cgi),
                sizeof(son_intra_rat_global_cell_id_t));

        p_local_son_nrt_info->nrt_op = SON_NRT_OP_DELETE;
        p_local_son_nrt_info->nr_list.intra_rat_nr_list_size = OAM_ONE;

    /* SPR 18930  FIX END */
        oam_memcpy(&p_local_son_nrt_info->nr_list.intra_rat_nr_list[OAM_ZERO].nbr_cgi,
                        &p_son_nr_add->nr_list.
                        intra_rat_nr_list[query_idx].nbr_cgi,
                        sizeof(son_intra_rat_global_cell_id_t));
        /* Spr 15438 Fix End */
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}
#endif
/* Spr 15438 Fix End */
/*SPR 15527 START*/
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_tti_bundling
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS:NONE
 ******************************************************************************/
void
set_bitmask_tti_bundling
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_TTI_BUNDLING_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_packet_error_loss_rate
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE 
 *            
 ******************************************************************************/
void
set_bitmask_packet_error_loss_rate
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_dscp
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_dscp
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_DSCP_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_sps_config_enabled
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_sps_config_enabled
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SPS_CONFIG_ENABLED_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_sps_config_dl
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_sps_config_dl
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SPS_CONFIG_DATA_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.sps_data.bitmask |= RRM_OAM_SPS_CONFIG_DL_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_sps_config_ul
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_sps_config_ul
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SPS_CONFIG_DATA_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.sps_data.bitmask |= RRM_OAM_SPS_CONFIG_UL_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_lossless_ho_required
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_lossless_ho_required
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_LOSSLESS_HO_REQ_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_dl_forwarding_applicability
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_dl_forwarding_applicability
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_DL_FWDING_APPLICABLE;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_ue_inactivity_timer_config
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_ue_inactivity_timer_config
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_UE_INACTIVE_TIMER_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_supported_rat
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_supported_rat
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SUPPORTED_RAT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_ul_min_bitrate
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_ul_min_bitrate
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_NGBR_UL_MIN_BITRATE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_dl_min_bitrate
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_dl_min_bitrate
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_NGBR_DL_MIN_BITRATE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rlc_mode
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rlc_mode
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_RLC_MODE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_sn_field_len_dl_rlc
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_sn_field_len_dl_rlc
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.sn_field_len.bitmask |= 
                RRM_OAM_SN_FIELD_LEN_DL_RLC_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_sn_field_len_ul_rlc
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_sn_field_len_ul_rlc
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.sn_field_len.bitmask |= 
                RRM_OAM_SN_FIELD_LEN_UL_RLC_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_t_reordering_am
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_t_reordering_am
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.addl_rlc_param.bitmask |= 
                RRM_OAM_TMR_REORDER_FOR_AM_MODE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_t_reordering_um
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_t_reordering_um
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.addl_rlc_param.bitmask |= 
                RRM_OAM_TMR_REORDER_FOR_UM_MODE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_ul_am_poll_byte
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_ul_am_poll_byte
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.addl_rlc_param.bitmask |= 
                RRM_OAM_UL_AM_POLL_BYTE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_ul_am_rrc_max_retx_threshold
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_ul_am_rrc_max_retx_threshold
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.addl_rlc_param.bitmask |= 
               RRM_OAM_MAX_RTX_THRESHOLD_PRESENT ;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rlc_am_status_report_required
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rlc_am_status_report_required
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_RLC_AM_STATUS_REPORT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_pdcp_discard_timer
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_pdcp_discard_timer
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_DISCARD_TIMER_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME:
 *   set_bitmask_rlc_um_pdcp_sn_size
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rlc_um_pdcp_sn_size
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SN_FIELD_LEN_PRESENT ;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.sn_field_len.bitmask |= 
            RRM_OAM_RLC_UM_PDCP_SN_SIZE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/****************************************************************************
 *   FUNCTION NAME:
 *   set_bitmask_rlc_am_enb_status_report_required
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rlc_am_enb_status_report_required
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_RLC_AM_ENB_STATUS_REPORT_PRESENT ;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME:
 *   set_bitmask_enable_rohc
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_enable_rohc
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_ENABLE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_max_cid
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_max_cid
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_MAX_CID_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0001
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0001
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_1_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0002
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0002
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_2_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0003
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0003
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_3_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0004
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0004
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_4_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0006
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0006
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_6_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0101
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0101
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_101_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0102
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0102
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_102_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0103
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0103
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_103_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_rohc_profile0x0104
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_rohc_profile0x0104
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PDCP_ROHC_PARAMS_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.bitmask |= 
            RRM_OAM_ROHC_PROFILE_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.rohc_params.rohc_profiles.bitmask |= 
            RRM_OAM_ROHC_PROFILE_104_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_logical_channel_group
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_logical_channel_group
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_LOGICAL_CHANNEL_GROUP_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_max_harq_retrans
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_max_harq_retrans
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_ARQ_TX_RETRANS_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_max_harq_tx
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_max_harq_tx
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_MAX_HARQ_TX_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_sr_configuration
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_sr_configuration
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SR_CONFIGURATION_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_t_status_prohibit
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_t_status_prohibit
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.addl_rlc_param.bitmask 
            |= RRM_OAM_TMR_STATUS_PROHIBIT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_t_poll_pdu
 *   DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *   RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_t_poll_pdu
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.addl_rlc_param.bitmask 
            |= RRM_OAM_TMR_POLL_PDU_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_t_poll_retransmit
 *  DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_t_poll_retransmit
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_ADDL_RLC_PARAM_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.addl_rlc_param.bitmask 
            |= RRM_OAM_TMR_RETRSMIT_PRESENT;

    OAM_FUN_EXIT_TRACE();
}
/****************************************************************************
 *   FUNCTION NAME: set_bitmask_srvcc_op_required
 *  DESCRIPTION:  This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS: NONE
 ******************************************************************************/
void
set_bitmask_srvcc_op_required
(
 int loop,
 void*p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILED,"unused parameter %d", loop);

    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    oam_rrm_cell_reconfig_req_t *p_cell_config = p_cell_reconfig_req;
    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    p_cell_config->bitmask |= RRM_OAM_EPC_INFO_PRESENT;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_SRVCC_OP_REQUIRED_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *   FUNCTION NAME: set_bitmask_short_drx_cycle
 *  DESCRIPTION  : This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS      : NONE
 **************************************************************************/
void set_bitmask_short_drx_cycle

(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    set_bitmask_mac_layer_params_drx(loop, p_cell_reconfig_req);
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].drx_per_qci_info.bitmask |=
        RRM_OAM_SHORT_DRX_CYCLE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *  FUNCTION NAME: set_bitmask_bucket_size_duration
 *  DESCRIPTION  : This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS      : NONE
 **************************************************************************/
void set_bitmask_bucket_size_duration
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_BUCKET_SIZE_DURATION_PRESENT;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 *  FUNCTION NAME: set_bitmask_prioritized_bit_rate
 *  DESCRIPTION  : This function will set the corresponding bitmask for the
 *                 optional parameter
 *  Inputs       : loop : loop value for future reference
 *  Output       : NONE
 *  RETURNS      : NONE
 **************************************************************************/
void set_bitmask_prioritized_bit_rate
(
 int loop,
 void * p_cell_reconfig_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid);
        return;
    }   

    UInt8 idx = local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_query_idx;
    local_prov_req.oam_rrm_req.qos_data[cell_config_idx].qos_obj_list[idx].qos_qci_info.bitmask |= RRM_OAM_PRIORITIZED_BIT_RATE_PRESENT;
    OAM_FUN_EXIT_TRACE();
}
/*SPR 15527 END*/


#ifdef OAM_SON_ENABLE
/* Spr 15438 Fix Start */
/**************************************************************************
 * FUNCTION NAME: set_bitmask_for_lte_cell_enable
 * DESCRIPTION  : This function will set bitmask for updation of parameter
 * Inputs       : loop : loop value for future reference
 * Output       : none
 * RETURNS      : none
 *****************************************************************************/
void
set_bitmask_for_lte_cell_enable
(
 int loop, 
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
	UInt8 idx = p_local_nr_info->nr_list_query_idx;

                        /* SPR 18930  FIX START */
    p_local_nr_info->eutran_nbr_ctxt[idx].
               bitmask |= OAM_SON_NEIGHBOUR_ENABLE_PRESENT;
                        /* SPR 18930  FIX END */

    OAM_FUN_EXIT_TRACE();
}


/**************************************************************************
 * FUNCTION NAME: set_bitmask_for_lte_cell_must_include 
 * DESCRIPTION  : This function will set bitmask for updation of parameter
 * Inputs       : loop : loop value for future reference
 * Output       : none
 * RETURNS      : none
 *****************************************************************************/
void
set_bitmask_for_lte_cell_must_include
(
 int loop, 
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
	UInt8 idx = p_local_nr_info->nr_list_query_idx;
    
                        /* SPR 18930  FIX START */
    p_local_nr_info->eutran_nbr_ctxt[idx].
               bitmask |= OAM_SON_NEIGHBOUR_MI_PRESENT;
                        /* SPR 18930  FIX END */
    
    OAM_FUN_EXIT_TRACE();
}
/* Spr 15438 Fix End */
/* Spr 15438 Fix Start */
/* SPR 15266 Fix Start */
/**************************************************************************
 * Function Name  : oam_add_neighbour_to_NL_n_check_if_update_req_at_son_nrt
 * Inputs         : neigh_idx : Idx of neighbour in NLIU
 * Outputs        :
 * Returns        : OAM_TRUE / OAM_FALSE
 * Description    : Add neighbour in NL and check weather this needs to be
 *                  updated at son
 *****************************************************************************/

                        /* SPR 18930  FIX START */
oam_bool_et
oam_add_neighbour_to_NL_n_check_if_update_req_at_son_nrt(SInt16 neigh_idx,SInt8 cell_arr_idx)
{
    OAM_FUN_ENTRY_TRACE();

    son_intra_rat_neighbor_info_t *intra_rat_nliu_neighbour = OAM_NULL;
    son_utran_neighbor_info_t *inter_rat_utran_nliu_neighbour = OAM_NULL;
    son_geran_neighbor_info_t *inter_rat_geran_nliu_neighbour = OAM_NULL;

    UInt8 query_idx = LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).nr_list_query_idx;
	UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;

    UInt32 nr_bit = OAM_ONE;
    oam_bool_et retval = OAM_FALSE;

    SInt8 nliu_cell_idx = oam_get_son_neigh_list_in_use_idx(cid);
    if(OAM_ERROR_RETURN_VAL == nliu_cell_idx) {

        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context"
                "[cid=%d ,nliu_cell_idx =%d]",
                 cid,nliu_cell_idx);
        /* SPR 18930  FIX END */

        return retval;
    }

    /* adding this neighbour info to NL as NR ADD is requested from user */
    if(LOCAL_SON_NR_LIST(cell_arr_idx).intra_rat_nr_list_size) {

        intra_rat_nliu_neighbour =
            &NRT_INFO(nliu_cell_idx).nr_list.intra_rat_nr_list[neigh_idx];

        oam_memcpy(
                &SON_NR_LIST(cell_arr_idx).intra_rat_nr_list[query_idx],
                intra_rat_nliu_neighbour,
                sizeof(son_intra_rat_neighbor_info_t));



        /* Resetting the X2 STATUS Bitmask As this cannot be add/update by OAM */
        SON_NR_LIST(cell_arr_idx).intra_rat_nr_list[query_idx].bitmask &=
                                        ~SON_ENABLE_X2_STATUS_PRESENT;

        SON_NEIGHBORLIST_INFO(cell_arr_idx).intra_rat_nr_entry_bitmap |=
            (nr_bit << query_idx);
        /* SPR 15604 START */
        /* Code Removed */
        /* SPR 15604 END */
    }
    else if (LOCAL_SON_NR_LIST(cell_arr_idx).inter_rat_nr_list_size) {

        SON_NR_LIST(cell_arr_idx).inter_rat_nr_list_size++;

        if(LOCAL_SON_NR_LIST(cell_arr_idx).inter_rat_nr_list[query_idx].bitmask & SON_INTER_UTRAN_NEIGHBOR){

            inter_rat_utran_nliu_neighbour =
                &NRT_INFO(nliu_cell_idx).nr_list.inter_rat_nr_list[neigh_idx].utran_neighbor;

            SON_NR_LIST(cell_arr_idx).inter_rat_nr_list[query_idx].bitmask |= SON_INTER_UTRAN_NEIGHBOR;
            oam_memcpy(
                    &SON_NR_LIST(cell_arr_idx).inter_rat_nr_list[query_idx].utran_neighbor,
                    inter_rat_utran_nliu_neighbour,
                    sizeof(son_utran_neighbor_info_t));
         
            SON_NEIGHBORLIST_INFO(cell_arr_idx).inter_rat_umts_entry_bitmap |=
                (nr_bit << query_idx);
            /*SPR_16951_START*/
            /*Code Removed*/
            /*SPR_16951_END*/
        }
        if(LOCAL_SON_NR_LIST(cell_arr_idx).inter_rat_nr_list[query_idx].bitmask & SON_INTER_GERAN_NEIGHBOR){

            inter_rat_geran_nliu_neighbour =
                &NRT_INFO(nliu_cell_idx).nr_list.inter_rat_nr_list[neigh_idx].geran_neighbor;

            SON_NR_LIST(cell_arr_idx).inter_rat_nr_list[query_idx].bitmask |= SON_INTER_GERAN_NEIGHBOR;

            oam_memcpy(
                    &SON_NR_LIST(cell_arr_idx).inter_rat_nr_list[query_idx].geran_neighbor,
                    &inter_rat_geran_nliu_neighbour,
                    sizeof(son_geran_neighbor_info_t));

            SON_PROV_REQ.neigh_list_in_use[cell_arr_idx].inter_rat_gsm_neigh_valid_bitmap |=
                (nr_bit << query_idx);

        }
    }
    retval = oam_check_if_update_req_at_son_nrt(neigh_idx, cell_arr_idx, nliu_cell_idx);

    OAM_FUN_EXIT_TRACE();
    return retval;
}
/* SPR 15266 Fix End */
                        /* SPR 18930  FIX END */



/**************************************************************************
 * Function Name  : oam_check_if_update_req_at_son_nrt 
 * Inputs         : neigh_idx : Idx of neighbour in NLIU
 * Outputs        :  
 * Returns        : OAM_TRUE / OAM_FALSE
 * Description    : Add neighbour in NL and check weather this needs to be 
 *                  updated at son  
 *****************************************************************************/
/* SPR 18930  FIX START */
oam_bool_et
oam_check_if_update_req_at_son_nrt(SInt16 neigh_idx,SInt8 cell_arr_idx,SInt8 nliu_cell_idx) 
{
    UInt8 query_idx = LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx).nr_list_query_idx;
    /* SPR 18930  FIX END */
    oam_bool_et retVal = OAM_FALSE;
    UInt32 bitmask = OAM_ZERO;
	oam_son_nr_add_req_t *p_local_son_nr_add = OAM_NULL; 
    oam_son_anr_updated_nrt_info_t *p_son_nrt_info = OAM_NULL;
	p_son_nrt_info = &NRT_INFO(nliu_cell_idx);
    p_local_son_nr_add = &LOCAL_SON_NR_ADD_REQ(cell_arr_idx);

    son_intra_rat_neighbor_info_t *intra_rat_nliu_neighbour = OAM_NULL;
    son_utran_neighbor_info_t *inter_rat_utran_nliu_neighbour = OAM_NULL;
    son_geran_neighbor_info_t *inter_rat_geran_nliu_neighbour = OAM_NULL;
    if(p_local_son_nr_add->nr_list.intra_rat_nr_list_size) {
        intra_rat_nliu_neighbour =
            &p_son_nrt_info->nr_list.intra_rat_nr_list[neigh_idx];
        bitmask =
            p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].bitmask;

        if(bitmask & SON_PCI_PRESENT) {
            if(intra_rat_nliu_neighbour-> pci !=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].pci)
            {
                retVal = OAM_TRUE;

            }
        }
        if((bitmask & SON_CELL_OFFSET_PRESENT)&& (retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->cell_specific_offset != 
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].
                    cell_specific_offset)
            {
                retVal = OAM_TRUE;

            }
        }
        if((bitmask & SON_TAC_PRESENT)&& (retVal == OAM_FALSE)) {
            if(OAM_ZERO != oam_memcmp(
                        intra_rat_nliu_neighbour->tac,
                        p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].tac,
                        SON_TAC_OCTET_SIZE))
            {
                retVal = OAM_TRUE;

            }

        }
        if((bitmask & SON_PLMN_ID_PRESENT)&& (retVal == OAM_FALSE)) {

            if (OAM_ZERO != oam_memcmp(&intra_rat_nliu_neighbour->plmn_id,
                        &p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].
                        plmn_id,
                        sizeof(son_cell_plmn_info_t) * SON_NR_MAX_NUM_PLMN))
            {
                retVal = OAM_TRUE;

            }

        }
        if((bitmask & SON_INTRA_CSG_ID_PRESENT)&& (retVal == OAM_FALSE)) {

            if(OAM_ZERO != oam_memcmp(intra_rat_nliu_neighbour->
                        csg_identity,
                        p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].
                        csg_identity,
                        SON_CSG_ID_OCTET_SIZE))
            {
                retVal = OAM_TRUE;

            }

        }
        if((bitmask & SON_EARFCN_PRESENT)&&(retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->earfcn !=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].
                    earfcn)
            {
                retVal = OAM_TRUE;

            } 
        }
        if((bitmask & SON_RSRP_PRESENT) && (retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->rsrp !=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].rsrp)
            {

                retVal= OAM_TRUE;
            }
        }
        if((bitmask & SON_RSRQ_PRESENT) && (retVal == OAM_FALSE)) {
            if(intra_rat_nliu_neighbour->rsrq !=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].rsrq)
            {

                retVal= OAM_TRUE;
            }
        }
        if((bitmask & SON_ENABLE_NR_STATUS_PRESENT)&& (retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->nr_status!=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].nr_status)
            {

                retVal= OAM_TRUE;
            }
        }
        if((bitmask & SON_ENABLE_HO_STATUS_PRESENT) && (retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->ho_status!=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].ho_status)
            {

                retVal= OAM_TRUE;
            }
        }
        if((bitmask & SON_ENABLE_X2_STATUS_PRESENT)&& (retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->x2_status !=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].x2_status)
            {

                retVal= OAM_TRUE;
            }
        }
        if((bitmask & SON_CM_CELL_OFFSET_PRESENT)&& (retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->cm_cell_specific_offset !=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].cm_cell_specific_offset)
            {

                retVal= OAM_TRUE;
            }
        }
        if((bitmask & SON_BROADCAST_STATUS_PRESENT )&& (retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->broadcast_status !=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].broadcast_status)
            {

                retVal= OAM_TRUE;
            }
        }
        if((bitmask & SON_ACCESS_MODE_PRESENT)&& (retVal == OAM_FALSE)) {

            if(intra_rat_nliu_neighbour->access_mode !=
                    p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].access_mode)
            {

                retVal= OAM_TRUE;
            }
        }
        if((bitmask & SON_PRACH_CONFIGURATION_PRESENT)&& (retVal == OAM_FALSE)) {

            if(OAM_ZERO != oam_memcmp(&intra_rat_nliu_neighbour->
                        prach_config,
                        &p_local_son_nr_add->nr_list.intra_rat_nr_list[query_idx].
                        prach_config,
                        sizeof(son_prach_configuration_t)))
            {
                retVal = OAM_TRUE;

            }

        }
    }
    else if(p_local_son_nr_add->nr_list.inter_rat_nr_list_size) {

        if(p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].bitmask 
                & SON_INTER_UTRAN_NEIGHBOR)
        {
            inter_rat_utran_nliu_neighbour =
                &p_son_nrt_info->nr_list.inter_rat_nr_list[neigh_idx].utran_neighbor;
            bitmask =
                p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.bitmask;  

            if(bitmask & SON_UTRAN_LAC_PRESENT) {

                if(OAM_ZERO != oam_memcmp(inter_rat_utran_nliu_neighbour->lac,
                            p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.lac,
                            SON_LAC_OCTET_SIZE))
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"Lac is changed for neighbor instance num =%d",query_idx+1);

                }
            } 
            if((bitmask & SON_UTRAN_RAC_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->rac  !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.rac)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"RAC is changed for neighbor instance num =%d",query_idx+1);

                }
            }
            if(bitmask & SON_UTRAN_CSG_ID_PRESENT) {

                if(OAM_ZERO != oam_memcmp(inter_rat_utran_nliu_neighbour->csg_identity,
                            p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.csg_identity,
                            SON_CSG_ID_OCTET_SIZE))
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"CSGID is changed for neighbor instance num =%d",query_idx+1);

                }
            } 
            if((bitmask & SON_UTRAN_PCI_PRESENT)&&(OAM_FALSE == retVal)) {
                if(p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.pci.bitmask == SON_PCI_FDD_PRESENT)
                { 
                    if(inter_rat_utran_nliu_neighbour->pci.pci_fdd  !=
                            p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.pci.pci_fdd)
                    {
                        retVal = OAM_TRUE;
                        OAM_LOG(OAM,OAM_INFO,"pci fdd is changed for neighbor instance num =%d",query_idx+1);

                    }
                }
                else if (p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.pci.bitmask == SON_PCI_TDD_PRESENT)
                { 
                    if(inter_rat_utran_nliu_neighbour->pci.pci_tdd  !=
                            p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.pci.pci_tdd)
                    {
                        retVal = OAM_TRUE;
                        OAM_LOG(OAM,OAM_INFO,"pci tdd is changed for neighbor instance num =%d",query_idx+1);

                    }
                }
            }
            if((bitmask & SON_UTRAN_UARFCN_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->uarfcn!=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.uarfcn)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"UARFCN is changed for neighbor instance num =%d",query_idx+1);

                }
            }
            if((bitmask & SON_UTRAN_CSO_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->cell_specific_offset!=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.cell_specific_offset)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"CSO is changed for neighbor instance num =%d",query_idx+1);

                }
            }
            if((bitmask & SON_UTRAN_ECNO_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->ecno !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.ecno)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"ECNO is changed for neighbor instance num =%d",query_idx+1);

                }
            }
            if((bitmask & SON_UTRAN_ENABLE_NR_STATUS_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->nr_status !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.nr_status)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"NR_STATUS is changed for neighbor instance num =%d",query_idx+1);

                }
            }
            if((bitmask & SON_UTRAN_ENABLE_HO_STATUS_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->ho_status !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.ho_status)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"HO_STATUS is changed for neighbor instance num =%d",query_idx+1);

                }
            }
            if((bitmask & SON_UTRAN_ACCESS_MODE_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->access_mode !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.access_mode)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"ACCSESS_MODE is changed for neighbor instance num =%d",query_idx+1);

                }
            }
            if((bitmask & SON_UTRAN_VOIP_CAPABLE_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->voip_capable!=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.voip_capable)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"VOIP_CAPABLE_PRESENT is changed for neighbor instance num =%d",query_idx+1);

                }
            }
            if((bitmask & SON_UTRAN_RSCP_PRESENT)&&(OAM_FALSE == retVal)) {
                if(inter_rat_utran_nliu_neighbour->rscp !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].utran_neighbor.rscp)
                {
                    retVal = OAM_TRUE;
                    OAM_LOG(OAM,OAM_INFO,"RSCP is changed for neighbor instance num =%d",query_idx+1);

                }
            }
        }
        else if(p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].bitmask
                & SON_INTER_GERAN_NEIGHBOR) 
        {
            inter_rat_geran_nliu_neighbour =
                &p_son_nrt_info->nr_list.inter_rat_nr_list[neigh_idx].geran_neighbor;
            bitmask =
                p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor.bitmask;

            if(bitmask & SON_GERAN_ARFCN_BAND_IND_PRESENT) {
                if(inter_rat_geran_nliu_neighbour->arfcn !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor.arfcn)
                {
                    retVal = OAM_TRUE;

                }
            }  
            if((bitmask & SON_GERAN_PCI_PRESENT) && (retVal== OAM_TRUE)) {
                if(OAM_ZERO != oam_memcmp(&inter_rat_geran_nliu_neighbour->pci,
                            &p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor.pci,
                            sizeof(son_geran_physical_cell_id_t)))
                {
                    retVal = OAM_TRUE;

                }
            }  
            if((bitmask & SON_GERAN_ENABLE_NR_STATUS_PRESENT)&&(retVal== OAM_TRUE)) {
                if(inter_rat_geran_nliu_neighbour->nr_status !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor.nr_status)
                {
                    retVal = OAM_TRUE;

                }
            }  
            if((bitmask & SON_GERAN_ENABLE_HO_STATUS_PRESENT)&&(retVal== OAM_TRUE)) {
                if(inter_rat_geran_nliu_neighbour->ho_status !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor.ho_status)
                {
                    retVal = OAM_TRUE;

                }
            }  
            if((bitmask & SON_GERAN_RAC_PRESENT)&&(retVal== OAM_TRUE)) {
                if(inter_rat_geran_nliu_neighbour->rac !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor.rac)
                {
                    retVal = OAM_TRUE;

                }
            }  
            if((bitmask & SON_GERAN_CSO_PRESENT)&&(retVal== OAM_TRUE)) {
                if(inter_rat_geran_nliu_neighbour->cell_specific_offset !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor.cell_specific_offset)
                {
                    retVal = OAM_TRUE;

                }
            }  
            if((bitmask & SON_GERAN_RSSI_PRESENT)&&(retVal== OAM_TRUE)) {
                if(inter_rat_geran_nliu_neighbour->rssi !=
                        p_local_son_nr_add->nr_list.inter_rat_nr_list[query_idx].geran_neighbor.rssi )
                {
                    retVal = OAM_TRUE;

                }
            }  
        } 
    }
    /*Coverity fix start : 83258 */
    OAM_FUN_EXIT_TRACE();
    /*Coverity fix End : 83258 */
    return retVal;
}
/* Spr 15438 Fix End */
/* Spr 15612  Fix Start*/
/**************************************************************************
 * FUNCTION NAME: set_bitmask_for_umts_cell_enable
 * DESCRIPTION  : This function will set bitmask for updation of parameter
 * Inputs       : loop : loop value for future reference
 * Output       : none
 * RETURNS      : none
 *****************************************************************************/
void
set_bitmask_for_umts_cell_enable
(
 int loop, 
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();

    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
	UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->utran_nbr_ctxt[idx].
               bitmask |= OAM_SON_NEIGHBOUR_ENABLE_PRESENT;

    OAM_FUN_EXIT_TRACE();
}

/**************************************************************************
 * FUNCTION NAME: set_bitmask_for_umts_cell_must_include 
 * DESCRIPTION  : This function will set bitmask for updation of parameter
 * Inputs       : loop : loop value for future reference
 * Output       : none
 * RETURNS      : none
 *****************************************************************************/
void
set_bitmask_for_umts_cell_must_include
(
 int loop,
 void *p_son_nr_add_req
 )
{
    OAM_FUN_ENTRY_TRACE();
    /* SPR 17777 fix */
    OAM_LOG(OAM, OAM_DETAILEDALL,"unused parameter %d", loop);

	oam_cell_neighbourlist_info_t *p_local_nr_info = p_son_nr_add_req;
	UInt8 idx = p_local_nr_info->nr_list_query_idx;

    p_local_nr_info->utran_nbr_ctxt[idx].
               bitmask |= OAM_SON_NEIGHBOUR_MI_PRESENT;

    OAM_FUN_EXIT_TRACE();
}


/**************************************************************************
 * FUNCTION NAME: oam_validate_and_send_utran_update_req 
 * DESCRIPTION  : This function will validate utran ne update based on the 
 *                input provided by user
 * Inputs       : p_api_buf,p_req 
 * Output       : none
 * RETURNS      : OAM_FAILURE/OAM_SUCCESS
 ***************************************************************************/
oam_return_et 
oam_validate_and_send_utran_update_req
(
void *p_api_buf,
 son_oam_nr_update_req_t *p_req,
 UInt8 cid,
 oam_bool_et * p_is_dom_update_reqd
)
{

    /*  coverity 85434 fix start */
    SInt16 neigh_idx;
    /*  coverity 85434 fix end */
    UInt16 dst_id = get_word_from_header(p_api_buf + OAM_TWO);
    UInt16 trans_id = get_word_from_header(p_api_buf);
    
    oam_return_et retVal = OAM_FAILURE;/*cov 85419_71315 +-*/
    oam_error_code_et p_error_code = NO_ERROR;
	oam_son_nr_add_req_t *p_local_son_nr_add = OAM_NULL;
    oam_son_anr_updated_nrt_info_t *p_son_nrt_info = OAM_NULL;
    oam_son_anr_updated_nrt_info_t *p_local_son_nrt_info = OAM_NULL;
	oam_cell_neighbourlist_info_t *p_local_cell_neigh_info = OAM_NULL;
	oam_cell_neighbourlist_info_t *p_cell_neigh_info = OAM_NULL;
	oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;

	SInt8 cell_arr_idx = OAM_ZERO;
	SInt8 cell_arr_idx1 = OAM_ZERO;
	SInt8 cell_meas_config_idx = OAM_ZERO;
	SInt8 cell_nliu_idx = OAM_ZERO;
	cell_arr_idx = oam_get_rrm_cell_config_idx(cid);
	cell_arr_idx1 = oam_get_son_cell_nr_list_idx(cid);
	cell_meas_config_idx = oam_get_son_inter_freq_carrier_idx(cid);
	cell_nliu_idx = oam_get_son_neigh_list_in_use_idx(cid);

    if((OAM_ERROR_RETURN_VAL == cell_arr_idx) ||
            (OAM_ERROR_RETURN_VAL == cell_arr_idx1) ||
            (OAM_ERROR_RETURN_VAL == cell_meas_config_idx) ||
            (OAM_ERROR_RETURN_VAL == cell_nliu_idx)) {

        OAM_LOG(OAM, OAM_WARNING, "Invalid cell context"
                "[cid=%d , rrm_cell_config_idx=%d, son_cell_nr_list_idx=%d"
                " cell_meas_config_idx =%d, cell_nliu_idx =%d]",
                cid, cell_arr_idx, cell_arr_idx1,cell_meas_config_idx,cell_nliu_idx);
        return retVal;
    }

	p_son_nr_add = &SON_NR_ADD_REQ(cell_arr_idx1);
	p_local_cell_neigh_info = &LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx1);
	p_cell_neigh_info = &SON_NEIGHBORLIST_INFO(cell_arr_idx1);
    p_local_son_nr_add = &LOCAL_SON_NR_ADD_REQ(cell_arr_idx1);
	p_son_nrt_info = &NRT_INFO(cell_nliu_idx);
	p_local_son_nrt_info = &LOCAL_NRT_INFO(cell_nliu_idx);
    UInt16 idx = p_local_cell_neigh_info->nr_list_query_idx;

    OAM_FUN_ENTRY_TRACE();

    neigh_idx = oam_cgi_search_in_neigh_list
                (&p_local_son_nr_add->nr_list.inter_rat_nr_list[idx].utran_neighbor.nbr_cgi,
                 p_son_nrt_info->nr_list.inter_rat_nr_list,
                 p_son_nrt_info->nr_list.inter_rat_nr_list_size,
                 &SON_PROV_REQ.neigh_list_in_use[cell_nliu_idx].inter_rat_umts_neigh_valid_bitmap,
                 OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);

    if((p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)||
            (p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT))
    {
        if(neigh_idx != NOT_FOUND)
        {   
            if((((p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT)&&
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include == OAM_FALSE))&&
                 ((p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)&&
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable == OAM_TRUE)))||
                 (((!(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT))&&
                 (p_cell_neigh_info->utran_nbr_ctxt[idx].must_include == OAM_FALSE))&&
                 ((p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)&&
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable == OAM_TRUE)))||
                 (((p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT)&&
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include == OAM_FALSE))&&
                 ((!(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT))&&
                 (p_cell_neigh_info->utran_nbr_ctxt[idx].enable == OAM_TRUE))))

            {
                /* Neighbour found in NLIU and Enable is true and MustInclude is false */
                OAM_LOG(OAM, OAM_DETAILED,
                        "Sending SON_OAM_NR_DELETE_REQ for umts nbr as Enable is True and MustInclude Is False");

                local_prov_req.oam_son_req.nr_action = OAM_NR_NO_ACTION;
                oam_son_nr_delete_req_t *oam_son_nr_delete_req = OAM_NULL;

                if(OAM_FAILURE == 
                        oam_mem_alloc(sizeof(oam_son_nr_delete_req_t),
                            (void**)&oam_son_nr_delete_req,
                            &p_error_code))
                {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Memory allocation to oam_son_nr_delete_req failed"
                            " with Error Code:%d",
                            p_error_code);
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }

                oam_memset(oam_son_nr_delete_req, OAM_ZERO,
                        sizeof(oam_son_nr_delete_req_t));

                oam_son_nr_delete_req->src_cgi = p_local_cell_neigh_info->oam_son_nr_add_req.src_cgi;
                oam_son_nr_delete_req->trgt_cgi_list_size = OAM_ONE;

                TRGT_CGI_LIST.bitmask = OAM_SON_BIT_2;

                TRGT_CGI_LIST.inter_rat_global_cell_id.bitmask |=
                    SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT;

                TRGT_CGI_LIST.inter_rat_global_cell_id.
                    utran_geran_global_cell_id.rat_type = SON_UTRAN_CELL;

                TRGT_CGI_LIST.inter_rat_global_cell_id.
                    utran_geran_global_cell_id.plmn_id =
                    p_local_cell_neigh_info->oam_son_nr_add_req.nr_list.
                    inter_rat_nr_list[idx].
                    utran_neighbor.nbr_cgi.plmn_id;

                oam_memcpy(TRGT_CGI_LIST.inter_rat_global_cell_id.
                        utran_geran_global_cell_id.cell_identity,
                        p_local_cell_neigh_info->oam_son_nr_add_req.nr_list.
                        inter_rat_nr_list[idx].
                        utran_neighbor.nbr_cgi.cell_identity,
                        SON_CELL_ID_OCTET_SIZE);

                retVal = oam_son_send_son_oam_nr_delete_req(oam_son_nr_delete_req, 
                        OAM_MODULE_ID,
                        SON_MODULE_ID,
                        trans_id,
                        cid);
                /* Resetting The Bitmask As Sending NR Delete To SON */
                oam_prov_req.system_status.event_ongoing &= 
                    ~OAM_SON_ADD_NR_ONGOING;

                SON_PROV_REQ.nr_action &= ~OAM_NR_ACTION_DELETE_UTRAN; 

                if(OAM_FAILURE == retVal) {
                    OAM_LOG(OAM, OAM_ERROR,
                            "Error in sending SON_OAM_NR_DELETE_REQ"
                            " with error code :%d", p_error_code);
                    /* coverity 94866 fix start */
                    oam_mem_free(oam_son_nr_delete_req,&p_error_code);
                    /* coverity 94866 fix end */
                    OAM_FUN_EXIT_TRACE();
                    return OAM_FAILURE;
                }
                else {
                    /* SPR 18930  FIX START */
                    oam_memcpy(&p_local_son_nrt_info->src_cgi,
                            &(p_cell_neigh_info->oam_son_nr_add_req.src_cgi),
                            sizeof(son_intra_rat_global_cell_id_t));

                    p_local_son_nrt_info->nrt_op = SON_NRT_OP_DELETE;
                    p_local_son_nrt_info->nr_list.inter_rat_nr_list_size = OAM_ONE;

                    /* SPR 18930  FIX END */
                    oam_memcpy(&p_local_son_nrt_info->nr_list.
                                inter_rat_nr_list[OAM_ZERO].utran_neighbor.nbr_cgi,
                               &TRGT_CGI_LIST.inter_rat_global_cell_id.
                               utran_geran_global_cell_id,
                               sizeof(son_utran_geran_global_cell_id_t));

                    p_local_son_nrt_info->nr_list.
                        inter_rat_nr_list[0].bitmask |= SON_INTER_UTRAN_NEIGHBOR;
                    /* Spr 15438 Fix End */


                    SON_PROV_REQ.nr_action  |= OAM_NLIU_ACTION_DELETE_UTRAN;
                    /* coverity 94866 fix start */
                    oam_mem_free(oam_son_nr_delete_req,&p_error_code);
                    /* coverity 94866 fix end */

                    OAM_FUN_EXIT_TRACE();
                    return OAM_SUCCESS;
                }  

            }
            else
            {
                /* Neighbour found in NLIU and MustInclude is not false and Enable true/false  */
                if(OAM_FALSE == oam_check_if_update_req_at_son_nrt(neigh_idx,cell_arr_idx1,cell_nliu_idx))
                {
                    *p_is_dom_update_reqd = OAM_TRUE;

                    OAM_LOG(OAM, OAM_DETAILED,
                            "Updating NR List Only, Not Sending Update To SON"
                            " as Values are identical");

                    /* Only Update In NR List No Need to Send NR Update To SON */
                    if(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask 
                            & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)    
                    {  
                        p_cell_neigh_info->utran_nbr_ctxt[idx].enable =
                            p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable;
                    }
                    if(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask 
                            & OAM_SON_NEIGHBOUR_MI_PRESENT)    
                    {  
                        p_cell_neigh_info->utran_nbr_ctxt[idx].must_include =
                            p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include;
                    }

                    OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL,
                            OAM_ZERO,
                            OAM_VERSION_ID,
                            OAM_MODULE_ID,
                            dst_id,
                            trans_id,
                            OAM_ZERO, OAM_ZERO,
                            &p_error_code);

                    /* Resetting The Bitmask As neighbour added to NR List */
                    oam_prov_req.system_status.event_ongoing &= 
                        ~OAM_SON_ADD_NR_ONGOING;

                    OAM_FUN_EXIT_TRACE();
                    return OAM_SUCCESS;

                }    

            }

        }
        else
        {
            if((((p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT) && 
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable == OAM_TRUE))&&
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT) &&
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include == OAM_TRUE)) ||
                 ((p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT) &&
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include == OAM_TRUE)&&
                 (!(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)) &&
                 (p_cell_neigh_info->utran_nbr_ctxt[idx].enable == OAM_TRUE)) ||
                 ((p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_ENABLE_PRESENT) &&
                 (p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable == OAM_TRUE)&&
                 (!(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask & OAM_SON_NEIGHBOUR_MI_PRESENT)) &&
                 (p_cell_neigh_info->utran_nbr_ctxt[idx].must_include == OAM_TRUE))) 
            {
                /* Neighbour not found in NLIU and enable and MustInclude are true */
                /* Sending NR ADD Req to SON */
                OAM_LOG(OAM, OAM_DETAILED,
                        "Sending SON_OAM_NR_ADD_REQ for umts nbr To SON as Enable and MustInclude made True");

                retVal = oam_son_send_son_oam_nr_add_req((son_oam_nr_add_req_t *)p_req, 
                                                          OAM_MODULE_ID, 
                                                          SON_MODULE_ID,
                                                          trans_id,
                                                          cell_arr_idx);
                oam_prov_req.system_status.event_ongoing |= OAM_SON_ADD_NR_UMTS_ONGOING;
                if(OAM_SUCCESS == retVal)
                {
                    /* SPR 18930  FIX START */
                    oam_save_nr_add_req_with_trans_id((son_oam_nr_add_req_t *)p_req,trans_id,cell_arr_idx);
                    /* SPR 18930  FIX END */
                }
                OAM_FUN_EXIT_TRACE();
                return retVal;
            }
            else
            {
                *p_is_dom_update_reqd = OAM_TRUE;
                /* Neighbour not found in NLIU and Either Enable or MustInclude Still False */
                OAM_LOG(OAM, OAM_DETAILED,
                        "Updating NR List Only Not Sending SON_OAM_NR_ADD_REQ To SON"
                        " as Either Enable or MustInclude Still False");

                /* Only Update In NR List No Need to Send NR Add To SON */
                oam_memcpy(&p_son_nr_add->nr_list.inter_rat_nr_list[idx].utran_neighbor,
                        &p_local_son_nr_add->nr_list.inter_rat_nr_list[idx].utran_neighbor,
                        sizeof(son_utran_neighbor_info_t));
                

                if(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask 
                        & OAM_SON_NEIGHBOUR_ENABLE_PRESENT)    
                {  
                    p_cell_neigh_info->utran_nbr_ctxt[idx].enable =
                        p_local_cell_neigh_info->utran_nbr_ctxt[idx].enable;
                }
                if(p_local_cell_neigh_info->utran_nbr_ctxt[idx].bitmask 
                        & OAM_SON_NEIGHBOUR_MI_PRESENT)    
                {  
                    p_cell_neigh_info->utran_nbr_ctxt[idx].must_include =
                        p_local_cell_neigh_info->utran_nbr_ctxt[idx].must_include;
                }

                p_son_nr_add->nr_list.inter_rat_nr_list[idx].bitmask |= SON_INTER_UTRAN_NEIGHBOR; 

                /* Resetting The Bitmask As neighbour added to NR List */
                oam_prov_req.system_status.event_ongoing &= 
                    ~OAM_SON_ADD_NR_ONGOING;

                OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
                oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                        OAM_ZERO, OAM_NULL,
                        OAM_ZERO,
                        OAM_VERSION_ID,
                        OAM_MODULE_ID,
                        dst_id,
                        trans_id,
                        OAM_ZERO, OAM_ZERO,
                        &p_error_code)

                    ;
                OAM_FUN_EXIT_TRACE();
                return OAM_SUCCESS;

            }  

        }
    }
    else 
    {
        if(neigh_idx == NOT_FOUND)
        {
            /* Neighbour not found in NLIU and No change in Enable and MI*/
            *p_is_dom_update_reqd = OAM_TRUE;
            OAM_LOG(OAM, OAM_DETAILED,
                    "Updating NR List Only, Not Sending SON_OAM_NR_ADD_REQ To SON"
                    " as Enable or MustInclude Still False");

            /* Only Update In NR List No Need to Send NR Add To SON */

            oam_memcpy(&p_son_nr_add->nr_list.inter_rat_nr_list[idx].utran_neighbor,
                    &p_local_son_nr_add->nr_list.inter_rat_nr_list[idx].utran_neighbor,
                    sizeof(son_utran_neighbor_info_t));


            /* Resetting The Bitmask As neighbour added to NR List */
            oam_prov_req.system_status.event_ongoing &= 
                ~OAM_SON_ADD_NR_ONGOING;

            OAM_LOG(OAM, OAM_DETAILED, "Sending Success Response to USER");
            oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                    OAM_ZERO, OAM_NULL,
                    OAM_ZERO,
                    OAM_VERSION_ID,
                    OAM_MODULE_ID,
                    dst_id,
                    trans_id,
                    OAM_ZERO, OAM_ZERO,
                    &p_error_code)
                ;
            OAM_FUN_EXIT_TRACE();
            return OAM_SUCCESS;
        }

    }
    OAM_LOG(OAM, OAM_DETAILED,"Sending SON_OAM_NR_UPDATE_REQ for inter-rat umts nbr To SON ");
	oam_prov_req.system_status.event_ongoing |= OAM_SON_UPD_NR_UMTS_ONGOING;
    retVal = oam_son_send_son_oam_nr_update_req
                   ((son_oam_nr_update_req_t *)p_req, 
                    OAM_MODULE_ID, 
                    SON_MODULE_ID,
                    trans_id,
					oam_prov_req.cell_cntxt.curr_cell_cid);
    OAM_FUN_EXIT_TRACE();
    return retVal;
}
#endif
/* Spr 15612  Fix End*/
/* SPR 15527 START */
/******************************************************************************
* Function Name  : oam_partial_path_qos_fill_params 
* Inputs         : 
* Outputs        : 
* Returns        : OAM_SUCCESS/OAM_FAILURE
* Description    : This function handles the partial path gpv support for QoS
*******************************************************************************/
oam_return_et
oam_partial_path_qos_fill_params(UInt8 *num_params , UInt8 *max_multi_obj_cnt )
{
	OAM_FUN_ENTRY_TRACE();
	g_parameter_map_element = g_parameter_TR_QOS_element;
	*num_params = ARRSIZE(g_parameter_TR_QOS_element);
    /* SPR 15527 START */
    SInt8 cell_config_idx = oam_get_rrm_cell_config_idx(oam_prov_req.cell_cntxt.curr_cell_cid);

    if(OAM_ERROR_RETURN_VAL == cell_config_idx)
    {
        OAM_LOG(OAM, OAM_ERROR, "Invalid cell context[cid=%d], rrm_cell_config_idx=[%d]",
                oam_prov_req.cell_cntxt.curr_cell_cid ,cell_config_idx);
        return OAM_FAILURE;
    }   

	*max_multi_obj_cnt = oam_prov_req.oam_rrm_req.qos_data[cell_config_idx].num_qos_entries;
    /* SPR 15527 END */

	OAM_LOG(OAM, OAM_DETAILED, "Partial parent is received for "
			"QoS.");
	if((*num_params) * (*max_multi_obj_cnt) > MAX_NUM_PARAMS_ALLOWED_GPV_RESP)
    {
        OAM_LOG(OAM, OAM_WARNING, "The number of parameters in the "
                "response are greater than the maximum limit allowed, "
                "sending an error response.");
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;;
    }
	OAM_FUN_EXIT_TRACE();
	return OAM_SUCCESS;
}
/* SPR 15527 END */
/*SPR 15604 START */
#ifdef OAM_SON_ENABLE
/**************************************************************************
 * FUNCTION NAME: oam_handle_nliu_object_updation 
 * DESCRIPTION  : This function handles updation and persistence of nliu cell parameters
 * Inputs       : NLIU list to be updated,LOCAL_NRT_INFO, instance_id, rat_type 
 * Output       : NRT_INFO
 * RETURNS      : OAM_FAILURE/OAM_SUCCESS
 ***************************************************************************/
UInt16 oam_handle_nliu_object_updation(void *p_to ,void *p_from, SInt16 instance_id, son_rat_type_et rat_type, UInt8 cell_config_idx)
{
	oam_counter_t cnt = OAM_ZERO;
	UInt32 bitmask = OAM_ZERO;
	oam_counter_t counter = OAM_ZERO;
    /*  coverity 85401 fix start */
	nliu_param_et retVal;
    /*  coverity 85401 fix end */
	UInt8 param_name_buff[256] = {0};
    /* Coverity CID 85421 Fix Start */
	UInt8 value[STR_LEN_128] = {OAM_ZERO};	
    /* Coverity CID 85421 Fix end */
	void *p_msg = OAM_NULL;
    /* SPR 15604 START */
    UInt8 num_params = OAM_ZERO;
    /* SPR 15604 END */
	son_intra_rat_neighbor_info_t *intra_rat_from_neighbor = OAM_NULL;
	son_intra_rat_neighbor_info_t *intra_rat_to_neighbor = OAM_NULL;
	son_utran_neighbor_info_t *inter_rat_utran_from_neighbor = OAM_NULL;
	son_utran_neighbor_info_t *inter_rat_utran_to_neighbor = OAM_NULL;
    /* Coverity CID 85441 Fix Start */ 
    if((OAM_NULL == p_to) || (OAM_NULL == p_from))
    {
        return OAM_FAILURE;
    }
    /* Coverity CID 85441 Fix End */ 

	if (rat_type == SON_EUTRAN_CELL)
	{
		intra_rat_from_neighbor  = (son_intra_rat_neighbor_info_t *)p_from;
		intra_rat_to_neighbor = (son_intra_rat_neighbor_info_t *)p_to;
		bitmask = intra_rat_from_neighbor->bitmask;
        oam_memcpy(param_name_buff, NLIU_LTECell_PATH, oam_strlen(NLIU_LTECell_PATH));
        num_params = 
            (sizeof(g_param_intra_rat_neigh_list_in_use)/sizeof(g_param_intra_rat_neigh_list_in_use[0]));
	}
	else if (rat_type == SON_UTRAN_CELL)
	{
		inter_rat_utran_from_neighbor = (son_utran_neighbor_info_t *) p_from;
		inter_rat_utran_to_neighbor = (son_utran_neighbor_info_t *) p_to;
		bitmask = inter_rat_utran_from_neighbor->bitmask;
        oam_memcpy(param_name_buff, NLIU_UMTS_PATH, oam_strlen(NLIU_UMTS_PATH));
        num_params = 
            (sizeof(g_param_inter_rat_neigh_list_in_use)/sizeof(g_param_inter_rat_neigh_list_in_use[0]));
	}
	else
	{
		OAM_LOG(OAM, OAM_WARNING, "Received UPDATED_NRT_INFO for unsupported neighbor");
		return OAM_FAILURE;
	}

	for (counter = OAM_ZERO; counter < num_params; counter++)
	{

        /*SPR 21628 FIXED START */    
        OAM_LOG(OAM, OAM_DETAILED, "Parameter TAG NAME :%s",g_parameter_map_element[counter].tag_name);
        /*SPR 21628 FIXED END */    

		p_msg = (void *)p_from;
		retVal = oam_validate_nliu_parameter(instance_id,
				g_parameter_map_element[counter].tag_name,
				param_name_buff,
				value,
				p_msg,
        /* SPR 18930  FIX START  */
				rat_type,
                cell_config_idx);
        /* SPR 18930  FIX END  */

		if (retVal == UNDEFINED)
		{
            OAM_LOG(OAM, OAM_DETAILED, "validation failed for Param :%s",g_parameter_map_element[counter].tag_name);
		}


		UInt32  enum_tag_val = (UInt32)oam_xml_search_string_to_integer(
                g_parameter_map_element[counter].tag_name, 
                NeighborList_Mapping_Table, OAM_THIRTY_TWO);


		switch (enum_tag_val)
		{
			case PLMNID:
				if (rat_type == SON_EUTRAN_CELL)
				{
					if(bitmask & SON_PLMN_ID_PRESENT) 
					{
						intra_rat_to_neighbor->bitmask |= SON_PLMN_ID_PRESENT;
						intra_rat_to_neighbor->num_plmn_id = intra_rat_from_neighbor->num_plmn_id;
						for(cnt = OAM_ZERO; cnt < intra_rat_to_neighbor->num_plmn_id; ++cnt) 
						{
							oam_memcpy(intra_rat_to_neighbor->plmn_id, intra_rat_from_neighbor->plmn_id,
									sizeof(son_cell_plmn_info_t));
						}
					}
				}
				else
				{
					if(bitmask & SON_UTRAN_PLMN_ID_PRESENT) 
					{
						inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_PLMN_ID_PRESENT;
                        /*Coverity 85441 Fix Start*/
						inter_rat_utran_to_neighbor->num_plmn_id = inter_rat_utran_from_neighbor->num_plmn_id;
                        /*Coverity 85441 Fix End*/
						for(cnt = OAM_ZERO; cnt < inter_rat_utran_to_neighbor->num_plmn_id; ++cnt) 
						{
							oam_memcpy(inter_rat_utran_to_neighbor->plmn_id, inter_rat_utran_from_neighbor->plmn_id,
									sizeof(son_cell_plmn_info_t));
						}
					}
				}
				break;
			case PhyCellID:
				if(bitmask & SON_PCI_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_PCI_PRESENT;
					intra_rat_to_neighbor->pci = intra_rat_from_neighbor->pci;
				}
				break;
			case QOffset:
				if(bitmask & SON_CM_CELL_OFFSET_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_CM_CELL_OFFSET_PRESENT;
					intra_rat_to_neighbor->cm_cell_specific_offset = intra_rat_from_neighbor->cm_cell_specific_offset;
				}
				break;
			case EUTRACarrierARFCN:
				if(bitmask & SON_EARFCN_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_EARFCN_PRESENT;
					intra_rat_to_neighbor->earfcn = intra_rat_from_neighbor->earfcn;
				}

				break;
			case X_VENDOR_TAC:
				if(bitmask & SON_TAC_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_TAC_PRESENT;
					oam_memcpy(intra_rat_to_neighbor->tac, intra_rat_from_neighbor->tac, SON_TAC_OCTET_SIZE);
				}
				break;
			case X_VENDOR_CSGID:
                if (rat_type == SON_EUTRAN_CELL)
                {
				if(bitmask & SON_INTRA_CSG_ID_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_INTRA_CSG_ID_PRESENT;
					oam_memcpy(intra_rat_to_neighbor->csg_identity,intra_rat_from_neighbor->csg_identity,
							SON_CSG_ID_OCTET_SIZE);
				}
                }
                else
                {
                    inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_CSG_ID_PRESENT;
                    oam_memcpy(inter_rat_utran_to_neighbor->csg_identity,inter_rat_utran_from_neighbor->csg_identity,
                            SON_CSG_ID_OCTET_SIZE);
                }
				break;
			case Blacklisted:
				if(bitmask & SON_ENABLE_HO_STATUS_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_ENABLE_HO_STATUS_PRESENT;
					intra_rat_to_neighbor->ho_status = intra_rat_from_neighbor->ho_status;
				}
				break;
			case X_VENDOR_RSRP:
				if(bitmask & SON_RSRP_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_RSRP_PRESENT;
					intra_rat_to_neighbor->rsrp = intra_rat_from_neighbor->rsrp;
				}
				break;
			case X_VENDOR_RSRQ:
				if(bitmask & SON_RSRQ_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_RSRQ_PRESENT;
					intra_rat_to_neighbor->rsrq = intra_rat_from_neighbor->rsrq;
				}
				break;
			case X_VENDOR_NR_STATUS:
                if (rat_type == SON_EUTRAN_CELL)
                {
				if(bitmask & SON_ENABLE_NR_STATUS_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_ENABLE_NR_STATUS_PRESENT;
					intra_rat_to_neighbor->nr_status = intra_rat_from_neighbor->nr_status;
				}
                }
                else
                {
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_ENABLE_NR_STATUS_PRESENT;
					inter_rat_utran_to_neighbor->nr_status = inter_rat_utran_from_neighbor->nr_status;

                }
				break;
			case X_VENDOR_BROADCAST_STATUS:
				if(bitmask & SON_BROADCAST_STATUS_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_ENABLE_NR_STATUS_PRESENT;
					intra_rat_to_neighbor->broadcast_status= intra_rat_from_neighbor->broadcast_status;
				}

				break;
			case X_VENDOR_PRACH_CONFIGURATION_INDEX:
				if(bitmask & SON_PRACH_CONFIGURATION_PRESENT) 
				{
					intra_rat_to_neighbor->bitmask |= SON_PRACH_CONFIGURATION_PRESENT;
					intra_rat_to_neighbor->prach_config.bitmask |= SON_PRACH_CONFIG_INDEX_PRESENT;
					intra_rat_to_neighbor->prach_config.prach_configuration_index= 
						intra_rat_from_neighbor->prach_config.prach_configuration_index;
				}
				break;
			case X_VENDOR_ACCESS_MODE:
				if (rat_type == SON_EUTRAN_CELL)
				{
					if(bitmask & SON_ACCESS_MODE_PRESENT) 
					{
						intra_rat_to_neighbor->bitmask |= SON_ACCESS_MODE_PRESENT;
						intra_rat_to_neighbor->access_mode = intra_rat_from_neighbor->access_mode;
					}
				}
				else
				{
					if(bitmask & SON_UTRAN_ACCESS_MODE_PRESENT) 
					{
						inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_ACCESS_MODE_PRESENT;
						inter_rat_utran_to_neighbor->access_mode= inter_rat_utran_from_neighbor->access_mode;
					}
				}
				break;
                /* coverity_fix 85438 +*/
			case PCPICHScramblingCode:
				if(bitmask & SON_UTRAN_PCI_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_PCI_PRESENT;
					inter_rat_utran_to_neighbor->pci= inter_rat_utran_from_neighbor->pci;
				}
				break;
			case LAC:
				if(bitmask & SON_UTRAN_LAC_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_LAC_PRESENT;
					oam_memcpy(inter_rat_utran_to_neighbor->lac, 
							inter_rat_utran_from_neighbor->lac, 
							sizeof(son_utran_neighbor_info_t));
				}
				break;
			case RAC:
				if(bitmask & SON_UTRAN_RAC_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_RAC_PRESENT;
					inter_rat_utran_to_neighbor->rac= inter_rat_utran_from_neighbor->rac;
				}
				break;
			case X_VENDOR_RSCP:
				if(bitmask & SON_UTRAN_RSCP_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_RSCP_PRESENT;
					inter_rat_utran_to_neighbor->rscp= inter_rat_utran_from_neighbor->rscp;
				}
				break;
			case X_VENDOR_CELL_SPECIFIC_OFFSET:
				if(bitmask & SON_UTRAN_CSO_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_CSO_PRESENT;
					inter_rat_utran_to_neighbor->cell_specific_offset = inter_rat_utran_from_neighbor->cell_specific_offset;
				}
				break;
			case X_VENDOR_PLMN_ID:
				if(bitmask & SON_UTRAN_PLMN_ID_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_PLMN_ID_PRESENT;
					inter_rat_utran_to_neighbor->num_plmn_id = inter_rat_utran_from_neighbor->num_plmn_id;
				}
				break;
			case X_VENDOR_PS_HO_SUPPORTED:
				if(bitmask & SON_UTRAN_PS_HO_SUPPORT_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_PS_HO_SUPPORT_PRESENT;
					inter_rat_utran_to_neighbor->ps_ho_supported= inter_rat_utran_from_neighbor->ps_ho_supported;
				}
				break;
			case X_VENDOR_VOIP_CAPABLE:
				if(bitmask & SON_UTRAN_VOIP_CAPABLE_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_VOIP_CAPABLE_PRESENT;
					inter_rat_utran_to_neighbor->voip_capable= inter_rat_utran_from_neighbor->voip_capable;
				}
				break;
			case UARFCNDL:
				if(bitmask & SON_UTRAN_UARFCN_PRESENT && (OAM_NULL != inter_rat_utran_to_neighbor)) 
				{
					inter_rat_utran_to_neighbor->bitmask |= SON_UTRAN_UARFCN_PRESENT;
					inter_rat_utran_to_neighbor->uarfcn = inter_rat_utran_from_neighbor->uarfcn;
				}
                /* coverity_fix 85438 -*/
				break;
			default:
				break;
		}
	}
	return OAM_SUCCESS;

}
/**************************************************************************
 * FUNCTION NAME: oam_reset_nliu 
 * DESCRIPTION  : This function will reset all the nliu entries to ZERO
 * Inputs       : none 
 * Output       : none
 * RETURNS      : OAM_FAILURE/OAM_SUCCESS
 ***************************************************************************/
void
oam_reset_nliu(UInt8 cell_arr_idx)
{
    UInt16 max_lte_cell_entries = NR_LIST_IN_USE(cell_arr_idx).max_lte_cell_entries;
    UInt16 max_umts_entries = NR_LIST_IN_USE(cell_arr_idx).max_umts_entries;
    UInt16 max_gsm_entries = NR_LIST_IN_USE(cell_arr_idx).max_gsm_entries;

    oam_memset(&NR_LIST_IN_USE(cell_arr_idx), OAM_ZERO, 
            sizeof(NR_LIST_IN_USE(cell_arr_idx)));

    NR_LIST_IN_USE(cell_arr_idx).max_lte_cell_entries = max_lte_cell_entries;
    NR_LIST_IN_USE(cell_arr_idx).max_umts_entries = max_umts_entries;
    NR_LIST_IN_USE(cell_arr_idx).max_gsm_entries = max_gsm_entries;

}


/*SPR 15604 END*/	
#endif

#ifndef OAM_SON_ENABLE

/* SPR-16334 START */
/******************************************************************************
 * Function Name  : oam_update_connected_gu_grp_id_list 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : TRUE/FALSE 
 * Description    : This function is to update neighbors with the pending 
 add/delete delta list to be sent in enodeB Configuration Update needs to be triggered towards X2AP.
 *****************************************************************************/

oam_void_t
oam_update_connected_gu_grp_id_list
(
 oam_x2ap_enb_config_update_req_t *ecu_req,
 UInt8 enb_update_all
)
{
    local_oam_gu_group_id_list_t local_oam_gu_group_id_list = {OAM_ZERO};
    s1ap_oam_mme_info_t oam_s1ap_mme_info = {OAM_ZERO};
    UInt8 loop = OAM_ZERO,
        index = OAM_ZERO;
    SInt8 mme_index = OAM_ZERO;
    oam_bool_et  isDelta = OAM_FALSE;


    OAM_FUN_ENTRY_TRACE();
    if(enb_update_all == OAM_ONE)
    {
    for(index = OAM_ZERO; index < oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb; index++)
    {
        ecu_req->num_peer_enb = oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb;
        oam_memcpy( &(ecu_req->enb_info[index]),
                &(oam_prov_req.oam_l3_req.peer_enb_data.eNB_id[index]),
                sizeof(x2_gb_enb_id_t));
    }
    }
    for (loop = 0; loop < g_oam_connected_mme_info.num_mme; ++loop) {
	    oam_memset(&local_oam_gu_group_id_list, 0,
			    sizeof(local_oam_gu_group_id_list_t));

	    createCurrGrpIdList(&local_oam_gu_group_id_list,
			    /*Coverity 66604 Fix Start*/
			    &oam_s1ap_mme_info.mme_info.served_gummei_info);
	    /*Coverity 66604 Fix End */

	    isDelta = getDelta(&local_oam_gu_group_id_list,
			    /* BCOM Compiltaion Fix */
			    ecu_req,
			    /* BCOM Compiltaion Fix */
			    /*Coverity 66605 Fix Start*/
			    &oam_s1ap_mme_info,
			    /*Coverity 66605 Fix Start*/
			    &mme_index);


	    if (OAM_TRUE == isDelta) {
		    /* BCOM Compiltaion Fix */
		    if(OAM_FAILURE == oam_send_x2ap_enb_config_update_req(ecu_req))
			    /* BCOM Compiltaion Fix */
		    {
			    OAM_LOG(OAM, OAM_ERROR,
					    "Failure in sending X2AP_ENB_CONFIG_UPDATE_REQ");
		    }
		    else
		    {
			    OAM_LOG(OAM, OAM_DETAILED,
					    "Successfully sent X2AP_ENB_CONFIG_UPDATE_REQ");
		    }
	    }

    }


    OAM_FUN_EXIT_TRACE();

}

/******************************************************************************
 * Function Name  : oam_set_x2_ecu_required 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : TRUE/FALSE 
 * Description    : This function is to check if any change is observed in 
 the serving cell/neighbor cell info and if enodeB Configuration Update needs to be triggered towards X2AP.
 *****************************************************************************/

oam_bool_et
oam_check_ecu_send_required()
{
    oam_bool_et oam_ecu_send = OAM_FALSE;
    x2apOam_srvd_cell_info_t *p_serv_cell_info = 
        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
        srvd_cell_arr[OAM_ZERO].served_cell_info;
    /* BCOM Compiltaion Fix */
    oam_rrm_cell_config_req_t *p_rrm_cell_config =
        oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req;
    /* BCOM Compiltaion Fix */

    if(oam_strcmp((void *)&p_serv_cell_info->track_area_code.tac, 
                (void *)&p_rrm_cell_config->epc_info
                .epc_params.general_epc_params.tac) != OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating TAC");
        oam_memset(&p_serv_cell_info->track_area_code.tac,
                OAM_ZERO,
                sizeof(p_serv_cell_info->track_area_code.tac));
        oam_memcpy((void *)&p_serv_cell_info->track_area_code.tac,
                (void *)&p_rrm_cell_config->epc_info.
                epc_params.general_epc_params.tac,
                sizeof(p_rrm_cell_config->epc_info.
                    epc_params.general_epc_params.tac));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->num_antenna_port, 
                (void *)&p_rrm_cell_config->operator_info.
                mimo_mode_params.antenna_ports_count_number)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating AntennaPortsCount");
        oam_memset(&p_serv_cell_info->num_antenna_port,
                OAM_ZERO,
                sizeof(p_serv_cell_info->num_antenna_port));
        oam_memcpy((void *)&p_serv_cell_info->num_antenna_port,
                (void *)&p_rrm_cell_config->operator_info.mimo_mode_params.                                
                antenna_ports_count_number,
                sizeof(p_rrm_cell_config->operator_info.mimo_mode_params.                                   
                    antenna_ports_count_number));
        p_serv_cell_info->bitmask |= NUM_ANTENNA_PORT_BITMASK;

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->pci, 
                (void *)&p_rrm_cell_config->
                ran_info.rf_params.rf_configurations.phy_cell_id)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating PhyCellID");
        oam_memset(&p_serv_cell_info->pci,
                OAM_ZERO,
                sizeof(p_serv_cell_info->pci));
        oam_memcpy((void *)&p_serv_cell_info->pci,
                (void *)&p_rrm_cell_config->ran_info.rf_params.
                rf_configurations.phy_cell_id,
                sizeof(p_rrm_cell_config->ran_info.rf_params.
                    rf_configurations.phy_cell_id));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.dl_trnsmission_bdwidth, 
                (void *)&p_rrm_cell_config->ran_info.rf_params.
                rf_configurations.dl_bandwidth)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating ULBandwidth");
        oam_memset(&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.dl_trnsmission_bdwidth,
                OAM_ZERO,
                sizeof(p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.dl_trnsmission_bdwidth));

        oam_memcpy((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.
                dl_trnsmission_bdwidth,
                (void *)&p_rrm_cell_config->ran_info.rf_params.
                rf_configurations.dl_bandwidth,
                sizeof(p_rrm_cell_config->ran_info.rf_params.
                    rf_configurations.dl_bandwidth));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.
                ul_trnsmission_bdwidth, 
                (void *)&p_rrm_cell_config->ran_info.rf_params.
                rf_configurations.ul_bandwidth)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating ULBandwidth");
        oam_memset(&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.ul_trnsmission_bdwidth,
                OAM_ZERO,
                sizeof(p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.ul_trnsmission_bdwidth));
        oam_memcpy((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.ul_trnsmission_bdwidth,
                (void *)&p_rrm_cell_config->ran_info.rf_params.
                rf_configurations.ul_bandwidth,
                sizeof(p_rrm_cell_config->ran_info.rf_params.
                    rf_configurations.ul_bandwidth));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.dl_earfcn.earfcn, 
                (void *)&p_rrm_cell_config->ran_info.rf_params.rf_configurations.
                dl_earfcn)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating EARFCNDL");
        oam_memset(&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.dl_earfcn.earfcn,
                OAM_ZERO,
                sizeof(p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.dl_earfcn.earfcn));
        oam_memcpy((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.dl_earfcn.earfcn,
                (void *)&p_rrm_cell_config->ran_info.rf_params.
                rf_configurations.dl_earfcn,
                sizeof(p_rrm_cell_config->ran_info.rf_params.
                    rf_configurations.dl_earfcn));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.ul_earfcn.earfcn, 
                (void *)&p_rrm_cell_config->ran_info.rf_params.rf_configurations.
                ul_earfcn)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating EARFCNUL");
        oam_memset(&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.ul_earfcn.earfcn,
                OAM_ZERO,
                sizeof(p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.ul_earfcn.earfcn));
        oam_memcpy((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.fdd_info.ul_earfcn.earfcn,
                (void *)&p_rrm_cell_config->ran_info.rf_params.
                rf_configurations.ul_earfcn,
                sizeof(p_rrm_cell_config->ran_info.rf_params.
                    rf_configurations.ul_earfcn));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.tdd_info.subframe_assn, 
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_tdd_frame_structure.sub_frame_assignment)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating SpecialSubframePatterns");
        oam_memset(&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.tdd_info.subframe_assn,
                OAM_ZERO,
                sizeof(p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.tdd_info.subframe_assn));
        oam_memcpy((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.tdd_info.subframe_assn,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_tdd_frame_structure.sub_frame_assignment,
                sizeof(p_rrm_cell_config->ran_info.physical_layer_params.
                    physical_layer_param_tdd_frame_structure.sub_frame_assignment));

        oam_ecu_send = OAM_TRUE;
    }
    if(oam_strcmp((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.tdd_info.
                special_subframe_info.special_subframe_patterns,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_tdd_frame_structure.special_sub_frame_patterns)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating SpecialSubframePatterns");
        oam_memset(&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.tdd_info.special_subframe_info.
                special_subframe_patterns,
                OAM_ZERO,
                sizeof(p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.tdd_info.special_subframe_info.
                    special_subframe_patterns));
        oam_memcpy((void *)&p_serv_cell_info->choice_eutra_mode.choice_eutra_mode.tdd_info.special_subframe_info.
                special_subframe_patterns,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_tdd_frame_structure.special_sub_frame_patterns,
                sizeof(p_rrm_cell_config->ran_info.physical_layer_params.
                    physical_layer_param_tdd_frame_structure.special_sub_frame_patterns));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->prach_config.root_sequence_index ,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.root_sequence_index)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating ZeroCorrelationZoneConfig");
        oam_memset(&p_serv_cell_info->prach_config.zero_correlation_zone_config,
                OAM_ZERO,
                sizeof(p_serv_cell_info->prach_config.zero_correlation_zone_config));
        oam_memcpy((void *)&p_serv_cell_info->prach_config.zero_correlation_zone_config,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.zero_correlation_zone_config,
                sizeof(p_rrm_cell_config->ran_info.physical_layer_params.
                    physical_layer_param_prach.zero_correlation_zone_config));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->prach_config.zero_correlation_zone_config ,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.zero_correlation_zone_config)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating ZeroCorrelationZoneConfig");
        oam_memset(&p_serv_cell_info->prach_config.zero_correlation_zone_config,
                OAM_ZERO,
                sizeof(p_serv_cell_info->prach_config.zero_correlation_zone_config));
        oam_memcpy((void *)&p_serv_cell_info->prach_config.zero_correlation_zone_config,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.zero_correlation_zone_config,
                sizeof(p_rrm_cell_config->ran_info.physical_layer_params.
                    physical_layer_param_prach.zero_correlation_zone_config));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->prach_config.prach_frequency_offset, 
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.frequency_offset)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating FreqOffset");
        oam_memset(&p_serv_cell_info->prach_config.prach_frequency_offset,
                OAM_ZERO,
                sizeof(p_serv_cell_info->prach_config.prach_frequency_offset));
        oam_memcpy((void *)&p_serv_cell_info->prach_config.prach_frequency_offset,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.frequency_offset,
                sizeof(p_rrm_cell_config->ran_info.physical_layer_params.
                    physical_layer_param_prach.frequency_offset));

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->prach_config.high_speed_flag ,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.high_speed_flag)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating HighSpeedFlag");
        oam_memset(&p_serv_cell_info->prach_config.high_speed_flag,
                OAM_ZERO,
                sizeof(p_serv_cell_info->prach_config.high_speed_flag));
        oam_memcpy((void *)&p_serv_cell_info->prach_config.high_speed_flag,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.high_speed_flag,
                sizeof(p_rrm_cell_config->ran_info.physical_layer_params.
                    physical_layer_param_prach.high_speed_flag));         

        oam_ecu_send = OAM_TRUE;
    }

    if(oam_strcmp((void *)&p_serv_cell_info->prach_config.prach_config_index ,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.configuration_index)!= OAM_ZERO)
    {
        OAM_LOG(OAM,OAM_DETAILED,"Updating ConfigurationIndex");
        oam_memset(&p_serv_cell_info->prach_config.prach_config_index, 
                OAM_ZERO, 
                sizeof(p_serv_cell_info->prach_config.prach_config_index));
        oam_memcpy((void *)&p_serv_cell_info->prach_config.prach_config_index,
                (void *)&p_rrm_cell_config->ran_info.physical_layer_params.
                physical_layer_param_prach.configuration_index,
                sizeof(p_rrm_cell_config->ran_info.physical_layer_params.
                    physical_layer_param_prach.configuration_index));
        p_serv_cell_info->prach_config.bitmask |= X2AP_PRACH_CONFIG_INDEX_PRESENT;

        oam_ecu_send = OAM_TRUE;
    }

    return oam_ecu_send;
}
/* BCOM Compiltaion Fix */
#ifndef OAM_SON_ENABLE

/******************************************************************************
 * Function Name  : oam_set_x2_ecu_required 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        :  
 * Description    : This function is to check condition when enodeB 
 Configuration Update needs to be triggered towards X2AP.
 *****************************************************************************/

oam_void_t
oam_set_x2_ecu_required(Char8 * parmeter_name)
{
	
    if(oam_strstr(parmeter_name,"LTE.RAN.RF")       ||
            oam_strstr(parmeter_name,"EPC.TAC")          ||
            oam_strstr(parmeter_name,"RAN.PHY.TDDFrame") ||
            oam_strstr(parmeter_name,"RAN.PHY.PRACH")    ||
            oam_strstr(parmeter_name,"RAN.NeighborList.LTECell"))
    {
        g_x2_ecu_send_check = OAM_TRUE;
    }
}
#endif
/* BCOM Compiltaion Fix */
/******************************************************************************
 * Function Name  : oam_update_list_per_enb 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        :  
 * Description    : This function is to update one neighbor whose link up is received to be sent in 
eNB config update request towards X2AP
 *****************************************************************************/

oam_void_t
oam_update_list_per_enb
(
    oam_peer_enb_data_t peer_enb_data,
    oam_x2ap_enb_config_update_req_t *ecu_req
)
{
    if(ecu_req->num_peer_enb == OAM_ZERO)
    {
      ecu_req->num_peer_enb = peer_enb_data.num_peer_enb;
    }
    if(peer_enb_data.num_peer_enb >= OAM_ONE)
    {
        oam_memcpy( &(ecu_req->enb_info[OAM_ZERO]), 
                &(peer_enb_data.eNB_id[peer_enb_data.num_peer_enb - OAM_ONE]),
                sizeof(x2_gb_enb_id_t)); 
    }
    ecu_req->bitmask |= X2AP_SERVED_CELLS_TO_MODIFY_LIST_PRESENT;   
}

/******************************************************************************
 * Function Name  : oam_update_list_all_enb 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : SUCCESS/FAILURE 
 * Description    : This function is to update all neighbor with link up info to be sent in 
eNB config update request towards X2AP
 *****************************************************************************/
oam_return_et
oam_update_list_all_enb
(
 oam_x2ap_enb_config_update_req_t *ecu_req
)
{
    UInt8 index = OAM_ZERO;
    oam_return_et retVal = OAM_SUCCESS;

    if(oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb == 0)
    {
        OAM_LOG(OAM,OAM_DETAILED,"No LINK UP received, not sending eNodeB Configuration Update to X2AP");
        retVal = OAM_FAILURE;
    }

    for(index = OAM_ZERO; index < oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb; index++)
    {
        ecu_req->num_peer_enb = oam_prov_req.oam_l3_req.peer_enb_data.num_peer_enb;
        oam_memcpy( &(ecu_req->enb_info[index]), 
                &(oam_prov_req.oam_l3_req.peer_enb_data.eNB_id[index]),
                sizeof(x2_gb_enb_id_t));
    }
    return retVal;
}

/******************************************************************************
 * Function Name  : oam_update_serving_enb_info 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        :  
 * Description    : This function is to update serving cel info to be sent in 
eNB config update request towards X2AP
 *****************************************************************************/

oam_void_t
oam_update_serving_enb_info
(
 oam_x2ap_enb_config_update_req_t *ecu_req
 ) 
{
    UInt8 loop = OAM_ZERO,
          nbr_count = OAM_ZERO,
          temp_bitmask = OAM_ZERO,
          ecu_bitmask = OAM_ZERO,
          cell_list_index = OAM_ZERO;
    	/* SPR 16334 Fix Start */
	 /* SPR 16334 Fix End */
	
    /* BCOM Compiltaion Fix */

    UInt8 cid = OAM_ZERO;


    for(loop=OAM_ZERO; loop<OAM_THREE; loop++)
    {
        cid = oam_extract_cid_from_eutran_cellidentity(OWN_CELL_CGI(loop).cell_identity);
        /* BCOM Compiltaion Fix */
        temp_bitmask = (UInt8)((UInt8)OAM_ONE << loop);
        ecu_bitmask = (ecu_req->bitmask & temp_bitmask);

        switch(ecu_bitmask)
        {
            case X2AP_SERVED_CELLS_TO_ADD_LIST_PRESENT:
                ecu_req->add_served_cell.num_served_cell = OAM_ONE;
                cell_list_index = ecu_req->add_served_cell.num_served_cell - OAM_ONE;

                oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.bcast_plmn_info,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.broadcast_plmn_info,
                        sizeof(x2ap_broadcast_plmn_t));
                                                
                oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.choice_eutra_mode,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.choice_eutra_mode,
                        sizeof(x2ap_choice_eutra_mode_info_t));

                ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.num_antenna_port =
                        oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.num_antenna_port;

                oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.prach_config,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.prach_config,
                        sizeof(x2ap_prach_configuration_info_t));

                oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.mbsfn_subframe_info,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.mbsfn_subframe_info,
                        sizeof(x2ap_mbsfn_subframe_info_t));

                oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.csg_identity,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.csg_identity,
                        sizeof(ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.csg_identity));

                oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.tac,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.track_area_code.tac,
                        sizeof(ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.tac));

                oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.cell_id,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.cell_id,
                        sizeof(ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.cell_id));

                ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.pci =
                        (UInt16)oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.pci;

                ecu_req->add_served_cell.cell_list[cell_list_index].cell_info.bitmask =
                        (UInt16)oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.bitmask;
 
                ecu_req->add_served_cell.cell_list[cell_list_index].nbour_cell_info.num_neighbour_cell = 
                    oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                    srvd_cell_arr[OAM_ZERO].nbour_cell_info.num_neighbour_cell;

                for(nbr_count = OAM_ZERO; nbr_count < ecu_req->add_served_cell.cell_list[cell_list_index].
                        nbour_cell_info.num_neighbour_cell; nbr_count++)
                {
                    oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].nbour_cell_info.neighbour_info_arr[nbr_count].ecgi,
                            &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                            srvd_cell_arr[OAM_ZERO].nbour_cell_info.neighbour_info_arr[nbr_count].ecgi,
                            sizeof(x2ap_ecgi_t));

                    oam_memcpy(&ecu_req->add_served_cell.cell_list[cell_list_index].nbour_cell_info.neighbour_info_arr[nbr_count].earfcn,
                            &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                            srvd_cell_arr[OAM_ZERO].nbour_cell_info.neighbour_info_arr[nbr_count].earfcn,
                            sizeof(x2ap_earfcn_t));

                    ecu_req->add_served_cell.cell_list[cell_list_index].nbour_cell_info.neighbour_info_arr[nbr_count].pci =
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                            srvd_cell_arr[OAM_ZERO].nbour_cell_info.neighbour_info_arr[nbr_count].pci;
                }
                break;

            case X2AP_SERVED_CELLS_TO_MODIFY_LIST_PRESENT:
                ecu_req->mod_served_cell.num_served_cell = OAM_ONE;
                cell_list_index = ecu_req->mod_served_cell.num_served_cell - OAM_ONE;
                ecu_req->mod_served_cell.cell_list[cell_list_index].old_cell_id = cid;
                /* currently, only CID 0 is supported so new_cell_id = old_cell_id=zero*/
                oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.bcast_plmn_info,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.broadcast_plmn_info,
                        sizeof(x2ap_broadcast_plmn_t));

                oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.choice_eutra_mode,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.choice_eutra_mode,
                        sizeof(x2ap_choice_eutra_mode_info_t));

                ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.num_antenna_port =
                        oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.num_antenna_port;

                oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.prach_config,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.prach_config,
                        sizeof(x2ap_prach_configuration_info_t));

                oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.mbsfn_subframe_info,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.mbsfn_subframe_info,
                        sizeof(x2ap_mbsfn_subframe_info_t));

                oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.csg_identity,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.csg_identity,
                        sizeof(ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.csg_identity));

                oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.tac,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.track_area_code.tac,
                        sizeof(ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.tac));

                oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.cell_id,
                        &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.cell_id,
                        sizeof(ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.cell_id));

                ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.pci =
                        (UInt16)oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.pci;

                ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.cell_info.bitmask =
                        (UInt16)oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                        srvd_cell_arr[OAM_ZERO].served_cell_info.bitmask;

                ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.nbour_cell_info.num_neighbour_cell = 
                    oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                    srvd_cell_arr[OAM_ZERO].nbour_cell_info.num_neighbour_cell;

                for(nbr_count = OAM_ZERO; nbr_count < ecu_req->mod_served_cell.cell_list[cell_list_index].
                        served_cell_info.nbour_cell_info.num_neighbour_cell; nbr_count++)
                {
                    oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.
                            nbour_cell_info.neighbour_info_arr[nbr_count].ecgi,
                            &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                            srvd_cell_arr[OAM_ZERO].nbour_cell_info.neighbour_info_arr[nbr_count].ecgi,
                            sizeof(x2ap_ecgi_t));

                    oam_memcpy(&ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.
                            nbour_cell_info.neighbour_info_arr[nbr_count].earfcn,
                            &oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                            srvd_cell_arr[OAM_ZERO].nbour_cell_info.neighbour_info_arr[nbr_count].earfcn,
                            sizeof(x2ap_earfcn_t));

                    ecu_req->mod_served_cell.cell_list[cell_list_index].served_cell_info.nbour_cell_info.
                        neighbour_info_arr[nbr_count].pci =
                            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.x2ap_info.srvd_cell.
                            srvd_cell_arr[OAM_ZERO].nbour_cell_info.neighbour_info_arr[nbr_count].pci;
                }
                break;

            case X2AP_SERVED_CELLS_TO_DELETE_LIST_PRESENT:
                ecu_req->del_served_cell.num_served_cell = OAM_ONE;
                ecu_req->del_served_cell.cell_id_list[ecu_req->del_served_cell.num_served_cell] = cid;

                break;

        }
    }
}

/******************************************************************************
 * Function Name  : oam_send_x2ap_enb_config_update_req_at_link_up 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : SUCCESS/FAILURE 
 * Description    : This function is to send eNB config update request towards X2AP
when link up for a neighbor eNB is received.
 *****************************************************************************/

oam_return_et
oam_send_x2ap_enb_config_update_req_at_link_up
(
    oam_peer_enb_data_t peer_enb_data
)
{
    oam_x2ap_enb_config_update_req_t ecu_req = {0};
    oam_return_et retVal = OAM_SUCCESS;
    UInt16 transaction_id = OAM_ZERO;
    ecu_req.num_peer_enb = OAM_ONE;
    /* update list per enb */
    oam_update_list_per_enb(peer_enb_data, &ecu_req);
    oam_update_serving_enb_info(&ecu_req);
    /* send list per enb */
    if(OAM_SUCCESS == oam_x2apCommon_send_x2ap_enb_config_update_req(
                    &ecu_req,
                    OAM_MODULE_ID,
                    RRC_MODULE_ID,
                    /* BCOM Compiltaion Fix */
                    transaction_id,
                    oam_prov_req.cell_cntxt.curr_cell_cid))
                    /* BCOM Compiltaion Fix */
        {
            OAM_LOG(OAM, OAM_INFO,
                    "eNB config update request triggered at Link UP");
            retVal = OAM_SUCCESS;

            oam_memset(&ecu_req, OAM_ZERO, sizeof(oam_x2ap_enb_config_update_req_t));
            ecu_req.num_peer_enb = OAM_ONE;
            /* update list per enb */
            oam_update_list_per_enb(peer_enb_data, &ecu_req);
            oam_update_serving_enb_info(&ecu_req);
            oam_update_connected_gu_grp_id_list(&ecu_req, OAM_ZERO); /* Zero means updation is not required for all enb, only for those whose link up is received */                   

        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "eNB config update request could not be sent to RRC");
            retVal = OAM_FAILURE;
        }
     return retVal;
}

/******************************************************************************
 * Function Name  : oam_send_x2ap_enb_config_update_req_first 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : SUCCESS/FAILURE 
 * Description    : This function is to send eNB config update request towards X2AP
first time to locally update X2AP about the NLIU and serving cell info.
 *****************************************************************************/
oam_return_et
oam_send_x2ap_enb_config_update_req_first
(
    oam_peer_enb_data_t peer_enb_data
)
{
    oam_x2ap_enb_config_update_req_t ecu_req = {0};
    oam_return_et retVal = OAM_SUCCESS;
    UInt16 transaction_id = OAM_ZERO;
    /* update list per enb */
    oam_update_list_per_enb(peer_enb_data, &ecu_req);
    oam_update_serving_enb_info(&ecu_req);
    /* send list per enb */
    if(OAM_SUCCESS == oam_x2apCommon_send_x2ap_enb_config_update_req(
                    &ecu_req,
                    OAM_MODULE_ID,
                    RRC_MODULE_ID,
                    /* BCOM Compiltaion Fix */
                    transaction_id,
                    oam_prov_req.cell_cntxt.curr_cell_cid))
                    /* BCOM Compiltaion Fix */
        {
            OAM_LOG(OAM, OAM_INFO,
                    "eNB config update request triggered for the first time before enb_add_request");
            retVal = OAM_SUCCESS;
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "eNB config update request could not be sent to RRC");
            retVal = OAM_FAILURE;
        }
     return retVal;
}

/******************************************************************************
 * Function Name  : oam_send_x2ap_enb_config_update_req 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : SUCCESS/FAILURE 
 * Description    : This function is to send eNB config update request towards X2AP
 *****************************************************************************/

oam_return_et
oam_send_x2ap_enb_config_update_req
(
 oam_x2ap_enb_config_update_req_t *ecu_req
)
{
    oam_return_et retVal = OAM_SUCCESS;
    UInt16 transaction_id = oam_get_new_trans_id();

    if(OAM_SUCCESS == oam_x2apCommon_send_x2ap_enb_config_update_req(
                    ecu_req,
                    OAM_MODULE_ID,
                    RRC_MODULE_ID,
                    /* BCOM Compiltaion Fix */
                    transaction_id,
                    oam_prov_req.cell_cntxt.curr_cell_cid))
                    /* BCOM Compiltaion Fix */
        {
            OAM_LOG(OAM, OAM_INFO,
                    "eNB config update request triggered ");
            retVal = OAM_SUCCESS;
        }
        else
        {
            OAM_LOG(OAM, OAM_ERROR,
                    "eNB config update request could not be sent to RRC");
            retVal = OAM_FAILURE;
        }
     return retVal;
}

/******************************************************************************
 * Function Name  : x2_get_idx_from_nbr_enb_add_list 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : index value 
 * Description    : This function provides existing index of storeed enb neighbors 
information
 *****************************************************************************/

SInt16
x2_get_idx_from_nbr_enb_add_list
(
oam_x2ap_add_enb_req_t *x2ap_info ,
x2_enb_comm_info_t  *tnl_addr
)
{
    OAM_FUN_ENTRY_TRACE();
    UInt8 index = OAM_ZERO,
          ip_add_index = OAM_ZERO,
          ipv6_add_index = OAM_ZERO,
          nbr_list_cnt = OAM_ZERO;
    SInt16 found_index = -1;
    nbr_list_cnt = x2ap_info->num_peer_enb;

    for(index= OAM_ZERO; index< nbr_list_cnt; index++)
    {
        for(ip_add_index= OAM_ZERO; 
                ip_add_index < x2ap_info->enb_info[index].num_ip_addr; ip_add_index++ )
        {
            if(!oam_memcmp(x2ap_info->enb_info[index].ip_addr[ip_add_index].ip_addr,
                        tnl_addr->ip_addr,
                        sizeof(x2ap_info->enb_info[index].ip_addr[ip_add_index].ip_addr)))
            {
                found_index= index;
                break;
            }
        }
        if((x2ap_info->enb_info[index].bitmask & X2_ENB_COMM_INFO_IPV6_IP_ADDR_PRESENT) &&
                (x2ap_info->enb_info[index].bitmask & X2_ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT))
        {
            for(ipv6_add_index= OAM_ZERO; 
                    ipv6_add_index < x2ap_info->enb_info[index].num_ipv6_addr; ipv6_add_index++ )
            {
                if(!oam_memcmp(x2ap_info->enb_info[index].ipv6_addr[ipv6_add_index].ipv6_addr,
                            tnl_addr->ipv6_addr,
                            sizeof(x2ap_info->enb_info[index].ipv6_addr[ipv6_add_index].ipv6_addr)))
                {
                    found_index= index;
                    break;
                }
            }
        }
        if(found_index != -1)
        {
            break;
        }
    }

    return found_index;
    OAM_FUN_EXIT_TRACE();
}

/******************************************************************************
 * Function Name  : oam_get_new_enb_idx 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : index value 
 * Description    : This function provides new index to store enb neighbors information
 * received in X2_ADD_ENB_RES.
 *****************************************************************************/
SInt16
oam_get_new_enb_idx()
{
        SInt16 is_neigh_idx_occupied = OAM_ONE,
               idx = OAM_ZERO;
        while(is_neigh_idx_occupied != OAM_ZERO)
        {
            is_neigh_idx_occupied =
                oam_prov_req.oam_l3_req.oam_x2ap_req.bitmap_x2_enb & (OAM_ONE << idx );
            if((idx == OAM_MAX_ENB_POOLS) || (is_neigh_idx_occupied == OAM_ZERO))
            {
              break;
            }
            idx++;
        }
return idx;
}

/******************************************************************************
 * Function Name  : oam_update_enb_list
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : 
 * Description    : This function updates the modified success list of enb neighbors 
 * received in X2_ADD_ENB_RES.
 *****************************************************************************/
oam_void_t
oam_update_enb_list
(
SInt16 index,
SInt16 idx
)
{
    oam_x2ap_add_enb_req_t *local_x2ap_info = 
        &local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req;
    oam_x2ap_add_enb_req_t *x2ap_info = 
        &oam_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req;
    if(local_x2ap_info->enb_info[index].bitmask
            & X2_ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT)
    {
        x2ap_info->enb_info[idx].num_ipv6_addr =
            local_x2ap_info->enb_info[index].num_ipv6_addr;
    }

    if(local_x2ap_info->enb_info[index].bitmask
            & X2_ENB_COMM_INFO_IPV6_IP_ADDR_PRESENT)
    {
        oam_memcpy(&x2ap_info->enb_info[idx].ipv6_addr,
                &local_x2ap_info->enb_info[index].ipv6_addr,
                sizeof(x2_enb_comm_info_t));
    }
    x2ap_info->enb_info[idx].port =
        local_x2ap_info->enb_info[index].port;

    x2ap_info->enb_info[idx].num_ip_addr =
        local_x2ap_info->enb_info[index].num_ip_addr;

    oam_memcpy(&x2ap_info->enb_info[idx].ip_addr,
            &local_x2ap_info->enb_info[index].ip_addr,
            sizeof(x2_enb_comm_info_t));
}

/******************************************************************************
 * Function Name  : oam_process_add_resp_list 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : 
 * Description    : This function processes the success/failure list of enb neighbors 
 * received in X2_ADD_ENB_RES.
 *****************************************************************************/

oam_void_t
oam_process_add_resp_list
(
    x2ap_enb_comm_info_list_t *p_enb_list,
    oam_return_et status,
    UInt16 trans_id_resp,
    UInt16 dst_id
)
{
    UInt8  index = OAM_ZERO;
    UInt8  num_ip_address = OAM_ZERO;
    UInt32  nbr_bit = OAM_ONE;
    SInt16  idx = OAM_MINUS_ONE,
            local_idx = OAM_MINUS_ONE;
    oam_error_code_et error_code = NO_ERROR;    

    UInt32   usr_req_resp = 
                (oam_prov_req.system_status.event_ongoing & OAM_X2AP_ENB_ADD_ONGOING);

    OAM_FUN_ENTRY_TRACE();
    /* BCOM Compiltaion Fix */
    OAM_LOG(OAM, OAM_DETAILED,
          "Value of num_ip_address[%d]", num_ip_address);
    /* BCOM Compiltaion Fix */
    for (; index < p_enb_list->num_peer_enb; index++)
    {
        if(X2_ENB_COMM_INFO_IPV6_NUM_ADDR_PRESENT &
                p_enb_list->enb_comm_info[index].bitmask)
        {
            num_ip_address = p_enb_list->enb_comm_info[index].num_ipv6_addr;
        }
        else
        {
            num_ip_address = p_enb_list->enb_comm_info[index].num_ip_addr;
        }

        idx = x2_get_idx_from_nbr_enb_add_list(
                &oam_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req,
                &p_enb_list->enb_comm_info[index]);

        if(OAM_MINUS_ONE != idx)
        {
            if(OAM_SUCCESS == status)
            {

                local_idx = x2_get_idx_from_nbr_enb_add_list(
                        &local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req,
                        &p_enb_list->enb_comm_info[index]);

                if(-1 == local_idx)
                {
                    OAM_LOG(OAM, OAM_WARNING,
                            "ENB Modification Success received for neighbor not in OAM list");
                    break;
                }
                oam_update_enb_list(local_idx, idx);
                oam_prov_req.oam_l3_req.oam_x2ap_req.bitmap_x2_enb |=
                    (nbr_bit << idx );
                if(usr_req_resp)
                {
                    oam_prov_req.system_status.event_ongoing &= (~OAM_X2AP_ENB_ADD_ONGOING);
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL, OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id,trans_id_resp,OAM_ZERO,
                            OAM_ZERO,&error_code);

                }
                break;

            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "ENB Modification Failed");
                if(usr_req_resp)
                {
                    oam_prov_req.system_status.event_ongoing &= (~OAM_X2AP_ENB_ADD_ONGOING);
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR, (UInt8 *) "X2AP_ADD_ENB_RES Fail", 
                            strlen("X2AP_ADD_ENB_RES Fail")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, trans_id_resp,OAM_ZERO,
                            OAM_ZERO,&error_code);

                }
            }
            break;
        }
        else
        {
            if(OAM_SUCCESS == status)
            {
                OAM_LOG(OAM, OAM_DETAILED,
                        "ENB Addition Success");
                idx = oam_get_new_enb_idx();
                if(idx == OAM_MAX_ENB_POOLS)
                {
                    OAM_LOG(OAM, OAM_WARNING,
                            "ENB Addition Failed as the maximum limit is exhausted");
                    break;

                }
                oam_prov_req.oam_l3_req.oam_x2ap_req.bitmap_x2_enb |=
                    (nbr_bit << idx );
                local_idx = x2_get_idx_from_nbr_enb_add_list(
                        &local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req,
                        &p_enb_list->enb_comm_info[index]);

                if(-1 == local_idx)
                {
                    OAM_LOG(OAM, OAM_WARNING,
                            "ENB Addition Success received for neighbor not in OAM list");
                    break;
                }
                oam_memcpy(&oam_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.enb_info[idx],
                        &local_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.enb_info[local_idx],
                        sizeof(x2_enb_comm_info_t));
                oam_prov_req.oam_l3_req.oam_x2ap_req.oam_x2ap_add_enb_req.num_peer_enb++;
                if(usr_req_resp)
                {
                    oam_prov_req.system_status.event_ongoing &= (~OAM_X2AP_ENB_ADD_ONGOING);
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_SUCCESS,
                            OAM_ZERO, OAM_NULL, OAM_ZERO,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id,trans_id_resp,OAM_ZERO,
                            OAM_ZERO,&error_code);
                }
                break;
            }
            else
            {
                OAM_LOG(OAM, OAM_WARNING,
                        "ENB Addition Failed");
                if(usr_req_resp)
                {
                    oam_prov_req.system_status.event_ongoing &= (~OAM_X2AP_ENB_ADD_ONGOING);
                    oam_construct_n_send_set_resp_to_usr(OAM_RESULT_FAILURE,
                            OAM_ERR_INTERNAL_ERROR, (UInt8 *) "X2AP_ADD_ENB_RES Fail", 
                            strlen("X2AP_ADD_ENB_RES Fail")+ OAM_ONE,
                            OAM_VERSION_ID, OAM_MODULE_ID,
                            dst_id, trans_id_resp,OAM_ZERO,
                            OAM_ZERO,&error_code);
                }
            }
            break;
        }
    }
    OAM_FUN_EXIT_TRACE();

}



/******************************************************************************
 * Function Name  : oam_add_x2ap_enb_req 
 * Inputs         : 
 * Outputs        :
 *                 
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : This function converts the internal list of enb neighbors 
 * added to the structure to be sent to X2AP.
 *****************************************************************************/
oam_return_et
oam_add_x2ap_enb_req
(
oam_x2ap_add_enb_req_t *p_req,
UInt16 transaction_id
)
{
    oam_return_et retVal = OAM_SUCCESS;

    /* send enb_add_req to x2ap */
    if (OAM_FAILURE == oam_x2apCommon_send_x2ap_add_enb_req(
                p_req,
                OAM_MODULE_ID,
                RRC_MODULE_ID,
                /* BCOM Compiltaion Fix */
                transaction_id,
                oam_prov_req.cell_cntxt.curr_cell_cid))
                /* BCOM Compiltaion Fix */
    {
        OAM_LOG(OAM, OAM_ERROR,
                "add eNB request with transaction id = %u could not be "
                "sent to RRC", transaction_id);
        retVal = OAM_FAILURE;
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,
                "add eNB request with transaction id = %u sent "
                "from %u to %u", transaction_id,
                 OAM_MODULE_ID, RRC_MODULE_ID);
        retVal = OAM_SUCCESS;
    }
    OAM_FUN_EXIT_TRACE();
    return retVal;

}

#endif
/* SPR-16334 END */

/* SPR 17376 START */
/******************************************************************************
 *   FUNCTION NAME: validate_qos_grandchild
 *
 *   DESCRIPTION  : This function will check for validation of parameter
 *
 *   Inputs       : parameter value
 *                  loop : loop value for future reference
 *   Output       : NONE
 *
 *   RETURNS      : OAM_SUCCESS/OAM_FAILURE : If the input value is valid returns
 *                                      OAM_SUCCESS else return OAM_FAILURE
 *
 ******************************************************************************/
oam_return_et
validate_qos_grandchild
(
 UInt8 *p_value,
 int loop,
 UInt8* index
 )
{
    OAM_FUN_ENTRY_TRACE();
    UInt16 ret_value = OAM_ZERO;
    UInt8 i = 1;
    xmlChar *p_param_val = OAM_NULL;
    xmlNode *p_xml_node = OAM_NULL;
    xmlNode *p_temp_node = OAM_NULL;
    xmlNode *p_temp_node2 = OAM_NULL;
    oam_bool_et node_found = OAM_FALSE;
    UInt8 inst_id_val = OAM_ZERO;
    xmlChar *p_paramVal  = OAM_NULL;

    /*if xml parent name or tag name is null*/
    if(OAM_NULL == (*g_parameter_map_element[loop].xml_parameter_parent) ||
            OAM_NULL == g_parameter_map_element[loop].tag_name ||
            (index == OAM_NULL))
    {
        OAM_LOG(OAM, OAM_DETAILED, "Parameter path for XML not defined, "
                "validation can't continue.");
        /*Coverity 85420 Fix Start*/
        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;
        /*Coverity 85420 Fix End*/
    }

    xmlNode *temp = *(g_parameter_map_element[loop].xml_parameter_parent);

    while(OAM_NULL != temp) {
        p_xml_node = oam_xml_find_tag(temp->children,
                (xmlChar*)"X_VENDOR_INSTANCE_ID");
        if(p_xml_node != OAM_NULL) {
            p_param_val = xmlNodeGetContent(p_xml_node);
            inst_id_val = oam_atoi((Char8*)p_param_val);

            OAM_LOG(OAM, OAM_INFO, "Object instance id in xml %d",
                    inst_id_val);

            if (inst_id_val == *index) {
                node_found = OAM_TRUE;
                break;
            }
        }
        /* Move to next instance of object */
        temp = (temp)->next;
    }

    if(OAM_FALSE == node_found) {
        temp = *(g_parameter_map_element[loop].xml_parameter_parent);
        for(i = OAM_ONE; i < *index; ++i) {
            if (OAM_NULL == temp) {
                OAM_LOG(OAM, OAM_WARNING, "Node not found in xml");
                OAM_FUN_EXIT_TRACE();
                return OAM_SUCCESS;
            }
            temp = (temp)->next;
        }
    }

    /*finding pointer to the immediate parent node*/
    if( OAM_NULL != temp)
    {
      if(((oam_strcmp(g_parameter_map_element[loop].tag_name,
                "MIN_UL_BITRATE") == OAM_ZERO) ||
            (oam_strcmp(g_parameter_map_element[loop].tag_name,
                        "MIN_DL_BITRATE") == OAM_ZERO)))
      {
        p_temp_node = oam_xml_find_tag(temp->children,
            (xmlChar*)"X_VENDOR_BITRATE");
      }
      else if(((oam_strcmp(g_parameter_map_element[loop].tag_name,
                "ENABLE_ROHC") == OAM_ZERO) ||
            (oam_strcmp(g_parameter_map_element[loop].tag_name,
                        "MAX_CID") == OAM_ZERO)))
      {
        p_temp_node = oam_xml_find_tag(temp->children,
            (xmlChar*)"X_VENDOR_ROHC_PARAMS");

      }
      else if ((oam_strstr(g_parameter_map_element[loop].tag_name,
              "ROHC_PROFILE0X0")))
      {
        /*finding pointer to the grand parent node*/
        p_temp_node2 = oam_xml_find_tag(temp->children,
            (xmlChar*)"X_VENDOR_ROHC_PARAMS");
        if(p_temp_node2 != OAM_NULL)
        {
          p_temp_node = oam_xml_find_tag(p_temp_node2->children,
              (xmlChar*)"ROHC_PROFILES");
        }
      }

    /*finding pointer to the node*/
      if(p_temp_node != OAM_NULL)
      {
        p_xml_node = oam_xml_find_tag(p_temp_node->children,
            (xmlChar*)g_parameter_map_element[loop].tag_name);
      }
    }
    else
    {
        p_xml_node = OAM_NULL;
    }
    if(OAM_NULL == oam_schema_valid_ctxt || OAM_NULL == p_xml_node) {
        OAM_LOG(OAM, OAM_WARNING, "oam_schema_valid_ctxt = NULL or "
                "p_xml_node =  NULL, so is resulting into failure");

        OAM_FUN_EXIT_TRACE();
        /*Coverity 85420 Fix Start*/
        return OAM_FAILURE;
        /*Coverity 85420 Fix End*/
    }
    p_paramVal = xmlNodeGetContent(p_xml_node);
    /* Enabling this code for parameter persistence */
    /*setting content of the node*/
    xmlNodeSetContent(p_xml_node, p_value);

    if (!(g_parameter_map_element[loop].parameter_mode & OAM_IGNORE_VALIDATION))
    {
        /*validating element with xml schema*/
        ret_value = xmlSchemaValidateOneElement(oam_schema_valid_ctxt,
                p_xml_node);
        if ((ret_value != OAM_ZERO) && (p_paramVal != OAM_NULL))
        {
            /* Resetting the xml content when Validation fails */
            xmlNodeSetContent(p_xml_node, p_paramVal);
        }
    }
    /*again seting content of node to pervious value*/
    if (ret_value == OAM_ZERO) {  /*validate successful*/
        OAM_LOG(OAM, OAM_DETAILED,
                "value %s of \"%s\" validated successfully",
                p_value, p_xml_node->name);
        /*Coverity 85420 Fix Start*/
        /*Code Deleted*/
        /*Coverity 85420 Fix End*/
    }
    else if(ret_value > OAM_ZERO) {  /*validate fails*/
        OAM_LOG(OAM, OAM_WARNING, "value %s of \"%s\" failed in validation.",
                p_value, p_xml_node->name);
    }
    else  {   /*validate fails due to internal api error*/
        OAM_LOG(OAM, OAM_WARNING,
                "Validation failed due to intarnal API error");
    }
    /* SPR 13291 START */
    xmlFree(p_paramVal);
    /* SPR 13291 END */

    OAM_FUN_EXIT_TRACE();


    return OAM_SUCCESS;
}
/* SPR 17376 END */

/* SPR_19279_START */
/******************************************************************************
 *   FUNCTION NAME: oam_populate_PLMNList
 *   DESCRIPTION: This function will populate the RRM cell config 
 *                and l3 and son provisioning structure for Primary PLMN ID
 *                after unlocking of Admin State
 *
 *   Inputs       : NONE
 *                  
 *   Output       : NONE
 *              
 *   RETURNS      : NONE 
 *******************************************************************************/
void
oam_populate_PLMNList()
{

    /* Coverity 109467 + - Code Removed */
    UInt8 idx = OAM_ZERO;
    UInt8 primary_plmn_idx = OAM_ZERO;
    UInt8 num_plmn_entries = OAM_ZERO;
    UInt8 swap_idx = OAM_ZERO;
    UInt8 plmn_idx = OAM_ZERO;
    /* Coverity 87053 + */
    rrm_oam_plmn_access_info_t tmp_plmnlist;
    /* Coverity 87053 - */
	UInt8 cid = oam_prov_req.cell_cntxt.curr_cell_cid;
    SInt8 cell_config_idx = oam_get_cell_plmnlist_data_idx(cid);

    /* Coverity 109467 + */
	if(OAM_ERROR_RETURN_VAL == cell_config_idx) {
		OAM_LOG(OAM, OAM_WARNING, "Invalid cell context[cid=%d]",
			           oam_prov_req.cell_cntxt.curr_cell_cid);
		return;
	}

    num_plmn_entries = RRM_PROV_REQ.plmnlist_data[cell_config_idx].curr_plmn_entries;
    /* Coverity 109467 - */
    oam_rrm_cell_plmnlist_data_t *p_cell_plmnlist_data = OAM_NULL;
    oam_rrm_cell_plmnlist_data_t *p_cell_local_plmnlist_data = OAM_NULL;
    p_cell_local_plmnlist_data =
            &LOCAL_RRM_PROV_REQ.plmnlist_data[cell_config_idx];
    p_cell_plmnlist_data =
            &RRM_PROV_REQ.plmnlist_data[cell_config_idx];

	oam_son_nr_add_req_t *p_son_nr_add = OAM_NULL;
	p_son_nr_add = &SON_NR_ADD_REQ(cell_config_idx);


#ifdef OAM_SON_ENABLE
    son_cell_plmn_info_t tmp_son_plmnlist = {"000",OAM_ZERO,"000"};
#endif    
    UInt8 tmp_s1_plmnlist[OAM_THREE] = {OAM_ZERO};

    OAM_FUN_ENTRY_TRACE();

    /* Populate Primary PLMNID (ECGI) */
    for(idx = OAM_ZERO; idx < num_plmn_entries; idx++)
    {
        if(OAM_TRUE == (oam_bool_et)p_cell_plmnlist_data->plmn_entries[idx].enable)
        {
            if(OAM_TRUE == (oam_bool_et)p_cell_plmnlist_data->plmn_entries[idx].is_primary)
            {
                primary_plmn_idx = idx;
                break;
            }
        }
    }
    /* Fill Primary PLMN for RRM  */
    oam_memcpy((void *)&(oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].global_cell_info.
            eutran_global_cell_id.primary_plmn_id),
            (void *)&p_cell_local_plmnlist_data->plmn_entries[primary_plmn_idx].plmn_id,
            sizeof(rrm_oam_cell_plmn_info_t));
    /* Fill Primary PLMN for S1AP and X2AP Prov.  */
    oam_populate_three_byte_plmn_from_mcc_mnc(
            oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
            s1_setup_req_parameters.gb_enb_id.plmn_identity.plmn_id,
            p_cell_local_plmnlist_data->plmn_entries[primary_plmn_idx].plmn_id
            );
    oam_populate_three_byte_plmn_from_mcc_mnc(
            oam_prov_req.oam_l3_req.oam_x2ap_req.x2ap_oam_prov.
            x2ap_info.global_enb_id.plmn_identity.plmn_id,
            p_cell_local_plmnlist_data->plmn_entries[primary_plmn_idx].plmn_id
            );

        /* SPR_20467_FIX_START */
	    bc_plmn_list_t local_bc_plmnList = {OAM_ZERO};
        UInt8 index = 0;
        for(index = OAM_ZERO; index < oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].curr_plmn_entries; index++)
        {
            if((oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].is_valid_bitmap)&(1<< index)&&
               (oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries[index].enable==OAM_ONE))
            {
                 oam_update_plmnlist_from_mcc_mnc(&oam_prov_req.oam_rrm_req.plmnlist_data[cell_config_idx].plmn_entries[index].plmn_id,
                                                                                                        plmn_idx,&(local_bc_plmnList));
                 plmn_idx++;
            }
        }    

        local_bc_plmnList.num_bplmn = plmn_idx;
        oam_memset(oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity,
                   OAM_ZERO,
                   sizeof(oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.plmn_identity));
        oam_memcpy((void *)&oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list,
                   (void *)&local_bc_plmnList,
                    sizeof(oam_prov_req.oam_l3_req.oam_s1ap_req.enb_config_update.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list));
        /* SPR_20467_FIX_END */
#ifdef OAM_SON_ENABLE
    /* Populate Primary PLMN for SON */
    oam_memcpy((void *)&(p_son_nr_add->src_cgi.plmn_id),
            (void *)&p_cell_local_plmnlist_data->plmn_entries[primary_plmn_idx].plmn_id,
            sizeof(rrm_oam_cell_plmn_info_t));

            /*SPR 21702 Start*/
    oam_memcpy((void *)&(oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                serving_cell[OAM_ZERO].src_cgi.plmn_id),
            (void *)&p_cell_local_plmnlist_data->plmn_entries[primary_plmn_idx].plmn_id,
            sizeof(rrm_oam_cell_plmn_info_t));
    /*SPR 21702 End*/

    /* Populate Broadcast PLMNs */
    oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
        epc_info.epc_params.general_epc_params.num_valid_plmn = OAM_ZERO;
            /*SPR 21702 Start*/
    oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
      serving_cell[OAM_ZERO].num_plmn_id = OAM_ZERO;
    /*SPR 21702 End*/
#endif
    oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
        s1_setup_req_parameters.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.
        num_bplmn = OAM_ZERO;
    for(idx = OAM_ZERO; idx < num_plmn_entries; idx++)
    {
        if(OAM_TRUE == (oam_bool_et)p_cell_local_plmnlist_data->plmn_entries[idx].enable)
        {
            if(idx == primary_plmn_idx)
                swap_idx = plmn_idx;

            oam_memcpy((void *)&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
                    epc_info.epc_params.general_epc_params.plmn_list[plmn_idx].plmn_info,
                    (void *)&p_cell_local_plmnlist_data->plmn_entries[idx].plmn_id,
                    sizeof(rrm_oam_cell_plmn_info_t));

#ifdef OAM_SON_ENABLE
            /*SPR 21702 Start*/
            oam_memcpy((void *)&oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                    serving_cell[OAM_ZERO].plmn_id[plmn_idx],
                    (void *)&p_cell_local_plmnlist_data->plmn_entries[idx].plmn_id,
                    sizeof(rrm_oam_cell_plmn_info_t));
            /*SPR 21702 End*/
#endif

            /* Populate Broadcast PLMN for S1Setup Request */
            oam_populate_three_byte_plmn_from_mcc_mnc(
                    oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                    s1_setup_req_parameters.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.
                    plmn_identity[plmn_idx].plmn_id,
                    p_cell_local_plmnlist_data->plmn_entries[idx].plmn_id);

            plmn_idx++;
            oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
                epc_info.epc_params.general_epc_params.num_valid_plmn++;
#ifdef OAM_SON_ENABLE
            /*SPR 21702 Start*/
            oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
              serving_cell[OAM_ZERO].num_plmn_id++;
            /*SPR 21702 End*/
#endif
            oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                s1_setup_req_parameters.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.
                num_bplmn++;
        }
    }

    /* Swap Primary PLMN to the first index in Broadcast PLMN */
    if(swap_idx > OAM_ZERO)
    {
        oam_memcpy(&tmp_plmnlist,
                &(oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
                epc_info.epc_params.
                general_epc_params.plmn_list[0]),
                sizeof(rrm_oam_plmn_access_info_t));

        oam_memcpy(&(oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
                epc_info.epc_params.
                general_epc_params.plmn_list[0].plmn_info),
                &(oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
                epc_info.epc_params.
                general_epc_params.plmn_list[swap_idx].plmn_info),
                sizeof(rrm_oam_cell_plmn_info_t));

        oam_memcpy(&oam_prov_req.oam_rrm_req.oam_rrm_cell_config_req[cell_config_idx].
                epc_info.epc_params.
                general_epc_params.plmn_list[swap_idx],
                &tmp_plmnlist,
                sizeof(rrm_oam_plmn_access_info_t));

        /* Swap Primary PLMN for S1Setup */

        oam_memcpy(&tmp_s1_plmnlist,
                &oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                s1_setup_req_parameters.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.
                plmn_identity[0].plmn_id,
                MAX_PLMN_ID_BYTES);

        oam_memcpy(&oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                s1_setup_req_parameters.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.
                plmn_identity[0].plmn_id,
                &oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                s1_setup_req_parameters.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.
                plmn_identity[swap_idx].plmn_id,
                MAX_PLMN_ID_BYTES);

        oam_memcpy(&oam_prov_req.oam_l3_req.oam_s1ap_req.s1ap_oam_prov.s1apInfo.
                s1_setup_req_parameters.supp_ta_list.supp_tais[OAM_ZERO].bc_plmn_list.
                plmn_identity[swap_idx].plmn_id,
                &tmp_s1_plmnlist,
                MAX_PLMN_ID_BYTES);

#ifdef OAM_SON_ENABLE
        /* Swap Primary PLMN for SON */
        /*SPR 21702 Start*/
        oam_memcpy(&tmp_son_plmnlist,
                &oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                serving_cell[OAM_ZERO].plmn_id[0],
                sizeof(rrm_oam_cell_plmn_info_t));

        oam_memcpy(&oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                serving_cell[OAM_ZERO].plmn_id[0],
                &oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                serving_cell[OAM_ZERO].plmn_id[swap_idx],
                sizeof(rrm_oam_cell_plmn_info_t));

        oam_memcpy(&oam_prov_req.oam_son_req.oam_son_cell_info_ind[cell_config_idx].
                serving_cell[OAM_ZERO].plmn_id[swap_idx],
                &tmp_son_plmnlist,
                sizeof(rrm_oam_cell_plmn_info_t));
        /*SPR 21702 End*/
#endif
    }
    OAM_FUN_EXIT_TRACE();

}

/******************************************************************************
 *   FUNCTION NAME: oam_populate_three_byte_plmn_from_mcc_mnc
 *   DESCRIPTION: This function convert PLMNID in three byte 
 *                from mcc/mnc 
 *
 *   Inputs       : dest_plmn,src_plmn 
 *                  
 *   Output       : Converted PLMN (dest_plmn)
 *              
 *   RETURNS      : NONE 
 *******************************************************************************/
void
oam_populate_three_byte_plmn_from_mcc_mnc
(
 UInt8 *dest_plmn,
 rrm_oam_cell_plmn_info_t src_plmn
)
{

    OAM_FUN_ENTRY_TRACE();

    char  temp_plmn[OAM_SEVEN];
    UInt8 offset = OAM_ZERO;
    UInt8 loop_index = OAM_ZERO;
    char final[MAX_PLMN_ID_BYTES];

    oam_memset(dest_plmn,OAM_ZERO,MAX_PLMN_ID_BYTES);

    if(OAM_TWO == src_plmn.num_mnc_digit)
    {
        temp_plmn[OAM_ZERO] = src_plmn.mcc[OAM_ONE];
        temp_plmn[OAM_ONE] = src_plmn.mcc[OAM_ZERO];
        temp_plmn[OAM_TWO] = 0x0F;
        temp_plmn[OAM_THREE] = src_plmn.mcc[OAM_TWO];
        temp_plmn[OAM_FOUR] = src_plmn.mnc[OAM_ONE];
        temp_plmn[OAM_FIVE] = src_plmn.mnc[OAM_ZERO];
        temp_plmn[OAM_SIX] = '\0';
    }
    else
    {
        oam_memcpy(&temp_plmn[OAM_ZERO],&src_plmn.mcc[OAM_ONE], OAM_ONE);
        oam_memcpy(&temp_plmn[OAM_ONE],&src_plmn.mcc[OAM_ZERO], OAM_ONE);
        oam_memcpy(&temp_plmn[OAM_TWO],&src_plmn.mnc[OAM_ZERO], OAM_ONE);
        oam_memcpy(&temp_plmn[OAM_THREE],&src_plmn.mcc[OAM_TWO], OAM_ONE);
        oam_memcpy(&temp_plmn[OAM_FOUR],&src_plmn.mnc[OAM_TWO], OAM_ONE);
        oam_memcpy(&temp_plmn[OAM_FIVE],&src_plmn.mnc[OAM_ONE], OAM_ONE);
        temp_plmn[OAM_SIX] = '\0';
    
    }

    for(offset = OAM_ZERO; offset < MAX_PLMN_ID_BYTES; ++offset) {
        snprintf(final, sizeof(final), "%c%c", temp_plmn[loop_index],temp_plmn[loop_index + 1]);
        dest_plmn[offset] |= final[OAM_ZERO];
        dest_plmn[offset] <<= OAM_FOUR;
        dest_plmn[offset] |= final[OAM_ONE];
        loop_index += 2;
    }

    OAM_FUN_EXIT_TRACE();
}
/* SPR_19279_END */

/* SPR 13501 FIX START */
/****************************************************************************
 * FUNCTION NAME: oam_validate_dyn_icic_num_ce_region
 *
 * DESCRIPTION:   This function will check for validation of parameter
 * Inputs     :   num_ce_regioin: parameter value
 *                loop : loop value for future reference
 * Output    : NONE
 *
 * RETURNS: OAM_SUCCESS/OAM_FAILURE
 ***************************************************************************/
oam_return_et
oam_validate_dyn_icic_num_ce_region(UInt8 *num_ce_regioin,
                                    SInt32 loop,
                                    UInt8* get_value)
{
    /* SPR 20904 Fix +- */
    /* Parameters loop and *get_value are NULL */
    OAM_FUN_ENTRY_TRACE();
    oam_return_et retVal = OAM_SUCCESS;

    if (!num_ce_regioin ||
        (oam_atoi((Char8*)num_ce_regioin) < OAM_MIN_NUM_CE_REGION) ||
        (oam_atoi((Char8*)num_ce_regioin) > OAM_MAX_NUM_CE_REGION)) {
        retVal = OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/****************************************************************************
 * FUNCTION NAME: oam_validate_dyn_icic_num_cc_region
 *
 * DESCRIPTION:   This function will check for validation of parameter
 * Inputs     :   num_cc_regioin: parameter value
 *                loop : loop value for future reference
 * Output    : NONE
 *
 * RETURNS: OAM_SUCCESS/OAM_FAILURE
 ***************************************************************************/
oam_return_et
oam_validate_dyn_icic_num_cc_region(UInt8 *num_cc_regioin,
                                    SInt32 loop,
                                    UInt8* get_value)
{
    /* SPR 20904 Fix +- */
    /* Parameters loop and *get_value are NULL */
    OAM_FUN_ENTRY_TRACE();
    oam_return_et retVal = OAM_SUCCESS;

    if (!num_cc_regioin ||
        (oam_atoi((Char8*)num_cc_regioin) < OAM_MIN_NUM_CC_REGION) ||
        (oam_atoi((Char8*)num_cc_regioin) > OAM_MAX_NUM_CC_REGION)) {
        retVal = OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/****************************************************************************
 * FUNCTION NAME: oam_validate_dyn_icic_start_rb
 *
 * DESCRIPTION:   This function will check for validation of parameter
 * Inputs     :   num_cc_regioin: parameter value
 *                loop : loop value for future reference
 * Output    : NONE
 *
 * RETURNS: OAM_SUCCESS/OAM_FAILURE
 ***************************************************************************/
oam_return_et
oam_validate_dyn_icic_start_rb(UInt8 *start_rb,
                               SInt32 loop,
                               UInt8* get_value)
{
    /* SPR 20904 Fix +- */
    /* Parameters loop and *get_value are NULL */
    OAM_FUN_ENTRY_TRACE();
    oam_return_et retVal = OAM_SUCCESS;

    if (!start_rb || (oam_atoi((Char8*)start_rb) < OAM_MIN_START_RB) ||
        (oam_atoi((Char8*)start_rb) > OAM_MAX_START_RB)) {
        retVal = OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}

/****************************************************************************
 * FUNCTION NAME: oam_validate_dyn_icic_end_rb
 *
 * DESCRIPTION:   This function will check for validation of parameter
 * Inputs     :   num_cc_regioin: parameter value
 *                loop : loop value for future reference
 * Output    : NONE
 *
 * RETURNS: OAM_SUCCESS/OAM_FAILURE
 ***************************************************************************/
oam_return_et
oam_validate_dyn_icic_end_rb(UInt8 *end_rb,
                             SInt32 loop,
                             UInt8* get_value)
{
    /* SPR 20904 Fix +- */
    /* Parameters loop and *get_value are NULL */
    OAM_FUN_ENTRY_TRACE();
    oam_return_et retVal = OAM_SUCCESS;

    if (!end_rb ||
        (oam_atoi((Char8*)end_rb) < OAM_MIN_NUM_RBS) ||
        (oam_atoi((Char8*)end_rb) > OAM_MAX_NUM_RBS)) {
        retVal = OAM_FAILURE;
    }

    OAM_FUN_EXIT_TRACE();
    return retVal;
}
/* SPR 13501 FIX END */

/*SPR 17008 Fixed Start*/
oam_return_et
validate_download_file_name(UInt8 *file_name)
{

	SInt32 lclTemp_value;
	UInt8 temp_file_name[INTEGRITY_FILE_NAME_SZ]= {OAM_ZERO};
	char* oui_value = OAM_NULL;
	char* productClass_value=OAM_NULL;
	char* hw_value=OAM_NULL;
	char* sw_value=OAM_NULL;

	oam_strcpy((char *)temp_file_name,(char *)file_name);


	oui_value=  strtok((char *)temp_file_name, "_");
    /*CID 100033 + */
    
    if(oui_value == NULL){
    
	    return OAM_FAILURE;
 
        }
    /*CID 100033 - */
 
	lclTemp_value = strlen (oui_value);
	if (lclTemp_value == OAM_SIX ){

		OAM_LOG (OAM, OAM_DETAILED, "ManufacturerOUI  Successfully Validated  %s",oui_value);
	}
	else
	{

		OAM_LOG (OAM, OAM_WARNING, "Error in validation ManufacturerOUI version info");
		OAM_FUN_EXIT_TRACE ();
		return OAM_FAILURE;
	}

	productClass_value=   strtok(OAM_NULL, "_");
	lclTemp_value = strlen (productClass_value);
	if (lclTemp_value >=OAM_ONE  && lclTemp_value <= OAM_SIXTY_FOUR){

		OAM_LOG (OAM, OAM_DETAILED, "validation ProductClass version info %s",productClass_value);
	}
	else{

		OAM_LOG (OAM, OAM_WARNING, "Error in validation ProductClass version info");
		OAM_FUN_EXIT_TRACE ();
		return OAM_FAILURE;

	}

	hw_value =  strtok(OAM_NULL, "_");
	lclTemp_value = strlen (hw_value);
	if (lclTemp_value >= OAM_ONE && lclTemp_value <= OAM_SIXTY_FOUR){

		OAM_LOG (OAM, OAM_DETAILED, "validation HardwareVersion version info %s", hw_value);
	}
	else{
		OAM_LOG (OAM, OAM_WARNING, "Error in validation HardwareVersion version info");
		OAM_FUN_EXIT_TRACE ();
		return OAM_FAILURE;

	}
	sw_value =  strtok(OAM_NULL, ".");
	lclTemp_value = strlen(sw_value);

	if (lclTemp_value >= OAM_ONE && lclTemp_value <= OAM_SIXTY_FOUR){

		OAM_LOG (OAM, OAM_DETAILED, "validation SoftwareVersion version info %s", sw_value);
	}
	else{

		OAM_LOG (OAM, OAM_WARNING, "Error in validation SoftwareVersion version info");
		OAM_FUN_EXIT_TRACE ();
		return OAM_FAILURE;

	}
	OAM_FUN_EXIT_TRACE ();
	return OAM_SUCCESS;

}
/*SPR 17008 Fixed End*/

/* SPR 17596 fixed start */
/****************************************************************************
 * Function Name : oam_construct_n_send_get_rpc_resp_to_usr 
 * Description   : This function prepares a OAM_GET_RPC_METHOD_RESP and
 *                 sends it to user interface.
 * Inputs        : 1. Pointer to location for reading for parsing
 *                 2. Length of message left to be read
 *                 3. Pointer to message buffer 
 * Outputs       : 1. Error Code
 * Returns       : OAM_SUCCESS/OAM_FAILURE
 ****************************************************************************/
void oam_construct_n_send_get_rpc_resp_to_usr(UInt8 resp_status,
        UInt32 resp_code,
        UInt8 oam_version, UInt16 src_id,
        UInt16 dst_id, UInt16 req_trans_id,
        char *str,
        oam_error_code_et *p_err_code)
{


    OAM_LOG(OAM, OAM_DETAILED, "In %s function ....",__FUNCTION__);
    OAM_FUN_ENTRY_TRACE();
    UInt8 *p_msg = OAM_NULL;
    UInt8 *p_buf = OAM_NULL;
    UInt8 str_len = OAM_ZERO;
    str_len = oam_strlen((const char *)str);

    UInt16 msg_len = (OAM_CSPL_HDR_SIZE + OAM_MGMT_INTF_HEADER_SIZE) + (OAM_EIGHT + str_len);
    p_msg = oam_msg_mem_get(msg_len);
    if(PNULL == p_msg) {
        OAM_LOG(OAM,OAM_ERROR, "Memory allocation to p_msg failed");
        *p_err_code = OAM_MALLOC_FAIL;
        OAM_FUN_EXIT_TRACE();
        return;
    }
    p_buf = p_msg;
    /* There will be exactly 8 + str_len Bytes in the response message payload */
    /* The structure of the payload will be as follows:
     * |   1 BYTE   |  2 BYTES   | 4 BYTES  | 1 BYTE   | str_len BYTES |
     * +---------------------------------------------------------------------+
     * |    Status  |            | Reserved | Length of| Error String / Info |
     * | 0=SUCCESS  | Error Code | (all 0s) |   error  |                     |
     * | 1=FAILURE  |            |          | string(0)|                     |
     * +------------+------------+----------+----------+---------------------+*/
 /* encode CSPL header in message*/
    oam_construct_api_header(p_msg, oam_version,
            src_id, dst_id, OAM_GET_RPC_METHOD_RESP, msg_len);
    p_msg += OAM_CSPL_HDR_SIZE;

    /* encode API header in message*/
    oam_construct_mgmt_api_hdr(p_msg, req_trans_id, src_id, dst_id,
            OAM_GET_RPC_METHOD_RESP, msg_len - OAM_CSPL_HDR_SIZE,
            OAM_ZERO);
    p_msg += OAM_MGMT_INTF_HEADER_SIZE;

    encode_get_params_resp_ctrl_blk((char *)p_msg , resp_status,
            resp_code, OAM_ZERO, OAM_ZERO, str_len,
            str);
    /* CID 107832 Fix Start */
    if(OAM_FAILURE == oam_send_message(p_buf, dst_id, p_err_code))
    {
        OAM_LOG(OAM,OAM_DETAILED,"Failed to send message : %d",*p_err_code);
    }    
    /* CID 107832 Fix Start */
    if(*p_err_code != NO_ERROR) {

        OAM_LOG(OAM, OAM_ERROR,
                "Error: Sendto failed with err_code %d", *p_err_code);
    }
    /* Coverity CID 107832 Fix End */

    OAM_FUN_EXIT_TRACE();
}



/******************************************************************************
 * Function Name  : oam_get_rpc_api_handler
 * Inputs         : p_api_buf
 *                : msg_len
 *                : src id
 *                : error_code
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 * Description    : this function handles the GET RPC command 
 *******************************************************************************/
oam_return_et
oam_get_rpc_api_handler
(
    void *p_api_buf,
    UInt16 msg_len,
    oam_error_code_et *p_error_code
)
{
    UInt16 trans_id = OAM_ZERO;
    if(OAM_NULL == p_api_buf)
    {
        OAM_LOG(OAM, OAM_WARNING, "NULL pointer error, returning...");
        *p_error_code = OAM_INTERNAL_ERROR;
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }
    UInt16 dst_module_id = OAM_ZERO;
    trans_id = get_word_from_header((UInt8 *)p_api_buf);

    OAM_LOG(OAM, OAM_DETAILED ,"....  trans id is + %d" , trans_id);
    /*src id of incoming buffer is going to be the destination id of outgoing msg*/
    dst_module_id = get_word_from_header((UInt8 *)p_api_buf +OAM_TWO);
    OAM_LOG(OAM, OAM_INFO, "GET_RPC Message received from dst_module-id: %d",
            dst_module_id);

    UInt16 msg_length = OAM_ZERO;
    msg_length = OAM_CSPL_HDR_SIZE + OAM_MGMT_INTF_HEADER_SIZE;
    UInt8 *p_msg= OAM_NULL;
    if(OAM_FAILURE == oam_mem_alloc(msg_length, (void*)&p_msg, p_error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to p_msg failed"
                " with Error Code:%d",
                *p_error_code);
         return OAM_FAILURE;
    }

     oam_memset(p_msg, OAM_ZERO, msg_length);
     p_api_buf = p_msg;

     oam_construct_api_header((UInt8 *)p_api_buf, OAM_VERSION_ID,
            OAM_MODULE_ID, dst_module_id,
            OAM_GET_RPC_METHOD_RESP,
            msg_len);
     p_api_buf += OAM_CSPL_HDR_SIZE;

      oam_construct_mgmt_api_hdr((UInt8 *)p_api_buf,
            trans_id,
            OAM_MODULE_ID,
            dst_module_id,
            OAM_GET_RPC_METHOD_RESP,
            msg_len - OAM_CSPL_HDR_SIZE,
            OAM_ZERO);
      p_api_buf += OAM_MGMT_INTF_HEADER_SIZE;

        oam_tr069_compose_get_rpc_message(p_api_buf);
        if(OAM_FAILURE == oam_send_message(p_msg, TR069_MODULE_ID, p_error_code))
        {
            /* CID 100770 + */
		/*Coverity_107804 Fix start */
		/* Code Removed */
		/*Coverity_107804 Fix End */
            /* CID 100770  - */

            OAM_LOG(OAM,OAM_DETAILED,"Failed to send message : %d",*p_error_code);
            return OAM_FAILURE;
        }
        /* coverity_100770 fix removed */
        /* CID 100770  - */

     return OAM_SUCCESS;
}

/******************************************************************************
 * Function Name  : oam_tr069_compose_get_rpc_message
 * Inputs         : p_buffer
 *                : error_code
 * Outputs        : none
 * Returns        : none
 * Description    : this function create the GET RPC response message that is 
 *                   to be sent to TR069  
 *******************************************************************************/

void
oam_tr069_compose_get_rpc_message
(
 UInt8 *p_buffer
 )
{
    Char8 string[256]={OAM_ZERO};
    UInt16 param_len =0;
    UInt32 curr_pos = OAM_ZERO;
    char *list[MAX_NUM_OF_RPC] = {
        "GetRPCMethods",
        "SetParameterValues",
        "GetParameterValues",
        "GetParameterNames",
        "SetParameterAttributes",
        "FactoryReset",
        "GetParameterAttributes",
        "DeleteObject",
        "ScheduleInform",
        "AddObject",
        "Download",
        "Reboot",
        "Upload",
    };

        U8 i =0;
    OAM_LOG (OAM , OAM_DETAILED ,"sp before = %d" ,curr_pos);
    *(p_buffer + curr_pos++) = (MAX_NUM_OF_RPC >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
    *(p_buffer + curr_pos++)  =   MAX_NUM_OF_RPC & OAM_ALL_8_BIT_SET;
    OAM_LOG (OAM , OAM_DETAILED ,"sp after = %d" ,curr_pos);

     OAM_LOG (OAM , OAM_DETAILED ,"spspsp num of param  = %d" ,*(p_buffer + curr_pos));
  /*packing reserved field*/
    *(p_buffer + curr_pos++) = OAM_ZERO ;
    *(p_buffer + curr_pos++) = OAM_ZERO;


    for(i =0 ; i< MAX_NUM_OF_RPC ;i++)
    {
        memset(string ,0 ,256);
        oam_strcpy((char *)string , list[i]);
        param_len = strlen((char*)string);

        OAM_LOG (OAM , OAM_DETAILED ," string length = %d", param_len);

        OAM_LOG (OAM , OAM_DETAILED ,"curr position = %d",curr_pos-1);
        OAM_LOG (OAM , OAM_DETAILED ,"sp string length is  = %d" ,*(p_buffer+(curr_pos-1)));
        string[param_len] = '\0';

         param_len += OAM_ONE;
        *(p_buffer + curr_pos++) = (param_len >> OAM_EIGHT) & OAM_ALL_8_BIT_SET;
        *(p_buffer + curr_pos++) = param_len & OAM_ALL_8_BIT_SET;

        OAM_LOG(OAM , OAM_DETAILED , "..after encode length is = %d" , *(p_buffer+(curr_pos-1)));
        OAM_LOG(OAM ,OAM_DETAILED ,"*** param_len = %d", param_len);
        if(param_len != OAM_ZERO)
        oam_memcpy(p_buffer+curr_pos,string, param_len);
        curr_pos +=param_len;
        
        //curr_pos +=1;
        param_len = OAM_ZERO;
    }
    OAM_LOG(OAM, OAM_INFO, "... Exiting in %s function ",__FUNCTION__);
    return;
}
/* SPR 17596 fixed end */

/* SPR 17380 START */

/* SPR 17380 END */
/* SPR 18930  FIX START */
oam_return_et
oam_add_nbr_to_nl_and_send_delete_req_to_son
(
 UInt8 * p_api_buf,
 SInt8  cell_arr_idx1
 )
{
    OAM_FUN_ENTRY_TRACE();

    oam_son_nr_delete_req_t *oam_son_nr_delete_req = OAM_NULL;
    oam_error_code_et       p_error_code = NO_ERROR;
    UInt32 nr_bit = OAM_ONE;
    oam_return_et retVal = OAM_FAILURE;
    UInt16 trans_id = get_word_from_header(p_api_buf);
    UInt8 query_idx = LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx1).nr_list_query_idx;

    if(OAM_FAILURE ==
            oam_mem_alloc(sizeof(oam_son_nr_delete_req_t),
                (void**)&oam_son_nr_delete_req,
                &p_error_code))
    {
        OAM_LOG(OAM, OAM_ERROR,
                "Memory allocation to oam_son_nr_delete_req failed"
                " with Error Code:%d",
                p_error_code);
        OAM_FUN_EXIT_TRACE();
        return OAM_FAILURE;
    }

    oam_memset(oam_son_nr_delete_req, OAM_ZERO,
            sizeof(oam_son_nr_delete_req_t));

    oam_son_nr_delete_req->src_cgi = 
         LOCAL_SON_NEIGHBORLIST_INFO(cell_arr_idx1).oam_son_nr_add_req.src_cgi ;
    oam_son_nr_delete_req->trgt_cgi_list_size = OAM_ONE;

    /* adding this neighbour info to NL as NR ADD is requested from user */
    if(LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list_size) {

        oam_memcpy(
                &SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[query_idx],
                &LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[query_idx],
                sizeof(son_intra_rat_neighbor_info_t));

        SON_NEIGHBORLIST_INFO(cell_arr_idx1).intra_rat_nr_entry_bitmap |=
            (nr_bit << query_idx);

        /* Creating message for NR Delete */
        TRGT_CGI_LIST.bitmask = OAM_SON_BIT_1;
        TRGT_CGI_LIST.intra_rat_global_cell_id =
            LOCAL_SON_NR_LIST(cell_arr_idx1).intra_rat_nr_list[query_idx].
            nbr_cgi;

        SON_PROV_REQ.nr_action  |= OAM_NLIU_ACTION_DELETE_EUTRAN;

    }
    else if(LOCAL_SON_NR_LIST(cell_arr_idx1).inter_rat_nr_list_size)
    {
        oam_memcpy(&SON_NR_LIST(cell_arr_idx1).inter_rat_nr_list[query_idx].utran_neighbor,
                &LOCAL_SON_NR_LIST(cell_arr_idx1).inter_rat_nr_list[query_idx].utran_neighbor,
                sizeof(son_utran_neighbor_info_t));

        SON_NEIGHBORLIST_INFO(cell_arr_idx1).inter_rat_umts_entry_bitmap |=
            (nr_bit << query_idx);

        TRGT_CGI_LIST.bitmask = OAM_SON_BIT_2;

        TRGT_CGI_LIST.inter_rat_global_cell_id.bitmask |=
            SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT;

        TRGT_CGI_LIST.inter_rat_global_cell_id.
            utran_geran_global_cell_id.rat_type = SON_UTRAN_CELL;

        TRGT_CGI_LIST.inter_rat_global_cell_id.
            utran_geran_global_cell_id.plmn_id =
            LOCAL_SON_NR_LIST(cell_arr_idx1).inter_rat_nr_list[query_idx].
            utran_neighbor.nbr_cgi.plmn_id;

        oam_memcpy(TRGT_CGI_LIST.inter_rat_global_cell_id.
                utran_geran_global_cell_id.cell_identity,
                LOCAL_SON_NR_LIST(cell_arr_idx1).
                inter_rat_nr_list[query_idx].
                utran_neighbor.nbr_cgi.cell_identity,
                SON_CELL_ID_OCTET_SIZE);

        SON_PROV_REQ.nr_action  |= OAM_NLIU_ACTION_DELETE_UTRAN;
    }
    retVal = oam_son_send_son_oam_nr_delete_req(oam_son_nr_delete_req, 
            OAM_MODULE_ID,
            SON_MODULE_ID,
            trans_id,
            oam_prov_req.cell_cntxt.curr_cell_cid);
    /* Resetting The Bitmask As Sending NR Delete To SON */
    oam_prov_req.system_status.event_ongoing &=
        ~OAM_SON_ADD_NR_ONGOING;

    if(OAM_FAILURE == retVal) {
        OAM_LOG(OAM, OAM_ERROR,
                "Error in sending neighbor delete request"
                " with error code :%d", p_error_code);

        SON_PROV_REQ.nr_action  &= ~OAM_NLIU_ACTION_DELETE_UTRAN;
        SON_PROV_REQ.nr_action  &= ~OAM_NLIU_ACTION_DELETE_EUTRAN;

        OAM_FUN_EXIT_TRACE();
        /*CID 88145 fix start*/
        oam_mem_free(oam_son_nr_delete_req,&p_error_code);
        /*CID 88145 fix end*/
        return OAM_FAILURE;
    }
    else {
        OAM_LOG(OAM, OAM_DETAILED,
                "sent neighbor delete request to son");
			/* SPR_19838 : Coverity_11066 Fix Start */
            oam_mem_free(oam_son_nr_delete_req,&p_error_code);
			/* SPR_19838 : Coverity_11066 Fix Stop */
        OAM_FUN_EXIT_TRACE();
        return OAM_SUCCESS;
    }
}
/******************************************************************************
 *   FUNCTION NAME: oam_prepare_nr_list_for_nliu
 *
 *   DESCRIPTION  : This function prepares the add and delete list based on 
 *                  response received from SON
 *
 *   Inputs       : p_layer_resp -  respose from SON
 *                  p_nr_list - temp list of NR saved at OAM
 *                  p_nr_list_added - poiner to added neighbor list on SON
 *                  p_nr_list_deleted - pointer to neighbors not added at SON
 *
 *   Output       : p_nr_list_added,p_nr_list_deleted
 *
 *   RETURNS      : Void  
 ******************************************************************************/

void oam_prepare_nr_list_for_nliu
(
 oam_son_nr_add_resp_t * p_layer_resp,
 oam_son_nr_add_req_t  * p_nr_list,
 oam_son_nr_add_req_t  * p_nr_list_added,
 oam_son_nr_add_req_t  * p_nr_list_deleted,
 SInt8 nliu_cell_config_idx
 )
{
    OAM_FUN_ENTRY_TRACE();

    oam_son_anr_updated_nrt_info_t *p_son_nrt_info = OAM_NULL;
    UInt8 index = OAM_ZERO,index_1 = OAM_ZERO;
    /* SPR 21903 FIXED START */
    /*SPR 21672 FIXED START*/
    UInt16 num_intra_neigh = OAM_ZERO,num_inter_neigh = OAM_ZERO;
    /*SPR 21672 FIXED END*/
    /* SPR 21903 FIXED END */

    oam_bool_et cgi_found = OAM_FALSE;
    SInt8 neigh_idx = NOT_FOUND;
    p_son_nrt_info = &NRT_INFO(nliu_cell_config_idx);

    /* preparing NR delete list */
    if(p_layer_resp->trgt_cell_status_list_size)
    {
        oam_memcpy(&p_nr_list_deleted->src_cgi,
                &p_nr_list->src_cgi,
                sizeof(son_intra_rat_global_cell_id_t));  

        for(index = OAM_ZERO; index <
                p_layer_resp->trgt_cell_status_list_size; index++)
        {
            /* SPR 19343 START */
            if(!(p_layer_resp->trgt_cell_status_list[index].error_code == SON_ERR_ANR_DUPLICATE_NR ))
            {
                /* SPR 19343 END */
            if(p_layer_resp->trgt_cell_status_list[index].cgi.bitmask &
                    SON_INTRA_RAT_GLOBAL_CELL_ID_PRESENT)
            {
                oam_memcpy(&p_nr_list_deleted->nr_list.
                        intra_rat_nr_list[num_intra_neigh++].nbr_cgi,
                        &p_layer_resp->trgt_cell_status_list[index].
                        cgi.intra_rat_global_cell_id,
                        sizeof(son_intra_rat_global_cell_id_t));

            }
            else if ((p_layer_resp->trgt_cell_status_list[index].cgi.bitmask &
                        SON_INTER_RAT_GLOBAL_CELL_ID_PRESENT)&& 
                    (p_layer_resp->trgt_cell_status_list[index].cgi.
                     inter_rat_global_cell_id.bitmask &
                     SON_UTRAN_GERAN_GLOBAL_CELL_ID_PRESENT))
            {
                if(p_layer_resp->trgt_cell_status_list[index].cgi.
                        inter_rat_global_cell_id.utran_geran_global_cell_id.rat_type == 
                        SON_UTRAN_CELL)
                {
                    oam_memcpy(&p_nr_list_deleted->nr_list.
                            inter_rat_nr_list[num_inter_neigh].utran_neighbor.nbr_cgi,
                            &p_layer_resp->trgt_cell_status_list[index].cgi.
                            inter_rat_global_cell_id.utran_geran_global_cell_id,
                            sizeof(son_utran_geran_global_cell_id_t));

                    p_nr_list_deleted->nr_list.inter_rat_nr_list[num_inter_neigh++].
                        bitmask |= SON_INTER_UTRAN_NEIGHBOR;

                }
                else if(p_layer_resp->trgt_cell_status_list[index].cgi.
                        inter_rat_global_cell_id.utran_geran_global_cell_id.rat_type == 
                        SON_GERAN_CELL)
                {
                    oam_memcpy(&p_nr_list_deleted->nr_list.
                            inter_rat_nr_list[num_inter_neigh].geran_neighbor.nbr_cgi,
                            &p_layer_resp->trgt_cell_status_list[index].cgi.
                            inter_rat_global_cell_id.utran_geran_global_cell_id,
                            sizeof (son_utran_geran_global_cell_id_t));

                        p_nr_list_deleted->nr_list.inter_rat_nr_list[num_inter_neigh++].
                        bitmask |= SON_INTER_GERAN_NEIGHBOR;
                }

            }

                                    /* SPR 19343 START */
            }
                                    /* SPR 19343 END */
        }
        p_nr_list_deleted->nr_list.intra_rat_nr_list_size = num_intra_neigh;
        p_nr_list_deleted->nr_list.inter_rat_nr_list_size = num_inter_neigh;
    }
    /* Preparing the add list for neighbors
     * The neighbor which are only present in NR will be populated to add list,
     * as neighbor which are already present in NLIU, no need to add them again */

    OAM_LOG(OAM,OAM_DETAILED,"Neighbor not aded by SON intra[%d] inter[%d]",
            p_nr_list_deleted->nr_list.intra_rat_nr_list_size,
            p_nr_list_deleted->nr_list.inter_rat_nr_list_size); 

    num_intra_neigh = OAM_ZERO;
    num_inter_neigh = OAM_ZERO;

    oam_memcpy(&p_nr_list_added->src_cgi,
            &p_nr_list->src_cgi,
            sizeof(son_intra_rat_global_cell_id_t)); 

    for(index = OAM_ZERO; index < p_nr_list->nr_list.intra_rat_nr_list_size; index++)
    {
        /* First Check if this neighbor is not present in delete list */ 
        for(index_1 = OAM_ZERO; index_1 < 
                p_nr_list_deleted->nr_list.intra_rat_nr_list_size; index_1++)

        {
            if(are_plmns_same(&p_nr_list->nr_list.
                        intra_rat_nr_list[index].nbr_cgi.plmn_id,
                        &p_nr_list_deleted->nr_list.
                        intra_rat_nr_list[index_1].nbr_cgi.plmn_id) &&
                    !oam_memcmp(&p_nr_list->nr_list.
                        intra_rat_nr_list[index].nbr_cgi.cell_identity,
                        &p_nr_list_deleted->nr_list.
                        intra_rat_nr_list[index_1].nbr_cgi.cell_identity,
                        SON_CELL_ID_OCTET_SIZE))

            {
                cgi_found = OAM_TRUE;
                break;
            }
        }
        if(OAM_FALSE == cgi_found)
        {
            /* Check if neighbor already present in nliu */ 
            neigh_idx = oam_cgi_search_in_neigh_list(
                    &p_nr_list->nr_list.intra_rat_nr_list[index].nbr_cgi,
                    p_son_nrt_info->nr_list.intra_rat_nr_list,
                    p_son_nrt_info->nr_list.intra_rat_nr_list_size,
                    &SON_PROV_REQ.neigh_list_in_use[nliu_cell_config_idx].
                    intra_rat_neigh_valid_bitmap,
                    OAM_SON_NEIGH_TYPE_INTRA_RAT);

            if(neigh_idx == NOT_FOUND)
            {
                /* Neighbor not found in nliu */
                oam_memcpy(&p_nr_list_added->nr_list.
                        intra_rat_nr_list[num_intra_neigh++],
                        &p_nr_list->nr_list.
                        intra_rat_nr_list[index],
                        sizeof(son_intra_rat_neighbor_info_t));
	    OAM_LOG(OAM,OAM_DETAILED,"neighbor populated by fun prepare_nr_fot nliu cid = %d ",
			    oam_extract_cid_from_eutran_cellidentity(
				    p_nr_list->nr_list.intra_rat_nr_list[index].nbr_cgi.cell_identity));
                /* SPR 19221: CID 107813 Fix Start */ 
                /*Code Deleted*/
                /* SPR 19221: CID 107813 Fix Start */ 
            }
        }
        cgi_found = OAM_FALSE;
    }
    
    p_nr_list_added->nr_list.intra_rat_nr_list_size = num_intra_neigh;
    for(index = OAM_ZERO; index < p_nr_list->nr_list.inter_rat_nr_list_size; index++)
    {
        for(index_1 = OAM_ZERO; index_1< 
                p_nr_list_deleted->nr_list.inter_rat_nr_list_size; index_1++)
        {
            if((p_nr_list_deleted->nr_list.inter_rat_nr_list[index_1].bitmask & SON_INTER_UTRAN_NEIGHBOR)&&
                    (p_nr_list->nr_list.inter_rat_nr_list[index].bitmask & SON_INTER_UTRAN_NEIGHBOR)) 
            {
                if(are_plmns_same(&p_nr_list->nr_list.inter_rat_nr_list[index].
                            utran_neighbor.nbr_cgi.plmn_id,
                            &p_nr_list_deleted->nr_list.inter_rat_nr_list[index_1].
                            utran_neighbor.nbr_cgi.plmn_id) &&
                        !oam_memcmp(p_nr_list->nr_list.inter_rat_nr_list[index].
                            utran_neighbor.nbr_cgi.cell_identity,
                            p_nr_list_deleted->nr_list.inter_rat_nr_list[index_1].
                            utran_neighbor.nbr_cgi.cell_identity,
                            SON_CELL_ID_OCTET_SIZE))
                {
                    cgi_found = OAM_TRUE;
                    break;
                }

            }
            else if ((p_nr_list_deleted->nr_list.inter_rat_nr_list[index_1].bitmask & SON_INTER_GERAN_NEIGHBOR)&&
                    (p_nr_list->nr_list.inter_rat_nr_list[index].bitmask & SON_INTER_GERAN_NEIGHBOR)) 
            {
                if(are_plmns_same(&p_nr_list->nr_list.inter_rat_nr_list[index].
                            geran_neighbor.nbr_cgi.plmn_id, 
                            &p_nr_list_deleted->nr_list.inter_rat_nr_list[index_1].
                            geran_neighbor.nbr_cgi.plmn_id)&& 
                        !oam_memcmp(p_nr_list->nr_list.inter_rat_nr_list[index].
                            geran_neighbor.nbr_cgi.cell_identity,
                            p_nr_list_deleted->nr_list.inter_rat_nr_list[index_1].
                            geran_neighbor.nbr_cgi.cell_identity,
                            SON_CELL_ID_OCTET_SIZE))
                {
                    cgi_found = OAM_TRUE;
                    break;
                }

            }
        }
        if(OAM_FALSE == cgi_found)
        {
            if(p_nr_list->nr_list.inter_rat_nr_list[index].bitmask & SON_INTER_UTRAN_NEIGHBOR)
            {
                neigh_idx = oam_cgi_search_in_neigh_list(
                        &p_nr_list->nr_list.inter_rat_nr_list[index].utran_neighbor.
                        nbr_cgi,
                        p_son_nrt_info->nr_list.inter_rat_nr_list,
                        p_son_nrt_info->nr_list.inter_rat_nr_list_size,
                        &SON_PROV_REQ.neigh_list_in_use[nliu_cell_config_idx].
                        inter_rat_umts_neigh_valid_bitmap,
                        OAM_SON_NEIGH_TYPE_INTER_RAT_UTRAN);


                if(neigh_idx == NOT_FOUND)
                {
                    oam_memcpy((&p_nr_list_added->nr_list.
                                inter_rat_nr_list[num_inter_neigh++]),
                            (&p_nr_list->nr_list.
                             inter_rat_nr_list[index]),     
                            sizeof(son_inter_rat_neighbor_info_t));
                    neigh_idx = NOT_FOUND; 
                }
                else
                {
                    OAM_LOG(OAM,OAM_DETAILED," Inter RAT UMTS Neighbor Index [%d] already"
                            " present in NLIU at index [%d]",index,neigh_idx);

                }

            }
            else if (p_nr_list->nr_list.inter_rat_nr_list[index].bitmask & SON_INTER_GERAN_NEIGHBOR)
            {
                /* Directly copying as it may not be present in NLIU */
                oam_memcpy((&p_nr_list_added->nr_list.
                            inter_rat_nr_list[num_inter_neigh++]),
                        (&p_nr_list->nr_list.
                         inter_rat_nr_list[index]),     
                        sizeof(son_inter_rat_neighbor_info_t));
            }
        }
        cgi_found = OAM_FALSE;

    }
    p_nr_list_added->nr_list.inter_rat_nr_list_size = num_inter_neigh;

    OAM_LOG(OAM,OAM_DETAILED,"Neighbor successfully aded by SON intra[%d] inter[%d]",
            p_nr_list_added->nr_list.intra_rat_nr_list_size,
            p_nr_list_added->nr_list.inter_rat_nr_list_size); 


    OAM_FUN_EXIT_TRACE();
}
/******************************************************************************
 *   FUNCTION NAME: oam_save_nr_add_req_with_trans_id
 *
 *   DESCRIPTION  : This function saves the nr_add_req sent to SON which will be 
 *                  used upon response received from SON
 *
 *   Inputs       : p_nr_add_req -  req sent to SON
 *                  trans_id - transaction id used to send nr_add_req
 *
 *   Output       : None
 *
 *   RETURNS      : None  
 *****************************************************************************/

void oam_save_nr_add_req_with_trans_id
(
 oam_son_nr_add_req_t  * p_nr_add_req,
 UInt16 trans_id,
 UInt8 cell_idx
 )
{
    OAM_FUN_ENTRY_TRACE();

    UInt8 count = OAM_ZERO;
    oam_error_code_et p_error_code = NO_ERROR;

    for(count = OAM_ZERO;(count <=SON_NEIGHBORLIST_INFO(cell_idx).curr_num_of_nr_add_req_sent)
                          && (count < OAM_MAX_NR_ADD_TRANS) ; count++ )
    {
        if(!(SON_NEIGHBORLIST_INFO(cell_idx).bitmap_for_nr_add_req_transactions & (OAM_ONE << count)))
        {
            if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_saved_son_nr_add_req_t),
            (void **)&SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count],
            &p_error_code))
            {
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req failed"
                        " with Error Code:%d",
                        p_error_code);
                OAM_FUN_EXIT_TRACE();
                return;
            }

            if(OAM_FAILURE == oam_mem_alloc(sizeof(oam_son_nr_add_req_t),
            (void **)&SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count]->p_nr_add_req,
            &p_error_code))
            {
                oam_mem_free(SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count],
                &p_error_code);
                OAM_LOG(OAM, OAM_ERROR,
                        "Memory allocation to SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req failed"
                        " with Error Code:%d",
                        p_error_code);
                OAM_FUN_EXIT_TRACE();
                return;
            }


            oam_memcpy(SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count]->p_nr_add_req, 
                    p_nr_add_req,sizeof(oam_son_nr_add_req_t));

            SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count]->trans_id = 
                trans_id;
            SON_NEIGHBORLIST_INFO(cell_idx).curr_num_of_nr_add_req_sent++;
            SON_NEIGHBORLIST_INFO(cell_idx).bitmap_for_nr_add_req_transactions |=
                OAM_ONE << count;

            OAM_LOG(OAM, OAM_DETAILED,
                    "NR_ADD_REQ saved at index %u with trans_id = %u for cell index %u",count,trans_id,cell_idx);
            break;

        }
    }
    if(OAM_MAX_NR_ADD_TRANS == count)
    {
        OAM_LOG(OAM, OAM_WARNING,
                "No space left to store NR_ADD_REQ transaction ");
    }

    OAM_FUN_EXIT_TRACE();
    return;


}
/*******************************************************************************
 *   FUNCTION NAME: oam_find_nr_add_req
 *
 *   DESCRIPTION  : This function fetches the nr_add_req sent to SON which will be 
 *                  used upon response received from SON
 *
 *   Inputs       : cell_idx - cell_config_idx
 *                  trans_id - transaction id used to send nr_add_req
 *
 *   Output       : None
 *
 *   RETURNS      : None  
 *****************************************************************************/


void oam_find_nr_add_req
(
 UInt16 trans_id,
 UInt8 cell_idx
 )
{
    OAM_FUN_ENTRY_TRACE();

    UInt8 count = OAM_ZERO;
    oam_error_code_et p_error_code = NO_ERROR;

    for(count = OAM_ZERO; count < OAM_MAX_NR_ADD_TRANS; count++)
    {
        if(trans_id == 
                SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count]->trans_id)
        {
            OAM_LOG(OAM, OAM_DETAILED,
                    "NR_ADD_REQ found at index %u for cell index %u and trans_id %u",count,cell_idx,trans_id);

            oam_memcpy(&LOCAL_SON_NR_ADD_REQ(cell_idx),
                    SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count]->p_nr_add_req,
                    sizeof(oam_son_nr_add_req_t));

            oam_mem_free(SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count]->p_nr_add_req,&p_error_code);
            oam_mem_free(SON_NEIGHBORLIST_INFO(cell_idx).p_saved_nr_add_req[count],&p_error_code);

            SON_NEIGHBORLIST_INFO(cell_idx).curr_num_of_nr_add_req_sent--;
            SON_NEIGHBORLIST_INFO(cell_idx).bitmap_for_nr_add_req_transactions &= ~(OAM_ONE << count);
            break;

        }
    }
    if(OAM_MAX_NR_ADD_TRANS == count)
    {
        OAM_LOG(OAM, OAM_WARNING,
                "No NR_ADD_REQ found for cell index %u and trans_id %u",cell_idx,trans_id);
    }


    OAM_FUN_EXIT_TRACE();
    return;
}
/* SPR 18930  FIX END */

/* SPR 21738 Fix Start */

oam_return_et
oam_stop_all_cells(void *p_api_buf, UInt16 msg_len)
{

	UInt8           cell_count = OAM_ZERO,
			cid = OAM_ZERO;
	oam_rrm_cell_config_req_t *p_rrm_cell_config = OAM_NULL;
	oam_return_et retVal = OAM_FAILURE;
	UInt16 trans_id = OAM_ZERO;
	oam_cell_status_t *p_cell_status = OAM_NULL;

	if(!oam_prov_req.num_cells_configured)
	{
		OAM_LOG(OAM, OAM_DETAILED, "Number of Cells configured is zero");
	}
	for(cell_count = OAM_ZERO;
			cell_count < oam_prov_req.num_cells_configured;
			++cell_count) 
	{
		p_rrm_cell_config =
			&RRM_CELL_CONFIG(cell_count);

		cid =
			oam_extract_cid_from_eutran_cellidentity(
					p_rrm_cell_config->global_cell_info.
					eutran_global_cell_id.cell_identity);

		OAM_LOG(OAM, OAM_INFO,
				"Sending cell stop for CID: %d to rrm",
				cid);
		p_cell_status = oam_get_cell_cntxt_status(cid);
		if (p_cell_status == OAM_NULL)
		{
			OAM_LOG(OAM, OAM_ERROR,
					"No cell found, cell identity = %d", cid);
			OAM_FUN_EXIT_TRACE();
			break;
		}

		if((p_cell_status->cell_state & OAM_CELL_ACTIVE))
		{
			trans_id = oam_get_new_trans_id();
			if (OAM_FAILURE == oam_rrm_send_rrm_oam_cell_stop_req(
						(rrm_oam_cell_stop_req_t *)
						&(p_rrm_cell_config->
							global_cell_info.
							eutran_global_cell_id),
						OAM_MODULE_ID,
						RRM_MODULE_ID,
						trans_id, cid))
			{
				OAM_LOG(OAM,OAM_ERROR,
						"Error in function oam_send_cell_stop_req");
				OAM_FUN_EXIT_TRACE ();
			}
			else{
#ifndef OAM_UT_FRAMEWORK
				if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRM,
							OAM_TRANS_RRM,msg_len,p_api_buf))
				{
					OAM_LOG(OAM, OAM_INFO, " Failed to maintain TCB ");
					OAM_FUN_EXIT_TRACE();
					break;
				}
#endif
				OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_CELL_STOP_REQ Successfully sent");
				retVal = OAM_SUCCESS;
			}
		}
	}
	return retVal;

}


oam_return_et
oam_start_all_cells(void *p_api_buf, UInt16 msg_len)
{

	UInt8           cell_count = OAM_ZERO,
			cid = OAM_ZERO;
	oam_rrm_cell_config_req_t *p_rrm_cell_config = OAM_NULL;
	oam_return_et retVal = OAM_FAILURE;
	oam_cell_status_t *p_cell_status = OAM_NULL;
	UInt16 trans_id = OAM_ZERO;

	if(!oam_prov_req.num_cells_configured)
	{
		OAM_LOG(OAM, OAM_DETAILED, "Number of Cells configured is zero");
	}
	for(cell_count = OAM_ZERO;
			cell_count < oam_prov_req.num_cells_configured;
			++cell_count) 
	{
		p_rrm_cell_config =
			&RRM_CELL_CONFIG(cell_count);

		cid =
			oam_extract_cid_from_eutran_cellidentity(
					p_rrm_cell_config->global_cell_info.
					eutran_global_cell_id.cell_identity);
		p_cell_status = oam_get_cell_cntxt_status(cid);
		if (p_cell_status == OAM_NULL)
		{
			OAM_LOG(OAM, OAM_ERROR,
					"No cell found, cell identity = %d", cid);
			OAM_FUN_EXIT_TRACE();
			break;
		}

		if((OAM_FALSE == oam_prov_req.oam_igd_params.rem_lte_params.is_nr_scan_required)
				|| (OAM_FALSE == oam_prov_req.system_status.is_nmm_enabled))
		{
			p_cell_status->cell_event |= NR_SCAN_RESP_RCVD;
		}
		else
		{
			OAM_LOG(OAM,OAM_DETAILED, "NR Scanning is enable");
		}
		if((p_cell_status->cell_event & CELL_CONFIG_RESP_RCVD)
				/*+SPR 18853 FIX*/
#ifdef OAM_SON_ENABLE
				/*check if NR SCAN Resp has receievd send start cell req */
				&& (p_cell_status->cell_event & NR_SCAN_RESP_RCVD))
#endif
		{

			if((!(p_cell_status->cell_event & OAM_USER_TRIGGERED_STOP)) &&
					((p_cell_status->cell_state & OAM_CELL_STOP)))
			{


				OAM_LOG(OAM, OAM_INFO,
						"Sending cell start for CID: %d to rrm",
						cid);
				trans_id = oam_get_new_trans_id();

				if (OAM_FAILURE == oam_rrm_send_rrm_oam_cell_start_req(
							(rrm_oam_cell_start_req_t *)
							&(p_rrm_cell_config->
								global_cell_info.
								eutran_global_cell_id),
							OAM_MODULE_ID,
							RRM_MODULE_ID,
							trans_id, cid))
				{
					OAM_LOG(OAM,OAM_ERROR,
							"Error in function oam_send_cell_start_req");
					OAM_FUN_EXIT_TRACE ();
				}
				else{
#ifndef OAM_UT_FRAMEWORK
					if( OAM_FAILURE == oam_maintain_tcb_with_timer(trans_id,OAM_SUB_MODULE_RRM,
								OAM_TRANS_RRM,msg_len,p_api_buf))
					{
						OAM_LOG(OAM, OAM_INFO, " Failed to maintain TCB ");
						break;
					}
#endif

					OAM_LOG(OAM, OAM_DETAILED, "RRM_OAM_CELL_START_REQ Successfully sent for CID: %d", cid);
					retVal = OAM_SUCCESS;
				}

				if(OAM_S1_LINK_DOWN_SET != flag_for_s1_link)
					p_cell_status->send_initialization_req = OAM_TRUE;
			}
			else
			{
				OAM_LOG(OAM,OAM_DETAILED,"Cell CID :%d stopped by operator so not started",cid);
			}
		}
	}

	return retVal;
}
/* SPR 21738 Fix End */




/*SPR 21889 Start*/
/*************************************************************************
 * Function Name  : oam_send_kill_to_all_agent
 * Description    : Function to send kill request to all agents
 * Inputs         : None
 * Outputs        : none
 * Returns        : None
 ******************************************************************************/
void oam_send_kill_to_all_agent()
{
    UInt8 i;
    for (i = OAM_ZERO; i < OAM_MAX_NUM_L2_INSTANCE; i++)
    {
        oam_trigger_agent_fsm(OAM_NULL, OAM_AGENT_EVENT_KILL_REQ, i);
    }
}


/*************************************************************************
 * Function Name  : oam_agent_get_main_state_str
 * Description    : Function for mapping enum to string for main state
 * Inputs         : State as enum
 * Outputs        : none
 * Returns        : Null terminated character array string
 ******************************************************************************/
Char8* oam_agent_get_main_state_str(oam_agent_fsm_main_state_et state)
{
    switch(state)
    {
        case OAM_AGENT_STATE_INIT:
            return "OAM_AGENT_STATE_INIT";
        case OAM_AGENT_STATE_WAIT_ACTIVE:
            return "OAM_AGENT_STATE_WAIT_ACTIVE";
        case OAM_AGENT_STATE_ACTIVE:
            return "OAM_AGENT_STATE_ACTIVE";
        case OAM_AGENT_STATE_WAIT_SHUTDOWN:
            return "OAM_AGENT_STATE_WAIT_SHUTDOWN";

        default:
            return "AGENT_UNKNOWN_MAIN_STATE";
    }
}

/*************************************************************************
 * Function Name  : oam_agent_get_procdre_state_str
 * Description    : Function for mapping between enum and procedure state
 *                  string
 * Inputs         : State enum
 * Outputs        : none
 * Returns        : Null terminated character array string
 ******************************************************************************/
Char8* oam_agent_get_procdre_state_str(oam_agent_fsm_procdre_state_et state)
{
    switch(state)
    {
        case OAM_AGENT_PROCDRE_STATE_INIT:
            return "OAM_AGENT_PROCDRE_STATE_INIT";

        case OAM_AGENT_SPAWN_RESP_PENDING:
            return "OAM_AGENT_SPAWN_RESP_PENDING";

        case OAM_AGENT_KILL_RESP_PENDING:
            return "OAM_AGENT_KILL_RESP_PENDING";

        case OAM_AGENT_GET_LOG_RESP_PENDING:
            return "OAM_AGENT_GET_LOG_RESP_PENDING";

        default:
            return "AGENT_UNKNOWN_PROCEDURE_STATE";
    }
}

/*************************************************************************
 * Function Name  : oam_trigger_agent_fsm
 * Description    : Function for triggering AGENT FSM
 * Inputs         : API buffer and event
 * Outputs        : none
 * Returns        : OAM_SUCCESS/OAM_FAILURE
 ******************************************************************************/
oam_return_et
oam_trigger_agent_fsm(void *p_api_buf,
         oam_agent_event_et event,
         UInt8 instance_id)
{
    oam_agnt_fsm_data_t fsm_data;
    oam_agent_fsm_ctxt_t *p_fsm_ctxt;
    /* SPR 21889: CID 115198 Start */
    oam_return_et   ret_val = OAM_FAILURE;
    oam_memset(&fsm_data, OAM_ZERO, sizeof(oam_agnt_fsm_data_t));
    /* SPR 21889: CID 115198 End */

    if (OAM_MAX_NUM_L2_INSTANCE >  instance_id)
    {
        fsm_data.instance_id = instance_id;
        p_fsm_ctxt = &oam_prov_req.l2_setup_info.instance_info[fsm_data.instance_id].oam_l2_req.oam_agnt_info.agent_fsm_ctxt;
        /* SPR 21889: CID 115180 Start */
            /* SPR 21889: CID 115180 End */
            fsm_data.p_api_data = p_api_buf;
            OAM_LOG(OAM, OAM_INFO, "### AGNT FSM Trigger Event %s for Instance Id %u Main state %s Proc state %s###",
                    oam_agent_get_event_str(event), fsm_data.instance_id,
                    oam_agent_get_main_state_str((oam_agent_fsm_main_state_et)p_fsm_ctxt->main_state),
                    oam_agent_get_procdre_state_str((oam_agent_fsm_procdre_state_et)p_fsm_ctxt->procdre_state));  
            ret_val = oam_agent_fsm_tbl[p_fsm_ctxt->main_state][p_fsm_ctxt->procdre_state][event](p_fsm_ctxt, &fsm_data);
            OAM_LOG(OAM, OAM_INFO, "### AGNT FSM Exit ###");
            fsm_data.p_api_data = OAM_NULL;
            /* SPR 21889: CID 115180 Start */
        /* SPR 21889: CID 115180 End */
    }
    else
    {
	/* SPR 21889 Start */
        OAM_LOG(OAM, OAM_ERROR, "Event %d received from Invalid Instance Id %d", event, instance_id);  
	/* SPR 21889 End */
    }


    return ret_val;
}
/*************************************************************************
 * Function Name  : oam_stop_agent_req_timer
 * Description    : This is used for stopping the running timer
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_stop_agent_req_timer(oam_agent_fsm_ctxt_t *p_fsm_ctxt,
        oam_agnt_fsm_data_t *p_fsm_data)
{
    if (OAM_SUCCESS == oam_stop_timer(p_fsm_ctxt->req_guard_timer))
    {
        p_fsm_ctxt->req_guard_timer = OAM_NULL;
    }
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_start_agent_req_timer
 * Description    : This is used to start request timer for agent
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_start_agent_req_timer(oam_agent_fsm_ctxt_t *p_fsm_ctxt,
        oam_agnt_fsm_data_t *p_fsm_data)
{
    UInt8 *p_instance_id;
    oam_error_code_et err = NO_ERROR;

    if (OAM_ZERO == p_fsm_ctxt->req_guard_timer)
    {
        if (OAM_SUCCESS != oam_mem_alloc(sizeof(UInt8), (void*)&p_instance_id, &err))
        {
            OAM_LOG(OAM, OAM_ERROR, "Request timer not started. Failed to allocate memory for instance id");
            return OAM_FAILURE;
        }

        *p_instance_id = p_fsm_data->instance_id;

        p_fsm_ctxt->req_guard_timer = oam_start_new_timer(OAM_SUB_MODULE_AGENT,
                OAM_MODULE_ID, OAM_AGENT_RESP_PENDING_TIMER, OAM_AGENT_RESP_PENDING_TM_OUT *
                OAM_THOUSAND,
                p_instance_id, sizeof(UInt8), OAM_FALSE);
        OAM_LOG(OAM, OAM_BRIEF, "Starting request timer for Agent %u Timer Id 0x%x",
                p_fsm_data->instance_id, p_fsm_ctxt->req_guard_timer);
    }
    else
    {
        OAM_LOG(OAM, OAM_WARNING, "Starting request timer for Agent %u without stopping previous 0x%x",
                p_fsm_data->instance_id, p_fsm_ctxt->req_guard_timer);
    }

    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_get_event_str
 * Description    : Function for mapping between event enum and the event name
 * Inputs         : Event enum
 * Outputs        : none
 * Returns        : Null terminated character array string
 ******************************************************************************/
Char8* oam_agent_get_event_str(oam_agent_event_et event)
{
    switch(event)
    {
        case OAM_AGENT_EVENT_IND:
            return "OAM_AGENT_EVENT_IND";

        case OAM_AGENT_EVENT_SPAWN_RESP:
            return "OAM_AGENT_EVENT_SPAWN_RESP";

        case OAM_AGENT_EVENT_KILL_REQ:
            return "OAM_AGENT_EVENT_KILL_REQ";

        case OAM_AGENT_EVENT_KILL_RESP:
            return "OAM_AGENT_EVENT_KILL_RESP";

        case OAM_AGENT_EVENT_GET_LOGS_REQ:
            return "OAM_AGENT_EVENT_GET_LOGS_REQ";

        case OAM_AGENT_EVENT_GET_LOGS_RESP:
            return "OAM_AGENT_EVENT_GET_LOGS_RESP";

        case OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY:
            return "OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY";

        case OAM_AGENT_EVENT_RESTART:
            return "OAM_AGENT_EVENT_RESTART";
            
        case OAM_AGENT_EVENT_IM_OK_IND:
            return "OAM_AGENT_EVENT_IM_OK_IND";

        default:
            return "AGENT_UNKNOWN_EVENT";
    }
}

/*************************************************************************
 * Function Name  : oam_agent_state_change
 * Description    : Function for changing the string
 * Inputs         : FSM context, Main state & procedure state
 * Outputs        : none
 * Returns        : None
 ******************************************************************************/
void 
oam_agent_state_change(
        oam_agent_fsm_ctxt_t *p_fsm_ctxt,
        oam_agent_fsm_main_state_et main_state,
        oam_agent_fsm_procdre_state_et procdre_state)
{
    if (OAM_AGENT_SPAWN_RESP_PENDING == procdre_state)
    {
        p_fsm_ctxt->spawn_retry_cnt++;
    }
    /* SPR 21889: CID 115184 Start */
    OAM_LOG(OAM, OAM_INFO, "Agent state change (Main: %s->%s) (Procedure lvl: %s->%s)",
            oam_agent_get_main_state_str((oam_agent_fsm_main_state_et)(p_fsm_ctxt->main_state)), oam_agent_get_main_state_str(main_state),
            oam_agent_get_procdre_state_str((oam_agent_fsm_procdre_state_et)(p_fsm_ctxt->procdre_state)), oam_agent_get_procdre_state_str(procdre_state));

    p_fsm_ctxt->main_state      = (UInt8)main_state;
    p_fsm_ctxt->procdre_state   = (UInt8)procdre_state;
    /* SPR 21889: CID 115184 End */
}

/*************************************************************************
 * Function Name  : oam_agent_fill_args
 * Description    : This is used for filling argument list as text
 * Inputs         : p_msg, dst_module
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_fill_args(oam_agent_process_args_t *p_arg, UInt16 str_len, Char8 **pp_args)
{
    /* Skipping the first argument because it is a binary name */
    UInt16 num_arg = OAM_ONE; 
    Char8 *p_tmp_str = p_arg->name;

    p_tmp_str[OAM_ZERO] = '\0'; /* Starting with the null termination */
    while (OAM_NULL != pp_args[num_arg])
    {
        if (str_len > (strlen(pp_args[num_arg]) + OAM_ONE))
        {
            oam_strcat(p_tmp_str, pp_args[num_arg]);
            /* Checking if this is the last argument in the list */
            if (OAM_NULL != pp_args[num_arg + OAM_ONE])
            {
                oam_strcat(p_tmp_str, " "); /* Adding space */
            }
            num_arg++;
        }
        else
        {
            /* Cannot fill the complete argument list */
            OAM_LOG(OAM,OAM_ERROR, "Failed to fill the complete argument list");
            return OAM_FAILURE;
        }
    }

    p_arg->len = oam_strlen(p_tmp_str);
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_init_evt_ind
 * Description    : Agent FSM handler for handling INIT indication
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_init_evt_ind(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    agent_oam_init_ind_t            *p_agent_init_ind;
    oam_agent_spawn_process_req_t   *p_agent_spawn_req;
    oam_error_code_et               err = NO_ERROR;
    UInt8                           i = OAM_ZERO;
    UInt8                           j = OAM_ZERO;
    UInt8 *p_api            = (UInt8*)p_fsm_data->p_api_data;
    SInt32 len              = OAM_ZERO;
    SInt32 msg_size         = OAM_ZERO;
    oam_bool_et agnt_upgraded = OAM_FALSE;

    if (OAM_NULL == p_api)
    {
        OAM_LOG(OAM, OAM_ERROR, "API is null");
        return OAM_FAILURE;
    }
    msg_size = (get_word_from_header(p_api + OAM_INTF_HDR_MSG_SIZE_OFFSET)) - LOWER_LAYER_INTERFACE_HEADER_SIZE;

    if (OAM_SUCCESS != oam_mem_alloc(sizeof(agent_oam_init_ind_t), (void*)&p_agent_init_ind, &err))
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to allocate memory for Init Ind");
        return OAM_FAILURE;
    }

    /* Parse the message */
    if (OAM_SUCCESS != oam_agnt_parse_agent_oam_init_ind(p_agent_init_ind,
                p_api + LOWER_LAYER_INTERFACE_HEADER_SIZE, msg_size, &len))
    {
        OAM_LOG(OAM, OAM_ERROR,"AGENT->OAM:AGENT_OAM_INIT_IND parsing failed");
        oam_mem_free(p_agent_init_ind, &err);
        return OAM_FAILURE;
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,"AGENT->OAM:AGENT_OAM_INIT_IND");
    }


    
    /* Stop if any timer is running */
    if (OAM_ZERO != p_fsm_ctxt->req_guard_timer)
    {
        oam_stop_agent_req_timer(p_fsm_ctxt, p_fsm_data);
    }

    if (OAM_SUCCESS != oam_mem_alloc(sizeof(oam_agent_spawn_process_req_t), (void*)&p_agent_spawn_req, &err))
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to allocate memory for Spawn Req");
        oam_mem_free(p_agent_init_ind, &err); //CID: 122022
        return OAM_FAILURE;
    }

    p_agent_spawn_req->num_process = OAM_ZERO;
    /* Every thing is fine now. Save bin path so that logs can be extracted from this path in later stages */
    oam_strncpy(oam_prov_req.l2_setup_info.instance_info[p_fsm_data->instance_id].oam_l2_req.oam_agnt_info.bin_path,
            p_agent_init_ind->bin_path.name,
            p_agent_init_ind->bin_path.len);

    /* Check which all process needs to be started on the agent */
    for (j = OAM_ZERO; j < g_oam_sim_t.max_no_process; j++)
    {
        if ((OAM_TRUE == g_oam_sim_t.p_info[j].is_remote) && (p_fsm_data->instance_id == g_oam_sim_t.p_info[j].instance_id))
        {
            for (i = OAM_ZERO; i < p_agent_init_ind->num_process; i++)
            {
                if (OAM_ZERO ==
                        oam_strncmp(p_agent_init_ind->process_list[i].process_name.name,
                            g_oam_sim_t.p_info[j].name,
                            OAM_AGENT_MAX_PROCESS_NAME))
                {
                    /* Checking if the checksum matches with the existing binary */
                    if (p_agent_init_ind->process_list[i].cksum == g_oam_sim_t.p_info[j].cksum)
                    {
                        break;
                    }
                }
            }

            if (i == p_agent_init_ind->num_process)
            {
                if (OAM_SUCCESS == oam_transfer_file(g_oam_sim_t.p_info[j].name,
                        p_fsm_data->instance_id, OAM_FALSE))
                {
                    /* This process is not present on agent hence needs to be transferred */
                    if (OAM_ZERO == oam_strcmp(g_oam_sim_t.p_info[j].name, OAM_AGENT_BIN_NAME))
                    {
                        agnt_upgraded = OAM_TRUE;
                        p_agent_spawn_req->num_process = OAM_ZERO;
                        OAM_LOG(OAM, OAM_INFO, "Agent on instance %u is needs to be upgraded",
                                p_fsm_data->instance_id);
                    }
                    if ((OAM_ZERO == oam_strcmp(g_oam_sim_t.p_info[j].name, OAM_L2_BIN_NAME)) ||
                            (OAM_ZERO == oam_strcmp(g_oam_sim_t.p_info[j].name, OAM_PDCP_BIN_NAME)) ||
                            (OAM_ZERO == oam_strcmp(g_oam_sim_t.p_info[j].name, OAM_EGTPU_BIN_NAME)))
                    {
                        if (OAM_SUCCESS != oam_transfer_file(OAM_LIBBINREAD_BIN_NAME,
                                    p_fsm_data->instance_id, OAM_FALSE))
                        {
                            /* Ignore this Indication as binary transfer failed */
                            p_agent_spawn_req->num_process = OAM_ZERO;
                            break;
                        }
                    }
                }
                else
                {
                    /* Ignore this Indication as binary transfer failed */
                    p_agent_spawn_req->num_process = OAM_ZERO;
                    break;
                }
            }
            oam_strncpy(p_agent_spawn_req->process_list[p_agent_spawn_req->num_process].process_name.name,
                    g_oam_sim_t.p_info[j].name, OAM_AGENT_MAX_PROCESS_NAME);
            p_agent_spawn_req->process_list[p_agent_spawn_req->num_process].process_name.name[OAM_AGENT_MAX_PROCESS_NAME - OAM_ONE]
            = '\0';
            p_agent_spawn_req->process_list[p_agent_spawn_req->num_process].process_name.len =
                oam_strlen(p_agent_spawn_req->process_list[p_agent_spawn_req->num_process].process_name.name);

            if (OAM_SUCCESS !=
                    oam_agent_fill_args(&p_agent_spawn_req->process_list[p_agent_spawn_req->num_process].arg_list,
                        OAM_AGENT_PROCESS_ARG_LIST, g_oam_sim_t.p_info[j].pp_args))
            {
                /* Abort this procedure */
                p_agent_spawn_req->num_process = OAM_ZERO;
                break;
            }
            p_agent_spawn_req->num_process++;
            if (OAM_TRUE == agnt_upgraded)
            {
                break;
            }
        }
    }

    if (OAM_ZERO != p_agent_spawn_req->num_process)
    {
        p_agent_spawn_req->interval = oam_prov_req.hm_config_param.nonresponsive_monitoring_interval/OAM_MSEC_IN_ONE_SEC;

        /* Send request for spawning */

        if (OAM_FAILURE !=
                oam_agnt_send_oam_agent_spawn_process_req(p_agent_spawn_req,
                    OAM_MODULE_ID, OAM_AGNT_MODULE_ID, OAM_ZERO,
                    p_fsm_data->instance_id))
        {
            if (OAM_TRUE != agnt_upgraded)
            {
                oam_start_agent_req_timer(p_fsm_ctxt, p_fsm_data);
                oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_WAIT_ACTIVE, OAM_AGENT_SPAWN_RESP_PENDING);
            }
        }
    }


    oam_mem_free(p_agent_spawn_req, &err);
    oam_mem_free(p_agent_init_ind, &err);
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_spwn_rsp_evt_spwn_rsp
 * Description    : Agent FSM handler for handling SPAWN response from Agent
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_spwn_rsp_evt_spwn_rsp(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data) 
{
    oam_error_code_et   err = NO_ERROR;
    UInt8               i   = OAM_ZERO;
    UInt8               j   = OAM_ZERO;
    UInt8 *p_api            = (UInt8*)p_fsm_data->p_api_data;
    SInt32 len              = OAM_ZERO;
    Char8 alarm_str[OAM_ALARM_ADD_TXT_MAX_LEN];
    oam_agent_spawn_process_req_t   *p_agent_spawn_req;
    agent_oam_spawn_process_resp_t  *p_agent_spawn_resp;
    SInt32 msg_size         = OAM_ZERO;
    if (OAM_NULL == p_api)
    {
        OAM_LOG(OAM, OAM_ERROR, "API is null");
        return OAM_FAILURE;
    }

    msg_size = (get_word_from_header(p_api + OAM_INTF_HDR_MSG_SIZE_OFFSET)) - LOWER_LAYER_INTERFACE_HEADER_SIZE;
    oam_stop_agent_req_timer(p_fsm_ctxt, p_fsm_data);

    if (OAM_SUCCESS != oam_mem_alloc(sizeof(agent_oam_spawn_process_resp_t), (void*)&p_agent_spawn_resp, &err))
    {
        /* Don't know the state of agent hence resetting so that no further communication needs to be done */
        oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_INIT, OAM_AGENT_PROCDRE_STATE_INIT);
    }

    /* Parse message */
    if (OAM_SUCCESS !=
            oam_agnt_parse_agent_oam_spawn_process_resp(p_agent_spawn_resp,
                p_api + LOWER_LAYER_INTERFACE_HEADER_SIZE, msg_size, &len))
    {
        OAM_LOG(OAM, OAM_ERROR,"AGENT->OAM:AGENT_OAM_SPAWN_PROCESS_RESP parsing failed");
        oam_mem_free(p_agent_spawn_resp, &err);
        return OAM_FAILURE;
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,"AGENT->OAM:AGENT_OAM_SPAWN_PROCESS_RESP");
    }

    if (OAM_ZERO != p_agent_spawn_resp->num_failed_process)
    {
        if (OAM_MAX_SPAWN_RETRY_COUNT > p_fsm_ctxt->spawn_retry_cnt)
        {
            if (OAM_SUCCESS != oam_mem_alloc(sizeof(oam_agent_spawn_process_req_t), (void*)&p_agent_spawn_req, &err))
            {
                OAM_LOG(OAM, OAM_ERROR, "Failed to allocate memory for second Spawn Req");
                p_fsm_ctxt->spawn_retry_cnt = OAM_ZERO;
                oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_ACTIVE, OAM_AGENT_PROCDRE_STATE_INIT);
                oam_mem_free(p_agent_spawn_resp, &err);
                /* Return success as the handling of response was correct */
                return OAM_SUCCESS;
            }

            /* Failed to start following process */
            for (i = OAM_ZERO; i < p_agent_spawn_resp->num_failed_process; i++)
            {
                OAM_LOG(OAM,OAM_ERROR, "Failed to start process %s on instance %u. Errno %d",
                        p_agent_spawn_resp->process_list[i].failed_process_name.name,
                        p_fsm_data->instance_id,
                        p_agent_spawn_resp->process_list[i].err);
            }
            /* Resending the request again */
            p_agent_spawn_req->num_process = OAM_ZERO;
            for (j = OAM_ZERO; g_oam_sim_t.max_no_process; i++)
            {
                if ((OAM_TRUE == g_oam_sim_t.p_info[j].is_remote) && (p_fsm_data->instance_id == g_oam_sim_t.p_info[j].instance_id))
                {
                    oam_strncpy(p_agent_spawn_req->process_list[p_agent_spawn_req->num_process].process_name.name,
                            g_oam_sim_t.p_info[j].name,
                            OAM_AGENT_MAX_PROCESS_NAME);
                    p_agent_spawn_req->process_list[p_agent_spawn_req->num_process].process_name.name[OAM_AGENT_MAX_PROCESS_NAME
                        - OAM_ONE] = '\0';
                    if (OAM_SUCCESS !=
                            oam_agent_fill_args(&p_agent_spawn_req->process_list[p_agent_spawn_req->num_process].arg_list,
                                OAM_AGENT_PROCESS_ARG_LIST,
                                g_oam_sim_t.p_info[j].pp_args))
                    {
                        p_agent_spawn_req->num_process = OAM_ZERO;
                        break;
                    }
                    p_agent_spawn_req->num_process++;
                }
            }
            /* Send request */
            oam_agnt_send_oam_agent_spawn_process_req(p_agent_spawn_req, OAM_MODULE_ID, OAM_AGNT_MODULE_ID, OAM_ZERO, p_fsm_data->instance_id);
            oam_mem_free(p_agent_spawn_req, &err);
        }
        else
        {
            /* Abort this procedure and raise the alarm */
            oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_INIT, OAM_AGENT_PROCDRE_STATE_INIT);

            /* Raise an alarm for operator to look */
            oam_snprintf(alarm_str, sizeof(alarm_str), "Spawning of process failed on instance %u.",
                    p_fsm_data->instance_id);

            OAM_ALARM(OAM_AGENT_PROCESS_STARTUP_FAILED, CRITICAL,
                    NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                    UNAVAILABLE, EXPEDITED_ALARM,
                    /* Spr 12880 Fix Start*/
                    alarm_str, "Check agent/machine status", OAM_INVALID_CELL_ID);
        }
    }
    else
    {
        p_fsm_ctxt->spawn_retry_cnt = OAM_ZERO;
        oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_ACTIVE, OAM_AGENT_PROCDRE_STATE_INIT);
    }

    oam_mem_free(p_agent_spawn_resp, &err);
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_init_evt_kill_req
 * Description    : Agent FSM handler for sending KILL request to Agent
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_init_evt_kill_req(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    oam_error_code_et   err = NO_ERROR;
    oam_agent_kill_process_req_t *p_kill_req;

    if (OAM_SUCCESS != oam_mem_alloc(sizeof(oam_agent_kill_process_req_t), (void*)&p_kill_req, &err))
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to allocate memory for Kill Req");
        return OAM_FAILURE;
    }

    if (OAM_NULL == p_fsm_data->p_api_data)
    {
        /* All process needs to be killed including agent */
        p_kill_req->num_process = OAM_ZERO;
    }
    oam_memset(p_kill_req, OAM_ZERO, sizeof(oam_agent_kill_process_req_t)); //CID: 122026 

    /* Send message */
    if (OAM_FAILURE != oam_agnt_send_oam_agent_kill_process_req(p_kill_req,
                OAM_MODULE_ID, OAM_AGNT_MODULE_ID, OAM_ZERO,
                p_fsm_data->instance_id))
    {
        oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_WAIT_SHUTDOWN, OAM_AGENT_KILL_RESP_PENDING);
        oam_start_agent_req_timer(p_fsm_ctxt, p_fsm_data);
    }

    oam_mem_free(p_kill_req, &err);
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_kill_rsp_evt_kill_rsp
 * Description    : Agent FSM handler for handling Kill response
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_kill_rsp_evt_kill_rsp(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    oam_error_code_et   err = NO_ERROR;
    UInt8               i = OAM_ZERO;
    UInt8 *p_api            = (UInt8*)p_fsm_data->p_api_data;
    SInt32 len              = OAM_ZERO;
    SInt32 msg_size         = OAM_ZERO;
    agent_oam_kill_process_resp_t *p_kill_resp;
    Char8 alarm_str[OAM_ALARM_ADD_TXT_MAX_LEN];

    if (OAM_NULL == p_api)
    {
        OAM_LOG(OAM, OAM_ERROR, "API is null");
        return OAM_FAILURE;
    }
    msg_size  = (get_word_from_header(p_api + OAM_INTF_HDR_MSG_SIZE_OFFSET)) - LOWER_LAYER_INTERFACE_HEADER_SIZE;

    oam_stop_agent_req_timer(p_fsm_ctxt, p_fsm_data);

    if (OAM_SUCCESS != oam_mem_alloc(sizeof(agent_oam_kill_process_resp_t), (void*)&p_kill_resp, &err))
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to allocate memory for Kill Resp");
        return OAM_FAILURE;
    }

    /* Parse message */
    if(OAM_SUCCESS != oam_agnt_parse_agent_oam_kill_process_resp(p_kill_resp,
                p_api + LOWER_LAYER_INTERFACE_HEADER_SIZE, msg_size, &len))
    {
        OAM_LOG(OAM, OAM_ERROR,"AGENT->OAM:AGENT_OAM_KILL_PROCESS_RESP parsing failed");
        oam_mem_free(p_kill_resp, &err);
        return OAM_FAILURE;
    }
    else
    {
        OAM_LOG(OAM, OAM_INFO,"AGENT->OAM:AGENT_OAM_KILL_PROCESS_RESP");
    }

    for (i = OAM_ZERO; i < p_kill_resp->num_process; i++)
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to kill process[%s] args[%s] Err[%s] Instance %u",
                p_kill_resp->fail_process_list[i].failed_process_name.name,
                oam_strerror(p_kill_resp->fail_process_list[i].err),
                p_fsm_data->instance_id);

        /* Raise an alarm for operator to look */
        oam_snprintf(alarm_str, sizeof(alarm_str), "Failed to kill process %s, errno %d on instance %u",
                p_kill_resp->fail_process_list[i].failed_process_name.name,
                p_kill_resp->fail_process_list[i].err,
                p_fsm_data->instance_id);

        OAM_ALARM(OAM_AGENT_PROCESS_SHUTDOWN_FAILED, CRITICAL,
                NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                UNAVAILABLE, EXPEDITED_ALARM,
                /* Spr 12880 Fix Start*/
                alarm_str, "Manual killing of process is required on instance",
                OAM_INVALID_CELL_ID);
    }
    oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_INIT, OAM_AGENT_PROCDRE_STATE_INIT);

    oam_mem_free(p_kill_resp, &err);
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_send_get_logs_req
 * Description    : Agent FSM handler for Sending GET log request to agent
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_send_get_logs_req
(
    U16                 src_module_id,  /* Source module identifier */
    U16                 dst_module_id,  /* Destination module identifier */
    U16                 transaction_id,  /* Interface transaction identifier */
    U8                  inst_id      /* Instance Id */
)
{
    U16 msg_api_length;
    U8 *p_msg, *p_oam_msg;

    OAM_LOG(OAM,OAM_INFO, "Src(%u)->Dst(%u) Instance(%u):OAM_AGENT_GET_LOGS", src_module_id, dst_module_id, inst_id);
    msg_api_length = OAM_CSPL_HDR_SIZE + LOWER_LAYER_INTERFACE_HEADER_SIZE;

    /* Allocate buffer */
    p_msg = oam_msg_mem_get(msg_api_length);

    if (p_msg == PNULL)
    {
        /* Not enough memory */
        return OAM_FAILURE;
    }

    oam_memset(p_msg, 0, msg_api_length);
    p_oam_msg = p_msg;

    /* Fill CSPL header */
    oam_construct_api_header(p_oam_msg, OAM_VERSION_ID, src_module_id,
        dst_module_id, OAM_AGENT_GET_LOGS, msg_api_length);

    /* Fill interface header */
    p_oam_msg = p_oam_msg + OAM_CSPL_HDR_SIZE;
    oam_construct_interface_api_header(p_oam_msg, transaction_id, src_module_id,
        dst_module_id, OAM_AGENT_GET_LOGS, OAM_ZERO, inst_id);

    /* Send message to */
    oam_rrm_send_message(p_msg, dst_module_id);

    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_send_restart_ind
 * Description    : Agent FSM handler for sending RESTART indication to agent
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_send_restart_ind
(
    U16                 src_module_id,  /* Source module identifier */
    U16                 dst_module_id,  /* Destination module identifier */
    U16                 transaction_id,  /* Interface transaction identifier */
    U8                  inst_id      /* Instance Id */
)
{
    U16 msg_api_length;
    U8 *p_msg, *p_oam_msg;

    OAM_LOG(OAM,OAM_INFO, "Src(%u)->Dst(%u) Instance(%u):OAM_AGENT_RESTART_IND", src_module_id, dst_module_id, inst_id);
    msg_api_length = OAM_CSPL_HDR_SIZE + LOWER_LAYER_INTERFACE_HEADER_SIZE;

    /* Allocate buffer */
    p_msg = oam_msg_mem_get(msg_api_length);

    if (p_msg == PNULL)
    {
        /* Not enough memory */
        return OAM_FAILURE;
    }

    oam_memset(p_msg, 0, msg_api_length);
    p_oam_msg = p_msg;

    /* Fill CSPL header */
    oam_construct_api_header(p_oam_msg, OAM_VERSION_ID, src_module_id,
        dst_module_id, OAM_AGENT_RESTART_IND, msg_api_length);

    /* Fill interface header */
    p_oam_msg = p_oam_msg + OAM_CSPL_HDR_SIZE;
    oam_construct_interface_api_header(p_oam_msg, transaction_id, src_module_id,
        dst_module_id, OAM_AGENT_RESTART_IND, OAM_ZERO, inst_id);

    /* Send message to */
    oam_rrm_send_message(p_msg, dst_module_id);

    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_init_evt_getlogs
 * Description    : Agent FSM handler for handling GET log response
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_init_evt_getlogs(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    oam_send_get_logs_req(OAM_MODULE_ID, OAM_AGNT_MODULE_ID, OAM_ZERO, p_fsm_data->instance_id);
    oam_prov_req.l2_setup_info.log_req_cnt++;

    oam_start_agent_req_timer(p_fsm_ctxt, p_fsm_data);
    oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_ACTIVE, OAM_AGENT_GET_LOG_RESP_PENDING);

    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_init_evt_getlogs_rsp
 * Description    : Agent FSM handler for handling GET log response
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_init_evt_getlogs_rsp(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    agent_oam_get_logs_resp_t   *p_get_log_resp;
    oam_agent_get_logs_cnf_t    *p_get_log_cnf;
    oam_error_code_et   err = NO_ERROR;
    UInt8 req_cnt           = OAM_ZERO;
    UInt8 *p_api            = (UInt8*)p_fsm_data->p_api_data;
    SInt32 len              = OAM_ZERO;
    SInt32 msg_size         = OAM_ZERO;
    if (OAM_NULL == p_api)
    {
        OAM_LOG(OAM, OAM_ERROR, "API is null");
        return OAM_FAILURE;
    }
    msg_size = (get_word_from_header(p_api + OAM_INTF_HDR_MSG_SIZE_OFFSET)) - LOWER_LAYER_INTERFACE_HEADER_SIZE;

    oam_stop_agent_req_timer(p_fsm_ctxt, p_fsm_data);

    if (OAM_SUCCESS != oam_mem_alloc(sizeof(agent_oam_get_logs_resp_t), (void*)&p_get_log_resp, &err))
    {
        OAM_LOG(OAM, OAM_ERROR, "Failed to allocate memory for get_log_resp");
    }
    else
    {

        /* Parse message */
        if (OAM_SUCCESS !=
                oam_agnt_parse_agent_oam_get_logs_resp(p_get_log_resp, p_api +
                    LOWER_LAYER_INTERFACE_HEADER_SIZE, msg_size, &len))
        {
            OAM_LOG(OAM, OAM_ERROR,"AGENT->OAM AGENT_OAM_GET_LOGS_RESP parsing failed");	  
            oam_mem_free(p_get_log_resp, &err);
            return OAM_FAILURE;
        }
        else
        {
            OAM_LOG(OAM, OAM_INFO,"AGENT->OAM AGENT_OAM_GET_LOGS_RESP");	  
        }

        /* Pull file on the local path */
        oam_transfer_file(p_get_log_resp->filename.name, p_fsm_data->instance_id,
                OAM_TRUE);

        /* Send message that file transfer is complete remove the file */
        if (OAM_SUCCESS != oam_mem_alloc(sizeof(oam_agent_get_logs_cnf_t), (void*)&p_get_log_cnf, &err))
        {
            OAM_LOG(OAM, OAM_ERROR, "Failed to allocate memory for get_log_cnf");
        }
        else
        {
            p_get_log_cnf->filename.len = p_get_log_resp->filename.len;
            oam_strncpy(p_get_log_cnf->filename.name, p_get_log_resp->filename.name, p_get_log_cnf->filename.len);

            /* Send message */
            oam_agnt_send_oam_agent_get_logs_cnf(p_get_log_cnf, OAM_MODULE_ID, OAM_AGNT_MODULE_ID, OAM_ZERO, p_fsm_data->instance_id);

            oam_mem_free(p_get_log_cnf, &err);
        }

        oam_mem_free(p_get_log_resp, &err);
    }

    oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_ACTIVE, OAM_AGENT_PROCDRE_STATE_INIT);

    req_cnt = oam_prov_req.l2_setup_info.log_req_cnt;
    if (OAM_ZERO < req_cnt)
    {
        req_cnt--;
    }

    if (OAM_ZERO == req_cnt)
    {
        if (OAM_SUCCESS != oam_perform_log_archival())
        {
            OAM_LOG(OAM,OAM_DETAILED, "Logs cannot be archived");
        }
    }

    oam_prov_req.l2_setup_info.log_req_cnt = req_cnt;
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_init_evt_im_ok
 * Description    : This is used for handling event in case of out of sync
 *                  between OAM and agent
 * Inputs         : FSM context and FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_init_evt_im_ok(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    return oam_send_restart_ind(OAM_MODULE_ID, OAM_AGNT_MODULE_ID, OAM_ZERO, p_fsm_data->instance_id);
}

/*************************************************************************
 * Function Name  : oam_agent_st_wspwn_evt_spwn_tmr_exp
 * Description    : This is used for handling timer expiry for spawn request
 *                  sent
 * Inputs         : FSM context and FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_wspwn_evt_spwn_tmr_exp(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    Char8 alarm_str[OAM_ALARM_ADD_TXT_MAX_LEN];
    OAM_LOG(OAM, OAM_ERROR, "Spawn request timed out on instance %u", p_fsm_data->instance_id);
    /* Raise an alarm for operator to look */
    oam_snprintf(alarm_str, sizeof(alarm_str), "Spawn request timed out on instance %u",
            p_fsm_data->instance_id);

    OAM_ALARM(OAM_AGENT_PROCESS_SPAWN_ERROR, CRITICAL,
                    NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                    UNAVAILABLE, EXPEDITED_ALARM,
                    /* Spr 12880 Fix Start*/
                    alarm_str, "Check agent/machine status", OAM_INVALID_CELL_ID);
    p_fsm_ctxt->req_guard_timer = OAM_ZERO;
    p_fsm_ctxt->spawn_retry_cnt = OAM_ZERO;
    oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_ACTIVE, OAM_AGENT_PROCDRE_STATE_INIT);

    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_wkill_evt_kill_tmr_exp
 * Description    : This is used for handling timer expiry for kill request
 *                  sent
 * Inputs         : FSM context and FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_wkill_evt_kill_tmr_exp(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    OAM_LOG(OAM, OAM_INFO, "Kill request timed out on instance %u", p_fsm_data->instance_id);
    oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_INIT, OAM_AGENT_PROCDRE_STATE_INIT);
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_wlog_evt_getlog_tmr_exp
 * Description    : This is used for handling timer expiry for get log request
 *                  sent
 * Inputs         : FSM context and FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_wlog_evt_getlog_tmr_exp(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    UInt8 req_cnt = OAM_ZERO;
    Char8 alarm_str[OAM_ALARM_ADD_TXT_MAX_LEN];
    OAM_LOG(OAM, OAM_WARNING,
            "Get log request timed out on instance %u."
            " Not able to provide logs for it", p_fsm_data->instance_id);

    /* Raise an alarm for operator to look */
    oam_snprintf(alarm_str, sizeof(alarm_str), "Get log request timed out on instance %u.",
            p_fsm_data->instance_id);

    OAM_ALARM(OAM_AGENT_LOG_COLLECTION_FAILED, MAJOR,
                    NOTIFY_NEW_ALARM, PROCESSING_ERROR_ALARM,
                    UNAVAILABLE, EXPEDITED_ALARM,
                    /* Spr 12880 Fix Start*/
                    alarm_str, "Logs will not be available in logs package", OAM_INVALID_CELL_ID);

    oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_ACTIVE, OAM_AGENT_PROCDRE_STATE_INIT);

    req_cnt = oam_prov_req.l2_setup_info.log_req_cnt;
    if (OAM_ZERO < req_cnt)
    {
        req_cnt--;
    }

    if (OAM_ZERO == req_cnt)
    {
        if (OAM_SUCCESS != oam_perform_log_archival())
        {
            OAM_LOG(OAM,OAM_DETAILED, "Logs cannot be archived");
        }
    }

    oam_prov_req.l2_setup_info.log_req_cnt = req_cnt;

    return OAM_SUCCESS;
}
/*************************************************************************
 * Function Name  : oam_agent_st_init_evt_ignore
 * Description    : Agent FSM handler to ignore the events
 * Inputs         : FSM context, FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_init_evt_ignore(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    OAM_LOG(OAM, OAM_WARNING, "Ignoring the event for instance %u", p_fsm_data->instance_id);
    return OAM_FAILURE;
}

/*************************************************************************
 * Function Name  : oam_agent_st_init_evt_ignore_im_ok
 * Description    : This is used for ignoring the periodic IM OK message from
 *                  agent
 * Inputs         : FSM context and FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_init_evt_ignore_im_ok(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    /* Ignoring this message silently */
    OAM_LOG(OAM, OAM_DETAILED, "IM OK received from agent %u", p_fsm_data->instance_id);
    return OAM_SUCCESS;
}

/*************************************************************************
 * Function Name  : oam_agent_st_any_evt_restart
 * Description    : This is used for sending restart message
 * Inputs         : FSM context and FSM data
 * Outputs        : none
 * Returns        : OAM_AGNT_SUCCESS/OAM_AGNT_FAILURE
 ******************************************************************************/
oam_return_et
oam_agent_st_any_evt_restart(oam_agent_fsm_ctxt_t *p_fsm_ctxt, oam_agnt_fsm_data_t *p_fsm_data)
{
    oam_stop_agent_req_timer(p_fsm_ctxt, p_fsm_data);

    oam_agent_state_change(p_fsm_ctxt, OAM_AGENT_STATE_INIT, OAM_AGENT_PROCDRE_STATE_INIT);
    p_fsm_ctxt->spawn_retry_cnt = OAM_ZERO;
    oam_prov_req.l2_setup_info.log_req_cnt = OAM_ZERO;

    return oam_send_restart_ind(OAM_MODULE_ID, OAM_AGNT_MODULE_ID, OAM_ZERO, p_fsm_data->instance_id);
}

oam_agent_func_ptr oam_agent_fsm_tbl[OAM_AGENT_MAX_STATE][OAM_AGENT_MAX_PROCDR_STATE][OAM_AGENT_EVENT_MAX] =
{
    /* OAM_AGENT_STATE_INIT */
    {
        /* OAM_AGENT_PROCDRE_STATE_INIT */
        {
            oam_agent_st_init_evt_ind,      /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_REQ */ 
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_RESP */ 
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,   /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_im_ok,   /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_SPAWN_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore    /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_KILL_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore    /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_GET_LOG_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore    /* OAM_AGENT_EVENT_IM_OK_IND */
        }
    },

    /* OAM_AGENT_STATE_WAIT_ACTIVE */
    {
        /* OAM_AGENT_PROCDRE_STATE_INIT */
        {
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,   /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,   /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore    /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_SPAWN_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,               /* OAM_AGENT_EVENT_IND */
            oam_agent_st_spwn_rsp_evt_spwn_rsp,         /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,               /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,               /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,               /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,               /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_wspwn_evt_spwn_tmr_exp,        /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,               /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok          /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_KILL_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_GET_LOG_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        }
    },

    /* OAM_AGENT_STATE_ACTIVE */
    {
        /* OAM_AGENT_PROCDRE_STATE_INIT */
        {
            oam_agent_st_init_evt_ind,              /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_kill_req,         /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_getlogs,          /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_SPAWN_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok     /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_KILL_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_GET_LOG_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_getlogs_rsp,      /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_wlog_evt_getlog_tmr_exp,   /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_any_evt_restart,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        }
    },

    /* OAM_AGENT_STATE_WAIT_SHUTDOWN */
    {
        /* OAM_AGENT_PROCDRE_STATE_INIT */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_SPAWN_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_KILL_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_kill_rsp_evt_kill_rsp,     /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_wkill_evt_kill_tmr_exp,    /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        },

        /* OAM_AGENT_GET_LOG_RESP_PENDING */
        {
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_IND */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_SPAWN_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_KILL_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_REQ */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_GET_LOGS_RESP */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_PROCEDURE_TMR_EXPIRY */
            oam_agent_st_init_evt_ignore,           /* OAM_AGENT_EVENT_RESTART */
            oam_agent_st_init_evt_ignore_im_ok      /* OAM_AGENT_EVENT_IM_OK_IND */
        }
    }
};
