/******************************************************************************
*   FILE NAME    : oam_enb_mib_tables.c
*
*   DESCRIPTION  : SNMP Agent Init
*
******************************************************************************/
/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <oam_enb_mib_tables.h>
#include <oam_snmp_interface.h>

#define SNMP_OAM_IINFOFREE(pi)  { if(pi) {\
                                    netsnmp_table_registration_info_free(pi->table_reginfo);\
                                    pi->table_reginfo = NULL;\
                                    netsnmp_iterator_delete_table(pi);\
                                    pi = NULL;\
                                }\
                                }

static netsnmp_iterator_info *plmnListTable_iinfo;
static netsnmp_iterator_info *qoSTable_iinfo;
static netsnmp_iterator_info *sfConfigListTable_iinfo;
static netsnmp_iterator_info *carrierTable_iinfo;
static netsnmp_iterator_info *utranFDDFreqTable_iinfo;
static netsnmp_iterator_info *geranFreqGroupTable_iinfo;
static netsnmp_iterator_info *neighborListLTECellTable_iinfo;
static netsnmp_iterator_info *neighborListUMTSTable_iinfo;
static netsnmp_iterator_info *neighborListInUseLTECellTable_iinfo;
static netsnmp_iterator_info *neighborListInUseUMTSTable_iinfo;
static netsnmp_iterator_info *currentAlarmTable_iinfo;
static netsnmp_iterator_info *supportedAlarmTable_iinfo;
static netsnmp_iterator_info *historyEventTable_iinfo;
static netsnmp_iterator_info *expeditedEventTable_iinfo;
static netsnmp_iterator_info *queuedEventTable_iinfo;

#define SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, requests, param_type) \
    retVal = oam_snmp_handle_set_request(handler, reginfo, requests, SNMP_OAM_TABLE_PARAM, param_type); \
	if(retVal != SNMP_ERR_NOERROR)\
	netsnmp_request_set_error(requests, retVal);

static unsigned plmnListTableIndex;
static unsigned plmnListTable_valid_idx_cnt;
static unsigned plmnListTable_num_rows;

static unsigned qoSTableIndex;
static unsigned qoSTable_valid_idx_cnt;
static unsigned qoSTable_num_rows;
/* EMBMS Changes Start */
static unsigned sfConfigListTableIndex;
static unsigned sfConfigListTable_valid_idx_cnt;
static unsigned sfConfigListTable_num_rows;
/* EMBMS Changes End */
static unsigned carrierTableIndex;
static unsigned carrierTable_valid_idx_cnt;
static unsigned carrierTable_num_rows;

static unsigned utranFDDFreqTableIndex;
static unsigned utranFDDFreqTable_valid_idx_cnt;
static unsigned utranFDDFreqTable_num_rows;

static unsigned geranFreqGroupTableIndex;
static unsigned geranFreqGroupTable_valid_idx_cnt;
static unsigned geranFreqGroupTable_num_rows;

static unsigned neighborListLTECellTableIndex;
static unsigned neighborListLTECellTable_valid_idx_cnt;
static unsigned neighborListLTECellTable_num_rows;

static unsigned neighborListUMTSTableIndex;
static unsigned neighborListUMTSTable_valid_idx_cnt;
static unsigned neighborListUMTSTable_num_rows;

static unsigned neighborListInUseLTECellTableIndex;
static unsigned neighborListInUseLTECellTable_valid_idx_cnt;
static unsigned neighborListInUseLTECellTable_num_rows;

static unsigned neighborListInUseUMTSTableIndex;
static unsigned neighborListInUseUMTSTable_valid_idx_cnt;
static unsigned neighborListInUseUMTSTable_num_rows;

static unsigned currentAlarmTableIndex;
static unsigned currentAlarmTable_valid_idx_cnt;
static unsigned currentAlarmTable_num_rows;

static unsigned supportedAlarmTableIndex;
static unsigned supportedAlarmTable_valid_idx_cnt;
static unsigned supportedAlarmTable_num_rows;

static unsigned historyEventTableIndex;
static unsigned historyEventTable_valid_idx_cnt;
static unsigned historyEventTable_num_rows;

static unsigned expeditedEventTableIndex;
static unsigned expeditedEventTable_valid_idx_cnt;
static unsigned expeditedEventTable_num_rows;

static unsigned queuedEventTableIndex;
static unsigned queuedEventTable_valid_idx_cnt;
static unsigned queuedEventTable_num_rows;


/* Function prototype declarations */
int
oam_snmp_handle_set_request
(
 netsnmp_mib_handler *handler,
 netsnmp_handler_registration *reginfo,
 netsnmp_request_info *requests,
 int param_type,
 int val_type
);


extern oam_mgmt_if_param_tab_t snmp_param_table[];


/** returns the first data point within the plmnListTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
plmnListTable_get_first_data_point(void **my_loop_context,
                                   void **my_data_context,
                                   netsnmp_variable_list * put_index_data,
                                   netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(PLMNLIST_TBL_TYPE,
                                           &plmnListTableIndex,
                                           &plmnListTable_valid_idx_cnt,
                                           &plmnListTable_num_rows,
                                           SNMP_OAM_MAX_PLMNLIST_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed plmnListTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &plmnListTableIndex ,
                       sizeof(plmnListTableIndex) );

    return put_index_data;
}

/** functionally the same as plmnListTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
plmnListTable_get_next_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(PLMNLIST_TBL_TYPE,
                                          &plmnListTableIndex,
                                          &plmnListTable_valid_idx_cnt,
                                          plmnListTable_num_rows,
                                          SNMP_OAM_MAX_PLMNLIST_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed plmnListTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;
    vptr = put_index_data;

    snmp_set_var_value(vptr, &plmnListTableIndex ,
                       sizeof(plmnListTableIndex) );

    return put_index_data;
}



/** returns the first data point within the qoSTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
qoSTable_get_first_data_point(void **my_loop_context,
                              void **my_data_context,
                              netsnmp_variable_list * put_index_data,
                              netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_first_row_data(QOS_TBL_TYPE,
                                           &qoSTableIndex ,
                                           &qoSTable_valid_idx_cnt,
                                           &qoSTable_num_rows,
                                           SNMP_OAM_MAX_QOS_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed qoSTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &qoSTableIndex ,
                       sizeof(qoSTableIndex) );

    return put_index_data;
}

/** functionally the same as qoSTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
qoSTable_get_next_data_point(void **my_loop_context,
                             void **my_data_context,
                             netsnmp_variable_list * put_index_data,
                             netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(QOS_TBL_TYPE,
                                          &qoSTableIndex,
                                          &qoSTable_valid_idx_cnt,
                                          qoSTable_num_rows,
                                          SNMP_OAM_MAX_QOS_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed qoSTable_get_next_data_point..., unused paremeter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &qoSTableIndex ,
                       sizeof(qoSTableIndex) );

    return put_index_data;
}


/* EMBMS Changes Start */
/** returns the first data point within the sfConfigListTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
sfConfigListTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_first_row_data(SFCONFIGLIST_TBL_TYPE,
                                           &sfConfigListTableIndex,
                                           &sfConfigListTable_valid_idx_cnt,
                                           &sfConfigListTable_num_rows,
                                           SNMP_OAM_MAX_SFCONFIGLIST_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "\nRow receive failed sfConfigListTable_get_first_data_point...%p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data ;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &sfConfigListTableIndex ,
                       sizeof(sfConfigListTableIndex) );

    return put_index_data;
}

/** functionally the same as sfConfigListTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
sfConfigListTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;

    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(SFCONFIGLIST_TBL_TYPE,
                                          &sfConfigListTableIndex,
                                          &sfConfigListTable_valid_idx_cnt,
                                           sfConfigListTable_num_rows,
                                          SNMP_OAM_MAX_SFCONFIGLIST_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "\nRow receive failed sfConfigListTable_get_next_data_point...%p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }
    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &sfConfigListTableIndex,
                       sizeof(sfConfigListTableIndex) );

    return put_index_data;
}
/* EMBMS Changes End*/

/** returns the first data point within the carrierTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
carrierTable_get_first_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(CARRIER_TBL_TYPE,
                                           &carrierTableIndex,
                                           &carrierTable_valid_idx_cnt,
                                           &carrierTable_num_rows,
                                           SNMP_OAM_MAX_CARRIER_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed carrierTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &carrierTableIndex ,
                       sizeof(carrierTableIndex) );

    return put_index_data;
}

/** functionally the same as carrierTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
carrierTable_get_next_data_point(void **my_loop_context,
                                 void **my_data_context,
                                 netsnmp_variable_list * put_index_data,
                                 netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(CARRIER_TBL_TYPE,
                                          &carrierTableIndex,
                                          &carrierTable_valid_idx_cnt,
                                          carrierTable_num_rows,
                                          SNMP_OAM_MAX_CARRIER_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed carrierTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &carrierTableIndex ,
                       sizeof(carrierTableIndex) );

    return put_index_data;
}



/** returns the first data point within the utranFDDFreqTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
utranFDDFreqTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(UTRANFDDFREQ_TBL_DATA,
                                           &utranFDDFreqTableIndex ,
                                           &utranFDDFreqTable_valid_idx_cnt,
                                           &utranFDDFreqTable_num_rows,
                                           SNMP_OAM_MAX_UTRANFDDFREQ_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed utranFDDFreqTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &utranFDDFreqTableIndex ,
                       sizeof(utranFDDFreqTableIndex) );

    return put_index_data;
}

/** functionally the same as utranFDDFreqTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
utranFDDFreqTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(UTRANFDDFREQ_TBL_DATA,
                                          &utranFDDFreqTableIndex,
                                          &utranFDDFreqTable_valid_idx_cnt,
                                          utranFDDFreqTable_num_rows,
                                          SNMP_OAM_MAX_UTRANFDDFREQ_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed utranFDDFreqTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &utranFDDFreqTableIndex ,
                       sizeof(utranFDDFreqTableIndex) );

    return put_index_data;
}


/** returns the first data point within the geranFreqGroupTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
geranFreqGroupTable_get_first_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(GERANFREQGROUP_TBL_TYPE,
                                           &geranFreqGroupTableIndex,
                                           &geranFreqGroupTable_valid_idx_cnt,
                                           &geranFreqGroupTable_num_rows,
                                           SNMP_OAM_MAX_GERANFREQGROUP_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed geranFreqGroupTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &geranFreqGroupTableIndex ,
                       sizeof(geranFreqGroupTableIndex) );

    return put_index_data;
}

/** functionally the same as geranFreqGroupTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
geranFreqGroupTable_get_next_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(GERANFREQGROUP_TBL_TYPE,
                                          &geranFreqGroupTableIndex,
                                          &geranFreqGroupTable_valid_idx_cnt,
                                          geranFreqGroupTable_num_rows,
                                          SNMP_OAM_MAX_GERANFREQGROUP_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed geranFreqGroupTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &geranFreqGroupTableIndex ,
                       sizeof(geranFreqGroupTableIndex) );

    return put_index_data;
}



/** returns the first data point within the neighborListLTECellTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
neighborListLTECellTable_get_first_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(NEIGHBORLISTLTECELL_TBL_TYPE,
                                           &neighborListLTECellTableIndex,
                                           &neighborListLTECellTable_valid_idx_cnt,
                                           &neighborListLTECellTable_num_rows,
                                           SNMP_OAM_MAX_NEIGHBORLISTLTECELL_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed neighborListLTECellTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &neighborListLTECellTableIndex ,
                       sizeof(neighborListLTECellTableIndex) );

    return put_index_data;
}

/** functionally the same as neighborListLTECellTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
neighborListLTECellTable_get_next_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(NEIGHBORLISTLTECELL_TBL_TYPE,
                                          &neighborListLTECellTableIndex,
                                          &neighborListLTECellTable_valid_idx_cnt,
                                          neighborListLTECellTable_num_rows,
                                          SNMP_OAM_MAX_NEIGHBORLISTLTECELL_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed neighborListLTECellTable_get_next_data_point..., unused parametrer %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &neighborListLTECellTableIndex ,
                       sizeof(neighborListLTECellTableIndex) );

    return put_index_data;
}



/** returns the first data point within the neighborListUMTSTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
neighborListUMTSTable_get_first_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(NEIGHBORLISTUMTS_TBL_TYPE,
                                           &neighborListUMTSTableIndex,
                                           &neighborListUMTSTable_valid_idx_cnt,
                                           &neighborListUMTSTable_num_rows,
                                           SNMP_OAM_MAX_NEIGHBORLISTUMTS_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed neighborListUMTSTable_get_first_data_point..., unused parametrer %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &neighborListUMTSTableIndex ,
                       sizeof(neighborListUMTSTableIndex) );

    return put_index_data;
}

/** functionally the same as neighborListUMTSTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
neighborListUMTSTable_get_next_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(NEIGHBORLISTUMTS_TBL_TYPE,
                                          &neighborListUMTSTableIndex,
                                          &neighborListUMTSTable_valid_idx_cnt,
                                          neighborListUMTSTable_num_rows,
                                          SNMP_OAM_MAX_NEIGHBORLISTUMTS_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed neighborListUMTSTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &neighborListUMTSTableIndex ,
                       sizeof(neighborListUMTSTableIndex) );

    return put_index_data;
}



/** returns the first data point within the neighborListInUseLTECellTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
neighborListInUseLTECellTable_get_first_data_point(void **my_loop_context,
                                                   void **my_data_context,
                                                   netsnmp_variable_list *
                                                   put_index_data,
                                                   netsnmp_iterator_info
                                                   *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(NEIGHBORLISTINUSELTECELL_TBL_TYPE,
                                           &neighborListInUseLTECellTableIndex,
                                           &neighborListInUseLTECellTable_valid_idx_cnt,
                                           &neighborListInUseLTECellTable_num_rows,
                                           SNMP_OAM_MAX_NEIGHBORLISTINUSELTECELL_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed neighborListInUseLTECellTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &neighborListInUseLTECellTableIndex ,
                       sizeof(neighborListInUseLTECellTableIndex) );

    return put_index_data;
}

/** functionally the same as neighborListInUseLTECellTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
neighborListInUseLTECellTable_get_next_data_point(void **my_loop_context,
                                                  void **my_data_context,
                                                  netsnmp_variable_list *
                                                  put_index_data,
                                                  netsnmp_iterator_info
                                                  *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(NEIGHBORLISTINUSELTECELL_TBL_TYPE,
                                          &neighborListInUseLTECellTableIndex,
                                          &neighborListInUseLTECellTable_valid_idx_cnt,
                                          neighborListInUseLTECellTable_num_rows,
                                          SNMP_OAM_MAX_NEIGHBORLISTINUSELTECELL_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed neighborListInUseLTECellTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &neighborListInUseLTECellTableIndex ,
                       sizeof(neighborListInUseLTECellTableIndex) );

    return put_index_data;
}



/** returns the first data point within the neighborListInUseUMTSTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
neighborListInUseUMTSTable_get_first_data_point(void **my_loop_context,
                                                void **my_data_context,
                                                netsnmp_variable_list *
                                                put_index_data,
                                                netsnmp_iterator_info
                                                *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(NEIGHBORLISTINUSEUMTS_TBL_TYPE,
                                           &neighborListInUseUMTSTableIndex,
                                           &neighborListInUseUMTSTable_valid_idx_cnt,
                                           &neighborListInUseUMTSTable_num_rows,
                                           SNMP_OAM_MAX_NEIGHBORLISTINUSEUMTS_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed neighborListInUseUMTSTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &neighborListInUseUMTSTableIndex ,
                       sizeof(neighborListInUseUMTSTableIndex) );

    return put_index_data;
}

/** functionally the same as neighborListInUseUMTSTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
neighborListInUseUMTSTable_get_next_data_point(void **my_loop_context,
                                               void **my_data_context,
                                               netsnmp_variable_list *
                                               put_index_data,
                                               netsnmp_iterator_info
                                               *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(NEIGHBORLISTINUSEUMTS_TBL_TYPE,
                                          &neighborListInUseUMTSTableIndex,
                                          &neighborListInUseUMTSTable_valid_idx_cnt,
                                          neighborListInUseUMTSTable_num_rows,
                                          SNMP_OAM_MAX_NEIGHBORLISTINUSEUMTS_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed neighborListInUseUMTSTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &neighborListInUseUMTSTableIndex ,
                       sizeof(neighborListInUseUMTSTableIndex) );

    return put_index_data;
}



/** returns the first data point within the currentAlarmTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
currentAlarmTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(CURRENTALARM_TBL_TYPE,
                                           &currentAlarmTableIndex,
                                           &currentAlarmTable_valid_idx_cnt,
                                           &currentAlarmTable_num_rows,
                                           SNMP_OAM_MAX_CURRENTALARM_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed currentAlarmTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &currentAlarmTableIndex ,
                       sizeof(currentAlarmTableIndex) );

    return put_index_data;
}

/** functionally the same as currentAlarmTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
currentAlarmTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(CURRENTALARM_TBL_TYPE,
                                          &currentAlarmTableIndex,
                                          &currentAlarmTable_valid_idx_cnt,
                                          currentAlarmTable_num_rows,
                                          SNMP_OAM_MAX_CURRENTALARM_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
        /* SPR 17777 fix */
               "Row receive failed currentAlarmTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &currentAlarmTableIndex ,
                       sizeof(currentAlarmTableIndex) );

    return put_index_data;
}



/** returns the first data point within the supportedAlarmTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
supportedAlarmTable_get_first_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(SUPPORTEDALARM_TBL_TYPE,
                                           &supportedAlarmTableIndex,
                                           &supportedAlarmTable_valid_idx_cnt,
                                           &supportedAlarmTable_num_rows,
                                           SNMP_OAM_MAX_SUPPORTEDALARM_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
        /* SPR 17777 fix */
               "Row receive failed supportedAlarmTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &supportedAlarmTableIndex ,
                       sizeof(supportedAlarmTableIndex) );

    return put_index_data;
}

/** functionally the same as supportedAlarmTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
supportedAlarmTable_get_next_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(SUPPORTEDALARM_TBL_TYPE,
                                          &supportedAlarmTableIndex,
                                          &supportedAlarmTable_valid_idx_cnt,
                                          supportedAlarmTable_num_rows,
                                          SNMP_OAM_MAX_SUPPORTEDALARM_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed supportedAlarmTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &supportedAlarmTableIndex ,
                       sizeof(supportedAlarmTableIndex) );

    return put_index_data;
}



/** returns the first data point within the historyEventTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
historyEventTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(HISTORYEVENT_TBL_TYPE,
                                           &historyEventTableIndex,
                                           &historyEventTable_valid_idx_cnt,
                                           &historyEventTable_num_rows,
                                           SNMP_OAM_MAX_HISTORYEVENT_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed historyEventTable_get_first_data_point..., unused parametere %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &historyEventTableIndex ,
                       sizeof(historyEventTableIndex) );

    return put_index_data;
}

/** functionally the same as historyEventTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
historyEventTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(HISTORYEVENT_TBL_TYPE,
                                          &historyEventTableIndex,
                                          &historyEventTable_valid_idx_cnt,
                                          historyEventTable_num_rows,
                                          SNMP_OAM_MAX_HISTORYEVENT_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed historyEventTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &historyEventTableIndex ,
                       sizeof(historyEventTableIndex) );

    return put_index_data;
}



/** returns the first data point within the expeditedEventTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
expeditedEventTable_get_first_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(EXPEDITEDEVENT_TBL_TYPE,
                                           &expeditedEventTableIndex,
                                           &expeditedEventTable_valid_idx_cnt,
                                           &expeditedEventTable_num_rows,
                                           SNMP_OAM_MAX_EXPEDITEDEVENT_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed expeditedEventTable_get_first_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &expeditedEventTableIndex ,
                       sizeof(expeditedEventTableIndex) );

    return put_index_data;
}

/** functionally the same as expeditedEventTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
expeditedEventTable_get_next_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(EXPEDITEDEVENT_TBL_TYPE,
                                          &expeditedEventTableIndex,
                                          &expeditedEventTable_valid_idx_cnt,
                                          expeditedEventTable_num_rows,
                                          SNMP_OAM_MAX_EXPEDITEDEVENT_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed expeditedEventTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &expeditedEventTableIndex ,
                       sizeof(expeditedEventTableIndex) );

    return put_index_data;
}



/** returns the first data point within the queuedEventTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
queuedEventTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;


    row_data = snmp_oam_get_first_row_data(QUEUEDEVENT_TBL_TYPE,
                                           &queuedEventTableIndex,
                                           &queuedEventTable_valid_idx_cnt,
                                           &queuedEventTable_num_rows,
                                           SNMP_OAM_MAX_QUEUEDEVENT_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed queuedEventTable_get_first_data_point..., unused param %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }

    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &queuedEventTableIndex ,
                       sizeof(queuedEventTableIndex) );

    return put_index_data;
}

/** functionally the same as queuedEventTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it to your local data type and
   then return my_loop_context->next.  The my_data_context pointer
   should be set to something you need later and the indexes in
   put_index_data updated again. */
netsnmp_variable_list *
queuedEventTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{

    netsnmp_variable_list *vptr;
    oam_mgmt_if_get_resp_t *row_data = NULL;

    row_data = snmp_oam_get_next_row_data(QUEUEDEVENT_TBL_TYPE,
                                          &queuedEventTableIndex,
                                          &queuedEventTable_valid_idx_cnt,
                                          queuedEventTable_num_rows,
                                          SNMP_OAM_MAX_QUEUEDEVENT_TABLE_ENTRIES);
    
    if(!row_data) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
               "Row receive failed queuedEventTable_get_next_data_point..., unused parameter %p", mydata);
        *my_loop_context = NULL;
        return NULL;
    }


    *my_data_context = row_data;

    vptr = put_index_data;

    snmp_set_var_value(vptr, &queuedEventTableIndex ,
                       sizeof(queuedEventTableIndex) );

    return put_index_data;
}


/** Initialize the plmnListTable table by defining its contents and how it's structured */
void
initialize_table_plmnListTable(void)
{
    const oid       plmnListTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 8 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table plmnListTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    plmnListTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("260",
                                                     plmnListTable_handler,
                                                     plmnListTable_oid,
                                                     OID_LENGTH
                                                     (plmnListTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !plmnListTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(plmnListTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_plmnListTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: plmnListTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_PLMNLISTTBLENABLE;
    table_info->max_column = COLUMN_PLMNLISTTBLCELLRESERVEDFOROPERATORUSE;

    /** iterator access routines */
    plmnListTable_iinfo->get_first_data_point = plmnListTable_get_first_data_point;
    plmnListTable_iinfo->get_next_data_point = plmnListTable_get_next_data_point;
    plmnListTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    plmnListTable_iinfo->make_data_context = plmnListTable_context_convert_function;

    /** pick *only* one of these if you use them */
    plmnListTable_iinfo->free_loop_context = plmnListTable_loop_free;
    plmnListTable_iinfo->free_loop_context_at_end = plmnListTable_loop_free;
#endif

    /** tie the two structures together */
    plmnListTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_plmnListTable",
                "Registering table plmnListTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, plmnListTable_iinfo);
}

/** Initialize the qoSTable table by defining its contents and how it's structured */
void
initialize_table_qoSTable(void)
{
    const oid       qoSTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 9 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table qoSTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    qoSTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("265",
                                                     qoSTable_handler,
                                                     qoSTable_oid,
                                                     OID_LENGTH
                                                     (qoSTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !qoSTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(qoSTable_iinfo);

        snmp_log(LOG_ERR, "malloc failed in initialize_table_qoSTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: qoSTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_QOSTBLQCI;
    table_info->max_column = COLUMN_QOSTBLPACKETDELAYBUDGET;

    /** iterator access routines */
    qoSTable_iinfo->get_first_data_point = qoSTable_get_first_data_point;
    qoSTable_iinfo->get_next_data_point = qoSTable_get_next_data_point;
    qoSTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    qoSTable_iinfo->make_data_context = qoSTable_context_convert_function;
    qoSTable_iinfo->free_data_context = qoSTable_data_free;

    /** pick *only* one of these if you use them */
    qoSTable_iinfo->free_loop_context = qoSTable_loop_free;
    qoSTable_iinfo->free_loop_context_at_end = qoSTable_loop_free;
#endif

    /** tie the two structures together */
    qoSTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_qoSTable",
                "Registering table qoSTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, qoSTable_iinfo);
}

/* EMBMS Changes Start*/
/** Initialize the sfConfigListTable table by defining its contents 
 * and how it's structured */
void
initialize_table_sfConfigListTable(void)
{
    const oid       sfConfigListTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 8, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table sfConfigListTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    sfConfigListTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    my_handler = netsnmp_create_handler_registration("392",
                                                     sfConfigListTable_handler,
                                                     sfConfigListTable_oid,
                                                     OID_LENGTH
                                                     (sfConfigListTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !sfConfigListTable_iinfo) {
        SNMP_FREE(table_info);
        SNMP_FREE(sfConfigListTable_iinfo);
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_sfConfigListTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: sfConfigListTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_SFCONFIGLISTTBLSYNCSTRATUMID;
    table_info->max_column = COLUMN_SFCONFIGLISTTBLSUBFRAMEALLOCATIONS;

    /** iterator access routines */
    sfConfigListTable_iinfo->get_first_data_point = sfConfigListTable_get_first_data_point;
    sfConfigListTable_iinfo->get_next_data_point = sfConfigListTable_get_next_data_point;
    sfConfigListTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    sfConfigListTable_iinfo->make_data_context = sfConfigListTable_context_convert_function;
    sfConfigListTable_iinfo->free_data_context = sfConfigListTable_data_free;

    /** pick *only* one of these if you use them */
    sfConfigListTable_iinfo->free_loop_context = sfConfigListTable_loop_free;
    sfConfigListTable_iinfo->free_loop_context_at_end = sfConfigListTable_loop_free;
#endif

    /** tie the two structures together */
    sfConfigListTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_sfConfigListTable",
                "Registering table sfConfigListTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, sfConfigListTable_iinfo);
}
/* EMBMS Changes End*/
/** Initialize the carrierTable table by defining its contents and how it's structured */
void
initialize_table_carrierTable(void)
{
    const oid       carrierTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 3, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table carrierTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    carrierTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("270",
                                                     carrierTable_handler,
                                                     carrierTable_oid,
                                                     OID_LENGTH
                                                     (carrierTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !carrierTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(carrierTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_carrierTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: carrierTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_CARRIERTBLEUTRACARRIERARFCN;
    table_info->max_column = COLUMN_CARRIERTBLCELLRESELECTIONPRIORITY;

    /** iterator access routines */
    carrierTable_iinfo->get_first_data_point = carrierTable_get_first_data_point;
    carrierTable_iinfo->get_next_data_point = carrierTable_get_next_data_point;
    carrierTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    carrierTable_iinfo->make_data_context = carrierTable_context_convert_function;
    carrierTable_iinfo->free_data_context = carrierTable_data_free;

    /** pick *only* one of these if you use them */
    carrierTable_iinfo->free_loop_context = carrierTable_loop_free;
    carrierTable_iinfo->free_loop_context_at_end = carrierTable_loop_free;
#endif

    /** tie the two structures together */
    carrierTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_carrierTable",
                "Registering table carrierTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, carrierTable_iinfo);
}

/** Initialize the utranFDDFreqTable table by defining its contents and how it's structured */
void
initialize_table_utranFDDFreqTable(void)
{
    const oid       utranFDDFreqTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 4, 1,
5 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table utranFDDFreqTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    utranFDDFreqTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("281",
                                                     utranFDDFreqTable_handler,
                                                     utranFDDFreqTable_oid,
                                                     OID_LENGTH
                                                     (utranFDDFreqTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !utranFDDFreqTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(utranFDDFreqTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_utranFDDFreqTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: utranFDDFreqTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_UTRANFDDFREQTBLUTRACARRIERARFCN;
    table_info->max_column = COLUMN_UTRANFDDFREQTBLPMAXUTRA;

    /** iterator access routines */
    utranFDDFreqTable_iinfo->get_first_data_point = utranFDDFreqTable_get_first_data_point;
    utranFDDFreqTable_iinfo->get_next_data_point = utranFDDFreqTable_get_next_data_point;
    utranFDDFreqTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    utranFDDFreqTable_iinfo->make_data_context = utranFDDFreqTable_context_convert_function;
    utranFDDFreqTable_iinfo->free_data_context = utranFDDFreqTable_data_free;

    /** pick *only* one of these if you use them */
    utranFDDFreqTable_iinfo->free_loop_context = utranFDDFreqTable_loop_free;
    utranFDDFreqTable_iinfo->free_loop_context_at_end = utranFDDFreqTable_loop_free;
#endif

    /** tie the two structures together */
    utranFDDFreqTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_utranFDDFreqTable",
                "Registering table utranFDDFreqTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, utranFDDFreqTable_iinfo);
}

/** Initialize the geranFreqGroupTable table by defining its contents and how it's structured */
void
initialize_table_geranFreqGroupTable(void)
{
    const oid       geranFreqGroupTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 4, 2,
1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table geranFreqGroupTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    geranFreqGroupTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("289",
                                                     geranFreqGroupTable_handler,
                                                     geranFreqGroupTable_oid,
                                                     OID_LENGTH
                                                     (geranFreqGroupTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !geranFreqGroupTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(geranFreqGroupTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_geranFreqGroupTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: geranFreqGroupTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_GERANFREQGROUPTBLQRXLEVMIN;
    table_info->max_column = COLUMN_GERANFREQGROUPTBLTHRESHXLOW;

    /** iterator access routines */
    geranFreqGroupTable_iinfo->get_first_data_point = geranFreqGroupTable_get_first_data_point;
    geranFreqGroupTable_iinfo->get_next_data_point = geranFreqGroupTable_get_next_data_point;
    geranFreqGroupTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    geranFreqGroupTable_iinfo->make_data_context =
        geranFreqGroupTable_context_convert_function;
    geranFreqGroupTable_iinfo->free_data_context = geranFreqGroupTable_data_free;

    /** pick *only* one of these if you use them */
    geranFreqGroupTable_iinfo->free_loop_context = geranFreqGroupTable_loop_free;
    geranFreqGroupTable_iinfo->free_loop_context_at_end = geranFreqGroupTable_loop_free;
#endif

    /** tie the two structures together */
    geranFreqGroupTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_geranFreqGroupTable",
                "Registering table geranFreqGroupTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, geranFreqGroupTable_iinfo);
}

/** Initialize the neighborListLTECellTable table by defining its contents and how it's structured */
void
initialize_table_neighborListLTECellTable(void)
{
    const oid       neighborListLTECellTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 10, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init",
                "initializing table neighborListLTECellTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    neighborListLTECellTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler =
        netsnmp_create_handler_registration("294",
                                            neighborListLTECellTable_handler,
                                            neighborListLTECellTable_oid,
                                            OID_LENGTH
                                            (neighborListLTECellTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !neighborListLTECellTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(neighborListLTECellTable_iinfo);
        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_neighborListLTECellTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: neighborListLTECellTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_NEIGHBORLISTLTECELLTBLPLMNID;
    table_info->max_column = COLUMN_NEIGHBORLISTLTECELLTBLBLACKLISTED;

    /** iterator access routines */
    neighborListLTECellTable_iinfo->get_first_data_point =
        neighborListLTECellTable_get_first_data_point;
    neighborListLTECellTable_iinfo->get_next_data_point =
        neighborListLTECellTable_get_next_data_point;
    neighborListLTECellTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    neighborListLTECellTable_iinfo->make_data_context =
        neighborListLTECellTable_context_convert_function;
    neighborListLTECellTable_iinfo->free_data_context = neighborListLTECellTable_data_free;

    /** pick *only* one of these if you use them */
    neighborListLTECellTable_iinfo->free_loop_context = neighborListLTECellTable_loop_free;
    neighborListLTECellTable_iinfo->free_loop_context_at_end = neighborListLTECellTable_loop_free;
#endif

    /** tie the two structures together */
    neighborListLTECellTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_neighborListLTECellTable",
                "Registering table neighborListLTECellTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, neighborListLTECellTable_iinfo);
}

/** Initialize the neighborListUMTSTable table by defining its contents and how it's structured */
void
initialize_table_neighborListUMTSTable(void)
{
    const oid       neighborListUMTSTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 10, 4, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table neighborListUMTSTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    neighborListUMTSTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler =
        netsnmp_create_handler_registration("302",
                                            neighborListUMTSTable_handler,
                                            neighborListUMTSTable_oid,
                                            OID_LENGTH
                                            (neighborListUMTSTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !neighborListUMTSTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(neighborListUMTSTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_neighborListUMTSTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: neighborListUMTSTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_NEIGHBORLISTUMTSTBLPLMNID;
    table_info->max_column = COLUMN_NEIGHBORLISTUMTSTBLUARFCNDL;

    /** iterator access routines */
    neighborListUMTSTable_iinfo->get_first_data_point =
        neighborListUMTSTable_get_first_data_point;
    neighborListUMTSTable_iinfo->get_next_data_point = neighborListUMTSTable_get_next_data_point;
    neighborListUMTSTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    neighborListUMTSTable_iinfo->make_data_context =
        neighborListUMTSTable_context_convert_function;
    neighborListUMTSTable_iinfo->free_data_context = neighborListUMTSTable_data_free;

    /** pick *only* one of these if you use them */
    neighborListUMTSTable_iinfo->free_loop_context = neighborListUMTSTable_loop_free;
    neighborListUMTSTable_iinfo->free_loop_context_at_end = neighborListUMTSTable_loop_free;
#endif

    /** tie the two structures together */
    neighborListUMTSTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_neighborListUMTSTable",
                "Registering table neighborListUMTSTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, neighborListUMTSTable_iinfo);
}

/** Initialize the neighborListInUseLTECellTable table by defining its contents and how it's structured */
void
initialize_table_neighborListInUseLTECellTable(void)
{
    const oid       neighborListInUseLTECellTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 11, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init",
                "initializing table neighborListInUseLTECellTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    neighborListInUseLTECellTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("309",
                             neighborListInUseLTECellTable_handler,
                             neighborListInUseLTECellTable_oid,
                             OID_LENGTH(neighborListInUseLTECellTable_oid),
                             HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !neighborListInUseLTECellTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(neighborListInUseLTECellTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_neighborListInUseLTECellTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: neighborListInUseLTECellTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_NEIGHBORLISTINUSELTECELLTBLPLMNID;
    table_info->max_column = COLUMN_NEIGHBORLISTINUSELTECELLTBLBLACKLISTED;

    /** iterator access routines */
    neighborListInUseLTECellTable_iinfo->get_first_data_point =
        neighborListInUseLTECellTable_get_first_data_point;
    neighborListInUseLTECellTable_iinfo->get_next_data_point =
        neighborListInUseLTECellTable_get_next_data_point;
    neighborListInUseLTECellTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    neighborListInUseLTECellTable_iinfo->make_data_context =
        neighborListInUseLTECellTable_context_convert_function;
    neighborListInUseLTECellTable_iinfo->free_data_context = neighborListInUseLTECellTable_data_free;

    /** pick *only* one of these if you use them */
    neighborListInUseLTECellTable_iinfo->free_loop_context = neighborListInUseLTECellTable_loop_free;
    neighborListInUseLTECellTable_iinfo->free_loop_context_at_end =
        neighborListInUseLTECellTable_loop_free;
#endif

    /** tie the two structures together */
    neighborListInUseLTECellTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_neighborListInUseLTECellTable",
                "Registering table neighborListInUseLTECellTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, neighborListInUseLTECellTable_iinfo);
}

/** Initialize the neighborListInUseUMTSTable table by defining its contents and how it's structured */
void
initialize_table_neighborListInUseUMTSTable(void)
{
    const oid       neighborListInUseUMTSTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 11, 4, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init",
                "initializing table neighborListInUseUMTSTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    neighborListInUseUMTSTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler =
        netsnmp_create_handler_registration("316",
                                            neighborListInUseUMTSTable_handler,
                                            neighborListInUseUMTSTable_oid,
                                            OID_LENGTH
                                            (neighborListInUseUMTSTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !neighborListInUseUMTSTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(neighborListInUseUMTSTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_neighborListInUseUMTSTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: neighborListInUseUMTSTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_NEIGHBORLISTINUSEUMTSTBLPLMNID;
    table_info->max_column = COLUMN_NEIGHBORLISTINUSEUMTSTBLUARFCNDL;

    /** iterator access routines */
    neighborListInUseUMTSTable_iinfo->get_first_data_point =
        neighborListInUseUMTSTable_get_first_data_point;
    neighborListInUseUMTSTable_iinfo->get_next_data_point =
        neighborListInUseUMTSTable_get_next_data_point;
    neighborListInUseUMTSTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    neighborListInUseUMTSTable_iinfo->make_data_context =
        neighborListInUseUMTSTable_context_convert_function;
    neighborListInUseUMTSTable_iinfo->free_data_context = neighborListInUseUMTSTable_data_free;

    /** pick *only* one of these if you use them */
    neighborListInUseUMTSTable_iinfo->free_loop_context = neighborListInUseUMTSTable_loop_free;
    neighborListInUseUMTSTable_iinfo->free_loop_context_at_end = neighborListInUseUMTSTable_loop_free;
#endif

    /** tie the two structures together */
    neighborListInUseUMTSTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_neighborListInUseUMTSTable",
                "Registering table neighborListInUseUMTSTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, neighborListInUseUMTSTable_iinfo);
}

/** Initialize the currentAlarmTable table by defining its contents and how it's structured */
void
initialize_table_currentAlarmTable(void)
{
    const oid       currentAlarmTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 7 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table currentAlarmTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    currentAlarmTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("323",
                                                     currentAlarmTable_handler,
                                                     currentAlarmTable_oid,
                                                     OID_LENGTH
                                                     (currentAlarmTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !currentAlarmTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(currentAlarmTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_currentAlarmTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: currentAlarmTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_CURRENTALARMTBLALARMIDENTIFIER;
    table_info->max_column = COLUMN_CURRENTALARMTBLADDITIONALINFORMATION;

    /** iterator access routines */
    currentAlarmTable_iinfo->get_first_data_point = currentAlarmTable_get_first_data_point;
    currentAlarmTable_iinfo->get_next_data_point = currentAlarmTable_get_next_data_point;
    currentAlarmTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    currentAlarmTable_iinfo->make_data_context = currentAlarmTable_context_convert_function;
    currentAlarmTable_iinfo->free_data_context = currentAlarmTable_data_free;

    /** pick *only* one of these if you use them */
    currentAlarmTable_iinfo->free_loop_context = currentAlarmTable_loop_free;
    currentAlarmTable_iinfo->free_loop_context_at_end = currentAlarmTable_loop_free;
#endif

    /** tie the two structures together */
    currentAlarmTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_currentAlarmTable",
                "Registering table currentAlarmTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, currentAlarmTable_iinfo);
}

/** Initialize the supportedAlarmTable table by defining its contents and how it's structured */
void
initialize_table_supportedAlarmTable(void)
{
    const oid       supportedAlarmTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 8 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table supportedAlarmTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    supportedAlarmTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("334",
                                                     supportedAlarmTable_handler,
                                                     supportedAlarmTable_oid,
                                                     OID_LENGTH
                                                     (supportedAlarmTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !supportedAlarmTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(supportedAlarmTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_supportedAlarmTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: supportedAlarmTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_SUPPORTEDALARMTBLEVENTTYPE;
    table_info->max_column = COLUMN_SUPPORTEDALARMTBLREPORTINGMECHANISM;

    /** iterator access routines */
    supportedAlarmTable_iinfo->get_first_data_point = supportedAlarmTable_get_first_data_point;
    supportedAlarmTable_iinfo->get_next_data_point = supportedAlarmTable_get_next_data_point;
    supportedAlarmTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    supportedAlarmTable_iinfo->make_data_context =
        supportedAlarmTable_context_convert_function;
    supportedAlarmTable_iinfo->free_data_context = supportedAlarmTable_data_free;

    /** pick *only* one of these if you use them */
    supportedAlarmTable_iinfo->free_loop_context = supportedAlarmTable_loop_free;
    supportedAlarmTable_iinfo->free_loop_context_at_end = supportedAlarmTable_loop_free;
#endif

    /** tie the two structures together */
    supportedAlarmTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_supportedAlarmTable",
                "Registering table supportedAlarmTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, supportedAlarmTable_iinfo);
}

/** Initialize the historyEventTable table by defining its contents and how it's structured */
void
initialize_table_historyEventTable(void)
{
    const oid       historyEventTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 9 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table historyEventTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    historyEventTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("340",
                                                     historyEventTable_handler,
                                                     historyEventTable_oid,
                                                     OID_LENGTH
                                                     (historyEventTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !historyEventTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(historyEventTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_historyEventTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: historyEventTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_HISTORYEVENTTBLEVENTTIME;
    table_info->max_column = COLUMN_HISTORYEVENTTBLADDITIONALINFORMATION;

    /** iterator access routines */
    historyEventTable_iinfo->get_first_data_point = historyEventTable_get_first_data_point;
    historyEventTable_iinfo->get_next_data_point = historyEventTable_get_next_data_point;
    historyEventTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    historyEventTable_iinfo->make_data_context = historyEventTable_context_convert_function;
    historyEventTable_iinfo->free_data_context = historyEventTable_data_free;

    /** pick *only* one of these if you use them */
    historyEventTable_iinfo->free_loop_context = historyEventTable_loop_free;
    historyEventTable_iinfo->free_loop_context_at_end = historyEventTable_loop_free;
#endif

    /** tie the two structures together */
    historyEventTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_historyEventTable",
                "Registering table historyEventTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, historyEventTable_iinfo);
}

/** Initialize the expeditedEventTable table by defining its contents and how it's structured */
void
initialize_table_expeditedEventTable(void)
{
    const oid       expeditedEventTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 10 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table expeditedEventTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    expeditedEventTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("351",
                                                     expeditedEventTable_handler,
                                                     expeditedEventTable_oid,
                                                     OID_LENGTH
                                                     (expeditedEventTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !expeditedEventTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(expeditedEventTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_expeditedEventTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: expeditedEventTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_EXPEDITEDEVENTTBLEVENTTIME;
    table_info->max_column = COLUMN_EXPEDITEDEVENTTBLADDITIONALINFORMATION;

    /** iterator access routines */
    expeditedEventTable_iinfo->get_first_data_point = expeditedEventTable_get_first_data_point;
    expeditedEventTable_iinfo->get_next_data_point = expeditedEventTable_get_next_data_point;
    expeditedEventTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    expeditedEventTable_iinfo->make_data_context =
        expeditedEventTable_context_convert_function;
    expeditedEventTable_iinfo->free_data_context = expeditedEventTable_data_free;

    /** pick *only* one of these if you use them */
    expeditedEventTable_iinfo->free_loop_context = expeditedEventTable_loop_free;
    expeditedEventTable_iinfo->free_loop_context_at_end = expeditedEventTable_loop_free;
#endif

    /** tie the two structures together */
    expeditedEventTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_expeditedEventTable",
                "Registering table expeditedEventTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, expeditedEventTable_iinfo);
}

/** Initialize the queuedEventTable table by defining its contents and how it's structured */
void
initialize_table_queuedEventTable(void)
{
    const oid       queuedEventTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 11 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;

    DEBUGMSGTL(("enb:init", "initializing table queuedEventTable\n"));

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    queuedEventTable_iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    my_handler = netsnmp_create_handler_registration("362",
                                                     queuedEventTable_handler,
                                                     queuedEventTable_oid,
                                                     OID_LENGTH
                                                     (queuedEventTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !queuedEventTable_iinfo) {
        /*  CID: 52824 to 52853 fix :VKG */
        SNMP_FREE(table_info);
        SNMP_FREE(queuedEventTable_iinfo);

        snmp_log(LOG_ERR,
                 "malloc failed in initialize_table_queuedEventTable");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_UNSIGNED,
                                                /** index: queuedEventTblIndex */
                                     0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrieval. */
    table_info->min_column = COLUMN_QUEUEDEVENTTBLEVENTTIME;
    table_info->max_column = COLUMN_QUEUEDEVENTTBLADDITIONALINFORMATION;

    /** iterator access routines */
    queuedEventTable_iinfo->get_first_data_point = queuedEventTable_get_first_data_point;
    queuedEventTable_iinfo->get_next_data_point = queuedEventTable_get_next_data_point;
    queuedEventTable_iinfo->free_data_context = snmp_oam_free_data_cntxt;

    /** you may wish to set these as well */
#ifdef MAYBE_USE_THESE
    queuedEventTable_iinfo->make_data_context = queuedEventTable_context_convert_function;
    queuedEventTable_iinfo->free_data_context = queuedEventTable_data_free;

    /** pick *only* one of these if you use them */
    queuedEventTable_iinfo->free_loop_context = queuedEventTable_loop_free;
    queuedEventTable_iinfo->free_loop_context_at_end = queuedEventTable_loop_free;
#endif

    /** tie the two structures together */
    queuedEventTable_iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_queuedEventTable",
                "Registering table queuedEventTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, queuedEventTable_iinfo);
}

/** Initializes the enb module */
void
init_oam_enb_mib_tables(void)
{

  /** here we initialize all the tables we're planning on supporting */
    initialize_table_plmnListTable();
    initialize_table_qoSTable();
    /* EMBMS Changes Start*/
    initialize_table_sfConfigListTable();
    /* EMBMS Changes End*/
    initialize_table_carrierTable();
    initialize_table_utranFDDFreqTable();
    initialize_table_geranFreqGroupTable();
    initialize_table_neighborListLTECellTable();
    initialize_table_neighborListUMTSTable();
    initialize_table_neighborListInUseLTECellTable();
    initialize_table_neighborListInUseUMTSTable();
    initialize_table_currentAlarmTable();
    initialize_table_supportedAlarmTable();
    initialize_table_historyEventTable();
    initialize_table_expeditedEventTable();
    initialize_table_queuedEventTable();
}

/** handles requests for the plmnListTable table, if anything else needs to be done */
int
plmnListTable_handler(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = PLMNLIST_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_long_val = NULL;
    char *p_str_val = NULL;
    size_t          retval_len = 0;
    int retVal = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_PLMNLISTTBLENABLE:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                    break;

                case COLUMN_PLMNLISTTBLISPRIMARY:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if(p_long_val) {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending parameter value: %ld", *p_long_val);
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                    break;

                case COLUMN_PLMNLISTTBLPLMNID:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                         ASN_OCTET_STR,
                                                         &retval_len);
                    if(p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                    break;

                case COLUMN_PLMNLISTTBLCELLRESERVEDFOROPERATORUSE:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if(p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                    break;

                default:
                    /** We shouldn't get here */
                    snmp_log(LOG_ERR,
                             "problem encountered in plmnListTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_ACTION:
            /** save a variable copy */
            switch (table_info->colnum) {
            case COLUMN_PLMNLISTTBLENABLE:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_PLMNLISTTBLISPRIMARY:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_PLMNLISTTBLPLMNID:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_OCTET_STR); 
                break;
            case COLUMN_PLMNLISTTBLCELLRESERVEDFOROPERATORUSE:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
             /** save a variable copy */
            break;

        case MODE_SET_FREE:
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in plmnListTable_handler: unsupported mode\n");
        }
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the qoSTable table, if anything else needs to be done */
int
qoSTable_handler(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = QOS_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_long_val = NULL;
    unsigned long *p_ulong_val = NULL;
    char *p_str_val = NULL;
    size_t          retval_len = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    snmp_log(LOG_DEBUG,
             "unused param %p and %p\n", reginfo, handler);

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_QOSTBLQCI:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            case COLUMN_QOSTBLTYPE:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            case COLUMN_QOSTBLPRIORITY:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            case COLUMN_QOSTBLPACKETDELAYBUDGET:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in qoSTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in qoSTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/* EMBMS Changes Start*/
/** handles requests for the sfConfigListTable table, if anything else needs to be done */
int
sfConfigListTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    void           *data_context = NULL;

    int base_idx = SFCONFIGLIST_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    unsigned long *p_ulong_val = NULL;
    char *p_str_val = NULL;
    size_t          retval_len = 0;
    int retVal = 0;
    
    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if (!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if (!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;

        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if (!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_SFCONFIGLISTTBLSYNCSTRATUMID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "\nSending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            case COLUMN_SFCONFIGLISTTBLRADIOFRAMEALLOCATIONPERIOD:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "\nSending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            case COLUMN_SFCONFIGLISTTBLRADIOFRAMEALLOCATIONOFFSET:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "\nSending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            case COLUMN_SFCONFIGLISTTBLRADIOFRAMEALLOCATIONSIZE:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "\nSending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            case COLUMN_SFCONFIGLISTTBLSUBFRAMEALLOCATIONS:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "\nSending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in sfConfigListTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_ACTION:
            /** save a variable copy */
            switch (table_info->colnum) {
            case COLUMN_SFCONFIGLISTTBLSYNCSTRATUMID:
                
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_SFCONFIGLISTTBLRADIOFRAMEALLOCATIONPERIOD:
                
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_SFCONFIGLISTTBLRADIOFRAMEALLOCATIONOFFSET:
                
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_SFCONFIGLISTTBLRADIOFRAMEALLOCATIONSIZE:
                
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_SFCONFIGLISTTBLSUBFRAMEALLOCATIONS:

                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_OCTET_STR); 
                break;
             }
             break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
             /** save a variable copy */
            break;

        case MODE_SET_FREE:
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in sfConfigListTable_handler: unsupported mode\n");
        }
    }

    return SNMP_ERR_NOERROR;
}

/** handles requests for the carrierTable table, if anything else needs to be done */
int
carrierTable_handler(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = CARRIER_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_ulong_val = NULL;
    long *p_long_val = NULL;
    size_t          retval_len = 0;
    int retVal = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_CARRIERTBLEUTRACARRIERARFCN:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLQOFFSETFREQ:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLQRXLEVMINSIB5:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLPMAX:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLTRESELECTIONEUTRA:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLTRESELECTIONEUTRASFMEDIUM:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLTRESELECTIONEUTRASFHIGH:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLTHRESHXHIGH:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLTHRESHXLOW:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_CARRIERTBLCELLRESELECTIONPRIORITY:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                               "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in carrierTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_ACTION:
            /** save a variable copy */
            switch (table_info->colnum) {
            case COLUMN_CARRIERTBLEUTRACARRIERARFCN:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_CARRIERTBLQOFFSETFREQ:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_CARRIERTBLQRXLEVMINSIB5:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_CARRIERTBLPMAX:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_CARRIERTBLTRESELECTIONEUTRA:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_CARRIERTBLTRESELECTIONEUTRASFMEDIUM:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_CARRIERTBLTRESELECTIONEUTRASFHIGH:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_CARRIERTBLTHRESHXHIGH:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_CARRIERTBLTHRESHXLOW:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_CARRIERTBLCELLRESELECTIONPRIORITY:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
             /** save a variable copy */
            break;

        case MODE_SET_FREE:
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in carrierTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the utranFDDFreqTable table, if anything else needs to be done */
int
utranFDDFreqTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = UTRANFDDFREQ_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_ulong_val = NULL;
    long *p_long_val = NULL;
    size_t          retval_len = 0;
    int retVal = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_UTRANFDDFREQTBLUTRACARRIERARFCN:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_UTRANFDDFREQTBLQRXLEVMIN:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_UTRANFDDFREQTBLQQUALMIN:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_UTRANFDDFREQTBLCELLRESELECTIONPRIORITY:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_UTRANFDDFREQTBLTHRESHXHIGH:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_UTRANFDDFREQTBLTHRESHXLOW:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_UTRANFDDFREQTBLPMAXUTRA:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in utranFDDFreqTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_ACTION:
            /** save a variable copy */
            switch (table_info->colnum) {
            case COLUMN_UTRANFDDFREQTBLUTRACARRIERARFCN:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;
            case COLUMN_UTRANFDDFREQTBLQRXLEVMIN:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_UTRANFDDFREQTBLQQUALMIN:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

            case COLUMN_UTRANFDDFREQTBLCELLRESELECTIONPRIORITY:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_UTRANFDDFREQTBLTHRESHXHIGH:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_UTRANFDDFREQTBLTHRESHXLOW:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_UTRANFDDFREQTBLPMAXUTRA:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        case MODE_SET_FREE:
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in utranFDDFreqTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the geranFreqGroupTable table, if anything else needs to be done */
int
geranFreqGroupTable_handler(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = GERANFREQGROUP_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_ulong_val = NULL;
    size_t          retval_len = 0;
    int retVal = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_GERANFREQGROUPTBLQRXLEVMIN:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_GERANFREQGROUPTBLCELLRESELECTIONPRIORITY:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_GERANFREQGROUPTBLTHRESHXHIGH:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

		case COLUMN_GERANFREQGROUPTBLTHRESHXLOW:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in geranFreqGroupTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_ACTION:
            /** save a variable copy */
            switch (table_info->colnum) {
            case COLUMN_GERANFREQGROUPTBLQRXLEVMIN:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_GERANFREQGROUPTBLCELLRESELECTIONPRIORITY:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_GERANFREQGROUPTBLTHRESHXHIGH:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

            case COLUMN_GERANFREQGROUPTBLTHRESHXLOW:
                SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        case MODE_SET_FREE:
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in geranFreqGroupTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the neighborListLTECellTable table, if anything else needs to be done */
int
neighborListLTECellTable_handler(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = NEIGHBORLISTLTECELL_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_ulong_val = NULL;
    char *p_str_val = NULL;
    long *p_long_val = NULL;
    size_t          retval_len = 0;
    int retVal = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_NEIGHBORLISTLTECELLTBLPLMNID:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLCID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLEUTRACARRIERARFCN:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLPHYCELLID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLQOFFSET:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLCIO:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLBLACKLISTED:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in neighborListLTECellTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_ACTION:
            /** save a variable copy */
            switch (table_info->colnum) {
                case COLUMN_NEIGHBORLISTLTECELLTBLPLMNID:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_OCTET_STR); 
                break;
                
                case COLUMN_NEIGHBORLISTLTECELLTBLCID:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLEUTRACARRIERARFCN:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLPHYCELLID:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLQOFFSET:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLCIO:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;

                case COLUMN_NEIGHBORLISTLTECELLTBLBLACKLISTED:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_INTEGER); 
                break;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        case MODE_SET_FREE:
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in neighborListLTECellTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the neighborListUMTSTable table, if anything else needs to be done */
int
neighborListUMTSTable_handler(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = NEIGHBORLISTUMTS_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_ulong_val = NULL;
    char *p_str_val = NULL;
    size_t          retval_len = 0;
    int retVal = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_NEIGHBORLISTUMTSTBLPLMNID:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLRNCID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLCID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLLAC:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLRAC:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLUARFCNDL:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in neighborListUMTSTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_ACTION:
            /** save a variable copy */
            switch (table_info->colnum) {
                case COLUMN_NEIGHBORLISTUMTSTBLPLMNID:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_OCTET_STR); 
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLRNCID:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLCID:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLLAC:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLRAC:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;

                case COLUMN_NEIGHBORLISTUMTSTBLUARFCNDL:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_UNSIGNED); 
                break;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        case MODE_SET_FREE:
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in neighborListUMTSTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the neighborListInUseLTECellTable table, if anything else needs to be done */
int
neighborListInUseLTECellTable_handler(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = NEIGHBORLISTINUSELTECELL_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_long_val = NULL;
    long *p_ulong_val = NULL;
    char *p_str_val = NULL;
    size_t          retval_len = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    snmp_log(LOG_DEBUG,
             "unused param %p and %p\n", reginfo, handler);

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_NEIGHBORLISTINUSELTECELLTBLPLMNID:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSELTECELLTBLCID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSELTECELLTBLEUTRACARRIERARFCN:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSELTECELLTBLPHYCELLID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSELTECELLTBLQOFFSET:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSELTECELLTBLBLACKLISTED:
                    p_long_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_INTEGER,
                                                          &retval_len);
                    if (p_long_val) {
                        snmp_set_var_typed_value(var, ASN_INTEGER,
                                                 p_long_val, retval_len);
                        oam_mgmt_mem_free(p_long_val);
                        p_long_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in neighborListInUseLTECellTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in neighborListInUseLTECellTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the neighborListInUseUMTSTable table, if anything else needs to be done */
int
neighborListInUseUMTSTable_handler(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = NEIGHBORLISTINUSEUMTS_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    long *p_ulong_val = NULL;
    char *p_str_val = NULL;
    size_t          retval_len = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    snmp_log(LOG_DEBUG,
             "unused param %p and %p\n", reginfo, handler);

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_NEIGHBORLISTINUSEUMTSTBLPLMNID:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSEUMTSTBLRNCID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSEUMTSTBLCID:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSEUMTSTBLLAC:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSEUMTSTBLRAC:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                case COLUMN_NEIGHBORLISTINUSEUMTSTBLUARFCNDL:
                    p_ulong_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_UNSIGNED,
                                                          &retval_len);
                    if (p_ulong_val) {
                        snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                                 p_ulong_val, retval_len);
                        oam_mgmt_mem_free(p_ulong_val);
                        p_ulong_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

            default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in neighborListInUseUMTSTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in neighborListInUseUMTSTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the currentAlarmTable table, if anything else needs to be done */
int
currentAlarmTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = CURRENTALARM_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    char *p_str_val = NULL;
    size_t          retval_len = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    snmp_log(LOG_DEBUG,
             "unused param %p and %p\n", reginfo, handler);

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }

        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_CURRENTALARMTBLALARMIDENTIFIER:
                case COLUMN_CURRENTALARMTBLRAISEDTIME:
                case COLUMN_CURRENTALARMTBLCHANGEDTIME:
                case COLUMN_CURRENTALARMTBLMANAGEDOBJECTINSTANCE:
                case COLUMN_CURRENTALARMTBLEVENTTYPE:
                case COLUMN_CURRENTALARMTBLPROBABLECAUSE:
                case COLUMN_CURRENTALARMTBLSPECIFICPROBLEM:
                case COLUMN_CURRENTALARMTBLPERCEIVEDSEVERITY:
                case COLUMN_CURRENTALARMTBLADDITIONALTEXT:
                case COLUMN_CURRENTALARMTBLADDITIONALINFORMATION:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                    break;

                default:
                    /** We shouldn't get here */
                    snmp_log(LOG_ERR,
                             "problem encountered in currentAlarmTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in currentAlarmTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the supportedAlarmTable table, if anything else needs to be done */
int
supportedAlarmTable_handler(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = SUPPORTEDALARM_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    char *p_str_val = NULL;
    size_t          retval_len = 0;
    int retVal = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_SUPPORTEDALARMTBLEVENTTYPE:
                case COLUMN_SUPPORTEDALARMTBLPROBABLECAUSE:
                case COLUMN_SUPPORTEDALARMTBLSPECIFICPROBLEM:
                case COLUMN_SUPPORTEDALARMTBLPERCEIVEDSEVERITY:
                case COLUMN_SUPPORTEDALARMTBLREPORTINGMECHANISM:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                    break;

                default:
                    /** We shouldn't get here */
                    snmp_log(LOG_ERR,
                             "problem encountered in supportedAlarmTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_ACTION:
            /** save a variable copy */
            switch (table_info->colnum) {
                case COLUMN_SUPPORTEDALARMTBLREPORTINGMECHANISM:
                    SNMP_OAM_HANDLE_TABLE_SET_REQUEST(handler, reginfo, request, ASN_OCTET_STR); 
                break;
            }
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        case MODE_SET_FREE:
            break;

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in supportedAlarmTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the historyEventTable table, if anything else needs to be done */
int
historyEventTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = HISTORYEVENT_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    char *p_str_val = NULL;
    size_t          retval_len = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));
    snmp_log(LOG_DEBUG,
             "unused param %p and %p\n", reginfo, handler);

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_HISTORYEVENTTBLEVENTTIME:
                case COLUMN_HISTORYEVENTTBLALARMIDENTIFIER:
                case COLUMN_HISTORYEVENTTBLNOTIFICATIONTYPE:
                case COLUMN_HISTORYEVENTTBLMANAGEDOBJECTINSTANCE:
                case COLUMN_HISTORYEVENTTBLEVENTTYPE:
                case COLUMN_HISTORYEVENTTBLPROBABLECAUSE:
                case COLUMN_HISTORYEVENTTBLSPECIFICPROBLEM:
                case COLUMN_HISTORYEVENTTBLPERCEIVEDSEVERITY:
                case COLUMN_HISTORYEVENTTBLADDITIONALTEXT:
                case COLUMN_HISTORYEVENTTBLADDITIONALINFORMATION:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                default:
                /** We shouldn't get here */
                    snmp_log(LOG_ERR,
                         "problem encountered in historyEventTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in historyEventTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the expeditedEventTable table, if anything else needs to be done */
int
expeditedEventTable_handler(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = EXPEDITEDEVENT_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    char *p_str_val = NULL;
    size_t          retval_len = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    snmp_log(LOG_DEBUG,
             "unused param %p and %p\n", reginfo, handler);

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_EXPEDITEDEVENTTBLEVENTTIME:
                case COLUMN_EXPEDITEDEVENTTBLALARMIDENTIFIER:
                case COLUMN_EXPEDITEDEVENTTBLNOTIFICATIONTYPE:
                case COLUMN_EXPEDITEDEVENTTBLMANAGEDOBJECTINSTANCE:
                case COLUMN_EXPEDITEDEVENTTBLEVENTTYPE:
                case COLUMN_EXPEDITEDEVENTTBLPROBABLECAUSE:
                case COLUMN_EXPEDITEDEVENTTBLSPECIFICPROBLEM:
                case COLUMN_EXPEDITEDEVENTTBLPERCEIVEDSEVERITY:
                case COLUMN_EXPEDITEDEVENTTBLADDITIONALTEXT:
                case COLUMN_EXPEDITEDEVENTTBLADDITIONALINFORMATION:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in expeditedEventTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in expeditedEventTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}

/** handles requests for the queuedEventTable table, if anything else needs to be done */
int
queuedEventTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;

    void           *data_context = NULL;
    int base_idx = QUEUEDEVENT_TBL_PARAM_START_IDX;
    int map_tbl_index = 0;
    char *p_str_val = NULL;
    size_t          retval_len = 0;

    DEBUGMSGTL(("enb:handler", "Processing request (%d)\n",
                reqinfo->mode));

    snmp_log(LOG_DEBUG,
             "unused param %p and %p\n", reginfo, handler);


    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        switch (reqinfo->mode) {
        case MODE_GET:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            break;

        case MODE_SET_RESERVE1:
            data_context = netsnmp_extract_iterator_context(request);
            if(!data_context) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_ERR_NOCREATION);
                continue;
            }
            break;
        }


        /** extracts the information about the table from the request */
        table_info = netsnmp_extract_table_info(request);
        /** table_info->colnum contains the column number requested */
        /** table_info->indexes contains a linked list of snmp variable
           bindings for the indexes of the table.  Values in the list
           have been set corresponding to the indexes of the
           request */
        if(!table_info) {
            continue;
        }

        map_tbl_index = base_idx + (table_info->colnum - 1);

        switch (reqinfo->mode) {
        case MODE_GET:
            switch (table_info->colnum) {
                case COLUMN_QUEUEDEVENTTBLEVENTTIME:
                case COLUMN_QUEUEDEVENTTBLALARMIDENTIFIER:
                case COLUMN_QUEUEDEVENTTBLNOTIFICATIONTYPE:
                case COLUMN_QUEUEDEVENTTBLMANAGEDOBJECTINSTANCE:
                case COLUMN_QUEUEDEVENTTBLEVENTTYPE:
                case COLUMN_QUEUEDEVENTTBLPROBABLECAUSE:
                case COLUMN_QUEUEDEVENTTBLSPECIFICPROBLEM:
                case COLUMN_QUEUEDEVENTTBLPERCEIVEDSEVERITY:
                case COLUMN_QUEUEDEVENTTBLADDITIONALTEXT:
                case COLUMN_QUEUEDEVENTTBLADDITIONALINFORMATION:
                    p_str_val = snmp_oam_get_param_value(data_context,
                                                          map_tbl_index,
                                                          ASN_OCTET_STR,
                                                          &retval_len);
                    if (p_str_val) {
                        snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                                 p_str_val, retval_len);
                        oam_mgmt_mem_free(p_str_val);
                        p_str_val = NULL;
                    }
                    else {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Sending error response to user");
                        netsnmp_request_set_error(request, SNMP_NOSUCHINSTANCE);
                    }
                break;

                default:
                /** We shouldn't get here */
                snmp_log(LOG_ERR,
                         "problem encountered in queuedEventTable_handler: unknown column\n");
            }
            break;


        default:
            snmp_log(LOG_ERR,
                     "problem encountered in queuedEventTable_handler: unsupported mode\n");
        }
    }


    return SNMP_ERR_NOERROR;
}


/****************************************************************************
 *  FUNCTION NAME    : snmp_oam_get_table_size
 *  DESCRIPTION      : This function send a GPV request to  OAM  to  get  the
 *                     current size of an SNMP table object.
 *  PARAMETERS       
 *      IN           : SNMP table object type
 *                   
 *      OUT          : NONE
 *                   
 *  RETURNS          :  non-zero value on Success zero otherwise
****************************************************************************/
/* coverity 52816 */
unsigned
snmp_oam_get_table_size(snmp_oam_table_type_et type)
{
    /* coverity 52817 */ 
    mgmt_return_et retVal = OAM_SNMP_GEN_ERROR;
    char* parent = NULL;
    char* size_param = NULL;
    oam_mgmt_if_req_t p_msg;
    oam_mgmt_if_param_info_t *p_param = NULL;
    oam_mgmt_if_get_resp_t *p_resp = NULL;
    char *val_str = NULL;

    oam_mgmt_memset(&p_msg, 0, sizeof(oam_mgmt_if_req_t));

    retVal = oam_mgmt_mem_alloc(sizeof(oam_mgmt_if_get_resp_t),
                                (void**)&p_resp);

    if(OAM_SNMP_SUCCESS != retVal) {
        return 0;
    }

    oam_mgmt_memset(p_resp, 0, sizeof(oam_mgmt_if_get_resp_t));

    switch(type) {
        case PLMNLIST_TBL_TYPE:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC";
            size_param = "PLMNListNumberOfEntries";
            break;

        case QOS_TBL_TYPE:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.EPC";
            size_param = "QoSNumberOfEntries";
            break;

        case CARRIER_TBL_TYPE:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.InterFreq";
            size_param = "CarrierNumberOfEntries";
            break;

        case UTRANFDDFREQ_TBL_DATA:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.UTRA";
            size_param = "UTRANFDDFreqNumberOfEntries";
            break;

        case GERANFREQGROUP_TBL_TYPE:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.Mobility.IdleMode.IRAT.GERAN";
            size_param = "GERANFreqGroupNumberOfEntries";
            break;

        case NEIGHBORLISTLTECELL_TBL_TYPE:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborList";
            size_param = "LTECellNumberOfEntries";
            break;

        case NEIGHBORLISTUMTS_TBL_TYPE:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborList.InterRATCell";
            size_param = "UMTSNumberOfEntries";
            break;

        case NEIGHBORLISTINUSELTECELL_TBL_TYPE:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse";
            size_param = "LTECellNumberOfEntries";
            break;

        case NEIGHBORLISTINUSEUMTS_TBL_TYPE:
            parent = "InternetGatewayDevice.Services.FAPService.CellConfig.LTE.RAN.NeighborListInUse.InterRATCell";
            size_param = "UMTSNumberOfEntries";
            break;

        case CURRENTALARM_TBL_TYPE:
            parent = "InternetGatewayDevice.FaultMgmt";
            size_param = "CurrentAlarmNumberOfEntries";
            break;

        case SUPPORTEDALARM_TBL_TYPE:
            parent = "InternetGatewayDevice.FaultMgmt";
            size_param = "SupportedAlarmNumberOfEntries";
            break;

        case HISTORYEVENT_TBL_TYPE:
            parent = "InternetGatewayDevice.FaultMgmt";
            size_param = "X_VENDOR_HISTORYEVENT_NUM_VALID_ENTRIES";
            break;

        case EXPEDITEDEVENT_TBL_TYPE:
            parent = "InternetGatewayDevice.FaultMgmt";
            size_param = "X_VENDOR_EXPEDITEDEVENT_NUM_VALID_ENTRIES";
            break;

        case QUEUEDEVENT_TBL_TYPE:
            parent = "InternetGatewayDevice.FaultMgmt";
            size_param = "X_VENDOR_QUEUEDEVENT_NUM_VALID_ENTRIES";
            break;

        default:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_WARNING,
                                "Unknown table type");
            oam_mgmt_mem_free(p_resp);
            p_resp = NULL;
            return 0;

    }

    /* KLOCWORK warning fix start */
    oam_snmp_strncpy(p_msg.parent_name, parent,
                 OAM_MGMT_IF_MAX_PARENT_NAME_LEN - 1);
    /* KLOCWORK warning fix end */
    p_msg.num_params = 1;


    retVal = oam_mgmt_mem_alloc(sizeof(oam_mgmt_if_param_info_t),
                                (void**)&p_msg.param_list);

    if(OAM_SNMP_SUCCESS != retVal) {
        oam_mgmt_mem_free(p_resp);
        p_resp = NULL;
        return 0;
    }

    oam_mgmt_memset(p_msg.param_list, 0, sizeof(oam_mgmt_if_param_info_t));
    /* KLOCWORK warning fix start */
    oam_snmp_strncpy(p_msg.param_list->param_name, size_param,
            OAM_MGMT_IF_MAX_PARAM_NAME_LEN - 1);
    /* KLOCWORK warning fix end */

    p_msg.param_list->next = NULL;


    retVal = oam_snmp_get_req_handler(&p_msg, p_resp);

    switch(retVal) {
        case OAM_SNMP_SUCCESS:
            if(p_resp->num_params != p_msg.num_params) {
                OAM_SNMP_LOG(SNMP, OAM_SNMP_WARNING,
                                "req:num_params[%u] != resp:num_params[%u]",
                                 p_msg.num_params, p_resp->num_params);
                retVal = OAM_SNMP_GEN_ERROR;
                break;
            }

            p_param = p_resp->param_list;
            val_str = oam_snmp_strchr(p_param->param_name, '=');
            ++val_str;

            if(!*val_str) {
                OAM_SNMP_LOG(SNMP, OAM_SNMP_WARNING,
                                "Empty parameter value received");
                retVal = OAM_SNMP_GEN_ERROR;
                break;
            }

            if(!oam_snmp_strncmp(p_param->param_name, size_param,
                        oam_snmp_strlen(size_param))) {
                /* coverity 52813 */ 
                retVal = (mgmt_return_et)oam_snmp_atoi(val_str);
                OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                "Current table size received: %d", retVal);
            }
            else {
                retVal = OAM_SNMP_GEN_ERROR;
                OAM_SNMP_LOG(SNMP, OAM_SNMP_WARNING,
                                "Unexpected parameter received");
            }
            break;

        default:
            retVal = OAM_SNMP_GEN_ERROR;
            break;
    }

    oam_mgmt_mem_free(p_msg.param_list);
    p_msg.param_list = NULL;
    free_param_list(&p_resp->param_list);
    oam_mgmt_mem_free(p_resp);
    p_resp = NULL;

    /* coverity 52814 */	
    return (unsigned)retVal;
}

mgmt_return_et
snmp_oam_populate_param_list(oam_mgmt_if_req_t *p_msg,
                             int map_tbl_idx,
                             int param_instance_num)
{
    char inst_id[SNMP_ROW_INSTANCE_ID_MAX_LEN] = {0};
    oam_mgmt_if_param_info_t **p_p_param = NULL;
    int param_cnt = 0;
    int offset = 0;
    mgmt_return_et retVal = OAM_SNMP_SUCCESS;

    /* KLOCWORK warning fix start */
    oam_snmp_strncpy(p_msg->parent_name,
                snmp_param_table[map_tbl_idx].parent,
            OAM_MGMT_IF_MAX_PARENT_NAME_LEN - 1);

    snprintf(inst_id, SNMP_ROW_INSTANCE_ID_MAX_LEN, ".[%d]",
                      param_instance_num);
    oam_snmp_strncat(p_msg->parent_name, inst_id, oam_snmp_strlen(inst_id));
    OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
        "Parent Name: %s, Num Params: %d", p_msg->parent_name,
                                                p_msg->num_params);

    p_p_param = &p_msg->param_list;
    for(param_cnt = 1; param_cnt <= p_msg->num_params; ++param_cnt) {
        retVal = oam_mgmt_mem_alloc(sizeof(oam_mgmt_if_param_info_t),
                                    (void**)p_p_param);

        if(OAM_SNMP_SUCCESS != retVal) {
            OAM_SNMP_LOG(SNMP, OAM_SNMP_ERROR, 
                "Memory allocation to p_p_param failed");
            return retVal;
        }

        oam_mgmt_memset(*p_p_param, 0, sizeof(oam_mgmt_if_param_info_t));
        offset = map_tbl_idx + param_cnt;

        oam_snmp_strncpy((*p_p_param)->param_name,
                    snmp_param_table[offset].param,
                OAM_MGMT_IF_MAX_PARAM_NAME_LEN - 1);
    /* KLOCWORK warning fix end */
        OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                "Param Name: %s", (*p_p_param)->param_name);
        p_p_param = &((*p_p_param)->next);
    }

    return OAM_SNMP_SUCCESS;
}


oam_mgmt_if_get_resp_t*
snmp_oam_get_row_data(snmp_oam_table_type_et type, unsigned index)
{
    oam_mgmt_if_req_t p_msg;
    oam_mgmt_if_get_resp_t *p_resp = NULL;
    int map_tbl_idx = 0;
    mgmt_return_et retVal = OAM_SNMP_SUCCESS;


    oam_mgmt_memset(&p_msg, 0, sizeof(oam_mgmt_if_req_t));
    retVal = oam_mgmt_mem_alloc(sizeof(oam_mgmt_if_get_resp_t),
                                (void**)&p_resp);

    if(OAM_SNMP_SUCCESS != retVal) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_ERROR, 
            "Memory allocation to p_resp failed");
        return NULL;
    }
    oam_mgmt_memset(p_resp, 0, sizeof(oam_mgmt_if_get_resp_t));


    switch(type) {
        case PLMNLIST_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for plmnListTable");
            p_msg.num_params =
                COLUMN_PLMNLISTTBLCELLRESERVEDFOROPERATORUSE - 1;
            map_tbl_idx = PLMNLIST_TBL_PARAM_START_IDX;
            break;

        case QOS_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for qoSTable");
            p_msg.num_params = COLUMN_QOSTBLPACKETDELAYBUDGET - 1;
            map_tbl_idx = QOS_TBL_PARAM_START_IDX;
            break;

    /* EMBMS Changes Start */
        case SFCONFIGLIST_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "\nFetching table row for SFConfigListTable");
            p_msg.num_params = COLUMN_SFCONFIGLISTTBLSUBFRAMEALLOCATIONS - 1;
            map_tbl_idx = SFCONFIGLIST_TBL_PARAM_START_IDX;
            break;
    /* EMBMS Changes End*/

        case CARRIER_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for carrierTable");
            p_msg.num_params =
                COLUMN_CARRIERTBLCELLRESELECTIONPRIORITY - 1;
            map_tbl_idx = CARRIER_TBL_PARAM_START_IDX;
            break;

        case UTRANFDDFREQ_TBL_DATA:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for utranFDDFreqTable");
            p_msg.num_params = COLUMN_UTRANFDDFREQTBLPMAXUTRA - 1;
            map_tbl_idx = UTRANFDDFREQ_TBL_PARAM_START_IDX;
            break;

        case GERANFREQGROUP_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for geranFreqGroupTable");
            p_msg.num_params =
                COLUMN_GERANFREQGROUPTBLTHRESHXLOW - 1;
            map_tbl_idx = GERANFREQGROUP_TBL_PARAM_START_IDX;
            break;

        case NEIGHBORLISTLTECELL_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for neighborListLTECellTable");
            p_msg.num_params =
                COLUMN_NEIGHBORLISTLTECELLTBLBLACKLISTED - 1;
            map_tbl_idx = NEIGHBORLISTLTECELL_TBL_PARAM_START_IDX;
            break;

        case NEIGHBORLISTUMTS_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for neighborListUMTSTable");
            p_msg.num_params =
                COLUMN_NEIGHBORLISTUMTSTBLUARFCNDL - 1;
            map_tbl_idx = NEIGHBORLISTUMTS_TBL_PARAM_START_IDX;
            break;

        case NEIGHBORLISTINUSELTECELL_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for neighborListInUseLTECellTable");
            p_msg.num_params =
                COLUMN_NEIGHBORLISTINUSELTECELLTBLBLACKLISTED - 1;
            map_tbl_idx = NEIGHBORLISTINUSELTECELL_TBL_PARAM_START_IDX;
            break;

        case NEIGHBORLISTINUSEUMTS_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for neighborListInUseUMTSTable");
            p_msg.num_params =
                COLUMN_NEIGHBORLISTINUSEUMTSTBLUARFCNDL - 1;
            map_tbl_idx = NEIGHBORLISTINUSEUMTS_TBL_PARAM_START_IDX;
            break;

        case CURRENTALARM_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for currentAlarmTable");
            p_msg.num_params =
                COLUMN_CURRENTALARMTBLADDITIONALINFORMATION - 1;
            map_tbl_idx = CURRENTALARM_TBL_PARAM_START_IDX;
            break;

        case SUPPORTEDALARM_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for supportedAlarmTable");
            p_msg.num_params =
                COLUMN_SUPPORTEDALARMTBLREPORTINGMECHANISM - 1;
            map_tbl_idx = SUPPORTEDALARM_TBL_PARAM_START_IDX;
            break;

        case HISTORYEVENT_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for historyEventTable");
            p_msg.num_params =
                COLUMN_HISTORYEVENTTBLADDITIONALINFORMATION - 1;
            map_tbl_idx = HISTORYEVENT_TBL_PARAM_START_IDX;
            break;

        case EXPEDITEDEVENT_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for expeditedEventTable");
            p_msg.num_params =
                COLUMN_EXPEDITEDEVENTTBLADDITIONALINFORMATION - 1;
            map_tbl_idx = EXPEDITEDEVENT_TBL_PARAM_START_IDX;
            break;

        case QUEUEDEVENT_TBL_TYPE:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Fetching table row for queuedEventTable");
            p_msg.num_params =
                COLUMN_QUEUEDEVENTTBLADDITIONALINFORMATION - 1;
            map_tbl_idx = QUEUEDEVENT_TBL_PARAM_START_IDX;
            break;

        default:
            OAM_SNMP_LOG(SNMP, OAM_SNMP_WARNING,
                    "Unknown table type[%u]...", type);
            return NULL;
    }

    retVal = snmp_oam_populate_param_list(&p_msg, map_tbl_idx, index);

    if(retVal != OAM_SNMP_SUCCESS) {
        oam_mgmt_mem_free(p_resp);
        return NULL;
    }

    retVal = oam_snmp_get_req_handler(&p_msg, p_resp);

    if(OAM_SNMP_SUCCESS != retVal) {
        oam_mgmt_mem_free(p_resp);
        p_resp = NULL;
    }

    free_param_list(&p_msg.param_list);
    return p_resp;
}


void*
snmp_oam_get_param_value(oam_mgmt_if_get_resp_t *p_data, int map_tbl_idx,
                         int data_type, size_t *size)
{
    oam_mgmt_if_param_info_t *p_param = NULL;
    int cnt = 0;
    char *val_str = NULL;
    void *p_val = NULL;
    mgmt_return_et retVal = OAM_SNMP_SUCCESS;

    p_param = p_data->param_list;
    for(cnt = 0; p_param && cnt < p_data->num_params; ++cnt) {
        if(!oam_snmp_strncmp(p_param->param_name,
                   snmp_param_table[map_tbl_idx].param,
                   oam_snmp_strlen(snmp_param_table[map_tbl_idx].param))) {
            OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                    "Parameter found...");

            val_str = oam_snmp_strchr(p_param->param_name, '=');

            /*  CID: 53738 fix : VKG */
            if(!val_str) {
                return val_str;
            }

            ++val_str;

            if(!oam_snmp_strlen(val_str)) {
                OAM_SNMP_LOG(SNMP, OAM_SNMP_WARNING,
                        "Empty Parameter value received...");
                break;
            }

            switch(data_type) {
                case ASN_INTEGER:
                    *size = sizeof(long);
                    retVal = oam_mgmt_mem_alloc(*size, &p_val);

                    if(OAM_SNMP_SUCCESS != retVal) {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_ERROR,
                                        "Memory allocation to p_val failed");
                        break;
                    }

                    oam_mgmt_memset(p_val, 0, *size);

                    *(long*)p_val = oam_snmp_strtol(val_str, NULL, 10);
                    break;

                case ASN_UNSIGNED:
                case ASN_COUNTER:
                case ASN_TIMETICKS:
                    *size = sizeof(unsigned long);
                    retVal = oam_mgmt_mem_alloc(*size, &p_val);

                    if(OAM_SNMP_SUCCESS != retVal) {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_ERROR,
                                        "Memory allocation to p_val failed");
                        break;
                    }

                    oam_mgmt_memset(p_val, 0, *size);
                    *(unsigned long*)p_val = oam_snmp_strtoul(val_str, NULL, 10);
                    break;

                default:
                    *size = oam_snmp_strlen(val_str);
                    retVal = oam_mgmt_mem_alloc(*size + 1, &p_val);

                    if(OAM_SNMP_SUCCESS != retVal) {
                        OAM_SNMP_LOG(SNMP, OAM_SNMP_ERROR,
                                        "Memory allocation to p_val failed");
                        break;
                    }

                    oam_mgmt_memset(p_val, 0, *size + 1);
                    oam_snmp_strncpy((char*)p_val, val_str, *size);
                    OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
                                 "Parameter value: %s", (char*)p_val);
            }

            return p_val;
        }

        p_param = p_param->next;
    }
    OAM_SNMP_LOG(SNMP, OAM_SNMP_WARNING, "Parameter not found...");

    return NULL;
}


void free_param_list(oam_mgmt_if_param_info_t  **p_head)
{
    oam_mgmt_if_param_info_t    *p_prev = NULL;
    oam_mgmt_if_param_info_t    *p_next = NULL;

    p_next = *p_head;
    while(p_next) {
        p_prev = p_next;
        p_next = p_next->next;
        oam_mgmt_mem_free(p_prev);
    }

    *p_head = NULL;
}

void
snmp_oam_free_data_cntxt(void *data, netsnmp_iterator_info *iinfo)
{
    oam_mgmt_if_get_resp_t *p_data = data;

    OAM_SNMP_LOG(SNMP, OAM_SNMP_DETAILED,
            "In snmp_oam_free_data_cntxt function, unused parameter %p", iinfo);

    if(!p_data) {
        return;
    }

    free_param_list(&p_data->param_list);
    oam_mgmt_mem_free(p_data);
}



/*  CID: 52816 fix : VKG */
oam_mgmt_if_get_resp_t*
snmp_oam_get_first_row_data(snmp_oam_table_type_et tbl_type, unsigned *index,
                            unsigned *num_valid_index,
                            unsigned *num_rows, int max_index)
{
    oam_mgmt_if_get_resp_t *row_data = NULL;
    *num_rows = snmp_oam_get_table_size(tbl_type);

    if(!*num_rows) {
        OAM_SNMP_LOG(SNMP, OAM_SNMP_WARNING,
            "No data in the table");
        *index = 0;
        return NULL;
    }

    *index = 1;

    while(*(SInt64*)index <= max_index) {
        row_data = snmp_oam_get_row_data(tbl_type, *index);
        if(row_data) {
            break;
        }

        ++(*index);
    }

    if(*(SInt64*)index > max_index) {
        *index = 0;
        return NULL;
    }

    *num_valid_index = 1;
    return row_data;
}

/*  CID: 52824 to 52815 fix : VKG */
oam_mgmt_if_get_resp_t*
snmp_oam_get_next_row_data(snmp_oam_table_type_et tbl_type,
                           unsigned *index,
                           unsigned *num_valid_index,
                           unsigned num_rows, int max_index)
{
    oam_mgmt_if_get_resp_t* row_data = NULL;

    if(*num_valid_index >= num_rows) {
        return NULL;
    }

    ++(*index);

    while(*(SInt64*)index <= max_index) {
        row_data = snmp_oam_get_row_data(tbl_type, *index);
        if(row_data) {
            break;
        }

        ++(*index);
    }

    if(*(SInt64*)index > max_index) {
        *index = 0;
        return NULL;
    }

    ++(*num_valid_index);

    return row_data;
}

/* FIX : Resource leak */
void deinitialize_table_data(void)
{

/*  CID: 52824 to 52853 fix : VKG */
    SNMP_OAM_IINFOFREE(plmnListTable_iinfo);
    SNMP_OAM_IINFOFREE(qoSTable_iinfo);
    SNMP_OAM_IINFOFREE(carrierTable_iinfo);
    SNMP_OAM_IINFOFREE(utranFDDFreqTable_iinfo);
    SNMP_OAM_IINFOFREE(geranFreqGroupTable_iinfo);
    SNMP_OAM_IINFOFREE(neighborListLTECellTable_iinfo);
    SNMP_OAM_IINFOFREE(neighborListUMTSTable_iinfo);
    SNMP_OAM_IINFOFREE(neighborListInUseLTECellTable_iinfo);
    SNMP_OAM_IINFOFREE(neighborListInUseUMTSTable_iinfo);
    SNMP_OAM_IINFOFREE(currentAlarmTable_iinfo);
    SNMP_OAM_IINFOFREE(supportedAlarmTable_iinfo);
    SNMP_OAM_IINFOFREE(historyEventTable_iinfo);
    SNMP_OAM_IINFOFREE(expeditedEventTable_iinfo);
    SNMP_OAM_IINFOFREE(queuedEventTable_iinfo);
}

