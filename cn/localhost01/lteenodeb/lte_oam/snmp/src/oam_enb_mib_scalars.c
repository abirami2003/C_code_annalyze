/******************************************************************************
 *   FILE NAME    : oam_enb_mib_scalars.c
 *
 *   DESCRIPTION  : SNMP Agent Init MIB(this file originally auto-generated by mib2c)
 *
 ******************************************************************************/

/*******************************************************************************
 *                        Header Files
 *******************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "oam_enb_mib_scalars.h"
#include "oam_snmp_interface.h"

#define SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, param_type) \
    retVal = oam_snmp_handle_get_request(handler, reginfo, requests, SNMP_OAM_SCALAR_PARAM, param_type); \
if(retVal != SNMP_ERR_NOERROR)\
netsnmp_request_set_error(requests, retVal);

#define SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, param_type) \
    retVal = oam_snmp_handle_set_request(handler, reginfo, requests, SNMP_OAM_SCALAR_PARAM, param_type); \
if(retVal != SNMP_ERR_NOERROR)\
netsnmp_request_set_error(requests, retVal);


extern oam_mgmt_if_param_tab_t snmp_param_table[];


/*************************************************************
 **
 **                       FUNCTIONS DECLARATIONS
 **
 *************************************************************/
mgmt_return_et
oam_snmp_handle_get_request
(
 netsnmp_mib_handler *handler,
 netsnmp_handler_registration *reginfo,
 netsnmp_request_info *requests,
 int param_type,
 int val_type
 );      

mgmt_return_et
oam_snmp_handle_set_request
(
 netsnmp_mib_handler *handler,
 netsnmp_handler_registration *reginfo,
 netsnmp_request_info *requests,
 int param_type,
 int val_type
 );


/******************************************************************************
 * Function Name    : init_aricentLTEeNodeBMIB
 * DESCRIPTION      : It is a MIB init function :Initializes the aricentLTEeNodeBMIB module
 * INPUT            : NONE
 * OUTPUT           : NONE                      
 * RETURNS          : Void
 ******************************************************************************/
    void
init_oam_enb_mib_scalars(void)
{
    const oid       manufacturer_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 1 };
    const oid       manufacturerOUI_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 2 };
    const oid       modelName_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 3 };
    const oid       description_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 4 };
    const oid       productClass_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 5 };
    const oid       serialNumber_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 6 };
    const oid       hardwareVersion_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 7 };
    const oid       softwareVersion_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 8 };
    const oid       modemFirmwareVersion_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 9 };
    const oid       additionalSoftwareVersion_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 10 };
    const oid       upTime_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 11 };
    const oid       firstUseDate_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 1, 12 };
    const oid       configNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 2, 1 };
    const oid       url_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 2, 2, 1 };
    const oid       userName_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 2, 2, 2 };
    const oid       password_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 2, 2, 3 };
    const oid       periodicUploadInterval_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 2, 2, 4 };
    const oid       periodicUploadTime_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 2, 2, 5 };
    const oid       fileWriteTimer_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 2, 2, 6 };
    const oid       samplingIntervalTimer_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 2, 2, 7 };
    const oid       enbServiceNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 1 };
    const oid       deviceType_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 1 };
    const oid       dnPrefix_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 2 };
    const oid       gpsEquipped_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 1 };
    const oid       maxTxPower_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 2 };
    const oid       supportedSystems_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 3 };
    const oid       beacon_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 4 };
    const oid       duplexMode_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 1 };
    const oid       bandsSupported_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 2 };
    const oid       nnsfSupported_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 3 };
    const oid       umtsRxSupported_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 4 };
    const oid       umtsRxBandsSupported_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 5 };
    const oid       gsmRxSupported_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 6 };
    const oid       gsmRxBandsSupported_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 7 };
    const oid       cdma2000RxSupported_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 8 };
    const oid       cdma2000RxBandsSupported_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 3, 5, 9 };
    const oid       opState_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 1 };
    const oid       adminState_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 2 };
    const oid       rfTxStatus_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 3 };
    const oid       availabilityStatus_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 5 };
    const oid       secGWServer1_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 4, 1 };
    const oid       secGWServer2_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 4, 2 };
    const oid       secGWServer3_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 4, 3 };
    const oid       s1SigLinkServerList_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 4, 4 };
    const oid       s1SigLinkPort_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 1, 4, 5 };
    const oid       enbCtrlCellAction_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 2 };
    const oid       enbSWUpdateAction_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 3 };
    const oid       enbSWImageFile_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 4 };
    const oid       enbConfiguredCID_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 5 };
    const oid       enbCurrentCID_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 4, 6 };
    const oid       accessMode_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 5, 1, 1 };
    const oid       maxUEsServed_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 5, 1, 2 };
    const oid       maxCSGMembers_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 5, 1, 3 };
    const oid       maxNonCSGMembers_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 5, 1, 4 };
    const oid       csgid_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 5, 1, 5 };
    const oid       hnbName_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 5, 1, 6 };
    const oid       allowedCipheringAlgorithmList_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 1 };
    const oid       allowedIntegrityProtectionAlgorithmList_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 2 };
    const oid       tac_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 3 };
    const oid       eaid_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 4 };
    const oid       maxPLMNListEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 5 };
    const oid       plmnListNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 6 };
    const oid       qoSNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 1, 7 };
    const oid       cellIdentity_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 1, 1 };
    const oid       tRelocPrep_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 2, 1 };
    const oid       tRelocOverall_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 2, 2 };
    const oid       earfcnDL_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 1 };
    const oid       earfcnUL_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 2 };
    const oid       freqBandIndicator_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 3 };
    const oid       dlBandwidth_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 4 };
    const oid       ulBandwidth_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 5 };
    const oid       referenceSignalPower_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 6 };
    const oid       rfPhyCellID_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 7 };
    const oid       pschPowerOffset_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 8 };
    const oid       sschPowerOffset_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 9 };
    const oid       pbchPowerOffset_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 3, 10 };
    const oid       antennaPortsCount_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 1, 1 };
    const oid       pb_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 2, 1 };
    const oid       pa_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 2, 2 };
    const oid       srsEnabled_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 3, 1 };
    const oid       srsBandwidthConfig_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 3, 2 };
    const oid       srsMaxUpPTS_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 3, 3 };
    const oid       ackNackSRSSimultaneousTransmission_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 3, 4 };
    const oid       rootSequenceIndex_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 4, 1 };
    const oid       configurationIndex_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 4, 2 };
    const oid       highSpeedFlag_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 4, 3 };
    const oid       zeroCorrelationZoneConfig_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 4, 4 };
    const oid       freqOffset_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 4, 5 };
    const oid       deltaPUCCHShift_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 5, 1 };
    const oid       nrbcqi_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 5, 2 };
    const oid       ncsan_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 5, 3 };
    const oid       n1PUCCHAN_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 5, 4 };
    const oid       nsb_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 6, 1 };
    const oid       hoppingMode_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 6, 2 };
    const oid       hoppingOffset_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 6, 3 };
    const oid       enable64QAM_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 6, 4 };
    const oid       groupHoppingEnabled_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 6, 5, 1 };
    const oid       groupAssignmentPUSCH_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 6, 5, 2 };
    const oid       sequenceHoppingEnabled_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 6, 5, 3 };
    const oid       cyclicShift_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 6, 5, 4 };
    const oid       p0NominalPUSCH_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 1 };
    const oid       alpha_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 2 };
    const oid       p0NominalPUCCH_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 3 };
    const oid       deltaFPUCCHFormat1_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 4 };
    const oid       deltaFPUCCHFormat1b_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 5 };
    const oid       deltaFPUCCHFormat2_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 6 };
    const oid       deltaFPUCCHFormat2a_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 7 };
    const oid       deltaFPUCCHFormat2b_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 8 };
    const oid       deltaPreambleMsg3_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 7, 9 };
    /* EMBMS Changes Start */
    const oid       neighCellConfig_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 8, 1 };
    const oid       maxSFConfigListEntries_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 8, 2 };
    const oid       sfConfigListNumberOfEntries_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 8, 3 };
    /* EMBMS Changes End */
    const oid       numPRSResourceBlocks_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 9, 1 };
    const oid       prsConfigurationIndex_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 9, 2 };
    const oid       numConsecutivePRSSubframes_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 9, 3 };
    const oid       subFrameAssignment_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 10, 1 };
    const oid       specialSubframePatterns_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 4, 10, 2 };
    const oid       numberOfRaPreambles_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 1 };
    const oid       sizeOfRaGroupA_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 2 };
    const oid       messageSizeGroupA_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 3 };
    const oid       messagePowerOffsetGroupB_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 4 };
    const oid       powerRampingStep_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 5 };
    const oid       preambleInitialReceivedTargetPower_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 6 };
    const oid       preambleTransMax_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 7 };
    const oid       responseWindowSize_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 8 };
    const oid       contentionResolutionTimer_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 9 };
    const oid       maxHARQMsg3Tx_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 1, 10 };
    const oid       drxEnabled_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 2, 1 };
    const oid       onDurationTimer_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 2, 2 };
    const oid       drxInactivityTimer_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 2, 3 };
    const oid       drxRetransmissionTimer_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 2, 4 };
    const oid       longDRXCycle_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 2, 5 };
    const oid       drxStartOffset_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 2, 6 };
    const oid       shortDRXCycle_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 2, 7 };
    const oid       drxShortCycleTimer_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 5, 2, 8 };
    const oid       srb1DefaultConfiguration_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 1, 1 };
    const oid       srb1TPollRetransmit_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 1, 2 };
    const oid       srb1PollPDU_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 1, 3 };
    const oid       srb1PollByte_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 1, 4 };
    const oid       srb1MaxRetxThreshold_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 1, 5 };
    const oid       srb1TReordering_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 1, 6 };
    const oid       srb1TStatusProhibit_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 1, 7 };
    const oid       srb2DefaultConfiguration_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 2, 1 };
    const oid       srb2TPollRetransmit_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 2, 2 };
    const oid       srb2PollPDU_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 2, 3 };
    const oid       srb2PollByte_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 2, 4 };
    const oid       srb2MaxRetxThreshold_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 2, 5 };
    const oid       srb2TReordering_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 2, 6 };
    const oid       srb2TStatusProhibit_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 6, 2, 7 };
    const oid       t300_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 1 };
    const oid       t301_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 2 };
    const oid       t302_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 3 };
    const oid       t304EUTRA_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 4 };
    const oid       t304IRAT_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 5 };
    const oid       t310_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 6 };
    const oid       t311_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 7 };
    const oid       t320_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 8 };
    const oid       n310_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 9 };
    const oid       n311_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 7, 10 };
    const oid       cellBarred_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 8, 1 };
    const oid       cellRestrictionCellReservedForOperatorUse_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 8, 2 };
    const oid       barringForEmergency_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 8, 3 };
    const oid       qHyst_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 1, 1 };
    const oid       qHystSFMedium_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 1, 2 };
    const oid       qHystSFHigh_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 1, 3 };
    const oid       tEvaluation_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 1, 4 };
    const oid       tHystNormal_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 1, 5 };
    const oid       nCellChangeMedium_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 1, 6 };
    const oid       nCellChangeHigh_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 1, 7 };
    const oid       qRxLevMinSIB1_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 1 };
    const oid       qRxLevMinSIB3_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 2 };
    const oid       qRxLevMinOffset_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 3 };
    const oid       sIntraSearch_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 4 };
    const oid       idleModeIntraFreqTReselectionEUTRA_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 5 };
    const oid       sNonIntraSearch_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 6 };
    const oid       idleModeIntraFreqCellReselectionPriority_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 7 };
    const oid       threshServingLow_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 8 };
    const oid       intraFreqTReselectionEUTRASFMedium_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 9 };
    const oid       intraFreqTReselectionEUTRASFHigh_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 2, 10 };
    const oid       maxCarrierEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 3, 1 };
    const oid       carrierNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 3, 2 };
    const oid       tReselectionUTRA_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 4, 1, 1 };
    const oid       tReselectionUTRASFMedium_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 4, 1, 2 };
    const oid       tReselectionUTRASFHigh_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 4, 1, 3 };
    const oid       utranFDDFreqNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 1, 4, 1, 4 };
    const oid       filterCoefficientRSRP_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 1 };
    const oid       filterCoefficientRSRQ_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 2 };
    const oid       a1ThresholdRSRP_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 3 };
    const oid       a1ThresholdRSRQ_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 4 };
    const oid       a2ThresholdRSRP_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 5 };
    const oid       a2ThresholdRSRQ_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 6 };
    const oid       a3Offset_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 7 };
    const oid       reportOnLeave_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 8 };
    const oid       a4ThresholdRSRP_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 9 };
    const oid       a4ThresholdRSRQ_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 10 };
    const oid       a5Threshold1RSRP_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 11 };
    const oid       a5Threshold1RSRQ_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 12 };
    const oid       a5Threshold2RSRP_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 13 };
    const oid       a5Threshold2RSRQ_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 14 };
    const oid       eutraHysteresis_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 15 };
    const oid       eutraTimeToTrigger_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 16 };
    const oid       triggerQuantity_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 17 };
    const oid       reportQuantity_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 18 };
    const oid       eutraReportInterval_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 19 };
    const oid       eutraReportAmount_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 1, 20 };
    const oid       qOffsettUTRA_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 1 };
    const oid       filterCoefficientUTRA_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 2 };
    const oid       measQuantityUTRAFDD_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 3 };
    const oid       b1ThresholdUTRARSCP_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 4 };
    const oid       b1ThresholdUTRAEcN0_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 5 };
    const oid       qoffsetGERAN_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 6 };
    const oid       filterCoefficientGERAN_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 7 };
    const oid       b1ThresholdGERAN_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 8 };
    const oid       qoffsetCDMA2000_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 9 };
    const oid       measQuantityCDMA2000_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 10 };
    const oid       b1ThresholdCDMA2000_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 11 };
    const oid       b2Threshold2UTRARSCP_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 12 };
    const oid       b2Threshold2UTRAEcN0_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 13 };
    const oid       b2Threshold2GERAN_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 14 };
    const oid       b2Threshold2CDMA2000_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 15 };
    const oid       iratHysteresis_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 16 };
    const oid       iratTimeToTrigger_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 17 };
    const oid       maxReportCells_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 18 };
    const oid       iratReportInterval_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 19 };
    const oid       iratReportAmount_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 9, 2, 2, 20 };
    const oid       neighborListMaxLTECellEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 10, 1 };
    const oid       neighborListLTECellNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 10, 2 };
    const oid       neighborListMaxUMTSEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 10, 4, 1 };
    const oid       neighborListUMTSNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 10, 4, 2 };
    const oid       neighborListInUseMaxLTECellEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 11, 1 };
    const oid       neighborListInUseLTECellNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 11, 2 };
    const oid       neighborListInUseMaxUMTSEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 11, 4, 1 };
    const oid       neighborListInUseUMTSNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 1, 2, 11, 4, 2 };

    const oid       eICICProvisionType_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 1 };
    const oid       numAbsReport_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 2, 1 };
    const oid       absUsageLowThreshold_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 2, 2 };
    const oid       absUsageHighThreshold_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 2, 3 };
    const oid       lowLoadAbsPattern_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 2, 4, 1 };
    const oid       victimAbsPattern_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 2, 4, 2 };
    const oid       victimMeasSubset_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 2, 4, 3 };
    const oid       eligibleUe_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 3 };
    const oid       macEicicMeasReportPeriodicity_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 4, 1 };
    const oid       aggressorSelTimer_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 4, 2 };
    const oid       loadInformationGuardTimer_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 4, 3 };
    const oid       loadInformationCollationTimer_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 4, 4 };
    const oid       dlSinrThreshLowMark_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 5 };
    const oid       dlSinrThreshHighMark_oid[] =
        { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 6, 2, 6 };

    const oid       sctpEnable_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 7, 1, 1 };
    const oid       hbInterval_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 7, 1, 2 };
    const oid       maxAssociationRetransmits_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 7, 1, 3 };
    const oid       maxPathRetransmits_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 7, 1, 4 };
    const oid       rTOInitial_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 7, 1, 5 };
    const oid       rTOMax_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 7, 1, 6 };
    const oid       rTOMin_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 7, 1, 7 };
    const oid       valCookieLife_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 3, 2, 7, 1, 8 };
    const oid       supportedAlarmNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 1 };
    const oid       maxCurrentAlarmEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 2 };
    const oid       currentAlarmNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 3 };
    const oid       historyEventNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 4 };
    const oid       expeditedEventNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 5 };
    const oid       queuedEventNumberOfEntries_oid[] =
    { 1, 3, 6, 1, 4, 1, 29601, 11, 20, 1, 4, 6 };

    DEBUGMSGTL(("aricentLTEeNodeBMIB", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("0", handle_manufacturer,
             manufacturer_oid,
             OID_LENGTH(manufacturer_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("1", handle_manufacturerOUI,
             manufacturerOUI_oid,
             OID_LENGTH(manufacturerOUI_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("2", handle_modelName, modelName_oid,
             OID_LENGTH(modelName_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("3", handle_description,
             description_oid, OID_LENGTH(description_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("4", handle_productClass,
             productClass_oid,
             OID_LENGTH(productClass_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("5", handle_serialNumber,
             serialNumber_oid,
             OID_LENGTH(serialNumber_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("6", handle_hardwareVersion,
             hardwareVersion_oid,
             OID_LENGTH(hardwareVersion_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("7", handle_softwareVersion,
             softwareVersion_oid,
             OID_LENGTH(softwareVersion_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("8",
             handle_modemFirmwareVersion,
             modemFirmwareVersion_oid,
             OID_LENGTH(modemFirmwareVersion_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("9",
             handle_additionalSoftwareVersion,
             additionalSoftwareVersion_oid,
             OID_LENGTH(additionalSoftwareVersion_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("10", handle_upTime, upTime_oid,
             OID_LENGTH(upTime_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("11", handle_firstUseDate,
             firstUseDate_oid,
             OID_LENGTH(firstUseDate_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("13",
             handle_configNumberOfEntries,
             configNumberOfEntries_oid,
             OID_LENGTH(configNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("14", handle_url, url_oid,
             OID_LENGTH(url_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("15", handle_userName, userName_oid,
             OID_LENGTH(userName_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("16", handle_password, password_oid,
             OID_LENGTH(password_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("17",
             handle_periodicUploadInterval,
             periodicUploadInterval_oid,
             OID_LENGTH(periodicUploadInterval_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("18",
             handle_periodicUploadTime,
             periodicUploadTime_oid,
             OID_LENGTH(periodicUploadTime_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("19", handle_fileWriteTimer,
             fileWriteTimer_oid,
             OID_LENGTH(fileWriteTimer_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("20",
             handle_samplingIntervalTimer,
             samplingIntervalTimer_oid,
             OID_LENGTH(samplingIntervalTimer_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("21",
             handle_enbServiceNumberOfEntries,
             enbServiceNumberOfEntries_oid,
             OID_LENGTH(enbServiceNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("23", handle_deviceType,
             deviceType_oid, OID_LENGTH(deviceType_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("24", handle_dnPrefix, dnPrefix_oid,
             OID_LENGTH(dnPrefix_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("25", handle_gpsEquipped,
             gpsEquipped_oid, OID_LENGTH(gpsEquipped_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("26", handle_maxTxPower,
             maxTxPower_oid, OID_LENGTH(maxTxPower_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("27", handle_supportedSystems,
             supportedSystems_oid,
             OID_LENGTH(supportedSystems_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("28", handle_beacon, beacon_oid,
             OID_LENGTH(beacon_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("29", handle_duplexMode,
             duplexMode_oid, OID_LENGTH(duplexMode_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("30", handle_bandsSupported,
             bandsSupported_oid,
             OID_LENGTH(bandsSupported_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("31", handle_nnsfSupported,
             nnsfSupported_oid,
             OID_LENGTH(nnsfSupported_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("32", handle_umtsRxSupported,
             umtsRxSupported_oid,
             OID_LENGTH(umtsRxSupported_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("33",
             handle_umtsRxBandsSupported,
             umtsRxBandsSupported_oid,
             OID_LENGTH(umtsRxBandsSupported_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("34", handle_gsmRxSupported,
             gsmRxSupported_oid,
             OID_LENGTH(gsmRxSupported_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("35",
             handle_gsmRxBandsSupported,
             gsmRxBandsSupported_oid,
             OID_LENGTH(gsmRxBandsSupported_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("36",
             handle_cdma2000RxSupported,
             cdma2000RxSupported_oid,
             OID_LENGTH(cdma2000RxSupported_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("37",
             handle_cdma2000RxBandsSupported,
             cdma2000RxBandsSupported_oid,
             OID_LENGTH(cdma2000RxBandsSupported_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("40", handle_opState, opState_oid,
             OID_LENGTH(opState_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("41", handle_adminState,
             adminState_oid, OID_LENGTH(adminState_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("42", handle_rfTxStatus,
             rfTxStatus_oid, OID_LENGTH(rfTxStatus_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("44", handle_secGWServer3,
             secGWServer3_oid,
             OID_LENGTH(secGWServer3_oid),
             HANDLER_CAN_RWRITE));  
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("45", handle_secGWServer2,
             secGWServer2_oid,
             OID_LENGTH(secGWServer2_oid),
             HANDLER_CAN_RWRITE));     
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("46",
             handle_s1SigLinkServerList,
             s1SigLinkServerList_oid,
             OID_LENGTH(s1SigLinkServerList_oid),
             HANDLER_CAN_RONLY));

    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("47", handle_secGWServer1,
             secGWServer1_oid,
             OID_LENGTH(secGWServer1_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("48", handle_s1SigLinkPort,
             s1SigLinkPort_oid,
             OID_LENGTH(s1SigLinkPort_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("49", handle_accessMode,
             accessMode_oid, OID_LENGTH(accessMode_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("50", handle_maxUEsServed,
             maxUEsServed_oid,
             OID_LENGTH(maxUEsServed_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("51", handle_maxCSGMembers,
             maxCSGMembers_oid,
             OID_LENGTH(maxCSGMembers_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("52", handle_maxNonCSGMembers,
             maxNonCSGMembers_oid,
             OID_LENGTH(maxNonCSGMembers_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("54", handle_csgid, csgid_oid,
             OID_LENGTH(csgid_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("55", handle_hnbName, hnbName_oid,
             OID_LENGTH(hnbName_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("57",
             handle_allowedCipheringAlgorithmList,
             allowedCipheringAlgorithmList_oid,
             OID_LENGTH(allowedCipheringAlgorithmList_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("58",
             handle_allowedIntegrityProtectionAlgorithmList,
             allowedIntegrityProtectionAlgorithmList_oid,
             OID_LENGTH
             (allowedIntegrityProtectionAlgorithmList_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("59", handle_tac, tac_oid,
             OID_LENGTH(tac_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("60", handle_eaid, eaid_oid,
             OID_LENGTH(eaid_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("61",
             handle_maxPLMNListEntries,
             maxPLMNListEntries_oid,
             OID_LENGTH(maxPLMNListEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("62",
             handle_plmnListNumberOfEntries,
             plmnListNumberOfEntries_oid,
             OID_LENGTH(plmnListNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("64",
             handle_qoSNumberOfEntries,
             qoSNumberOfEntries_oid,
             OID_LENGTH(qoSNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("65", handle_cellIdentity,
             cellIdentity_oid,
             OID_LENGTH(cellIdentity_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("66", handle_tRelocPrep,
             tRelocPrep_oid, OID_LENGTH(tRelocPrep_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("67", handle_tRelocOverall,
             tRelocOverall_oid,
             OID_LENGTH(tRelocOverall_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("68", handle_earfcnDL, earfcnDL_oid,
             OID_LENGTH(earfcnDL_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("69", handle_earfcnUL, earfcnUL_oid,
             OID_LENGTH(earfcnUL_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("70", handle_freqBandIndicator,
             freqBandIndicator_oid,
             OID_LENGTH(freqBandIndicator_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("71", handle_dlBandwidth,
             dlBandwidth_oid, OID_LENGTH(dlBandwidth_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("72", handle_ulBandwidth,
             ulBandwidth_oid, OID_LENGTH(ulBandwidth_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("73",
             handle_referenceSignalPower,
             referenceSignalPower_oid,
             OID_LENGTH(referenceSignalPower_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("74", handle_rfPhyCellID,
             rfPhyCellID_oid, OID_LENGTH(rfPhyCellID_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("75", handle_pschPowerOffset,
             pschPowerOffset_oid,
             OID_LENGTH(pschPowerOffset_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("76", handle_sschPowerOffset,
             sschPowerOffset_oid,
             OID_LENGTH(sschPowerOffset_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("77", handle_pbchPowerOffset,
             pbchPowerOffset_oid,
             OID_LENGTH(pbchPowerOffset_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("78", handle_antennaPortsCount,
             antennaPortsCount_oid,
             OID_LENGTH(antennaPortsCount_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("79", handle_pb, pb_oid, OID_LENGTH(pb_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("80", handle_pa, pa_oid, OID_LENGTH(pa_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("81", handle_srsEnabled,
             srsEnabled_oid, OID_LENGTH(srsEnabled_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("82",
             handle_srsBandwidthConfig,
             srsBandwidthConfig_oid,
             OID_LENGTH(srsBandwidthConfig_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("83", handle_srsMaxUpPTS,
             srsMaxUpPTS_oid, OID_LENGTH(srsMaxUpPTS_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("84",
             handle_ackNackSRSSimultaneousTransmission,
             ackNackSRSSimultaneousTransmission_oid,
             OID_LENGTH
             (ackNackSRSSimultaneousTransmission_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("85", handle_rootSequenceIndex,
             rootSequenceIndex_oid,
             OID_LENGTH(rootSequenceIndex_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("86",
             handle_configurationIndex,
             configurationIndex_oid,
             OID_LENGTH(configurationIndex_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("87", handle_highSpeedFlag,
             highSpeedFlag_oid,
             OID_LENGTH(highSpeedFlag_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("88",
             handle_zeroCorrelationZoneConfig,
             zeroCorrelationZoneConfig_oid,
             OID_LENGTH(zeroCorrelationZoneConfig_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("89", handle_freqOffset,
             freqOffset_oid, OID_LENGTH(freqOffset_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("90", handle_deltaPUCCHShift,
             deltaPUCCHShift_oid,
             OID_LENGTH(deltaPUCCHShift_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("91", handle_nrbcqi, nrbcqi_oid,
             OID_LENGTH(nrbcqi_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("92", handle_ncsan, ncsan_oid,
             OID_LENGTH(ncsan_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("93", handle_n1PUCCHAN, n1PUCCHAN_oid,
             OID_LENGTH(n1PUCCHAN_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("95", handle_nsb, nsb_oid,
             OID_LENGTH(nsb_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("96", handle_hoppingMode,
             hoppingMode_oid, OID_LENGTH(hoppingMode_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("97", handle_hoppingOffset,
             hoppingOffset_oid,
             OID_LENGTH(hoppingOffset_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("98", handle_enable64QAM,
             enable64QAM_oid, OID_LENGTH(enable64QAM_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("99",
             handle_groupHoppingEnabled,
             groupHoppingEnabled_oid,
             OID_LENGTH(groupHoppingEnabled_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("100",
             handle_groupAssignmentPUSCH,
             groupAssignmentPUSCH_oid,
             OID_LENGTH(groupAssignmentPUSCH_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("101",
             handle_sequenceHoppingEnabled,
             sequenceHoppingEnabled_oid,
             OID_LENGTH(sequenceHoppingEnabled_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("102", handle_cyclicShift,
             cyclicShift_oid, OID_LENGTH(cyclicShift_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("103", handle_p0NominalPUSCH,
             p0NominalPUSCH_oid,
             OID_LENGTH(p0NominalPUSCH_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("104", handle_alpha, alpha_oid,
             OID_LENGTH(alpha_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("105", handle_p0NominalPUCCH,
             p0NominalPUCCH_oid,
             OID_LENGTH(p0NominalPUCCH_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("106",
             handle_deltaFPUCCHFormat1,
             deltaFPUCCHFormat1_oid,
             OID_LENGTH(deltaFPUCCHFormat1_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("107",
             handle_deltaFPUCCHFormat1b,
             deltaFPUCCHFormat1b_oid,
             OID_LENGTH(deltaFPUCCHFormat1b_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("108",
             handle_deltaFPUCCHFormat2,
             deltaFPUCCHFormat2_oid,
             OID_LENGTH(deltaFPUCCHFormat2_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("109",
             handle_deltaFPUCCHFormat2a,
             deltaFPUCCHFormat2a_oid,
             OID_LENGTH(deltaFPUCCHFormat2a_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("110",
             handle_deltaFPUCCHFormat2b,
             deltaFPUCCHFormat2b_oid,
             OID_LENGTH(deltaFPUCCHFormat2b_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("111", handle_deltaPreambleMsg3,
             deltaPreambleMsg3_oid,
             OID_LENGTH(deltaPreambleMsg3_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("113",
             handle_numPRSResourceBlocks,
             numPRSResourceBlocks_oid,
             OID_LENGTH(numPRSResourceBlocks_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("114",
             handle_prsConfigurationIndex,
             prsConfigurationIndex_oid,
             OID_LENGTH(prsConfigurationIndex_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("115",
             handle_numConsecutivePRSSubframes,
             numConsecutivePRSSubframes_oid,
             OID_LENGTH(numConsecutivePRSSubframes_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("116",
             handle_subFrameAssignment,
             subFrameAssignment_oid,
             OID_LENGTH(subFrameAssignment_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("117",
             handle_specialSubframePatterns,
             specialSubframePatterns_oid,
             OID_LENGTH(specialSubframePatterns_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("118",
             handle_numberOfRaPreambles,
             numberOfRaPreambles_oid,
             OID_LENGTH(numberOfRaPreambles_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("119", handle_sizeOfRaGroupA,
             sizeOfRaGroupA_oid,
             OID_LENGTH(sizeOfRaGroupA_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("120", handle_messageSizeGroupA,
             messageSizeGroupA_oid,
             OID_LENGTH(messageSizeGroupA_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("121",
             handle_messagePowerOffsetGroupB,
             messagePowerOffsetGroupB_oid,
             OID_LENGTH(messagePowerOffsetGroupB_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("122", handle_powerRampingStep,
             powerRampingStep_oid,
             OID_LENGTH(powerRampingStep_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("123",
             handle_preambleInitialReceivedTargetPower,
             preambleInitialReceivedTargetPower_oid,
             OID_LENGTH
             (preambleInitialReceivedTargetPower_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("124", handle_preambleTransMax,
             preambleTransMax_oid,
             OID_LENGTH(preambleTransMax_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("125",
             handle_responseWindowSize,
             responseWindowSize_oid,
             OID_LENGTH(responseWindowSize_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("126",
             handle_contentionResolutionTimer,
             contentionResolutionTimer_oid,
             OID_LENGTH(contentionResolutionTimer_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("127", handle_maxHARQMsg3Tx,
             maxHARQMsg3Tx_oid,
             OID_LENGTH(maxHARQMsg3Tx_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("128", handle_drxEnabled,
             drxEnabled_oid, OID_LENGTH(drxEnabled_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("129", handle_onDurationTimer,
             onDurationTimer_oid,
             OID_LENGTH(onDurationTimer_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("130",
             handle_drxInactivityTimer,
             drxInactivityTimer_oid,
             OID_LENGTH(drxInactivityTimer_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("131",
             handle_drxRetransmissionTimer,
             drxRetransmissionTimer_oid,
             OID_LENGTH(drxRetransmissionTimer_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("132", handle_longDRXCycle,
             longDRXCycle_oid,
             OID_LENGTH(longDRXCycle_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("133", handle_drxStartOffset,
             drxStartOffset_oid,
             OID_LENGTH(drxStartOffset_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("134", handle_shortDRXCycle,
             shortDRXCycle_oid,
             OID_LENGTH(shortDRXCycle_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("135",
             handle_drxShortCycleTimer,
             drxShortCycleTimer_oid,
             OID_LENGTH(drxShortCycleTimer_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("136",
             handle_srb1DefaultConfiguration,
             srb1DefaultConfiguration_oid,
             OID_LENGTH(srb1DefaultConfiguration_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("137",
             handle_srb1TPollRetransmit,
             srb1TPollRetransmit_oid,
             OID_LENGTH(srb1TPollRetransmit_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("138", handle_srb1PollPDU,
             srb1PollPDU_oid, OID_LENGTH(srb1PollPDU_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("139", handle_srb1PollByte,
             srb1PollByte_oid,
             OID_LENGTH(srb1PollByte_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("140",
             handle_srb1MaxRetxThreshold,
             srb1MaxRetxThreshold_oid,
             OID_LENGTH(srb1MaxRetxThreshold_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("141", handle_srb1TReordering,
             srb1TReordering_oid,
             OID_LENGTH(srb1TReordering_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("142",
             handle_srb1TStatusProhibit,
             srb1TStatusProhibit_oid,
             OID_LENGTH(srb1TStatusProhibit_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("143",
             handle_srb2DefaultConfiguration,
             srb2DefaultConfiguration_oid,
             OID_LENGTH(srb2DefaultConfiguration_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("144",
             handle_srb2TPollRetransmit,
             srb2TPollRetransmit_oid,
             OID_LENGTH(srb2TPollRetransmit_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("145", handle_srb2PollPDU,
             srb2PollPDU_oid, OID_LENGTH(srb2PollPDU_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("146", handle_srb2PollByte,
             srb2PollByte_oid,
             OID_LENGTH(srb2PollByte_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("147",
             handle_srb2MaxRetxThreshold,
             srb2MaxRetxThreshold_oid,
             OID_LENGTH(srb2MaxRetxThreshold_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("148", handle_srb2TReordering,
             srb2TReordering_oid,
             OID_LENGTH(srb2TReordering_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("149",
             handle_srb2TStatusProhibit,
             srb2TStatusProhibit_oid,
             OID_LENGTH(srb2TStatusProhibit_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("150", handle_t300, t300_oid,
             OID_LENGTH(t300_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("151", handle_t301, t301_oid,
             OID_LENGTH(t301_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("152", handle_t302, t302_oid,
             OID_LENGTH(t302_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("153", handle_t304EUTRA, t304EUTRA_oid,
             OID_LENGTH(t304EUTRA_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("154", handle_t304IRAT, t304IRAT_oid,
             OID_LENGTH(t304IRAT_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("155", handle_t310, t310_oid,
             OID_LENGTH(t310_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("156", handle_t311, t311_oid,
             OID_LENGTH(t311_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("157", handle_t320, t320_oid,
             OID_LENGTH(t320_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("158", handle_n310, n310_oid,
             OID_LENGTH(n310_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("159", handle_n311, n311_oid,
             OID_LENGTH(n311_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("160", handle_cellBarred,
             cellBarred_oid, OID_LENGTH(cellBarred_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("161",
             handle_cellRestrictionCellReservedForOperatorUse,
             cellRestrictionCellReservedForOperatorUse_oid,
             OID_LENGTH
             (cellRestrictionCellReservedForOperatorUse_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("162",
             handle_barringForEmergency,
             barringForEmergency_oid,
             OID_LENGTH(barringForEmergency_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("163", handle_qHyst, qHyst_oid,
             OID_LENGTH(qHyst_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("164", handle_qHystSFMedium,
             qHystSFMedium_oid,
             OID_LENGTH(qHystSFMedium_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("165", handle_qHystSFHigh,
             qHystSFHigh_oid, OID_LENGTH(qHystSFHigh_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("166", handle_tEvaluation,
             tEvaluation_oid, OID_LENGTH(tEvaluation_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("167", handle_tHystNormal,
             tHystNormal_oid, OID_LENGTH(tHystNormal_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("168", handle_nCellChangeMedium,
             nCellChangeMedium_oid,
             OID_LENGTH(nCellChangeMedium_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("169", handle_nCellChangeHigh,
             nCellChangeHigh_oid,
             OID_LENGTH(nCellChangeHigh_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("170", handle_qRxLevMinSIB1,
             qRxLevMinSIB1_oid,
             OID_LENGTH(qRxLevMinSIB1_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("171", handle_qRxLevMinSIB3,
             qRxLevMinSIB3_oid,
             OID_LENGTH(qRxLevMinSIB3_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("172", handle_qRxLevMinOffset,
             qRxLevMinOffset_oid,
             OID_LENGTH(qRxLevMinOffset_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("173", handle_sIntraSearch,
             sIntraSearch_oid,
             OID_LENGTH(sIntraSearch_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("174",
             handle_idleModeIntraFreqTReselectionEUTRA,
             idleModeIntraFreqTReselectionEUTRA_oid,
             OID_LENGTH
             (idleModeIntraFreqTReselectionEUTRA_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("175", handle_sNonIntraSearch,
             sNonIntraSearch_oid,
             OID_LENGTH(sNonIntraSearch_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("176",
             handle_idleModeIntraFreqCellReselectionPriority,
             idleModeIntraFreqCellReselectionPriority_oid,
             OID_LENGTH
             (idleModeIntraFreqCellReselectionPriority_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("178", handle_threshServingLow,
             threshServingLow_oid,
             OID_LENGTH(threshServingLow_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("179",
             handle_carrierNumberOfEntries,
             carrierNumberOfEntries_oid,
             OID_LENGTH(carrierNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("180", handle_tReselectionUTRA,
             tReselectionUTRA_oid,
             OID_LENGTH(tReselectionUTRA_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("181",
             handle_tReselectionUTRASFHigh,
             tReselectionUTRASFHigh_oid,
             OID_LENGTH(tReselectionUTRASFHigh_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("182",
             handle_utranFDDFreqNumberOfEntries,
             utranFDDFreqNumberOfEntries_oid,
             OID_LENGTH(utranFDDFreqNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("190",
             handle_filterCoefficientRSRP,
             filterCoefficientRSRP_oid,
             OID_LENGTH(filterCoefficientRSRP_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("191",
             handle_filterCoefficientRSRQ,
             filterCoefficientRSRQ_oid,
             OID_LENGTH(filterCoefficientRSRQ_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("192", handle_a1ThresholdRSRP,
             a1ThresholdRSRP_oid,
             OID_LENGTH(a1ThresholdRSRP_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("193", handle_a1ThresholdRSRQ,
             a1ThresholdRSRQ_oid,
             OID_LENGTH(a1ThresholdRSRQ_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("194", handle_a2ThresholdRSRP,
             a2ThresholdRSRP_oid,
             OID_LENGTH(a2ThresholdRSRP_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("195", handle_a2ThresholdRSRQ,
             a2ThresholdRSRQ_oid,
             OID_LENGTH(a2ThresholdRSRQ_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("196", handle_a3Offset, a3Offset_oid,
             OID_LENGTH(a3Offset_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("197", handle_reportOnLeave,
             reportOnLeave_oid,
             OID_LENGTH(reportOnLeave_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("198", handle_a4ThresholdRSRP,
             a4ThresholdRSRP_oid,
             OID_LENGTH(a4ThresholdRSRP_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("199", handle_a4ThresholdRSRQ,
             a4ThresholdRSRQ_oid,
             OID_LENGTH(a4ThresholdRSRQ_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("200", handle_a5Threshold1RSRP,
             a5Threshold1RSRP_oid,
             OID_LENGTH(a5Threshold1RSRP_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("201", handle_a5Threshold1RSRQ,
             a5Threshold1RSRQ_oid,
             OID_LENGTH(a5Threshold1RSRQ_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("202", handle_a5Threshold2RSRP,
             a5Threshold2RSRP_oid,
             OID_LENGTH(a5Threshold2RSRP_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("203", handle_a5Threshold2RSRQ,
             a5Threshold2RSRQ_oid,
             OID_LENGTH(a5Threshold2RSRQ_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("204", handle_eutraHysteresis,
             eutraHysteresis_oid,
             OID_LENGTH(eutraHysteresis_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("205",
             handle_eutraTimeToTrigger,
             eutraTimeToTrigger_oid,
             OID_LENGTH(eutraTimeToTrigger_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("206", handle_triggerQuantity,
             triggerQuantity_oid,
             OID_LENGTH(triggerQuantity_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("207", handle_reportQuantity,
             reportQuantity_oid,
             OID_LENGTH(reportQuantity_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("208", handle_maxReportCells,
             maxReportCells_oid,
             OID_LENGTH(maxReportCells_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("209",
             handle_eutraReportInterval,
             eutraReportInterval_oid,
             OID_LENGTH(eutraReportInterval_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("210", handle_eutraReportAmount,
             eutraReportAmount_oid,
             OID_LENGTH(eutraReportAmount_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("211", handle_qOffsettUTRA,
             qOffsettUTRA_oid,
             OID_LENGTH(qOffsettUTRA_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("212",
             handle_filterCoefficientUTRA,
             filterCoefficientUTRA_oid,
             OID_LENGTH(filterCoefficientUTRA_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("213",
             handle_measQuantityUTRAFDD,
             measQuantityUTRAFDD_oid,
             OID_LENGTH(measQuantityUTRAFDD_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("214",
             handle_b1ThresholdUTRARSCP,
             b1ThresholdUTRARSCP_oid,
             OID_LENGTH(b1ThresholdUTRARSCP_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("215",
             handle_b1ThresholdUTRAEcN0,
             b1ThresholdUTRAEcN0_oid,
             OID_LENGTH(b1ThresholdUTRAEcN0_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("216", handle_qoffsetGERAN,
             qoffsetGERAN_oid,
             OID_LENGTH(qoffsetGERAN_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("217",
             handle_filterCoefficientGERAN,
             filterCoefficientGERAN_oid,
             OID_LENGTH(filterCoefficientGERAN_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("218", handle_b1ThresholdGERAN,
             b1ThresholdGERAN_oid,
             OID_LENGTH(b1ThresholdGERAN_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("219", handle_qoffsetCDMA2000,
             qoffsetCDMA2000_oid,
             OID_LENGTH(qoffsetCDMA2000_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("220",
             handle_measQuantityCDMA2000,
             measQuantityCDMA2000_oid,
             OID_LENGTH(measQuantityCDMA2000_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("221",
             handle_b1ThresholdCDMA2000,
             b1ThresholdCDMA2000_oid,
             OID_LENGTH(b1ThresholdCDMA2000_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("222",
             handle_b2Threshold2UTRARSCP,
             b2Threshold2UTRARSCP_oid,
             OID_LENGTH(b2Threshold2UTRARSCP_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("223",
             handle_b2Threshold2UTRAEcN0,
             b2Threshold2UTRAEcN0_oid,
             OID_LENGTH(b2Threshold2UTRAEcN0_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("224", handle_b2Threshold2GERAN,
             b2Threshold2GERAN_oid,
             OID_LENGTH(b2Threshold2GERAN_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("225",
             handle_b2Threshold2CDMA2000,
             b2Threshold2CDMA2000_oid,
             OID_LENGTH(b2Threshold2CDMA2000_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("226", handle_iratHysteresis,
             iratHysteresis_oid,
             OID_LENGTH(iratHysteresis_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("227", handle_iratTimeToTrigger,
             iratTimeToTrigger_oid,
             OID_LENGTH(iratTimeToTrigger_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("229",
             handle_iratReportInterval,
             iratReportInterval_oid,
             OID_LENGTH(iratReportInterval_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("230", handle_iratReportAmount,
             iratReportAmount_oid,
             OID_LENGTH(iratReportAmount_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("231",
             handle_neighborListMaxLTECellEntries,
             neighborListMaxLTECellEntries_oid,
             OID_LENGTH(neighborListMaxLTECellEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("232",
             handle_neighborListLTECellNumberOfEntries,
             neighborListLTECellNumberOfEntries_oid,
             OID_LENGTH
             (neighborListLTECellNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("233",
             handle_neighborListMaxUMTSEntries,
             neighborListMaxUMTSEntries_oid,
             OID_LENGTH(neighborListMaxUMTSEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("234",
             handle_neighborListUMTSNumberOfEntries,
             neighborListUMTSNumberOfEntries_oid,
             OID_LENGTH
             (neighborListUMTSNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("239",
             handle_neighborListInUseMaxLTECellEntries,
             neighborListInUseMaxLTECellEntries_oid,
             OID_LENGTH
             (neighborListInUseMaxLTECellEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("240",
             handle_neighborListInUseLTECellNumberOfEntries,
             neighborListInUseLTECellNumberOfEntries_oid,
             OID_LENGTH
             (neighborListInUseLTECellNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("241",
             handle_neighborListInUseMaxUMTSEntries,
             neighborListInUseMaxUMTSEntries_oid,
             OID_LENGTH
             (neighborListInUseMaxUMTSEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("242",
             handle_neighborListInUseUMTSNumberOfEntries,
             neighborListInUseUMTSNumberOfEntries_oid,
             OID_LENGTH
             (neighborListInUseUMTSNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("243", handle_sctpEnable,
             sctpEnable_oid, OID_LENGTH(sctpEnable_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("244", handle_hbInterval,
             hbInterval_oid, OID_LENGTH(hbInterval_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("245",
             handle_maxAssociationRetransmits,
             maxAssociationRetransmits_oid,
             OID_LENGTH(maxAssociationRetransmits_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("246",
             handle_maxPathRetransmits,
             maxPathRetransmits_oid,
             OID_LENGTH(maxPathRetransmits_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("247", handle_rTOInitial,
             rTOInitial_oid, OID_LENGTH(rTOInitial_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("248", handle_rTOMax, rTOMax_oid,
             OID_LENGTH(rTOMax_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("249", handle_rTOMin, rTOMin_oid,
             OID_LENGTH(rTOMin_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("250", handle_valCookieLife,
             valCookieLife_oid,
             OID_LENGTH(valCookieLife_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("251",
             handle_supportedAlarmNumberOfEntries,
             supportedAlarmNumberOfEntries_oid,
             OID_LENGTH(supportedAlarmNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("252",
             handle_maxCurrentAlarmEntries,
             maxCurrentAlarmEntries_oid,
             OID_LENGTH(maxCurrentAlarmEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("253",
             handle_currentAlarmNumberOfEntries,
             currentAlarmNumberOfEntries_oid,
             OID_LENGTH(currentAlarmNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("254",
             handle_historyEventNumberOfEntries,
             historyEventNumberOfEntries_oid,
             OID_LENGTH(historyEventNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("255",
             handle_expeditedEventNumberOfEntries,
             expeditedEventNumberOfEntries_oid,
             OID_LENGTH(expeditedEventNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("256",
             handle_queuedEventNumberOfEntries,
             queuedEventNumberOfEntries_oid,
             OID_LENGTH(queuedEventNumberOfEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("257", handle_enbCtrlCellAction,
             enbCtrlCellAction_oid,
             OID_LENGTH(enbCtrlCellAction_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("12",
             handle_intraFreqTReselectionEUTRASFMedium,
             intraFreqTReselectionEUTRASFMedium_oid,
             OID_LENGTH(intraFreqTReselectionEUTRASFMedium_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("22",
             handle_intraFreqTReselectionEUTRASFHigh,
             intraFreqTReselectionEUTRASFHigh_oid,
             OID_LENGTH
             (intraFreqTReselectionEUTRASFHigh_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("38",
             handle_tReselectionUTRASFMedium,
             tReselectionUTRASFMedium_oid,
             OID_LENGTH(tReselectionUTRASFMedium_oid),
             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
            ("39", handle_maxCarrierEntries,
             maxCarrierEntries_oid,
             OID_LENGTH(maxCarrierEntries_oid),
             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
           ("43", handle_availabilityStatus,
            availabilityStatus_oid,
            OID_LENGTH(availabilityStatus_oid),
            HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
          ("258", handle_enbSWUpdateAction,
           enbSWUpdateAction_oid,
           OID_LENGTH(enbSWUpdateAction_oid),
           HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
          ("259", handle_enbSWImageFile,
           enbSWImageFile_oid,
           OID_LENGTH(enbSWImageFile_oid),
           HANDLER_CAN_RWRITE));            
    netsnmp_register_scalar(netsnmp_create_handler_registration
           ("373", handle_enbConfiguredCID,
           enbConfiguredCID_oid,
           OID_LENGTH(enbConfiguredCID_oid),
           HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
           ("374", handle_enbCurrentCID,
           enbCurrentCID_oid,
           OID_LENGTH(enbCurrentCID_oid),
           HANDLER_CAN_RWRITE));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("375",
                             handle_eICICProvisionType,
                             eICICProvisionType_oid,
                             OID_LENGTH(eICICProvisionType_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("376", handle_numAbsReport,
                             numAbsReport_oid,
                             OID_LENGTH(numAbsReport_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("377",
                             handle_absUsageLowThreshold,
                             absUsageLowThreshold_oid,
                             OID_LENGTH(absUsageLowThreshold_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("378",
                             handle_absUsageHighThreshold,
                             absUsageHighThreshold_oid,
                             OID_LENGTH(absUsageHighThreshold_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("379", handle_lowLoadAbsPattern,
                             lowLoadAbsPattern_oid,
                             OID_LENGTH(lowLoadAbsPattern_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("380", handle_victimAbsPattern,
                             victimAbsPattern_oid,
                             OID_LENGTH(victimAbsPattern_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("381", handle_victimMeasSubset,
                             victimMeasSubset_oid,
                             OID_LENGTH(victimMeasSubset_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("382", handle_eligibleUe,
                             eligibleUe_oid, OID_LENGTH(eligibleUe_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("383",
                             handle_macEicicMeasReportPeriodicity,
                             macEicicMeasReportPeriodicity_oid,
                             OID_LENGTH(macEicicMeasReportPeriodicity_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("384", handle_aggressorSelTimer,
                             aggressorSelTimer_oid,
                             OID_LENGTH(aggressorSelTimer_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("385",
                             handle_loadInformationGuardTimer,
                             loadInformationGuardTimer_oid,
                             OID_LENGTH(loadInformationGuardTimer_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("386",
                             handle_loadInformationCollationTimer,
                             loadInformationCollationTimer_oid,
                             OID_LENGTH(loadInformationCollationTimer_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("387",
                             handle_dlSinrThreshLowMark,
                             dlSinrThreshLowMark_oid,
                             OID_LENGTH(dlSinrThreshLowMark_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("388",
                             handle_dlSinrThreshHighMark,
                             dlSinrThreshHighMark_oid,
                             OID_LENGTH(dlSinrThreshHighMark_oid),
                             HANDLER_CAN_RWRITE));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("389", handle_neighCellConfig,
                             neighCellConfig_oid,
                             OID_LENGTH(neighCellConfig_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("390",
                             handle_maxSFConfigListEntries,
                             maxSFConfigListEntries_oid,
                             OID_LENGTH(maxSFConfigListEntries_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("391",
                             handle_sfConfigListNumberOfEntries,
                             sfConfigListNumberOfEntries_oid,
                             OID_LENGTH(sfConfigListNumberOfEntries_oid),
                             HANDLER_CAN_RONLY));
    /* EMBMS Changes End */

}


/******************************************************************************
 * Function Name    : handle_manufacturer
 * DESCRIPTION      : It is a handler function
 * RETURNS          : SUCCESS/FAILURE
 ******************************************************************************/
    int
handle_manufacturer(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = 0;
    int param_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, param_type );

            }
            break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_manufacturer\n",reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



    int
handle_manufacturerOUI(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_manufacturerOUI\n",reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_modelName(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{

    mgmt_return_et retVal  = OAM_SNMP_SUCCESS;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode)
    {

        case MODE_GET:
            {
                /* call get handler from here
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );
            }
            break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_modelName\n",reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_description(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_description\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_productClass(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_productClass\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_serialNumber(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_serialNumber\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_hardwareVersion(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hardwareVersion\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_softwareVersion(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_softwareVersion\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_modemFirmwareVersion(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_modemFirmwareVersion\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_additionalSoftwareVersion(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_additionalSoftwareVersion\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_upTime(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_upTime\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_firstUseDate(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_firstUseDate\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_configNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_configNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_secGWServer1(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_OCTET_STR;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
 *      * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
 *      * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode)
    {

        case MODE_GET:
            {
                /* call get handler from here
 *                  * this would further send GPV request to OAM
 *                                   * and wait for the GPV response -- signaling
 *                                                    * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
 *              * SET REQUEST
 *                           *
 *                                        * multiple states in the transaction.  See:
 *                                                     * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
 *                                                                  */
        case MODE_SET_RESERVE1:
            /*
 *              * or you could use netsnmp_check_vb_type_and_size instead
 *                           */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
 *              * XXX malloc "undo" storage buffer
 *                           */
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
 *              * XXX: free resources allocated in RESERVE1 and/or
 *                           * RESERVE2.  Something failed somewhere, and the states
 *                                        * below won't be called.
 *                                                     */
            break;
        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
 *              * XXX: delete temporary storage
 *                           */
            break;

        case MODE_SET_UNDO:
            /*
 *              * XXX: UNDO and return to previous value for the object
 *                           */
            break;

        default:
            /*
 *              * we should never get here, so this is a really bad error
 *                           */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_secGWServer1\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
    int
handle_secGWServer2(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_OCTET_STR;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
 *  *      * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
 *  *      * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode)
    {

        case MODE_GET:
            {
                /* call get handler from here
 *  *                  * this would further send GPV request to OAM
 *   *                                   * and wait for the GPV response -- signaling
 *    *                                                    * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
 *  *              * SET REQUEST
 *   *                           *
 *    *                                        * multiple states in the transaction.  See:
 *     *                                                     * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
 *      *                                                                  */
        case MODE_SET_RESERVE1:
            /*
 *  *              * or you could use netsnmp_check_vb_type_and_size instead
 *   *                           */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
 *  *              * XXX malloc "undo" storage buffer
 *   *                           */
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;
        case MODE_SET_FREE:
            /*
 *  *              * XXX: free resources allocated in RESERVE1 and/or
 *   *                           * RESERVE2.  Something failed somewhere, and the states
 *    *                                        * below won't be called.
 *     *                                                     */
            break;
        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
 *  *              * XXX: delete temporary storage
 *   *                           */
            break;

        case MODE_SET_UNDO:
            /*
 *  *              * XXX: UNDO and return to previous value for the object
 *   *                           */
            break;

        default:
            /*
 *  *              * we should never get here, so this is a really bad error
 *   *                           */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_secGWServer2\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


    int
handle_secGWServer3(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_OCTET_STR;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
 *  *      * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
 *  *      * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode)
    {

        case MODE_GET:
            {
                /* call get handler from here
 *  *                  * this would further send GPV request to OAM
 *   *                                   * and wait for the GPV response -- signaling
 *    *                                                    * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
 *  *              * SET REQUEST
 *   *                           *
 *    *                                        * multiple states in the transaction.  See:
 *     *                                                     * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
 *      *                                                                  */
        case MODE_SET_RESERVE1:
            /*
 *  *              * or you could use netsnmp_check_vb_type_and_size instead
 *   *                           */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
 *  *              * XXX malloc "undo" storage buffer
 *   *                           */
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;
        case MODE_SET_FREE:
            /*
 *  *              * XXX: free resources allocated in RESERVE1 and/or
 *   *                           * RESERVE2.  Something failed somewhere, and the states
 *    *                                        * below won't be called.
 *     *                                                     */
            break;
        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
 *  *              * XXX: delete temporary storage
 *   *                           */
            break;

        case MODE_SET_UNDO:
            /*
 *  *              * XXX: UNDO and return to previous value for the object
 *   *                           */
            break;

        default:
            /*
 *  *              * we should never get here, so this is a really bad error
 *   *                           */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_secGWServer3\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


    int
handle_url(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_OCTET_STR;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_url\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_userName(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_userName\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_password(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_password\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_periodicUploadInterval(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_periodicUploadInterval\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_periodicUploadTime(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;
    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_periodicUploadTime\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_fileWriteTimer(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fileWriteTimer\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_samplingIntervalTimer(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_samplingIntervalTimer\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_enbServiceNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_enbServiceNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_deviceType(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_deviceType\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_dnPrefix(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dnPrefix\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_gpsEquipped(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gpsEquipped\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxTxPower(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_maxTxPower\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_supportedSystems(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_supportedSystems\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_beacon(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_beacon\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_duplexMode(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_duplexMode\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_bandsSupported(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_bandsSupported\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_nnsfSupported(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nnsfSupported\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_umtsRxSupported(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_umtsRxSupported\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_umtsRxBandsSupported(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_umtsRxBandsSupported\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_gsmRxSupported(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsmRxSupported\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_gsmRxBandsSupported(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{   int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_gsmRxBandsSupported\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_cdma2000RxSupported(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_cdma2000RxSupported\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_cdma2000RxBandsSupported(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_cdma2000RxBandsSupported\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_opState(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_opState\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_adminState(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_adminState\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_rfTxStatus(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rfTxStatus\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_s1SigLinkServerList(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_s1SigLinkServerList\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_s1SigLinkPort(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_s1SigLinkPort\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_accessMode(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_accessMode\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxUEsServed(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_maxUEsServed\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxCSGMembers(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
			retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_maxCSGMembers\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxNonCSGMembers(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_maxNonCSGMembers\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_csgid(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_csgid\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_hnbName(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hnbName\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_allowedCipheringAlgorithmList(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_allowedCipheringAlgorithmList\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_allowedIntegrityProtectionAlgorithmList(netsnmp_mib_handler
        *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info
        *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_allowedIntegrityProtectionAlgorithmList\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_tac(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_tac\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_eaid(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_eaid\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxPLMNListEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_maxPLMNListEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_plmnListNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_plmnListNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qoSNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_qoSNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_cellIdentity(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cellIdentity\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_tRelocPrep(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_tRelocPrep\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_tRelocOverall(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_tRelocOverall\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_earfcnDL(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_earfcnDL\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_earfcnUL(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_earfcnUL\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_freqBandIndicator(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{   
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_freqBandIndicator\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_dlBandwidth(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dlBandwidth\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_ulBandwidth(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ulBandwidth\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_referenceSignalPower(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_referenceSignalPower\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_rfPhyCellID(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rfPhyCellID\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_pschPowerOffset(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pschPowerOffset\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_sschPowerOffset(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sschPowerOffset\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_pbchPowerOffset(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pbchPowerOffset\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_antennaPortsCount(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_antennaPortsCount\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_pb(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pb\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_pa(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_pa\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srsEnabled(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_srsEnabled\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srsBandwidthConfig(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srsBandwidthConfig\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srsMaxUpPTS(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_srsMaxUpPTS\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_ackNackSRSSimultaneousTransmission(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_ackNackSRSSimultaneousTransmission\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_rootSequenceIndex(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_rootSequenceIndex\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_configurationIndex(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_configurationIndex\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_highSpeedFlag(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_highSpeedFlag\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_zeroCorrelationZoneConfig(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_zeroCorrelationZoneConfig\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_freqOffset(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_freqOffset\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_deltaPUCCHShift(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_deltaPUCCHShift\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_nrbcqi(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nrbcqi\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_ncsan(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ncsan\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_n1PUCCHAN(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_n1PUCCHAN\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


    int
handle_nsb(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{

    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nsb\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_hoppingMode(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hoppingMode\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_hoppingOffset(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hoppingOffset\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_enable64QAM(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_enable64QAM\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_groupHoppingEnabled(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_groupHoppingEnabled\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_groupAssignmentPUSCH(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_groupAssignmentPUSCH\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_sequenceHoppingEnabled(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_sequenceHoppingEnabled\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_cyclicShift(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cyclicShift\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_p0NominalPUSCH(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_p0NominalPUSCH\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_alpha(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_alpha\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_p0NominalPUCCH(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_p0NominalPUCCH\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_deltaFPUCCHFormat1(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_deltaFPUCCHFormat1\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_deltaFPUCCHFormat1b(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_deltaFPUCCHFormat1b\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_deltaFPUCCHFormat2(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_deltaFPUCCHFormat2\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_deltaFPUCCHFormat2a(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_deltaFPUCCHFormat2a\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_deltaFPUCCHFormat2b(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_deltaFPUCCHFormat2b\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_deltaPreambleMsg3(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_deltaPreambleMsg3\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* EMBMS Changes Start */
int
handle_neighCellConfig(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type);

            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if ( 0 ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        
            SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests,0);
                        
            }
           
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if ( 0 ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if ( 0 ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_neighCellConfig\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_maxSFConfigListEntries(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

        case MODE_GET:
        {
            /* call get handler from here 
             * this would further send GPV request to OAM
             * and wait for the GPV response -- signaling
             * once the response is received the value for the parameter shall be passed in the below function*/

            SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type);

        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_maxSFConfigListEntries\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_sfConfigListNumberOfEntries(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

        case MODE_GET:
        {
            /* call get handler from here 
             * this would further send GPV request to OAM
             * and wait for the GPV response -- signaling
             * once the response is received the value for the parameter shall be passed in the below function*/

            SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type);

        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_sfConfigListNumberOfEntries\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
/* EMBMS Changes End */
    int
handle_numPRSResourceBlocks(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_numPRSResourceBlocks\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_prsConfigurationIndex(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_UNSIGNED;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_prsConfigurationIndex\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_numConsecutivePRSSubframes(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_numConsecutivePRSSubframes\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_subFrameAssignment(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_subFrameAssignment\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_specialSubframePatterns(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_specialSubframePatterns\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_numberOfRaPreambles(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_numberOfRaPreambles\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_sizeOfRaGroupA(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sizeOfRaGroupA\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_messageSizeGroupA(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_INTEGER;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_messageSizeGroupA\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_messagePowerOffsetGroupB(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_messagePowerOffsetGroupB\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_powerRampingStep(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_powerRampingStep\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_preambleInitialReceivedTargetPower(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_preambleInitialReceivedTargetPower\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_preambleTransMax(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_preambleTransMax\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_responseWindowSize(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_responseWindowSize\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_contentionResolutionTimer(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_contentionResolutionTimer\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxHARQMsg3Tx(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_maxHARQMsg3Tx\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_drxEnabled(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_drxEnabled\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_onDurationTimer(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_onDurationTimer\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_drxInactivityTimer(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_drxInactivityTimer\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_drxRetransmissionTimer(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_drxRetransmissionTimer\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_longDRXCycle(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_longDRXCycle\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_drxStartOffset(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_drxStartOffset\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_shortDRXCycle(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_shortDRXCycle\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_drxShortCycleTimer(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_drxShortCycleTimer\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb1DefaultConfiguration(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srb1DefaultConfiguration\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb1TPollRetransmit(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srb1TPollRetransmit\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb1PollPDU(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_srb1PollPDU\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb1PollByte(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_srb1PollByte\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb1MaxRetxThreshold(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srb1MaxRetxThreshold\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb1TReordering(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_INTEGER;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_srb1TReordering\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb1TStatusProhibit(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srb1TStatusProhibit\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb2DefaultConfiguration(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srb2DefaultConfiguration\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb2TPollRetransmit(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srb2TPollRetransmit\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb2PollPDU(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_srb2PollPDU\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb2PollByte(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_srb2PollByte\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb2MaxRetxThreshold(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srb2MaxRetxThreshold\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb2TReordering(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_srb2TReordering\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_srb2TStatusProhibit(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_srb2TStatusProhibit\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_t300(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_t300\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_t301(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_t301\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_t302(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_t302\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_t304EUTRA(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_t304EUTRA\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_t304IRAT(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_t304IRAT\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_t310(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_t310\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_t311(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_t311\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_t320(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_t320\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_n310(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;
            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_n310\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_n311(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_INTEGER;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_n311\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_cellBarred(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_cellBarred\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cellRestrictionCellReservedForOperatorUse(netsnmp_mib_handler
        *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info
        *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;      

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_cellRestrictionCellReservedForOperatorUse\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_barringForEmergency(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_barringForEmergency\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qHyst(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_qHyst\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qHystSFMedium(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_INTEGER;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_qHystSFMedium\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qHystSFHigh(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_INTEGER;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_qHystSFHigh\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_tEvaluation(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int asn_type = ASN_INTEGER;
    int retVal = SNMP_ERR_NOERROR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_tEvaluation\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_tHystNormal(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_tHystNormal\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_nCellChangeMedium(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_nCellChangeMedium\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_nCellChangeHigh(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nCellChangeHigh\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qRxLevMinSIB1(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_qRxLevMinSIB1\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qRxLevMinSIB3(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_qRxLevMinSIB3\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qRxLevMinOffset(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_qRxLevMinOffset\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_sIntraSearch(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_sIntraSearch\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_idleModeIntraFreqTReselectionEUTRA(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_idleModeIntraFreqTReselectionEUTRA\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_sNonIntraSearch(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_sNonIntraSearch\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_idleModeIntraFreqCellReselectionPriority(netsnmp_mib_handler
        *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info
        *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_idleModeIntraFreqCellReselectionPriority\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_threshServingLow(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_threshServingLow\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_carrierNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_carrierNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_tReselectionUTRA(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_tReselectionUTRA\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_utranFDDFreqNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_utranFDDFreqNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_filterCoefficientRSRP(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_filterCoefficientRSRP\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_filterCoefficientRSRQ(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_filterCoefficientRSRQ\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a1ThresholdRSRP(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a1ThresholdRSRP\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a1ThresholdRSRQ(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a1ThresholdRSRQ\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a2ThresholdRSRP(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a2ThresholdRSRP\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a2ThresholdRSRQ(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a2ThresholdRSRQ\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a3Offset(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a3Offset\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_reportOnLeave(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_reportOnLeave\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a4ThresholdRSRP(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a4ThresholdRSRP\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a4ThresholdRSRQ(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a4ThresholdRSRQ\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a5Threshold1RSRP(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a5Threshold1RSRP\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a5Threshold1RSRQ(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a5Threshold1RSRQ\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a5Threshold2RSRP(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a5Threshold2RSRP\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_a5Threshold2RSRQ(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_a5Threshold2RSRQ\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_eutraHysteresis(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_eutraHysteresis\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_eutraTimeToTrigger(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_eutraTimeToTrigger\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_triggerQuantity(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_triggerQuantity\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_reportQuantity(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_reportQuantity\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_eutraReportInterval(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_eutraReportInterval\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_eutraReportAmount(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_eutraReportAmount\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qOffsettUTRA(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_qOffsettUTRA\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_filterCoefficientUTRA(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_filterCoefficientUTRA\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_measQuantityUTRAFDD(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_measQuantityUTRAFDD\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_b1ThresholdUTRARSCP(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_b1ThresholdUTRARSCP\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_b1ThresholdUTRAEcN0(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_b1ThresholdUTRAEcN0\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qoffsetGERAN(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_qoffsetGERAN\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_filterCoefficientGERAN(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_filterCoefficientGERAN\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_b1ThresholdGERAN(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_b1ThresholdGERAN\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_qoffsetCDMA2000(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_qoffsetCDMA2000\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_measQuantityCDMA2000(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_measQuantityCDMA2000\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_b1ThresholdCDMA2000(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_b1ThresholdCDMA2000\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_b2Threshold2UTRARSCP(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_b2Threshold2UTRARSCP\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_b2Threshold2UTRAEcN0(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_b2Threshold2UTRAEcN0\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_b2Threshold2GERAN(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_b2Threshold2GERAN\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_b2Threshold2CDMA2000(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_b2Threshold2CDMA2000\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_iratHysteresis(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iratHysteresis\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_iratTimeToTrigger(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_iratTimeToTrigger\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxReportCells(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_maxReportCells\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_iratReportInterval(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_iratReportInterval\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_iratReportAmount(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iratReportAmount\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_neighborListMaxLTECellEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_neighborListMaxLTECellEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_neighborListLTECellNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_neighborListLTECellNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_neighborListMaxUMTSEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_neighborListMaxUMTSEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_neighborListUMTSNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_neighborListUMTSNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_neighborListInUseMaxLTECellEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_neighborListInUseMaxLTECellEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_neighborListInUseLTECellNumberOfEntries(netsnmp_mib_handler
        *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info
        *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_neighborListInUseLTECellNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_neighborListInUseMaxUMTSEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_neighborListInUseMaxUMTSEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_neighborListInUseUMTSNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_neighborListInUseUMTSNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_eICICProvisionType(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_eICICProvisionType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_numAbsReport(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        {
            SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );
        }

        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_numAbsReport\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_absUsageLowThreshold(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }

        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_absUsageLowThreshold\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_absUsageHighThreshold(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }

        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_absUsageHighThreshold\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_lowLoadAbsPattern(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }

        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_lowLoadAbsPattern\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_victimAbsPattern(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:

            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_victimAbsPattern\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_victimMeasSubset(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:

            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */

            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_victimMeasSubset\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_eligibleUe(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:

            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */

            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_eligibleUe\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_macEicicMeasReportPeriodicity(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:

            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */

            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_macEicicMeasReportPeriodicity\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_aggressorSelTimer(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:

            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */

            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_aggressorSelTimer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_loadInformationGuardTimer(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:

            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_loadInformationGuardTimer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_loadInformationCollationTimer(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */

            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_loadInformationCollationTimer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlSinrThreshLowMark(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */

            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dlSinrThreshLowMark\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dlSinrThreshHighMark(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:

            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
        if (retVal != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, retVal);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dlSinrThreshHighMark\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_sctpEnable(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_sctpEnable\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_hbInterval(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_hbInterval\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxAssociationRetransmits(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_maxAssociationRetransmits\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxPathRetransmits(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_maxPathRetransmits\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_rTOInitial(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rTOInitial\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_rTOMax(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rTOMax\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_rTOMin(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_rTOMin\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_valCookieLife(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_valCookieLife\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_supportedAlarmNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_supportedAlarmNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxCurrentAlarmEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_maxCurrentAlarmEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_currentAlarmNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_currentAlarmNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_historyEventNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_historyEventNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_expeditedEventNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_expeditedEventNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_queuedEventNumberOfEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;



        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_queuedEventNumberOfEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_intraFreqTReselectionEUTRASFMedium(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_intraFreqTReselectionEUTRASFMedium\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_intraFreqTReselectionEUTRASFHigh(netsnmp_mib_handler *handler,
        netsnmp_handler_registration
        *reginfo,
        netsnmp_agent_request_info
        *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_intraFreqTReselectionEUTRASFHigh\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


    int
handle_tReselectionUTRASFHigh(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            {
                SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
                if (0 ) {
                    netsnmp_set_request_error(reqinfo, requests,0 );
                }
            }
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_tReselectionUTRASFHigh\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_tReselectionUTRASFMedium(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here 
             */
            SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_tReselectionUTRASFMedium\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_availabilityStatus(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_availabilityStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_enbCtrlCellAction(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;

            /*
             * SET REQUEST
             *
             * multiple states in the transaction.  See:
             * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
             */
        case MODE_SET_RESERVE1:
            /*
             * or you could use netsnmp_check_vb_type_and_size instead 
             */
            retVal = netsnmp_check_vb_type(requests->requestvb, asn_type);
            if (retVal != SNMP_ERR_NOERROR) {
                netsnmp_set_request_error(reqinfo, requests, retVal);
            }
            break;

        case MODE_SET_RESERVE2:
            /*
             * XXX malloc "undo" storage buffer 
             */
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /*
             * XXX: free resources allocated in RESERVE1 and/or
             * RESERVE2.  Something failed somewhere, and the states
             * below won't be called. 
             */
            break;

        case MODE_SET_ACTION:
            /*
             * XXX: perform the value change here 
             */
            SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
            break;

        case MODE_SET_COMMIT:
            /*
             * XXX: delete temporary storage 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /*
             * XXX: UNDO and return to previous value for the object 
             */
            if ( 0 ) {
                /*
                 * try _really_really_ hard to never get to this point 
                 */
                netsnmp_set_request_error(reqinfo, requests,
                        SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_enbCtrlCellAction\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

    int
handle_maxCarrierEntries(netsnmp_mib_handler *handler,
        netsnmp_handler_registration *reginfo,
        netsnmp_agent_request_info *reqinfo,
        netsnmp_request_info *requests)
{
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_UNSIGNED;

    /* We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.*/

    /* a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. */



    switch (reqinfo->mode) 
    {

        case MODE_GET:
            {
                /* call get handler from here 
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );

            }
            break;


        default:
            /*
             * we should never get here, so this is a really bad error 
             */
            snmp_log(LOG_ERR,
                    "unknown mode (%d) in handle_maxCarrierEntries\n",
                    reqinfo->mode);
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_enbSWUpdateAction(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int             ret;
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_INTEGER;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
               SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if ( 0 ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
            SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if ( 0 ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if ( 0 ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_enbSWUpdateAction\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_enbSWImageFile(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int             ret;
    int retVal = SNMP_ERR_NOERROR;
    int asn_type = ASN_OCTET_STR;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
               SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, asn_type );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if ( 0 ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
            SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, asn_type);
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if ( 0 ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if ( 0 ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_enbSWImageFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_enbConfiguredCID(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int param_type = ASN_OCTET_STR;
        int retVal = 0;
    switch (reqinfo->mode) {

    case MODE_GET:
            {
                /* call get handler from here
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests, param_type );

            }
        break;


    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_enbConfiguredCID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_enbCurrentCID(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int retVal = 0;
    int ret = 0;
    int param_type = ASN_UNSIGNED;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one.
     */

    switch (reqinfo->mode) {

    case MODE_GET:
                /* call get handler from here
                 * this would further send GPV request to OAM
                 * and wait for the GPV response -- signaling
                 * once the response is received the value for the parameter shall be passed in the below function*/

                SNMP_OAM_HANDLE_GET_REQUEST(handler, requests,    param_type );
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead
         */
        ret = netsnmp_check_vb_type(requests->requestvb, param_type);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer
         */
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;
    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called.
         */
        break;

    case MODE_SET_ACTION:
         {
              SNMP_OAM_HANDLE_SET_REQUEST(handler, requests, param_type);
         }
         break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage
         */
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object
         */
        break;

    default:
        /*
         * we should never get here, so this is a really bad error
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_enbCurrentCID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

