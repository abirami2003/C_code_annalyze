/***************************************************************************
 *
 *  ARICENT -
 *
 *  Copyright (c) Aricent.
 *
 ****************************************************************************
 *
 *  $Id: lteFapiPhySimulatorApiHandler.c,v 1.1.4.11 2010/10/28 11:08:42 gur20056 Exp $
 *
 ****************************************************************************
 *
 *  File Description : This file contains the Interface API between the 
 *                     MAC and Phy Simulator Layer in a LTE system. Also 
 *                     contain the starting point of execution.
 *
 ****************************************************************************
 *
 * Revision Details :
 * $Log: lteFapiPhySimulatorApiHandler.c,v $
 * Revision 1.1.4.11.4.2  2010/11/10 06:35:11  gur10121
 * macEmulator/src/interfaces/lteFapiPhySimulatorApiHandler.c
 *
 * Revision 1.1.4.11.4.1  2010/11/09 14:20:28  gur10121
 *  Semi static merging
 *
 * Revision 1.1.4.11  2010/10/28 11:08:42  gur20056
 * DL data loss fix
 *
 * Revision 1.1.4.10  2010/10/27 08:37:08  gur20056
 * Viswa - rrcConSetup issue - ccch msg len fix
 *
 * Revision 1.1.4.9.4.6  2010/11/01 11:31:51  gur10121
 * Removing compilation error when Semi static flag is undefined
 *
 * Revision 1.1.4.9.4.5  2010/10/29 15:09:42  gur10121
 * UT fix
 *
 * Revision 1.1.4.9.4.4  2010/10/29 10:25:51  gur10121
 *  Semi Static UT fixes
 *
 * 
 * Revision 1.1.4.9.4.3  2010/10/27 17:14:01  gur10121
 * UT fixes + review comments incorporation
 * 
 * Revision 1.1.4.9.4.2  2010/10/26 11:10:35  gur10121
 * Removed Semi static UT traces
 *
 * Revision 1.1.4.9.2.6  2010/10/21 08:08:19  gur10121
 * semi static UT Fix
 *
 * Revision 1.1.4.9.2.5  2010/10/19 07:22:27  gur10694
 * compilation error fixed
 *
 * Revision 1.1.4.9.2.4  2010/10/18 14:49:41  gur10694
 * UL CONFIG: Validations added for SR, HARQ and ULSCH
 *
 * Revision 1.1.4.9.2.3  2010/10/18 13:46:15  gur10694
 * UL Config Validation changes for SR and HARQ
 *
 * Revision 1.1.4.9.2.2  2010/10/18 10:27:39  gur10121
 * MAC_SEMI_STATIC_INF flag added
 *
 * Revision 1.1.4.9.2.1  2010/10/18 07:08:12  gur20439
 * semi static code changes
 *
 * Revision 1.1.4.9  2010/10/12 13:38:08  gur20439
 * removal of globaltick incrementation from dispatcherThread, already happening at RLC layer
 *
 * Revision 1.1.4.8  2010/10/08 17:15:55  gur10121
 * SPR 7333 Fix
 *
 * Revision 1.1.4.7  2010/10/01 14:44:13  gur20491
 * mac/maccore/src/scheduler/dlSchManager/lteMacPDCCHMgr.c
 *
 * Revision 1.1.4.6  2010/10/01 08:09:17  gur04640
 * Reintroduced sched_yield
 *
 * Revision 1.1.4.5  2010/10/01 06:04:19  gur04640
 * Moved sending of SubFrameStartIndication back from end to processing to previous location
 *
 * Revision 1.1.4.4  2010/09/29 05:10:03  gur04640
 * Fixed sending of HARQ and CRC
 *
 * Revision 1.1.4.3  2010/09/28 06:20:30  gur10121
 * UE crash RNTI change
 *
 * Revision 1.1.4.2  2010/09/23 13:04:35  gur20491
 * segmentation fault removed
 *
 * Revision 1.1.4.1  2010/09/21 15:53:31  gur20491
 * FAPI changes
 *
 * Revision 1.1.2.2  2010/09/13 06:26:34  gur20439
 * FAPI UL RACH changes
 *
 * Revision 1.1.2.1  2010/09/07 11:21:08  gur20439
 * new files added for FAPI changes
 *1,v $
 ***************************************************************************/ 

/****************************************************************************
 * Project Includes
 ****************************************************************************/

#include "lteLayer2UplinkUEContext.h"
#include "lteLayer2ParseUtil.h" 
#include "lteFapiControlMsgHandler.h"
#include "phySimulatorApiHandler.h"
#include "lteCommonStatsManager.h"

#ifdef LTE_EMBMS_SUPPORTED
#include "lteLayer2EmbmsInterface.h"
#endif

UInt32 processDLDemuxData( UInt8  *data_p,
        void   *zeroBufCpy_p,
        UInt32 dataLen,
        UInt16 ueIndex,
        UInt8 txCellIndex);
#ifdef TDD_CONFIG
#include "lteLayer2TDDMgr.h"
#endif

#ifdef FDD_CONFIG
 UInt32 fddAckNackval_g[7] = {
     FAPI_NACK,
     FAPI_ACK,
     /*CLPC_CHG*/
     FAPI_ACK_OR_NACK,
     FAPI_DTX,
     FAPI_ACK_OR_DTX,
     FAPI_NACK_OR_DTX,
     FAPI_ACK_OR_NACK_OR_DTX
         /*CLPC_CHG*/
};

#define SEND_ACK_NACK_VERIFY(cellIndex)\
{\
    if( sendAckNack_g[cellIndex] && (sig_cnt[cellIndex] > signalling_ack_nack_g[cellIndex]))\
    {\
        return;\
    }\
}
#endif
/* SS_S2 */
#define API_MSG_OFFSET 4;
/*SPR 2311*/
#define CQI_PDU_DATA 0x8F;
/*SPR 2311*/
#define CQI_IND_OFFSET 4;
/* SS_S2 */

/*CLPC_CHG*/
#define TPC_TO_SINR_CORR_PUSCH_STEP 2
#define TPC_TO_SINR_CORR_PUCCH_STEP 2
#define CLPC_PUCCH_ENABLE FALSE
#define CLPC_PUSCH_ENABLE FALSE
#define STEP_UP_ACK 10
#define STEP_UP_NACK 5
#define STEP_UP_UNSURE 5
/* SPR 3531 START */
#define SINR_DURING_ULSCH_NACK  122
/* SPR 3531 END */
/* SPR 19679: TDD HARQ Multiplexing Changes Start */
#define TWO 2
/* SPR 19679: TDD HARQ Multiplexing Changes End */
/* CA_START_UP_PHASE_2 */
extern SInt32 ev_fd_g[MAX_NUM_CELLS][MAX_NUM_CELLS];
 /* + SPR_11557_11143 */
/* + SPR_11907_11908 */
UInt8 isEvFdRead[MAX_NUM_CELLS] = {0};
/* - SPR_11907_11908 */
extern SInt32 ev_fd_SFI_g; 
 /* - SPR_11557_11143 */
HarqIndQueueNodeInfo *harqIndQNode_gp[MAX_NUM_CELLS];
/* CA_START_UP_PHASE_2 */
extern CellConfig cellConfigUeSim_g[MAX_NUM_CELLS];
extern LTE_SEM demuxDataSemlock_g[MAX_NUM_CELLS][MAX_NUM_CELLS];
extern LTE_SEM fapiUlDispatcherTickSem_g; 
extern UInt16  startRARNTI_g;
/*LTE_REG_FIX*/
extern UInt16  endRARNTI_g[MAX_NUM_CELLS];
/*LTE_REG_FIX*/
extern UInt32 wiresharEnable_g;
extern SInt32 wiresharkfd_g;
extern SockAddr wiresharkAddr_g;
FAPI_dciConfig_st dlDciConfigSPS_g[MAX_SPS_UE];//UeSim-Sps
/* SPR 11445 Changes Start */
/* + SPS_TDD_Changes */
#ifdef FDD_CONFIG
SpsUeSimTTIContext spsSimTTIMap_g[MAX_NUM_CELLS][MAX_SPS_INTERVAL] = {{0}};
#elif TDD_CONFIG
SpsUeSimTTIContext spsSimTTIMap_g[MAX_NUM_CELLS][MAX_UL_SPS_INTERVAL] = {{0}};
#endif
/* - SPS_TDD_Changes */
/* SPR 11445 Changes End */

/* TTIB_Code Start */
#ifdef FDD_CONFIG
#define TTI_BUNDLE_SIZE 4
#define PHICH_RECEIVE_INDEX 11
#define TTI_BUNDLE_RTT  16
#define FRESH_TRANSMISSION 3
#define RE_TRANSMISSION 4
/* SPR 21958 PUSCH RAT1 Support Start */
#define COMB_SET_SIZE  4

extern UInt8 rbgSize_g[MAX_NUM_CELLS] ;
extern UInt8 numRBGConfigured_g[MAX_NUM_CELLS] ;
/* SPR 21958 PUSCH RAT1 Support End */
#endif
/* TTIB_Code End */

/* + Support for toggling configured Nack percentage to 100% ack and vice-versa */
extern UInt32 currentTick_g;
UInt32 ToggleTickTB1[MAX_NUM_CELLS]={0, 0};
UInt32 ToggleTickTB2[MAX_NUM_CELLS]={0, 0};
UInt32 ToggleTickCRC[MAX_NUM_CELLS]={0, 0};
/* - Support for toggling configured Nack percentage to 100% ack and vice-versa */

UInt8 perAckTb1_g[MAX_NUM_CELLS] = {0,0};
UInt8 perNackTb1_g[MAX_NUM_CELLS] = {0,0};
UInt8 perUnsureTb1_g[MAX_NUM_CELLS] = {0,0};
UInt8 perAckTb2_g[MAX_NUM_CELLS] = {0,0};
UInt8 perNackTb2_g[MAX_NUM_CELLS] = {0,0};
UInt8 perUnsureTb2_g[MAX_NUM_CELLS] = {0,0};
UInt8 dlRecvSF_g = 0;

#ifdef LTE_EMBMS_SUPPORTED
UInt8 mcchPduReceived_g=FALSE;
UInt8 rlcResetSN_g=FALSE;
#endif

#ifdef FAPI_L2_MASTER
UInt8 firstDlConfigAfterPhyStart_g[MAX_NUM_CELLS] = {0,0};
#endif

 

/* Global values read from l1MeasurementConfig.cfg*/
extern SInt32 interValues_g[MAX_NUM_CELLS] [MAX_INTER_PROFILES][MAX_PRB];
extern UInt8  dlRsTxPowerNum_g[MAX_NUM_CELLS] ;
extern SInt32 dlRsTxValues_g[MAX_NUM_CELLS] [100];
extern UInt8  thermalNoiseNum_g[MAX_NUM_CELLS] ;
extern SInt32 thermalNoiseValues_g[MAX_NUM_CELLS] [100];
extern UInt8  measEnabled_g[MAX_NUM_CELLS] ;
extern UInt8  interSequence_g[MAX_NUM_CELLS] [MAX_INTER_PROFILES];
extern UInt8  interferenceEnb_g[MAX_NUM_CELLS] ;
extern UInt8  dlRsTxPowerEnb_g[MAX_NUM_CELLS] ;
extern UInt8  thermalNoiseEnb_g[MAX_NUM_CELLS] ;
extern UInt32 measReportPeriodicity_g[MAX_NUM_CELLS] ;
extern TpcInfo tpcRntiInfoMap[TPC_RNTI_COUNT];

extern UInt8 srsProfileNum;
extern UInt8 srsSinrProfileNum;
extern  UInt8 ulschProfileNum;
extern  UInt8 ulschSinrProfileNum;
extern UInt8 cqiProfileNum;
extern UInt8 cqiSinrProfileNum;
extern UInt8 srsSinrValues_g[MAX_SRS_SINR_PROFILES][MAX_PRB];
extern UInt8 ulschSinrValues_g[MAX_ULSCH_SINR_PROFILES];
extern UInt8 cqiSinrValues_g[MAX_CQI_SINR_PROFILES];
extern PHRProfile phrProfileInfo_g[MAX_NUM_CELLS][MAX_PHR_PROFILES];
static void validateAckNackRange(SInt16 *ackNackVal);
static void modifyAckNackArrayForTpc(DLUEContext *dlUeContext_p, 
		UInt8 cellIndex);
static void ackNackCorrectionForTpc(DLUEContext *dlUeContext_p, UInt8 cellIndex);
extern CQIProfile cqiProfileInfo_g[MAX_CQI_PROFILES];
/*CLPC_CHG*/
extern ueProfile ueProfileInfo_g[MAX_NUM_CELLS][MAX_UE_PROFILES];
extern SRSProfile srsProfileInfo_g[MAX_SRS_PROFILES];
extern ULSCHProfile ulschProfileInfo_g[MAX_ULSCH_PROFILES];
/* ULA_CHG */

#ifdef FDD_CONFIG
/* TTIB_Code Start */
extern void processTTIBQueue(UInt8 cellIndex);
extern void pushTTIBNodes(
        UInt8 harqIndex,
        UInt8 delay,
        UInt8 phichReceiveIndex,
        UInt8 qIndex,
        FAPI_dlDCIPduInfo_st *dciPdu_p,                        
        UInt8 recvSF,
        UInt16  recvSFN,
        UInt16 sendSfnSf,
        UInt8 count,
/* SPR_11526_Fix Start */
        UInt8 cellIndex
/* SPR_11526_Fix End */
        );
/* TTIB_Code End */
#endif
#ifdef UESIM_ENHANCEMENTS
UInt8 dlRBInfo_g[MAX_NUM_CELLS][MAX_RBs];
UInt8 ulRBInfo_g[MAX_NUM_CELLS][MAX_RBs];
#endif

/* + SPR_6009 */
UInt8 l1MeasReportsToSend = 0;
/* - SPR_6009 */
UInt32 sig_cnt[MAX_NUM_CELLS] = {0,0}; 
/* + CL-MIMO RSM */
extern codebookSubsetRestrictionInfo codeBookSubsetfromRRC;
UInt32 cqiPmi_dynamic_RI_1[PMI_ARRAY_SIZE] = {0,0,0,0};
UInt32 cqiPmi_dynamic_RI_2[PMI_ARRAY_SIZE/2] = {0,0};
static int pmiSendIndex = 0;
/* - CL-MIMO RSM*/
extern UChar8 macIPAddress_g[40];
extern ueContextForUplink *uplinkContextInfoMap_g[MAX_UE_SUPPORTED];
extern dynamicUEContext *dynUEContextInfoMap_g[MAX_UE_SUPPORTED];
extern void trimSpaces(char *str);
/* SPR 15909 fix start */
tickType_t phy_err_start_tti_g[MAX_NUM_CELLS] = {0,0};
tickType_t phy_err_end_tti_g[MAX_NUM_CELLS] = {0,0};
/* SPR 15909 fix end */
UInt16 phy_err_msg_type_g[MAX_NUM_CELLS] = {0,0};
SInt16 phy_err_delta_val_g[MAX_NUM_CELLS] = {0,0};
UInt16 phy_err_pdu_type_g[MAX_NUM_CELLS] = {0,0};
UInt16 phy_err_sub_err_code_g[MAX_NUM_CELLS] = {0,0};
UInt16 phy_err_error_type_g[MAX_NUM_CELLS] = {0,0};
UInt16 phy_err_crnti_g[MAX_NUM_CELLS] = {0,0};
UInt16 phy_err_rb_start_g[MAX_NUM_CELLS] = {0,0};
UInt16 phy_err_pdu_index_g[MAX_NUM_CELLS] = {0,0};
UInt16 errorCount_g[MAX_NUM_CELLS] = {0,0};
UInt16 phy_err_config_g[MAX_NUM_CELLS] = {0,0};
UInt16 phy_tick_miss_g[MAX_NUM_CELLS] = {0, 0};
extern UInt8 startRecvFlag[MAX_NUM_CELLS];
UInt16 phy_err_abs_delta_val_g[MAX_NUM_CELLS] = {0,0};
UInt8 dlConfigErrorFlag_g[MAX_NUM_CELLS] = {0,0};
extern FAPI_phyStates_en phyState_g[MAX_NUM_CELLS];
extern UInt8 isCellOfTargetEnb[MAX_NUM_CELLS];
extern UInt8 cellStopTriggered[MAX_NUM_CELLS];
/*SPR 11646*/
/* Queue for FAPI Error indication */
#ifdef FDD_CONFIG
LTE_CIRCQUEUE phyErrIndQ_g[MAX_NUM_CELLS][MAX_SUB_FRAME];
#elif TDD_CONFIG
LTE_CIRCQUEUE phyErrIndQ_g[MAX_NUM_CELLS][MAX_UL_ARRAY];
#endif

UInt8 fillPMIForNSubBands_RI_1(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,
        DLCQIInfo *dlCQIInfo,
        UInt8 cellIndex);
UInt8 fillPMIForNSubBands_RI_2(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,
        DLCQIInfo *dlCQIInfo,
        UInt8 cellIndex);

void prepareAperiodicCqiReport(DLCQIInfo *dlCQIInfo,
        UInt8 *cqiReport_p,
        UInt8 *cqi_count,
        UInt8 count,
        UInt8 cellIndex);
UInt8 fillPosOfMSelSubband(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo);
UInt8 fillPosOfMSelSubbandAndPMI_RI_1(UInt8 *cqiReport_p,UInt8 cqi_count,
		UInt8 count,DLCQIInfo *dlCQIInfo,UInt8 cellIndex );
UInt8 fillPosOfMSelSubbandAndPMI_RI_2(UInt8 *cqiReport_p,UInt8 cqi_count,
		UInt8 count,DLCQIInfo *dlCQIInfo, UInt8 cellIndex);
UInt8 fillSubBandDiffCQIForNSubBands(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo);
UInt8 fillSubBandDiffCQIForNSubBandsAndPMI_RI_1(UInt8 *cqiReport_p,
		UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo,
		UInt8 celIndex);
UInt8 fillSubBandDiffCQIForNSubBandsAndWB_RI_2(UInt8 *cqiReport_p,
		UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo);
UInt8 fillSubBandDiffCQIForNSubBandsAndPMI_RI_2(UInt8 *cqiReport_p,
		UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo,
		UInt8 cellIndex);
UInt8 aperiodicCqiCsiFieldArr[MAX_SFN_VALUE][MAX_SF_VALUE][MAX_UE_SUPPORTED];
/* SPR 10980 Fix Start */
cqiPmiRiReportMap cqiPmiRiReportMap_g[MAX_SFN_VALUE];
/* SPR 10980 Fix End */
/* EICIC +*/
cqiPmiRiReportMap cqiPmiRiReportMap2_g[MAX_SFN_VALUE] = { 0 };

UInt16 uplinkToGrantMap_g[MAX_UL_DL_CONFIG][MAX_SUB_FRAME] =
{
    /*This table gives the number of subframes by which DCI0 precedes UL data*/
    /*cfg0*/
    {0xFF,0xFF,6,7,4,0xFF,0xFF,6,7,4},
    /*cfg1*/
    {0xFF,0xFF,6,4,0xFF,0xFF,0xFF,6,4,0xFF},
    /*cfg2*/
    {0xFF,0xFF,4,0xFF,0xFF,0xFF,0xFF,4,0xFF,0xFF},
    /*cfg3*/
    {0xFF,0xFF,4,4,4,0xFF,0xFF,0xFF,0xFF,0xFF},
    /*cfg4*/
    {0xFF,0xFF,4,4,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
    /*cfg5*/
    {0xFF,0xFF,4,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
    /*cfg6*/
    {0xFF,0xFF,7,7,5,0xFF,0xFF,7,7,0xFF}
};

/* EICIC -*/
cqiPmiRiReportMap cqiPmiRiScellReportMap_g[MAX_NUM_SCELL][MAX_SFN_VALUE];
cqiPmiRiReportMap cqiPmiRiScellReportMap2_g[MAX_NUM_SCELL][MAX_SFN_VALUE]; /* EICIC +-*/
UInt8 cqiReportArr[MAX_SFN_VALUE][MAX_SF_VALUE][MAX_CQI_UE_SUPPORTED];

void preparePcellPeriodicCqiReport(UInt8 cellIndex,
                                   UInt8 cqiPeriodicReportType,
                                   DLUEContext *newUEContext_p,
                                   UInt8 *cqiReport_p,
                                   UInt8 *cqiCount,
                                   UInt8 sendSF);
void prepareScellPeriodicCqiReport(UInt8 cellIndex, 
                                   UInt8 cqiPeriodicReportType,
                                   ueContextForUplink  *ulUEInfo_p,
                                   UInt8 *cqiReport_p,
                                   UInt8 *cqiCount,
                                   UInt8 sendSF);
/* + CA_TDD_HARQ_CHANGES */
#ifdef TDD_CONFIG
static void fapiProcessTDDULSchPdu(
                                UInt16 recvSfnSf,
                                ueContextForUplink * ueContextInfo_p
                           );
/* - CA_TDD_HARQ_CHANGES */
#endif

/* Enum used to find the Report Type */
typedef enum cqiRepTypeT
{
    CQI_INVALID_REPORT_TYPE = 0,
    ULSCH_APERIODIC_REPORT_TYPE,
    UCI_PERIODIC_REPORT_TYPE
}cqiRepType;


/* SPR 10867 Fix Start */
#define CQI_RI_PERIODIC_MODE           0
#define CQI_RI_APERIODIC_MODE          1
/* SPR 10867 Fix End */

/* invalidSfnRcvd_g used to identify whether error indication for invalid SFN for HI_DCI0 
 * If error is received, this flag will be set to TRUE else it is always FALSE */
UInt8 invalidSfnRcvd_g = FALSE;

#ifdef TDD_CONFIG
/* msgSfDlConfigErr_g used to identify whether error indication for MSG_SUBFRAME
 * error for DL_CONFIG Request message. If error is received, this flag will be
 * set to TRUE else it is always FALSE */
/* CA TDD Changes Start */
UInt8 msgSfDlConfigErr_g[MAX_NUM_CELLS] = {FALSE};
/* CA TDD Changes End */
#endif

static void initBandwidthPart(DLUEContext *newUEContext_p,UInt32 SFN, UInt8 SF);
/** SPR 12586 Fix : Start **/ 
static void initSCellBandwidthPart(ScellInfo *scellInfo_p,UInt32 SFN, UInt8 SF);
/** SPR 12586 Fix : End **/
#define GET_REQUIRED_TICK(sfn,sf,incrementFactor)\
{\
    UInt32 sf1 = 0;\
        sf1  = sf + incrementFactor;\
        \
        if (sf1 >=  MAX_SF_VALUE)\
        {\
            sf = sf1 % 10;\
\
            sfn  += (sf1 / 10);\
\
            if ( sfn >= MAX_SFN_VALUE )\
            {\
                sfn -= MAX_SFN_VALUE;\
            }\
        }\
        else\
        {\
            sf = sf1;\
        }\
}

#define UPDATE_BANDWIDTHPART_ON_WIDEBAND_REPORT(newUEContext_p,sfn,sf)\
{\
    UInt32 nextCQISFN = sfn;\
    UInt8 nextCQISF = sf;\
    /* SPR 7799 changes start */\
    UInt32  nextCQIOccurance = 0;\
    /* SPR 7799 changes end */\
    newUEContext_p->dlCQIInfo.bandwidthPartCount =0; \
 \
    /* Updating next wideband occurance*/ \
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      newUEContext_p->dlCQIInfo.widebandPeriodicity);\
    newUEContext_p->dlCQIInfo.nextWidebandOccurrence = ((nextCQISFN * 10) + nextCQISF);\
\
    /* Updating next subband occurance*/\
    nextCQISFN = sfn;\
    nextCQISF = sf;\
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      newUEContext_p->dlCQIInfo.cqiPeriodicity);\
    /* SPR 7799 changes start */\
    nextCQIOccurance = ((nextCQISFN * 10) + nextCQISF);\
\
    /* Check for wrap around condition.If it is, then next cqi report\
     * will be Wideband and bandwidthpart starts from 0*/ \
    if(newUEContext_p->dlCQIInfo.nextSubbandOccurrence > nextCQIOccurance)\
    { \
        newUEContext_p->dlCQIInfo.nextWidebandOccurrence = nextCQIOccurance; \
        newUEContext_p->dlCQIInfo.nextSubbandOccurrence = nextCQIOccurance;\
        newUEContext_p->dlCQIInfo.bandwidthPartCount = 0;\
    } \
    else\
    {\
        newUEContext_p->dlCQIInfo.nextSubbandOccurrence = nextCQIOccurance;\
\
    }\
    /* SPR 7799 changes end */\
}

#define UPDATE_BANDWIDTHPART_ON_SUBBAND_REPORT(newUEContext_p,sfn,sf)\
{\
    UInt32 nextCQISFN = sfn;\
    UInt8  nextCQISF = sf;\
    UInt32 nextCQIOccurance = 0;\
 \
    /* Updating bandwidthpart*/ \
    newUEContext_p->dlCQIInfo.bandwidthPartCount++;\
    if(newUEContext_p->dlCQIInfo.bandwidthPartCount >= newUEContext_p->dlCQIInfo.bandwidthParts)\
    {\
        newUEContext_p->dlCQIInfo.bandwidthPartCount = 0;\
    }\
 \
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      newUEContext_p->dlCQIInfo.cqiPeriodicity);\
    nextCQIOccurance = ((nextCQISFN * 10) + nextCQISF);\
 \
    /* Check for wrap around condition.If it is, then next cqi report \
     * will be Wideband and bandwidthpart starts from 0*/ \
    if(newUEContext_p->dlCQIInfo.nextSubbandOccurrence > nextCQIOccurance)\
    { \
        newUEContext_p->dlCQIInfo.nextWidebandOccurrence = nextCQIOccurance; \
        newUEContext_p->dlCQIInfo.bandwidthPartCount = 0;\
    } \
    else\
    {\
        newUEContext_p->dlCQIInfo.nextSubbandOccurrence = nextCQIOccurance;\
\
   }\
}

/** SPR 12586 Fix : Start **/ 
#define UPDATE_SCELL_BANDWIDTHPART_ON_WIDEBAND_REPORT(scellInfo_p,sfn,sf)\
{\
    UInt32 nextCQISFN = sfn;\
    UInt8 nextCQISF = sf;\
    /* SPR 7799 changes start */\
    UInt32  nextCQIOccurance = 0;\
    /* SPR 7799 changes end */\
    scellInfo_p->dlCQIInfo.bandwidthPartCount =0; \
 \
    /* Updating next wideband occurance*/ \
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      scellInfo_p->dlCQIInfo.widebandPeriodicity);\
    scellInfo_p->dlCQIInfo.nextWidebandOccurrence = ((nextCQISFN * 10) + nextCQISF);\
\
    /* Updating next subband occurance*/\
    nextCQISFN = sfn;\
    nextCQISF = sf;\
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      scellInfo_p->dlCQIInfo.cqiPeriodicity);\
    /* SPR 7799 changes start */\
    nextCQIOccurance = ((nextCQISFN * 10) + nextCQISF);\
\
    /* Check for wrap around condition.If it is, then next cqi report\
     * will be Wideband and bandwidthpart starts from 0*/ \
    if(scellInfo_p->dlCQIInfo.nextSubbandOccurrence > nextCQIOccurance)\
    { \
        scellInfo_p->dlCQIInfo.nextWidebandOccurrence = nextCQIOccurance; \
        scellInfo_p->dlCQIInfo.nextSubbandOccurrence = nextCQIOccurance;\
        scellInfo_p->dlCQIInfo.bandwidthPartCount = 0;\
    } \
    else\
    {\
        scellInfo_p->dlCQIInfo.nextSubbandOccurrence = nextCQIOccurance;\
\
    }\
    /* SPR 7799 changes end */\
}
/* EICIC +*/

#define UPDATE_SCELL_BANDWIDTHPART_ON_WIDEBAND_REPORT_2(scellInfo_p,sfn,sf)\
{\
    UInt32 nextCQISFN = sfn;\
    UInt8 nextCQISF = sf;\
    /* SPR 7799 changes start */\
    UInt32  nextCQIOccurance = 0;\
    /* SPR 7799 changes end */\
    scellInfo_p->dlCQIInfo.bandwidthPartCount_2 =0; \
 \
    /* Updating next wideband occurance*/ \
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      scellInfo_p->dlCQIInfo.widebandPeriodicity_2);\
    scellInfo_p->dlCQIInfo.nextWidebandOccurrence_2 = ((nextCQISFN * 10) + nextCQISF);\
\
    /* Updating next subband occurance*/\
    nextCQISFN = sfn;\
    nextCQISF = sf;\
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      scellInfo_p->dlCQIInfo.cqiPeriodicity_2);\
    /* SPR 7799 changes start */\
    nextCQIOccurance = ((nextCQISFN * 10) + nextCQISF);\
\
    /* Check for wrap around condition.If it is, then next cqi report\
     * will be Wideband and bandwidthpart starts from 0*/ \
    if(scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 > nextCQIOccurance)\
    { \
        scellInfo_p->dlCQIInfo.nextWidebandOccurrence_2 = nextCQIOccurance; \
        scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 = nextCQIOccurance;\
        scellInfo_p->dlCQIInfo.bandwidthPartCount_2 = 0;\
    } \
    else\
    {\
        scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 = nextCQIOccurance;\
\
    }\
    /* SPR 7799 changes end */\
}

#define UPDATE_BANDWIDTHPART_ON_WIDEBAND_REPORT_2(newUEContext_p,sfn,sf)\
{\
    UInt32 nextCQISFN = sfn;\
    UInt8 nextCQISF = sf;\
    /* SPR 7799 changes start */\
    UInt32  nextCQIOccurance = 0;\
    /* SPR 7799 changes end */\
    newUEContext_p->dlCQIInfo.bandwidthPartCount_2 =0; \
 \
    /* Updating next wideband occurance*/ \
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      newUEContext_p->dlCQIInfo.widebandPeriodicity);\
    newUEContext_p->dlCQIInfo.nextWidebandOccurrence_2 = ((nextCQISFN * 10) + nextCQISF);\
\
    /* Updating next subband occurance*/\
    nextCQISFN = sfn;\
    nextCQISF = sf;\
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      newUEContext_p->dlCQIInfo.cqiPeriodicity_2);\
    /* SPR 7799 changes start */\
    nextCQIOccurance = ((nextCQISFN * 10) + nextCQISF);\
\
    /* Check for wrap around condition.If it is, then next cqi report\
     * will be Wideband and bandwidthpart starts from 0*/ \
    if(newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 > nextCQIOccurance)\
    { \
        newUEContext_p->dlCQIInfo.nextWidebandOccurrence_2 = nextCQIOccurance; \
        newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 = nextCQIOccurance;\
        newUEContext_p->dlCQIInfo.bandwidthPartCount_2 = 0;\
    } \
    else\
    {\
        newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 = nextCQIOccurance;\
\
    }\
    /* SPR 7799 changes end */\
}

#define UPDATE_BANDWIDTHPART_ON_SUBBAND_REPORT_2(newUEContext_p,sfn,sf)\
{\
    UInt32 nextCQISFN = sfn;\
    UInt8  nextCQISF = sf;\
    UInt32 nextCQIOccurance = 0;\
 \
    /* Updating bandwidthpart*/ \
    newUEContext_p->dlCQIInfo.bandwidthPartCount_2++;\
    if(newUEContext_p->dlCQIInfo.bandwidthPartCount_2 >= newUEContext_p->dlCQIInfo.bandwidthParts)\
    {\
        newUEContext_p->dlCQIInfo.bandwidthPartCount_2 = 0;\
    }\
 \
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      newUEContext_p->dlCQIInfo.cqiPeriodicity_2);\
    nextCQIOccurance = ((nextCQISFN * 10) + nextCQISF);\
 \
    /* Check for wrap around condition.If it is, then next cqi report \
     * will be Wideband and bandwidthpart starts from 0*/ \
    if(newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 > nextCQIOccurance)\
    { \
        newUEContext_p->dlCQIInfo.nextWidebandOccurrence_2 = nextCQIOccurance; \
        newUEContext_p->dlCQIInfo.bandwidthPartCount_2 = 0;\
    } \
    else\
    {\
        newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 = nextCQIOccurance;\
\
   }\
}

/* EICIC -*/


#define UPDATE_SCELL_BANDWIDTHPART_ON_SUBBAND_REPORT(scellInfo_p,sfn,sf)\
{\
    UInt32 nextCQISFN = sfn;\
    UInt8  nextCQISF = sf;\
    UInt32 nextCQIOccurance = 0;\
 \
    /* Updating bandwidthpart*/ \
    scellInfo_p->dlCQIInfo.bandwidthPartCount++;\
    if(scellInfo_p->dlCQIInfo.bandwidthPartCount >= scellInfo_p->dlCQIInfo.bandwidthParts)\
    {\
        scellInfo_p->dlCQIInfo.bandwidthPartCount = 0;\
    }\
 \
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      scellInfo_p->dlCQIInfo.cqiPeriodicity);\
    nextCQIOccurance = ((nextCQISFN * 10) + nextCQISF);\
 \
    /* Check for wrap around condition.If it is, then next cqi report \
     * will be Wideband and bandwidthpart starts from 0*/ \
    if(scellInfo_p->dlCQIInfo.nextSubbandOccurrence > nextCQIOccurance)\
    { \
        scellInfo_p->dlCQIInfo.nextWidebandOccurrence = nextCQIOccurance; \
        scellInfo_p->dlCQIInfo.bandwidthPartCount = 0;\
    } \
    else\
    {\
        scellInfo_p->dlCQIInfo.nextSubbandOccurrence = nextCQIOccurance;\
\
   }\
}
/** SPR 12586 Fix : End **/
/* - CQI_4.1 */

/* + CA_TDD_HARQ_CHANGES */
#ifdef TDD_CONFIG
#define CHECK_BIT_SET(str, bitPos)  ((str) & (1 << (bitPos) ))
#endif
/* - CA_TDD_HARQ_CHANGES */

/* EICIC +*/



#define UPDATE_SCELL_BANDWIDTHPART_ON_SUBBAND_REPORT_2(scellInfo_p,sfn,sf)\
{\
    UInt32 nextCQISFN = sfn;\
    UInt8  nextCQISF = sf;\
    UInt32 nextCQIOccurance = 0;\
 \
    /* Updating bandwidthpart*/ \
    scellInfo_p->dlCQIInfo.bandwidthPartCount_2++;\
    if(scellInfo_p->dlCQIInfo.bandwidthPartCount_2 >= scellInfo_p->dlCQIInfo.bandwidthParts)\
    {\
        scellInfo_p->dlCQIInfo.bandwidthPartCount_2 = 0;\
    }\
 \
    GET_REQUIRED_TICK(nextCQISFN,\
                      nextCQISF,\
                      scellInfo_p->dlCQIInfo.cqiPeriodicity_2);\
    nextCQIOccurance = ((nextCQISFN * 10) + nextCQISF);\
 \
    /* Check for wrap around condition.If it is, then next cqi report \
     * will be Wideband and bandwidthpart starts from 0*/ \
    if(scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 > nextCQIOccurance)\
    { \
        scellInfo_p->dlCQIInfo.nextWidebandOccurrence_2 = nextCQIOccurance; \
        scellInfo_p->dlCQIInfo.bandwidthPartCount_2 = 0;\
    } \
    else\
    {\
        scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 = nextCQIOccurance;\
\
   }\
}

/* EICIC -*/

void parseAckNackConfigFile(void);

void parsePhyErrorConfigFile(void);
#if 0
/******** Thread Specific Semaphore ****************/

LTE_SEM fapiUlDispatcherThreadSem_g;
extern LTE_SEM rlcPdcprunThreadSem_g;

/************Thread ID Variable***********************/

ULong32 fapiUlDispatcherThread_g;
ULong32 fapiUlReceiverThread_g;
ULong32 fapiPhyTimerThread_g;

extern int ulReceiverThreadCoreNum_g;
extern int uePhyTimerThreadCoreNum_g;
extern int uldispatcherThreadCoreNum_g;

#endif
/********** TICK Related Parameters ************************/

/* global variables for ul harq */
#ifdef HO_SETUP_CHANGES
extern UChar8 targetEnbIp_g [64];
/* +CA */
extern SInt32 targetEnbTxFd_g[MAX_NUM_CELLS];
extern SockAddr targetEnbmacLayerAddr_g[MAX_NUM_CELLS];
/* -CA */
#endif

extern ULHarqTimerEntityList ulHarqTimerEntityList_g[MAX_SUBFRAME];
extern unsigned char* pduDataPointer;
extern unsigned char* pduDciDataPointer;
extern UInt16 freeqIndex;
extern UInt16 oldSF,oldSFN;
extern UInt16 checkCurrentSFN,checkCurrentSF;
extern UInt16 checkackSF,checkTIdx;
/* -------------------------- */

extern volatile UInt16 SFN_g[MAX_NUM_CELLS];
extern volatile UInt8  SF_g[MAX_NUM_CELLS];
extern UInt8 nackChoiceTB1_g;
extern UInt8 nackChoiceTB2_g;
extern UInt8 uLnackChoice_g;
extern UInt8 dwlkPacketArrTB1_g[MAX_SUBFRAME];
extern UInt8 dwlkPacketArrTB2_g[MAX_SUBFRAME];
extern statsGeneral statsGeneralInfo_g;
extern volatile UInt8 macRegFlag_g[MAX_NUM_CELLS];
extern SockAddr phyLayerAddr_g[MAX_NUM_CELLS];
extern SockAddr macLayerAddr_g[MAX_NUM_CELLS];
extern SInt32 txSockFD_g[MAX_NUM_CELLS];
extern SInt32 sockfd_g[MAX_NUM_CELLS];
extern LTE_SEM dlConfigSemlock_g[MAX_NUM_CELLS][MAX_NUM_CELLS];
/* SPR 5313 changes start */
/* +CA */
extern SInt32 sockfdHO_g[MAX_NUM_CELLS];
extern SockAddr phyLayerAddrHO_g[MAX_NUM_CELLS];
/* -CA */

#ifdef DL_UL_SPLIT_TDD
extern SockAddr macLayerAddrULThd_g;
#endif

/* SPR 5313 changes end */
extern void prepareBSR(UInt8 **sendBufer_p,UInt8 isLongBSR,
            UInt8 bsr0,UInt8 bsr1, UInt8 bsr2, UInt8 bsr3,UInt8 lcId);
extern void prepareCCCHSDU(UInt8 **sendBuffer_p, RARequest *raReq_p);
extern inline UInt8 validateSFNandSFAndgetDelay( UInt16 recvSFN, UInt8 recvSF,
                                           UInt16 currentSFN, UInt8 currentSF);
extern ueContextForUplink *getUEContext(UInt16 rnti, UInt8 cellIndex);
extern inline void sendDatatoPeerMac( UInt8 *sendBuffer_p, UInt32 msgLen, UInt8 cellIndex);
extern void getIPAddrFromFile();
extern UInt32 periodicBsrFlag_g;
/* +CA */
extern volatile UInt16 cellId_g[MAX_NUM_CELLS];
/* -CA */
/* +CA_NA */
void sendMsg3withOnlycrntiCE(UInt16 rnti, UInt32 sendSfnSf,UInt8 qIndex,
		UInt16 tempCrnti,
		UInt8 cellIndex);
/*MAC_EMU ACK_NACK OPTIONS*/
UInt8 tb1_ack_nack_value_array[MAX_NUM_CELLS][ACK_NACK_ARRAY_SIZE][ACK_NACK_ARRAY_SIZE];
UInt8 tb2_ack_nack_value_array[MAX_NUM_CELLS][ACK_NACK_ARRAY_SIZE][ACK_NACK_ARRAY_SIZE];
UInt8 crc_ind_value_array[MAX_NUM_CELLS][ACK_NACK_ARRAY_SIZE][ACK_NACK_ARRAY_SIZE];
UInt8 crc_indication_g[MAX_NUM_CELLS];
UInt8 sendAckNack_g[MAX_NUM_CELLS] = {0,0};
UInt32 signalling_ack_nack_g[MAX_NUM_CELLS];
/* -CA_NA */
/*MAC_EMU ACK_NACK OPTIONS*/

/* HI Pdu Multi UE Changes Start*/

hiRntiMap hi_pdu_crnti_array_g[MAC_MAX_RESOURCE_BLOCKS][MAX_HARQ_PROCESS_NB];
#ifdef FDD_CONFIG
/** TTIB_Code Start */ 
hiRntiMap hi_pdu_crnti_ttib_array_g[MAC_MAX_RESOURCE_BLOCKS][MAX_TTIB_HARQ_PROCESS_NB];
/** TTIB_Code End */ 
#endif
/* HI Pdu Multi UE Changes End*/

/* TA_CHG */
#include "lteLayer2InitMac.h"
/* + SPR 11024 Fix */ 
extern TAValues  taValues_g[MAX_NUM_CELL];
/* - SPR 11024 Fix */ 
static UInt8     taCntr = 0;
/* TA_CHG */
/* + CL-MIMO LJA*/
static FILE  *cqiFileFp = NULL;
static UInt8 cqiPMIReportSizeBytes_g = 0;
static UInt8 RI_g = 0;
/* + CL-MIMO RSM */
static UInt8 ri_Toggle = 0;
static UInt8 pmi_Toggle = 0;
/* - CL-MIMO RSM */
static UInt8 cqiPmiValue_g[2*MAX_SUB_BAND];
/* - CL-MIMO LJA*/

static UInt8 preambleCircularIndex = 0;

/* + MEAS_GAP_CHG */
/* + E_CID_5.3 */
extern Rel9TAValues rel9TaValues_g[MAX_NUM_CELLS];
static UInt8     rel9TaCntr = 0;
/* - E_CID_5.3 */
static inline MacRetType  checkIsMeasurementGapPeriodON ( UInt16 recvSFN,
                                                          UInt8 recvSF,
                                                       DLUEContext  *ueDLInfo_p
                                                        );
static inline DLUEContext* getDLUEContextFromRnti( UInt16 rnti, UInt8 cellIndex);
static inline UInt16 getRNTIFromULConfigPdu( FAPI_ulPDUConfigInfo_st *ulConfigPdu_p );
extern inline void UpdateSfnSf( UInt16 *sfn_p,
                                UInt8 *sf_p,
                                UInt16 subframeCount
                              );
extern UInt8 ulSfForDCI0OrHiReceived_g[MAX_UL_DL_CONFIG][MAX_SUBFRAME];
extern UInt8 ulSfForDlAckNack_g[MAX_UL_DL_CONFIG][MAX_SUBFRAME];
/* - MEAS_GAP_CHG */
/* + TM7_8 Changes Start */
UInt8   angleOfArrivalValuesIndex_g[MAX_NUM_CELLS] = {0,0};
extern SInt32  angleOfArrivalValues_g[MAX_NUM_CELLS][MAX_NUM_ANTENNA][MAX_SF_VALUE];
/* - TM7_8 Changes End */

/* crc changes begin */
#ifdef TDD_CONFIG
SInt8 harqIdArray_g[MAX_UL_DL_CONFIG][MAX_SUBFRAME] =
                               {
                                   {-1,-1, 0, 1, 2,-1,-1, 3, 4, 5},
                                   {-1,-1, 0, 1,-1,-1,-1, 2, 3,-1},
                                   {-1,-1, 0,-1,-1,-1,-1, 1,-1,-1},
                                   {-1,-1, 0, 1, 2,-1,-1,-1,-1,-1},
                                   {-1,-1, 0, 1,-1,-1,-1,-1,-1,-1},
                                   {-1,-1, 0,-1,-1,-1,-1,-1,-1,-1},
                                   {-1,-1, 0, 1, 2,-1,-1, 3, 4,-1}

                               };
/* crc changes end*/

/*TDD Config 0 And 6 Changes Start*/

/* This  Map is used to get Harq ID for Config 6 corresponds to
 * UL subframe Number. In Config 6, the same Harq ID has been 
 * allocated on same UL subframe Number after 60 subframe.
 *  For e.g: Harq ID 0 is first allocated to UL subframe 7 and
 *  Same Harq ID 0 will be allocated to  UL subframe number 67.
 */
static UInt8 harqIdArrayTdd6_g[] =
			{ /* 00, 01, 02, 03, 04, 05, 06, 07, 08, 09, */
			     NA,  NA, 3,  4,  5, NA, NA,  0,  1, NA,
			  /* 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, */
			     NA,  NA, 2,  3,  4, NA, NA,  5,  0, NA,
			  /* 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, */
			     NA,  NA, 1,  2,  3, NA, NA,  4,  5, NA,
			  /* 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, */
			     NA,  NA, 0,  1,  2, NA, NA,  3,  4, NA,
			  /* 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, */
			     NA,  NA, 5,  0,  1, NA, NA,  2,  3, NA,
			  /* 50, 51, 52, 53, 54, 55, 56, 57, 58, 59  */
			     NA,  NA, 4,  5,  0, NA, NA,  1,  2, NA
			};

/* This Map is used to get Harq ID for Config 0 corresponds to
 * UL subframe Number. In Config0, the same Harq ID has  been 
 * allocated on same UL subframe Number after 70 subframe.
 *  For e.g: Harq ID 0 is first allocated to UL subframe 4 and
 *  same Harq ID will be allocated to UL subframe number 74.
 */
static UInt8 harqIdArrayTdd0_g[] =
			{ /* 00, 01, 02, 03, 04, 05, 06, 07, 08, 09, */
			     NA,  NA, 5,  6,  0, NA, NA,  1,  2, 3,
			  /* 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, */
			     NA,  NA, 4,  5,  6, NA, NA,  0,  1, 2,
			  /* 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, */
			     NA,  NA, 3,  4,  5, NA, NA,  6,  0, 1,
			  /* 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, */
			     NA,  NA, 2,  3,  4, NA, NA,  5,  6, 0,
			  /* 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, */
			     NA,  NA, 1,  2,  3, NA, NA,  4,  5, 6,
			  /* 50, 51, 52, 53, 54, 55, 56, 57, 58, 59  */
			     NA,  NA, 0,  1,  2, NA, NA,  3,  4, 5,
			  /* 60, 61, 62, 63, 64, 65, 66, 67, 68, 69  */
			     NA,  NA, 6,  0,  1, NA, NA,  2,  3, 4
			};


/* SPR 19679: TDD HARQ Multiplexing Changes Start */
UInt8 tddHarqMuxIndex[MAX_UL_DL_CONFIG][MAX_SUBFRAME] = {
    {255,255,255,255,255,255,255,255,255,255}, /* Tdd config 0 */
    {0,1,255,255,255,0,1,255,255,0}, /* Tdd config 1 */
    {1,3,255,2,0,1,3,255,2,0}, /* Tdd config 2 */
    {1,2,255,255,255,0,1,0,1,0}, /* Tdd config 3 */
    {0,3,255,255,1,2,3,0,1,2}, /* Tdd config 4 */
    {255,255,255,255,255,255,255,255,255,255}, /* Tdd config 5 */
    {255,255,255,255,255,255,255,255,255,255}  /* Tdd config 6 */
};
/* SPR 19679: TDD HARQ Multiplexing Changes End */



/* + CA_TDD_HARQ_CHANGES */
extern const UInt8 getM_g[MAX_UL_DL_CONFIG][MAX_SUBFRAME];

/** This is bitmap of 20 bits which tells at particular subframe which dl subframes can schedule data 
    First 10 bit corresponds to SFN = N & next 10 bits corresponds to SFN = N+1.
    e.g : Take DL UL Config 2 M=4 as example then at SF = 7 SFN = N+1 
          DL Ack/NACk of SF = 9     SFN =N  
                         SF = 0,1,3 SFN = N+1 can be sent
          Pickout bitmap of [DL UL Config 2][7] = 0x00002E00 which shows corresponding bits on.
          So bitmap would be 0000 0000 0000 0000 0010 1110 0000 0000
                                            |__________||__________|
                                              SFN = N+1    SFN = N
**/

const UInt32 dlAckNackBitMap[MAX_UL_DL_CONFIG][MAX_SUBFRAME]= {
        {0,0,0x00000040,0,0x000000400,0,0,0x00000800,0,0x00000400}, /* DL UL Config 0 */
        {0,0,0x00000060,0x00000200,0,0,0,0x00000C00,0x00004000,0}, /* DL UL Config 1 */
        {0,0,0x0005C000,0,0,0,0,0x00002E00,0,0}, /* DL UL Config 2 */
        {0,0,0x00000062,0x00000180,0x00000600,0,0,0,0,0}, /* DL UL Config 3 */
        {0,0,0x00000033,0x000003C0,0,0,0,0,0,0}, /* DL UL Config 4 */
        {0,0,0,0,0,0,0,0,0,0}, /* DL UL Config 5 */
        {0,0,0x00000020,0x00000040,0x00000200,0,0,0x00000400,0x00000800,0}  /* DL UL Config 6 */
};
/* - CA_TDD_HARQ_CHANGES */

/*TDD Config 0 And 6 Changes End*/
/* SPR 11066 Changes start */
#define MAX_HARQ_MAP_CONFIG0_SIZE 70
#define MAX_HARQ_MAP_CONFIG6_SIZE 60
/* SPR 11066 Changes End */
#endif

UInt32 fapi_crc_g[2] =
{
    FAPI_CRC_ERROR,
    FAPI_CRC_CORRECT
};

/*SPS_CHG*/
        /*SPR 6690 fix Start */
void processUlUeSimSpsOccasion(UInt8 cellIndex );
        /*SPR 6690 fix Start */
static void ulAddUeInUeSimOccasionList( UInt16 ueIndex,
        UInt16 ttiIndex,
        ueContextForUplink *ueContextInfo_p, UInt8 cellIndex ); 
static void processSPSGrant(FAPI_dlDCIPduInfo_st *dciPdu, 
		UInt16  semiPersistentSchedIntervalUL, UInt8 recvSF, 
		UInt16 recvSFN, UInt8 cellIndex);
UInt8 populateSpsCrnti(UInt16 spsCrnti, UInt8 cellIndex);
/* +- SPR 18268 */
UInt8 checkScellStatus(UInt16 ueIndex);
/* +- SPR 18268 */


/*! \code
 * -Map for getting the actual Interval
 * \endcode
 * */
UInt16 spsIntervalMap_g[SPS_INTERVAL_MAX] = {10,
                                             20,
                                             32,
                                             40,
                                             64,
                                             80,
                                             128,
                                             160,
                                             320,
                                             640};

/* SPR 11549 fix start */
#ifdef FDD_CONFIG
PRACHConfigInfo prachConfig[64] =
{
    /*******************************************************
     *Preamble format   SFN        Subframe map
     ******************************************************/
    {PREAMBLE_FORMAT_0, EVEN, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_0, EVEN, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_0, EVEN, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 1, 0, 0, 0, 0, 1, 0, 0, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 0, 1, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 0, 0, 1, 0, 0, 0, 0, 1, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 1, 0, 0, 1, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 0, 1, 0, 0, 1, 0, 0, 1, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 0, 0, 1, 0, 0, 1, 0, 0, 1}},
    {PREAMBLE_FORMAT_0, ANY,  {1, 0, 1, 0, 1, 0, 1, 0, 1, 0}},
    {PREAMBLE_FORMAT_0, ANY,  {0, 1, 0, 1, 0, 1, 0, 1, 0, 1}},
    {PREAMBLE_FORMAT_0, ANY,  {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}},
    {PREAMBLE_FORMAT_0, EVEN, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}},
    {PREAMBLE_FORMAT_1, EVEN, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_1, EVEN, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_1, EVEN, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 1, 0, 0, 0, 0, 1, 0, 0, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 0, 1, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 0, 0, 1, 0, 0, 0, 0, 1, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 1, 0, 0, 1, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 0, 1, 0, 0, 1, 0, 0, 1, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 0, 0, 1, 0, 0, 1, 0, 0, 1}},
    {PREAMBLE_FORMAT_1, ANY,  {1, 0, 1, 0, 1, 0, 1, 0, 1, 0}},
    {PREAMBLE_FORMAT_1, ANY,  {0, 1, 0, 1, 0, 1, 0, 1, 0, 1}},
    {INVALID_PREAMBLE_FORMAT, INVALID_PRACH_SFN,  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_1, EVEN, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}},
    {PREAMBLE_FORMAT_2, EVEN, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_2, EVEN, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_2, EVEN, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 1, 0, 0, 0, 0, 1, 0, 0, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 0, 1, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 0, 0, 1, 0, 0, 0, 0, 1, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 1, 0, 0, 1, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 0, 1, 0, 0, 1, 0, 0, 1, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 0, 0, 1, 0, 0, 1, 0, 0, 1}},
    {PREAMBLE_FORMAT_2, ANY,  {1, 0, 1, 0, 1, 0, 1, 0, 1, 0}},
    {PREAMBLE_FORMAT_2, ANY,  {0, 1, 0, 1, 0, 1, 0, 1, 0, 1}},
    {INVALID_PREAMBLE_FORMAT, INVALID_PRACH_SFN,  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_2, EVEN, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}},
    {PREAMBLE_FORMAT_3, EVEN, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_3, EVEN, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_3, EVEN, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 1, 0, 0, 0, 0, 1, 0, 0, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 0, 1, 0, 0, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 0, 0, 1, 0, 0, 0, 0, 1, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 1, 0, 0, 1, 0, 0, 1, 0, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 0, 1, 0, 0, 1, 0, 0, 1, 0}},
    {PREAMBLE_FORMAT_3,  ANY, {0, 0, 0, 1, 0, 0, 1, 0, 0, 1}},
    {INVALID_PREAMBLE_FORMAT, INVALID_PRACH_SFN,  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
    {INVALID_PREAMBLE_FORMAT, INVALID_PRACH_SFN,  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
    {INVALID_PREAMBLE_FORMAT, INVALID_PRACH_SFN,  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
    {PREAMBLE_FORMAT_3, EVEN, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}
};
#endif
/* SPR 11549 fix end */

#if 0
volatile UInt32 globalTTITickCount_g;
UInt32 tickValue_g = TICK_IN_MS * 1000000;

/*************Configuration Variable For DL/ UL ACK,NACK and BSR *****/


/*UInt8 bsrChoice_g;*/
/* static UInt8 bsrAckPacketCounter_s;*/
/*static UInt8 bsrArrIndex_s;*/

/* Filling the position which packet reply ack or nack */

/****************Log Related Variables******************************/

UChar8 * phyLogFileName_g =  "LTE_PHY";
ModuleLogDetail PhyModuleLogDetail_g;

/******* Registration Related Variables *****************/

UInt32 enableMenuReg_g = 1;
volatile UInt8 macRegFlag_g = REG_FAILURE;

/********* Socket/ Wireshark Related Information *******************/
UInt32 wiresharEnable_g = 0;
SInt32 wiresharkfd_g = -1;

SInt32 txSockFD_g = -1;
SockAddr wiresharkAddr_g;

/** Msq Queue UL and DL***/
SInt32 shMsgQIdDL_g;
SInt32 shMsgQIdUL_g;

/**************** RA Procedure Related Parameters  ********/

RARequest raRntiArr_g[MAX_NUM_RA_REQUEST] = {{0}};

/********************************************************/


UInt8 recvDataBuffer_g[RECV_BUFF_SIZE] = {0};

UInt16 transactionId_g;


UInt32 periodicEnableFlag_g = FALSE;

extern UInt32 rlcUeSimLoop_g;

/****************************************************************************
 * Function Name  : getCurrentglobaltick
 *
 * Inputs         :
 * Outputs        : 
 * Returns        : current value of global tick
 * Description    : returns the current value of global tick 
 * this func called by /lteenodeb/simulators/macEmulator/src/interfaces/lteLayer2RRCInterface.c:316:
                        `getCurrentglobaltick'
 ****************************************************************************/

inline UInt32 getCurrentglobaltick()
{
    return globalTTITickCount_g;
}

#endif
    /* +CA_NA */
/****************************************************************************
 * Function Name  : getUEContext 
 * Inputs         : rnti and cellIndex
 * Outputs        : pointer to ul ue context
 * Returns        :
 * Variables      :
 * Description    : 
 *
 ****************************************************************************/
ueContextForUplink *getUEContext(UInt16 rnti, UInt8 cellIndex)
{
    RNTIInfo *rntiInfo_p = PNULL;
    ueContextForUplink *ueContextInfo_p = PNULL;
    rntiInfo_p = getRntiInfofromRNTIMap(rnti, cellIndex);
    if (rntiInfo_p == PNULL) {
//        lteWarning("Error!!! [1]No Rnti Info present for crnti = %d\n", rnti);
        return PNULL;
    }
    ueContextInfo_p = uplinkContextInfoMap_g[rntiInfo_p->ueIndex];
    if ( ueContextInfo_p == PNULL )
    {
        lteWarning("Error!! UE Context does not exist for crnti = %d, ueIndex = %d\n", 
                rnti, rntiInfo_p->ueIndex);
        return PNULL;
    }
    return ueContextInfo_p;
}
/* -CA */

#ifdef UESIM_ENHANCEMENTS
/******************************************************************************
 * Function Name  : UInt32 
 * Inputs :1)bitMap - This holds BitMap on which number of set bit need to be counted.
 * Outputs :None
 * Returns : None
 * Description :This funtion will return the number of Set Bit in the given bitmap
 ******************************************************************************/
inline UInt32 getCount(UInt32 bitMap)
{
    UInt32 countOfSetBit;
    bitMap = bitMap - ((bitMap >> 1) & 0x55555555);                 
    bitMap = (bitMap & 0x33333333) + ((bitMap >> 2) & 0x33333333);    
    countOfSetBit = (((bitMap + (bitMap >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24; 
    return countOfSetBit;
}

/******************************************************************************
 * Function Name  : UInt32 
 * Inputs :1)bitMap - This holds BitMap on which position of first set bit from LSB Need to
 *              to be found.
 * Outputs :None
 * Returns : None
 * Description :This funtion will return the position of first set bit from LSB 
 ******************************************************************************/
inline UInt32 FFS(UInt32 bitMap)
{
    return ffs(bitMap);
}

/******************************************************************************
 * Function Name  : calculateMaxPRB
 * Inputs : 1)subsetIndex - This holds the subsetIndex on which 
 *            maximum numberof RBs need to be calculated.    
 *          2)dlRBs - This holds the downlink Bandwidth in terms of 
 *            RBs 
 *          3)subsetSize - This holds the subsetSize
 * Outputs : Max number of  PRB in a subset
 * Returns : None
 * Description : This funtion will calculate maximum number of  PRB in a 
 subset 

 ******************************************************************************/
static UInt32 calculateMaxPRB(UInt32 subsetIndex,
        UInt32 dlRBs,
        UInt32 subsetSize)
{
    UInt32  x1 = 0;
    UInt32 maxAddressablePRBCount= 0;
    UInt32 temp  = 0;

    temp = ((dlRBs - 1) / (subsetSize * subsetSize) ) * subsetSize;
    x1 = ((dlRBs - 1) / subsetSize ) % subsetSize;

    /* Below logic is mentioned in specs for calculating maximum number of  
       PRB 
       in a subset */
    if ( subsetIndex < x1)
    {
        maxAddressablePRBCount= temp + subsetSize;    
        return maxAddressablePRBCount;
    }
    else if(subsetIndex == x1)
    {   
        maxAddressablePRBCount= temp  + (dlRBs - 1) % subsetSize + 1;
        return maxAddressablePRBCount;

    }
    else if (subsetIndex > x1 )
    {
        maxAddressablePRBCount= temp ;
        return maxAddressablePRBCount;
    }
    return 0;
}
#endif

/****************************************************************************
 * Function Name  : getPreambleRangeValuesFromFile
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    : This function will read the preamble start and end values from a
 *                  config file. 
 ****************************************************************************/
static inline void getPreambleRangeValuesFromFile()
{

    char* line_p = PNULL;
    size_t len = 0;
    ssize_t read;
    char temp[100] = {0};
    FILE  *preambleRangeFileFp = PNULL;

    preambleRangeFileFp = fopen("../cfg/ueSim_preambleConfig.txt", "r"); 
    
    if ( PNULL == preambleRangeFileFp)
    {
        preambleRangeStart_g = 0;
        preambleRangeEnd_g = 51;
        preambleCircularIndex = preambleRangeStart_g;
        mcsIndexPdcchOrder_g = 6;
        numRBPdcchOrder_g = 2;
        mcsIndexHO_g = 4;
        numRBHO_g = 4;
        mcsIndexPreambleGroupA_g = 1;
        numRBPreambleGroupA_g = 2;
        mcsIndexPreambleGroupB_g = 6;
        numRBPreambleGroupB_g = 2;

        fprintf(stderr,"NO ../cfg/ueSim_preambleConfig.txt\n");
        fprintf(stderr,"preambleRangeStart_g %d preambleRangeEnd_g %d\n",
                    preambleRangeStart_g,preambleRangeEnd_g);
        LTE_LOG(LOG_DETAIL,PNULL,"File ueSim_preambleConfig.txt opening error, \
                provide correct file name.\n");
        return;
    }
    
    while ((read = getline(&line_p, &len, preambleRangeFileFp)) != -1)
    {
        if (strncmp(line_p,"#",1) == 0)
        {
            if (line_p)
            {
                freeMemSys(line_p);
                line_p = PNULL;
            }
            continue;
        }
        else if (strncmp(line_p,"preambleRangeStart",18) == 0)
        {
            strncpy(temp,line_p+19,read);
            preambleRangeStart_g  = atoi(temp);
            fprintf(stderr,"preambleRangeStart_g  = %d\n",preambleRangeStart_g);
        }
        else if (strncmp(line_p,"preambleRangeEnd",16) == 0)
        {
            strncpy(temp,line_p+17,read);
            preambleRangeEnd_g  = atoi(temp);
            fprintf(stderr,"preambleRangeEnd_g = %d\n",preambleRangeEnd_g);
        }
        else if (strncmp(line_p,"mcsIndexPdcchOrder_g",20) == 0)
        {
            strncpy(temp,line_p+21,read);
            mcsIndexPdcchOrder_g  = atoi(temp);
            fprintf(stderr,"mcsIndexPdcchOrder_g = %d\n",mcsIndexPdcchOrder_g);
        }
        else if (strncmp(line_p,"numRBPdcchOrder_g",17) == 0)
        {
            strncpy(temp,line_p+18,read);
            numRBPdcchOrder_g = atoi(temp);
            fprintf(stderr,"numRBPdcchOrder_g = %d\n",numRBPdcchOrder_g);
        }
        else if (strncmp(line_p,"mcsIndexHO_g",12) == 0)
        {
            strncpy(temp,line_p+13,read);
            mcsIndexHO_g  = atoi(temp);
            fprintf(stderr,"mcsIndexHO_g = %d\n",mcsIndexHO_g);
        }
        else if (strncmp(line_p,"numRBHO_g",9) == 0)
        {
            strncpy(temp,line_p+10,read);
            numRBHO_g = atoi(temp);
            fprintf(stderr,"numRBHO_g = %d\n",numRBHO_g);
        }
        else if (strncmp(line_p,"mcsIndexPreambleGroupA_g",24) == 0)
        {
            strncpy(temp,line_p+25,read);
            mcsIndexPreambleGroupA_g  = atoi(temp);
            fprintf(stderr,"mcsIndexPreambleGroupA_g = %d\n",mcsIndexPreambleGroupA_g);
        }
        else if (strncmp(line_p,"numRBPreambleGroupA_g",21) == 0)
        {
            strncpy(temp,line_p+22,read);
            numRBPreambleGroupA_g  = atoi(temp);
            fprintf(stderr,"numRBPreambleGroupA_g = %d\n",numRBPreambleGroupA_g);
        }
        else if (strncmp(line_p,"mcsIndexPreambleGroupB_g",24) == 0)
        {
            strncpy(temp,line_p+25,read);
            mcsIndexPreambleGroupB_g  = atoi(temp);
            fprintf(stderr,"mcsIndexPreambleGroupB_g = %d\n",mcsIndexPreambleGroupB_g);
        }
        else if (strncmp(line_p,"numRBPreambleGroupB_g",21) == 0)
        {
            strncpy(temp,line_p+22,read);
            numRBPreambleGroupB_g  = atoi(temp);
            fprintf(stderr,"numRBPreambleGroupB = %d\n",numRBPreambleGroupB_g);
        }
    }
    
    preambleCircularIndex = preambleRangeStart_g;

    fclose(preambleRangeFileFp);
}


/****************************************************************************
 * Function Name  : fapiGetULDataPduNode
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    : This function will create the data PDU node that will be
 *                  pushed into uldataQueue when get data from RLC.
 ****************************************************************************/
inline ulschDataQueueNode* fapiGetULDataPduNode( UInt8 qIndex, UInt16 sendSfnSf,
                                                UInt16 rnti ) 
{
    ulschDataQueueNode *uldataNode_p = (ulschDataQueueNode *) 
                    getMemFromPool(sizeof(ulschDataQueueNode), PNULL);
    if ( PNULL == uldataNode_p )
    {
        return  uldataNode_p;
    }
    uldataNode_p->isCqiSet = FALSE;
    uldataNode_p->qIndex = qIndex;
    uldataNode_p->rnti = rnti;
    uldataNode_p->sendSfnSf = sendSfnSf;
    uldataNode_p->SF = sendSfnSf & FAPI_SF_MASK;
    uldataNode_p->SFN = (sendSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT; 
    uldataNode_p->pdudata_p = NULL;
    uldataNode_p->pduLen = 0;

    /* isCqiSet is set to reduce SINR below threshold */
    if( TRUE == invalidSfnRcvd_g )
    {
        uldataNode_p->isCqiSet = TRUE;
    }
    
    return  uldataNode_p;
}
/****************************************************************************
 * Function Name  : preapreCRCIndication 
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    : 
 ****************************************************************************/
UInt8 preapreCRCIndication( UInt16 rnti,UInt16 sendSfnSf, 
                           UInt8 qIndex, UInt8 msg3Flag, UInt8 cellIndex )
{
    static UInt32 ULpacketCounter_s[MAX_NUM_CELLS];
    UInt8  crc = FAPI_CRC_ERROR;
    FAPI_ulCrcIndicationNode_st *crcIndNode_p = PNULL;
    ueContextForUplink *ueContextInfo_p = PNULL;

    if ( msg3Flag )
    {
        crc = FAPI_CRC_CORRECT;
        crcIndNode_p = (FAPI_ulCrcIndicationNode_st *) 
            getMemFromPool(sizeof(FAPI_ulCrcIndicationNode_st), 
                    PNULL);     
        if ( PNULL == crcIndNode_p )
        {
            fprintf(stderr,"Error!! in allocating memory for CRC node\
                    while sending msg3\n");
            return crc;
        }
        crcIndNode_p->sfnsf = sendSfnSf;
        crcIndNode_p->crcPduInfo.handle = MAC_PHY_CONVERT_32(1);
        crcIndNode_p->crcPduInfo.rnti = rnti;
        crcIndNode_p->crcPduInfo.crcFlag = crc;
        pushNode(&(crcIndQueue[cellIndex][qIndex]), 
                &(crcIndNode_p->crcNodeAnchor));
        return crc;
    }

    ueContextInfo_p = getUEContext(rnti, cellIndex);

    if (PNULL == ueContextInfo_p)
    {
        fprintf(stderr, "Non Existent UEContext for RNTI [%d]\n", rnti);        
        return crc;
    }

    /* crc changes begin */
    if (PNULL == ((FAPI_ulCrcIndicationNode_st *)ueContextInfo_p->crcIndRefNode_p[qIndex]))
    {
        if(signalling_ack_nack_g[cellIndex] < ULpacketCounter_s[cellIndex])
        {
            if(crc_indication_g[cellIndex])
            {
                return crc;
            }
	    /* + Support for toggling configured Nack percentage to 100% ack and vice-versa */
	    if (ToggleTickCRC[cellIndex] > 1 && ((currentTick_g/ToggleTickCRC[cellIndex])%2))
	    {
                    crc = FAPI_CRC_CORRECT;
	    }
            else
	    {
		    crc = fapi_crc_g[crc_ind_value_array[cellIndex][ueContextInfo_p->shiftInd]\
			  [ueContextInfo_p->crcIndex]];
	    }
	    /* - Support for toggling configured Nack percentage to 100% ack and vice-versa */
        }
        else
        {
            crc = FAPI_CRC_CORRECT; /*ACK - 0*/
            ULpacketCounter_s[cellIndex]++;
        }
        /* rlf_issue_fixed start */
        if ((rnti >=700)&&(!ueContextInfo_p->ulNdi))
        {
            crc = FAPI_CRC_CORRECT; /*ACK - 0*/
        }
        /* rlf_issue_fixed end */


        ueContextInfo_p->crcIndex++;
        if(ueContextInfo_p->crcIndex == ACK_NACK_ARRAY_SIZE)
        {
            ueContextInfo_p->crcIndex = 0;
            ueContextInfo_p->shiftInd++;
            if(ACK_NACK_ARRAY_SIZE == ueContextInfo_p->shiftInd)
            {
                ueContextInfo_p->shiftInd = 0;
            }
        }

        crcIndNode_p = (FAPI_ulCrcIndicationNode_st *)
            getMemFromPool(sizeof(FAPI_ulCrcIndicationNode_st),
                    PNULL);
        if ( PNULL == crcIndNode_p )
        {
            fprintf(stderr,"Error!! in allocating memory for CRC node\n");
            return crc;
        }
        if( TRUE == invalidSfnRcvd_g )
        {
            crc = FAPI_CRC_ERROR; 
        }
        crcIndNode_p->sfnsf = sendSfnSf;
        crcIndNode_p->crcPduInfo.crcFlag = crc;
        crcIndNode_p->crcPduInfo.handle = MAC_PHY_CONVERT_32(1);
        crcIndNode_p->crcPduInfo.rnti = rnti;

        pushNode(&(crcIndQueue[cellIndex][qIndex]),
                &(crcIndNode_p->crcNodeAnchor));
        ueContextInfo_p->crcIndRefNode_p[qIndex] = crcIndNode_p;
    }
    else
    {
        crc = ((FAPI_ulCrcIndicationNode_st *)ueContextInfo_p->crcIndRefNode_p[qIndex])->crcPduInfo.crcFlag;
        /* rlf_issue_fixed start */
        if ((rnti >=700)&&(!ueContextInfo_p->ulNdi))
        {
            crc = FAPI_CRC_CORRECT; /*ACK - 0*/
        }
        /* rlf_issue_fixed end */
    }
    return crc;
/*crc changes end*/

}
/****************************************************************************
 * Function Name  : sendDatatoPeerMac 
 * Inputs         : message pointer, message Length
 * Outputs        : None
 * Returns        : None
 * Description    : This function will send the message to peer MAC 
 *                  on fast path Interface or on message queue.
 *
 ****************************************************************************/
inline void sendDatatoPeerMac( UInt8 *sendBuffer_p, UInt32 msgLen, UInt8 cellIndex)
{
    /* macLayerAddr_g.sin_port = htons(UPLK_PORT);*/
#if 0
    UInt16 api_id = 0;
    UInt8 *x = sendBuffer_p;
    x +=6;
    api_id = (*x| (*(x + 1) << 8));
    if ( api_id == MAC_UL_DATA_MSG_IND )
      fprintf(stderr," ========= UL data sent to MAC of msgLen = %d========\n",msgLen);
#endif
    if ( cellId_g[cellIndex] == 0 )
    {
        /* +CA_NA */
        if ( sendto(txSockFD_g[cellIndex],(UInt8 *)sendBuffer_p,msgLen, 0,
        /* -CA_NA */
                (struct sockaddr*)&macLayerAddr_g[cellIndex], sizeof(SockAddr)) < 0 )
        {
            ltePanic("Error in sending data on socket:: errno=%d",errno);
        }
    }
#ifdef HO_SETUP_CHANGES
    else if (cellId_g[cellIndex] == 1 )
    {
        /* +CA-SJ */
        sendDataToTargetEnbMac( sendBuffer_p, msgLen, cellIndex );
        /* -CA-SJ */
    }
#endif
    if(wiresharEnable_g)
    {
        sendto(wiresharkfd_g,(UInt8 *)sendBuffer_p,msgLen, 0,
                (struct sockaddr*)&wiresharkAddr_g, sizeof(SockAddr));
    }

#ifdef FAST_INTF
#endif

}
#if 0
/****************************************************************************
 * Function Name  : sendDatatoPeerMac 
 * Inputs         : message pointer, message Length
 * Outputs        : None
 * Returns        : None
 * Description    : This function will send the message to peer MAC 
 *                  on fast path Interface or on message queue.
 *
 ****************************************************************************/
void sendDatatoPeerMac( UInt8 *sendBuffer_p, UInt32 msgLen, uInt8 cellIndex)
{
    UInt32 len = msgLen;
    if ( sendto(txSockFD_g[cellIndex],(UInt8 *)sendBuffer_p,msgLen, 0,
            (struct sockaddr*)&macLayerAddr_g[cellIndex], sizeof(SockAddr)) < 0 )
    {
        ltePanic("Error in sending data on socket:: errno=%d",errno);
    }
    if(wiresharEnable_g)
    {
        sendto(wiresharkfd_g,(UInt8 *)sendBuffer_p,len, 0,
                (struct sockaddr*)&wiresharkAddr_g, sizeof(SockAddr));
    }
}
#endif
// code needs for only mac testing
#if 0
/****************************************************************************
 * Function Name  : checkPeroidicConfiguredUE
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    :
 *
 ****************************************************************************/

void checkPeroidicConfiguredUE()
{
  UInt16 row = 0, j = 0;
  UInt16 crnti = 0;
  for( row = 0 ; row < TOTAL_NUM_PERIODICITY; row++)
  {
    if ( globalTTITickCount_g % periodicCQITable[row].periodicity == 0)
    {
      for( j = 0; j <= periodicCQITable[row].numOfUEs; j++)
      {
        crnti = periodicCQITable[row].ueId[j];
        if( crnti != 0)
        {
          createAndSendPeriodicCQI(crnti);
        }
      }

    }
  }
}
/****************************************************************************
 * Function Name  : setValueInPeriodicityCounter
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    :
 *
 ****************************************************************************/

void setValueInPeriodicityCounter(UInt32 periodicity , UInt32 crnti)
{
  SInt32 rowId = -1;
  switch ( periodicity )
  {
    case PERIODICITY_2:
      periodicCQITable[0].numOfUEs++;
      rowId = 0;
      break;
    case PERIODICITY_5:
      periodicCQITable[1].numOfUEs++;
      rowId = 1;
      break;
    case PERIODICITY_10:
      periodicCQITable[2].numOfUEs++;
      rowId = 2;
      break;
    case PERIODICITY_20:
      periodicCQITable[3].numOfUEs++;
      rowId = 3;
      break;
    case PERIODICITY_32:
      periodicCQITable[4].numOfUEs++;
      rowId = 4;
      break;
    case PERIODICITY_40:
      periodicCQITable[5].numOfUEs++;
      rowId = 5;
      break;
    case PERIODICITY_64:
      periodicCQITable[6].numOfUEs++;
      rowId = 6;
      break;
    case PERIODICITY_80:
      periodicCQITable[7].numOfUEs++;
      rowId = 7;
      break;
    case PERIODICITY_128:
      periodicCQITable[8].numOfUEs++;
      rowId = 8;
      break;
    case PERIODICITY_160:
      periodicCQITable[9].numOfUEs++;
      rowId = 9;
      break;
    case PERIODICITY_256:
      periodicCQITable[10].numOfUEs++;
      rowId = 10;
      break;
    default:
#ifdef LTE_MAC_UT_LOG
      lteWarning("Invalid Periodicity");
#endif
      rowId = -1;
  }
  if ( rowId == -1)
    return;
  periodicCQITable[rowId].ueId[periodicCQITable[rowId].numOfUEs - 1] = crnti;
}
/****************************************************************************
 * Function Name  : initSendPeridicCQIBuffer
 * Inputs         :
 *
 *
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    :
 *
 ****************************************************************************/
void initSendPeridicCQIBuffer()
{
    UInt32 row = 0;
    UInt32 periodicity[] ={2,5,10,20,32,40,64,80,128,160,256};
    for( row = 0 ; row < TOTAL_NUM_PERIODICITY ; row++)
    {
        periodicCQITable[row].periodicity = periodicity[row];
    } 

}

#endif

#ifdef TDD_CONFIG

/*Imanish:- temp. added new functon*/
void sendDlAckNack( UInt16 sendSfnSf,
                    UInt16 rnti,
                    UInt8 qIndex
                    ,UInt8 cellIndex
                  )
{
    FAPI_harqIndQueueNode_st *harqNode_p = PNULL;
    /* send DL contention ack */
    harqNode_p = (FAPI_harqIndQueueNode_st *) 
               getMemFromPool(sizeof(FAPI_harqIndQueueNode_st),PNULL);

    if ( PNULL == harqNode_p )
    {
        fprintf(stderr,"Not able to get memory for DL ACK NACK packet in" "Contention resolution ACK\n");
        return;
    }

    harqNode_p->sfnsf = sendSfnSf;
    harqNode_p->harqPduInfo.rnti = MAC_PHY_CONVERT_16(rnti);
    harqNode_p->harqPduInfo.handle = MAC_PHY_CONVERT_32(1);
    harqNode_p->harqPduInfo.mode = 0;
    harqNode_p->harqPduInfo.numOfAckNack = 1;
//    ((FAPI_tddBundlingHarqInfo *)
   //     (harqNode_p->harqPduInfo.harqBuffer))->value0 = FAPI_ACK;
    harqNode_p->harqPduInfo.harqBuffer.value0 = FAPI_ACK;

    pushNode(&(harqQueue[cellIndex][qIndex]), &(harqNode_p->harqNodeAnchor) );
    fprintf(stderr,"\n\n######[%s]ush NodeAck for SfnSf [%d],qIndex[%d]\n\n",
                   __func__,sendSfnSf,qIndex);
                  

}


void fapiCheckTddHarq( UInt16 sendSfnSf,
                       UInt16 rnti,
                       UInt8 *ackNackFieldTB1_p, 
                       UInt8 *ackNackFieldTB2_p,
                       /* + SPR 14001 Changes */
                       UInt8 cellIndex,
                       UInt8 daiCellId)
                       /* - SPR 14001 Changes */
{
   
    UInt8 sendSF = sendSfnSf & FAPI_SF_MASK;    
    UInt16 sendSFN = (sendSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT;
    UInt8 harqIndex = sendSFN & 0x01;
    ueContextForUplink *ulUEContext_p = PNULL;
    DaiTrackingRegister *daiTrackingInfo_p = NULL;
    
    ulUEContext_p = getUEContext(rnti,cellIndex);

    /* + CA_TDD_HARQ_CHANGES */
    if (ulUEContext_p)
    {
        /* + SPR 14001 Changes */
        daiTrackingInfo_p = &(ulUEContext_p->daiTrackingRegister[daiCellId][harqIndex][sendSF]);
        /* - SPR 14001 Changes */
    }
    /* - CA_TDD_HARQ_CHANGES */
    
    /* + CA_TDD_HARQ_CHANGES */
    if (daiTrackingInfo_p)
    /* - CA_TDD_HARQ_CHANGES */
    {
        *ackNackFieldTB1_p = daiTrackingInfo_p->ackNackFieldTB1;
        *ackNackFieldTB2_p = daiTrackingInfo_p->ackNackFieldTB2;
    }
	
//    fprintf(stderr,"sendSFN [%d] sendSF [%d] Index[%d] ackNackFieldTB1_p [%d] ackNackFieldTB2_p [%d]\n",
//		sendSFN,sendSF,harqIndex,*ackNackFieldTB1_p,*ackNackFieldTB2_p);
}


#elif FDD_CONFIG

/****************************************************************************
 * Function Name  : fapiCheckHarq 
 * Inputs         : acknackIndexIncrement - 
 *                  TRUE - increment the index, in case of SISO and MIMO(TB1 valid TB2 invalid
 *                      or TB1 invalid TB2 valid)
 *                  FALSE - In case of MIMO,  only 1 TB is processed yet  and 
 *                  increment the index when 2nd TB is processed.
 * Outputs        :  
 * Returns        :  
 * Description    :  
 *                   
 ****************************************************************************/
/*SPR 2234 Changes Begin */
/* SPR 8993 changes start */
void fapiCheckHarq( UInt8 acknackIndexIncrement, UInt8 tbFlag,UInt8 *ackNackFieldTB1_p,
/* SPR 8993 changes end */
                    UInt8 *ackNackFieldTB2_p, UInt16 rnti, UInt8 cellIndex )
/*Spr 2234 changes End */
{
	/* SPR 2234 Fix Begin*/
	ueContextForUplink *ulUEContext_p = PNULL;
	/* SPR 2234 Fix End*/ 
	/*CLPC_CHG*/
	DLUEContext *dlUEContext_p = PNULL;
	/*CLPC_CHG*/

	UInt8 ackNackStatusForTB1 = 0;
	UInt8 ackNackStatusForTB2 = 0;

	if (sig_cnt[cellIndex] <= signalling_ack_nack_g[cellIndex])
	{
		*ackNackFieldTB1_p = 1;
		/* SPR 1811 Fix Start */    
		*ackNackFieldTB2_p = 1;
		/* SPR 1811 Fix End */
		sig_cnt[cellIndex]++;
		return;
	}

	/* SPR 2234 Fix Begin*/
	ulUEContext_p = getUEContext(rnti,cellIndex);
	if (PNULL == ulUEContext_p)
	{
		fprintf(stderr, "Non Existent UEContext for RNTI [%d]\n", rnti);
		return FAPI_NACK;

	}

	/* SPR 1811 Fix Start */   
	/*CLPC_CHG*/
	dlUEContext_p = getDLUEContextFromRnti(rnti,cellIndex);
	if(dlUEContext_p == PNULL)
	{
		return FAPI_NACK;
	}
        /* + Support for toggling configured Nack percentage to 100% ack and vice-versa */
        if (ToggleTickTB1[cellIndex] > 1 && ((currentTick_g/ToggleTickTB1[cellIndex])%2))
	{
           ackNackStatusForTB1=1;
	}
	else
	{
	   ackNackStatusForTB1 = dlUEContext_p->tpcAckNackContext.tb1_ack_nack_perUe_array
		[ulUEContext_p->rowCounter][ulUEContext_p->columnCounter];
	}
	/* SPR 1811 Fix End */
        if (ToggleTickTB2[cellIndex] > 1 && ((currentTick_g/ToggleTickTB2[cellIndex])%2))
	{
           ackNackStatusForTB2=1;
	}
	else
	{
	   ackNackStatusForTB2 = dlUEContext_p->tpcAckNackContext.tb2_ack_nack_perUe_array
		[ulUEContext_p->rowCounter][ulUEContext_p->columnCounter];
	}
        /* - Support for toggling configured Nack percentage to 100% ack and vice-versa */
	/*CLPC_CHG*/
	/* SPR 8993 changes start */    
	if(acknackIndexIncrement)
	{
		ulUEContext_p->columnCounter++;
		/* SPR 8993 changes end */    
		if ( ulUEContext_p->columnCounter >= ACK_NACK_ARRAY_SIZE)
		{
			ulUEContext_p->columnCounter = 0;
			ulUEContext_p->rowCounter++;
			if ( ulUEContext_p->rowCounter >= ACK_NACK_ARRAY_SIZE)
			{
				ulUEContext_p->rowCounter = 0;
			}
		}
	}

	(*ackNackFieldTB1_p) = ackNackStatusForTB1;
	(*ackNackFieldTB2_p) = ackNackStatusForTB2;
	/* SPR 2234 Fix End*/
#if 0
	UInt8 flag1 = TRUE;
	UInt8 flag2 = FALSE;
	static UInt8 arrIndexTB1_s      = 0;
	static UInt8 arrIndexTB2_s      = 0;
	static UInt8 packetCounterTB1_s = 0;
	static UInt8 packetCounterTB2_s = 0;

	/* based on DL ACK/NACK ratio send ACK/NACK */
	if ( mimoFlag )
	{
		switch ( tbFlag )
		{
			case IstTB_INVALID_2ndTB_VALID:
				*ackNackFieldTB1_p = FAPI_ACK_OR_NACK;
				flag1 = FALSE;
				break;
			case IstTB_VALID_2ndTB_INVALID:
				*ackNackFieldTB2_p = FAPI_ACK_OR_NACK;
				flag2 = FALSE;
				break;
			case BOTH_TB_VALID:
				*ackNackFieldTB1_p = FAPI_ACK;
				*ackNackFieldTB2_p = FAPI_ACK;
				break;
				/* SPR 609 changes start */
			default:    
				/* SPR 609 changes end */
				fprintf(stderr,"Error..!! worng tbFlag = %d received "
						"no harqIndicationPDU will be sent \n",tbFlag);
				return;
		}
		if( flag1 && nackChoiceTB1_g != 10)
		{
			*ackNackFieldTB1_p = FAPI_ACK;
			if (packetCounterTB1_s == TOTALPACKETS)
			{
				packetCounterTB1_s = 0;
				arrIndexTB1_s = 0;
			}
			if(dwlkPacketArrTB1_g[0] != 0 && 
					dwlkPacketArrTB1_g[arrIndexTB1_s] == packetCounterTB1_s + 1)
			{
				*ackNackFieldTB1_p =  FAPI_NACK; /*NACK */ 
				arrIndexTB1_s++;
			}
			packetCounterTB1_s++;
		}
		if ( flag2 && nackChoiceTB2_g != 10 )
		{
			*ackNackFieldTB2_p = FAPI_ACK;
			if (packetCounterTB2_s == TOTALPACKETS)
			{
				packetCounterTB2_s = 0;
				arrIndexTB2_s = 0;
			}
			if( dwlkPacketArrTB2_g[0] != 0  && 
					dwlkPacketArrTB2_g[arrIndexTB2_s] == (packetCounterTB2_s + 1) )
			{
				*ackNackFieldTB2_p =  FAPI_NACK; /*NACK */
				arrIndexTB2_s++;
			}
			packetCounterTB2_s++;
		}
	}
	else /* normal SISO */
	{
		if(nackChoiceTB1_g != 10)
		{
			*ackNackFieldTB1_p = FAPI_ACK;
			if (packetCounterTB1_s == TOTALPACKETS)
			{
				packetCounterTB1_s = 0;
				arrIndexTB1_s = 0;
			}
			if(dwlkPacketArrTB1_g[0] != 0 && 
					dwlkPacketArrTB1_g[arrIndexTB1_s] == packetCounterTB1_s + 1)
			{
				*ackNackFieldTB1_p =  FAPI_NACK; /*NACK */ 
				arrIndexTB1_s++;
			}
			packetCounterTB1_s++;
		}
		*ackNackFieldTB2_p = FAPI_ACK_OR_NACK;
	}
#endif
}
/* + CA_TDD_HARQ_CHANGES */
#endif


/****************************************************************************
 * Function Name  : updateHarqIndNode 
 * Inputs         :  
 * Outputs        :  
 * Returns        :  
 * Description    :  
 *                   
 ****************************************************************************/

updateHarqIndNode(UInt8 pCellTbCount, UInt8 sCellTbCount, UInt8 cellId,UInt8 numOfAckNack, 
        UInt8 *ackNackFieldTB1,UInt8 *ackNackFieldTB2, 
#ifdef FDD_CONFIG
        UInt8 acknackIndexIncrement,
#endif
        FAPI_harqIndQueueNode_st *harqNode_p,UInt8 cellIndex)
{
	UInt16 rnti = harqNode_p->harqPduInfo.rnti;

	DLUEContext *ueContextInfo_p = PNULL;
	ueContextForUplink *ueUlContextInfo_p = PNULL;

	ueContextInfo_p = getDLUEContextFromRnti(rnti,cellIndex);
	ueUlContextInfo_p = getUEContext(rnti,cellIndex);

#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
    if (cellId == PCELL)
    {
#ifdef FDD_CONFIG
        if (pCellTbCount == 1)
        {
            harqNode_p->harqPduInfo.release9Param.HARQTB[0] = *ackNackFieldTB1;
        }
        else
        {
            harqNode_p->harqPduInfo.release9Param.HARQTB[0] = *ackNackFieldTB1;
            harqNode_p->harqPduInfo.release9Param.HARQTB[1] = *ackNackFieldTB2;
        }
#else
#if 0        
        harqNode_p->harqPduInfo.channelSelectionHarqBuffer[0].value0 = *ackNackFieldTB1;
        if (1 < pCellTbCount)
        {
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[1].value0 = *ackNackFieldTB1;
#endif           
        if ( pCellTbCount == 1 && sCellTbCount == 2 )
        {
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[2].value0 = *ackNackFieldTB1;
        }
        else
        {
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[0].value0 = *ackNackFieldTB1;
            if (1 < pCellTbCount)
            {
                harqNode_p->harqPduInfo.channelSelectionHarqBuffer[1].value0 = *ackNackFieldTB2;
            }

        }
#endif
    }
    else
    {
#ifdef FDD_CONFIG
        /*Bug 11713 fix Start*/
        numOfAckNack = harqNode_p->harqPduInfo.release9Param.numOfAckNack;  
        *ackNackFieldTB1 = ueContextInfo_p->tpcAckNackContextScell.tb1_ack_nack_perUe_array
            [ueUlContextInfo_p->rowSCellCounter][ueUlContextInfo_p->columnSCellCounter];
        *ackNackFieldTB2 = ueContextInfo_p->tpcAckNackContextScell.tb2_ack_nack_perUe_array
            [ueUlContextInfo_p->rowSCellCounter][ueUlContextInfo_p->columnSCellCounter];

        if(acknackIndexIncrement)
        {
            ueUlContextInfo_p->columnSCellCounter++;
            /* SPR 8993 changes end */    
            if ( ueUlContextInfo_p->columnSCellCounter >= ACK_NACK_ARRAY_SIZE)
            {
                ueUlContextInfo_p->columnSCellCounter = 0;
                ueUlContextInfo_p->rowSCellCounter++;
                if ( ueUlContextInfo_p->rowSCellCounter >= ACK_NACK_ARRAY_SIZE)
                {
                    ueUlContextInfo_p->rowSCellCounter = 0;
                }
            }
        }
        /*Bug 11713 fix End*/

        switch(numOfAckNack)
        {
            case  2:
            /* + SPR 11217 Changes */
                harqNode_p->harqPduInfo.release9Param.HARQTB[1] = *ackNackFieldTB1;
            /* - SPR 11217 Changes */
                break;
            case 3:
                if (pCellTbCount == 2)
                {
                    harqNode_p->harqPduInfo.release9Param.HARQTB[2] = *ackNackFieldTB1;
                }
                else
                {
                    harqNode_p->harqPduInfo.release9Param.HARQTB[2] = harqNode_p->harqPduInfo.release9Param.HARQTB[0];
                    harqNode_p->harqPduInfo.release9Param.HARQTB[0] = *ackNackFieldTB1;
                    harqNode_p->harqPduInfo.release9Param.HARQTB[1] = *ackNackFieldTB2;
                }
                break;
            case 4:
                harqNode_p->harqPduInfo.release9Param.HARQTB[2] = *ackNackFieldTB1;
                harqNode_p->harqPduInfo.release9Param.HARQTB[3] = *ackNackFieldTB2;
                break;

                default:
                break;

        }
#else
        numOfAckNack = harqNode_p->harqPduInfo.numOfAckNack;  
        switch(numOfAckNack)
        {
            case  2:
            /* + SPR 11217 Changes */
                harqNode_p->harqPduInfo.channelSelectionHarqBuffer[1].value0 = *ackNackFieldTB1;
            /* - SPR 11217 Changes */
                break;
            case 3:
                if (pCellTbCount == 2)
                {
                    harqNode_p->harqPduInfo.channelSelectionHarqBuffer[2].value0 = *ackNackFieldTB1;
                }
                else
                {
                    //harqNode_p->harqPduInfo.channelSelectionHarqBuffer[2].value0 = harqNode_p->harqPduInfo.channelSelectionHarqBuffer[0].value0;
                    harqNode_p->harqPduInfo.channelSelectionHarqBuffer[0].value0 = *ackNackFieldTB1;
                    harqNode_p->harqPduInfo.channelSelectionHarqBuffer[1].value0 = *ackNackFieldTB2;
                }
                break;
            case 4:
                harqNode_p->harqPduInfo.channelSelectionHarqBuffer[2].value0 = *ackNackFieldTB1;
                harqNode_p->harqPduInfo.channelSelectionHarqBuffer[3].value0 = *ackNackFieldTB2;
                break;
            default:
                break;
        }
#endif


    }
#endif
}
/* - CA_TDD_HARQ_CHANGES */
/****************************************************************************
 * Function Name  : fapiSendHarqIndication 
 * Inputs         :  
 * Outputs        :  
 * Returns        :  
 * Description    :  
 *                   
 ****************************************************************************/
/* + SPR 11216 Changes */
/*Bug 11713 fix Start*/
/* + CA_TDD_HARQ_CHANGES */    
void fapiSendHarqIndication(
#ifdef FDD_CONFIG
        UInt8 acknackIndexIncrement,
#endif
        UInt16 crnti, 
		UInt8 qIndex,
#ifdef FDD_CONFIG
        UInt16 sendSfnSf,
#endif
/* SPR 609 changes start */
        UInt8 *ackNackFieldTB1,UInt8 *ackNackFieldTB2,
/* SPR 609 changes end */
#ifdef TDD_CONFIG
        FAPI_harqIndQueueNode_st  *harqNode_p,
        UInt8 txCellIndex,
#endif
        UInt8 cellIndex)
/* - CA_TDD_HARQ_CHANGES */    
/*Bug 11713 fix End*/
{
/* + CA_TDD_HARQ_CHANGES */    
#ifdef FDD_CONFIG
    FAPI_harqIndQueueNode_st  *harqNode_p = PNULL;
    UInt8 txCellIndex = cellIndex;
#endif
/* - CA_TDD_HARQ_CHANGES */    
#if 0
    harqNode_p = ( FAPI_harqIndQueueNode_st  *) getMemFromPool (
            sizeof (FAPI_harqIndQueueNode_st ), PNULL );
#endif
    DLUEContext *ueContextInfo_p = PNULL;
    ueContextForUplink *ueUlContextInfo_p = PNULL;
    UInt8  queueCount = 0;
    UInt8 pCellTbCount = 0;
    UInt8 sCellTbCount = 0;
    UInt8 numOfAckNack = 0;
    /* SPR 11998 fix start */
    UInt16 crntiForSpsUe = 0;
    /* SPR 11998 fix end */
#if 0
    if ( PNULL == harqNode_p )
    { 
        fprintf(stderr," in function: fapiSendHarqIndication  mem alloc failed \
                while sending harq indication for crnti = %d\n", crnti);
        return;     
    }
    harqNode_p->sfnsf = sendSfnSf;
    harqNode_p->harqPduInfo.rnti = MAC_PHY_CONVERT_16(crnti); 
#endif
    /* SPR 609 changes start */

#ifdef FAPI_4_0_COMPLIANCE
#if (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))

    ueContextInfo_p = getDLUEContextFromRnti(MAC_PHY_CONVERT_16
            (crnti), cellIndex);
    if(ueContextInfo_p == PNULL)
    {
        lteWarning("Dl Ue context is NULL\n");
        return;
    }

    if (PNULL == (ueUlContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(crnti), cellIndex)))
    {
        fprintf (stderr, "HARQ Node has to be pushed in Queue for UE having"
                "crnti =%d but Context Doesnot exist for this UE\n",MAC_PHY_CONVERT_16(crnti));
        return;

    }
    UInt32 diff = 0;

    /* SPR 11962 fix start */
    if (crnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti && 
            crnti <= cellConfigUeSim_g[cellIndex].endSpsCrnti)
    {
        /* SPR 11998 fix start */
        /* Get the actual CRNTI for SPS UE */
        crntiForSpsUe = ueContextInfo_p->crnti;
    }
    else
    {
        crntiForSpsUe = crnti;
    }

    if (cellConfigUeSim_g[cellIndex].lowerCRNTIBound == startRARNTI_g)
    {
        diff = crntiForSpsUe - (endRARNTI_g[cellIndex] - startRARNTI_g + 1 + cellConfigUeSim_g[cellIndex].lowerCRNTIBound);
    }
    else
    {
        /* + SPR 14111 Changes */
        diff = crntiForSpsUe - cellConfigUeSim_g[txCellIndex].lowerCRNTIBound;
        /* - SPR 14111 Changes */
    }
    /* SPR 11998 fix end */
    /* SPR 11962 fix end */
    //    fprintf(stderr, "diff = %d\n", diff);

    /* Handle is not being filled in current code as well */
    /*
       harqNode_p->harqPduInfo.handle = 0; 
     */

    /* Harq Indication for CA UEs */

    HarqIndQueueNodeInfo *harqIndQNode_p = PNULL;
    if (0 < ueUlContextInfo_p->carrierAggrConfig.scellCount)
    {
        /* SPR 11755 + 11962 Fix Start */
        /* + SPR 14111 Changes */
        harqIndQNode_p = &(harqIndQNode_gp[txCellIndex][diff]);
        /* - SPR 14111 Changes */
        /* SPR 11755 + 11962 Fix End */
        if (PNULL == harqIndQNode_p)
        {
#if 0
            harqIndQNode_p =  ( HarqIndQueueNodeInfo  *) getMemFromPool (
                    sizeof (HarqIndQueueNodeInfo ), PNULL );
            fprintf(stderr,"\n Memory allocation done for harqIndQNode_p");
            (harqIndQNode_gp[cellIndex][crnti]) = harqIndQNode_p;
            harqIndQNode_gp[cellIndex][crnti].state = FALSE;
            harqIndQNode_gp[cellIndex][crnti].qIndex = MAX_SUBFRAME;
#endif
            fprintf(stderr,"\n Memory not found for harqIndQNode_p");
            return;
        }

        /* pointer at that q index is null then*/
        if(ueContextInfo_p->transmissionMode > 2)
        { 
            pCellTbCount = 2;
        }
        else
        {
            pCellTbCount = 1;
        }
        /** SPR 12208 Fix : Start **/
        //if (ueUlContextInfo_p->carrierAggrConfig.scellInfo[cellIndex].transmissionMode > 2)
        if (ueUlContextInfo_p->carrierAggrConfig.scellInfo[0].transmissionMode > 2)
        /** SPR 12208 Fix : End **/
        {
            sCellTbCount = 2;
        }
        else
        {
            sCellTbCount = 1;
        }
        //harqNode_p->harqPduInfo.release9Param.numOfAckNack = pCellTbCount + sCellTbCount;

        /* SPR 12832 FIX , added first condition */
/* + CA_TDD_HARQ_CHANGES */   
/* SPR 15278 */ 
#ifdef FDD_CONFIG
        if ( ( qIndex != harqIndQNode_gp[txCellIndex][diff].qIndex)||(TRUE != harqIndQNode_p->state)  )
/* - CA_TDD_HARQ_CHANGES */    
        {
#endif
/* SPR 15278 */ 
            /*
               harqNode_p = (FAPI_fddHarqPduIndicationR9_st *)harqIndQNode_p;
             */
/* + CA_TDD_HARQ_CHANGES */    
#ifdef FDD_CONFIG
/* - CA_TDD_HARQ_CHANGES */    
            /* Store harq TB first time then update next time */
            harqNode_p = ( FAPI_harqIndQueueNode_st  *) getMemFromPool (
                    sizeof (FAPI_harqIndQueueNode_st ), PNULL );
            if ( PNULL == harqNode_p )
            { 
                fprintf(stderr," in function: fapiSendHarqIndication  mem alloc failed \
                        while sending harq indication for crnti = %d\n", crnti);
                return;     
            }
            harqNode_p->sfnsf = sendSfnSf;
            harqNode_p->harqPduInfo.rnti = MAC_PHY_CONVERT_16(crnti);
            harqNode_p->harqPduInfo.release9Param.HARQTB[0] = ACK;
            harqNode_p->harqPduInfo.release9Param.HARQTB[1] = ACK;
            harqNode_p->harqPduInfo.release9Param.HARQTB[2] = ACK;
            harqNode_p->harqPduInfo.release9Param.HARQTB[3] = ACK;
            harqNode_p->harqPduInfo.release9Param.mode = 1;
            harqNode_p->harqPduInfo.release9Param.numOfAckNack = pCellTbCount + sCellTbCount;
            numOfAckNack = harqNode_p->harqPduInfo.release9Param.numOfAckNack;
/* + CA_TDD_HARQ_CHANGES */    
#elif TDD_CONFIG
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[0].value0 = ACK;
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[1].value0 = ACK;
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[2].value0 = ACK;
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[3].value0 = ACK;
#if 0
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[0].value0 = 3;
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[1].value0 = 3;
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[2].value0 = 3;
            harqNode_p->harqPduInfo.channelSelectionHarqBuffer[3].value0 = 3;
#endif            
            harqNode_p->harqPduInfo.mode = CHANNEL_SELECTION;
            harqNode_p->harqPduInfo.numOfAckNack = pCellTbCount + sCellTbCount;
            numOfAckNack = harqNode_p->harqPduInfo.numOfAckNack;
#endif
/* - CA_TDD_HARQ_CHANGES */    

            /*HARQ NACK fix, if data is scheduled only on scell in a tick*/ 
            /* + SPR 13887 Changes */
            if(txCellIndex != cellIndex)
            {
                harqIndQNode_gp[txCellIndex][diff].isScell = TRUE;
            }
            /* - SPR 13887 Changes */
/* + CA_TDD_HARQ_CHANGES */    
            if(TRUE == harqIndQNode_gp[txCellIndex][diff].isScell)
/* - CA_TDD_HARQ_CHANGES */    
            {
                updateHarqIndNode(pCellTbCount, sCellTbCount, SCELL, numOfAckNack, ackNackFieldTB1, ackNackFieldTB2,
/* + CA_TDD_HARQ_CHANGES */    
#ifdef FDD_CONFIG
                        TRUE, 
#endif
                        harqNode_p,cellIndex);
                harqIndQNode_gp[txCellIndex][diff].isScell = FALSE;
/* - CA_TDD_HARQ_CHANGES */    
            }
            else
            {
/* + CA_TDD_HARQ_CHANGES */    
                updateHarqIndNode(pCellTbCount, sCellTbCount, PCELL, numOfAckNack, ackNackFieldTB1, ackNackFieldTB2,
#ifdef FDD_CONFIG
                    acknackIndexIncrement, 
#endif
                    harqNode_p,txCellIndex);
/* - CA_TDD_HARQ_CHANGES */    
            }

            /* SPR 11962 fix start */
/* + CA_TDD_HARQ_CHANGES */    
            harqIndQNode_gp[txCellIndex][diff].qIndex = qIndex;
            harqIndQNode_gp[txCellIndex][diff].state = TRUE;
/* - CA_TDD_HARQ_CHANGES */    
            /* SPR 11962 fix end */
/* SPR 15278 */ 
#ifdef FDD_CONFIG
        }
        else
        {
            /* Check "index" field */

            //harqIndQNode_p =   &(harqIndQNode_gp[cellIndex][crnti]);
            /* SPR 11962 fix start */
/* + CA_TDD_HARQ_CHANGES */    
            qIndex = harqIndQNode_gp[txCellIndex][diff].qIndex;
/* - CA_TDD_HARQ_CHANGES */    
            /* SPR 11962 fix end */
/* + SPR 14111 Changes */
#ifdef FDD_CONFIG            
            if(qIndex >= MAX_SUBFRAME)
#elif TDD_CONFIG
            if(qIndex >= MAX_UL_ARRAY)
#endif                
/* - SPR 14111 Changes */
            {
                fprintf(stderr, "%s invalid q index [%d]\n", __func__, qIndex);
                return ;
            }

/* + CA_TDD_HARQ_CHANGES */    
            queueCount = sQueueCount(&(harqQueue[txCellIndex][qIndex]));
/* - CA_TDD_HARQ_CHANGES */    
            /*
               harqNode_p =  ( HarqIndQueueNodeInfo  *) getMemFromPool (
               sizeof (HarqIndQueueNodeInfo ), PNULL );
             */
/* + CA_TDD_HARQ_CHANGES */    
            harqNode_p = ( FAPI_harqIndQueueNode_st * ) getFirstNode(&(harqQueue[txCellIndex][qIndex]));
/* - CA_TDD_HARQ_CHANGES */    

            while ( queueCount-- )
            {

                if (harqNode_p->harqPduInfo.rnti != crnti)
                {
                    harqNode_p = ( FAPI_harqIndQueueNode_st *)getNextNode((const LTE_SNODE *)harqNode_p);

                }
                else
                {
/* + CA_TDD_HARQ_CHANGES */    
                    harqNode_p = ( FAPI_harqIndQueueNode_st * )
                        popNode ( &(harqQueue[txCellIndex][qIndex]) );
/* - CA_TDD_HARQ_CHANGES */    
                    break;
                }

            }
            /* Update Harq TB if data scheduled at Scell */
            /* + SPR 11218 Changes */
            if(harqNode_p != PNULL) 
            {
                updateHarqIndNode(pCellTbCount, sCellTbCount, SCELL, numOfAckNack, ackNackFieldTB1, ackNackFieldTB2, 
/* + CA_TDD_HARQ_CHANGES */    
#ifdef FDD_CONFIG
                        acknackIndexIncrement,
#endif
                        harqNode_p,cellIndex);
#ifdef FDD_CONFIG
/* - CA_TDD_HARQ_CHANGES */    
                /* + SPR 11327 Fix */
                harqNode_p->harqPduInfo.release9Param.mode = 1;
                /* - SPR 11327 Fix */
/* + CA_TDD_HARQ_CHANGES */    
#elif TDD_CONFIG
                harqNode_p->harqPduInfo.mode = CHANNEL_SELECTION;
                /* + SPR 14112 Changes */
                pushNode(&(harqQueue[txCellIndex][qIndex]), &(harqNode_p->harqNodeAnchor)); 
                /* - SPR 14112 Changes */
#endif
/* - CA_TDD_HARQ_CHANGES */    
            }
            /* - SPR 11218 Changes */
            /* SPR 11962 fix start */
/* + CA_TDD_HARQ_CHANGES */    
            harqIndQNode_gp[txCellIndex][diff].state = FALSE;
/* + SPR 14111 Changes */
#ifdef FDD_CONFIG            
            harqIndQNode_gp[txCellIndex][diff].qIndex = MAX_SUBFRAME;
#elif TDD_CONFIG            
            harqIndQNode_gp[txCellIndex][diff].qIndex = MAX_UL_ARRAY;
#endif            
/* - SPR 14111 Changes */
/* - CA_TDD_HARQ_CHANGES */    
            /* SPR 11962 fix end */
        }
#endif
/* SPR 15278 */ 
    }
    /* Harq Indication for Non CA UEs */
    else
    {
/* + CA_TDD_HARQ_CHANGES */    
#ifdef FDD_CONFIG
        harqNode_p = ( FAPI_harqIndQueueNode_st  *) getMemFromPool (
                sizeof (FAPI_harqIndQueueNode_st ), PNULL );

        if ( PNULL == harqNode_p )
        { 
            fprintf(stderr," in function: fapiSendHarqIndication  mem alloc failed \
                    while sending harq indication for crnti = %d\n", crnti);
            return;     
        }

        harqNode_p->sfnsf = sendSfnSf;
        harqNode_p->harqPduInfo.rnti = MAC_PHY_CONVERT_16(crnti); 

        /* + SPR 11327 Fix */
        harqNode_p->harqPduInfo.release9Param.mode = 0;
        /* - SPR 11327 Fix */

        /* MIMO */
        /*SPR 20019 +*/
        if (ueContextInfo_p->transmissionMode > 2 && ( FAPI_ACK_OR_NACK != *ackNackFieldTB1 && FAPI_ACK_OR_NACK != *ackNackFieldTB2))
        /*SPR 20019 -*/  
        {
            harqNode_p->harqPduInfo.release9Param.numOfAckNack = 2;
            harqNode_p->harqPduInfo.release9Param.HARQTB[0] = *ackNackFieldTB1;
            harqNode_p->harqPduInfo.release9Param.HARQTB[1] = *ackNackFieldTB2;
        }
        /* SISO */
        else
        {
            harqNode_p->harqPduInfo.release9Param.numOfAckNack = 1;
            /*SPR 20019 +*/
            if(FAPI_ACK_OR_NACK != *ackNackFieldTB1)
            {
                harqNode_p->harqPduInfo.release9Param.HARQTB[0] = *ackNackFieldTB1;
            }
            else
            {
                harqNode_p->harqPduInfo.release9Param.HARQTB[0] = *ackNackFieldTB2;
            }
            /*SPR 20019 -*/
        }
#elif TDD_CONFIG
        ltePanic("\nWrong mode Channel Selection selected for Non-CA UE = %d",ueUlContextInfo_p->ueIdx);
#endif
/* - CA_TDD_HARQ_CHANGES */    
    }
    /** SPR 13147 Fix : Start **/
#else
/* + CA_TDD_HARQ_CHANGES */    
#ifdef FDD_CONFIG
    /* start SPR 11662 */
    harqNode_p = ( FAPI_harqIndQueueNode_st  *) getMemFromPool (
            sizeof (FAPI_harqIndQueueNode_st ), PNULL );
    harqNode_p->sfnsf = sendSfnSf;
    harqNode_p->harqPduInfo.rnti = MAC_PHY_CONVERT_16(crnti); 
    /* end SPR 11662 */
#endif
/* - CA_TDD_HARQ_CHANGES */    
#endif
    /** SPR 13147 Fix : Start **/
#else
/* + CA_TDD_HARQ_CHANGES */    
#ifdef FDD_CONFIG
    /* start SPR 11662 */
    harqNode_p = ( FAPI_harqIndQueueNode_st  *) getMemFromPool (
            sizeof (FAPI_harqIndQueueNode_st ), PNULL );
    harqNode_p->sfnsf = sendSfnSf;
    harqNode_p->harqPduInfo.rnti = MAC_PHY_CONVERT_16(crnti); 
    /* end SPR 11662 */
#endif
#endif
/* - CA_TDD_HARQ_CHANGES */    

/* + CA_TDD_HARQ_CHANGES */    
#ifdef FDD_CONFIG
/* - CA_TDD_HARQ_CHANGES */    
#ifndef FAPI_4_0_COMPLIANCE
    harqNode_p->harqPduInfo.harqTB1 = *ackNackFieldTB1;  
    harqNode_p->harqPduInfo.harqTB2 = *ackNackFieldTB2;
#else
#if (!defined(FAPI_RELEASE10) && !defined(FAPI_RELEASE9))
    harqNode_p->harqPduInfo.release8Param.harqTB1 = *ackNackFieldTB1;
    /* +- SPR 21997 Fix */
    harqNode_p->harqPduInfo.release8Param.harqTB2 = *ackNackFieldTB2;
#endif
#endif

    pushNode(&(harqQueue[cellIndex][qIndex]), &(harqNode_p->harqNodeAnchor));  
/* + CA_TDD_HARQ_CHANGES */    
#endif
/* - CA_TDD_HARQ_CHANGES */    
    /* SPR 609 changes start */
    /* SPR 609 changes end */
    /* SPR 609 changes end */
#ifdef UE_SIM_ENABLE_PRINTF_LOGS 
    fprintf(stderr,"harq node pushed into harq queue at index = %d for rnti = %d, sfnsf = %d, cellIndex[%d]\n",
            qIndex, harqNode_p->harqPduInfo.rnti, harqNode_p->sfnsf, cellIndex);
#endif
}
/* - SPR 11216 Changes */

#if 0
/****************************************************************************
 * Function Name  :  prepareCCCHSDU
 * Inputs         :  
 * Outputs        :  
 * Returns        :  
 * Description    :  
 *                   
 ****************************************************************************/
void prepareCCCHSDU(UInt8 **sendBuffer_p, RARequest *raReq_p)
{
    UInt8 *sendBufer_p = *sendBuffer_p;
    UInt8 i = 0;

    if (PNULL != raReq_p)
    {
        while (i < raReq_p->rrcConReqLen)
        {
            *sendBufer_p = raReq_p->rrcConnectionReq[i++];
            sendBufer_p++;
        }
    }

    (*sendBuffer_p) = sendBufer_p;
}
#endif

/****************************************************************************
 * Function Name  : fapiCreateAndSendMsg3withCrntiCE
 * Inputs         :  rnti value, system frame numberm, subframenumber,
 *                   and the qindex on which node will be pushed  
 * Outputs        :  
 * Returns        :  
 * Description    : 
 *                   
 ****************************************************************************/
void fapiCreateAndSendMsg3withCrntiCE(ueContextForUplink *ulUEContext_p, 
        UInt32 sendSfnSf, UInt8 qIndex,UInt32 tbSize,UInt16 rarnti,
        UInt16 tempCrnti, UInt8 cellIndex)
{
    ulschDataQueueNode *uldataNode_p = PNULL;  
    RARequest raReq  = {0};
    UInt16 macRetType = 0;
    raReq = raRntiArr_g[cellIndex][rarnti - 1];

    if (tbSize >= 11) /*ULA_UTP*/
    {
        ulUEContext_p->bsrPresentFlag = 1;
        ulUEContext_p->crntiCEFlag = 1; 
        uldataNode_p = (ulschDataQueueNode *) 
            getMemFromPool(sizeof(ulschDataQueueNode), PNULL);
        if ( PNULL == uldataNode_p )
        {
            fprintf(stderr,"Not able to get memory for" \ 
                            "ulschDataQueueNode" \
                            "in fapiCreateAndSendMsg3withCrntiCE\n");
            return  uldataNode_p;
        }
        uldataNode_p->qIndex = qIndex;
        uldataNode_p->rnti = tempCrnti;
        uldataNode_p->sendSfnSf = sendSfnSf;
        uldataNode_p->SF = sendSfnSf & FAPI_SF_MASK;
        uldataNode_p->SFN = (sendSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT; 
        uldataNode_p->pdudata_p = NULL;
        uldataNode_p->pduLen = 0;
        macRetType = distributeRBsAndSendReqToRLC(ulUEContext_p->ueIdx,
                tbSize,
                ulUEContext_p->bsrPresentFlag,
                uldataNode_p,
                &(uldataNode_p->pdudata_p),
                &(uldataNode_p->pduLen),
                FALSE
#ifdef FDD_CONFIG
                ,PNULL
#endif
                ,cellIndex);
#if 0
        fprintf(stderr, "\n Recieve data from RLC [%d]\n", macRetType);
#endif
        if ( MAC_SUCCESS == macRetType )
        {
        }
        else if(MAC_PARTIAL_SUCCESS == macRetType)
        {
            sendMsg3withOnlycrntiCE(ulUEContext_p->crnti, sendSfnSf, qIndex,
                    tempCrnti, cellIndex);
            fprintf(stderr,"NO Uplink QLOAD MSG3 With Only Crnti Sent %d\n", ulUEContext_p->crnti);
        }
        else if(MAC_FAILURE == macRetType)
        {
            /* SPR 2417 changes start */
            freeMemPool(uldataNode_p);
            uldataNode_p = PNULL;
            /* SPR 2417 changes end */
        }
    }
    else
    {
        /* handling of UL Grant */
        sendMsg3withOnlycrntiCE(ulUEContext_p->crnti, sendSfnSf, qIndex,
                tempCrnti, cellIndex);
        fprintf(stderr,"TBSIZE %d MSG3 With Only Crnti Sent %d\n",tbSize,ulUEContext_p->crnti);
    }
}

/****************************************************************************
 * Function Name  : sendMsg3withOnlycrntiCE
 * Inputs         :  rnti value, system frame numberm, subframenumber,
 *                   and the qindex on which node will be pushed  
 * Outputs        :  
 * Returns        :  
 * Description    : 
 *                   
 ****************************************************************************/
void sendMsg3withOnlycrntiCE(UInt16 rnti, UInt32 sendSfnSf,UInt8 qIndex,
        UInt16 tempCrnti, UInt8 cellIndex)
{
    UInt8    *sendBuffer_p = PNULL;
    UInt8    *start_p = PNULL;
    ulschDataQueueNode *uldataNode_p = PNULL;
    UInt8 sduSubHeader = 0;
    ueContextForUplink *ulUEContext_p = getUEContext(rnti, cellIndex);
    start_p = ( UInt8 *) getMemFromPool (20, PNULL);
    if ( PNULL == start_p )
    {
        fprintf(stderr,"Not able to get memory for msg3 Data packet in "
                "fapiCreateAndSendMsg3withOnlycrntiCE\n");
        return; 
    }
    sendBuffer_p = start_p;
    sduSubHeader |= (0 << 7);
    sduSubHeader |= (0 << 6);
    sduSubHeader |= (0  << 5);
    sduSubHeader |=  27 & 0x1F;
    *sendBuffer_p++ = sduSubHeader;

    *sendBuffer_p++ = (UInt8) (rnti >> 8);
    *sendBuffer_p++ = (UInt8) rnti;


    uldataNode_p = (ulschDataQueueNode *) 
        getMemFromPool(sizeof(ulschDataQueueNode), PNULL);
    if ( uldataNode_p == PNULL )
    {
        fprintf(stderr,"Not able to get memory for ulschDataQueueNode"
                " in fapiCreateAndSendMsg3withOnlycrntiCE\n");
        return;
    }

    uldataNode_p->pdudata_p = start_p;
    uldataNode_p->sendSfnSf = sendSfnSf;
    uldataNode_p->SF = sendSfnSf & FAPI_SF_MASK;    
    uldataNode_p->SFN = (sendSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT;    
    uldataNode_p->rnti = tempCrnti;
    uldataNode_p->qIndex = qIndex;
    uldataNode_p->pduLen = sendBuffer_p - start_p;
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,"prepareCCCHSDU called for rnti = %d uldataNode_p->pduLen = %d\n", tcrnti, uldataNode_p->pduLen);
#endif
    pushNode(&ulDataQueue[cellIndex][qIndex], &(uldataNode_p->ulDataAnchor) );
    if( ulUEContext_p->crntiCEFlag)
    {
        ulUEContext_p->crntiCEFlag=0x0;
    }

}

/****************************************************************************
 * Function Name  : fapiCreateAndSendMsg3 
 * Inputs         :  rnti value, sent raReq, system frame numberm, subframenumber,
 *                   and the qindex on which node will be pushed  
 * Outputs        :  
 * Returns        :  
 * Description    : 
 *                   
 ****************************************************************************/
void fapiCreateAndSendMsg3( UInt16 tcrnti, 
                        RARequest *raReq_p, 
                        UInt16 sendSfnSf, 
                        UInt8 qIndex,
                        UInt8 cellIndex)
{
    UInt16   pduLen = 0;
    UInt8    *sendBuffer_p = PNULL;
    UInt8    *start_p = PNULL;
/* SPR 609 changes start */    
    //FAPI_l1ApiMsg_st           *l1ApiMsg_p = PNULL;
    //FAPI_rxULSCHIndication_st  *ulschDataInd_p = PNULL;
    //FAPI_ulDataPduIndication_st *ulDataPdu_p = PNULL;
    //UInt32                     l1ApiMsgSize = 0;  
/* SPR 609 changes start */    
    ulschDataQueueNode *uldataNode_p = PNULL;
    pduLen = raReq_p->rrcConReqLen + 1;
    
    start_p = ( UInt8 *) getMemFromPool (100, PNULL);
    if ( PNULL == start_p )
    {
        fprintf(stderr,"Not able to get memory for msg3 Data packet in fapiCreateAndSendMsg3\n");
        return; 
    }
    sendBuffer_p = start_p;
#if 0 
    l1ApiMsg_p = ( FAPI_l1ApiMsg_st *) start_p;
    sendBuffer_p = start_p; 

    l1ApiMsg_p->msgId = PHY_UL_RX_ULSCH_INDICATION;
    l1ApiMsg_p->lenVendorSpecific = 0;

    ulschDataInd_p = (FAPI_rxULSCHIndication_st *) &(l1ApiMsg_p->msgBody[0]);
    ulschDataInd_p->sfnsf = sendSfnSf;
    ulschDataInd_p->numOfPdu = 1;
    sendBuffer_p += (2*sizeof(UInt16)) + L1_PARTIAL_API_MSG_SIZE;

    ulDataPdu_p = ( FAPI_ulDataPduIndication_st *) 
                        &(ulschDataInd_p->ulDataPduInfo[0]);
    ulDataPdu_p->handle = 1;
    ulDataPdu_p->rnti = tcrnti;
    ulDataPdu_p->length = pduLen;
    ulDataPdu_p->dataOffset = sizeof(FAPI_ulDataPduIndication_st);
    ulDataPdu_p->timingAdvance = INVALID_TA_VALUE;
    ulDataPdu_p->ulCqi = 0;

    sendBuffer_p += ulDataPdu_p->dataOffset;
 
    if ( &(ulschDataInd_p->pduBuffer[0]) != sendBuffer_p )
    {
        fprintf(stderr,"2 address are not same\n");
        exit (0);
    }   
#endif
    prepareSduSubHeader(&sendBuffer_p, 0/*R1*/,
            0/*R2*/, 0/*E*/, 0/*CCCH lcId*/, 0/*F*/, 0/*length*/);
    

    prepareCCCHSDU(&sendBuffer_p, raReq_p);


    uldataNode_p = (ulschDataQueueNode *) 
                   getMemFromPool(sizeof(ulschDataQueueNode), PNULL);
    if ( uldataNode_p == PNULL )
    {
        fprintf(stderr,"Not able to get memory for ulschDataQueueNode in fapiCreateAndSendMsg3\n");
        return;
    }

    uldataNode_p->pdudata_p = start_p;
    uldataNode_p->sendSfnSf = sendSfnSf;
    uldataNode_p->SF = sendSfnSf & FAPI_SF_MASK;    
    uldataNode_p->SFN = (sendSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT;    
    uldataNode_p->rnti = tcrnti;
    uldataNode_p->qIndex = qIndex;
    uldataNode_p->pduLen = sendBuffer_p - start_p;
#if 0
    l1ApiMsg_p->msgLen = (sendBuffer_p - start_p) - l1ApiMsgSize;
    l1ApiMsgSize = (sendBuffer_p - start_p);
#endif
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,"prepareCCCHSDU called for rnti = %d uldataNode_p->pduLen = %d\n", tcrnti, uldataNode_p->pduLen);
#endif
    pushNode(&ulDataQueue[cellIndex][qIndex], &(uldataNode_p->ulDataAnchor) );

}
/****************************************************************************
 * Function Name  : fapiGetRntiType 
 * Inputs         : rnti value 
 * Outputs        :  
 * Returns        :  
 * Description    : This function will return the type of rnti 
 *                   
 ****************************************************************************/
FAPI_rntiType_en fapiGetRntiType(UInt16 rnti, UInt8 cellIndex)
{
    FAPI_rntiType_en rntiType = FAPI_OTHER_CRNTI;
    RNTIInfo *rntiInfo_p = PNULL;
     
    if ( rnti >= startRARNTI_g && rnti <=  endRARNTI_g[cellIndex])
          rntiType = FAPI_RA_RNTI;
    else if ( rnti == 0xFFFE ) 
          rntiType = FAPI_RA_RNTI_P_RNTI_SI_RNTI;
    else if ( rnti == 0xFFFF )
          rntiType = FAPI_SIRNTI;
    else if( ( rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti && 
               rnti <= cellConfigUeSim_g[cellIndex].endSpsCrnti ) )
    {
        rntiInfo_p = getRntiInfofromRNTIMap(rnti, cellIndex);//getDlDciConfigSpsInfoFromMap(rnti);
        if ( rntiInfo_p == PNULL )
        {
           fprintf(stderr,"no SPS RNTI Info present for received [rnti = %d]\n", rnti);
           return rntiType;
        }
        else
        {
           rntiType = FAPI_SPS_CRNTI;
        }
    }
    else if ( (rnti > endRARNTI_g[cellIndex]  &&  rnti <= MAX_CRNTI_RANGE) )
    {
          rntiInfo_p = getRntiInfofromRNTIMap(rnti, cellIndex);
          if ( rntiInfo_p == PNULL )
          {
              fprintf(stderr,"no RNTI Info present for received [rnti = %d]\n", rnti);
              return rntiType;
          }
          if ( rntiInfo_p->state == WAIT_CONTENTION_RESOLUTION)
              rntiType = FAPI_T_CRNTI;
          else 
              rntiType = FAPI_C_RNTI;
    }

    return rntiType;
}

/****************************************************************************
 * Function Name  : validateUlConfig 
 * Inputs         :  value of SFN and SF received from Peer MAC  
 * 
 * Returns        :  
 * Description    : This function will validate the UL Config received with 
 *                  current SFN SF running at phy, and returns TRUE or FALSE. 
 *                   
 ****************************************************************************/
//TA: NON_SS
inline UInt8 validateUlConfig( UInt16 recvSFN, UInt8 recvSF,
                                           UInt16 currentSFN, UInt8 currentSF) 
{
    UInt8 flag = TRUE;
#ifdef UE_SIM_ENABLE_PRINTF_LOGS

    if ( recvSFN == currentSFN)
    {
        if ( recvSF >= currentSF )
        {
            if ( (recvSF - currentSF) <= MAX_ULCONFIG_DELAY) 
            {
                flag = TRUE;    
            }
            else
            {
                fprintf(stderr,"validate 1  failure\n");
            }
        }
        else
        {
            fprintf(stderr,"validate 2  failure\n");

        }
    }
    else if ( recvSFN > currentSFN )
    {
        if ( (recvSFN - currentSFN) <= 1 && (recvSF < currentSF) )
        {
            if ( (MAX_SUBFRAME + recvSF - currentSF ) <= MAX_ULCONFIG_DELAY )
            {
                flag = TRUE;    
            }
            else
            {
                fprintf(stderr,"validate 3  failure\n");
            }

        }
        else
        {
            fprintf(stderr,"validate 4  failure\n");

        }
    }
    else if ( recvSFN < currentSFN ) 
    {
        if ( recvSFN == 0 && ( currentSFN == (MAX_SFN - 1) ))  
        {
            if( ( recvSF < currentSF )&& ( ( MAX_SUBFRAME + recvSF  - currentSF ) <= MAX_ULCONFIG_DELAY ))
            {
                flag = TRUE;    
            }
            else
            {
                fprintf(stderr,"validate 5  failure\n");

            }
        } 
        else
        {
            fprintf(stderr,"validate 6  failure\n");

        }
    }
    else
    {
        fprintf(stderr," should never come in this block \n");
    }
#endif
    return flag;
}
/****************************************************************************
 * Function Name  : fapiHandlePchConfigPdu 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
void  fapiHandlePchConfigPdu( UInt16 dciDlpduSize,
                            FAPI_pchPduConfigInfo_st *pchPdu_p,
                            fapiMsgIdStruct *msgIdArr_p, UInt16 *pduIndex_p,
							UInt8 cellIndex )
{
    UInt32 count = 0;
    if ( PNULL == pchPdu_p )
    {
        fprintf(stderr,"Error..!!! pchPdu recevied no data\n");
        return;
    }
    *pduIndex_p = MAC_PHY_CONVERT_16(pchPdu_p->pduIndex);
    msgIdArr_p[*pduIndex_p].pch.pchrnti = MAC_PHY_CONVERT_16(pchPdu_p->pRNTI);
    msgIdArr_p[*pduIndex_p].pch.pchPduLen = MAC_PHY_CONVERT_16(pchPdu_p->pchPduLen);
    msgIdArr_p[*pduIndex_p].pch.rntiType = \
		fapiGetRntiType(MAC_PHY_CONVERT_16(pchPdu_p->pRNTI), cellIndex);
    
    /* SPR#733 Changes Start */
    msgIdArr_p[*pduIndex_p].pchPduCount++;
    /* SPR#733 Changes End */
    while ( count <  msgIdArr_p[0].dciPduCount )
    { 
        if ( msgIdArr_p[0].dciConfig[count].rnti == msgIdArr_p[*pduIndex_p].pch.pchrnti)
        {
             msgIdArr_p[*pduIndex_p].pch.dciFormat = msgIdArr_p[0].dciConfig[count].dciFormat;
             break;
        }
        count++;
    } 
}
/****************************************************************************
 * Function Name  : fapiHandledlSCHConfigPdu 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
UInt8 fapiHandledlSCHConfigPdu (UInt16 dciDlpduSize,
                            FAPI_dlSCHConfigPDUInfo_st *dlschPdu_p,
                            fapiMsgIdStruct *msgIdArr_p,
                            UInt16 *pduIndex_p,UInt8 recvSF,
                            UInt8 cellIndex
/* SPR 20758 fix start */                            
#ifdef TDD_CONFIG
                            ,
                            Dci0HiPdu *dci0HiPdu_p
#endif
/* SPR 20758 fix end */                            
                            )
{
/* + SPR 11220 Changes */
    UInt8 txCellIndex = 0;
/* - SPR 11220 Changes */
    UInt32 count = 0,dlSCHPduCount = 0;
    UInt8 *PhyDlConfigRes_p =  PNULL;
    UInt32 PhyDlConfigRes_size = 0;
    /* SPR 20758 fix start */
#ifdef TDD_CONFIG
    ueContextForUplink *ueContextInfo_p = PNULL;
    ueContextForUplink *ulUeContextInfo_p = PNULL;
    ueContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(dlschPdu_p->rnti), cellIndex);
    UInt8  dciSendSF   = dci0HiPdu_p->dci0SF;
    UInt16 dciSendSFN  = dci0HiPdu_p->dci0SFN;
    UInt8 tb1Valid = TRUE;
    UInt8  dciQIndex   = dci0HiPdu_p->dciQIdx;
    ulUeContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(dlschPdu_p->rnti), cellIndex);

#endif
    /* SPR 20758 fix end */
    if ( PNULL == dlschPdu_p )
    {
        fprintf(stderr,"Error..!!! dlschPdu_p data is PNULL\n");
        return; 
    } 
    *pduIndex_p = MAC_PHY_CONVERT_16(dlschPdu_p->pduIndex);

    /* SPR#733 Changes Start */
     dlSCHPduCount =  msgIdArr_p[(*pduIndex_p)].dlSCHPduCount;
    /*!
      * \code
      * In SPS occasion case
      * 1. we will populates the message Array of dlSCHPdu values like Rnti, rntiType.
      * 2. set the dlSCHPduCount to msgIdArr_p[(*pduIndex_p)].dlSCHPduCount
      * \endcode
      * */
     msgIdArr_p[*pduIndex_p].dlSCHPdu.rnti = MAC_PHY_CONVERT_16(dlschPdu_p->rnti);
     /*FAPI_ERROR_INDICATION_CHANGES_START*/
     /* Send subframe error from phy in case of error in DLSCH Pdu*/
     if ((1 == phy_err_config_g[cellIndex])&&\
         ((globalTTITickCount_g >= phy_err_start_tti_g[cellIndex])&& \
         (globalTTITickCount_g <= phy_err_end_tti_g[cellIndex])) && (errorCount_g[cellIndex] == 0))
         {
         if (PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[cellIndex])
         {
             if ((FAPI_MSG_SUBFRAME_ERR == phy_err_error_type_g[cellIndex]) && (FAPI_DLSCH_PDU == phy_err_pdu_type_g[cellIndex]))
             {
                 phy_err_crnti_g[cellIndex] = (MAC_PHY_CONVERT_16(dlschPdu_p->rnti));
                 fapiSendErrorIndication(FAPI_MSG_SUBFRAME_ERR, PHY_DL_CONFIG_REQUEST,
                         0,0,&PhyDlConfigRes_p,&PhyDlConfigRes_size, cellIndex);

                 UInt8 errQIdx = recvSF + 1;
                 if( errQIdx >= MAX_SUBFRAME )
                 {
                     errQIdx -= MAX_SUBFRAME;
                 }
                 LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                         sizeof(PhyErrInd), PNULL );
                 if( PNULL == phyErrInd_p )
                 {
                     freeMemPool(PhyDlConfigRes_p);
                     PhyDlConfigRes_p = PNULL;
                     return;
                 }
                 else
                 {
                     phyErrInd_p->data_p = PhyDlConfigRes_p;
                     phyErrInd_p->dataSize = PhyDlConfigRes_size;

                     ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx, cellIndex );
                 }
                 errorCount_g[cellIndex]++;
                 return INVALID_RET_VAL;
             }
         }
     }
     /*FAPI_ERROR_INDICATION_CHANGES_END*/

/* + SPR 11220 Changes */
GET_RNTI_TO_CELL_INDEX((MAC_PHY_CONVERT_16(dlschPdu_p->rnti)), txCellIndex);
     //fprintf(stderr,"RNTI = %d\n",dlschPdu_p->rnti);
	 msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rntiType = \
		fapiGetRntiType(MAC_PHY_CONVERT_16(dlschPdu_p->rnti), txCellIndex);
/* - SPR 11220 Changes */
     if (FAPI_SPS_CRNTI ==  msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rntiType )
     {
         FAPI_dciConfig_st     *tempSPSDciInfo = NULL;
         if(NULL != (tempSPSDciInfo = getDlDciConfigSpsInfoFromMap(msgIdArr_p[*pduIndex_p].dlSCHPdu.rnti, cellIndex)))
         {
              msgIdArr_p[(*pduIndex_p)].dlSCHPdu.pduCount++;
              msgIdArr_p[*pduIndex_p].dlSCHPdu.dciFormat = tempSPSDciInfo->dciFormat;
              msgIdArr_p[*pduIndex_p].dlSCHPdu.tb1Valid = tempSPSDciInfo->tb1Valid;
              msgIdArr_p[*pduIndex_p].dlSCHPdu.tb2Valid = tempSPSDciInfo->tb2Valid;
              msgIdArr_p[*pduIndex_p].dlSCHPdu.rnti = MAC_PHY_CONVERT_16(dlschPdu_p->rnti);
              msgIdArr_p[*pduIndex_p].dlSCHPdu.dlschPduLen = MAC_PHY_CONVERT_16(dlschPdu_p->dlschPduLen);
	      msgIdArr_p[*pduIndex_p].dlSCHPdu.rntiType = \
			 fapiGetRntiType(MAC_PHY_CONVERT_16(dlschPdu_p->rnti), cellIndex);
              msgIdArr_p[*pduIndex_p].dlSCHPduCount++;
         }
        /* SPR 20758 fix start */

#ifdef TDD_CONFIG
        if ( ulUeContextInfo_p->ackNackMode == MULTIPLEXING)
        {

            static UInt8 ackNackFieldTB1 = FAPI_ACK_OR_NACK;
            static UInt8 ackNackFieldTB2 = FAPI_ACK_OR_NACK;
            UInt16 sendSfnSf = GENERATE_SUBFRAME_SFNSF(dciSendSFN, dciSendSF);

            fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                    &ackNackFieldTB1,&ackNackFieldTB2, cellIndex, cellIndex); // to be done 

            if ( ueContextInfo_p != PNULL )
            {
                if (!sendAckNack_g[cellIndex])
                {

                    updateDaiAndBuildDlAckNack( ueContextInfo_p,
                            dciSendSFN,
                            dciSendSF,
                            0xFF,
                            0,
                            dciQIndex,
                            tb1Valid,
                            FALSE,
                            /* + CA_TDD_HARQ_CHANGES */
                            recvSF,
                            cellIndex
                            /* + CA_TDD_HARQ_CHANGES */
                            );
                }



            }
        }
#endif
        
        /* SPR 20758 fix end */
     }

    //while ( count <= dlSCHPduCount )
    #if 0
        if ( msgIdArr_p[(*pduIndex_p)].dlSCHPduCount == 1 )
        {
            if ( (dlschPdu_p->rnti == msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rnti) )
            {
                msgIdArr_p[(*pduIndex_p)].dlSCHPdu.pduCount++;
            }
            else
            {
                fprintf(stderr,"rnti mismatch in DLSCH PDU %d!= %d\n",dlschPdu_p->rnti,msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rnti);
                return;
            }
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rnti = dlschPdu_p->rnti;
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.dlschPduLen = dlschPdu_p->dlschPduLen;
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rntiType = fapiGetRntiType(dlschPdu_p->rnti);
            msgIdArr_p[(*pduIndex_p)].dlSCHPduCount++;
        }
        else if ( msgIdArr_p[(*pduIndex_p)].dlSCHPduCount == 2 )
        {
            return;
        }
        else
        {
#endif
        else
        {
/* + SPR 11220 Changes */
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.pduCount++;
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rnti = MAC_PHY_CONVERT_16(dlschPdu_p->rnti);
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.dlschPduLen = MAC_PHY_CONVERT_16(dlschPdu_p->dlschPduLen);
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rntiType = \
				fapiGetRntiType(MAC_PHY_CONVERT_16(dlschPdu_p->rnti), txCellIndex);
            msgIdArr_p[(*pduIndex_p)].dlSCHPduCount++;
/* - SPR 11220 Changes */
        }
        //count++;
    
    /* SPR#733 Changes End */
    
    count = 0;
    while ( count < msgIdArr_p[0].dciPduCount )
    {

        if ( msgIdArr_p[0].dciConfig[count].rnti == msgIdArr_p[(*pduIndex_p)].dlSCHPdu.rnti )
        {
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.dciFormat = msgIdArr_p[0].dciConfig[count].dciFormat;
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.tb1Valid = msgIdArr_p[0].dciConfig[count].tb1Valid;
            msgIdArr_p[(*pduIndex_p)].dlSCHPdu.tb2Valid = msgIdArr_p[0].dciConfig[count].tb2Valid;
#if 0
            if ( (msgIdArr_p[(*pduIndex_p)].dlSCHPdu.pduCount == FAPI_MIMO_TB_COUNT) &&  
                   ( (FAPI_DL_DCI_FORMAT_2 != msgIdArr_p[(*pduIndex_p)].dlSCHPdu.dciFormat) || 
                    (FAPI_DL_DCI_FORMAT_2A != msgIdArr_p[(*pduIndex_p)].dlSCHPdu.dciFormat) ))
            {
                fprintf(stderr,"Error..!! dciFormat should be 2 or 2A\n");
                return;
            }
            break;
#endif
        }
        count++;   
    }
}

#ifdef UESIM_ENHANCEMENTS
/****************************************************************************
 * Function Name  : calculateNumOfRBs 
 * Inputs         : rbCoding, resAllocationType, cellIndex  
 * Outputs        : numOfRBsAllocatedInDL
 * Returns        : numOfRBsAllocatedInDL 
 * Description    : 
 ****************************************************************************/
UInt8 calculateNumOfRBs(UInt32 rbCoding, UInt8 resAllocationType, UInt8 cellIndex)
{
    UInt8 numOfRBGsAllocated = 0;
    UInt8 numOfRBsAllocatedInDL = 0, bitsToShift = 0;
    UInt32 setBits = 0;
    UInt8 rbInLastRBG = 0;
    UInt8 rbgCount = 0;
    rbgCount = ceil_wrapper( (UDouble32)cellConfigUeSim_g[cellIndex].dlAvailableRBs / cellConfigUeSim_g[cellIndex].rat0RbgSize);
    rbInLastRBG = cellConfigUeSim_g[cellIndex].rat0RbgSize - (rbgCount * cellConfigUeSim_g[cellIndex].rat0RbgSize - cellConfigUeSim_g[cellIndex].dlAvailableRBs);
    if(0 == resAllocationType)
    {
        numOfRBGsAllocated = getCount(rbCoding);
        numOfRBsAllocatedInDL = numOfRBGsAllocated * cellConfigUeSim_g[cellIndex].rat0RbgSize;
        if (rbCoding & ((UInt32) 1 >> (rbgCount - 1)))
        {
            numOfRBsAllocatedInDL = numOfRBsAllocatedInDL - cellConfigUeSim_g[cellIndex].rat0RbgSize + rbInLastRBG;
        }
        
    }
    else if(1 == resAllocationType)
    {
        setBits = ( rbCoding & cellConfigUeSim_g[cellIndex].rat1MaxRBsAllocated );
        numOfRBsAllocatedInDL = getCount(setBits);
    }
    return numOfRBsAllocatedInDL;
}

/****************************************************************************
 * Function Name  : updateDlRbInfo 
 * Inputs         : rbCoding, resAllocationType, cellIndex 
 * Outputs        : None
 * Returns        : None 
 * Description    : 
 ****************************************************************************/
void updateDlRbInfo(UInt32 rbCoding, UInt8 resAllocationType, UInt8 cellIndex) 
{
    UInt8 bitsToShift = 0, spanWidth = 0, z = 0;
    UInt8 reportedSubset = 0, reportedSpan = 0;
    UInt32 setBits = 0, tempBitMap = 0x0000, bitReported = 0, bitReported1 = 0;
    UInt8 reportedRBG = 0, reportedRB = 0, maxPRBInSubset = 0, rbgCount = 0;

    if(0 == resAllocationType)
    {
        tempBitMap = rbCoding;
        rbgCount = ceil_wrapper( (UDouble32)cellConfigUeSim_g[cellIndex].dlAvailableRBs / cellConfigUeSim_g[cellIndex].rat0RbgSize);
        reportedRBG =  (rbgCount - (FFS(tempBitMap))) ;
        if(0 == reportedRBG)
        {
            for(z = 0; z < cellConfigUeSim_g[cellIndex].rat0RbgSize; z++)
            {
                if((RB_CAN_BE_ALLOCATED__BUSY == dlRBInfo_g[cellIndex][z]) ||
                   (RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION == dlRBInfo_g[cellIndex][z]))
                {
                    ltePanic("RAT0, RBG = %d/RB = %d is already allocated\n",reportedRBG,z);
                }
                else
                {
                    dlRBInfo_g[cellIndex][z] = RB_CAN_BE_ALLOCATED__BUSY;
                }
            }
        }
        else
        {
            while(tempBitMap)
            {
                bitReported1 = (FFS(tempBitMap));
                reportedRBG =  (rbgCount - bitReported1) ;
                tempBitMap &= (~((UInt16)1 << (bitReported1 - 1)));
                reportedRB = (reportedRBG * cellConfigUeSim_g[cellIndex].rat0RbgSize); 
                for(z = reportedRB; z < reportedRB + cellConfigUeSim_g[cellIndex].rat0RbgSize; z++)
                {
                    if(reportedRB < cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                    {
                        if((RB_CAN_BE_ALLOCATED__BUSY == dlRBInfo_g[cellIndex][z]) ||
                           (RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION == dlRBInfo_g[cellIndex][z]))
                        {
                            ltePanic("RAT0, RBG = %d/RB = %d is already allocated\n",reportedRBG,z);
                        }
                        else
                        {
                            dlRBInfo_g[cellIndex][z] = RB_CAN_BE_ALLOCATED__BUSY;
                        }
                    }
                }
            }
        }
    }
    else if(1 == resAllocationType)
    {
        bitsToShift = getCount(cellConfigUeSim_g[cellIndex].rat1MaxRBsAllocated); 
        reportedSubset = ( (rbCoding & cellConfigUeSim_g[cellIndex].bitsMaskForSubsetCount) >> (bitsToShift + 1) );  
        reportedSpan = ( (rbCoding & cellConfigUeSim_g[cellIndex].bitsMaskForSpan) >> (bitsToShift) );
        maxPRBInSubset = calculateMaxPRB(reportedSubset, cellConfigUeSim_g[cellIndex].dlAvailableRBs, cellConfigUeSim_g[cellIndex].rat0RbgSize);
        spanWidth = maxPRBInSubset - bitsToShift;                  
        setBits = (rbCoding & cellConfigUeSim_g[cellIndex].rat1MaxRBsAllocated);
        tempBitMap = setBits;
        while(tempBitMap)
        {
            bitReported1 = (FFS(tempBitMap));
            bitReported = (bitsToShift - bitReported1);
            tempBitMap &= (~((UInt32)1 << (bitReported1 - 1)));
            if (0 == reportedSpan)
            {
                reportedRB = ( ((floor((bitReported + 0)/cellConfigUeSim_g[cellIndex].rat0RbgSize)) * 
                            (cellConfigUeSim_g[cellIndex].rat0RbgSize * cellConfigUeSim_g[cellIndex].rat0RbgSize)) + 
                        (reportedSubset * cellConfigUeSim_g[cellIndex].rat0RbgSize ) +
                        ((bitReported + 0) % cellConfigUeSim_g[cellIndex].rat0RbgSize) );

                if((RB_CAN_BE_ALLOCATED__BUSY == dlRBInfo_g[cellIndex][reportedRB]) ||
                   (RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION == dlRBInfo_g[cellIndex][reportedRB]))
                {
                    ltePanic("RAT1, RB = %d is already allocated\n",z);
                }
                else
                {
                    dlRBInfo_g[cellIndex][reportedRB] = RB_CAN_BE_ALLOCATED__BUSY;
                }
            }
            else
            {
                reportedRB = ( ((floor((bitReported + spanWidth)/cellConfigUeSim_g[cellIndex].rat0RbgSize)) * 
                            (reportedSubset * cellConfigUeSim_g[cellIndex].rat0RbgSize)) + 
                        (reportedSubset * cellConfigUeSim_g[cellIndex].rat0RbgSize ) +
                        ((bitReported + spanWidth) % cellConfigUeSim_g[cellIndex].rat0RbgSize) );

                if((RB_CAN_BE_ALLOCATED__BUSY == dlRBInfo_g[cellIndex][reportedRB]) ||
                   (RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION == dlRBInfo_g[cellIndex][reportedRB]))
                {
                    ltePanic("RAT1, RB = %d is already allocated\n",z);
                }
                else
                {
                    dlRBInfo_g[cellIndex][reportedRB] = RB_CAN_BE_ALLOCATED__BUSY;
                }
            }
        }
    }
}

/****************************************************************************
 * Function Name  : calculateAndUpdateRAT2Info 
 * Inputs         : rbCoding, cellIndex  
 * Outputs        : numOfRBsAllocatedInDL
 * Returns        : numOfRBsAllocatedInDL 
 * Description    : 
 ****************************************************************************/
UInt8 calculateAndUpdateRAT2Info(UInt32 rbCoding, UInt8 cellIndex)
{
    UInt8 rbStart = 0, rbStartIndicator = 0, z = 0;
    UInt8 numOfRBsAllocatedInDL = 0;

    numOfRBsAllocatedInDL = ((rbCoding / cellConfigUeSim_g[cellIndex].dlAvailableRBs) + 1);

    rbStartIndicator = (rbCoding % cellConfigUeSim_g[cellIndex].dlAvailableRBs);

    if ( (numOfRBsAllocatedInDL + rbStartIndicator) <= (cellConfigUeSim_g[cellIndex].dlAvailableRBs) )
    {
        rbStart = (rbCoding - (cellConfigUeSim_g[cellIndex].dlAvailableRBs * (numOfRBsAllocatedInDL - 1)));
    }
    else
    {
        numOfRBsAllocatedInDL = ((cellConfigUeSim_g[cellIndex].dlAvailableRBs + 2) - numOfRBsAllocatedInDL);
        rbStart = 
           (cellConfigUeSim_g[cellIndex].dlAvailableRBs * (cellConfigUeSim_g[cellIndex].dlAvailableRBs - numOfRBsAllocatedInDL + 1)) + (cellConfigUeSim_g[cellIndex].dlAvailableRBs - 1) - rbCoding;
           if(cellConfigUeSim_g[cellIndex].dlAvailableRBs < rbStart)
           {  
               rbStart = 0;
           }
        
    }

    for(z = rbStart; z < rbStart + numOfRBsAllocatedInDL; z++)
    {
        if((RB_CAN_BE_ALLOCATED__BUSY == dlRBInfo_g[cellIndex][z]) ||
           (RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION == dlRBInfo_g[cellIndex][z]))
        {
            /* SPR 15909 fix start */
            ltePanic("[%llu] In %s, RAT2, RB = %d is already allocated, rbStartIndicator = %d, numOfRBsAllocatedInDL = %d, rbCoding = %0x\n",
                    globalTTITickCount_g,__func__,z,rbStartIndicator,numOfRBsAllocatedInDL,rbCoding);
            /* SPR 15909 fix end */
        }
        else
        {
            dlRBInfo_g[cellIndex][z] = RB_CAN_BE_ALLOCATED__BUSY;
        }
    }
    return numOfRBsAllocatedInDL;
}

/****************************************************************************
 * Function Name  : updateSPSRAT2Info 
 * Inputs         : rbCoding, cellIndex   
 * Outputs        : 
 * Returns        :  
 * Description    : 
 ****************************************************************************/
UInt8 updateSPSRAT2Info(UInt32 rbCoding, UInt8 cellIndex)
{
    UInt8 rbStart = 0, rbStartIndicator = 0, z = 0;
    UInt8 numOfRBsAllocatedInDL = 0;

    numOfRBsAllocatedInDL = ((rbCoding / cellConfigUeSim_g[cellIndex].dlAvailableRBs) + 1);

    rbStartIndicator = (rbCoding % cellConfigUeSim_g[cellIndex].dlAvailableRBs);

    if ( (numOfRBsAllocatedInDL + rbStartIndicator) <= (cellConfigUeSim_g[cellIndex].dlAvailableRBs) )
    {
        rbStart = (rbCoding - (cellConfigUeSim_g[cellIndex].dlAvailableRBs * (numOfRBsAllocatedInDL - 1)));
    }
    else
    {
        numOfRBsAllocatedInDL = ((cellConfigUeSim_g[cellIndex].dlAvailableRBs + 2) - numOfRBsAllocatedInDL);
    }

    for(z = rbStart; z < rbStart + numOfRBsAllocatedInDL; z++)
    {
        if((RB_CAN_BE_ALLOCATED__BUSY == dlRBInfo_g[cellIndex][z]) ||
           (RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION == dlRBInfo_g[cellIndex][z]))
        {
            ltePanic("In %s, RAT2, RB = %d is already allocated\n",__func__,z);
        }
        else
        {
            dlRBInfo_g[z] = RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION;
        }
    }
    return numOfRBsAllocatedInDL;
}

/****************************************************************************
 * Function Name  : updateRAT2RBsinUL 
 * Inputs         : rbStart, numOfRB, cellIndex  
 * Outputs        : 
 * Returns        :  
 * Description    : 
 ****************************************************************************/
void updateRAT2RBsinUL(UInt8 rbStart, UInt8 numOfRB, UInt8 cellIndex)
{
    UInt8 z = 0;
    numOfRB -= 1;
    for(z = rbStart; z < rbStart + numOfRB; z++)
    {
        if((RB_CAN_BE_ALLOCATED__BUSY == ulRBInfo_g[cellIndex][z]) ||
           (RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION == ulRBInfo_g[cellIndex][z]))
        {
            /* SPR 15909 fix start */
            ltePanic("[%llu] In %s, RAT2, RB = %d , rbStart = %d, numOfRB = %d, is already allocated\n",
            globalTTITickCount_g,__func__,z,rbStart,numOfRB);
            /* SPR 15909 fix end */
        }
        else
        {
            ulRBInfo_g[cellIndex][z] = RB_CAN_BE_ALLOCATED__BUSY;
        }
    }
}
#endif

/****************************************************************************
 * Function Name  : fapiParseAndStoreDciDlConfigPdu 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
UInt8 fapiParseAndStoreDciDlConfigPdu( UInt16 dciDlpduSize,
                            FAPI_dciDLPduInfo_st *dciDlPdu_p,
                            fapiMsgIdStruct *msgIdArr_p,
                            UInt8 cellIndex
                            ,UInt8 recvSF
#ifdef TDD_CONFIG
                            ,
                            Dci0HiPdu *dci0HiPdu_p
#endif
                             )
{
    /* SPR 609 changes start */    
    UInt32 count = 0;
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    UInt32 i = 0;
#endif    
    /* SPR 609 changes end */
    UInt8 tb1Valid = TRUE;
#ifdef TDD_CONFIG    
    UInt8 tb2Valid = TRUE;
#else
    UInt8 tb2Valid = TRUE;
#endif   
    FAPI_dciFormat2_st *dciFormat2_p = PNULL;
    FAPI_dciFormat2A_st *dciFormat2A_p = PNULL;
    /* + TM7_8 Changes Start */
    FAPI_dciFormat2B_st *dciFormat2B_p = PNULL;
    /* - TM7_8 Changes End */
    ueContextForUplink *ueContextInfo_p = PNULL;
    UInt8 spsUeIndex = 0;
#ifdef UESIM_ENHANCEMENTS
    DLHARQProcess *harqProcess_p = PNULL;
    UInt32 rbCoding = 0x0000;
    UInt8 numOfRBsAllocatedInDL = 0;
    UInt16 rnti = 0;
    UInt8 harqProcessId =  255, rbStartIndicator = 0;
#endif   
    UInt8 *PhyDlConfigRes_p =  PNULL;
    UInt32 PhyDlConfigRes_size = 0;


    if ( PNULL == dciDlPdu_p )
    {
        fprintf(stderr,"Error!! DCI PDU recevied is NULL\n");
        return;
    }
    /*CLPC_CHG*/
    SInt8 tpcPUCCHInfoArr[4] = {-1, 0, 1, 3};
    DLUEContext *dlUeContext_p = PNULL;
#ifdef UESIM_ENHANCEMENTS
    rnti = (MAC_PHY_CONVERT_16(dciDlPdu_p->rnti));
    UInt8 tempSF = globalTTITickCount_g % 10;
#endif 
    /*Send subframe error from phy in case of error in DCI_DL pdu*/
    if ((1 == phy_err_config_g[cellIndex])&&\
            ((globalTTITickCount_g >= phy_err_start_tti_g[cellIndex]) &&\
             (globalTTITickCount_g <= phy_err_end_tti_g[cellIndex])) && (errorCount_g[cellIndex] == 0))
    {
        if (PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[cellIndex])
        {
            if ((FAPI_MSG_SUBFRAME_ERR == phy_err_error_type_g[cellIndex]) && (FAPI_DCI_DL_PDU == phy_err_pdu_type_g[cellIndex]))
            {
                phy_err_crnti_g[cellIndex] = (MAC_PHY_CONVERT_16(dciDlPdu_p->rnti));
                fapiSendErrorIndication(FAPI_MSG_SUBFRAME_ERR, PHY_DL_CONFIG_REQUEST, 
                        0,0,&PhyDlConfigRes_p,&PhyDlConfigRes_size,cellIndex);

                UInt8 errQIdx = recvSF + 1;
                if( errQIdx >= MAX_SUBFRAME )
                {
                    errQIdx -= MAX_SUBFRAME;
                }
                LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                        sizeof(PhyErrInd), PNULL );
                if( PNULL == phyErrInd_p )
                {
                    freeMemPool(PhyDlConfigRes_p);
                    PhyDlConfigRes_p = PNULL;
                    return 1 ;
                }
                else
                {
                    phyErrInd_p->data_p = PhyDlConfigRes_p;
                    phyErrInd_p->dataSize = PhyDlConfigRes_size;

                    ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx, cellIndex);
                }
                errorCount_g[cellIndex]++;
#ifdef TDD_CONFIG
                /* CA TDD Changes Start */
                msgSfDlConfigErr_g[cellIndex] = TRUE;
                /* CA TDD Changes End */
#elif FDD_CONFIG
                return INVALID_RET_VAL;
#endif
            }
        }
    }

    if (dciDlPdu_p->rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti && 
            dciDlPdu_p->rnti <=  cellConfigUeSim_g[cellIndex].endSpsCrnti)
    {
        /* Populate SPS-CRNTI map for first DCI PDU received for SPS-CRNTI */
        populateSpsCrnti(dciDlPdu_p->rnti, cellIndex);
        spsUeIndex = dciDlPdu_p->rnti - cellConfigUeSim_g[cellIndex].startSpsCrnti;
    }

    if((dciDlPdu_p->rnti == 0xFFFF) || (0xFFFE == dciDlPdu_p->rnti) )
    {
        lteWarning("Invalid RNTI value (0xFFFF)\n");
        return;
    }
    ueContextForUplink *ulUeContextInfo_p = PNULL;
    /* + SPS_TDD_Changes */
    if (!(dciDlPdu_p->rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti && dciDlPdu_p->rnti <=  cellConfigUeSim_g[cellIndex].endSpsCrnti))
    {
        dlUeContext_p = getDLUEContextFromRnti(MAC_PHY_CONVERT_16
                (dciDlPdu_p->rnti), cellIndex);
        UInt8 pCellIndex = 0xFF;
        GET_RNTI_TO_CELL_INDEX( 
                dciDlPdu_p->rnti, 
                pCellIndex);
        ulUeContextInfo_p = getUEContext(dciDlPdu_p->rnti, pCellIndex);
        if(dlUeContext_p == PNULL)
        {
            lteWarning("Dl Ue context is NULL\n");
            /* SPR 12832 FIX start */
            /*code added to prevent return in case,DCI for sCell data is received*/
            if(pCellIndex != cellIndex)
            {
                if(!(ulUeContextInfo_p && (ulUeContextInfo_p->carrierAggrConfig.scellCount > 0)))
                {
                    return;
                }
            }
            else
            {
                return;
            }
        }
    }
    /* - SPS_TDD_Changes */
#ifdef FDD_CONFIG
#endif

    /* + SPR 14177 Changes */
#ifdef TDD_CONFIG        
#if 0        
    else if(ulUeContextInfo_p->carrierAggrConfig.scellCount == 0)
    {
        if(pCellIndex != cellIndex)
        {
            /* No need to handle Scell Data if scell doesn't exist */
            return;
        }
    }
#endif        
#endif        
    /* - SPR 14177 Changes */
    /* SPR 12832 FIX end */
    /*CLPC_CHG*/
    FAPI_ulPdcchOrderNode_st *ulPdcchOrderNode_p = PNULL;
#ifdef TDD_CONFIG    
    /* DCI parsing */
    UInt16 dciSendSFN  = dci0HiPdu_p->dci0SFN;
    UInt8  dciSendSF   = dci0HiPdu_p->dci0SF;
    UInt8  dciQIndex   = dci0HiPdu_p->dciQIdx;
    UInt16 hiSendSFN  = dci0HiPdu_p->hiSFN;
    UInt8  hiSendSF   = dci0HiPdu_p->hiSF;
    UInt8  hiQIndex   = dci0HiPdu_p->hiQIdx;
    UInt8  dciFormat   = dciDlPdu_p->dciFormat;
    UInt8  isConsistent = 0; 
    UInt8  dai          = 0;
#endif   

#ifdef UESIM_ENHANCEMENTS
    UInt8 cceIndex = dciDlPdu_p->cceIndex;
#endif    
    switch ( dciDlPdu_p->dciFormat )
    {
        case FAPI_DL_DCI_FORMAT_1:
#ifdef TDD_CONFIG    
        dai = ((FAPI_dciFormat1_st *)&dciDlPdu_p->dciPdu[0])->dlAssignmentIndex;
#endif   
        tb2Valid = FALSE;

#ifdef UESIM_ENHANCEMENTS
        if( (0xFFFF != rnti) && (recvSF == tempSF) &&
                (((FAPI_dciFormat1_st *)&dciDlPdu_p->dciPdu[0])->rbCoding) )
        {
            numOfRBsAllocatedInDL = calculateNumOfRBs((((FAPI_dciFormat1_st *)&dciDlPdu_p->dciPdu[0])->rbCoding),
                    (((FAPI_dciFormat1_st *)&dciDlPdu_p->dciPdu[0])->resAllocationType),
                    cellIndex); 

            harqProcessId = ((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->harqProcessNum;
            harqProcess_p = &dlUeContext_p->harqProcess[harqProcessId];
            dlUeContext_p->pucchResource[((recvSF+4)%10)] = cellConfigUeSim_g[cellIndex].n1PUCCH_AN + cceIndex;
            if(0 == ((FAPI_dciFormat1_st *)&dciDlPdu_p->dciPdu[0])->redundancyVersion_1)
            {
                harqProcess_p->harqProcessId = harqProcessId;
                harqProcess_p->numOfRBsAllocatedForTBOne = numOfRBsAllocatedInDL;
            }
            else
            {
                if(harqProcessId == harqProcess_p->harqProcessId)
                {
                    if(numOfRBsAllocatedInDL != harqProcess_p->numOfRBsAllocatedForTBOne)
                    {
                        ltePanic("In DL HARQ retransmission, same number of RB's = %d are not given to UE \
                                as in initial transmission = %d",harqProcess_p->numOfRBsAllocatedForTBOne,numOfRBsAllocatedInDL);
                    }
                }
            }
        }           
#endif   
        /*CLPC_CHG*/
        if(CLPC_PUCCH_ENABLE)
        {
            dlUeContext_p->tpcPUCCH =  
                tpcPUCCHInfoArr[((FAPI_dciFormat1_st *)&dciDlPdu_p->dciPdu[0])->tpc];
            ackNackCorrectionForTpc(dlUeContext_p, cellIndex);
        }
        /*CLPC_CHG*/
        break;
        case FAPI_DL_DCI_FORMAT_1A:
#ifdef TDD_CONFIG    
        dai = ((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->dlAssignmentIndex;
#endif   
        tb2Valid = FALSE;
#ifdef UESIM_ENHANCEMENTS
        if( (0xFFFF != rnti) && (0 == (((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->vRBAssignmentFlag)) &&
                (recvSF == tempSF) && (!(dciDlPdu_p->rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti && dciDlPdu_p->rnti <=  cellConfigUeSim_g[cellIndex].endSpsCrnti)) ) 
        {
            rbCoding = (((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->rbCoding);
            numOfRBsAllocatedInDL = ( (rbCoding / cellConfigUeSim_g[cellIndex].dlAvailableRBs) + 1);

            rbStartIndicator = (rbCoding % cellConfigUeSim_g[cellIndex].dlAvailableRBs);

            if ( (numOfRBsAllocatedInDL + rbStartIndicator) > (cellConfigUeSim_g[cellIndex].dlAvailableRBs) )
            {
                numOfRBsAllocatedInDL = ((cellConfigUeSim_g[cellIndex].dlAvailableRBs + 2) - numOfRBsAllocatedInDL);
            }

            harqProcessId = ((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->harqProcessNum;
            harqProcess_p = &dlUeContext_p->harqProcess[harqProcessId];
            dlUeContext_p->pucchResource[((recvSF+4)%10)] = cellConfigUeSim_g[cellIndex].n1PUCCH_AN + cceIndex;
            if(0 == ((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->redundancyVersion_1)
            {
                harqProcess_p->harqProcessId = harqProcessId;
                harqProcess_p->numOfRBsAllocatedForTBOne = numOfRBsAllocatedInDL;
            }
            else
            {
                if(harqProcessId == harqProcess_p->harqProcessId)
                {
                    if(numOfRBsAllocatedInDL != harqProcess_p->numOfRBsAllocatedForTBOne)
                    {
                        ltePanic("In DL HARQ retransmission, same number of RB's = %d are not given to UE \
                                as in initial transmission = %d",harqProcess_p->numOfRBsAllocatedForTBOne,numOfRBsAllocatedInDL);
                    }
                }
            }
        }           
#endif   
        /*CLPC_CHG*/
        if(CLPC_PUCCH_ENABLE)
        {
            dlUeContext_p->tpcPUCCH =  
                tpcPUCCHInfoArr[((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->tpc];
            ackNackCorrectionForTpc(dlUeContext_p, cellIndex);
        }
        /*CLPC_CHG*/
        if (1 == (((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->        
                    allocatePRACHFlag))
        { 
#ifndef ENABLE_TEST_MAC_RLF 

            if (PNULL == (ueContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(dciDlPdu_p->rnti), cellIndex)))
            {
                fprintf (stderr, "PDCCH_ORDER is received for UE having" 
                        "crnti =%d but Context Doesnot exist for this UE\n",MAC_PHY_CONVERT_16(dciDlPdu_p->rnti));
                return;
            }   
            ulPdcchOrderNode_p = (FAPI_ulPdcchOrderNode_st *)
                getMemFromPool(sizeof(FAPI_ulPdcchOrderNode_st), PNULL); 
            if (ulPdcchOrderNode_p == PNULL)
            {
                fprintf (stderr, "Unable to get Mem for"  
                        "FAPI_ulPdcchOrderNode_st Node\n");
                return;
            }
            ulPdcchOrderNode_p->crnti = MAC_PHY_CONVERT_16(dciDlPdu_p->rnti);
            ulPdcchOrderNode_p->preambleIdx =  
                ((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->preambleIndex;
            /* SPR 12148 start */                
            pushNode(&pdcchOrderQueue_g[cellIndex],&(ulPdcchOrderNode_p->pdcchOrderNodeAnchor)); 
            /* SPR 12148 end */                
#endif
        }
        FAPI_rntiType_en rntiType;
        RNTIInfo *rntiInfo_p = NULL;
        rntiType = fapiGetRntiType (MAC_PHY_CONVERT_16(dciDlPdu_p->rnti), cellIndex);
        //rntiInfo_p = getDlDciConfigSpsInfoFromMap(MAC_PHY_CONVERT_16(dciDlPdu_p->rnti));
        rntiInfo_p = getRntiInfofromRNTIMap(MAC_PHY_CONVERT_16(dciDlPdu_p->rnti), cellIndex);
        ueContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(dciDlPdu_p->rnti), cellIndex);
        //fprintf(stderr,"DCI RNTI = %d RNTI TYPE = %d \n",dciDlPdu_p->rnti,rntiType);
        if ((rntiType == FAPI_SPS_CRNTI))
        {
            if ( ueContextInfo_p != PNULL )
            {
#ifdef UESIM_ENHANCEMENTS
                rbCoding = (((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->rbCoding);
                updateSPSRAT2Info(rbCoding, cellIndex);
#endif
                msgIdArr_p[0].dciPduCount++;
                //spsUeIndex = msgIdArr_p[0].dciPduCount - 1;
                dlDciConfigSPS_g[spsUeIndex].dciFormat = dciDlPdu_p->dciFormat;
                dlDciConfigSPS_g[spsUeIndex].rnti = MAC_PHY_CONVERT_16(dciDlPdu_p->rnti);
                dlDciConfigSPS_g[spsUeIndex].tb1Valid = tb1Valid;
                dlDciConfigSPS_g[spsUeIndex].tb2Valid = tb2Valid;
                count = msgIdArr_p[0].dciPduCount - 1;
                msgIdArr_p[0].dciConfig[count].dciFormat = dciDlPdu_p->dciFormat;
                msgIdArr_p[0].dciConfig[count].rnti = MAC_PHY_CONVERT_16(dciDlPdu_p->rnti);
                msgIdArr_p[0].dciConfig[count].tb1Valid = tb1Valid;
                msgIdArr_p[0].dciConfig[count].tb2Valid = tb2Valid;
                /* Following piece of code is for deactivation
                 * when DL-SCH and data is not there on SPS-
                 * CRNTI and only DCI PDU is received */
                if (0x1F == ((FAPI_dciFormat1A_st *)&dciDlPdu_p->dciPdu[0])->mcs_1)
                {
                    UInt8 recvSF = msgIdArr_p[0].recvSfnSf & FAPI_SF_MASK;
                    UInt16 recvSFN = msgIdArr_p[0].recvSfnSf & FAPI_SFN_MASK;
                    recvSFN >>= FAPI_SFN_VALUE_SHIFT; 
                    /* + SPS_TDD_Changes */
                    static UInt8 ackNackFieldTB1 = FAPI_ACK_OR_NACK;
                    static UInt8 ackNackFieldTB2 = FAPI_ACK_OR_NACK;
#ifdef FDD_CONFIG
                    UInt8 qIndex =  recvSF + 4  + PEER_MAC_DELAY ; 
                    if (qIndex >= MAX_SUBFRAME)
                    {
                        qIndex -= MAX_SUBFRAME;
                    }
                    recvSF += 4;
                    if ( recvSF >= MAX_SUBFRAME )
                    {
                        recvSF -= MAX_SUBFRAME;
                        recvSFN++ ;
                        if ( MAX_SFN == recvSFN )
                        {
                            recvSFN = 0;
                        }
                    }
                    UInt16 sendSfnSf = ( (recvSFN  & 0x0FFF) << 
                            FAPI_SFN_VALUE_SHIFT ) | 
                        ( recvSF & 0x000F);
                    /* SPR 8993 changes start */
                    fapiCheckHarq(TRUE, IstTB_VALID_2ndTB_INVALID, 
                            /* SPR 8993 changes end */
                            &ackNackFieldTB1, &ackNackFieldTB2, 
                            msgIdArr_p[0].dciConfig[count].rnti, cellIndex);
                    /* + CA_TDD_HARQ_CHANGES */    
                    fapiSendHarqIndication(TRUE,
                            msgIdArr_p[0].dciConfig[count].rnti, 
                            qIndex, sendSfnSf,&ackNackFieldTB1,
                            /* - CA_TDD_HARQ_CHANGES */    
                            &ackNackFieldTB2, cellIndex);
#elif TDD_CONFIG
                    UInt16 sendSfnSf =  GENERATE_SUBFRAME_SFNSF(dciSendSFN, dciSendSF);   
                    /* + SPR 14001 Changes */
                    fapiCheckTddHarq(sendSfnSf, msgIdArr_p[0].dciConfig[count].rnti,
                            &ackNackFieldTB1,&ackNackFieldTB2, cellIndex, cellIndex);
                    /* - SPR 14001 Changes */
                    if(!sendAckNack_g[cellIndex])
                    {   
                        updateDaiAndBuildDlAckNack( ueContextInfo_p, 
                                dciSendSFN,
                                dciSendSF,
                                dai, 
                                dciFormat,
                                dciQIndex,
                                tb1Valid,                   
                                tb2Valid,
                                /* + CA_TDD_HARQ_CHANGES */
                                recvSF,
                                cellIndex
                                /* + CA_TDD_HARQ_CHANGES */
                                );
                }
                    /* send HARQ Indication */
                    //SPS_TDD_FIX
                    /*sendDlAckNack( sendSfnSf,
                      msgIdArr_p[0].dciConfig[count].rnti,
                      dciQIndex
                      );*/
#endif
                    /* - SPS_TDD_Changes */
            }
            }
        }
        else
        {
            msgIdArr_p[0].dciPduCount++;
            count = msgIdArr_p[0].dciPduCount - 1;
            msgIdArr_p[0].dciConfig[count].dciFormat = dciDlPdu_p->dciFormat;
            msgIdArr_p[0].dciConfig[count].rnti = MAC_PHY_CONVERT_16(dciDlPdu_p->rnti);
            msgIdArr_p[0].dciConfig[count].tb1Valid = tb1Valid;
            msgIdArr_p[0].dciConfig[count].tb2Valid = tb2Valid;
        }
        break;
        case FAPI_DL_DCI_FORMAT_1B:
#ifdef TDD_CONFIG    
        dai = ((FAPI_dciFormat1B_st *)&dciDlPdu_p->dciPdu[0])->dlAssignmentIndex;
#endif   
        tb2Valid = FALSE;
        break;
        case FAPI_DL_DCI_FORMAT_1C:
#ifdef TDD_CONFIG    
        //dai = ((FAPI_dciFormat1C_st *)&dciDlPdu_p->dciPdu[0])->dlAssignmentIndex;
#endif   
        tb2Valid = FALSE;
        break;
        case FAPI_DL_DCI_FORMAT_1D:
#ifdef TDD_CONFIG    
        dai = ((FAPI_dciFormat1D_st *)&dciDlPdu_p->dciPdu[0])->dlAssignmentIndex;
#endif   
        tb2Valid = FALSE;
        break;
        case FAPI_DL_DCI_FORMAT_2: 
#ifdef TDD_CONFIG    
        dai = ((FAPI_dciFormat2_st *)&dciDlPdu_p->dciPdu[0])->dlAssignmentIndex;
#endif   
        dciFormat2_p = (FAPI_dciFormat2_st *)& (dciDlPdu_p->dciPdu[0]);
        if ( dciFormat2_p->mcs_1 == 0 && 
                dciFormat2_p->redundancyVersion_1 == 1)
        {
            tb1Valid = FALSE;
        }
        else if ( dciFormat2_p->mcs_2 == 0 && 
                dciFormat2_p->redundancyVersion_2 == 1)
        {
            tb2Valid = FALSE;
        } 

#ifdef UESIM_ENHANCEMENTS
        if( (0xFFFF != rnti) && (recvSF == tempSF) &&
                (((FAPI_dciFormat2_st *)&dciDlPdu_p->dciPdu[0])->rbCoding) )
        {
            numOfRBsAllocatedInDL = calculateNumOfRBs((((FAPI_dciFormat2_st *)&dciDlPdu_p->dciPdu[0])->rbCoding),
                    (((FAPI_dciFormat2_st *)&dciDlPdu_p->dciPdu[0])->resAllocationType),
                    cellIndex); 

            harqProcessId = ((FAPI_dciFormat2_st *)&dciDlPdu_p->dciPdu[0])->harqProcessNum;
            harqProcess_p = &dlUeContext_p->harqProcess[harqProcessId];
            dlUeContext_p->pucchResource[((recvSF+4)%10)] = cellConfigUeSim_g[cellIndex].n1PUCCH_AN + cceIndex;
            if(tb1Valid)  
            {
                if(0 == ((FAPI_dciFormat2_st *)&dciDlPdu_p->dciPdu[0])->redundancyVersion_1)
                {
                    harqProcess_p->harqProcessId = harqProcessId;
                    harqProcess_p->numOfRBsAllocatedForTBOne = numOfRBsAllocatedInDL;
                }
                else
                {
                    if(harqProcessId == harqProcess_p->harqProcessId)
                    {
                        if(numOfRBsAllocatedInDL != harqProcess_p->numOfRBsAllocatedForTBOne)
                        {
                            ltePanic("In DL HARQ retransmission, same number of RB's = %d are not given to UE \
                                    as in initial transmission = %d",harqProcess_p->numOfRBsAllocatedForTBOne,numOfRBsAllocatedInDL);
                        }
                    }
                }
            }

            if(tb2Valid)  
            {
                if(0 == ((FAPI_dciFormat2_st *)&dciDlPdu_p->dciPdu[0])->redundancyVersion_2)
                {
                    harqProcess_p->harqProcessId = harqProcessId;
                    harqProcess_p->numOfRBsAllocatedForTBTwo = numOfRBsAllocatedInDL;
                }
                else
                {
                    if(harqProcessId == harqProcess_p->harqProcessId)
                    {
                        if(numOfRBsAllocatedInDL != harqProcess_p->numOfRBsAllocatedForTBTwo)
                        {
                            ltePanic("In DL HARQ retransmission, same number of RB's = %d are not given to UE \
                                    as in initial transmission = %d",harqProcess_p->numOfRBsAllocatedForTBOne,numOfRBsAllocatedInDL);
                        }
                    }
                }
            }
        }           
#endif   

        /*CLPC_CHG*/
        if(CLPC_PUCCH_ENABLE)
        {
            dlUeContext_p->tpcPUCCH =  
                tpcPUCCHInfoArr[((FAPI_dciFormat2_st *)&dciDlPdu_p->dciPdu[0])->tpc];
            ackNackCorrectionForTpc(dlUeContext_p, cellIndex);
        }
        /*CLPC_CHG*/
        break; 
        case FAPI_DL_DCI_FORMAT_2A:
#ifdef TDD_CONFIG    
        dai = ((FAPI_dciFormat2A_st *)&dciDlPdu_p->dciPdu[0])->dlAssignmentIndex;
#endif   
        dciFormat2A_p = (FAPI_dciFormat2A_st *)& (dciDlPdu_p->dciPdu[0]); 
        if ( dciFormat2A_p->mcs_1 == 0 && 
                dciFormat2A_p->redundancyVersion_1 == 1)
        {
            tb1Valid = FALSE;
        }
        else if ( dciFormat2A_p->mcs_2 == 0 && 
                dciFormat2A_p->redundancyVersion_2 == 1)
        {
            tb2Valid = FALSE;
        } 
#ifdef UESIM_ENHANCEMENTS
        if( (0xFFFF != rnti) && (recvSF == tempSF) &&
                (((FAPI_dciFormat2A_st *)&dciDlPdu_p->dciPdu[0])->rbCoding) )
        {
            numOfRBsAllocatedInDL = calculateNumOfRBs((((FAPI_dciFormat2A_st *)&dciDlPdu_p->dciPdu[0])->rbCoding),
                    (((FAPI_dciFormat2A_st *)&dciDlPdu_p->dciPdu[0])->resAllocationType),
                    cellIndex); 

            harqProcessId = ((FAPI_dciFormat2A_st *)&dciDlPdu_p->dciPdu[0])->harqProcessNum;
            harqProcess_p = &dlUeContext_p->harqProcess[harqProcessId];
            dlUeContext_p->pucchResource[((recvSF+4)%10)] = cellConfigUeSim_g[cellIndex].n1PUCCH_AN + cceIndex;
            if(tb1Valid)  
            {
                if(0 == ((FAPI_dciFormat2A_st *)&dciDlPdu_p->dciPdu[0])->redundancyVersion_1)
                {
                    harqProcess_p->harqProcessId = harqProcessId;
                    harqProcess_p->numOfRBsAllocatedForTBOne = numOfRBsAllocatedInDL;
                }
                else
                {
                    if(harqProcessId == harqProcess_p->harqProcessId)
                    {
                        if(numOfRBsAllocatedInDL != harqProcess_p->numOfRBsAllocatedForTBOne)
                        {
                            ltePanic("In DL HARQ retransmission, same number of RB's = %d are not given to UE \
                                    as in initial transmission = %d",harqProcess_p->numOfRBsAllocatedForTBOne,numOfRBsAllocatedInDL);
                        }
                    }
                }
            }

            if(tb2Valid)  
            {
                if(0 == ((FAPI_dciFormat2A_st *)&dciDlPdu_p->dciPdu[0])->redundancyVersion_2)
                {
                    harqProcess_p->harqProcessId = harqProcessId;
                    harqProcess_p->numOfRBsAllocatedForTBTwo = numOfRBsAllocatedInDL;
                }
                else
                {
                    if(harqProcessId == harqProcess_p->harqProcessId)
                    {
                        if(numOfRBsAllocatedInDL != harqProcess_p->numOfRBsAllocatedForTBTwo)
                        {
                            ltePanic("In DL HARQ retransmission, same number of RB's = %d are not given to UE \
                                    as in initial transmission = %d",harqProcess_p->numOfRBsAllocatedForTBOne,numOfRBsAllocatedInDL);
                        }
                    }
                }
            }
        }           
#endif

        /*CLPC_CHG*/
        if(CLPC_PUCCH_ENABLE)
        {
            dlUeContext_p->tpcPUCCH =  
                tpcPUCCHInfoArr[((FAPI_dciFormat2A_st *)&dciDlPdu_p->dciPdu[0])->tpc];
            ackNackCorrectionForTpc(dlUeContext_p, cellIndex);
        }
        /*CLPC_CHG*/
        break;
        /* + TM7_8 Changes Start */
        case FAPI_DL_DCI_FORMAT_2B: 
#ifdef TDD_CONFIG    
        dai = ((FAPI_dciFormat2B_st *)&dciDlPdu_p->dciPdu[0])->dlAssignmentIndex;
#endif   
        dciFormat2B_p = (FAPI_dciFormat2B_st *)& (dciDlPdu_p->dciPdu[0]);
        if ( dciFormat2B_p->mcs_1 == 0 && 
                dciFormat2B_p->redundancyVersion_1 == 1)
        {
            tb1Valid = FALSE;
        }
        else if ( dciFormat2B_p->mcs_2 == 0 && 
                dciFormat2B_p->redundancyVersion_2 == 1)
        {
            tb2Valid = FALSE;
        } 
        /*CLPC_CHG*/
        if(CLPC_PUCCH_ENABLE)
        {
            dlUeContext_p->tpcPUCCH =  
                tpcPUCCHInfoArr[((FAPI_dciFormat2B_st *)&dciDlPdu_p->dciPdu[0])->tpc];
            ackNackCorrectionForTpc(dlUeContext_p, cellIndex);
        }
        /*CLPC_CHG*/
        break; 
        /* - TM7_8 Changes End */
//pb_todo
#if 1
#endif
        default:
        fprintf(stderr,"Error!! unsupported DCI DL CONFIG PDU %d received \n", dciDlPdu_p->dciFormat);
        return; 
    }
#ifdef TDD_CONFIG  
#if 1
    FAPI_rntiType_en rntiType;
    RNTIInfo *rntiInfo_p = NULL;
    //ueContextForUplink *ueContextInfo_p = PNULL; 

    rntiType = fapiGetRntiType (MAC_PHY_CONVERT_16(dciDlPdu_p->rnti), cellIndex);
    rntiInfo_p = getRntiInfofromRNTIMap(MAC_PHY_CONVERT_16(dciDlPdu_p->rnti));

    //    fprintf(stderr, " Received DCI [%x] SFN_g[%d] SF_g[%d] \n");

    ueContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(dciDlPdu_p->rnti), cellIndex);
    if (((rntiType == FAPI_C_RNTI) && (rntiInfo_p->state != WAIT_FOR_DL_CCCH_MSG))&&
            ( ueContextInfo_p != PNULL ))
    {
        if(!sendAckNack_g[cellIndex] || sig_cnt[cellIndex] <= signalling_ack_nack_g[cellIndex])
        {   
            updateDaiAndBuildDlAckNack( ueContextInfo_p, 
                    dciSendSFN,
                    dciSendSF,
                    dai, 
                    dciFormat,
                    dciQIndex,
                    tb1Valid,
                    tb2Valid,
                    /* + CA_TDD_HARQ_CHANGES */
                    recvSF,
                    cellIndex
                    /* - CA_TDD_HARQ_CHANGES */
                    );
        }
    }
    else
    {
        //  fprintf(stderr, "\n dci [%d] rntiType [%d] Sending DL Ack from sendDlAckNack dai [%d]\n", dciFormat, rntiType, dai);
    }
#endif    
#endif

    msgIdArr_p[0].dciPduCount++;
    count = msgIdArr_p[0].dciPduCount - 1;
    msgIdArr_p[0].dciConfig[count].dciFormat = dciDlPdu_p->dciFormat; 
    msgIdArr_p[0].dciConfig[count].rnti = MAC_PHY_CONVERT_16(dciDlPdu_p->rnti);
    msgIdArr_p[0].dciConfig[count].tb1Valid = tb1Valid;
    msgIdArr_p[0].dciConfig[count].tb2Valid = tb2Valid;
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    /* actually it should loop through MAX_MSG_ID */
    for ( i = 0; i < FAPI_MAX_DCI_PDU; i++ )
    {
        if ( (msgIdArr_p[i].dlSCHPduCount) ) 
        {
            count = 0;
            while ( count < msgIdArr_p[0].dciPduCount )
            {
                if ( msgIdArr_p[i].dlSCHPdu.rnti == msgIdArr_p[0].dciConfig[count].rnti )
                {
                    msgIdArr_p[i].dlSCHPdu.dciFormat = msgIdArr_p[0].dciConfig[count].dciFormat;
                    msgIdArr_p[i].dlSCHPdu.tb1Valid = msgIdArr_p[0].dciConfig[count].tb1Valid;
                    msgIdArr_p[i].dlSCHPdu.tb2Valid = msgIdArr_p[0].dciConfig[count].tb2Valid;
#if 0
                    if ( (msgIdArr_p[i].dlSCHPdu.pduCount == FAPI_MIMO_TB_COUNT) && 
                            ( (FAPI_DL_DCI_FORMAT_2 == msgIdArr_p[i].dlSCHPdu.dciFormat) || 
                              (FAPI_DL_DCI_FORMAT_2A == msgIdArr_p[i].dlSCHPdu.dciFormat) ) )
                    {
                        fprintf(stderr,"Error..!! dciFormat should be 2 or 2A\n");
                        return;
                    }
#endif
                    break;
                } 
                count++;
            }
        }
        else if ( msgIdArr_p[i].pchPduCount )
        {
            count = 0;
            while ( count < msgIdArr_p[0].dciPduCount )
            {
                if ( msgIdArr_p[i].pch.pchrnti == msgIdArr_p[0].dciConfig[count].rnti )
                {
                    msgIdArr_p[i].pch.dciFormat = msgIdArr_p[0].dciConfig[count].dciFormat;
                    break;
                }
                count++;
            }  
        }
    }
#endif
}

/*CLPC_CHG*/
/****************************************************************************
 * Function Name  :  validateAckNackRange 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
static void validateAckNackRange(SInt16 *ackNackVal)
{
    if(*ackNackVal < 0)
    {
        *ackNackVal = 0;
    }
    else if(*ackNackVal > 100)
    {
        *ackNackVal = 100;
    }
}


/****************************************************************************
 * Function Name  : ackNackCorrectionForTpc 
 * Inputs         : DLUEContext pointer  
 *                  cellIndex 
 * Outputs        : None
 * Returns        : void 
 * Description    : 
 ****************************************************************************/
static void ackNackCorrectionForTpc(DLUEContext *dlUeContext_p, UInt8 cellIndex)
{
    dlUeContext_p->tpcAckNackContext.perUnsureTb1UE -=
        (STEP_UP_UNSURE * dlUeContext_p->tpcPUCCH);
    validateAckNackRange((SInt16 *)&dlUeContext_p->tpcAckNackContext.perUnsureTb1UE);
#ifdef PHR_TESTING
    fprintf(stderr,"perUnsureTb1UE=%d\n",dlUeContext_p->tpcAckNackContext.perUnsureTb1UE);
#endif

    dlUeContext_p->tpcAckNackContext.perUnsureTb2UE -=
        (STEP_UP_UNSURE * dlUeContext_p->tpcPUCCH);
    validateAckNackRange((SInt16 *)&dlUeContext_p->tpcAckNackContext.perUnsureTb2UE);
#ifdef PHR_TESTING
    fprintf(stderr,"perUnsureTb2UE=%d\n",dlUeContext_p->tpcAckNackContext.perUnsureTb2UE);
#endif

    dlUeContext_p->tpcAckNackContext.perSureTb1UE = \
                                                    100 - dlUeContext_p->tpcAckNackContext.perUnsureTb1UE;
#ifdef PHR_TESTING
    fprintf(stderr,"perSureTb1UE=%d\n",dlUeContext_p->tpcAckNackContext.perSureTb1UE);
#endif

    dlUeContext_p->tpcAckNackContext.perSureTb2UE = \
                                                    100 - dlUeContext_p->tpcAckNackContext.perUnsureTb2UE;
#ifdef PHR_TESTING
    fprintf(stderr,"perSureTb2UE=%d\n",dlUeContext_p->tpcAckNackContext.perSureTb2UE);
#endif

    dlUeContext_p->tpcAckNackContext.perAckTb1UE = 
        (dlUeContext_p->tpcAckNackContext.perSureTb1UE * 
         perAckTb1_g[cellIndex])/100;
    validateAckNackRange((SInt16 *)&dlUeContext_p->tpcAckNackContext.perAckTb1UE);
#ifdef PHR_TESTING
    fprintf(stderr,"CellIndex [%d], perAckTb1UE=%d,perAckTb1_g=%d\n",cellIndex,
            dlUeContext_p->tpcAckNackContext.perAckTb1UE,perAckTb1_g[cellIndex]);
#endif

    dlUeContext_p->tpcAckNackContext.perNackTb1UE = 
        dlUeContext_p->tpcAckNackContext.perSureTb1UE - dlUeContext_p->tpcAckNackContext.perAckTb1UE;
    validateAckNackRange((SInt16 *)&dlUeContext_p->tpcAckNackContext.perNackTb1UE);
#ifdef PHR_TESTING
    fprintf(stderr,"CellIndex [%d], perNackTb1UE=%d,perNackTb1_g=%d\n",cellIndex,
            dlUeContext_p->tpcAckNackContext.perNackTb1UE,perNackTb1_g[cellIndex]);
#endif

    dlUeContext_p->tpcAckNackContext.perAckTb2UE 
        = (dlUeContext_p->tpcAckNackContext.perSureTb2UE *
                perAckTb2_g[cellIndex])/100;
    validateAckNackRange((SInt16 *)&dlUeContext_p->tpcAckNackContext.perAckTb2UE);
#ifdef PHR_TESTING
    fprintf(stderr,"CellIndex [%d], perAckTb2UE=%d,perAckTb2_g=%d\n",cellIndex,
            dlUeContext_p->tpcAckNackContext.perAckTb2UE,perAckTb2_g[cellIndex]);
#endif

    dlUeContext_p->tpcAckNackContext.perNackTb2UE =
        dlUeContext_p->tpcAckNackContext.perSureTb2UE - dlUeContext_p->tpcAckNackContext.perAckTb2UE;
    validateAckNackRange((SInt16 *)&dlUeContext_p->tpcAckNackContext.perNackTb2UE);
#ifdef PHR_TESTING
    fprintf(stderr,"CellIndex[%d],perNackTb2UE=%d,perNackTb2_g=%d\n",cellIndex,
            dlUeContext_p->tpcAckNackContext.perNackTb2UE,perNackTb2_g[cellIndex]);
#endif
    modifyAckNackArrayForTpc(dlUeContext_p, cellIndex);
}
/*CLPC_CHG*/
/* +CA_NA */ 
/* PHASE 2 Changes */
/****************************************************************************
 * Function Name  :  processDLConfigPduInQueue 
 * Inputs         :  received DL Config PDU, serving cell Index, PCell Index
 * Outputs        :  DL Config PDU to be processed in serving cell
 * Returns        :  
 * Description    : This function pushes Dl Config PDU received for particular 
 *                  cell in respective queues and pop Dl config PDU for 
 *                  serving cell
 ****************************************************************************/

void processDLConfigPduInQueue(FAPI_dlConfigPDUInfo_st * recvDlConfigPdu_p,  
        UInt8 rxCellIndex,
        UInt8  txCellIndex )
{
    UInt8 cellCount = 0;

    pushNodeCircQ(&(dlConfigData[txCellIndex].DlConfigCircQ[rxCellIndex]), 
            (recvDlConfigPdu_p));
    /* semPost(&dlConfigSemlock_g[txCellIndex][rxCellIndex]);*/
    for (cellCount = 0 ; cellCount < MAX_NUM_CELLS; cellCount++)
    {
        /*semWait(&dlConfigSemlock_g[rxCellIndex][cellCount]);*/
        popNodeCircQ(&(dlConfigData[rxCellIndex].DlConfigCircQ[cellCount]), 
                (recvDlConfigPdu_p));
        printf("[%s]: processDLDemuxData for Servinf CellIndex = %d\n",__func__\
                , rxCellIndex);
    }

}
/* PHASE 2 Changes End*/
/* -CA_NA */ 

/****************************************************************************
 * Function Name  :  fapiHandlePhyDlConfigRequest 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : This function is the entry point for parsing of DL Config 
 *                  Msg recv from peer MAC.
 ****************************************************************************/
//TA: NON_SS
void fapiHandlePhyDlConfigRequest ( FAPI_l1ApiMsg_st *l1RcvMsg_p,
        fapiMsgIdStruct *msgIdArr_p, UInt8 rxCellIndex)
{
    UInt32 qCount = 0;
    UInt8 txCellIndex = 0;
    FAPI_dlConfigPDUInfo_st *recvDlConfigPdu_p = PNULL;
    FAPI_dlConfigRequest_st  *dlConfigReq_p = PNULL;
    UInt8 *PhyDlConfigRes_p =  PNULL;
    UInt32 PhyDlConfigRes_size = 0;
    UInt8 *temp_p = PNULL;
    UInt16 dciPduCount = 0;
    UInt16 recvSfnSf = 0, numOfDlConfigPdu = 0;
    UInt16 recvSFN = 0;
    UInt16 pduIndex = 0;
    UInt8 recvSF = 0, delay = 0;
    UInt16 dlConfigPduSize = 0;
    UInt16 currentSFN = sfnsf_g[rxCellIndex] & FAPI_SFN_MASK;
    UInt8 currentSF = sfnsf_g[rxCellIndex] & FAPI_SF_MASK;
    /* + MEAS_GAP_CHG*/
    DLUEContext *newUEContext_p = PNULL;
    UInt16  ackNackSFN = 0;
    UInt8   ackNackSF = 0;
    /* -  MEAS_GAP_CHG*/
#ifdef UESIM_ENHANCEMENTS
    UInt8 rbStart = 0, rbStartIndicator = 0;
    UInt8 totalTBAllocatedPerTick = 0, numOfRBsAllocatedInDL = 0;
    UInt8 tempSF = globalTTITickCount_g % 10;
#endif
    UInt32 subFrameNum = 0;
    UInt32 sysFrameNum = 0;
    UInt8 retVal = 0;
    UInt16 expectedSfnSf = 0;
    UInt16 mchPduIndex=0;

    /* Since global tick is updated on sending of SFI message, hence DL Config 
     * tick will be 1 less */
    /* SPR 15909 fix start */
    tickType_t dlConfigTick = globalTTITickCount_g - 1;
    /* SPR 15909 fix end */

#ifdef LTE_EMBMS_SUPPORTED
    UInt8 mcchFlag=0;
    AreaMCCHMap* areaMCCHMapNode_p=PNULL;
#endif

    /* SPR 11588 Changes Start */
    memset (msgIdArr_p, 0, sizeof(fapiMsgIdStruct)*MAX_ARR_SIZE);
    /* SPR 11588 Changes End */
    if ( l1RcvMsg_p->msgLen == 0 )
    {
        fprintf(stderr,"Error..!!! msgLen = 0 recevied from MAC in DL CONFIG REQ\n");  
        return;
    }

    /* Send fapi error incase of invalid phy state*/
    if ((1 == phy_err_config_g[rxCellIndex])&&\
            (( dlConfigTick >= phy_err_start_tti_g[rxCellIndex]) &&\
             (dlConfigTick <= phy_err_end_tti_g[rxCellIndex])) && (errorCount_g[rxCellIndex] == 0))
        {
        if ((PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[rxCellIndex]) && (FAPI_MSG_INVALID_STATE == phy_err_error_type_g[rxCellIndex]))
        {
            fapiSendErrorIndication(FAPI_MSG_INVALID_STATE, l1RcvMsg_p->msgId,
                    0,0,&PhyDlConfigRes_p,&PhyDlConfigRes_size, rxCellIndex);
#ifdef HO_SETUP_CHANGES
            sendSFItoSourceENBMac( PhyDlConfigRes_p, PhyDlConfigRes_size, rxCellIndex );
            if ( startRecvFlag[rxCellIndex] == 2 )
            {
                sendDataToTargetEnbMac( PhyDlConfigRes_p, PhyDlConfigRes_size, rxCellIndex);
            }
#else
            sendDatatoPeerMac( (UInt8 *)PhyDlConfigRes_p,PhyDlConfigRes_size,rxCellIndex);
#endif              
            freeMemPool(PhyDlConfigRes_p);
            PhyDlConfigRes_p = PNULL;
            phyState_g[rxCellIndex] = FAPI_CONFIGURED;
            /*Reset the global vars */
            resetGlobals(rxCellIndex);
            errorCount_g[rxCellIndex]++;
            return;
        }
    }
    /*FAPI_ERROR_INDICATION_CHANGES_END*/

#ifndef HO_SETUP_CHANGES
    if ( FAPI_RUNNING != phyState_g[rxCellIndex] )
    {
        /* send error indication */
        /* FAPI_MSG_INVALID_STATE */
        fapiSendErrorIndication(FAPI_MSG_INVALID_STATE, l1RcvMsg_p->msgId, 
                recvSfnSf, rxCellIndex);
        return;

    }
#endif
    /* PARSE DL Config request */
    dlConfigReq_p =  ( FAPI_dlConfigRequest_st *) &(l1RcvMsg_p->msgBody[0]);
    if ( PNULL == dlConfigReq_p )
    {
        fprintf(stderr,"Error..!!! dlConfig msgBody = NULL recevied from MAC" "in DL CONFIG REQ\n");  
        return;
    }

    recvSfnSf = MAC_PHY_CONVERT_16(dlConfigReq_p->sfnsf); 
    recvSFN = recvSfnSf & FAPI_SFN_MASK;
    recvSFN >>= FAPI_SFN_VALUE_SHIFT; 
    recvSF = recvSfnSf & FAPI_SF_MASK;
    currentSFN >>= FAPI_SFN_VALUE_SHIFT;
    /*FAPI_ERROR_INDICATION_CHANGES_START*/
    /* Send error from phy incase of discrepancy in expected and received
     * SFN/SF*/
    if ((1 == phy_err_config_g[rxCellIndex])&&\
            ((dlConfigTick >= phy_err_start_tti_g[rxCellIndex]) &&\
             (dlConfigTick <= phy_err_end_tti_g[rxCellIndex])) && (errorCount_g[rxCellIndex] == 0))
        {
        if ((PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[rxCellIndex]) && (FAPI_SFN_OUT_OF_SYNC == phy_err_error_type_g[rxCellIndex]))
        {
            dlConfigErrorFlag_g[rxCellIndex] = 0;
            /* FAPI L2 AS MASTER START */
#ifdef FAPI_L2_MASTER
            /*
            ** Update the SFNSF global variable and send the error
            ** indication to L2 except DL Config is received first time
            ** after PHY start.
            **
            ** Keep processing this  message and upcoming message with the
            ** SFNSF received in the DL Config message.
            */
            if (firstDlConfigAfterPhyStart_g[rxCellIndex])
            {
#endif
                if (phy_err_abs_delta_val_g[rxCellIndex]) 
                {
                    subFrameNum = recvSF;
                    sysFrameNum = recvSFN;
                    if ( 0 <= phy_err_delta_val_g[rxCellIndex] )
                    {
                        UInt16 deltaVal = phy_err_delta_val_g[rxCellIndex];
                        while( deltaVal-- )
                        {
                            subFrameNum++;
                            if( MAX_SUBFRAME <= subFrameNum )
                            {
                                subFrameNum = 0;
                                sysFrameNum++;
                            }
                        }
                    }
                    else 
                    {
                        UInt16 deltaVal = ABS( phy_err_delta_val_g[rxCellIndex] );
                        while( deltaVal-- )
                        {
                            if( 0 == subFrameNum )
                            {
                                subFrameNum = MAX_SUBFRAME - 1;
                                if( 0 == sysFrameNum )
                                {
                                   sysFrameNum = 1023;
                                }
                                else
                                {
                                    sysFrameNum--;
                                }
                            }
                            else
                            {
                                subFrameNum--;
                            }
                        }
                    }
                    expectedSfnSf = ( ( (sysFrameNum) << 4) | ( (subFrameNum) & 0xf) );
                    fapiSendErrorIndication(FAPI_SFN_OUT_OF_SYNC, l1RcvMsg_p->msgId,
                            recvSfnSf, expectedSfnSf,&PhyDlConfigRes_p,&PhyDlConfigRes_size, rxCellIndex);

                    UInt8 errQIdx = recvSF + 1;
                    if( errQIdx >= MAX_SUBFRAME )
                    {
                        errQIdx -= MAX_SUBFRAME;
                    }
                    LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                            sizeof(PhyErrInd), PNULL );
                    if( PNULL == phyErrInd_p )
                    {
                        freeMemPool(PhyDlConfigRes_p);
                        PhyDlConfigRes_p = PNULL;
                        return;
                    }
                    else
                    {
                        phyErrInd_p->data_p = PhyDlConfigRes_p;
                        phyErrInd_p->dataSize = PhyDlConfigRes_size;
                        ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx, rxCellIndex);
                    }
                    phy_err_abs_delta_val_g[rxCellIndex]--;
                    dlConfigErrorFlag_g[rxCellIndex] = 1;
                    return;
                }
#ifdef FAPI_L2_MASTER
            }

            if (PEER_MAC_ADVANCE == 1)
            {
                if (recvSF == 0)
                {
                    SF_g[rxCellIndex] = MAX_SUBFRAME - PEER_MAC_ADVANCE;
                    if (recvSFN == 0)
                    {
                        SFN_g[rxCellIndex] = MAX_SFN - 1;
                    }
                    else
                    {
                        SFN_g[rxCellIndex] = recvSFN - 1;
                    }
                }
                else
                {
                    SF_g[rxCellIndex]       = recvSF - PEER_MAC_ADVANCE;
                    SFN_g[rxCellIndex]      = recvSFN;
                }
            }
            else if(PEER_MAC_ADVANCE == 2)
            {
                if (recvSF == 0)
                {
                    SF_g[rxCellIndex] = MAX_SUBFRAME - PEER_MAC_ADVANCE;
                    if (recvSFN == 0)
                    {
                        SFN_g[rxCellIndex] = MAX_SFN - 1;
                    }
                    else
                    {
                        SFN_g[rxCellIndex] = recvSFN - 1;
                    }
                }
                else if(recvSF == 1)
                {
                    SF_g[rxCellIndex] = MAX_SUBFRAME - 1;
                    if (recvSFN == 0)
                    {
                        SFN_g[rxCellIndex] = MAX_SFN - 1;
                    }
                    else
                    {
                        SFN_g[rxCellIndex] = recvSFN - 1;
                    }
                }
                else
                {
                    SF_g[rxCellIndex]       = recvSF - PEER_MAC_ADVANCE;
                    SFN_g[rxCellIndex]      = recvSFN;
                }
            }
            else
            {
                /* Nothing to do */
            }
            sfnsf_g[rxCellIndex] = GENERATE_SUBFRAME_SFNSF(SFN_g[rxCellIndex],SF_g[rxCellIndex]);
            currentSFN = SFN_g[rxCellIndex];
            currentSF  = SF_g[rxCellIndex];
#else
            errorCount_g[rxCellIndex]++;
#endif
        }
    }
    /*FAPI_ERROR_INDICATION_CHANGES_END*/

#ifdef TDD_CONFIG
    if ( delay = validateTick( recvSFN,
                                recvSF,
                                currentSFN,
                                currentSF
                              ) == 0xFF)
    {
        /* FAPI L2 AS MASTER START */
#ifdef FAPI_L2_MASTER
        /*
        ** Update the SFNSF global variable and send the error
        ** indication to L2 except DL Config is received first time
        ** after PHY start.
        **
        ** Keep processing this  message and upcoming message with the
        ** SFNSF received in the DL Config message.
        */
        if (firstDlConfigAfterPhyStart_g[rxCellIndex])
        {
            fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId, 
                    recvSfnSf, sfnsf_g[rxCellIndex], &PhyDlConfigRes_p,&PhyDlConfigRes_size, rxCellIndex);
            /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            sendSFItoSourceENBMac( (UInt8 *)PhyDlConfigRes_p,PhyDlConfigRes_size,rxCellIndex );
            /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            freeMemPool( PhyDlConfigRes_p );
            PhyDlConfigRes_p = PNULL;
        }
        if (PEER_MAC_ADVANCE == 1)
        {
            if (recvSF == 0)
            {
                SF_g[rxCellIndex] = MAX_SUBFRAME - PEER_MAC_ADVANCE;
                if (recvSFN == 0)
                {
                    SFN_g[rxCellIndex] = MAX_SFN - 1;
                }
                else
                {
                    SFN_g[rxCellIndex] = recvSFN - 1;
                }
            }
            else
            {
                SF_g[rxCellIndex]       = recvSF - PEER_MAC_ADVANCE;
                SFN_g[rxCellIndex]      = recvSFN;
            }
        }
        else if(PEER_MAC_ADVANCE == 2)
        {
            if (recvSF == 0)
            {
                SF_g[rxCellIndex] = MAX_SUBFRAME - PEER_MAC_ADVANCE;
                if (recvSFN == 0)
                {
                    SFN_g[rxCellIndex] = MAX_SFN - 1;
                }
                else
                {
                    SFN_g[rxCellIndex] = recvSFN - 1;
                }
            }
            else if(recvSF == 1)
            {
                SF_g[rxCellIndex] = MAX_SUBFRAME - 1;
                if (recvSFN == 0)
                {
                    SFN_g[rxCellIndex] = MAX_SFN - 1;
                }
                else
                {
                    SFN_g[rxCellIndex] = recvSFN - 1;
                }
            }
            else
            {
                SF_g[rxCellIndex]       = recvSF - PEER_MAC_ADVANCE;
                SFN_g[rxCellIndex]      = recvSFN;
            }

        }
        else
        {
            /* Nothing to do */
        }

        sfnsf_g[rxCellIndex] = GENERATE_SUBFRAME_SFNSF(SFN_g[rxCellIndex],SF_g[rxCellIndex]);
        currentSFN = SFN_g[rxCellIndex];
        currentSF  = SF_g[rxCellIndex];
#else
        /* FAPI_MSG_INVALID_SFN */
        fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId, 
                recvSfnSf, sfnsf_g[rxCellIndex], &PhyDlConfigRes_p,&PhyDlConfigRes_size, rxCellIndex);
        /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
        sendSFItoSourceENBMac( (UInt8 *)PhyDlConfigRes_p,PhyDlConfigRes_size, rxCellIndex );
        /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
        freeMemPool( PhyDlConfigRes_p );
        PhyDlConfigRes_p = PNULL;
        return;
#endif
    }
    Dci0HiPdu *dci0HiPdu_p = PNULL;
    Dci0HiPdu dci0HiPdu;
    //Nitin
    dci0HiPdu_p = (Dci0HiPdu *)&dci0HiPdu;

    calQIdxSFandSFN( recvSF,
                     recvSFN,
                     delay,
                     dci0HiPdu_p                     
            /* SPR 11568 Start */
            ,rxCellIndex
            /* SPR 11568 End */
                   );
#elif FDD_CONFIG
    /* check for validation of recevied SFN & SF from MAC */ 
    // HD FDD Changes Start 
    dlRecvSF_g = recvSF;
    // HD FDD Changes End
    if (( delay = validateSFNandSFAndgetDelay(recvSFN, recvSF, 
                                             currentSFN, currentSF)) == 0xFF )
    {
        //fprintf(stderr,"DL CONFIG packet Drooped due to delayed received\n");
       //fprintf(stderr,"DL Control: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);
        
        /* FAPI L2 AS MASTER START */
#ifdef FAPI_L2_MASTER
        /*
        ** Update the SFNSF global variable and send the error
        ** indication to L2 except DL Config is received first time
        ** after PHY start.
        **
        ** Keep processing this  message and upcoming message with the
        ** SFNSF received in the DL Config message.
        */
        if (firstDlConfigAfterPhyStart_g[rxCellIndex])
        {
            fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId, 
                    recvSfnSf,sfnsf_g[rxCellIndex], &PhyDlConfigRes_p,&PhyDlConfigRes_size,rxCellIndex);
            /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            sendSFItoSourceENBMac( (UInt8 *)PhyDlConfigRes_p,PhyDlConfigRes_size,rxCellIndex );
            /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            freeMemPool( PhyDlConfigRes_p );
            PhyDlConfigRes_p = PNULL;
        }

        if (PEER_MAC_ADVANCE == 1)
        {
            if (recvSF == 0)
            {
                SF_g[rxCellIndex] = MAX_SUBFRAME - PEER_MAC_ADVANCE;
                if (recvSFN == 0)
                {
                    SFN_g[rxCellIndex] = MAX_SFN - 1;
                }
                else
                {
                    SFN_g[rxCellIndex] = recvSFN - 1;
                }
            }
            else
            {
                SF_g[rxCellIndex]       = recvSF - PEER_MAC_ADVANCE;
                SFN_g[rxCellIndex]      = recvSFN;
            }
        }
        else if(PEER_MAC_ADVANCE == 2)
        {
            if (recvSF == 0)
            {
                SF_g[rxCellIndex] = MAX_SUBFRAME - PEER_MAC_ADVANCE;
                if (recvSFN == 0)
                {
                    SFN_g[rxCellIndex] = MAX_SFN - 1;
                }
                else
                {
                    SFN_g[rxCellIndex] = recvSFN - 1;
                }
            }
            else if(recvSF == 1)
            {
                SF_g[rxCellIndex] = MAX_SUBFRAME - 1;
                if (recvSFN == 0)
                {
                    SFN_g[rxCellIndex] = MAX_SFN - 1;
                }
                else
                {
                    SFN_g[rxCellIndex] = recvSFN - 1;
                }
            }
            else
            {
                SF_g[rxCellIndex]       = recvSF - PEER_MAC_ADVANCE;
                SFN_g[rxCellIndex]      = recvSFN;
            }
        }
        else
        {
            /* Nothing to do */
        }

        sfnsf_g[rxCellIndex] = GENERATE_SUBFRAME_SFNSF(SFN_g[rxCellIndex],SF_g[rxCellIndex]);
        currentSFN = SFN_g[rxCellIndex];
        currentSF  = SF_g[rxCellIndex];
#else
        /* send error indication */
        /* FAPI_MSG_INVALID_SFN */
        fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId, 
                recvSfnSf,sfnsf_g[rxCellIndex], &PhyDlConfigRes_p,&PhyDlConfigRes_size,rxCellIndex);
        /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
        sendSFItoSourceENBMac( (UInt8 *)PhyDlConfigRes_p,PhyDlConfigRes_size, rxCellIndex );
        /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
        freeMemPool( PhyDlConfigRes_p );
        PhyDlConfigRes_p = PNULL;
        return;
#endif
    }
    /* FAPI L2 AS MASTER END */
#endif
#ifdef FAPI_L2_MASTER
    firstDlConfigAfterPhyStart_g[rxCellIndex] = TRUE;
#endif
    /*FAPI_ERROR_INDICATION_CHANGES_START*/
    /* Send fapi error in case of missing BCH PDU in DL Config*/
    if ((1 == phy_err_config_g[rxCellIndex])&&\
            ((dlConfigTick >= phy_err_start_tti_g[rxCellIndex]) && \
             (dlConfigTick <= phy_err_end_tti_g[rxCellIndex])) && (errorCount_g[rxCellIndex] == 0))

    {
        if ((PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[rxCellIndex]) && (FAPI_MSG_BCH_MISSING == phy_err_error_type_g[rxCellIndex]))
        {
            if ((0 == recvSF) && (0 == (recvSFN % 4)))
            {
                /* Send error indication and continue normally */
                fapiSendErrorIndication(FAPI_MSG_BCH_MISSING, l1RcvMsg_p->msgId, 
                        0,0,&PhyDlConfigRes_p,&PhyDlConfigRes_size,rxCellIndex);

                UInt8 errQIdx = recvSF + 1;
                if( errQIdx >= MAX_SUBFRAME )
                {
                    errQIdx -= MAX_SUBFRAME;
                }
                LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                        sizeof(PhyErrInd), PNULL );
                if( PNULL == phyErrInd_p )
                {
                    freeMemPool(PhyDlConfigRes_p);
                    PhyDlConfigRes_p = PNULL;
                    return;
                }
                else
                {
                    phyErrInd_p->data_p = PhyDlConfigRes_p;
                    phyErrInd_p->dataSize = PhyDlConfigRes_size;

                    ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx, rxCellIndex);
                }
                errorCount_g[rxCellIndex]++;
            }
        }
    }

    numOfDlConfigPdu = MAC_PHY_CONVERT_16(dlConfigReq_p->numOfPDU);
    UInt8 cellIndex = 0;
    FAPI_rntiType_en rntiType;

    temp_p = (UInt8 *)dlConfigReq_p->dlConfigpduInfo; 

    if ( PNULL == temp_p )
    {
        fprintf(stderr,"\n recevied dl config with no PDU\n ");
        return;
    } 

    msgIdArr_p[0].recvSfnSf = recvSfnSf;
    while (  numOfDlConfigPdu-- )
    {
        recvDlConfigPdu_p = ( FAPI_dlConfigPDUInfo_st * ) temp_p;

        /* SPR 11998 fix start */
        if (recvDlConfigPdu_p->dlConfigpduInfo.DCIPdu.rnti >= 
                 cellConfigUeSim_g[rxCellIndex].startSpsCrnti && 
            recvDlConfigPdu_p->dlConfigpduInfo.DCIPdu.rnti <=
                  cellConfigUeSim_g[rxCellIndex].endSpsCrnti )
        {
            txCellIndex = rxCellIndex;
        }
        else
        {
            GET_RNTI_TO_CELL_INDEX( 
                    recvDlConfigPdu_p->dlConfigpduInfo.DCIPdu.rnti, 
                    txCellIndex);
        }
        /* SPR 11998 fix end */

        /* PHASE 2 Changes Start*/
        /* put dlConfigPdu in respective queues if serveing cell is not pcell 
         * and get dlConfigPdu from queues for which serving cell is pcell */
        /*processDLConfigPduInQueue(recvDlConfigPdu_p, 
          rxCellIndex,txCellIndex );*/
        /* PHASE 2 Changes End*/
        /* + SPR 11220 Changes */
        if(recvDlConfigPdu_p->pduType == FAPI_MCH_PDU)
        {
            newUEContext_p=PNULL;
        }
        else
        {    
            newUEContext_p =
                getDLUEContextFromRnti(MAC_PHY_CONVERT_16(recvDlConfigPdu_p->\
                            dlConfigpduInfo.DCIPdu.rnti), txCellIndex);
        }    
        /* - SPR 11220 Changes */
        if ( PNULL !=  newUEContext_p &&
                RELEASE != newUEContext_p->measGapConfigType )
        {
            if ( MAC_SUCCESS == 
                    checkIsMeasurementGapPeriodON(recvSFN,recvSF,newUEContext_p))
            {
                lteWarning("DL Config request received during Measurement gap" 
                        "period SFN = %d , SF = %d ,ueIndex = %d ."
                        ,recvSFN , recvSF,newUEContext_p->ueIndex );
                dlConfigPduSize = recvDlConfigPdu_p->pduSize;
                temp_p += dlConfigPduSize;
                continue;
            }
            ackNackSFN = recvSFN;
            ackNackSF = recvSF;
#ifdef FDD_CONFIG
            UpdateSfnSf(&ackNackSFN, &ackNackSF, 4);
#elif TDD_CONFIG
            UpdateSfnSf(&ackNackSFN,
                    &ackNackSF,
                    /* CA TDD Changes Start */
                    ulSfForDlAckNack_g[tddUlDlConfig_g[rxCellIndex]][ackNackSF]);
                    /* CA TDD Changes End */
#endif
            if ( MAC_SUCCESS ==
                    checkIsMeasurementGapPeriodON(ackNackSFN,ackNackSF,
                        newUEContext_p))
            {
                dlConfigPduSize = recvDlConfigPdu_p->pduSize;
                temp_p += dlConfigPduSize;
                continue;
            }

        }  
        /* - MEAS_GAP_CHG*/
        /* HD FDD Changes Start */ 
#ifdef FDD_CONFIG
#ifdef HD_FDD_CONFIG
        if((newUEContext_p != NULL) && (TRUE == newUEContext_p->isHDFddFlag))
        {
            if(!isDLScheduledForHDFddUe(newUEContext_p->ueIndex, recvSF, FALSE, rxCellIndex))
            {
                /* SPR 15909 fix start */
                fprintf(stderr," [%llu] DL drop UE:%d PDU type= %d, Delay = %d, recvSFN= %d, recvSF = %d, currentSFN=%d, currentSF=%d \n",
                        getCurrentglobaltick(),newUEContext_p->ueIndex,recvDlConfigPdu_p->pduType, delay, recvSFN , recvSF, currentSFN, currentSF);
                /* SPR 15909 fix end */
                dlConfigPduSize = recvDlConfigPdu_p->pduSize;
                temp_p += dlConfigPduSize;
                continue;
            }
            //fprintf(stderr," [%d] DL Config UE:%d PDU type= %d, Delay = %d, recvSFN= %d, recvSF = %d, currentSFN=%d, currentSF=%d \n",
            //         getCurrentglobaltick(),newUEContext_p->ueIndex,recvDlConfigPdu_p->pduType, delay, recvSFN , recvSF, currentSFN, currentSF);
        }
        else
        {
            //  fprintf(stderr, "[%d] FAPI_DLSCH_PDU received isHDDFlag = %d  \n", getCurrentglobaltick(), newUEContext_p->isHDFddFlag);
        }
        /* HD FDD Changes End */
#endif
#endif

        switch ( recvDlConfigPdu_p->pduType )
        {
            case FAPI_DCI_DL_PDU:
            {   
                dlConfigPduSize = recvDlConfigPdu_p->pduSize;   
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"\n DCI DL PDU recevied \n");
#endif
                fapiParseAndStoreDciDlConfigPdu( recvDlConfigPdu_p->pduSize, 
                        &(recvDlConfigPdu_p->dlConfigpduInfo.DCIPdu),
                         msgIdArr_p,
                         rxCellIndex
                        ,recvSF
#ifdef TDD_CONFIG

                        ,dci0HiPdu_p
#endif
                        );
                /*FAPI_ERROR_INDICATION_CHANGES_START*/
                /*Discard the remaining msg when the first error is
                 * encountered*/
                if ((1 == phy_err_config_g[rxCellIndex]) &&\
                    (INVALID_RET_VAL ==retVal))
                {
                    return;
                }
                /*FAPI_ERROR_INDICATION_CHANGES_END*/
                dciPduCount++;
                if (  dciPduCount > dlConfigReq_p->numDCI )
                {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"Error!!! num Of dciPdu [%d] recevied is more than \
                            numDCI [%d] present in dlConfigRequest PDU \n",
                            dciPduCount, dlConfigReq_p->numDCI);
#endif
                }
                break;
                } 

            case FAPI_BCH_PDU:
                {
                    /*FAPI_ERROR_INDICATION_CHANGES_START*/
                    /*Send phy error in case of subframe error in BCH PDU*/
                    if ((1 == phy_err_config_g[rxCellIndex])&&\
                        (( globalTTITickCount_g >= phy_err_start_tti_g[rxCellIndex]) && \
                        ( globalTTITickCount_g <= phy_err_end_tti_g[rxCellIndex])) && (errorCount_g[rxCellIndex] == 0))
                        {
                        if (PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[rxCellIndex])
                        {
                            if ((FAPI_MSG_SUBFRAME_ERR == phy_err_error_type_g[rxCellIndex]) && (FAPI_BCH_PDU == phy_err_pdu_type_g[rxCellIndex]))
                            {
                                phy_err_crnti_g[rxCellIndex] = 0;
                                fapiSendErrorIndication(FAPI_MSG_SUBFRAME_ERR, l1RcvMsg_p->msgId,
                                        0,0,&PhyDlConfigRes_p,&PhyDlConfigRes_size, rxCellIndex);

                                UInt8 errQIdx = recvSF + 1;
                                if( errQIdx >= MAX_SUBFRAME )
                                {
                                    errQIdx -= MAX_SUBFRAME;
                                }
                                LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                                        sizeof(PhyErrInd), PNULL );
                                if( PNULL == phyErrInd_p )
                                {
                                    freeMemPool(PhyDlConfigRes_p);
                                    PhyDlConfigRes_p = PNULL;
                                    return;
                                }
                                else
                                {
                                    phyErrInd_p->data_p = PhyDlConfigRes_p;
                                    phyErrInd_p->dataSize = PhyDlConfigRes_size;

                                    ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx, rxCellIndex );
                                }
                                errorCount_g[rxCellIndex]++;
                                return;
                            }
                        }
                    }
                    /*FAPI_ERROR_INDICATION_CHANGES_END*/

                    dlConfigPduSize = recvDlConfigPdu_p->pduSize;   
                    pduIndex = MAC_PHY_CONVERT_16(recvDlConfigPdu_p->dlConfigpduInfo.BCHPdu.pduIndex); 
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"\n BCH Config PDU recevied pduIndex = %d\n", pduIndex);
#endif
                    msgIdArr_p[pduIndex].bchPduCount++;
                    msgIdArr_p[pduIndex].bchPdu.bchPduLen = 
                        MAC_PHY_CONVERT_16(recvDlConfigPdu_p->dlConfigpduInfo.BCHPdu.bchPduLen);
                    msgIdArr_p[pduIndex].bchPdu.rntiType = \
						fapiGetRntiType(0xFFFF, rxCellIndex);
                    break;
                } 
#ifdef LTE_EMBMS_SUPPORTED
            case FAPI_MCH_PDU:
                {
                    /*FAPI_ERROR_INDICATION_CHANGES_START*/
                    /*Send phy error in case of subframe error in MCH PDU*/
                    if ((1 == phy_err_config_g[rxCellIndex])&& 
                            ( ( globalTTITickCount_g >= phy_err_start_tti_g[rxCellIndex]) && 
                              ( globalTTITickCount_g <= phy_err_end_tti_g[rxCellIndex])) && 
                            (errorCount_g[rxCellIndex] == 0))
                    {
                        if (PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[rxCellIndex])
                        {
                            if ((FAPI_MSG_SUBFRAME_ERR == phy_err_error_type_g[rxCellIndex]) && (FAPI_MCH_PDU == phy_err_pdu_type_g[rxCellIndex]))
                            {
                                phy_err_crnti_g[rxCellIndex] = 0;
                                fapiSendErrorIndication(FAPI_MSG_SUBFRAME_ERR, l1RcvMsg_p->msgId,
                                        0,0,&PhyDlConfigRes_p,&PhyDlConfigRes_size, rxCellIndex);

                                UInt8 errQIdx = recvSF + 1;
                                if( errQIdx >= MAX_SUBFRAME )
                                {
                                    errQIdx -= MAX_SUBFRAME;
                                }
                                LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                                        sizeof(PhyErrInd), PNULL );
                                if( PNULL == phyErrInd_p )
                                {
                                    freeMemPool(PhyDlConfigRes_p);
                                    PhyDlConfigRes_p = PNULL;
                                    return;
                                }
                                else
                                {
                                    phyErrInd_p->data_p = PhyDlConfigRes_p;
                                    phyErrInd_p->dataSize = PhyDlConfigRes_size;

                                    ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx ,rxCellIndex);
                                }
                                errorCount_g[rxCellIndex]++;
                                return;
                            }
                        }
                    }
                    /*FAPI_ERROR_INDICATION_CHANGES_END*/
                    dlConfigPduSize = recvDlConfigPdu_p->pduSize;   
                    pduIndex = MAC_PHY_CONVERT_16(recvDlConfigPdu_p->dlConfigpduInfo.MCHPdu.pduIndex);
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"\n PCH DL Config MCH PDU recevied pduIndex = %d\n",pduIndex);
#endif
                    mchPduIndex=recvSFN*10+recvSF;
                    mcchFlag=1;
#if 0                    
                    if(areaMcchMap_g[rxCellIndex][mchPduIndex]== PNULL)
                    {
                        ltePanic("MCH_PDU received for invalid SFN:%u SF:%u\n",recvSFN,recvSF);
                    }
#endif             
                    /* SPR 18131 Fix Start*/
                    areaMCCHMapNode_p=areaMcchMap_g[rxCellIndex][mchPduIndex];
                    /* SPR 18131 Fix End*/
                    if(areaMCCHMapNode_p != PNULL && areaMCCHMapNode_p->areaType==NON_RESERVED_AREA)
                    {
                         mcchPduReceived_g=TRUE;
                    }
                    fapiHandleMchConfigPdu(&(recvDlConfigPdu_p->dlConfigpduInfo.MCHPdu), msgIdArr_p, &pduIndex);
                    if(areaMCCHMapNode_p != PNULL && areaMCCHMapNode_p->isModificationPeriod)
                    {
                         rlcResetSN_g=TRUE;
                    }
                    break;
                }
#endif                

            case FAPI_DLSCH_PDU:
                {   
#ifdef UESIM_ENHANCEMENTS
                    newUEContext_p =
                        getDLUEContextFromRnti(MAC_PHY_CONVERT_16(
									recvDlConfigPdu_p->dlConfigpduInfo.\
									DlSCHPdu.rnti), rxCellIndex);
                    if( (0XFFFF != recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.rnti) &&
                        (PNULL != newUEContext_p) )
                    {
                        newUEContext_p->tbSizeReceived = recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.dlschPduLen;
                    }
#endif                    
                    dlConfigPduSize = recvDlConfigPdu_p->pduSize;   
                    pduIndex = MAC_PHY_CONVERT_16(recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.pduIndex);
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"\n DLSCH config PDU recevied %d\n",pduIndex);
#endif
                    fapiHandledlSCHConfigPdu(recvDlConfigPdu_p->pduSize, 
                            &(recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu),
                            msgIdArr_p, &pduIndex, recvSF, rxCellIndex
                            /* SPR 20758 fix start */
#ifdef TDD_CONFIG
                            ,dci0HiPdu_p
#endif
                            /* SPR 20758 fix end */
                            );

                    /*FAPI_ERROR_INDICATION_CHANGES_START*/
                    if ((1 == phy_err_config_g[rxCellIndex]) &&\
                        (INVALID_RET_VAL == retVal))
                    {
                        return;
                    }
                    /*FAPI_ERROR_INDICATION_CHANGES_END*/

#ifdef UESIM_ENHANCEMENTS
                    if( (0xFFFF != recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.rnti) &&  (recvSF == tempSF) &&
                        (2 != recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.transportBlocks) &&
                        (recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.rbCoding) )
                    {
                        if(2 == recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.resAllocationType)
                        {
                            numOfRBsAllocatedInDL = calculateAndUpdateRAT2Info(recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.rbCoding,\
                                                                               rxCellIndex);
                            totalTBAllocatedPerTick += numOfRBsAllocatedInDL;
                        }                                              
                        else if(3 != recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.resAllocationType)
                        {
                            numOfRBsAllocatedInDL = calculateNumOfRBs(recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.rbCoding,
                                    recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.resAllocationType, rxCellIndex);
                            totalTBAllocatedPerTick += numOfRBsAllocatedInDL;
                            updateDlRbInfo(recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.rbCoding,
                                    recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.resAllocationType,rxCellIndex);  
                        }
                    }
                    else if( (0xFFFF != recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.rnti) &&
                             (2 == recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.resAllocationType) &&
                             (0 == recvDlConfigPdu_p->dlConfigpduInfo.DlSCHPdu.rbCoding) )
                    {
                        numOfRBsAllocatedInDL = 1;
                        totalTBAllocatedPerTick += numOfRBsAllocatedInDL;
                        if((RB_CAN_BE_ALLOCATED__BUSY == dlRBInfo_g[rxCellIndex][0]) ||
                           (RB_ALLOCATED_FOR_SEMI_STATIC_INFORMATION == dlRBInfo_g[rxCellIndex][0]))
                        {
                            ltePanic("In %s, RAT2, RB = 0 is already allocated\n",__func__);
                        }
                        else
                        {
                            dlRBInfo_g[rxCellIndex][0] = RB_CAN_BE_ALLOCATED__BUSY;
                        }   
                    }
#endif                    
                    break;
                } 

            case FAPI_PCH_PDU:
                {   
                    /*FAPI_ERROR_INDICATION_CHANGES_START*/
                    /*Send phy error in case of subframe error in PCH PDU*/
                    if ((1 == phy_err_config_g[rxCellIndex])&&\
                        ((dlConfigTick >= phy_err_start_tti_g[rxCellIndex]) && \
                        (dlConfigTick <= phy_err_end_tti_g[rxCellIndex])) && (errorCount_g[rxCellIndex] == 0))
                        {
                        if (PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[rxCellIndex])
                        {
                            if ((FAPI_MSG_SUBFRAME_ERR == phy_err_error_type_g[rxCellIndex]) && (FAPI_PCH_PDU == phy_err_pdu_type_g[rxCellIndex]))
                            {
                                phy_err_crnti_g[rxCellIndex] = 0;
                                fapiSendErrorIndication(FAPI_MSG_SUBFRAME_ERR, l1RcvMsg_p->msgId,
                                        0,0,&PhyDlConfigRes_p,&PhyDlConfigRes_size, rxCellIndex);

                                UInt8 errQIdx = recvSF + 1;
                                if( errQIdx >= MAX_SUBFRAME )
                                {
                                    errQIdx -= MAX_SUBFRAME;
                                }
                                LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                                        sizeof(PhyErrInd), PNULL );
                                if( PNULL == phyErrInd_p )
                                {
                                    freeMemPool(PhyDlConfigRes_p);
                                    PhyDlConfigRes_p = PNULL;
                                    return;
                                }
                                else
                                {
                                    phyErrInd_p->data_p = PhyDlConfigRes_p;
                                    phyErrInd_p->dataSize = PhyDlConfigRes_size;

                                    ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx ,rxCellIndex);
                                }
                                errorCount_g[rxCellIndex]++;
                                return;
                            }
                        }
                    }
                    /*FAPI_ERROR_INDICATION_CHANGES_END*/
                    dlConfigPduSize = recvDlConfigPdu_p->pduSize;   
                    pduIndex = MAC_PHY_CONVERT_16(recvDlConfigPdu_p->dlConfigpduInfo.PCHPdu.pduIndex);
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"\n PCH DL Config PDU recevied pduIndex = %d\n",pduIndex);
#endif
                    fapiHandlePchConfigPdu(recvDlConfigPdu_p->pduSize, 
                            &(recvDlConfigPdu_p->dlConfigpduInfo.PCHPdu),
                            msgIdArr_p, &pduIndex, rxCellIndex);
                    msgIdArr_p[pduIndex].pch.rntiType =
                   		 fapiGetRntiType(0xFFFE, rxCellIndex);
                    break;
                } 
               case FAPI_PRS_PDU:
               {   
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                 fprintf(stderr,"\n PRS DL Config PDU recevied pduIndex = %d\n",pduIndex);
#endif
                 fapiHandlePrsConfigPdu(&(recvDlConfigPdu_p->dlConfigpduInfo.PRSPdu),
                                       msgIdArr_p);
                 break;
               } 
               /* - PRS_CHANGES */
           default:
                 dlConfigPduSize = recvDlConfigPdu_p->pduSize;   
                 fprintf(stderr,"\n Unsupported DL Config PDU recevied \n");
                 break;          
   
        }
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"pdu size = %d\n", dlConfigPduSize);
#endif
        temp_p += dlConfigPduSize;
    }
#ifdef LTE_EMBMS_SUPPORTED    
    mchPduIndex=recvSFN*10+recvSF;
    /* SPR 18131 Fix Start*/
    if(areaMcchMap_g[rxCellIndex][mchPduIndex]!= PNULL && mcchFlag==0 &&\
        areaMcchMap_g[rxCellIndex][mchPduIndex]->areaType == NON_RESERVED_AREA)
    {
        fprintf(stderr,"MCH_PDU not received for  SFN:%u SF:%u\n",recvSFN,recvSF);
    }
    /* SPR 18131 Fix End*/
#endif    

#ifdef UESIM_ENHANCEMENTS
    if(totalTBAllocatedPerTick > cellConfigUeSim_g[rxCellIndex].dlAvailableRBs)
    {
        ltePanic("Total RB's allocated in DL = %d is more than equal to system bandwidth = %d\n",
                totalTBAllocatedPerTick,cellConfigUeSim_g[rxCellIndex].dlAvailableRBs);
    }
#endif
}
/****************************************************************************
 * Function Name  :  fapiProcessContentionMsg 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
void fapiProcessContentionMsg (UInt16 rnti, UInt16 dlschPduLength, 
                               UInt8 *data_p,UInt16 sendSfnSf, 
                               UInt8 qIndex, UInt8 cellIndex)
{
    UInt8 i = 0;
    RNTIInfo *rntiInfo_p = PNULL;
    FAPI_harqIndQueueNode_st *ulContentionAckNode_p = PNULL;
    rntiInfo_p = getRntiInfofromRNTIMap(rnti, cellIndex);
    if ( rntiInfo_p == PNULL)
    {
        fprintf(stderr,"fapiProcessContentionMsg: rnti info not found for [rnti = %d]\n", rnti);
        return;
    }
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr," contention data received..........!!! for rnti = %d\n",rnti);
#endif
    if ( (WAIT_CONTENTION_RESOLUTION != rntiInfo_p->state) )
    {
        fprintf(stderr,"rnti = %d state %d is not WAIT_CONTENTION_RESOLUTION\n",rnti, rntiInfo_p->state);
        return;
    }
    /* compare the msg3 with recv data 
     * if matches then store tcrnti as crnti and send dl ACK
     */
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    for ( i = 0; i <dlschPduLength; i++)
    {
        fprintf(stderr,"0x%x\t",data_p[i]);
    }
    fprintf(stderr,"\n");
#endif
    for ( i = 0; i < 6; i++)
    {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"recv %d stored %d\t",data_p[i+1], rntiInfo_p->ccchSDUArr[i]);
#endif
        if (raRntiArr_g[cellIndex][rntiInfo_p->RaRnti - 1].rrcConnectionReq[i] 
                               != data_p[i + 1])
        {
            fprintf(stderr,"CCCH SDU did not match.Contention resolution unsucess \n");
            statsGeneralInfo_g.statsContentionResUnSuccess--;
            return;
        }
    }

    /* send DL contention ack */
    ulContentionAckNode_p = (FAPI_harqIndQueueNode_st *) 
                        getMemFromPool(sizeof(FAPI_harqIndQueueNode_st),PNULL);

    if ( PNULL == ulContentionAckNode_p )
    {
        fprintf(stderr,"Not able to get memory for DL ACK NACK packet in" "Contention resolution ACK\n");
        return;
    }
#ifdef FDD_CONFIG
    ulContentionAckNode_p->sfnsf = sendSfnSf;
    ulContentionAckNode_p->harqPduInfo.rnti = MAC_PHY_CONVERT_16(rnti); 
/* CA_START_UP_PHASE_2 */
#ifndef FAPI_4_0_COMPLIANCE
    ulContentionAckNode_p->harqPduInfo.harqTB1 = FAPI_ACK;
#else
#if (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
    ulContentionAckNode_p->harqPduInfo.release9Param.HARQTB[0] = FAPI_ACK;
/* UESIM PHASE 2 FIX START*/
    ulContentionAckNode_p->harqPduInfo.release9Param.numOfAckNack = 1;
    ulContentionAckNode_p->harqPduInfo.release9Param.mode = 1;
/* UESIM PHASE 2 FIX END*/
#else
    ulContentionAckNode_p->harqPduInfo.release8Param.harqTB1 = FAPI_ACK;
#endif
#endif
/* CA_START_UP_PHASE_2 */
    pushNode(&(harqQueue[cellIndex][qIndex]), &(ulContentionAckNode_p->harqNodeAnchor) );
#elif  TDD_CONFIG
    ulContentionAckNode_p->sfnsf = sendSfnSf;
    ulContentionAckNode_p->harqPduInfo.rnti = rnti;
    ulContentionAckNode_p->harqPduInfo.handle = 1;
    ulContentionAckNode_p->harqPduInfo.mode = 0;
    ulContentionAckNode_p->harqPduInfo.numOfAckNack = 1;
//    ((FAPI_tddBundlingHarqInfo *)
//        (ulContentionAckNode_p->harqPduInfo.harqBuffer))->value0 = FAPI_ACK;
        ulContentionAckNode_p->harqPduInfo.harqBuffer.value0 = FAPI_ACK;

    pushNode(&(harqQueue[cellIndex][qIndex]), &(ulContentionAckNode_p->harqNodeAnchor) );
    fprintf(stderr,"##################################"
                   "Contention Ack SfnSf [%d],qIndex[%d]\n\n\n\n",
                   sendSfnSf,qIndex);
#endif
    rntiInfo_p->state = WAIT_FOR_DL_CCCH_MSG;

    fprintf(stderr,"\nCCCH SDU  match.Contention resolution sucess \n");
    statsGeneralInfo_g.statsContentionResSuccess++;
    return;
} 


/****************************************************************************
 * Function Name  :  fapiProcessRAR 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
void fapiProcessRAR(UInt16 rnti, UInt16 dlschPduLength, UInt8 *data_p,
                    UInt16 sendSfnSf, UInt8 qIndex, UInt8 cellIndex) 
{
    ulschDataQueueNode *uldataNode_p = PNULL;   
    FILE  *preambleRangeFileFp = PNULL; 
    RARequest raReq  = {0};
    UInt16 tempCrnti = 0 ;
    UInt8 index      = 0;
    UInt8 backOffInd = 0;
    UInt8 firstByte  = 0;
    UInt8 preamble   = 0;
    UInt8 preCount   = 0;
    UInt8 tcount     = 0;
    UInt8 raRspCount = 0;
    UInt8 loopCount  = 0;
    UInt8 found      = FALSE;
    UInt8 recvPreamble[MAX_NUM_PREAMBLE] = {0,};
    UInt8 tcrnti[MAX_NUM_PREAMBLE] = {0,};
    RNTIInfo *rntiInfo_p = PNULL;
    UInt32 tbSize = 0;
    UInt32 mcsIndex = 0;
    UInt32 numRB = 0;
    /* SPR 1827_28_29 Fix Start */
#ifdef FDD_CONFIG    
    UInt8 rarQindex      = 0;
    UInt16 rarSfnSf = 0 ;
    UInt16 rarSfn = 0 ;
    UInt16 rarSf = 0 ;
#elif TDD_CONFIG
    UInt16 rarSf = 0 ;
#endif
    /* SPR 1827_28_29 Fix End */
    fprintf(stderr,"\n%s Entry \n ",
            __func__);
    /* SPR 1827_28_29 Fix Start */
#ifdef FDD_CONFIG    
    rarQindex = qIndex + 2;
    if (rarQindex >= MAX_SUBFRAME)
    {
        rarQindex -= MAX_SUBFRAME;
    }
    rarSf = sendSfnSf & FAPI_SF_MASK;
    rarSfn = (sendSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT;
    rarSf = rarSf + 2;
    if ( rarSf >= MAX_SUBFRAME )
    {
        rarSf -= MAX_SUBFRAME;
        rarSfn++ ;
        if ( rarSfn == MAX_SFN )
        {
            rarSfn = 0;
        }
    }
    rarSfnSf = ( (rarSfn &  0x0FFF) << FAPI_SFN_VALUE_SHIFT )
        | (rarSf & 0x000F) ;
/* TDD SB_CQI */
#elif TDD_CONFIG
    rarSf = sendSfnSf & FAPI_SF_MASK;
/* TDD SB_CQI */
#endif
    /* SPR 1827_28_29 Fix End */
    if ( PNULL == data_p )
    {
#if 0
        fprintf(stderr,"Error!! fapiProcessRAR: RAR recevied is NULL \n");    
#endif
        return;
    }

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    for ( index = 0; index < dlschPduLength; index++)
    {
        fprintf(stderr,"--- 0x%x\t",data_p[index]);
    }
    fprintf(stderr,"\n");
#endif

    raRspCount =  dlschPduLength / 7;
    /* check for Backoff indicator */
    index = 0;
    firstByte = data_p[index] & 0xFF;
    if ( ! (firstByte & 0x40) ) /* T field is false means BI is present in RAR*/
    {
        backOffInd = (firstByte & 0x0F);
        fprintf(stderr,"Backoff Indicator [%d] received.with RAR...\n",backOffInd);
        index++;
    }

    if ( raRspCount > 1 )
    {
        /* Parse all the RAR headers and store the Preamble in local array */
        firstByte = data_p[index] & 0xFF; 
        while ( firstByte & 0x80 ) /* while E bit is true */
        {
            if ( data_p[index] & 0x1F == PADDING_LCH ) 
            {
                /* End of RAR PDU subheader break out of loop */
                index++;
                break; 
            }
            preamble = firstByte & 0x3F;
            recvPreamble[raRspCount] = preamble;
            raRspCount++;
            index++;
            firstByte = data_p[index] & 0xFF;
        }
        /* now store the T-Crnti value */
        loopCount = raRspCount;
        while ( loopCount-- )
        {
            /* SPR 1824 changes start */    
            /* SPR 1565 changes start */    
            memcpy(&tempCrnti,(data_p+index+4),sizeof(UInt16));
            /* SPR 2140 changes start */
            tempCrnti = ntohs(tempCrnti);            
            /* SPR 2140 changes end */            
            /* SPR 1565 changes end */            
            /* SPR 1824 changes end */            
#ifdef UT_TESTING                              
            /* validate Range of TCrnti */
            if ( tempCrnti <  endRARNTI_g[cellIndex] || tempCrnti > MAX_CRNTI_RANGE )
            {
                fprintf(stderr,"Error!!  tcrnti received  = %d is not in range \n", tempCrnti);
                loopCount--;
                continue;
            }
#endif                                                    
            tcrnti[tcount++] = tempCrnti;
            index += 6;
        }

        /* handing of RAR for multiple preamble will be done later */
        if ( raRspCount > 1 )
        {
            raRntiArr_g[cellIndex][rnti-1].RaRnti = INVALID_RNTI;
            return;
        }
    }
    /* only one RAR received */
    else
    {
        found = FALSE;
        if ( (rnti == raRntiArr_g[cellIndex][rnti - 1].RaRnti) &&
                (WAIT_RAR == raRntiArr_g[cellIndex][rnti - 1].state))
        {
            found = TRUE;
            raReq = raRntiArr_g[cellIndex][rnti - 1];
            fprintf(stderr, "RAR recevied \n");
	    /*RAR_Handling:End*/
        }
        if (FALSE == found)
        {
            fprintf(stderr,"Error!!  preamble received  = %x is not in range \n", preamble);
            return;
        }
        firstByte = data_p[index++] & 0xFF; 
        preamble = firstByte & 0x3F;
        memcpy(&tempCrnti,(data_p+index+4),sizeof(UInt16));
        tempCrnti = ntohs(tempCrnti);            

#ifdef FDD_CONFIG    
        /* + CQI_5.0 */
        DLUEContext *newUEContext_p = PNULL;
        newUEContext_p =  getDLUEContextFromRnti(tempCrnti, cellIndex);
        if( (data_p[index+3]) & 0x01)
        {
            newUEContext_p->dlCQIInfo.aperiodicCQIRequest[rarSf] = TRUE;               
 /*  Aperiodic CQI Changes start*/
        /* set num of bits at that SF ad SFN in a global array */
        /* How o fill here as we dont have DCI field here */
        /* I think no need to fill here */
        /*
        aperiodicCqiCsiFieldArr[sendSFN][sendSF][newUEContext_p->ueIndex] = \
                    dciPdu_p->release10param.sizeOfCqiCsiField;
                    */
 /* Aperiodic CQI Changes End*/
        }    
        /* - CQI_5.0 */
/* TDD SB_CQI */
#elif TDD_CONFIG
        DLUEContext *newUEContext_p = PNULL;
        newUEContext_p =  getDLUEContextFromRnti(tempCrnti, cellIndex);
        if( (data_p[index+3]) & 0x01)
        {
            newUEContext_p->dlCQIInfo.aperiodicCQIRequest[rarSf] = TRUE;
        }
/* TDD SB_CQI */
#endif

        if (  preamble !=  raReq.preamble )
        {
            fprintf(stderr,"preamble recevied %d in RAR is not the one \
                    which was sent" "in RA REQ = %d in cell = %d \n", \
                    preamble, raReq.preamble);
            return;
        }
        /* create CRC for msg3. */
        /* SPR 1827_28_29 Fix Start */
        if ( CONTENTION_BASED_RACH == raReq.rachTypeFlag )
        {
            rntiInfo_p = getRntiInfofromRNTIMap(tempCrnti, cellIndex);
            if ( PNULL == rntiInfo_p )
            {
                fprintf(stderr,"rntiInfo is null for TCRNTI = %d\n", tempCrnti);
                return;
            }
            if(!IS_NB_IOT_CELL(cellIndex))
            {

#ifdef FDD_CONFIG    
            preapreCRCIndication( tempCrnti,rarSfnSf,rarQindex, TRUE , cellIndex);

            fapiCreateAndSendMsg3(tempCrnti, &raReq, rarSfnSf, rarQindex, cellIndex);
#elif  TDD_CONFIG 
            /* SPR 1827_28_29 Fix End */
            preapreCRCIndication( tempCrnti,sendSfnSf,qIndex, TRUE, cellIndex );

            fapiCreateAndSendMsg3(tempCrnti, &raReq, sendSfnSf, qIndex, cellIndex);
            /* SPR 1827_28_29 Fix Start */
#endif   
            /*LTE_REG_FIX*/    
            }
            /* SPR 1827_28_29 Fix End */     
            fprintf(stderr,"Msg3 send tempCrnti [%d]\n",tempCrnti);                                            

            rntiInfo_p->RaRnti = rnti;
            rntiInfo_p->rntiType = FAPI_T_CRNTI;
            rntiInfo_p->rnti = tempCrnti;
	    if (cellConfigUeSim_g[cellIndex].lowerCRNTIBound == startRARNTI_g)
	   {
                 rntiInfo_p->ueIndex = 
			( tempCrnti - endRARNTI_g[cellIndex] - 
			  startRARNTI_g + 1 - cellConfigUeSim_g[cellIndex].lowerCRNTIBound);
	    }
	    else
	   {	
		rntiInfo_p->ueIndex =  ( tempCrnti - cellConfigUeSim_g[cellIndex].lowerCRNTIBound);
       	   }
             /*LTE_REG_FIX*/
            if(!IS_NB_IOT_CELL(cellIndex))
            {
            fprintf(stderr," \n  rntiInfo_p->ueIndex = %d \n", rntiInfo_p->ueIndex);
            rntiInfo_p->state = WAIT_CONTENTION_RESOLUTION;
            raRntiArr_g[cellIndex][rnti - 1].state = WAIT_CONTENTION_RESOLUTION;
        }
        }
        else if ( CONTENTION_FREE_HO_RACH == raReq.rachTypeFlag 
                || CONTENTION_FREE_PDCCH_ORDER_RACH == raReq.rachTypeFlag 
                || CONTENTION_BASED_PDCCH_ORDER_RACH == raReq.rachTypeFlag 
                || CONTENTION_BASED_HO_RACH == raReq.rachTypeFlag )
        {
            ueContextForUplink *ulUEContext_p = getUEContext(raReq.rnti, cellIndex);
            if ( PNULL == ulUEContext_p )
            {
                fprintf(stderr,"ulUEContext_p is null for CRNTI = %d\n", raReq.rnti);
                return;
            }
            dynamicUEContext *ulDynUEContext_p = dynUEContextInfoMap_g[ulUEContext_p->ueIdx];
            rntiInfo_p = getRntiInfofromRNTIMap(raReq.rnti, cellIndex);
            if ( PNULL == rntiInfo_p )
            {
                fprintf(stderr,"rntiInfo is null for CRNTI = %d\n", raReq.rnti);
                return;
            }
            if ( PNULL == ulDynUEContext_p)
            {
                fprintf(stderr,"dynContext is null for CRNTI = %d\n", raReq.rnti);
                return;
            }
#ifdef FDD_CONFIG    
            if ( CONTENTION_FREE_HO_RACH == raReq.rachTypeFlag 
                || CONTENTION_FREE_PDCCH_ORDER_RACH == raReq.rachTypeFlag )
            {
                preapreCRCIndication( raReq.rnti,rarSfnSf,rarQindex, TRUE, cellIndex );
                if(CONTENTION_FREE_HO_RACH == raReq.rachTypeFlag)
                {
                    mcsIndex = mcsIndexHO_g;
                    numRB = numRBHO_g;
                }
                else if(CONTENTION_FREE_PDCCH_ORDER_RACH == raReq.rachTypeFlag)
                {
                    mcsIndex = mcsIndexPdcchOrder_g;
                    numRB = numRBPdcchOrder_g;
                }
                tbSize = determineTBSize(mcsIndex , numRB);
                if (tbSize >= 8) /*ULA_UTP*/
                {
                    ulUEContext_p->bsrPresentFlag = 1;
                    uldataNode_p = fapiGetULDataPduNode (rarQindex, rarSfnSf,
                            raReq.rnti );
                    if ( uldataNode_p == PNULL )
                    {
                        printf("Not able to get memory for ulschDataQueueNode\n");
                        return;
                    }
#if 0
                    fprintf(stderr, "TB Size passed to distributeRBsAndSendReqToRLC is [%d]\n", tbSize);
#endif
                    UInt16 macRetType = 0;
                    macRetType = distributeRBsAndSendReqToRLC(ulUEContext_p->ueIdx,
                            tbSize,
                            ulUEContext_p->bsrPresentFlag,
                            uldataNode_p,
                            &(uldataNode_p->pdudata_p),
                            &(uldataNode_p->pduLen),
                            FALSE
#ifdef FDD_CONFIG
			    ,PNULL
#endif
                ,cellIndex  );
#if 0
                    fprintf(stderr, "\n Recieve data from RLC [%d]\n", macRetType);
#endif
                    if ( MAC_SUCCESS == macRetType )
                    {
                    }
                    else if ( MAC_PARTIAL_SUCCESS == macRetType )
                    {
#if 0
                        fprintf(stderr, "\n Send only Bsr if Q load zero\n");
#endif
                        /*SPR 2499 Start. Suggested by Ashu*/
                        fapiPrepareLongBSRAndPHR(ulDynUEContext_p, 
								ulUEContext_p->crnti, rarSfnSf, rarQindex, 
								uldataNode_p, tbSize, FALSE, cellIndex);
                        /*SPR 2499 End. Sugegsted by Ashu*/

                        /* Memory Leak Fixes */
                        //freeMemPool(uldataNode_p);
                        //uldataNode_p = PNULL;
                        /* Memory Leak Fixes */
                    }
                    else
                    {
                        /* SPR 2417 changes start */
                        freeMemPool(uldataNode_p);
                        uldataNode_p = PNULL;
                        /* SPR 2417 changes end */
                    }
                }
                else
                {
                    uldataNode_p = fapiGetULDataPduNode (rarQindex, rarSfnSf,
                            raReq.rnti );
                    if ( uldataNode_p == PNULL )
                    {
                        printf("Not able to get memory for ulschDataQueueNode\n");
                        return;
                    }
                    /* handling of UL Grant */
					fapiPrepareLongBSRAndPHR(ulDynUEContext_p, 
							ulUEContext_p->crnti, rarSfnSf, rarQindex,
							uldataNode_p, tbSize, FALSE, cellIndex);
                    fprintf(stderr,"prepareLongBSR Sent crnti %d, MAC_FAILURE_FDD \n", ulUEContext_p->crnti);
                }
            }
            else if ( CONTENTION_BASED_PDCCH_ORDER_RACH == raReq.rachTypeFlag 
                      || CONTENTION_BASED_HO_RACH == raReq.rachTypeFlag )
            {
                tbSize = determineTBSize(mcsIndexPreambleGroupB_g, numRBPreambleGroupB_g);
                preapreCRCIndication( tempCrnti,rarSfnSf,rarQindex, TRUE, cellIndex );
                fapiCreateAndSendMsg3withCrntiCE(ulUEContext_p, rarSfnSf, rarQindex,tbSize,rnti,tempCrnti, cellIndex);
            }
#elif TDD_CONFIG
            preapreCRCIndication( raReq.rnti,sendSfnSf,qIndex, TRUE, cellIndex );

            if ( CONTENTION_FREE_HO_RACH == raReq.rachTypeFlag 
                || CONTENTION_FREE_PDCCH_ORDER_RACH == raReq.rachTypeFlag )
            {
                if(CONTENTION_FREE_HO_RACH == raReq.rachTypeFlag)
                {
                    mcsIndex = mcsIndexHO_g;
                    numRB = numRBHO_g;
                }
                else if(CONTENTION_FREE_PDCCH_ORDER_RACH == raReq.rachTypeFlag)
                {
                    mcsIndex = mcsIndexPdcchOrder_g;
                    numRB = numRBPdcchOrder_g;
                }
                tbSize = determineTBSize(mcsIndex , numRB);

                if (tbSize >= 8) /*ULA_UTP*/
                {
                    ulUEContext_p->bsrPresentFlag = 1;
                    uldataNode_p = fapiGetULDataPduNode (qIndex, sendSfnSf,
                            raReq.rnti );
                    if ( uldataNode_p == PNULL )
                    {
                        printf("Not able to get memory for ulschDataQueueNode\n");
                        return;
                    }
#if 0
                    fprintf(stderr, "TB Size passed to distributeRBsAndSendReqToRLC is [%d]\n", tbSize);
#endif
                    UInt16 macRetType = 0;
                    macRetType = distributeRBsAndSendReqToRLC(ulUEContext_p->ueIdx,
                            tbSize,
                            ulUEContext_p->bsrPresentFlag,
                            uldataNode_p,
                            &(uldataNode_p->pdudata_p),
                            &(uldataNode_p->pduLen),
                            FALSE
#ifdef FDD_CONFIG
			    ,PNULL
#endif
                 ,cellIndex );
#if 0
                    fprintf(stderr, "\n Recieve data from RLC [%d]\n", macRetType);
#endif
                    if ( MAC_SUCCESS == macRetType )
                    {
                    }
                    else if ( MAC_PARTIAL_SUCCESS == macRetType )
                    {
#if 0
                        fprintf(stderr, "\n Send only Bsr if Q load zero\n");
#endif
                        /*SPR 2499 Start. Suggested by Ashu*/
                        fapiPrepareLongBSRAndPHR(ulDynUEContext_p,
								ulUEContext_p->crnti , sendSfnSf, qIndex,
								uldataNode_p, tbSize, FALSE, cellIndex);
                        /*SPR 2499 End. Sugegsted by Ashu*/

                        /* Memory Leak Fixes */
                        /* 
                        freeMemPool(uldataNode_p);
                        uldataNode_p = PNULL;
                        */
                        /* Memory Leak Fixes */
                    }
                    else
                    {
                        /* SPR 2417 changes start */
                        freeMemPool(uldataNode_p);
                        uldataNode_p = PNULL;
                        /* SPR 2417 changes end */
                    }
                }
                else
                {
                    uldataNode_p = fapiGetULDataPduNode (qIndex, sendSfnSf,
                            raReq.rnti );
                    if ( uldataNode_p == PNULL )
                    {
                        printf("Not able to get memory for ulschDataQueueNode\n");
                        return;
                    }
                    /* handling of UL Grant */
                    fapiPrepareLongBSRAndPHR(ulDynUEContext_p,
							ulUEContext_p->crnti , sendSfnSf, qIndex, 
							uldataNode_p, tbSize, FALSE, cellIndex);
                    fprintf(stderr," CellIndex [%d], prepareLongBSR Sent crnti\
							%d\n MAC_FAILURE_TDD",cellIndex, ulUEContext_p->crnti);
                }

            }
            else if ( CONTENTION_BASED_PDCCH_ORDER_RACH == raReq.rachTypeFlag 
                      || CONTENTION_BASED_HO_RACH == raReq.rachTypeFlag )
            {
                tbSize = determineTBSize(mcsIndexPreambleGroupB_g, numRBPreambleGroupB_g);
                preapreCRCIndication( raReq.rnti,sendSfnSf,qIndex, TRUE, cellIndex );
                fapiCreateAndSendMsg3withCrntiCE(ulUEContext_p, sendSfnSf, 
						qIndex,tbSize,rnti,tempCrnti, cellIndex);
            }
#endif
            rntiInfo_p->state = UE_ACTIVE;
            ulUEContext_p->resetFlag = FALSE;
            raRntiArr_g[cellIndex][rnti-1].RaRnti = INVALID_RNTI;
        }
    }
}
/****************************************************************************
 * Function Name  : fapiHandleDlData 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
/* CA */ 
void fapiHandleDlData(UInt16 sendSfnSf, FAPI_dlPduInfo_st *dlPdu_p, 
        fapiMsgIdStruct *msgIdArr_p, UInt8 qIndex,
        UInt8 rxCellIndex
        /* CA_NA */ 
#ifdef UESIM_ENHANCEMENTS
        ,UInt32* dlSchPduLen
#endif
        /* SPR 2984 Fix */
#ifdef TDD_CONFIG
        /* + SPR 14001 Changes */
        , UInt16 savedSFN,UInt8 savedSF, UInt8 cellId
        /* - SPR 14001 Changes */
#endif
        /* SPR 2984 Fix */
#ifdef FDD_CONFIG
        , UInt8 recvSF
#endif

        )
{
    UInt32 i = 0;
    /* CA */ 
    UInt8 txCellIndex = 0;
    /* CA */ 
    UInt8 mimoFlag = FALSE;
    /* SPR 1811 Fix Start */    
    static UInt8 flagForMIMO = 0;
    /* SPR 1811 Fix End */
    static UInt16 prevPduRnti = 0;
    static UInt8 ackNackFieldTB1 = FAPI_ACK_OR_NACK;
    static UInt8 ackNackFieldTB2 = FAPI_ACK_OR_NACK;
    UInt16 dlschPduLength = 0;
    UInt8* data_p = PNULL;
    FAPI_dlTLVInfo_st *dlDataTlv_p = PNULL;
    /* SPR 609 changes start */
    //FAPI_dlTLVInfo_st *dlTlv_p = PNULL;
    //UInt8 *ptr = PNULL;
    /* SPR 609 changes end */
    RNTIInfo *rntiInfo_p                = PNULL;
    ueContextForUplink *ueContextInfo_p = PNULL;
#ifdef LTE_EMBMS_SUPPORTED    
    AreaContextInfo* areaContext_p = PNULL;
#endif    
#ifdef TDD_CONFIG
    FAPI_harqIndQueueNode_st *harqNode_p = PNULL;
#endif
    UInt8 sf = 0;
    UInt16 sfn = 0;
    dlDataTlv_p = ( FAPI_dlTLVInfo_st *) &(dlPdu_p->dlTLVInfo[0]);
    if ( PNULL == dlDataTlv_p )
    {
        fprintf(stderr,"\n dlData TLV recevied is NULL \n");
        return;
    }
#if 0
    if ( msgIdArr_p->dlSCHPduCount && !msgIdArr_p->dciPduCount )
    {
        //        fprintf(stderr,"Error...!!!dlsch config PDU recevied without DCI\n");
        return;
    }
    else if (  msgIdArr_p->bchPduCount && msgIdArr_p->dciPduCount )
    {
        //        fprintf(stderr,"Error...!! bch config PDU received with DCI PDU\n");
        return;
    }
    else if ( msgIdArr_p->pchPduCount && msgIdArr_p->dciPduCount) 
    {
        //        fprintf(stderr,"Error...!! pch config PDU received with DCI PDU\n");
        return;
    }
    else
    {
    }
#endif
    if ( msgIdArr_p->dlSCHPduCount )
    {
        /* SISO DL Data or SIB */
        if ( FAPI_SIRNTI == msgIdArr_p->dlSCHPdu.rntiType )
        {
            /* SIB */
        }
        else
        {
            /* DL DATA */
            if ( (FAPI_RA_RNTI == msgIdArr_p->dlSCHPdu.rntiType) && 
                    ( (FAPI_DL_DCI_FORMAT_1 == msgIdArr_p->dlSCHPdu.dciFormat) || 
                      (FAPI_DL_DCI_FORMAT_1A == msgIdArr_p->dlSCHPdu.dciFormat) ) )
            {
                fprintf(stderr, "HARQ for RAR\n");
                /* RAR recevied */
                dlschPduLength = MAC_PHY_CONVERT_16(dlDataTlv_p[i].tagLen);
#ifdef UESIM_ENHANCEMENTS
                *dlSchPduLen = dlschPduLength;
#endif
                data_p = (UInt8 *) &(dlDataTlv_p[i].value[0]);
                /* SPR 2984 Fix */
#ifdef TDD_CONFIG
                /* CA TDD Changes Start */
                qIndex = getMsg3SFandQIndex(&savedSFN, &savedSF, rxCellIndex);
                /* CA TDD Changes End */
                sendSfnSf = GENERATE_SUBFRAME_SFNSF(savedSFN, savedSF);
#endif
                /* SPR 2984 Fix */
                fapiProcessRAR( msgIdArr_p->dlSCHPdu.rnti, dlschPduLength, 
                        data_p, sendSfnSf, qIndex, rxCellIndex );
            }
            else if ( (FAPI_T_CRNTI == msgIdArr_p->dlSCHPdu.rntiType) && 
                    ( (FAPI_DL_DCI_FORMAT_1 == msgIdArr_p->dlSCHPdu.dciFormat) || 
                      (FAPI_DL_DCI_FORMAT_1A == msgIdArr_p->dlSCHPdu.dciFormat) ) )
            {
                fprintf(stderr, "contention recevied HARQ for contention\n");
                /* contention recevied */
                dlschPduLength = MAC_PHY_CONVERT_16(dlDataTlv_p[i].tagLen); 
#ifdef UESIM_ENHANCEMENTS
                *dlSchPduLen = dlschPduLength;
#endif
                data_p = (UInt8 *) &(dlDataTlv_p[i].value[0]);
                fapiProcessContentionMsg( msgIdArr_p->dlSCHPdu.rnti, dlschPduLength,
                        data_p, sendSfnSf, qIndex, rxCellIndex);

            }
            /*!
             * \code
             * 1. if SPS rnti type
             * \endcode
             * */
            else if ( FAPI_SPS_CRNTI == msgIdArr_p->dlSCHPdu.rntiType )
            {
                populateSpsCrnti(msgIdArr_p->dlSCHPdu.rnti, rxCellIndex); 
                rntiInfo_p = getRntiInfofromRNTIMap(msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                if ( PNULL == rntiInfo_p )
                {
                    fprintf(stderr,"in function: fapiHandleDlData rnti info not found" 
                            " for rnti = %d\n", msgIdArr_p->dlSCHPdu.rnti);
                    return;
                }
                /* + SPS_TDD_Changes */
                ueContextInfo_p = getUEContext(msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                /* - SPS_TDD_Changes */
                /*! \code
                 * 2. set the values of variables ueContext_p using function getUEContext
                 * 3. pdu Length from dlDataTlv_p[i].tagLen
                 * 4. and data_p value received from the eNodeB
                 * \endcode
                 * */
                dlschPduLength = MAC_PHY_CONVERT_16(dlDataTlv_p[i].tagLen);
                /* CA_NA */ 
                //txCellIndex = GET_RNTI_TO_CELL_INDEX(rntiInfo_p->rnti);
                GET_RNTI_TO_CELL_INDEX(rntiInfo_p->rnti, txCellIndex);
                /* CA_NA */ 
#ifdef UESIM_ENHANCEMENTS
                *dlSchPduLen = dlschPduLength;
#endif            
                data_p = (UInt8 *) &(dlDataTlv_p[0].value[0]);
                if ( PNULL == data_p  || !dlschPduLength)
                {
                    fprintf(stderr,"Error either data_p is NULL or tagLen %d recevied is ZERO\n",dlschPduLength);
                    return;
                }
                /*! \code
                 * 5. do the following if DCI Format is of type 1 or 1A
                 * \endcode
                 * */
                if((FAPI_DL_DCI_FORMAT_1 == msgIdArr_p->dlSCHPdu.dciFormat) ||
                        (FAPI_DL_DCI_FORMAT_1A == msgIdArr_p->dlSCHPdu.dciFormat) ) 
                {
                    mimoFlag = FALSE;
#ifdef FDD_CONFIG
                    /* +CA */
                    SEND_ACK_NACK_VERIFY(rxCellIndex);
                    /* -CA */
                    /*! \code
                     *   6. check for the HARQ
                     *      6.1 call fn. fapiCheckHarq(mimoFlag,IstTB_INVALID_2ndTB_VALID, &ackNackFieldTB1,&ackNackFieldTB2, msgIdArr_p->dlSCHPdu.rnti)
                     *      6.2 and fn. fapiSendHarqIndication(msgIdArr_p->dlSCHPdu.rnti, sendSfnSf,qIndex,&ackNackFieldTB1,&ackNackFieldTB2)
                     *       6.3 if ackNackFieldTB1 equal to FAPI_ACK
                     *              6.3.1 send the DL SPS PDU to RLC by using
                     *                  fn processDLDemuxData with values data_p, dlschPduLength, rntiInfo_p->ueIndex.
                     * \endcode
                     * */
                    /* SPR 8993 changes start */
                    fapiCheckHarq(TRUE, IstTB_INVALID_2ndTB_VALID,
                            /* SPR 8993 changes start */
                            &ackNackFieldTB1,&ackNackFieldTB2, 
                            msgIdArr_p->dlSCHPdu.rnti,rxCellIndex);
                    /* + CA_TDD_HARQ_CHANGES */    
                    fapiSendHarqIndication(TRUE,msgIdArr_p->dlSCHPdu.rnti, 
                            qIndex,sendSfnSf,&ackNackFieldTB1,&ackNackFieldTB2, rxCellIndex);
                    /* - CA_TDD_HARQ_CHANGES */    
                    /* + SPS_TDD_Changes */

                        /* SPR 20758 fix start */
                        
#elif TDD_CONFIG
                        if ( ueContextInfo_p->ackNackMode != MULTIPLEXING )
                        {
                    /* + SPR 14001 Changes */
                    fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                            &ackNackFieldTB1,&ackNackFieldTB2, rxCellIndex, cellId);
                    /* - SPR 14001 Changes */
                    UInt16 sendSFN = (sendSfnSf & FAPI_SFN_MASK ) >> FAPI_SFN_VALUE_SHIFT;
                    UInt8 sendSF = sendSfnSf & FAPI_SF_MASK;
                    if(!sendAckNack_g[rxCellIndex])
                    {   
                        updateDaiAndBuildDlAckNack( ueContextInfo_p, 
                                sendSFN,
                                sendSF,
                                0xFF, 
                                0,/*DCI_FORMAT_0*/
                                qIndex,
                                TRUE,                   
                                FALSE,
                                /* + CA_TDD_HARQ_CHANGES */
                                savedSF,
                                rxCellIndex
                                /* - CA_TDD_HARQ_CHANGES */
                                );
                    }
                    ackNackFieldTB1= FAPI_ACK;
                    /* - SPS_TDD_Changes */
                        }
#endif

                        /* SPR 20758 fix end */
                    if ( FAPI_ACK == ackNackFieldTB1 )
                    {
                        /* PHASE 2 changes */
                        /*   putDLDataInDemuxQueue(data_p, dlschPduLength, 
                             rntiInfo_p->ueIndex, rxCellIndex,txCellIndex ); 
                             processDLDemuxData( data_p, PNULL,
                             dlschPduLength,rntiInfo_p->ueIndex,
                             txCellIndex);*/
                        /* PHASE 2 changes End*/
                        processDLDemuxData( data_p, PNULL,
                                dlschPduLength,rntiInfo_p->ueIndex,
                                rxCellIndex);
                    }
                }
            }
            else if ( FAPI_C_RNTI == msgIdArr_p->dlSCHPdu.rntiType )
            {
                /* + SPR 11220 Changes */
                rntiInfo_p = getRntiInfofromRNTIMap(msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                /* - SPR 11220 Changes */
                if ( PNULL == rntiInfo_p )
                {
                    fprintf(stderr,"in function: fapiHandleDlData rnti info not found" " for rnti = %d\n", msgIdArr_p->dlSCHPdu.rnti);
                    return;
                }
                /* DL Data Sep Changes */
                /* dlDataTlv_p->tag is populated with RNTI value : Only testing purpose with simulator 
                 * Please take care while updating same */
                if(msgIdArr_p->dlSCHPdu.rnti != dlDataTlv_p->tag) 
                {
#ifdef PRINT
                    fprintf(stderr, "##########  Mismatch in RNTI recvd in DL Config & TxReq : DL_CONFIG_RNTI[%d] TxREQ_RNTI[%d] #########\n", msgIdArr_p->dlSCHPdu.rnti, dlDataTlv_p->tag);
#endif 
                }

                /* send RRC Connection setup or reject Msg to RRC */
                if ((rntiInfo_p->rnti ==  msgIdArr_p->dlSCHPdu.rnti) &&
                        (WAIT_FOR_DL_CCCH_MSG == rntiInfo_p->state))
                {
                    fprintf(stderr, "\nRRC Connection Setup\n");
                    /*RRC Connection Setup or RRC Connection Reject received*/
                    UInt32 extnFlag = FALSE;
                    UInt8  taRcvFlag = FALSE;
                    UInt8  ccchSduRecvd = FALSE;
                    UInt8  lcId     = 0;
                    UInt16 len      = 0;
                    UInt16 headerLen = 0;
                    rrcDataInfo rrcInfo = {0};
                    dlschPduLength = MAC_PHY_CONVERT_16(dlDataTlv_p[i].tagLen); 
                    data_p = (UInt8 *) &(dlDataTlv_p[i].value[0]);

                    /*Demultiplex the data received*/
                    do
                    {
                        lcId = (*data_p & 0x1F);
                        len = 0;
                        /* SPR 4633 Fix Start */
                        if ((lcId >= 1) && (lcId <= 11))
                        {
                            data_p++;
                            headerLen++;
                            //extnFlag = FALSE;
                            break;
                        }
                        /* SPR 4633 Fix End */

                        if (*data_p & UL_PDU_EXTN_FLAG)
                        {
                            extnFlag = TRUE;
                        }
                        else
                        {
                            extnFlag = FALSE;
                        }

                        if (PADDING_LCH == lcId)
                        {
                            data_p++;
                            headerLen++;
                        }
                        /* 31UE attach issue fix */
                        else if (TA_LCID == lcId)
                        {
                            data_p++;
                            headerLen++;
                            taRcvFlag = TRUE;
                        }
                        else if((TRUE == extnFlag) &&
                                (CCCH_LCID == lcId))
                        {
                            ccchSduRecvd = TRUE;
                            data_p++;

                            /*Reffer section 6.1.2 in 36321-850.doc*/
                            if (*data_p & 0x80)
                            {
                                /*length is greater than 128 bytes*/
                                len = *data_p++ & 0x7F;
                                len <<= 8;
                                len |= *data_p;
                            }
                            else
                            {
                                /*length is less than 128 bytes*/
                                len = *data_p & 0x7F;
                            }

                            data_p++;

                            /*check the next LC, if Padding LC present 
                             *skip 1 byte padding LC
                             */
                            lcId = (*data_p & 0x1F);
                            if (PADDING_LCH == lcId)
                            {
                                data_p++;
                            }

                            rrcInfo.dataLen  = len;
                            rrcInfo.rnti     = rntiInfo_p->rnti;
                            rrcInfo.buffer_p = data_p;
#ifdef FDD_CONFIG
                            /* +CA */
                            SEND_ACK_NACK_VERIFY(rxCellIndex);
                            /* -CA */
                            /* SPR 2234 Fix Begin*/
                            /* SPR 8993 changes start */
                            fapiCheckHarq(TRUE,SISO_CASE,
                                    /* SPR 8993 changes start */
                                    &ackNackFieldTB1,&ackNackFieldTB2,
                                    msgIdArr_p->dlSCHPdu.rnti,rxCellIndex);
                            /* SPR 2234 Fix End*/
#elif TDD_CONFIG
#if 0
                            fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                                    &ackNackFieldTB1,&ackNackFieldTB2);

#endif
#endif
                            /* SPR 11123 changes start */
                            ackNackFieldTB1 = FAPI_ACK;
                            /* SPR 11123 changes end */
                            if (FAPI_ACK == ackNackFieldTB1 )
                            {
                                fprintf(stderr, "HARQ for RRC connection SetUP message\n");

#ifdef FDD_CONFIG
                                /* send HARQ Indication */
                                /* + SPR 22848 */
                                {
                                    FAPI_harqIndQueueNode_st *msg5Ack_p = (FAPI_harqIndQueueNode_st *) 
                                        getMemFromPool(sizeof(FAPI_harqIndQueueNode_st),PNULL);

                                    if ( PNULL == msg5Ack_p )
                                    {
                                        fprintf(stderr,"Not able to get memory for DL ACK NACK packet in" "Contention resolution ACK\n");
                                        return;
                                    }
                                    msg5Ack_p->sfnsf = sendSfnSf;
                                    msg5Ack_p->harqPduInfo.rnti = MAC_PHY_CONVERT_16(msgIdArr_p->dlSCHPdu.rnti); 
#ifndef FAPI_4_0_COMPLIANCE
                                    msg5Ack_p->harqPduInfo.harqTB1 = FAPI_ACK;
#else
#if (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                                    msg5Ack_p->harqPduInfo.release9Param.HARQTB[0] = FAPI_ACK;
                                    msg5Ack_p->harqPduInfo.release9Param.numOfAckNack = 1;
                                    msg5Ack_p->harqPduInfo.release9Param.mode = 1;
#else
                                    msg5Ack_p->harqPduInfo.release8Param.harqTB1 = FAPI_ACK;
#endif
#endif
                                    pushNode(&(harqQueue[rxCellIndex][qIndex]), &(msg5Ack_p->harqNodeAnchor) );
                                    fprintf(stderr,"##################################"
                                            "Contention Ack SfnSf [%d],qIndex[%d]\n\n",
                                            sendSfnSf,qIndex);
                                }
#endif
                                fprintf(stderr,"RRC_CONNECTION_SETUP msg sent to RRC\n");
                                sendMsgToRRC(RRC_CONNECTION_SETUP, 
                                        (void *)(&rrcInfo),
                                        PNULL, PNULL,rxCellIndex);
                            }
                            else
                            {
                                fprintf(stderr,"setup is running for NACK case\n");
                            }


                            break;
                        }
                        else if (CCCH_LCID == lcId)
                        {
                            ccchSduRecvd = TRUE;
                            data_p++;
                            headerLen++;
                            if (dlschPduLength > headerLen)
                            {
                                len = dlschPduLength - headerLen;

                                rrcInfo.dataLen  = len;
                                rrcInfo.rnti     = rntiInfo_p->rnti;
                                rrcInfo.buffer_p = data_p;
#ifdef FDD_CONFIG
                                /* +CA */
                                SEND_ACK_NACK_VERIFY(rxCellIndex);
                                /* -CA */
                                /* SPR 2234 Fix Begin*/
                                /* SPR 8993 changes start */
                                fapiCheckHarq(TRUE,SISO_CASE,
                                        /* SPR 8993 changes end */
                                        &ackNackFieldTB1,&ackNackFieldTB2, 
                                        msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                                /* SPR 2234 Fix End*/
#elif TDD_CONFIG
#if 0
                                fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                                        &ackNackFieldTB1,&ackNackFieldTB2);
#endif
#endif
                                /* SPR 11123 changes start */
                                ackNackFieldTB1 = FAPI_ACK;
                                /* SPR 11123 changes end */
                                if (FAPI_ACK == ackNackFieldTB1 )
                                {
                                    fprintf(stderr, "1.. HARQ for RRC connection SetUP message\n");
#ifdef FDD_CONFIG									
                                    /* send HARQ Indication */
                                    /* + CA_TDD_HARQ_CHANGES */    
                                    fapiSendHarqIndication(TRUE,msgIdArr_p->dlSCHPdu.rnti, 
                                            /* SPR 609 changes start */
                                            qIndex,sendSfnSf,&ackNackFieldTB1,&ackNackFieldTB2,
                                            rxCellIndex);
                                    /* - CA_TDD_HARQ_CHANGES */    
                                    /* SPR 609 changes end */
#elif TDD_CONFIG
#if 0
                                    sendDlAckNack( sendSfnSf,
                                            msgIdArr_p->dlSCHPdu.rnti,
                                            qIndex
                                            );
#endif                          

#endif

                                    fprintf(stderr," 1...RRC_CONNECTION_SETUP msg sent to RRC\n");
                                    sendMsgToRRC(RRC_CONNECTION_SETUP, 
                                            (void *)(&rrcInfo),
                                            PNULL, PNULL, rxCellIndex);
                                }
                                else
                                {
                                    fprintf(stderr,"setup is running for NACK case\n");
                                }

                            }
                            else
                            {
                                fprintf(stderr, "Invalid dlsch pdu length = %d\n", dlschPduLength);
                            }
                            break;
                        }
                    }while(TRUE == extnFlag);


                    if ( taRcvFlag && !ccchSduRecvd) 
                    {
                        return;
                    }

                    raRntiArr_g[rxCellIndex][rntiInfo_p->RaRnti - 1].RaRnti = INVALID_RNTI;
                    raRntiArr_g[rxCellIndex][rntiInfo_p->RaRnti - 1].rrcConReqLen = 0;
                    raRntiArr_g[rxCellIndex][rntiInfo_p->RaRnti - 1].state = 0;

                    rntiInfo_p->state = UE_NOT_ADDED;


#ifdef TDD_CONFIG
                    /* send HARQ Indication */
                    sendDlAckNack( sendSfnSf,
                            msgIdArr_p->dlSCHPdu.rnti,
                            qIndex
                            ,rxCellIndex
                            );

#endif                            
                    return;
                }

                /*Reestablishment fix, using msgIdArr_p->dlSCHPdu.rnti insted of rntiInfo_p->rnti to get ue context*/
                /* + SPR 11220 Changes */
                /* + SPR 11347 Changes */
                //ueContextInfo_p = getUEContext(msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                GET_RNTI_TO_CELL_INDEX(msgIdArr_p->dlSCHPdu.rnti, txCellIndex)
                    ueContextInfo_p = getUEContext(msgIdArr_p->dlSCHPdu.rnti, txCellIndex);
                //ueContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(rntiInfo_p->rnti), txCellIndex); 
                /* - SPR 11347 Changes */
                /* - SPR 11220 Changes */
                if ( ueContextInfo_p == PNULL )
                {
                    fprintf(stderr,"in function: fapiHandleDlData UE Context does not" 
                            "exist for crnti = %d,ueIndex = %d\n", msgIdArr_p->dlSCHPdu.rnti,rntiInfo_p->ueIndex);
                    return ;
                }

                /* HD FDD Changes Start */ 
#ifdef FDD_CONFIG
#ifdef HD_FDD_CONFIG
                if((ueContextInfo_p != NULL) && (TRUE == ueContextInfo_p->isHDFddFlag))
                {
                    if(!isDLScheduledForHDFddUe(ueContextInfo_p->ueIdx, recvSF, TRUE, rxCellIndex))
                    {
                        /* SPR 15909 fix start */
                        fprintf(stderr," [%llu] DL drop UE:%d \n",getCurrentglobaltick(),ueContextInfo_p->ueIdx);
                        /* SPR 15909 fix start */
                        return;
                    }
                    //fprintf(stderr," [%d] DL Data UE:%d  recvSF = %d,  \n", getCurrentglobaltick(),ueContextInfo_p->ueIdx, recvSF );
                }
#endif
#endif
                /* HD FDD Changes End */

                dlschPduLength = MAC_PHY_CONVERT_16(dlDataTlv_p[i].tagLen); 
#ifdef UESIM_ENHANCEMENTS
                *dlSchPduLen = dlschPduLength;
#endif            
                data_p = (UInt8 *) &(dlDataTlv_p[0].value[0]);
                if ( PNULL == data_p  || !dlschPduLength)
                {
                    fprintf(stderr,"Error either data_p is NULL or tagLen %d "
                            "recevied is ZERO\n",dlschPduLength);
                    return;
                }
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"calling demux data function %x dataLen = %d\n", *data_p, dlschPduLength);
#endif

                if ( (FAPI_DL_DCI_FORMAT_2 == msgIdArr_p->dlSCHPdu.dciFormat) ||
                        (FAPI_DL_DCI_FORMAT_2A == msgIdArr_p->dlSCHPdu.dciFormat)||
                        /* + TM7_8 Changes Start */
                        (FAPI_DL_DCI_FORMAT_2B == msgIdArr_p->dlSCHPdu.dciFormat)
                        /* - TM7_8 Changes End */
                   ) 
                {
                    if ( msgIdArr_p->dlSCHPdu.tb1Valid && msgIdArr_p->dlSCHPdu.tb2Valid )
                    {
                        /* SPR 1811 Fix Start */    
                        if ( 0 == prevPduRnti && !flagForMIMO)
                        { 
                            flagForMIMO = 1;
                            /* SPR 1811 Fix End */
                            prevPduRnti = msgIdArr_p->dlSCHPdu.rnti;

#ifdef FDD_CONFIG
                            /* +CA_NA */
                            SEND_ACK_NACK_VERIFY(rxCellIndex);
                            /* -CA_NA */

                            /* SPR 8993 changes start */
                            fapiCheckHarq(FALSE,BOTH_TB_VALID,
                                    /* SPR 8993 changes end */
                                    &ackNackFieldTB1,&ackNackFieldTB2, 
                                    msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                            /* SPR 8993 changes end */

                            /* SPR 1811 Fix Start */    
                            /* + CA_TDD_HARQ_CHANGES */    
                            fapiSendHarqIndication(FALSE,msgIdArr_p->dlSCHPdu.rnti,
                                    qIndex,sendSfnSf,&ackNackFieldTB1,&ackNackFieldTB2,
                                    rxCellIndex);
                            /* SPR 1811 Fix End */
                            /* - CA_TDD_HARQ_CHANGES */    
#elif TDD_CONFIG
                            /* + SPR 14001 Changes */
                            fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                                    &ackNackFieldTB1,&ackNackFieldTB2, rxCellIndex, cellId);
                            /* - SPR 14001 Changes */
#endif
                            if ( FAPI_ACK == ackNackFieldTB1 )
                            {
                                /* PHASE 2 changes Start*/
                                /*putDLDataInDemuxQueue(data_p, dlschPduLength, 
                                  rntiInfo_p->ueIndex, rxCellIndex,txCellIndex );
                                  processDLDemuxData( data_p, PNULL,
                                  dlschPduLength, rntiInfo_p->ueIndex,
                                  rxCellIndex,txCellIndex); */
                                /* PHASE 2 changes End*/
                                processDLDemuxData( data_p, PNULL,
                                        dlschPduLength,rntiInfo_p->ueIndex,
                                        rxCellIndex);
                            }
                            return;
                        }
                        /* SPR 1811 Fix Start */    
                        else
                        {
                            prevPduRnti = msgIdArr_p->dlSCHPdu.rnti;  

                            flagForMIMO = 0;
                        }
                        /* SPR 1811 Fix End */

                        if ( prevPduRnti == msgIdArr_p->dlSCHPdu.rnti)
                        {
                            mimoFlag = TRUE;
                            /* send HARQ Indication */
#ifdef FDD_CONFIG
                            /* +CA_NA */
                            SEND_ACK_NACK_VERIFY(rxCellIndex);				
                            /* -CA_NA */
                            /*SPR 8993 changes start*/
                            fapiCheckHarq(TRUE,BOTH_TB_VALID,
                                    &ackNackFieldTB1,&ackNackFieldTB2, 
                                    msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                            /*SPR 8993 changes end*/  
                            /* SPR 2234 Fix End*/
#elif TDD_CONFIG
                            /* RPT suggestion */
#if 1
                            /* + SPR 14001 Changes */
                            fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                                    &ackNackFieldTB1,&ackNackFieldTB2, rxCellIndex, cellId);
                            /* - SPR 14001 Changes */
#endif
#endif									
                            if ( FAPI_ACK == ackNackFieldTB2 )
                            {
                                /* PHASE 2 changes Start*/
                                /*putDLDataInDemuxQueue(data_p, dlschPduLength, 
                                  rntiInfo_p->ueIndex, rxCellIndex,txCellIndex );
                                  processDLDemuxData( data_p, PNULL,
                                  dlschPduLength, rntiInfo_p->ueIndex,
                                  rxCellIndex, txCellIndex);
                                  */
                                /* PHASE 2 changes End*/
                                processDLDemuxData( data_p, PNULL,
                                        dlschPduLength,rntiInfo_p->ueIndex,
                                        rxCellIndex);
                            }
                            prevPduRnti = 0;
                        }
                    }
                    else if ( msgIdArr_p->dlSCHPdu.tb1Valid && !msgIdArr_p->dlSCHPdu.tb2Valid)
                    {
                        mimoFlag = TRUE;
#ifdef FDD_CONFIG						
                        /* +CA */
                        SEND_ACK_NACK_VERIFY(rxCellIndex);
                        /* -CA */
                        /* SPR 2234 Fix Begin*/
                        /* SPR 8993 changes start */
                        fapiCheckHarq(TRUE,IstTB_VALID_2ndTB_INVALID,
                                /* SPR 8993 changes end */
                                &ackNackFieldTB1,&ackNackFieldTB2, 
                                msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                        /* SPR 2234 Fix End*/
                        /* send HARQ Indication */
                        /* + CA_TDD_HARQ_CHANGES */  
                        /*SPR 20019 +*/
                        ackNackFieldTB2 = FAPI_ACK_OR_NACK;
                        /*SPR 20019 -*/
                        fapiSendHarqIndication(TRUE,msgIdArr_p->dlSCHPdu.rnti,
                                /* SPR 609 changes start */
                                qIndex,sendSfnSf,&ackNackFieldTB1,&ackNackFieldTB2,
                                rxCellIndex);
                        /* - CA_TDD_HARQ_CHANGES */    
                        /* SPR 609 changes end */
#elif TDD_CONFIG
                        /* + SPR 14001 Changes */
                        fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                                &ackNackFieldTB1,&ackNackFieldTB2, rxCellIndex, cellId);
                        /* - SPR 14001 Changes */
#endif								
                        if ( FAPI_ACK == ackNackFieldTB1 )
                        {
                            /* PHASE 2 changes */
                            /*        putDLDataInDemuxQueue(data_p, dlschPduLength, 
                                      rntiInfo_p->ueIndex, rxCellIndex,txCellIndex );
                                      processDLDemuxData( data_p, PNULL,
                                      dlschPduLength, rntiInfo_p->ueIndex,
                                      rxCellIndex,txCellIndex);*/
                            /* PHASE 2 changes End*/
                            processDLDemuxData( data_p, PNULL,
                                    dlschPduLength,rntiInfo_p->ueIndex,
                                    rxCellIndex);
                        }
                    }
                    else if ( !msgIdArr_p->dlSCHPdu.tb1Valid && msgIdArr_p->dlSCHPdu.tb2Valid)
                    {
                        mimoFlag = TRUE;
#ifdef FDD_CONFIG
                        /* +CA */
                        SEND_ACK_NACK_VERIFY(rxCellIndex);
                        /* -CA */
                        /* SPR 2234 Fix Begin*/
                        /* SPR 8993 changes start */
                        fapiCheckHarq(TRUE,IstTB_INVALID_2ndTB_VALID,
                                /* SPR 8993 changes end */
                                &ackNackFieldTB1,&ackNackFieldTB2, 
                                msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                        /* SPR 2234 Fix End*/
                        /* send HARQ Indication */
                        /* + CA_TDD_HARQ_CHANGES */   
                        /*SPR 20019 +*/
                        ackNackFieldTB1 = FAPI_ACK_OR_NACK;
                        /*SPR 20019 - */
                        fapiSendHarqIndication(TRUE,msgIdArr_p->dlSCHPdu.rnti,
                                /* SPR 609 changes start */
                                qIndex,sendSfnSf,&ackNackFieldTB1,&ackNackFieldTB2,
                                rxCellIndex);
                        /* - CA_TDD_HARQ_CHANGES */    
                        /* SPR 609 changes end */
#elif TDD_CONFIG
                        /* + SPR 14001 Changes */
                        fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                                &ackNackFieldTB1,&ackNackFieldTB2, rxCellIndex, cellId);
                        /* - SPR 14001 Changes */
#endif								
                        if ( FAPI_ACK == ackNackFieldTB2 )
                        {
                            /* PHASE 2 changes End*/
                            /*        putDLDataInDemuxQueue(data_p, dlschPduLength, 
                                      rntiInfo_p->ueIndex, rxCellIndex,txCellIndex );
                                      processDLDemuxData( data_p, PNULL,
                                      dlschPduLength, rntiInfo_p->ueIndex,
                                      rxCellIndex,txCellIndex); */
                            /* PHASE 2 changes End*/
                            processDLDemuxData( data_p, PNULL,
                                    dlschPduLength,rntiInfo_p->ueIndex,
                                    rxCellIndex);
                        }

                    }
                    else
                    {
                        fprintf(stderr,"Error !! either of TB shpuld be valid in MIMO case"
                                "Wrong case shouldn't come here\n");
                    }

                }
                else
                {
                    mimoFlag = FALSE;
#ifdef FDD_CONFIG					
                    /* +CA_NA */
                    SEND_ACK_NACK_VERIFY(rxCellIndex);
                    /* -CA_NA */
                    /* SPR 2234 Fix Begin*/
                    /*SPR 8993 changes start*/
                    fapiCheckHarq(TRUE,IstTB_INVALID_2ndTB_VALID,
                            /*SPR 8993 changes end*/  
                            &ackNackFieldTB1,&ackNackFieldTB2, 
                            msgIdArr_p->dlSCHPdu.rnti, rxCellIndex);
                    /* SPR 2234 Fix End*/
                    /* send HARQ Indication */
                    /* + CA_TDD_HARQ_CHANGES */    
                    fapiSendHarqIndication(TRUE,msgIdArr_p->dlSCHPdu.rnti,
                            /* SPR 609 changes start */
                            qIndex,sendSfnSf,&ackNackFieldTB1,&ackNackFieldTB2,
                            rxCellIndex);
                    /* - CA_TDD_HARQ_CHANGES */    
                    /* SPR 609 changes end */
#elif TDD_CONFIG
                    /* + SPR 14001 Changes */
                    fapiCheckTddHarq(sendSfnSf, msgIdArr_p->dlSCHPdu.rnti,
                            &ackNackFieldTB1,&ackNackFieldTB2, rxCellIndex, cellId);
                    /* - SPR 14001 Changes */
#endif							
                    if ( FAPI_ACK == ackNackFieldTB1 )
                    {
                        /* PHASE 2 changes */
                        /*                            putDLDataInDemuxQueue(data_p, dlschPduLength, 
                                                      rntiInfo_p->ueIndex, rxCellIndex,txCellIndex );
                                                      processDLDemuxData( data_p, PNULL,
                                                      dlschPduLength, rntiInfo_p->ueIndex, 
                                                      rxCellIndex,txCellIndex); */
                        /* PHASE 2 changes End*/
                        processDLDemuxData( data_p, PNULL,
                                dlschPduLength,rntiInfo_p->ueIndex,
                                rxCellIndex);
                    }

                }
                /*phase-3 changes start*/
                ueContextInfo_p->carrierAggrConfig.scellInfo[rxCellIndex].scellDeactivationExpirytti = \
                                                                                                       ueContextInfo_p->carrierAggrConfig.scellDeactivationTimer + getCurrentglobaltick();
                /*phase-3 changes end*/ 
            }
        }
    }
    else if ( msgIdArr_p->bchPduCount )
    {
        /* broad cast pdu received */
    }
    else if ( msgIdArr_p->pchPduCount )
    {
        /* paging PDU recevied */
        rrcDataInfo rrcInfo = {0};
        //fprintf(stderr, "PCH Pdu Received\n");
        //fprintf(stderr, "PUD Length is : %d\n", msgIdArr_p->pch.pchPduLen);
        sfn = sendSfnSf >> 4;
        sf =  sendSfnSf & 0x000f;
        //            fprintf(stderr, "at SFN/SF %d \n ", sendSfnSf);
        //fprintf(stderr, "at SFN %d & SF %d \n", sfn , sf);
        rrcInfo.dataLen  = dlDataTlv_p[i].tagLen;
        rrcInfo.rnti     = 0xFFFE;
        rrcInfo.buffer_p = (UInt8 *) &(dlDataTlv_p[i].value[0]);

        sendMsgToRRC(MAC_PCCH_MSG_IND,
                (void *)(&rrcInfo),
                PNULL, PNULL, rxCellIndex);
    }
#ifdef LTE_EMBMS_SUPPORTED
    else if(msgIdArr_p->mchPduCount)
    {
        areaContext_p = getAreaInfo(msgIdArr_p->mchPdu.mchAreaId, rxCellIndex);
        if ( PNULL == areaContext_p )
        {
            fprintf(stderr,"in function: Area info not found" 
                    " for areaId  = %d\n", msgIdArr_p->mchPdu.mchAreaId);
            return;
        }
        /*! \code
         * 2. set the values of variables ueContext_p using function getUEContext
         * 3. pdu Length from dlDataTlv_p[i].tagLen
         * 4. and data_p value received from the eNodeB
         * \endcode
         * */
        dlschPduLength = MAC_PHY_CONVERT_16(dlDataTlv_p[i].tagLen);

#ifdef UESIM_ENHANCEMENTS
        *dlSchPduLen = dlschPduLength;
#endif            
        data_p = (UInt8 *) &(dlDataTlv_p[0].value[0]);
        if ( PNULL == data_p  || !dlschPduLength)
        {
            fprintf(stderr,"Error either data_p is NULL or tagLen %d recevied is ZERO\n",dlschPduLength);
            return;
        }
        processMBMSDemuxData( data_p, PNULL,
                        dlschPduLength,areaContext_p->areaIndex,
                        rxCellIndex);


    }
#endif    

}
/* CA_START_UP_PHASE_2 */
/****************************************************************************
 * Function Name  :  processDlSchPduForAllCells 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
void processDlSchPduForAllCells(UInt16 sendSfnSf, fapiMsgIdStruct *msgIdArr_p, UInt8 qIndex
#ifdef UESIM_ENHANCEMENTS
           ,UInt32 dlSchPduLen
#endif
#ifdef TDD_CONFIG
           ,UInt16 savedSFN, UInt8 savedSF
#else
           , UInt8 recvSF
#endif
           , UInt8 rxCellIndex
        )
{
    UInt8 cellId = 0;
    FAPI_dlPduInfo_st *dlSchPdu_p = PNULL;
    /* SPR 11995 Changes Start */
    FAPI_dlRecvDataInfo_st  *dlDataInfo_p = PNULL;
    UInt16 recvSfnSf = 0, recvSFN = 0;
    /* SPR 11995 Changes End */

    eventFD_t tempfd[MAX_NUM_CELLS][MAX_NUM_CELLS] = {0};
    UInt8 scellPduCount[MAX_NUM_CELLS] = {0,0};
    fapiMsgIdStruct *msgIdxArr_p =PNULL;
    ueContextForUplink   *ueContextInfo_p  = PNULL;
    FAPI_dlTLVInfo_st *dlDataTlv_p = PNULL;

    for (cellId = 0 ; cellId < numCells_g; cellId++)
    {
        if (cellId == rxCellIndex)
            continue;
        /*CA multi-thread sync fix Start*/
#ifdef UESIM_MULTI_THREAD_CELL
        /* + SPR_11907_11908 */
        if (FAPI_RUNNING == phyState_g[cellId] && (phyState_g[rxCellIndex] == FAPI_RUNNING))
        {
            isEvFdRead[rxCellIndex] = 1;      
            eventfd_read_wrapper(ev_fd_g[rxCellIndex][cellId],&tempfd[rxCellIndex][cellId]);
            isEvFdRead[rxCellIndex] = 0;      
        }
        /* - SPR_11907_11908 */ 
#endif

        scellPduCount[cellId] = circQueueCount(&dlSchPduQ[rxCellIndex].DlDataCircQ[cellId]);
        if (scellPduCount[cellId])
        {
            /* eventfd_read_wrapper(ev_fd_g[rxCellIndex][cellId],&tempfd[rxCellIndex][cellId]);*/
            /*CA multi-thread sync fix End*/
            msgIdxArr_p = (fapiMsgIdStruct *)getMemFromPool(sizeof(fapiMsgIdStruct),PNULL);
            /** SPR 11348 Changes Start **/
            memSet(msgIdxArr_p,0,sizeof(fapiMsgIdStruct));
            /** SPR 11348 Changes End **/
            /* SPR 11995 Changes Start */
            popNodeCircQ(&(dlSchPduQ[rxCellIndex].DlDataCircQ[cellId]), (void *) &dlDataInfo_p);
            if(dlDataInfo_p != PNULL)
            {
                dlSchPdu_p =(FAPI_dlPduInfo_st*)(((FAPI_dlRecvDataInfo_st *)dlDataInfo_p)->data_p);
                recvSfnSf = ((FAPI_dlRecvDataInfo_st *)dlDataInfo_p)->recvSfnSf;
                freeMemPool(dlDataInfo_p);
                dlDataInfo_p = PNULL;
            }
            /* SPR 11995 Changes End */
            //fprintf(stderr,"\n Nidhi Pop node rxCellIndex = %d scellPduCount[%d] = %d is", rxCellIndex,cellId, scellPduCount[cellId]); 
            /* UESIM PHASE 2 FIX START*/
            if (dlSchPdu_p != PNULL)
            {
                while(0xFFFF != dlSchPdu_p->pduIndex)
                {

                    UInt8 index = 0;
                    // fprintf(stderr,"\n Nidhi inside while in [%s]",__func__);
                    /*Multi Ue/TTi fix start*/
                    dlDataTlv_p = ( FAPI_dlTLVInfo_st *) &(dlSchPdu_p->dlTLVInfo[0]);
                    ueContextInfo_p  = getUEContext(dlDataTlv_p->tag, rxCellIndex);

                    /*Added handling in case ueContextInfo_p is NULL start*/       
                    if(!ueContextInfo_p)
                    {
                        popNodeCircQ(&(dlSchPduQ[rxCellIndex].DlDataCircQ[cellId]),(void *)&dlDataInfo_p);
                        if(dlDataInfo_p != PNULL)
                        {
                            dlSchPdu_p =(FAPI_dlPduInfo_st*)(((FAPI_dlRecvDataInfo_st *)dlDataInfo_p)->data_p);
                            recvSfnSf = ((FAPI_dlRecvDataInfo_st *)dlDataInfo_p)->recvSfnSf;
                            freeMemPool(dlDataInfo_p);
                            dlDataInfo_p = PNULL;
                        }
                        else
                        {
                            break;
                        }
                            continue;
                    }
                    /* + SPR 14177 Changes */
#ifdef TDD_CONFIG        
#if 0                    
                    else  if(ueContextInfo_p->carrierAggrConfig.scellCount == 0)//rajni
                    {
                        popNodeCircQ(&(dlSchPduQ[rxCellIndex].DlDataCircQ[cellId]),(void *)&dlDataInfo_p);
                        if(dlDataInfo_p != PNULL)
                        {
                            dlSchPdu_p =(FAPI_dlPduInfo_st*)(((FAPI_dlRecvDataInfo_st *)dlDataInfo_p)->data_p);
                            recvSfnSf = ((FAPI_dlRecvDataInfo_st *)dlDataInfo_p)->recvSfnSf;
                            freeMemPool(dlDataInfo_p);
                            dlDataInfo_p = PNULL;
                        }
                    }
#endif                    
#endif                    
                    /* - SPR 14177 Changes */
                    /*Added handling in case ueContextInfo_p is NULL end*/       
                    msgIdxArr_p->dlSCHPduCount = scellDlSchInfo[rxCellIndex][cellId][ueContextInfo_p->ueIdx].dlSCHPduCount;
                    msgIdxArr_p->dlSCHPdu.rnti = scellDlSchInfo[rxCellIndex][cellId][ueContextInfo_p->ueIdx].rnti;
                    msgIdxArr_p->dlSCHPdu.rntiType = scellDlSchInfo[rxCellIndex][cellId][ueContextInfo_p->ueIdx].rntiType;
                    msgIdxArr_p->dlSCHPdu.dciFormat = scellDlSchInfo[rxCellIndex][cellId][ueContextInfo_p->ueIdx].dciFormat;
                    /* SPR 12832 FIX start, fetching tb1Valid and tb2Valid */
                    msgIdxArr_p->dlSCHPdu.tb1Valid = scellDlSchInfo[rxCellIndex][cellId][ueContextInfo_p->ueIdx].tb1Valid;
                    msgIdxArr_p->dlSCHPdu.tb2Valid = scellDlSchInfo[rxCellIndex][cellId][ueContextInfo_p->ueIdx].tb2Valid;
                    /* SPR 12832 FIX end*/
                    index++;
                    /* SPR 11995 Changes Start */
#ifdef FDD_CONFIG
                    /* Calculated the SFN-SF from the one received in the DL-Data which is popped */
                    /* This case will occur for FDD only */
                    recvSFN = recvSfnSf & FAPI_SFN_MASK;
                    recvSFN >>= FAPI_SFN_VALUE_SHIFT;
                    recvSF = recvSfnSf & FAPI_SF_MASK;
                    qIndex = recvSF + 4  + PEER_MAC_DELAY;
                    if (qIndex >= MAX_SUBFRAME)
                    {
                        qIndex -= MAX_SUBFRAME;
                    }
                    recvSF += 4; 
                    if ( recvSF >= MAX_SUBFRAME )
                    {
                        recvSF -= MAX_SUBFRAME;
                        recvSFN++ ;
                        if ( recvSFN == MAX_SFN )
                        {
                            recvSFN = 0;
                        }
                    }
                    sendSfnSf = ( ( recvSFN & 0x0FFF) << FAPI_SFN_VALUE_SHIFT )
                        | ( recvSF & FAPI_SF_MASK ) ;
                    /* SPR 11995 Changes End */
/* + SPR 14002 Changes */
#else
                    /** SPR 14273 Changes Start **/
                    savedSFN = recvSfnSf & FAPI_SFN_MASK;
                    savedSFN >>= FAPI_SFN_VALUE_SHIFT;
                    savedSF = recvSfnSf & FAPI_SF_MASK;
                    /** SPR 14273 Changes End **/
                    qIndex = calPdschQIdxSFNAndSF( &savedSFN, &savedSF, 0, cellId);

                    sendSfnSf = GENERATE_SUBFRAME_SFNSF(savedSFN, savedSF) ;
/* - SPR 14002 Changes */
#endif

                    /*Multi Ue/TTi fix end*/ 
                    fapiHandleDlData(sendSfnSf, dlSchPdu_p,
                            /** SPR 11348 Changes Start **/
                            msgIdxArr_p, qIndex
                            , rxCellIndex 
                            /** SPR 11348 Changes End **/
#ifdef UESIM_ENHANCEMENTS
                            ,&dlSchPduLen
#endif                
#ifdef TDD_CONFIG
                            , savedSFN, savedSF
/* + SPR 14001 Changes */
                            ,cellId
/* - SPR 14001 Changes */
#else
                            , recvSF
#endif
                            );
                    /* SPR 11995 Changes Start */
                    popNodeCircQ(&(dlSchPduQ[rxCellIndex].DlDataCircQ[cellId]),(void *)&dlDataInfo_p);
                    if(dlDataInfo_p != PNULL)
                    {
                        dlSchPdu_p =(FAPI_dlPduInfo_st*)(((FAPI_dlRecvDataInfo_st *)dlDataInfo_p)->data_p);
                        recvSfnSf = ((FAPI_dlRecvDataInfo_st *)dlDataInfo_p)->recvSfnSf;
                        freeMemPool(dlDataInfo_p);
                        dlDataInfo_p = PNULL;
                    }
                    else
                    {
                        break;
                    }
                }
                if(dlSchPdu_p)
                {
                    freeMemPool(dlSchPdu_p);
                }
                /* SPR 11995 Changes End */
                dlSchPdu_p = PNULL;
                /* UESIM PHASE 2 FIX END*/
            }
            /** SPR 11348 Changes Start **/
            freeMemPool(msgIdxArr_p);
            msgIdxArr_p = PNULL;
            /** SPR 11348 Changes End **/
        }
    }
}
/* CA_START_UP_PHASE_2 */
/****************************************************************************
 * Function Name  :  fapiHandlePhyDlTxRequest 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : This function is the entry point for parsing of DL TX.Req  
 *                  Msg recv from peer MAC.
 ****************************************************************************/
//TA: NON_SS
/* CA */ 
void fapiHandlePhyDlTxRequest (FAPI_l1ApiMsg_st *l1RcvMsg_p, 
        fapiMsgIdStruct *msgIdArr_p, UInt8 rxCellIndex)
/* CA */ 
{
    UInt8 *PhyDlTxresp_p = PNULL;
    UInt32 PhyDlTxresp_size = 0;
    FAPI_dlDataTxRequest_st *dlDataTxReq_p = PNULL;
    FAPI_dlPduInfo_st       *dlPdu_p = PNULL;
    /* SPR 11995 Changes Start */
    FAPI_dlRecvDataInfo_st  *dlDataInfo_p = PNULL;
    /* SPR 11995 Changes End */
    UInt16 recvSFN = 0, numOfDlDataPdu = 0, recvSfnSf = 0;
    UInt16 currentSFN = sfnsf_g[rxCellIndex] & FAPI_SFN_MASK;
    UInt8 currentSF = sfnsf_g[rxCellIndex] & FAPI_SF_MASK;
    UInt8 recvSF = 0, delay = 0, qIndex;
    UInt32 i = 0;
    UInt16 sendSfnSf = 0;
#ifdef UESIM_ENHANCEMENTS
    DLUEContext *newUEContext_p = PNULL;
    UInt16 ueIndex = 0;
    UInt8 value = 0;
#endif    
    /* CA_START_UP_PHASE_2 */
    FAPI_dlTLVInfo_st *dlDataTlv_p = PNULL;
    ueContextForUplink   *ueContextInfo_p  = PNULL;
    UInt8* data_p = PNULL;
    fapiMsgIdStruct *fapiMsgIdArr_p = PNULL;
    fapiMsgIdStruct *msgIndexArr_p = PNULL;
    FAPI_dlPduInfo_st *dlSchPdu_p = PNULL;
    UInt16 rnti = 0;
    UInt8 txCellIndex = 0;
    UInt8 cellIndex = 0;
    UInt8 scellPduCount[MAX_NUM_CELLS] = {0,0};
    /* CA_START_UP_PHASE_2 */
    UInt32 subFrameNum = 0;
    UInt32 sysFrameNum = 0;
    UInt16 expectedSfnSf = 0;

    
    /* Since global tick is updated on sending of SFI message, hence DL Config 
     * tick will be 1 less */
    /* SPR 15909 fix start */
    tickType_t dlTxReqTick = globalTTITickCount_g - 1;
    /* SPR 15909 fix end */
    /*FAPI_ERROR_INDICATION_CHANGES_START*/
    /* Discard DL Tx msg as well incase of error in DL CONFIG msg*/
    if ((1 == phy_err_config_g[rxCellIndex])&&\
            (PHY_DL_CONFIG_REQUEST == phy_err_msg_type_g[rxCellIndex]) && 
            ( FAPI_MSG_BCH_MISSING != phy_err_error_type_g[rxCellIndex] ) )
    {
        if ((FAPI_SFN_OUT_OF_SYNC != phy_err_error_type_g[rxCellIndex]) && (errorCount_g[rxCellIndex] == 1)) 
        {
            errorCount_g[rxCellIndex]++;
            return;
        }
        else if(dlConfigErrorFlag_g[rxCellIndex])
        {
            return;
        }
    }
    /*FAPI_ERROR_INDICATION_CHANGES_END*/
    if ( l1RcvMsg_p->msgLen == 0 )
    {
        fprintf(stderr,"Error..!!! msgLen = 0 recevied from MAC in DL CONFIG REQ\n");  
        return;
    }
    /*FAPI_ERROR_INDICATION_CHANGES_START*/
    /* Send error indication for Invalid phy state*/
    if ((1 == phy_err_config_g[rxCellIndex])&&\
            ((dlTxReqTick  >= phy_err_start_tti_g[rxCellIndex]) && \
             ( dlTxReqTick <= phy_err_end_tti_g[rxCellIndex])) && (errorCount_g[rxCellIndex] == 0))
        {
        if ((PHY_DL_TX_REQUEST  == phy_err_msg_type_g[rxCellIndex]) && (FAPI_MSG_INVALID_STATE == phy_err_error_type_g[rxCellIndex]))
        {
            fapiSendErrorIndication(FAPI_MSG_INVALID_STATE, l1RcvMsg_p->msgId,
                    0,0,&PhyDlTxresp_p,&PhyDlTxresp_size, rxCellIndex);
#ifdef HO_SETUP_CHANGES
            sendSFItoSourceENBMac(PhyDlTxresp_p,PhyDlTxresp_size,rxCellIndex);
            if ( startRecvFlag[rxCellIndex] == 2 )
            {
                sendDataToTargetEnbMac(PhyDlTxresp_p,PhyDlTxresp_size, rxCellIndex);
            }
#else
            sendDatatoPeerMac( (UInt8 *)PhyDlTxresp_p,PhyDlTxresp_size,rxCellIndex );
#endif            
            freeMemPool(PhyDlTxresp_p);
            PhyDlTxresp_p = PNULL;
            phyState_g[rxCellIndex] = FAPI_CONFIGURED;
            /*Reset the global vars */
            resetGlobals(rxCellIndex);
            errorCount_g[rxCellIndex]++;
            return;
        }
    }
    /*FAPI_ERROR_INDICATION_CHANGES_END*/

#ifndef HO_SETUP_CHANGES
    if ( FAPI_RUNNING != phyState_g[rxCellIndex] )
    {
        /* send error indication */
        /* FAPI_MSG_INVALID_STATE */
        fapiSendErrorIndication(FAPI_MSG_INVALID_STATE, l1RcvMsg_p->msgId,
                recvSfnSf,sfnsf_g[rxCellIndex], &PhyDlTxresp_p,&PhyDlTxresp_size);
        sendMsgtoTargetL2Config( (UInt8 *)PhyDlTxresp_p,PhyDlTxresp_size);
        freeMemPool( PhyDlTxresp_p );
        PhyDlTxresp_p = PNULL;
        return;

    }
#endif

    dlDataTxReq_p = (FAPI_dlDataTxRequest_st *)&(l1RcvMsg_p->msgBody[0]);
    if ( PNULL == dlDataTxReq_p )
    {
        fprintf(stderr,"Error..!!! dl data tx request msgBody = NULL" "recevied from MAC in DL DATA TX REQ\n");  
        return;
    }
    recvSfnSf = MAC_PHY_CONVERT_16(dlDataTxReq_p->sfnsf); 
    recvSFN = recvSfnSf & FAPI_SFN_MASK;
    recvSFN >>= FAPI_SFN_VALUE_SHIFT;
    recvSF = recvSfnSf & FAPI_SF_MASK;
    currentSFN >>= FAPI_SFN_VALUE_SHIFT;
    /*FAPI_ERROR_INDICATION_CHANGES_START*/
    /*Send phy error in case of discrepancy in expected and received SFN/SF*/
    if ((1 == phy_err_config_g[rxCellIndex])&&\
            ((dlTxReqTick >= phy_err_start_tti_g[rxCellIndex]) && \
             (dlTxReqTick <= phy_err_end_tti_g[rxCellIndex])) && (errorCount_g[rxCellIndex] == 0))
        {
        if ((PHY_DL_TX_REQUEST == phy_err_msg_type_g[rxCellIndex]) && (FAPI_MSG_INVALID_SFN == phy_err_error_type_g[rxCellIndex]))
        {
            if (phy_err_abs_delta_val_g[rxCellIndex])
            {
                subFrameNum = recvSF;
                sysFrameNum = recvSFN;
                if( 0 <= phy_err_delta_val_g[rxCellIndex] )
                {
                    UInt16 deltaVal = phy_err_delta_val_g[rxCellIndex];
                    while( deltaVal-- )
                    {
                        subFrameNum++;
                        if( MAX_SUBFRAME <= subFrameNum )
                        {
                            subFrameNum = 0;
                            sysFrameNum++;
                        }
                    }
                }
                else 
                {
                    UInt16 deltaVal = ABS( phy_err_delta_val_g[rxCellIndex] );
                    while( deltaVal-- )
                    {
                        if( 0 == subFrameNum )
                        {
                            subFrameNum = MAX_SUBFRAME - 1;
                            if( 0 == sysFrameNum )
                            {
                                sysFrameNum = 1023;
                            }
                            else
                            {
                                sysFrameNum--;
                            }
                        }
                        else
                        {
                            subFrameNum--;
                        }
                    }
                }
                expectedSfnSf = ( ( (sysFrameNum) << 4) | ( (subFrameNum) & 0xf) );
                fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId,
                        recvSfnSf, expectedSfnSf,&PhyDlTxresp_p,&PhyDlTxresp_size, rxCellIndex);

                UInt8 errQIdx = recvSF + 1;
                if( errQIdx >= MAX_SUBFRAME )
                {
                    errQIdx -= MAX_SUBFRAME;
                }
                LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                        sizeof(PhyErrInd), PNULL );
                if ( l1RcvMsg_p->msgLen == 0 )
                {
                    freeMemPool(PhyDlTxresp_p);
                    PhyDlTxresp_p = PNULL;
                    return;
                }
                else
                {
                    phyErrInd_p->data_p = PhyDlTxresp_p;
                    phyErrInd_p->dataSize = PhyDlTxresp_size;
                    ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx ,rxCellIndex);
                }
                phy_err_abs_delta_val_g[rxCellIndex]--;
                return;

            }
            errorCount_g[rxCellIndex]++;
            return;
        }
    }
    /*FAPI_ERROR_INDICATION_CHANGES_END*/

#ifdef TDD_CONFIG

    if ( recvSfnSf != msgIdArr_p[0].recvSfnSf )
    {
        lteWarning("recvSfnSf = 0x%x is not matching with the control sfnsf = 0x%x\n",
                recvSfnSf,msgIdArr_p[0].recvSfnSf); 
        if (( delay = validateTick( recvSFN,
                        recvSF,
                        currentSFN,
                        currentSF
                        ))== 0xFF )
        {
            fprintf(stderr,"DL DATA packet Drooped due to delayed received\n");
            fprintf(stderr,"DL DATA: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);

            /* send error indication */
            /* FAPI_MSG_INVALID_SFN */
            fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId,
                    recvSfnSf,sfnsf_g[rxCellIndex], &PhyDlTxresp_p,&PhyDlTxresp_size, rxCellIndex);
            /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            sendSFItoSourceENBMac( (UInt8 *)PhyDlTxresp_p,PhyDlTxresp_size, rxCellIndex);
            /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 

            freeMemPool( PhyDlTxresp_p );
            PhyDlTxresp_p = PNULL;
            return;
        }
    }
    else
    {
        if (( delay = validateTick( recvSFN,
                        recvSF,
                        currentSFN,
                        currentSF
                        )) == 0xFF )
        {
            fprintf(stderr,"DL DATA packet Drooped due to delayed received\n");
            fprintf(stderr,"DL DATA: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);

            /* send error indication */
            /* FAPI_MSG_INVALID_SFN */
            fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId,
                    recvSfnSf, sfnsf_g[rxCellIndex], &PhyDlTxresp_p,&PhyDlTxresp_size, rxCellIndex);
            /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            sendSFItoSourceENBMac( (UInt8 *)PhyDlTxresp_p,PhyDlTxresp_size, rxCellIndex);
            /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            freeMemPool( PhyDlTxresp_p );
            PhyDlTxresp_p = PNULL;
            return;

        }

    } 

#elif FDD_CONFIG
    if ( recvSfnSf != msgIdArr_p[0].recvSfnSf )
    {
        lteWarning("recvSfnSf = 0x%x is not matching with the control sfnsf = 0x%x\n", recvSfnSf,msgIdArr_p[0].recvSfnSf); 

        /* check for validation of recevied SFN & SF from MAC */ 
        if (( delay = validateSFNandSFAndgetDelay(recvSFN, recvSF, 
                        currentSFN, currentSF)) == 0xFF )
        {
            fprintf(stderr,"DL DATA packet Droped due to delayed received\n");
            fprintf(stderr,"DL DATA: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);

            /* send error indication */
            /* FAPI_MSG_INVALID_SFN */
            fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId, 
                    recvSfnSf,sfnsf_g[rxCellIndex], &PhyDlTxresp_p, &PhyDlTxresp_size,rxCellIndex);
            /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            sendSFItoSourceENBMac( (UInt8 *)PhyDlTxresp_p,PhyDlTxresp_size, rxCellIndex);
            /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            freeMemPool( PhyDlTxresp_p );
            PhyDlTxresp_p = PNULL;
            return;
        }
    }
    else
    {
        /* check for validation of recevied SFN & SF from MAC */ 
        if (( delay = validateSFNandSFAndgetDelay(recvSFN, recvSF, 
                        currentSFN, currentSF)) == 0xFF )
        {
            fprintf(stderr,"DL DATA packet Droped due to delayed received\n");
            fprintf(stderr,"DL DATA: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);

            /* send error indication */
            /* FAPI_MSG_INVALID_SFN */
            fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId, 
                    recvSfnSf,sfnsf_g[rxCellIndex], &PhyDlTxresp_p,&PhyDlTxresp_size,rxCellIndex); 
            /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            sendSFItoSourceENBMac( (UInt8 *)PhyDlTxresp_p,PhyDlTxresp_size, rxCellIndex);
            /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
            freeMemPool( PhyDlTxresp_p );
            PhyDlTxresp_p = PNULL;
            return;
        }
    }
#endif

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,"DLSCH data received at sfnsf = 0x%x delay = %d\n",recvSfnSf, delay);
#endif

#ifdef TDD_CONFIG
    /* SPR 2984 Fix */
    UInt16 savedSFN = recvSFN;
    UInt8 savedSF = recvSF;
    /* SPR 2984 Fix */
    /* CA TDD Changes Start */
    qIndex = calPdschQIdxSFNAndSF( &recvSFN, &recvSF, delay, rxCellIndex);  
    /* CA TDD Changes End */

#elif FDD_CONFIG
    qIndex = recvSF + 4  + PEER_MAC_DELAY;
    if (qIndex >= MAX_SUBFRAME)
    {
        qIndex -= MAX_SUBFRAME;
    }
    recvSF += 4;
    if ( recvSF >= MAX_SUBFRAME )
    {
        recvSF -= MAX_SUBFRAME;
        recvSFN++ ;
        if ( recvSFN == MAX_SFN )
        {
            recvSFN = 0;
        }
    }
#endif    
    sendSfnSf = GENERATE_SUBFRAME_SFNSF(recvSFN, recvSF);
    numOfDlDataPdu = MAC_PHY_CONVERT_16(dlDataTxReq_p->numOfPDU);
    dlPdu_p = (FAPI_dlPduInfo_st *) &(dlDataTxReq_p->dlPduInfo[0]);
    if ( PNULL == dlPdu_p )
    {
        fprintf(stderr,"\n dl data pdu recevied is NULL\n");
        return;
    }
    i = 0;
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,"sendsfn = %d sf = %d\n", recvSFN,recvSF);
    fprintf(stderr,"numOfDlDataPdu = %d sendsfnsf = %d\n",numOfDlDataPdu, sendSfnSf);
#endif
#ifdef UESIM_ENHANCEMENTS
    UInt32 dlSchPduLen = 0;
#endif
    while ( numOfDlDataPdu-- )
    {
        /* CA_START_UP_PHASE_2 */

        fapiMsgIdStruct *msgIdxArr_p =  PNULL;
        msgIdxArr_p = &(msgIdArr_p[MAC_PHY_CONVERT_16(dlPdu_p->pduIndex)]);
        if (FAPI_C_RNTI == msgIdxArr_p->dlSCHPdu.rntiType )
        {
            rnti = msgIdxArr_p->dlSCHPdu.rnti;
            GET_RNTI_TO_CELL_INDEX(rnti, txCellIndex)
                RNTIInfo             *rntiInfo_p       = PNULL;
/* + SPR 11220 Changes */
            rntiInfo_p       =  getRntiInfofromRNTIMap(msgIdxArr_p->dlSCHPdu.rnti, txCellIndex); 
/* - SPR 11220 Changes */

            if (rntiInfo_p)
            {
                if ((rxCellIndex != txCellIndex))
                {
                    /* SPR 11995 Changes Start */
                    dlDataInfo_p = (FAPI_dlRecvDataInfo_st *)getMemFromPool(sizeof(FAPI_dlRecvDataInfo_st),PNULL);
                    /* Store the Recieved SFN-SF in the PDU being enqueued for processing */
                    dlDataInfo_p->recvSfnSf = recvSfnSf;
                    dlDataInfo_p->data_p = (FAPI_dlPduInfo_st*)dlPdu_p;
                    /* + SPR 14177 Changes */
                    UInt8 index = 0;  
                    dlDataTlv_p = ( FAPI_dlTLVInfo_st *) &(dlPdu_p->dlTLVInfo[0]);
                    ueContextInfo_p  = getUEContext(dlDataTlv_p->tag, txCellIndex);
                    if(ueContextInfo_p)
                    {
#ifdef TDD_CONFIG        
#if 0                        
                        if(ueContextInfo_p->carrierAggrConfig.scellCount == 0)
                        {
                            freeMemPool(dlDataInfo_p);
                            dlDataInfo_p = PNULL;
                            return;

                        }
#endif                        
#endif                        
                    }
                    /* - SPR 14177 Changes */
                    /** SPR 11348 Changes Start **/
                    if(0 ==   pushNodeCircQ(&(dlSchPduQ[txCellIndex].DlDataCircQ[rxCellIndex]), 
                                (void *)(dlDataInfo_p)))
                    {
                        ltePanic("\n CirCular Q Push node Fail\n");
                    }
                    /* SPR 11995 Changes End */
                    /** SPR 11348 Changes End **/
#if 0
                    UInt8 index = 0;  
                    dlDataTlv_p = ( FAPI_dlTLVInfo_st *) &(dlPdu_p->dlTLVInfo[0]);
                    ueContextInfo_p  = getUEContext(dlDataTlv_p->tag, txCellIndex);
#endif                    
                    if (ueContextInfo_p)
                    {
                        scellDlSchInfo[txCellIndex][rxCellIndex][ueContextInfo_p->ueIdx].dlSCHPduCount = msgIdxArr_p->dlSCHPduCount;
                        scellDlSchInfo[txCellIndex][rxCellIndex][ueContextInfo_p->ueIdx].rnti = msgIdxArr_p->dlSCHPdu.rnti;
                        scellDlSchInfo[txCellIndex][rxCellIndex][ueContextInfo_p->ueIdx].rntiType = msgIdxArr_p->dlSCHPdu.rntiType;
                        scellDlSchInfo[txCellIndex][rxCellIndex][ueContextInfo_p->ueIdx].dciFormat = msgIdxArr_p->dlSCHPdu.dciFormat;
                        /* + SPR_15971 */
                        scellDlSchInfo[txCellIndex][rxCellIndex][ueContextInfo_p->ueIdx].tb1Valid =  msgIdxArr_p->dlSCHPdu.tb1Valid;
                        scellDlSchInfo[txCellIndex][rxCellIndex][ueContextInfo_p->ueIdx].tb2Valid = msgIdxArr_p->dlSCHPdu.tb2Valid;
                        /* - SPR_15971 */
                    index++;
                    }
                    else
                    {
                        continue;
                    }
                    /* 25apr change */
                    dlPdu_p = (FAPI_dlPduInfo_st *)((UInt8 *)dlPdu_p + MAC_PHY_CONVERT_16(dlPdu_p->pduLen));
                    continue;

                }
            } 
        }
        /* CA_START_UP_PHASE_2 */

        /*FAPI_ERROR_INDICATION_CHANGES_START*/
        /* Send phy error incase of subframe error in TX.Request */
        if ((1 == phy_err_config_g[rxCellIndex])&&\
                (( dlTxReqTick >= phy_err_start_tti_g[rxCellIndex]) && \
                 ( dlTxReqTick <= phy_err_end_tti_g[rxCellIndex])) && (errorCount_g[rxCellIndex] == 0))
            {
            if ((PHY_DL_TX_REQUEST == phy_err_msg_type_g[rxCellIndex]) && (FAPI_MSG_TX_ERR  == phy_err_error_type_g[rxCellIndex]))
            {
                phy_err_pdu_index_g[rxCellIndex] = dlPdu_p->pduIndex;
                fprintf(stderr,"\n RASHMI -- in case of tx error in tx.request ");
                fapiSendErrorIndication(FAPI_MSG_TX_ERR,l1RcvMsg_p->msgId,
                        recvSfnSf,0, &PhyDlTxresp_p,&PhyDlTxresp_size, rxCellIndex);

                UInt8 errQIdx = recvSF + 1;
                if( errQIdx >= MAX_SUBFRAME )
                {
                    errQIdx -= MAX_SUBFRAME;
                }
                LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                        sizeof(PhyErrInd), PNULL );
                if( PNULL == phyErrInd_p )
                {
                    freeMemPool(PhyDlTxresp_p);
                    PhyDlTxresp_p = PNULL;
                    return;
                }
                else
                {
                    phyErrInd_p->data_p = PhyDlTxresp_p;
                    phyErrInd_p->dataSize = PhyDlTxresp_size;

                    ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx ,rxCellIndex);
                }
                errorCount_g[rxCellIndex]++;
                return;
            }
        }
        /*FAPI_ERROR_INDICATION_CHANGES_END*/

        fapiHandleDlData(sendSfnSf, (dlPdu_p), 
        /* CA_NA */ 
             &(msgIdArr_p[MAC_PHY_CONVERT_16(dlPdu_p->pduIndex)]), qIndex,
             rxCellIndex
        /* CA_NA */ 
#ifdef UESIM_ENHANCEMENTS
                ,&dlSchPduLen
#endif                
                /* SPR 2984 Fix */
#ifdef TDD_CONFIG
                , savedSFN, savedSF
/* + SPR 14001 Changes */
                ,rxCellIndex
/* - SPR 14001 Changes */
#endif
                /* SPR 2984 Fix */
             
#ifdef FDD_CONFIG
, (recvSfnSf & FAPI_SF_MASK)
#endif
                );
        dlPdu_p = (FAPI_dlPduInfo_st *)((UInt8 *)dlPdu_p + MAC_PHY_CONVERT_16(dlPdu_p->pduLen));
        i++; 

#ifdef UESIM_ENHANCEMENTS
        if((msgIdArr_p[value].dlSCHPduCount > 0) && 
           (0xFFFF != msgIdArr_p[value].dlSCHPdu.rnti))
        {
            /* +- SPR 18268 */
                UInt16 ueIndex = (msgIdArr_p[value].dlSCHPdu.rnti) - 51;
                /* +- SPR 18268 */
                newUEContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
                if((PNULL != newUEContext_p) && (dlSchPduLen))
                {
                  if(newUEContext_p->tbSizeReceived != dlSchPduLen)
                  {  
                      ltePanic("TB size in DL config = %d and TX request = %d is not same\n",newUEContext_p->tbSizeReceived,dlSchPduLen);
                  }
                  value++;
                }
        }
#endif
   }
    /* CA_START_UP_PHASE_2 */
    for(cellIndex = 0 ; cellIndex < numCells_g ; cellIndex++)
    {
        if (cellIndex == rxCellIndex)
            continue;
        scellPduCount[cellIndex] = circQueueCount(&dlSchPduQ[cellIndex].DlDataCircQ[rxCellIndex]);
        if (scellPduCount[cellIndex])
        {
            /** SPR 12286 Changes Start **/
            dlSchPdu_p = (FAPI_dlPduInfo_st *)getMemFromPool(sizeof(FAPI_dlPduInfo_st),PNULL);
            dlSchPdu_p->pduIndex = 0xFFFF;
            /** SPR 12286 Changes End **/

            /* SPR 11995 Changes Start */
            dlDataInfo_p = (FAPI_dlRecvDataInfo_st *)getMemFromPool(sizeof(FAPI_dlRecvDataInfo_st),PNULL);
            dlDataInfo_p->recvSfnSf = recvSfnSf;
            dlDataInfo_p->data_p = dlSchPdu_p;
            /** SPR 11348 Changes Start **/
            pushNodeCircQ(&(dlSchPduQ[cellIndex].DlDataCircQ[rxCellIndex]), 
                    (void *) (dlDataInfo_p));
            /* SPR 11995 Changes End */
            /*CA multi-thread sync fix Start*/
            /*eventfd_write_wrapper(ev_fd_g[cellIndex][rxCellIndex],1);*/

        }

    }
   /* processDlSchPduForAllCells(sendSfnSf, msgIndexArr_p, qIndex
#ifdef UESIM_ENHANCEMENTS
                ,dlSchPduLen
#endif
#ifdef TDD_CONFIG
                , savedSFN, savedSF
#else
                , (recvSfnSf & FAPI_SF_MASK)
#endif
                , rxCellIndex);
*/
/*CA multi-thread sync fix End*/
}

/****************************************************************************
 * Function Name  :  fapiProcessHiPdu 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
void fapiProcessHiPdu(UInt8  harqIndex, 
        UInt8  hiVal,UInt8 currentSF, UInt8 phichReceiveIndex,
        UInt8 delay, UInt16 sendSfnSf, ControlNodeInfo *ctlInfo_p,
        UInt8 recvSf, UInt8 cellIndex)
{
    /*crc changes begin*/
    UInt8 crcFlag = 0;
    ueContextForUplink   *ueContextInfo_p  = PNULL;
    ULHarqInfo* ulHarq_p = PNULL;
    /* SPR 2333 Changes Begins */
    ulschDataQueueNode *uldataNode_p = PNULL;
    /* SPR 2333 Changes Ends */
    /* + SPR 11347 Changes */
    UInt8 txCellIndex = 0;
    GET_RNTI_TO_CELL_INDEX((MAC_PHY_CONVERT_16(ctlInfo_p->crnti)), txCellIndex);
    ueContextInfo_p  = getUEContext(ctlInfo_p->crnti, txCellIndex);
    /* - SPR 11347 Changes */
#ifdef FDD_CONFIG
   /* For TTIB_Code */
    UInt8 tick = 0;
    ttibDataQueueNode *ttibDataNode_p = PNULL;
    UInt8 ttibqIndex = 0;
    /* SPR 15909 fix start */
    tickType_t currentTick = getCurrentglobaltick();
    /* SPR 15909 fix end */
    /*UESIM ADAPTIVE RETX FIX*/
#else
    UInt8 macRetType = 0;
    /*SPR 15909 fix start*/
    tickType_t currentTick = getCurrentglobaltick();
    /*SPR 15909 fix end*/
    UInt8 phrTriggered = FALSE;
    ULHARQEntity *ulHarqEntity_p = PNULL;
    ULHARQProcess * ulharqProcess_p = PNULL;
    FAPI_dlDCIPduInfo_st *dciPdu_p = PNULL;
    if (PNULL == ueContextInfo_p)
    {
        fprintf(stderr,"\n[%d] %s UE CONTEXT NULL for RNTI:%d ",globalTTITickCount_g,__func__,ctlInfo_p->crnti);
        return;    
    }
    dynamicUEContext *ulDynUEContext_p  = dynUEContextInfoMap_g[ueContextInfo_p->ueIdx];
    if ( PNULL == ulDynUEContext_p )
    {
        fprintf(stderr,"fapiProcessUlGrant: dynamicUe context is NULL for rnti = %d\n", dciPdu_p->rnti);
        return;  
    }
#endif
    /*UESIM ADAPTIVE RETX FIX*/
    if(ueContextInfo_p)
    {
        ulHarq_p = &ueContextInfo_p->ulharqInfo[harqIndex];
        /*UESIM ADAPTIVE RETX FIX*/
#ifdef TDD_CONFIG
        ulHarqEntity_p = ueContextInfo_p->ulHarqEntity_p;
        ulharqProcess_p = &(ulHarqEntity_p->ulHarqProcess[harqIndex]);
        ulharqProcess_p->ulSchSendFlag = 0;
#endif
        /*UESIM ADAPTIVE RETX FIX*/

        if((0 == hiVal) && (ulHarq_p->currentRetransCount < 
                    /* max harq tx changes */
                    /* SPR 22264 Fix Start */
                    (ueContextInfo_p->maxUlHarqTx - 1)))
                    /* SPR 22264 Fix End */
            /* max harq tx changes */
        {
            /*UESIM ADAPTIVE RETX FIX*/
#ifdef TDD_CONFIG
            dciPdu_p = &ulharqProcess_p->dciPdu;
            ulharqProcess_p->ulSchSendFlag = 1;
#endif
            /*UESIM ADAPTIVE RETX FIX*/
            crcFlag = preapreCRCIndication(ctlInfo_p->crnti,sendSfnSf,
					ctlInfo_p->qIndex,FALSE, cellIndex);
            /* SPR 2333 Changes Begins */
            if ( FAPI_CRC_ERROR == crcFlag )
            { 
#ifdef FDD_CONFIG
		    /* For TTIB_Code */
                if (ueContextInfo_p->ttiBundling)
                {
                    pushTTIBNodes(harqIndex,delay,phichReceiveIndex,ctlInfo_p->qIndex,&(ulHarq_p->dciPdu),ctlInfo_p->sendSF,ctlInfo_p->sendSFN,sendSfnSf,RE_TRANSMISSION,cellIndex);
                    ulHarq_p->currentRetransCount += 4;
                }
                else
#endif
                {
                    uldataNode_p = fapiGetULDataPduNode (ctlInfo_p->qIndex, sendSfnSf,
                            ctlInfo_p->crnti );
                    pushNode(&ulDataQueue[cellIndex][ctlInfo_p->qIndex], &(uldataNode_p->ulDataAnchor));
                    ueContextInfo_p->ulschIndRefNode_p[ctlInfo_p->qIndex] = uldataNode_p;
                        ulHarq_p->currentRetransCount++;
                }
            }
            /*UESIM ADAPTIVE RETX FIX*/
#ifdef TDD_CONFIG
            else
            {
                if ( (ulharqProcess_p->totalTBSize >= 8) ) /*ULA_UTP*/
                {
                    ueContextInfo_p->bsrPresentFlag = 1;
                    if((ueContextInfo_p->phrFlag == TRUE) &&
                            (ueContextInfo_p->phrTime <= globalTTITickCount_g))
                    {
                        phrTriggered = TRUE;
                    }
                    else
                    {
                        phrTriggered = FALSE;
                    }

                    uldataNode_p = fapiGetULDataPduNode (ctlInfo_p->qIndex, sendSfnSf,
                            MAC_PHY_CONVERT_16(dciPdu_p->rnti));

                    if ( uldataNode_p == PNULL )
                    {
                        printf("Not able to get memory for ulschDataQueueNode\n");
                        return;
                    }

                    macRetType = distributeRBsAndSendReqToRLC( ueContextInfo_p->ueIdx,
                            ulharqProcess_p->totalTBSize,
                            ueContextInfo_p->bsrPresentFlag,
                            uldataNode_p,
                            &(uldataNode_p->pdudata_p),
                            &(uldataNode_p->pduLen),
                            phrTriggered,
                            cellIndex
                            );

                    if ( MAC_SUCCESS == macRetType )
                    {

                    }
                    else if ( MAC_PARTIAL_SUCCESS == macRetType )
                    {
                        if((ueContextInfo_p->phrFlag == TRUE) &&
                                (ueContextInfo_p->phrTime <= currentTick))
                        {
                            /* SPR 14789 Fix Start */
                            fapiPrepareLongBSRAndPHR(ulDynUEContext_p, MAC_PHY_CONVERT_16(dciPdu_p->rnti),
                                    sendSfnSf,ctlInfo_p->qIndex,uldataNode_p,ulharqProcess_p->totalTBSize, TRUE,cellIndex);
                            /* SPR 14789 Fix End */
                            ueContextInfo_p->phrTime = currentTick +
                                phrProfileInfo_g[cellIndex][ueProfileInfo_g[cellIndex][ueContextInfo_p->ueProfileId]
                                .phrProfileId].phrTimer;
                        }
                        else
                        {
                            /* SPR 14789 Fix Start */
                            fapiPrepareLongBSRAndPHR(ulDynUEContext_p, MAC_PHY_CONVERT_16(dciPdu_p->rnti),
                                    sendSfnSf, ctlInfo_p->qIndex,uldataNode_p,ulharqProcess_p->totalTBSize, FALSE,cellIndex);
                            /* SPR 14789 Fix End */
                        }
                    }
                    else
                    {
                        /* SPR 2417 changes start */
                        freeMemPool(uldataNode_p);
                        uldataNode_p = PNULL;
                        /* SPR 2417 changes end */
                    }
                }
                else
                {
                    uldataNode_p = fapiGetULDataPduNode (ctlInfo_p->qIndex, sendSfnSf,
                            MAC_PHY_CONVERT_16(dciPdu_p->rnti));
                    if ( uldataNode_p == PNULL )
                    {
                        printf("Not able to get memory for ulschDataQueueNode\n");
                        return;
                    }
                    if((ueContextInfo_p->phrFlag == TRUE) &&
                            (ueContextInfo_p->phrTime <= currentTick))
                    {
                            /* SPR 14789 Fix Start */
                        fapiPrepareLongBSRAndPHR(ulDynUEContext_p, MAC_PHY_CONVERT_16(dciPdu_p->rnti),
                                sendSfnSf,ctlInfo_p->qIndex,uldataNode_p,ulharqProcess_p->totalTBSize, TRUE,cellIndex);
                            /* SPR 14789 Fix End */
                        ueContextInfo_p->phrTime = currentTick +
                            phrProfileInfo_g[cellIndex][ueProfileInfo_g[cellIndex][ueContextInfo_p->ueProfileId]
                            .phrProfileId].phrTimer;
                    }
                    else
                    {
                            /* SPR 14789 Fix Start */
                        fapiPrepareLongBSRAndPHR(ulDynUEContext_p, MAC_PHY_CONVERT_16(dciPdu_p->rnti),
                                sendSfnSf, ctlInfo_p->qIndex,uldataNode_p,ulharqProcess_p->totalTBSize, FALSE,cellIndex);
                            /* SPR 14789 Fix End */
                    }
                }

            }
#endif
            /*UESIM ADAPTIVE RETX FIX*/
        }
#ifdef FDD_CONFIG
	/* For TTIB_Code */
        else if (1 == hiVal)
        {
            /* If ACk & NDI bit not toggled inc retransmission count else set to 0 */
        }
#endif
        else
        {
            /*UESIM ADAPTIVE RETX FIX*/
#ifdef TDD_CONFIG
            ulharqProcess_p->ulSchSendFlag = 0;
#endif
	    /* SPR 22264 Fix Start */
            ulHarq_p->currentRetransCount = 0;
            /* SPR 22264 Fix End */
            /*UESIM ADAPTIVE RETX FIX*/
        }
    }
    /*crc changes end*/

#ifdef FAPI_UL_HARQ_ENABLE
    /* MAC HI PDU 
     *  
     *  PHICH Lowest UL RB Index   -  1 byte  [ 0 - 100 ]
     *  HI Value                   -  1 byte  [ 0 - 1 ]
     *  CRNTI                      -  2 byte  [ 1 - 0xFFF3]
     */

    UInt8 crcFlag = 0;
    SInt8 diffHarqIndex  = 0;
    UInt8 harqIndex = 0;
    SInt8 maxHarqProcNum = MAX_HARQ_PROCESS_NB;
    SInt8 diffDataPduIndex =0,diffCurrentSFSubDelay=0;
    SInt8 maxDataPduNum = MAX_SUBFRAME;
    UInt8 harqSF         = 0;
    UInt8 currentSFSubDelay = 0;
    UInt8 dataPduIndex = 0; 
    UInt16 currentSFNSF    = 0;
    UInt16 sendSFNSF    = 0;
    UInt16 timercount=0;
    UInt8 qIndex = ctlInfo_p->qIndex;
    UInt32 tbSize = 0;
    UInt16 ulHarqTimerElementCount = 0;    
    UInt16 sendQIndex,sendAckSFN,sendAckSF;


    RNTIInfo             *rntiInfo_p       = PNULL;
    ueContextForUplink   *ueContextInfo_p  = PNULL;
    dynamicUEContext     *ulDynUEContext_p = PNULL;
    ULHarqInfo* ulHarq_p = PNULL;
    ulschDataQueueNode *uldataNode_p = PNULL;

    /* Decode the HI Pdu */

    rntiInfo_p       =  getRntiInfofromRNTIMap(ctlInfo_p->crnti, cellIndex);
    ueContextInfo_p  = getUEContext(ctlInfo_p->crnti, cellIndex);
    ulDynUEContext_p = dynUEContextInfoMap_g[rntiInfo_p->ueIndex];


    // _ULHARQ_RETX_  start  


    if(currentSF>=MAX_HARQ_PROCESS_NB)
    {
        harqSF=currentSF-DIFF_HARQ_SUBFRAME;
    }
    else
    {
        harqSF=currentSF;
    }

    diffHarqIndex = (SInt8)harqSF - (4 + delay) ;

    if(diffHarqIndex <= 0 )
    {
        harqIndex = ((maxHarqProcNum + diffHarqIndex + DIFF_HARQ_SUBFRAME) % MAX_HARQ_PROCESS_NB) ; 
    }
    else
    {
        harqIndex = diffHarqIndex + DIFF_HARQ_SUBFRAME; 
    }

    diffDataPduIndex = (SInt8)currentSF - (4 + delay);

    if(diffDataPduIndex < 0)
    {
        dataPduIndex = maxDataPduNum + diffDataPduIndex; 
    }
    else
    {
        dataPduIndex = diffDataPduIndex; 
    }
    diffCurrentSFSubDelay = (SInt8)currentSF - delay;

    if(diffCurrentSFSubDelay < 0)
    {
        currentSFSubDelay = maxDataPduNum + diffCurrentSFSubDelay;    
    }
    else
    {
        currentSFSubDelay = diffCurrentSFSubDelay; 
    }

    if(currentSFSubDelay != recvSf)
    {
        ltePanic("[%s]: Recv SF is not calulated correctly \n", __func__);
    }
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,"HICASE currentSFN %d currentSF %d delay %d\n",SFN_g,SF_g,delay);
    fprintf(stderr,"HICASE currentSFSubDelay %d harqIndex  = %d dataPduIndex = %d  qIndex = %d\n",currentSFSubDelay,harqIndex,dataPduIndex,qIndex);
#endif
    // _ULHARQ_RETX_  end  
    ulHarq_p = &ueContextInfo_p->ulharqInfo[harqIndex];

    ueContextInfo_p->hiReceived = 1;
    ulHarq_p->ackNack = hiVal;

    if (ulHarq_p->ackNack == NACK)
    {
        if ( ulHarq_p->ulgrantrecvCount >= 1 )
        {

            tbSize = ulHarq_p->tbSizeForNackCase;

            if (ulHarq_p->currentRetransCount < 
                    /* max harq tx changes */
                    (ueContextInfo_p->maxUlHarqTx -1 ))
                /* max harq tx changes */
            {

                ulHarq_p->currentRetransCount++;

                if (ulHarq_p->currentRetransCount != 1)
                {
                    /* The following lines are being added to Enhance the Harq Functionality in UL Direction*/

                    ulHarqTimerElementCount = ueContextInfo_p->ulHarqTimerNodeArrrayIndex[currentSFSubDelay];

                    dataPduIndex=ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex;

                    if(ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid)
                    {
                        ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid = 0;
                        ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId = 255;
                        ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex = INVALID_UE_INDEX;
                        ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex = 255;
                        ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti = INVALID_UE_INDEX; 
                        ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn = 0;
                        ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf = 0;    

                        if(!ulHarqTimerEntityList_g[currentSFSubDelay].count)
                        {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                            fprintf(stderr,"\n Current SF = %d at Line No = %d  and ulHarqTimerElementCount = %d \n",currentSF, __LINE__, ulHarqTimerElementCount);
#endif
                        }
                        else  
                            ulHarqTimerEntityList_g[currentSFSubDelay].count--;
                    }

                    ueContextInfo_p->ulHarqTimerNodeArrrayIndex[currentSFSubDelay] = 255;

                    ulHarqTimerElementCount = ulHarqTimerEntityList_g[phichReceiveIndex].count;
                    ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid = 1;
                    ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId = harqIndex;
                    ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex = rntiInfo_p->ueIndex;
                    ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex = ctlInfo_p->qIndex;
                    ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti = ctlInfo_p->crnti; 
                    ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn = ctlInfo_p->sendSFN;
                    ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf = ctlInfo_p->sendSF;
                    ulHarqTimerEntityList_g[phichReceiveIndex].count++;
                    ueContextInfo_p->ulHarqTimerNodeArrrayIndex[phichReceiveIndex] = ulHarqTimerElementCount;
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"NACKCASE TIMERSTART hI %d uI %d tI %d qI %d TCnt %d sendSF %d sendSFN %d phichReceiveIndex %d TIdx %d\n",harqIndex,rntiInfo_p->ueIndex,ctlInfo_p->crnti,ctlInfo_p->qIndex,ulHarqTimerElementCount,ctlInfo_p->sendSF,ctlInfo_p->sendSFN,phichReceiveIndex,ulHarqTimerElementCount);
#endif
                    /* The above lines are being added to Enhance the Harq Functionality in UL Direction*/

                    crcFlag = preapreCRCIndication( ctlInfo_p->crnti,sendSfnSf, 
                            ctlInfo_p->qIndex, FALSE);
                    if ( FAPI_CRC_CORRECT == crcFlag )
                    {
                        uldataNode_p = fapiGetULDataPduNode (ctlInfo_p->qIndex, sendSfnSf,
                                ctlInfo_p->crnti );
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                        fprintf(stderr,"NACKCASE \n");
#endif

                        if(ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p)
                        {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                            fprintf(stderr,"PACKETTX \n");
#endif
                            uldataNode_p->pdudata_p = ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p;
                            uldataNode_p->pduLen = ueContextInfo_p->ulDataPduInfo[dataPduIndex].PDULength;
                            ueContextInfo_p->ulDataPduInfo[qIndex].Pdudata_p = uldataNode_p->pdudata_p;
                            ueContextInfo_p->ulDataPduInfo[qIndex].PDULength = uldataNode_p->pduLen;
                            // _ULHARQ_RETX_  start  

                            if(uldataNode_p->SFN != SFN_g)
                            {
                                if ((!((uldataNode_p->SFN==0)&& (SFN_g==(MAX_SFN -1)))) && (!((uldataNode_p->SFN==(MAX_SFN -1) )&& (SFN_g==0))))
                                {
                                    currentSFNSF=SFN_g * 10 + SF_g[cellIndex];
                                    //sendSFNSF= uldataNode_p->SFN * 10 + qIndex;
                                    sendSFNSF= uldataNode_p->SFN * 10 + uldataNode_p->SF;
                                }
                                else if((uldataNode_p->SFN==0)&& (SFN_g==(MAX_SFN -1)))
                                {
                                    currentSFNSF=0;
                                    sendSFNSF=(MAX_SFN - 1);
                                }
                                else if((uldataNode_p->SFN==(MAX_SFN -1) )&& (SFN_g==0))
                                {
                                    currentSFNSF=(MAX_SFN - 1);
                                    sendSFNSF=0;
                                }
                            }
                            else
                            {
                                currentSFNSF=SF_g;
                                sendSFNSF=qIndex;
                            }
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                            fprintf(stderr,"In [%s] currentSFN %d currentSF %d\n",__func__,SFN_g,SF_g);
                            fprintf(stderr,"In [%s] qIndex %d sendSF %d  sendSFN  %d\n",__func__,qIndex,ctlInfo_p->sendSF,uldataNode_p->SFN);
                            fprintf(stderr,"In [%s] currentSFNSF %d sendSFNSF %d\n",__func__,currentSFNSF,sendSFNSF);
#endif

                            if (currentSFNSF<sendSFNSF)
                            {   
                                pushNode(&ulDataQueue[cellIndex][qIndex], &(uldataNode_p->ulDataAnchor));
                            }
                            else
                            {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                                fprintf(stderr,"In [%s] INITHARQRETRY\n",__func__);
#endif
                            }

                            // _ULHARQ_RETX_  end                                                        
                            ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p=NULL;
                            ueContextInfo_p->ulDataPduInfo[dataPduIndex].PDULength=0;
                        }
                        else
                        {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                            fprintf(stderr,"NOTX \n");
#endif
                        }

                        // _ULHARQ_RETX_  end  
                    }
                }
            }
            else
            {

                ulHarq_p->tbSizeForNackCase = 0;
                ulHarq_p->ulgrantrecvCount = 0;
                ulHarq_p->currentRetransCount = 0;
                /* The following lines are being added to Enhance the Harq Functionality in UL Direction*/

                ulHarqTimerElementCount = ueContextInfo_p->ulHarqTimerNodeArrrayIndex[currentSFSubDelay];

                if(ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid)
                {
                    ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId = 255;
                    ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid = 0;
                    ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex = INVALID_UE_INDEX;
                    ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex = 255;
                    ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti = INVALID_UE_INDEX;
                    ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn = 0;
                    ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf = 0;    
                    if(!ulHarqTimerEntityList_g[currentSFSubDelay].count)
                    {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                        fprintf(stderr,"\n Re-Trans Completed Current SF = %d and Count = %d at Line No = %d  \n",currentSF,ulHarqTimerElementCount ,__LINE__);
#endif
                    }
                    else  
                    { 
                        ulHarqTimerEntityList_g[currentSFSubDelay].count--;
                    } 
                    timercount=ulHarqTimerEntityList_g[currentSFSubDelay].count;

                }

                ueContextInfo_p->ulHarqTimerNodeArrrayIndex[currentSFSubDelay] = 255;
                // _ULHARQ_RETX_  start  

                if(ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p)
                {    
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"MAXRETX BUFFER FREE currentSF %d timercount %d ulHarqTimerElementCount %d\n",currentSF,ulHarqTimerEntityList_g[currentSF].count,ulHarqTimerElementCount);
#endif
                    freeMemPool(ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p);
                }
                else
                {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"MAXRETX BUFFER LEAK currentSF %d timercount %d ulHarqTimerElementCount %d\n",currentSF,ulHarqTimerEntityList_g[currentSF].count,ulHarqTimerElementCount);
#endif
                }
                ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p=NULL;
                ueContextInfo_p->ulDataPduInfo[dataPduIndex].PDULength=0;
                // _ULHARQ_RETX_  end  

                /* The above lines are being added to Enhance the Harq Functionality in UL Direction*/                                       
            }
        }
        else
        {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
            fprintf(stderr,"GRANT NOT RECIEVED CASE currentSFN = %d Current SF = %d\n",SFN_g,currentSF);
#endif
        }

    }
    else
    {
        ulHarq_p->tbSizeForNackCase   = 0;
        ulHarq_p->ulgrantrecvCount    = 0;
        ulHarq_p->currentRetransCount = 0;


        ulHarqTimerElementCount = ueContextInfo_p->ulHarqTimerNodeArrrayIndex[currentSFSubDelay];

        if(ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid)
        {
            dataPduIndex=ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex;
            sendQIndex=dataPduIndex;
            sendAckSFN=ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn;
            sendAckSF=ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf;

            if(PNULL!=ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p)
            {
                pduDataPointer=ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p;
            }


            ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid = 0;
            ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId = 255;
            ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex = INVALID_UE_INDEX;
            ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex = 255;
            ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti = INVALID_UE_INDEX;
            ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn = 0;
            ulHarqTimerEntityList_g[currentSFSubDelay].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf = 0;    

            if(!ulHarqTimerEntityList_g[currentSFSubDelay].count)
            {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"\n  ACK CASE currentSFN = %d currentSFSubDelay = %d and Count = %d at Line No = %d  \n",SFN_g,currentSFSubDelay,ulHarqTimerElementCount ,__LINE__);
#endif
            }
            else  
                ulHarqTimerEntityList_g[currentSFSubDelay].count--;

            timercount=ulHarqTimerEntityList_g[currentSFSubDelay].count;


            ueContextInfo_p->ulHarqTimerNodeArrrayIndex[currentSFSubDelay] = 255;

            // _ULHARQ_RETX_  start 

            if(ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p != PNULL)
            {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"ACKCASE BUFFER FREE currentSF %d currentSFSubDelay %d TIdx %d timercount %d dataPduIndex %d sendAckSFN %d sendAckSF %d pduDataPointer %016llX\n",currentSF,currentSFSubDelay,ulHarqTimerElementCount,timercount,sendQIndex,sendAckSFN,sendAckSF,pduDataPointer);
#endif
                freeMemPool(ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p);
            }
            else
            {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"ACKCASE BUFFER LEAK currentSF %d currentSFSubDelay %d TIdx %d timercount %d dataPduIndex %d sendAckSFN %d sendAckSF %d\n",currentSF,currentSFSubDelay,ulHarqTimerElementCount,timercount,sendQIndex,sendAckSFN,sendAckSF);
#endif
            }
            ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p=PNULL;
            ueContextInfo_p->ulDataPduInfo[dataPduIndex].PDULength=0;
            // _ULHARQ_RETX_  end  
        }
    }
#endif
}
/* +CA */
/****************************************************************************
 * Function Name  : getRntiType 
 * Inputs         :  rnti value 
 *                   cellIndex
 * Outputs        :  
 * Returns        :  
 * Description    : This function will return the type of rnti 
 *                   
 ****************************************************************************/
RNTIType getRntiType(UInt16 rnti, UInt8 cellIndex)
{
    RNTIType rntiType = NONE;
    RNTIInfo *rntiInfo_p = PNULL;
     
    if ( rnti >= startRARNTI_g && rnti <=  endRARNTI_g[cellIndex])
          rntiType = RA_RNTI;
    else if ( rnti == 0xFFFE ) // for other crnti range check
          rntiType = PRNTI;
    else if ( rnti == 0xFFFF )
          rntiType = SIRNTI;
    else if ( (rnti > endRARNTI_g[cellIndex]  &&  rnti <= 0xFFF3) )
    {
          rntiInfo_p = getRntiInfofromRNTIMap(rnti, cellIndex);
          if ( rntiInfo_p == PNULL )
          {
#ifdef LTE_MAC_UT_LOG
              lteWarning("no RNTI Info present for received [rnti = %d]\n", rnti);
#endif
              return rntiType;
          }
          //if ( rntiInfo_p->state == UE_INACTIVE || rntiInfo_p->state == WAIT_CONTENTION_RESOLUTION)
              rntiType = rntiInfo_p->rntiType;
          //else 
          //    rntiType = CRNTI;
    }
    return rntiType;
}
/* -CA */

/****************************************************************************
 * Function Name  :  fapiProcessUlGrant 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
void fapiProcessUlGrant(UInt8 harqIndex, UInt16 sendSfnSf, UInt8 qIndex, 
        UInt8 phichReceiveIndex, UInt8 delay, 
        FAPI_dlDCIPduInfo_st *dciPdu_p,
        UInt8 recvSFSPS, UInt16 recvSFNSPS, UInt8 cellIndex)
{
    RNTIInfo               *rntiInfo_p = PNULL;
    dynamicUEContext       *ulDynUEContext_p = PNULL;
    ueContextForUplink *ueContextInfo_p = PNULL;
    ulschDataQueueNode *uldataNode_p = PNULL;
    /*CLPC_CHG*/
    /* SPR 15909 fix start */
    tickType_t currentTick = getCurrentglobaltick();
    /* SPR 15909 fix end */
    UInt8 phrTriggered = FALSE;
    SInt8 tpcPUSCHAccInfoArr[4] = {-1, 0, 1, 3};
    SInt8 tpcPUSCHAbsInfoArr[4] = {-4, -1, 1, 4};

    UInt32 tbSize = 0;
    UInt8 crcFlag = 0;
    MacRetType macRetType;

    /* SPR 609 changes start */
#ifdef FAPI_UL_HARQ_ENABLE
    /* SPR 609 changes end */
    UInt16 ulHarqTimerElementCount = 0;
    UInt16 timercount=0;
    UInt16 pduPointerFlag=0;
    UInt16 numDataPdu   = 0;
    UInt16  currentSFN    = SFN_g;
    /* SPR 609 changes start */
#endif    
    /* SPR 609 changes end */
    pduDciDataPointer=PNULL;
    UInt8   currentSF     = SF_g[cellIndex];
    UInt16  ueIndex = 0;
#ifdef FDD_CONFIG    
    ULHarqInfo *ulHarqInfo_p                 = PNULL;
#elif TDD_CONFIG
    ULHARQProcess *ulharqProcess_p           = PNULL;
#endif   

#ifdef FDD_CONFIG
	/* For TTIB_Code */
    RLCHarqFailureInfo rlcHarqFailureInfo[11] = {{0,0}};
    UInt8 lIdx = 0;
#endif
    UInt8 ttiBundlingRtxFlag = 0;

    /* SPR 21958 PUSCH RAT1 Support Start */
    /* SPR 22741 Start */
#if defined(FDD_CONFIG) && defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE10)
    /* SPR 22741 End */
    UInt16 x, xmin, p = 0;
    UInt8 si[COMB_SET_SIZE]= {0,0,0,0},rbgIndexForSet[COMB_SET_SIZE]={0,0,0,0};
    UInt8 N = numRBGConfigured_g[cellIndex] +1;
    UInt8 M = COMB_SET_SIZE,i = 0;
    
    if(dciPdu_p->release10param.resourceAllocationType == TRUE)
    {
	    /* Function to decode comninatorial index*/
	   
	    xmin = 1;
	    for(i=0;i<M;i++)
	    {
		    x = xmin;
		    p = calcBinomialCoef((N-x),(M-i));
		    while(p > dciPdu_p->release10param.rbCoding)
		    {
			    x = x+1;
			    p = calcBinomialCoef((N-x),(M-i));
		    }
		    si[i] = x;
		    xmin = si[i]+1;
		    dciPdu_p->release10param.rbCoding = (dciPdu_p->release10param.rbCoding) - p;
		    rbgIndexForSet[i] = si[i];
	    } 
	    dciPdu_p->numOfRB = ((rbgIndexForSet[1] - rbgIndexForSet[0])+
			    (rbgIndexForSet[3] - rbgIndexForSet[2])) * rbgSize_g[cellIndex];
       /* SPR 22281 Fix Start */
	    dciPdu_p->rbStart = (rbgIndexForSet[0] - 1)* rbgSize_g[cellIndex] ; 
       /* SPR 22281 Fix End */
    }
#endif
    /* SPR 21958 PUSCH RAT1 Support End */
    if (dciPdu_p->rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti && 
            dciPdu_p->rnti <= cellConfigUeSim_g[cellIndex].endSpsCrnti && (dciPdu_p->numOfRB!=0))
    {
        populateSpsCrnti(dciPdu_p->rnti, cellIndex);  
    }
    rntiInfo_p = getRntiInfofromRNTIMap(dciPdu_p->rnti, cellIndex);
    /* + CQI_4.1 */
    DLUEContext *newUEContext_p = PNULL;
    newUEContext_p =  getDLUEContextFromRnti(dciPdu_p->rnti, cellIndex);

    /* - CQI_4.1 */
    if ( PNULL == rntiInfo_p )
    {
        fprintf(stderr,"fapiProcessUlGrant:no rnti inf opresent for rnti = %d\n", dciPdu_p->rnti);
        return;
    }
    ueIndex = rntiInfo_p->ueIndex;
    ueContextInfo_p = uplinkContextInfoMap_g[ueIndex];
    ulDynUEContext_p  = dynUEContextInfoMap_g[ueIndex];
    if ( PNULL == ueContextInfo_p )
    {
        fprintf(stderr,"fapiProcessUlGrant: ue context is NULL for rnti = %d\n", dciPdu_p->rnti);
        return;  
    }
    if ( PNULL == ulDynUEContext_p )
    {
        fprintf(stderr,"fapiProcessUlGrant: dynamicUe context is NULL for rnti = %d\n", dciPdu_p->rnti);
        return;  
    }

    /*CLPC_CHG*/
    if(CLPC_PUSCH_ENABLE)
    {
        if(ueContextInfo_p->dedicatedULPowerControlInfo.accumulationEnabled)
        {
            ueContextInfo_p->tpcPUSCH =  tpcPUSCHAccInfoArr[dciPdu_p->tpc] + 
                ueContextInfo_p->tpcPUSCH;
        }
        else
        {
            ueContextInfo_p->tpcPUSCH =  tpcPUSCHAbsInfoArr[dciPdu_p->tpc];
        }
    }
    /*CLPC_CHG*/

    /* SPR 1298 */
#ifdef FDD_CONFIG
	/* For TTIB_Code */
    if (!ueContextInfo_p->ttiBundling)
#endif
    {
        ueContextInfo_p->latDci0RcvdTick = globalTTITickCount_g;
    }
    /*Fix for Invalid BSR*/
    ueContextInfo_p->availGrantCounter = 0;
#ifdef UT_TESTING
    fprintf(stderr,"\n RCV Grant for %d\n",ueContextInfo_p->ueIdx);
#endif
    /*Fix for Invalid BSR*/
    UInt16 sendSFN = (sendSfnSf & FAPI_SFN_MASK ) >> FAPI_SFN_VALUE_SHIFT;
    UInt8 sendSF = sendSfnSf & FAPI_SF_MASK;

    /* + CQI_5.0 */
	if ( dciPdu_p->cqiRequest)
    {
        /* SPR 12135 Fix Start */
	// commented	newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF] = TRUE;               
		newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF] = dciPdu_p->cqiRequest;               
 /*  Aperiodic CQI Changes start*/
#ifdef FAPI_4_0_COMPLIANCE
        /* set num of bits at that SF ad SFN in a global array */
        /* + SPR_14047 */
        aperiodicCqiCsiFieldArr[sendSFN][sendSF][newUEContext_p->ueIndex] = \
                   
                    dciPdu_p->release10param.sizeOfCqiCsiField  + 1;
        /* - SPR_14047 */
/* SPR 12135 Fix End */
#endif
 /*  Aperiodic CQI Changes End*/
	}
#ifdef FDD_CONFIG
	/* For TTIB_Code */
    if (!ueContextInfo_p->ttiBundling)
    {

        /*MCS = 29 && RB <=4*/
        if((29 == dciPdu_p->mcs) && 
                (4 >= dciPdu_p->numOfRB))    
        {
            return;
        }
    }
#else
        /*MCS = 29 && RB <=4*/
        if((29 == dciPdu_p->mcs) && 
                (4 >= dciPdu_p->numOfRB))    
        {
            return;
        }

#endif    
    /* - CQI_5.0 */

#ifdef TDD_CONFIG  
    /* CA TDD Changes Start */
    UInt8 index  = sendSF + dlSfForUlAckNack_g[tddUlDlConfig_g[cellIndex]][sendSF];
    /* CA TDD Changes End */
    ULHARQEntity *ulHarqEntity_p = ueContextInfo_p->ulHarqEntity_p;
    /* + SPS_TDD */
                /* SPR 19679: TDD HARQ Multiplexing Changes Start*/
    if (!sendAckNack_g)
                /* SPR 19679: TDD HARQ Multiplexing Changes End*/
    {
        updateDaiAndBuildDlAckNack( ueContextInfo_p, 
                sendSFN,
                sendSF,
                dciPdu_p->dlAssignmentIndex,
                8,
                qIndex,
                0,
                0,
                /* CA TDD Changes Start */
                currentSF,
                cellIndex
                /* CA TDD Changes End */
                );
    }
    /* - SPS_TDD */
    tbSize = determineTBSize(dciPdu_p->mcs,dciPdu_p->numOfRB);

    ulharqProcess_p = &(ulHarqEntity_p->ulHarqProcess[harqIndex]);
    ulharqProcess_p->ulgrantrecvCount++;
    ulharqProcess_p->totalTBSize = tbSize;
    /*UESIM ADAPTIVE RETX FIX*/
    memcpy(&ulharqProcess_p->dciPdu,dciPdu_p,sizeof(FAPI_dlDCIPduInfo_st));
    /*UESIM ADAPTIVE RETX FIX*/
#elif FDD_CONFIG

    if (ueContextInfo_p->hiReceived)
    {
        ueContextInfo_p->hiReceived = 0;
    }
    ulHarqInfo_p = &ueContextInfo_p->ulharqInfo[harqIndex];
    ulHarqInfo_p->ulgrantrecvCount++;

    /* SPR 2082 changes start */

    if(dciPdu_p->mcs <= 28)
    {
        tbSize = determineTBSize(dciPdu_p->mcs,dciPdu_p->numOfRB);
        //        fprintf(stderr,"TBsize of ul grant =%d \n",tbSize);
    }
#ifdef FDD_CONFIG
    else if ((dciPdu_p->mcs == 31)&& (dciPdu_p->rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti) && 
            dciPdu_p->rnti <= cellConfigUeSim_g[cellIndex].endSpsCrnti && (dciPdu_p->numOfRB == 0))
    {
        //tbSize = determineTBSize(dciPdu_p->mcs,dciPdu_p->numOfRB);
        tbSize = 0;
    }
#endif
    else
    {
        tbSize = ulHarqInfo_p->tbSizeForNackCase; 
#ifdef UESIM_ENHANCEMENTS
        if(ulHarqInfo_p->riLen != dciPdu_p->numOfRB)
        {
            ltePanic("UL HARQ retransmission, same number of RB's = %d are given to UE as in" \ 
                    "initial transmission = %d, harqIndex = %d, ueIndex = %d\n",
                    ulHarqInfo_p->riLen,dciPdu_p->numOfRB,harqIndex,ueIndex);
        }
#endif        
    }
    /* SPR 2082 changes end */
#ifdef UESIM_ENHANCEMENTS
    ulHarqInfo_p->riLen = dciPdu_p->numOfRB;
#endif        
    ulHarqInfo_p->tbSizeForNackCase = tbSize;

#endif
    /* HI Pdu Multi UE Changes Start */
    if(dciPdu_p->rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti)
    {
        hi_pdu_crnti_array_g[dciPdu_p->rbStart][harqIndex].crnti = dciPdu_p->rnti;
        //fprintf(stderr,"Got sps grant \n");
    }
    else
    {
        hi_pdu_crnti_array_g[dciPdu_p->rbStart][harqIndex].crnti = dciPdu_p->rnti;
//        hi_pdu_crnti_array_g[dciPdu_p->rbStart][harqIndex].crnti = ueContextInfo_p->crnti;
    }
#ifdef FDD_CONFIG
	/* For TTIB_Code */
    if(ueContextInfo_p->ttiBundling && ueContextInfo_p->ttibInfo.bundleStartIndex != TTIB_INVALID_VALUE)
    {
        if(dciPdu_p->rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti)
        {
            hi_pdu_crnti_ttib_array_g[dciPdu_p->rbStart][harqIndex].crnti = dciPdu_p->rnti;
        }
        else
        {
            hi_pdu_crnti_ttib_array_g[dciPdu_p->rbStart][harqIndex].crnti = ueContextInfo_p->crnti;
        }
    }
#endif                
    /* HI Pdu Multi UE Changes Ends */ 

#ifdef UE_SIM_ENABLE_PRINTF_LOGS 
    fprintf(stderr,"DBGDELAY currentSFN %d currentSF %d delay %d\n",SFN_g,SF_g,delay);
#endif

    crcFlag = preapreCRCIndication(MAC_PHY_CONVERT_16(dciPdu_p->rnti),sendSfnSf, 
            qIndex, FALSE, cellIndex);
    if ( FAPI_CRC_CORRECT == crcFlag )
    {
#ifdef FAPI_UL_HARQ_ENABLE
        /* send oppartunity to RLC for UL Data */
        /* The following lines are being added to Enhance the Harq Functionality in UL Direction*/
        //fprintf(stderr,"sending crc ind after ifdef at [%u] qIndex=%d phichIndex=%d \n",globalTTITickCount_g,qIndex,phichReceiveIndex);
        ulHarqTimerElementCount = ulHarqTimerEntityList_g[phichReceiveIndex].count;

        if(ulHarqTimerElementCount>0)
        {
            timercount=ulHarqTimerElementCount--;    
            if(ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid)
            {
                if(ulHarqTimerEntityList_g[phichReceiveIndex].count>=1)
                {
                    ulHarqTimerEntityList_g[phichReceiveIndex].count=ulHarqTimerElementCount;

                    freeqIndex=ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex;
                    oldSF=ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf;
                    oldSFN=ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn;
                    checkCurrentSFN=currentSFN;
                    checkCurrentSF=currentSF;
                    checkackSF=phichReceiveIndex;
                    checkTIdx=ulHarqTimerElementCount;

                    if(PNULL!=ueContextInfo_p->ulDataPduInfo[freeqIndex].Pdudata_p)
                    {
                        pduDciDataPointer = ueContextInfo_p->ulDataPduInfo[freeqIndex].Pdudata_p;
                        pduPointerFlag=1;
                        ueContextInfo_p->ulDataPduInfo[freeqIndex].Pdudata_p=PNULL;
                    }

                    if(freeqIndex!=SF_g)
                    {
                        numDataPdu=sQueueCount(&ulDataQueue[cellIndex][freeqIndex] );
                        if(numDataPdu )
                        {
                            uldataNode_p= (ulschDataQueueNode*) popNode\\
                                          (&ulDataQueue[cellIndex][freeqIndex]);

                            if(PNULL!=uldataNode_p)
                            {
                                if ( PNULL != uldataNode_p->pdudata_p)
                                {
                                    freeMemPool(uldataNode_p->pdudata_p);
                                    uldataNode_p->pdudata_p = PNULL;
                                }
                                freeMemPool(uldataNode_p);
                                uldataNode_p=PNULL;
                            }

                        }
                    }
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                    fprintf(stderr,"DCIFORMAT0 RETX BUFFER FREE freeqIndex %d freeSF %d freeSFN %d numDataPdu %d TIdx %d timercount %d \n",freeqIndex,oldSF,oldSFN,numDataPdu,ulHarqTimerElementCount,timercount);
#endif

                    if(1==pduPointerFlag)
                    {
                        pduPointerFlag=0;

                        if(pduDciDataPointer)
                        {
                            freeMemPool(pduDciDataPointer);
                        }    
                        pduDciDataPointer=PNULL;
                    }
                }
            }  
        }

        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId = harqIndex;
        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid = 1;
        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex = ueIndex;
        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex = qIndex;
        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti = MAC_PHY_CONVERT_16(dciPdu_p->rnti); 
        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn = (sendSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT;
        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf = sendSfnSf & FAPI_SF_MASK;
        ueContextInfo_p->ulHarqTimerNodeArrrayIndex[phichReceiveIndex] = ulHarqTimerElementCount;
        ulHarqTimerEntityList_g[phichReceiveIndex].count++;
        timercount=ulHarqTimerEntityList_g[phichReceiveIndex].count;
#endif
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"DCIFORMAT0 TIMERSTART hI %d qI %d sendSF %d sendSFN %d ackSF %d TIdx %d timercount %d\n",harqIndex,qIndex,ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf,ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn,phichReceiveIndex,ulHarqTimerElementCount,timercount);
#endif
        /*SPR 907 changes Start  */
        if (tbSize >= 8) /*ULA_UTP*/
        {
            ueContextInfo_p->bsrPresentFlag = 1;
            if((ueContextInfo_p->phrFlag == TRUE) &&
                    (ueContextInfo_p->phrTime <= globalTTITickCount_g))
            {
                phrTriggered = TRUE;
            }
            else
            {
                phrTriggered = FALSE;
            }

            uldataNode_p = fapiGetULDataPduNode (qIndex, sendSfnSf,
                    MAC_PHY_CONVERT_16(dciPdu_p->rnti));
            if ( uldataNode_p == PNULL )
            {
                printf("Not able to get memory for ulschDataQueueNode\n");
                return;
            }
#ifdef FDD_CONFIG
             /** TTIB_Code Start */
	    if (ueContextInfo_p && ueContextInfo_p->ttiBundling &&
	       (ulHarqInfo_p->dciPdu.newDataIndication == dciPdu_p->newDataIndication) 
		&& (dciPdu_p->mcs > 28)
                && ulHarqInfo_p && ulHarqInfo_p->transmissionBuffer_p)
	    {
            /* Fetch Entity context using LCID and UE Idx. */
            for ( lIdx = 0; lIdx < ulHarqInfo_p->transmissionBuffer_p->lccount; lIdx++)
            {
                RLCDataBuffer* rlcDataBuffer_p  = ulHarqInfo_p->transmissionBuffer_p->rlcDataBufferArr;
                rlcHarqFailureInfo[lIdx].lcId = rlcDataBuffer_p[lIdx].lcID;
            }
            ulHarqInfo_p->transmissionBuffer_p->dataPtr_p = &(uldataNode_p->pdudata_p);
            ulHarqInfo_p->transmissionBuffer_p->dataLen_p = &(uldataNode_p->pduLen);
            ulHarqInfo_p->transmissionBuffer_p->uldataNode_p = uldataNode_p;

            /*Fix for SPR 11915,pass the below parameter as 1 for TTIB retransmitted pkts */
            ttiBundlingRtxFlag = 1;   
		   
		    multiplexAndSendDataToPhysical(ueIndex,
				    ulHarqInfo_p->transmissionBuffer_p->lccount,
				    ulHarqInfo_p->transmissionBuffer_p,
                    &rlcHarqFailureInfo, cellIndex,
                    ttiBundlingRtxFlag);
	    }
	    else
             /** TTIB_Code End */
#endif
	    {
#if 0
		    if(ueContextInfo_p && ueContextInfo_p->ttiBundling && 
                       ulHarqInfo_p->transmissionBuffer_p != PNULL) 
		    {
                UInt32 index=0;
                TransmissionAndRLCData *transmissionAndRLCData_p=ulHarqInfo_p->transmissionBuffer_p; 
                for(index=0; index < transmissionAndRLCData_p->lccount; index++)
                {
                    if(transmissionAndRLCData_p->rlcDataBufferArr[index].statusPdu_p)
                    {
                        msgFree((void*)transmissionAndRLCData_p->rlcDataBufferArr[index].statusPdu_p);
                    }
                    if(transmissionAndRLCData_p->rlcDataBufferArr[index].newRlcPdu_p)
                    {
                        msgFree((void*)transmissionAndRLCData_p->rlcDataBufferArr[index].newRlcPdu_p);
                    }
                    transmissionAndRLCData_p->rlcDataBufferArr[index].statusPdu_p = PNULL;
                    transmissionAndRLCData_p->rlcDataBufferArr[index].newRlcPdu_p = PNULL;
                    rlcReTxPduNode *rlcReTxPduNode_p = PNULL;
                    retxCount = QUEUE_COUNT_AMD_RETX_PDU_Q(transmissionAndRLCData_p->rlcDataBufferArr[index].reTxRlcPduQ);
                    if(retxCount)
                    {
                        DEQUEUE_AMD_RETX_PDU_Q(rlcReTxPduNode_p,
                                transmissionAndRLCData_p->rlcDataBufferArr[index].reTxRlcPduQ);
                        msgFree( rlcReTxPduNode_p->retxRlcPdu_p);
                        fprintf(stderr,"[%s] [%d] [%d] \n",__func__,__LINE__,globalTTITickCount_g);
                        rlcReTxPduNode_p->retxRlcPdu_p = PNULL;
                        freeMemPool(rlcReTxPduNode_p);
                        fprintf(stderr,"[%s] [%d] [%d] \n",__func__,__LINE__,globalTTITickCount_g);
                        rlcReTxPduNode_p = PNULL;        
                    }
                }
                freeMemPool(ulHarqInfo_p->transmissionBuffer_p);
                ulHarqInfo_p->transmissionBuffer_p = PNULL;

		    }
#endif
            /*SPS_TDD_Changes*/
#ifdef TDD_CONFIG
            if((getRntiType(dciPdu_p->rnti, cellIndex) == FAPI_SPS_CRNTI) && (dciPdu_p->numOfRB!=0)
                    && (ueContextInfo_p->ulNdi == 0))
            {
                ueContextInfo_p->isSpsOccasion = TRUE;
                processSPSGrant (dciPdu_p,spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\  
                        spsUplinkSetupInfo.semiPersistentSchedIntervalUL],recvSFSPS, recvSFNSPS,cellIndex);
                ueContextInfo_p->ulNdi = 1;
            }
#endif
            /*SPS_TDD_Changes*/

            macRetType = distributeRBsAndSendReqToRLC( ueIndex,
				    tbSize,
				    ueContextInfo_p->bsrPresentFlag,
				    uldataNode_p,
				    &(uldataNode_p->pdudata_p),
				    &(uldataNode_p->pduLen),
				    phrTriggered
#ifdef FDD_CONFIG
	/* For TTIB_Code */
                                    ,&ulHarqInfo_p->transmissionBuffer_p
#endif
				    ,cellIndex);

	    
            if ( MAC_SUCCESS == macRetType )
            {

                if( (getRntiType(dciPdu_p->rnti, cellIndex) == 
							FAPI_SPS_CRNTI) && (dciPdu_p->numOfRB!=0) )
                {
                    ueContextInfo_p->ulEmptyTx = 0;
                }
            }
            else if ( MAC_PARTIAL_SUCCESS == macRetType )
            {
                if((ueContextInfo_p->phrFlag == TRUE) &&
                        (ueContextInfo_p->phrTime <= currentTick))
                {
                    fapiPrepareLongBSRAndPHR(ulDynUEContext_p, 
							MAC_PHY_CONVERT_16(dciPdu_p->rnti), sendSfnSf, 
							qIndex,uldataNode_p, tbSize, TRUE, cellIndex);
                    ueContextInfo_p->phrTime = currentTick +
                        phrProfileInfo_g[cellIndex][ueProfileInfo_g[cellIndex]
						[ueContextInfo_p->ueProfileId].phrProfileId].phrTimer;
                }
                else
                {
					fapiPrepareLongBSRAndPHR(ulDynUEContext_p, 
							MAC_PHY_CONVERT_16(dciPdu_p->rnti), sendSfnSf, 
							qIndex,uldataNode_p, tbSize, FALSE, cellIndex);
                }

                /* Check for Empty TX for SPS-CRNTI and trigger implicit release */
                if( (getRntiType(dciPdu_p->rnti, cellIndex) == 
							FAPI_SPS_CRNTI) && (dciPdu_p->numOfRB!=0) &&
                        (ueContextInfo_p->occListNode_p !=PNULL) )    
                {
                    ueContextInfo_p->ulEmptyTx++;

                    if(ueContextInfo_p->ulEmptyTx == ueContextInfo_p->spsUplinkInfo.\
                            spsUplinkSetupInfo.implicitReleaseAfter )
                    {
                        removeSPSGrant(dciPdu_p, cellIndex);
                        ueContextInfo_p->ulEmptyTx = 0;
                        return;
                    }
                }
            }
            else
            {
                /* SPR 2417 changes start */
                freeMemPool(uldataNode_p);
                uldataNode_p = PNULL;
                /* SPR 2417 changes end */
            }
        }
            /*SPS_TDD_Changes*/
#ifdef FDD_CONFIG
            /*SPS_TDD_Changes*/
            /*processSPSGrant for SPS Activation*/
            if((getRntiType(dciPdu_p->rnti, cellIndex) == 
						FAPI_SPS_CRNTI) && (dciPdu_p->numOfRB!=0)
                    && (ueContextInfo_p->ulNdi == 0))

            {
                //fprintf(stderr,"SPS GRANT RECEIVED frm L2 \n");
                processSPSGrant (dciPdu_p,spsIntervalMap_g[
						ueContextInfo_p->spsUplinkInfo.spsUplinkSetupInfo.\
						semiPersistentSchedIntervalUL],recvSFSPS, 
						recvSFNSPS, cellIndex);
                ueContextInfo_p->ulNdi = 1;
            }
            /*SPS_TDD_Changes*/
#endif
            /*SPS_TDD_Changes*/
        }
        else
        {
            uldataNode_p = fapiGetULDataPduNode (qIndex, sendSfnSf,
                    MAC_PHY_CONVERT_16(dciPdu_p->rnti));
            if ( uldataNode_p == PNULL )
            {
                printf("Not able to get memory for ulschDataQueueNode\n");
                return;
            }
            /* handling of UL Grant */
            //rntiInfo_p->state = UE_ACTIVE;
            if((ueContextInfo_p->phrFlag == TRUE && ueContextInfo_p->phrTime
                        <= currentTick)&&(tbSize >= 6))
            {
                fapiPrepareLongBSRAndPHR(ulDynUEContext_p, 
						MAC_PHY_CONVERT_16(dciPdu_p->rnti), sendSfnSf, 
						qIndex,uldataNode_p, tbSize, TRUE, cellIndex);
                ueContextInfo_p->phrTime = currentTick +
                    phrProfileInfo_g[cellIndex][ueProfileInfo_g[cellIndex]
					[ueContextInfo_p->ueProfileId].phrProfileId].phrTimer;
            }
            else
            {
				fapiPrepareLongBSRAndPHR(ulDynUEContext_p, 
						MAC_PHY_CONVERT_16(dciPdu_p->rnti), sendSfnSf,
						qIndex,uldataNode_p, tbSize, FALSE, cellIndex);
            }

            //fprintf(stderr,"prepareLongBSR Sent crnti %d\n", MAC_PHY_CONVERT_16(dciPdu_p->rnti));
            /*processSPSGrant for SPS Deactivation*/
            if( (getRntiType(dciPdu_p->rnti, cellIndex) == 
						FAPI_SPS_CRNTI) && (dciPdu_p->numOfRB == 0))
            {

                //fprintf(stderr,"recieved SPS deact grant at tick[%u] \n",globalTTITickCount_g);
                removeSPSGrant(dciPdu_p, cellIndex);
                ueContextInfo_p->ulEmptyTx =0;
                return;
            }
        }
        /*SPR 907 changes Start  */
    }
    /* SPR 2333 Changes Begin */
    else
    {
        if (PNULL == ((ulschDataQueueNode *)ueContextInfo_p->ulschIndRefNode_p[qIndex]))
        {
            uldataNode_p = fapiGetULDataPduNode (qIndex, sendSfnSf,
                    MAC_PHY_CONVERT_16(dciPdu_p->rnti));
            pushNode(&ulDataQueue[cellIndex][qIndex], 
                    &(uldataNode_p->ulDataAnchor));
            ueContextInfo_p->ulschIndRefNode_p[qIndex] = uldataNode_p;
        } 
    }
    /* SPR 2333 Changes Ends */
}
/****************************************************************************
 * Function Name  :  fapiHandlePhyHiDciRequest 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
void fapiHandlePhyHiDciRequest(FAPI_l1ApiMsg_st *l1RcvMsg_p, UInt8 cellIndex)
{
    FAPI_dlHiDCIPduInfo_st   *hiDciReq_p = PNULL;
    FAPI_dlDCIPduInfo_st     *dciPdu_p = PNULL;
    FAPI_dlHiPduInfo_st      *hiPdu_p = PNULL;
    UInt8 * PhyHiDciresp_p=PNULL;
    UInt32 PhyHiDciresp_size = 0;
    UInt8 *recvBuffer_p = PNULL;
    UInt16 currentSFN = 0, recvSFN = 0, receivedSf = 0, recvSFNSPS = 0;
    UInt16 currentSfnSf = 0, recvSfnSf = 0;
    UInt8  currentSF = 0, recvSF = 0, recvSFSPS=0;
    UInt16 sendSfnSf = 0;
    UInt8  delay = 0, qIndex = 0;
#ifdef FDD_CONFIG
   /** TTIB_Code Start */
    SInt8 tick = 0;
    UInt8 queueCount = 0;
    UInt8 diff = 0,index = 0;
    /* SPR 15909 fix start */
    tickType_t ttibqIndex = 0;
    /* SPR 15909 fix end */
    UInt8 ttibRetxqIndex = 0;
    UInt8 ttibRetxSendSF = 0;
    UInt16 ttibRetxSendSFN = 0;
    UInt16 ttibRetxSendSfnSf = 0;
    ulschDataQueueNode *ulschDataNode_p= PNULL;
   /** TTIB_Code End */
#endif
    UInt16 numOfDci = 0, numOfHi = 0;
    UInt16 count = 0;
    ControlNodeInfo    ctlInfo  = {0};
    /* HI Pdu Multi UE Changes*/
    UInt8 sendSF = 0;
    UInt8 chkNDI = 0;
    UInt16 sendSFN = 0; 
    UInt8 harqIndex = 0;
    /* HI Pdu Multi UE Changes*/
    UInt8  phichReceiveIndex   = 0; 
    /* + MEAS_GAP_CHG*/
    DLUEContext *newUEContext_p = PNULL;
    UInt16 dci0SFN = 0;
    UInt8  dci0SF  = 0;
    /* -  MEAS_GAP_CHG*/
    ULHarqInfo* ulHarq_p = PNULL;

    /*CLPC_CHG*/
    ueContextForUplink *ueContextInfo_p = NULL;
    SInt8 tpcPUSCHAccInfoArr[4] = {-1, 0, 1, 3};
    SInt8 tpcPUCCHAccInfoArr[2] = {-1, 1};
    UInt8 idx = 0;
    UInt8 offset = 0;
    UInt8 tpcCommand = 0;
    UInt16 ueIndex;
    UInt16 bitmapIndex;

    RNTIInfo               *rntiInfo_p  = PNULL;
    UInt32 subFrameNum = 0;
    UInt32 sysFrameNum = 0;
    UInt16 expectedSfnSf = 0;

    /* Since global tick is updated on sending of SFI message, hence HI_DCI_0 
     * tick will be 1 less */
    /* SPR 15909 fix start */
    tickType_t hiDci0Tick = globalTTITickCount_g - 1;
    /* SPR 15909 fix end */
    /*TDD Config 0 And 6 Changes Start*/
#ifdef TDD_CONFIG
    UInt8 iPhich = 0;
    UInt16 receivedSfn = 0;
    UInt16 sendSFNFor2ndUlSf = 0;
    UInt8 sendSFFor2ndUlSf = 0;
    UInt16 sendSfnSfFor2ndUlSf = 0;
    UInt8 harqIdFor2ndUlSf = 0;
    UInt8 qIndexFor2ndUlSf = 0;
    UInt8 ulIndex = 0;
    UInt8 calcHarqId = 0;
    /* SPR 11562 Changes Start */
    /*SPR 15909 fix start*/
    tickType_t tickFrmCurrSfnSf = 0;
    tickType_t tickFrmRecvSfnSf = 0;
    tickType_t correctedHarqTick = 0;
    /*SPR 15909 fix end*/
    UInt16 currentSfnFrmTick = 0;
    UInt8  currentSfFrmTick = 0;
    /* SPR 11562 Changes End */

#endif
    /*TDD Config 0 And 6 Changes End*/

    if ( l1RcvMsg_p->msgLen == 0 )
    {
        fprintf(stderr,"Error..!!! msgLen = 0 recevied from MAC in UL CONFIG REQ\n");  
        return;
    }
    /*FAPI_ERROR_INDICATION_CHANGES_START*/
    /*Send phy error in case of invalid phy state*/
    if ((1 == phy_err_config_g[cellIndex])&&\
        (( hiDci0Tick >= phy_err_start_tti_g[cellIndex]) && \
        ( hiDci0Tick <= phy_err_end_tti_g[cellIndex])) && (errorCount_g[cellIndex] == 0))
        {
        if ((PHY_DL_HI_DCI0_REQUEST == phy_err_msg_type_g[cellIndex]) && (FAPI_MSG_INVALID_STATE == phy_err_error_type_g[cellIndex]))
        {
            fapiSendErrorIndication(FAPI_MSG_INVALID_STATE, l1RcvMsg_p->msgId,
                    0,0,&PhyHiDciresp_p,&PhyHiDciresp_size, cellIndex);
#ifdef HO_SETUP_CHANGES
            sendSFItoSourceENBMac(PhyHiDciresp_p,PhyHiDciresp_size, cellIndex);
            if ( startRecvFlag[cellIndex] == 2 )
            {
                sendDataToTargetEnbMac(PhyHiDciresp_p,PhyHiDciresp_size,cellIndex);
            }
#else
            sendDatatoPeerMac( (UInt8 *)PhyHiDciresp_p,PhyHiDciresp_size, cellIndex);
#endif            
            freeMemPool(PhyHiDciresp_p);
            PhyHiDciresp_p = PNULL;
            phyState_g[cellIndex] = FAPI_CONFIGURED;
            /*Reset the global vars */
            resetGlobals(cellIndex);
            errorCount_g[cellIndex]++;
            return;
        }
    }
    /*FAPI_ERROR_INDICATION_CHANGES_END*/


#ifndef HO_SETUP_CHANGES
    if ( FAPI_RUNNING != phyState_g[cellIndex] )
    {
        /* send error indication */
        /* FAPI_MSG_INVALID_STATE */
        fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId, 
                recvSfnSf,0,&PhyHiDciresp_p,&PhyHiDciresp_size, cellIndex);
        sendMsgtoTargetL2Config( (UInt8 *)PhyHiDciresp_p,PhyHiDciresp_size, cellIndex);
        freeMemPool( PhyHiDciresp_p );
        PhyHiDciresp_p = PNULL;
        return;
    }
#endif
    hiDciReq_p = ( FAPI_dlHiDCIPduInfo_st * ) &(l1RcvMsg_p->msgBody[0]);
    if ( PNULL == hiDciReq_p)
    {
        fprintf(stderr,"Error..!! ulConfig req has no data\n");
        return;
    }
    numOfDci = hiDciReq_p->numOfDCI;
    numOfHi = hiDciReq_p->numOfHI;
    /* SPR 10482 START */
    currentSfnSf = sfnsf_g[cellIndex];
    /* SPR 10482 END */
    recvSfnSf = MAC_PHY_CONVERT_16(hiDciReq_p->sfnsf); 
    recvSFN = recvSfnSf & FAPI_SFN_MASK;
    recvSFN >>= FAPI_SFN_VALUE_SHIFT; 
    /* SPR 19679: TDD HARQ Multiplexing Changes Start*/
    UInt16 sendSFNMUX = recvSFN;
    UInt16 temp = sendSFNMUX;
    /* SPR 19679: TDD HARQ Multiplexing Changes End*/
    recvSF = recvSfnSf & FAPI_SF_MASK;
    currentSFN = currentSfnSf & FAPI_SFN_MASK;
    currentSFN >>= FAPI_SFN_VALUE_SHIFT;
    currentSF = currentSfnSf & FAPI_SF_MASK;
    receivedSf = recvSF;
    /* SPR 19679: TDD HARQ Multiplexing Changes Start*/
    UInt16 recSFMUX = recvSF;
    /* SPR 19679: TDD HARQ Multiplexing Changes End*/
    /*TDD Config 0 And 6 Changes Start*/
#ifdef TDD_CONFIG
    receivedSfn = recvSFN;
#endif
    /*TDD Config 0 And 6 Changes Start*/

    recvSFSPS=recvSF;
    recvSFNSPS=recvSFN;
    /*FAPI_ERROR_INDICATION_CHANGES_START*/
    /* Initialize invalidSfnRcvd_g to FALSE so that CRC error is not triggered
     * for consecutive UL Config */
    invalidSfnRcvd_g = FALSE;
    /*Send phy error in case of discrepancy in expected and received
     * SFN/SF*/
    if ((1 == phy_err_config_g[cellIndex])&&\
        (( hiDci0Tick >= phy_err_start_tti_g[cellIndex]) && \
        ( hiDci0Tick <= phy_err_end_tti_g[cellIndex])) && (errorCount_g[cellIndex] == 0))
        {
        if ((PHY_DL_HI_DCI0_REQUEST == phy_err_msg_type_g[cellIndex]) && (FAPI_MSG_INVALID_SFN == phy_err_error_type_g[cellIndex]))
        {
            if (phy_err_abs_delta_val_g[cellIndex])
            {
                subFrameNum = recvSF;
                sysFrameNum = recvSFN;
                if( 0 <= phy_err_delta_val_g[cellIndex] )
                {
                    UInt16 deltaVal = phy_err_delta_val_g[cellIndex];
                    while( deltaVal-- )
                    {
                        subFrameNum++;
                        if( MAX_SUBFRAME <= subFrameNum )
                        {
                            subFrameNum = 0;
                            sysFrameNum++;
                        }
                    }
                }
                else 
                {
                    UInt16 deltaVal = ABS( phy_err_delta_val_g[cellIndex] );
                    while( deltaVal-- )
                    {
                        if( 0 == subFrameNum )
                        {
                            subFrameNum = MAX_SUBFRAME - 1;
                            if( 0 == sysFrameNum )
                            {
                                sysFrameNum = 1023;
                            }
                            else
                            {
                                sysFrameNum--;
                            }
                        }
                        else
                        {
                            subFrameNum--;
                        }
                    }
                }
                expectedSfnSf = ( ( (sysFrameNum) << 4) | ( (subFrameNum) & 0xf) );
                fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId,
                        recvSfnSf, expectedSfnSf,&PhyHiDciresp_p,&PhyHiDciresp_size, cellIndex);

                UInt8 errQIdx = recvSF + 1;
                if( errQIdx >= MAX_SUBFRAME )
                {
                    errQIdx -= MAX_SUBFRAME;
                }
                LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                        sizeof(PhyErrInd), PNULL );
                if( PNULL == phyErrInd_p )
                {
                    freeMemPool(PhyHiDciresp_p);
                    PhyHiDciresp_p = PNULL;
                    return;
                }
                else
                {
                    phyErrInd_p->data_p = PhyHiDciresp_p;
                    phyErrInd_p->dataSize = PhyHiDciresp_size;

                    ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx ,cellIndex);
                }
                phy_err_abs_delta_val_g[cellIndex]--;
                invalidSfnRcvd_g = TRUE;
            }
            else
            {
                errorCount_g[cellIndex]++;
            }
        }
    }
    /*FAPI_ERROR_INDICATION_CHANGES_END*/

#ifdef TDD_CONFIG
    if (( delay = validateTick( recvSFN,
                    recvSF,
                    currentSFN,
                    currentSF
                    )) == 0xFF )
    {

        fprintf(stderr,"UL CONFIG packet Drooped due to delayed received\n");
        fprintf(stderr,"UL Control: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);

        /* send error indication */
        /* FAPI_MSG_INVALID_SFN */
        fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId,
                recvSfnSf, sfnsf_g, &PhyHiDciresp_p,&PhyHiDciresp_size, cellIndex);

        /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
        sendSFItoSourceENBMac( (UInt8 *)PhyHiDciresp_p,PhyHiDciresp_size, cellIndex); 
        /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
        freeMemPool( PhyHiDciresp_p );
        PhyHiDciresp_p = PNULL;
        return;
    }

#elif FDD_CONFIG
    /* check for validation of recevied SFN & SF from MAC */ 
    if (( delay = validateSFNandSFAndgetDelay(recvSFN, recvSF, 
                    currentSFN, currentSF)) == 0xFF )
    {
        fprintf(stderr,"UL CONFIG packet Drooped due to delayed received\n");
        fprintf(stderr,"UL Control: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);

        /* send error indication */
        /* FAPI_MSG_INVALID_SFN */
        fapiSendErrorIndication(FAPI_MSG_INVALID_SFN, l1RcvMsg_p->msgId, 
                recvSfnSf, sfnsf_g, &PhyHiDciresp_p,&PhyHiDciresp_size, cellIndex);
        /* + FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
        sendSFItoSourceENBMac( (UInt8 *)PhyHiDciresp_p,PhyHiDciresp_size, cellIndex);
        /* - FAPI_ERR_IND_SEND_ON_DATA_PORT_CHANGES */ 
        freeMemPool( PhyHiDciresp_p );
        PhyHiDciresp_p = PNULL;
        return;
    }
#endif

    //  fprintf(stderr," after validation of UL grant recvSF = %d recvSFN = %d currentSF = %d currentSFN = %d recvsfnsf = %d, delay = %d\n",recvSF,recvSFN,SF_g,SFN_g, recvSfnSf,delay );

#ifdef TDD_CONFIG

    Dci0HiPdu *dci0HiPdu_p = PNULL;
    Dci0HiPdu dci0HiPdu;
    dci0HiPdu_p = (Dci0HiPdu *) &dci0HiPdu;

    UInt16 enbSFN = recvSFN;
    UInt8  enbSF  = recvSF;

    calQIdxSFandSFN( recvSF,
            recvSFN,
            delay,
            dci0HiPdu_p
            /* SPR 11568 Start */
            ,cellIndex
            /* SPR 11568 End */
            );

    recvSFN = dci0HiPdu_p->hiSFN;
    recvSF  = dci0HiPdu_p->hiSF;
    qIndex  = dci0HiPdu_p->hiQIdx;

    phichReceiveIndex = (enbSFN * 10 + enbSF) % MAX_UL_HARQ_TIMER_ARRAY;

#elif FDD_CONFIG

    //Rajesh
    //qIndex = currentSF + 4 - delay - PEER_MAC_DELAY;
    //phichReceiveIndex = currentSF + 8 - delay - PEER_MAC_DELAY;
    qIndex = recvSF + 4 + PEER_MAC_DELAY;
     /* For TTIB_Code */
    ttibqIndex = globalTTITickCount_g ;

    phichReceiveIndex = recvSF + 8;
    if (qIndex >= MAX_SUBFRAME)
    {
        qIndex -= MAX_SUBFRAME;
    }
    if (phichReceiveIndex >= MAX_SUBFRAME)
    {
        phichReceiveIndex -= MAX_SUBFRAME;
    }

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,
            "after validation of UL grant recvSF = %d recvSFN = %d currentSF = %d currentSFN = %d recvsfnsf = %d\n",
            recvSF,recvSFN,SF_g,SFN_g, recvSfnSf );
#endif

    recvSF += 4;
    if ( recvSF >= MAX_SUBFRAME )
    {
        recvSF -= MAX_SUBFRAME;
        recvSFN++ ;
        if ( recvSFN == MAX_SFN )
        {
            recvSFN = 0;
        }
    }
#endif


    sendSfnSf = GENERATE_SUBFRAME_SFNSF(recvSFN, recvSF);
    ctlInfo.sendSF      = recvSF;
    ctlInfo.sendSFN     = recvSFN;
    ctlInfo.qIndex      = qIndex;
   
    numOfDci = hiDciReq_p->numOfDCI;
    numOfHi = hiDciReq_p->numOfHI;

    /* HI Pdu Multi UE Changes Starts */ 
#ifdef FDD_CONFIG
    sendSF = sendSfnSf & FAPI_SF_MASK;
    sendSFN = (sendSfnSf & FAPI_SFN_MASK ) >> FAPI_SFN_VALUE_SHIFT;
    harqIndex = (((sendSFN * MAX_SUBFRAME) + sendSF /*+ HI_DCI_DIFF*/) % MAX_HARQ_PROCESS_NB);
    //fprintf(stderr,"UL will be sent in SendSF = %d, SendSFN = %d, recvSF = %d, recvSFN = %d\n", sendSF, sendSFN, recvSF, recvSFN );
#elif TDD_CONFIG
    /*TDD Config 0 And 6 Changes Start*/
    sendSF = sendSfnSf & FAPI_SF_MASK;
    /* CA TDD Changes Start */
    if (tddUlDlConfig_g[cellIndex] > 0 && tddUlDlConfig_g[cellIndex] < 6)
    {
    harqIndex = harqIdArray_g[tddUlDlConfig_g[cellIndex]][sendSF];
    }
    else if (tddUlDlConfig_g[cellIndex] == 6)
    {
        /* CA TDD Changes End */
        /* SPR 11562 Changes Start */
        currentSfnFrmTick = (globalTTITickCount_g/MAX_SUBFRAME) % MAX_SFN;
        currentSfFrmTick = globalTTITickCount_g % MAX_SUBFRAME;

        /*
         ** In Rel5.4.0, this has been observed that sometimes RLC/PDCP are taking time more than 1ms.
         ** In this case, FAPI is not sending UL SFI indication to eNodeB in 1 ms.
         ** No impact is observed on eNodeB as it works on SFI indication received from FAPI rather than REAL time.
         ** But, sometime issue is observed on uesim that the messages(HI, DCI0 and so on) are being processed one
         ** tick late on uesim.
         **
         ** To correct this, we are putting check to process the message on recv tick rather than current globalTTITickCount
         ** with following assuption:
         ** a) if recv tick not equal to current sfn then it's received late not in advance.
         */
        if ( currentSfnFrmTick != receivedSfn)
        {
            /*
             ** Two case can be possible :
             ** 1 case: current tick SFN is wrap around(0) and receive tick is still 1023
             ** 2 case : normal case no wrap around.
             */
            if (currentSfnFrmTick < receivedSfn)
            {
                tickFrmCurrSfnSf = ((MAX_SFN + currentSfnFrmTick) * MAX_SUBFRAME) + currentSfFrmTick;

            }
            else
            {

                tickFrmCurrSfnSf = (currentSfnFrmTick * MAX_SUBFRAME) + currentSfFrmTick;
            }
        }
        else
        {
            tickFrmCurrSfnSf = (currentSfnFrmTick * MAX_SUBFRAME) + currentSfFrmTick;
        }
        tickFrmRecvSfnSf = (receivedSfn * MAX_SUBFRAME) + receivedSf;
        if (tickFrmCurrSfnSf > tickFrmRecvSfnSf)
        {
            correctedHarqTick = globalTTITickCount_g -  (tickFrmCurrSfnSf - tickFrmRecvSfnSf);
        }
        else
        {
            correctedHarqTick = globalTTITickCount_g +  (tickFrmRecvSfnSf - tickFrmCurrSfnSf);
        }

        /* SPR 11066 Changes Start */
        /* SPR 11257 Changes Start */
        /* CA TDD Changes Start */
        calcHarqId = (correctedHarqTick + ulSfForDCI0OrHiReceived_g[tddUlDlConfig_g[cellIndex]][receivedSf]) % MAX_HARQ_MAP_CONFIG6_SIZE;
        /* CA TDD Changes End */
        /* SPR 11257 Changes End */
        /* SPR 11562 Changes End */
        harqIndex = harqIdArrayTdd6_g[calcHarqId];
        /* SPR 11066 Changes End */
    }
    /*TDD Config 0 And 6 Changes End*/
#endif   
    /* HI Pdu Multi UE Changes end */

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,"numOfDci = %d numOfHi = %d\n",numOfDci,numOfHi);
#endif
    recvBuffer_p = hiDciReq_p->hidciPduInfo;

    while ( count < (numOfDci + numOfHi) )
    {
        switch ( *recvBuffer_p )
        {
            case FAPI_HI_PDU:
             {
                hiPdu_p = (FAPI_dlHiPduInfo_st *) recvBuffer_p;
                recvBuffer_p +=  hiPdu_p->hipduSize;
                /*FAPI_ERROR_INDICATION_CHANGES_START*/
                /*Send phy error in case of subframe error in HI PDU*/
                if ((1 == phy_err_config_g[cellIndex])&&\
                    (( hiDci0Tick >= phy_err_start_tti_g[cellIndex]) && \
                    ( hiDci0Tick <= phy_err_end_tti_g[cellIndex])) && (errorCount_g[cellIndex] == 0))
                    {
                    if ((PHY_DL_HI_DCI0_REQUEST == phy_err_msg_type_g[cellIndex]) && (FAPI_MSG_HI_ERR == phy_err_error_type_g[cellIndex]))
                    {
                        phy_err_rb_start_g[cellIndex] = hiPdu_p->rbStart;
                        fapiSendErrorIndication(FAPI_MSG_HI_ERR , l1RcvMsg_p->msgId,
                                0,0, &PhyHiDciresp_p,&PhyHiDciresp_size, cellIndex);

                        UInt8 errQIdx = recvSF + 1;
                        if( errQIdx >= MAX_SUBFRAME )
                        {
                            errQIdx -= MAX_SUBFRAME;
                        }
                        LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                                sizeof(PhyErrInd), PNULL );
                        if( PNULL == phyErrInd_p )
                        {
                            freeMemPool(PhyHiDciresp_p);
                            PhyHiDciresp_p = PNULL;
                            return;
                        }
                        else
                        {
                            phyErrInd_p->data_p = PhyHiDciresp_p;
                            phyErrInd_p->dataSize = PhyHiDciresp_size;

                            ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx ,cellIndex);
                        }
                        errorCount_g[cellIndex]++;
                    }
                }
                /*FAPI_ERROR_INDICATION_CHANGES_END*/

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"HI PDU recevied with hival = %d at SF = %d SFN = %d\n",hiPdu_p->hiValue, recvSfnSf & FAPI_SF_MASK, ((recvSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT));
#endif

		/*TDD Config 0 And 6 Changes Start*/
#if TDD_CONFIG
        /* CA TDD Changes Start */
		if ( 0 == tddUlDlConfig_g[cellIndex] )
		{
		    iPhich = hiPdu_p->iPHICH;

		    sendSF = receivedSf + getUlSubFrameForHIPdu(receivedSf,iPhich,cellIndex);
            /* CA TDD Changes End */
		    if (sendSF >= MAX_SUBFRAME)
		    {
			sendSFN = receivedSfn +1;
			sendSF = sendSF - MAX_SUBFRAME;
			if (sendSFN >= MAX_SFN)
			{
			    sendSFN = sendSFN - MAX_SFN;
			}
		    }
            else
            {
                sendSFN = receivedSfn;
            }

            sendSfnSf = GENERATE_SUBFRAME_SFNSF(sendSFN, sendSF);
		    qIndex = (( sendSFN * MAX_SUBFRAME+ sendSF) + PEER_MAC_DELAY ) % MAX_UL_ARRAY;
		    ctlInfo.sendSF = sendSF;
		    ctlInfo.sendSFN = sendSFN;
		    ctlInfo.qIndex = qIndex;
            
            /* SPR 11562 Changes Start */
            currentSfnFrmTick = (globalTTITickCount_g/MAX_SUBFRAME) % MAX_SFN;
            currentSfFrmTick = globalTTITickCount_g % MAX_SUBFRAME;
            
            /*
            ** In Rel5.4.0, this has been observed that sometimes RLC/PDCP are taking time more than 1ms.
            ** In this case, FAPI is not sending UL SFI indication to eNodeB in 1 ms.
            ** No impact is observed on eNodeB as it works on SFI indication received from FAPI rather than REAL time.
            ** But, sometime issue is observed on uesim that the messages(HI, DCI0 and so on) are being processed one
            ** tick late on uesim.
            **
            ** To correct this, we are putting check to process the message on recv tick rather than current globalTTITickCount
            ** with following assuption:
            ** a) if recv tick not equal to current sfn then it's received late not in advance.
            */
            if ( currentSfnFrmTick != receivedSfn)
            {
                /*
                ** Two case can be possible :
                ** 1 case: current tick SFN is wrap around(0) and receive tick is still 1023
                ** 2 case : normal case no wrap around.
                */
                if (currentSfnFrmTick < receivedSfn)
                {
                    tickFrmCurrSfnSf = ((MAX_SFN + currentSfnFrmTick) * MAX_SUBFRAME) + currentSfFrmTick;

                }
                else
                {

                    tickFrmCurrSfnSf = (currentSfnFrmTick * MAX_SUBFRAME) + currentSfFrmTick;
                }
            }
            else
            {
                tickFrmCurrSfnSf = (currentSfnFrmTick * MAX_SUBFRAME) + currentSfFrmTick;
            }
            tickFrmRecvSfnSf = (receivedSfn * MAX_SUBFRAME) + receivedSf;
            if (tickFrmCurrSfnSf > tickFrmRecvSfnSf)
            {
                correctedHarqTick = globalTTITickCount_g -  (tickFrmCurrSfnSf - tickFrmRecvSfnSf);
            }
            else
            {
                correctedHarqTick = globalTTITickCount_g +  (tickFrmRecvSfnSf - tickFrmCurrSfnSf);
            }
            /* SPR 11066 Changes Start */
            /* SPR 11257 Changes Start */
            /* CA TDD Changes Start */
            calcHarqId = (correctedHarqTick + getUlSubFrameForHIPdu(receivedSf,iPhich,cellIndex)) % MAX_HARQ_MAP_CONFIG0_SIZE;
            /* CA TDD Changes End */
            /* SPR 11257 Changes End*/
            /* SPR 11562 Changes End */
		    harqIndex = harqIdArrayTdd0_g[calcHarqId];
            /* SPR 11066 Changes End */
		}
#endif
		/*TDD Config 0 And 6 Changes End*/

                /* Rajesh Changes
                 * fapiProcessHiPdu(hiPdu_p->hiValue,currentSF, sendSfnSf,delay,
                 phichReceiveIndex, &ctlInfo);
                 */


                /* HI Pdu Multi UE Changes Starts */ 
                ctlInfo.crnti = hi_pdu_crnti_array_g[hiPdu_p->rbStart][harqIndex].crnti; 
                /* HI Pdu Multi UE Changes end */
                /* + SPR 11347 Changes */
                UInt8 txCellIndex = 0;
                GET_RNTI_TO_CELL_INDEX((MAC_PHY_CONVERT_16(ctlInfo.crnti)), txCellIndex);
                newUEContext_p =  getDLUEContextFromRnti(ctlInfo.crnti, txCellIndex);
                ueContextForUplink   *ulUeContextInfo_p  = getUEContext(ctlInfo.crnti, txCellIndex);
                /* - SPR 11347 Changes */
#ifdef FDD_CONFIG
                    /* TTIB_Code Start */
                    if((PNULL != ulUeContextInfo_p) && ulUeContextInfo_p->ttiBundling && 
				    (ulUeContextInfo_p->ttibInfo.bundleStartIndex != TTIB_INVALID_VALUE))
                    {
                        ttibRetxSendSFN = recvSFNSPS;
                        ttibRetxSendSF = recvSFSPS;
                        ttibRetxSendSF += 9;
                        
                        if ( ttibRetxSendSF >= MAX_SUBFRAME )
                        {
                            ttibRetxSendSF -= MAX_SUBFRAME;
                            ttibRetxSendSFN++;
                            if ( ttibRetxSendSFN == MAX_SFN )
                            {
                                ttibRetxSendSFN = 0;
                            }
                        }
                        
                        ttibRetxSendSfnSf = ( ( ttibRetxSendSFN & 0x0FFF) << FAPI_SFN_VALUE_SHIFT )
                            | ( ttibRetxSendSF & FAPI_SF_MASK ) ;

                        harqIndex = (((ttibRetxSendSFN * MAX_SUBFRAME) + ttibRetxSendSF - ulUeContextInfo_p->ttibInfo.bundleStartIndex) % TTI_BUNDLE_RTT) /TTI_BUNDLE_SIZE;
                        ctlInfo.crnti       = hi_pdu_crnti_ttib_array_g[hiPdu_p->rbStart][harqIndex].crnti;
                        ctlInfo.sendSF      = recvSFSPS;
                        ctlInfo.sendSFN     = recvSFNSPS;
                        ttibRetxqIndex      = ttibRetxSendSF + PEER_MAC_DELAY;
                        if ( ttibRetxqIndex >= MAX_SUBFRAME )
                        {
                            ttibRetxqIndex -= MAX_SUBFRAME;
                        }
                        ctlInfo.qIndex      = ttibRetxqIndex;
                        phichReceiveIndex   = (ttibRetxSendSF + TTI_BUNDLE_RTT) % MAX_SUBFRAME;

                        if (hiPdu_p->hiValue)
                        {
                            ulUeContextInfo_p->chkNDI[harqIndex] = globalTTITickCount_g;
                        }

                    }
                    else
                    {
                        harqIndex = (((sendSFN * MAX_SUBFRAME) + sendSF /*+ HI_DCI_DIFF*/) % MAX_HARQ_PROCESS_NB);
                        phichReceiveIndex   = (recvSFSPS + 8) % MAX_SUBFRAME;
                        ctlInfo.sendSF      =  recvSF;
                        ctlInfo.sendSFN     =  recvSFN;
                        ctlInfo.qIndex      =  qIndex;
                    }
                    /* TTIB_Code End */
#endif                
                if (PNULL != newUEContext_p && 
                        RELEASE != newUEContext_p->measGapConfigType )
                {    
                    UInt16 hiSFN = recvSFN;
                    UInt8 hiSF  = recvSF;

                    /* Check if ulsch/crc for this hi lies in meas period */
                    if ( MAC_SUCCESS ==
                            checkIsMeasurementGapPeriodON(hiSFN,hiSF,
                                newUEContext_p) )
                    {
                        count++;
                        //increment retx count
                        ulHarq_p = &ulUeContextInfo_p->ulharqInfo[harqIndex];
                        if((ulHarq_p->currentRetransCount < 
                                    /* max harq tx changes */
                                    (ulUeContextInfo_p->maxUlHarqTx -1)))
                            /* max harq tx changes */
                        {
                            ulHarq_p->currentRetransCount++;
                        }
                        else 
                        {
                            ulHarq_p->currentRetransCount = 0;
                        }
                        continue;
                    }
                }
#ifdef FDD_CONFIG
                    /* TTIB_Code Start */
                    if((PNULL != ulUeContextInfo_p) && ulUeContextInfo_p->ttiBundling && ulUeContextInfo_p->ttibInfo.bundleStartIndex != TTIB_INVALID_VALUE)
                    {
                        fapiProcessHiPdu(harqIndex, hiPdu_p->hiValue,currentSF,
                                phichReceiveIndex,delay,ttibRetxSendSfnSf, 
                                &ctlInfo, receivedSf, cellIndex);
                    }
                    else
                    /* TTIB_Code End */
#endif
                    {
                        fapiProcessHiPdu(harqIndex, hiPdu_p->hiValue,currentSF,
                                phichReceiveIndex,delay,sendSfnSf,
                                &ctlInfo, receivedSf, cellIndex);
                    }
                 }
                break;
            case FAPI_DCI_UL_PDU:
                dciPdu_p = (FAPI_dlDCIPduInfo_st *) recvBuffer_p;
                recvBuffer_p += dciPdu_p->ulDCIPDUSize;

		/*TDD Config 0 And 6 Changes Start*/
#ifdef TDD_CONFIG
        /* CA TDD Changes Start */
		if ( 0 == tddUlDlConfig_g[cellIndex] )
		{
		    ulIndex = dciPdu_p->ulIndex;

		    /* For DCI0 if ulIndex is 11 and 10 , 
		     * that means MSB of the UL Index is set to 1
		     * We need to send ul data on n+k tick. */
		    if ( (ulIndex == 2) || (ulIndex == 3) )
		    {
			sendSF = receivedSf + getUlSubFrameForDCI0Pdu(receivedSf,2,cellIndex);
            /* CA TDD Changes End */
			if (sendSF >= MAX_SUBFRAME)
			{
			    sendSFN = receivedSfn +1;
			    sendSF = sendSF - MAX_SUBFRAME;
			    if (sendSFN >= MAX_SFN)
			    {
				sendSFN = sendSFN - MAX_SFN;
			    }
			}
            else
            {
                sendSFN = receivedSfn;
            }
            sendSfnSf = GENERATE_SUBFRAME_SFNSF(sendSFN, sendSF);
            /*UESIM ADAPTIVE RETX FIX*/
            /* CA TDD Changes Start */
			qIndex = (( receivedSfn * MAX_SUBFRAME + (receivedSf + getUlSubFrameForDCI0Pdu(receivedSf,2,cellIndex)))
                + PEER_MAC_DELAY ) % MAX_UL_ARRAY;
            /* CA TDD Changes End */

            /* SPR 11562 Changes Start */
            currentSfnFrmTick = (globalTTITickCount_g/MAX_SUBFRAME) % MAX_SFN;
            currentSfFrmTick = globalTTITickCount_g % MAX_SUBFRAME;

            /*
             ** In Rel5.4.0, this has been observed that sometimes RLC/PDCP are taking time more than 1ms.
             ** In this case, FAPI is not sending UL SFI indication to eNodeB in 1 ms.
             ** No impact is observed on eNodeB as it works on SFI indication received from FAPI rather than REAL time.
             ** But, sometime issue is observed on uesim that the messages(HI, DCI0 and so on) are being processed one
             ** tick late on uesim.
             **
             ** To correct this, we are putting check to process the message on recv tick rather than current globalTTITickCount
             ** with following assuption:
             ** a) if recv tick not equal to current sfn then it's received late not in advance.
             */
            if ( currentSfnFrmTick != receivedSfn)
            {
                /*
                 ** Two case can be possible :
                 ** 1 case: current tick SFN is wrap around(0) and receive tick is still 1023
                 ** 2 case : normal case no wrap around.
                 */
                if (currentSfnFrmTick < receivedSfn)
                {
                    tickFrmCurrSfnSf = ((MAX_SFN + currentSfnFrmTick) * MAX_SUBFRAME) + currentSfFrmTick;

                }
                else
                {

                    tickFrmCurrSfnSf = (currentSfnFrmTick * MAX_SUBFRAME) + currentSfFrmTick;
                }
            }
            else
            {
                tickFrmCurrSfnSf = (currentSfnFrmTick * MAX_SUBFRAME) + currentSfFrmTick;
            }
            tickFrmRecvSfnSf = (receivedSfn * MAX_SUBFRAME) + receivedSf;
            if (tickFrmCurrSfnSf > tickFrmRecvSfnSf)
            {
                correctedHarqTick = globalTTITickCount_g -  (tickFrmCurrSfnSf - tickFrmRecvSfnSf);
            }
            else
            {
                correctedHarqTick = globalTTITickCount_g +  (tickFrmRecvSfnSf - tickFrmCurrSfnSf);
            }
            /*UESIM ADAPTIVE RETX FIX*/
            /* SPR 11066 Changes Start */
            /* SPR 11257 Changes Start */
            /* CA TDD Changes Start */
            calcHarqId = (correctedHarqTick + getUlSubFrameForDCI0Pdu(receivedSf,2,cellIndex) ) % MAX_HARQ_MAP_CONFIG0_SIZE;
            /* SPR 11257 Changes End*/
            /* SPR 11562 Changes End */

			harqIndex = harqIdArrayTdd0_g[calcHarqId];
            /* SPR 11066 Changes End */

		    }
		    /* For DCI0 if ulIndex is 11 and 01,
		     * that means LSB of the UL Index is set to 1
		     * We need to send ul data on n+7 tick. */
		    if ( (ulIndex == 1) || (ulIndex == 3) )
		    {
			sendSFFor2ndUlSf = receivedSf + getUlSubFrameForDCI0Pdu(receivedSf,1,cellIndex);
            /* CA TDD Changes End */
			if (sendSFFor2ndUlSf >= MAX_SUBFRAME)
			{
			    sendSFNFor2ndUlSf = receivedSfn + 1;
			    sendSFFor2ndUlSf = sendSFFor2ndUlSf - MAX_SUBFRAME;
			    if (sendSFNFor2ndUlSf >= MAX_SFN)
			    {
				sendSFNFor2ndUlSf = sendSFNFor2ndUlSf - MAX_SFN;
			    }
			}
            else
            {
			    sendSFNFor2ndUlSf = receivedSfn;
            }
			sendSfnSfFor2ndUlSf = ( ( sendSFNFor2ndUlSf & 0x0FFF) << FAPI_SFN_VALUE_SHIFT )
			    | ( sendSFFor2ndUlSf & FAPI_SF_MASK ) ;
            /*UESIM ADAPTIVE RETX FIX*/
            /* CA TDD Changes Start */
			qIndexFor2ndUlSf = (( receivedSfn * MAX_SUBFRAME + (receivedSf + getUlSubFrameForDCI0Pdu(receivedSf,1,cellIndex))) 
                    + PEER_MAC_DELAY ) % MAX_UL_ARRAY;
            /* CA TDD Changes End */

            /* SPR 11562 Changes Start */
            currentSfnFrmTick = (globalTTITickCount_g/MAX_SUBFRAME) % MAX_SFN;
            currentSfFrmTick = globalTTITickCount_g % MAX_SUBFRAME;

            /*
             ** In Rel5.4.0, this has been observed that sometimes RLC/PDCP are taking time more than 1ms.
             ** In this case, FAPI is not sending UL SFI indication to eNodeB in 1 ms.
             ** No impact is observed on eNodeB as it works on SFI indication received from FAPI rather than REAL time.
             ** But, sometime issue is observed on uesim that the messages(HI, DCI0 and so on) are being processed one
             ** tick late on uesim.
             **
             ** To correct this, we are putting check to process the message on recv tick rather than current globalTTITickCount
             ** with following assuption:
             ** a) if recv tick not equal to current sfn then it's received late not in advance.
             */
            if ( currentSfnFrmTick != receivedSfn)
            {
                /*
                 ** Two case can be possible :
                 ** 1 case: current tick SFN is wrap around(0) and receive tick is still 1023
                 ** 2 case : normal case no wrap around.
                 */
                if (currentSfnFrmTick < receivedSfn)
                {
                    tickFrmCurrSfnSf = ((MAX_SFN + currentSfnFrmTick) * MAX_SUBFRAME) + currentSfFrmTick;

                }
                else
                {

                    tickFrmCurrSfnSf = (currentSfnFrmTick * MAX_SUBFRAME) + currentSfFrmTick;
                }
            }
            else
            {
                tickFrmCurrSfnSf = (currentSfnFrmTick * MAX_SUBFRAME) + currentSfFrmTick;
            }
            tickFrmRecvSfnSf = (receivedSfn * MAX_SUBFRAME) + receivedSf;
            if (tickFrmCurrSfnSf > tickFrmRecvSfnSf)
            {
                correctedHarqTick = globalTTITickCount_g -  (tickFrmCurrSfnSf - tickFrmRecvSfnSf);
            }
            else
            {
                correctedHarqTick = globalTTITickCount_g +  (tickFrmRecvSfnSf - tickFrmCurrSfnSf);
            }
			//qIndexFor2ndUlSf = (( sendSFNFor2ndUlSf * MAX_SUBFRAME + sendSFFor2ndUlSf) + PEER_MAC_DELAY ) % MAX_UL_ARRAY;
            /*UESIM ADAPTIVE RETX FIX*/
            /* SPR 11066 Changes Start */
            /* SPR 11257 Changes Start */
            /* CA TDD Changes Start */
            calcHarqId = (correctedHarqTick + getUlSubFrameForDCI0Pdu(receivedSf,1,cellIndex) ) % MAX_HARQ_MAP_CONFIG0_SIZE;
            /* CA TDD Changes End */
            /* SPR 11257 Changes End*/
            /* SPR 11562 Changes End */

			harqIdFor2ndUlSf = harqIdArrayTdd0_g[calcHarqId];
            /* SPR 11066 Changes End */
		    }
		}
#endif
		/*TDD Config 0 And 6 Changes End*/

                /* +  MEAS_GAP_CHG*/

                newUEContext_p =  getDLUEContextFromRnti(MAC_PHY_CONVERT_16
						(dciPdu_p->rnti), cellIndex);
                if (PNULL != newUEContext_p && 
                        RELEASE != newUEContext_p->measGapConfigType )
                {    

                    dci0SFN = (recvSfnSf & FAPI_SFN_MASK) >> 
                        FAPI_SFN_VALUE_SHIFT;
                    dci0SF  = recvSfnSf & FAPI_SF_MASK;  

                    if ( MAC_SUCCESS ==
                            checkIsMeasurementGapPeriodON(dci0SFN,dci0SF,
                                newUEContext_p))
                    {
                        lteWarning("DCI0  received during Measurement gap period"
                                " SFN = %d , SF = %d ,ueIndex = %d ." ,
                                dci0SFN,dci0SF,newUEContext_p->ueIndex );
                        count++;
                        /* crash fix */
                        hi_pdu_crnti_array_g[dciPdu_p->rbStart][harqIndex].crnti = 
                            MAC_PHY_CONVERT_16(dciPdu_p->rnti);
                        /* crash fix */
                        continue;
                    }
		    /*TDD Config 0 And 6 Changes Start*/
#ifdef TDD_CONFIG
		    /* For TDD Config 0 */
            /* CA TDD Changes Start */
		    if (0 == tddUlDlConfig_g[cellIndex])
            {
                /* CA TDD Changes End */
			/* For DCI0 if ulIndex is 11 and 10 ,
                         * that means MSB of the UL Index is set to 1
                         * We need to send ul data on n+k tick.
                         * So we check for meas gap Period for n+k
                         * tick.
                         */
			if ((ulIndex == 2 || ulIndex == 3))
			{
			    if ( MAC_SUCCESS ==
				    checkIsMeasurementGapPeriodON(recvSFN,recvSF,
					newUEContext_p))
			    {
				lteWarning("UL data  received during Measurement gap"
					"period SFN = %d , SF = %d ,ueIndex = %d ."
					,recvSFN ,recvSF ,newUEContext_p->ueIndex );
				/* crash fix */
				hi_pdu_crnti_array_g[dciPdu_p->rbStart][harqIndex].crnti =
				    MAC_PHY_CONVERT_16(dciPdu_p->rnti);
				/* crash fix */
				count++;
				continue;
			    }
			}
			/* For DCI0 if ulIndex is 11 and 01 ,
                         * that means LSB of the UL Index is set to 1
                         * We need to send ul data on n+7 tick. 
                         * So we check for meas gap Period for n+7
                         * tick.
                         */
			else if ((ulIndex == 1 || ulIndex == 3))
			{
			    if ( MAC_SUCCESS ==
				    checkIsMeasurementGapPeriodON(sendSFNFor2ndUlSf,sendSFFor2ndUlSf,
					newUEContext_p))
			    {
				lteWarning("UL data  received during Measurement gap"
					"period SFN = %d , SF = %d ,ueIndex = %d ."
					,sendSFNFor2ndUlSf ,sendSFFor2ndUlSf ,newUEContext_p->ueIndex );
				/* crash fix */
				hi_pdu_crnti_array_g[dciPdu_p->rbStart][harqIdFor2ndUlSf].crnti =
				    MAC_PHY_CONVERT_16(dciPdu_p->rnti);
				/* crash fix */
				count++;
				continue;
			    }
			}
		    }
		    /* For all other TDD configurations except 0 */
		    else
		    {
			if ( MAC_SUCCESS ==
				checkIsMeasurementGapPeriodON(recvSFN,recvSF,
				    newUEContext_p))
			{
			    lteWarning("UL data  received during Measurement gap"
				    "period SFN = %d , SF = %d ,ueIndex = %d ."
				    ,recvSFN ,recvSF ,newUEContext_p->ueIndex );
			    /* crash fix */
			    hi_pdu_crnti_array_g[dciPdu_p->rbStart][harqIndex].crnti =
				MAC_PHY_CONVERT_16(dciPdu_p->rnti);
			    /* crash fix */
			    count++;
			    continue;
			}
		    }
#else
		    if ( MAC_SUCCESS ==
			    checkIsMeasurementGapPeriodON(recvSFN,recvSF,
				newUEContext_p))
		    {
			lteWarning("UL data  received during Measurement gap"
				"period SFN = %d , SF = %d ,ueIndex = %d ."
				,recvSFN ,recvSF ,newUEContext_p->ueIndex );
			/* crash fix */
			hi_pdu_crnti_array_g[dciPdu_p->rbStart][harqIndex].crnti =
			    MAC_PHY_CONVERT_16(dciPdu_p->rnti);
			/* crash fix */
			count++;
			continue;
		    }
#endif
		}
		/*TDD Config 0 And 6 Changes End*/

                /* - MEAS_GAP_CHG */

                /* DCI PDU Handling */
                switch ( dciPdu_p->ulDCIFormat )
                {
                    case FAPI_UL_DCI_FORMAT_0:
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
#endif
                        //fprintf(stderr,"UL GRANT recevied at sf = %d sfn = %d sendSF = %d sendSFN = %d sdnfsfnsf = %d\n",recvSfnSf & FAPI_SF_MASK, ((recvSfnSf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT),recvSF,recvSFN,sendSfnSf );
#ifdef TDD_CONFIG
                /* SPR 19679: TDD HARQ Multiplexing Changes Start*/
                rntiInfo_p = getRntiInfofromRNTIMap(dciPdu_p->rnti, cellIndex);
                ueIndex = rntiInfo_p->ueIndex;
                ueContextInfo_p = uplinkContextInfoMap_g[ueIndex];
                FAPI_harqIndQueueNode_st *harqNode_p = PNULL;
                    UInt16 sendSFMUX = recSFMUX + ulSfForDCI0OrHiReceived_g[tddUlDlConfig_g[cellIndex]][recSFMUX];
                    sendSFMUX = sendSFMUX % MAX_SUBFRAME;
                if(NULL != ueContextInfo_p) 
                {
                    if ( sendSFMUX < recSFMUX )
                    {
                        sendSFNMUX++;
                        if ( sendSFNMUX >= MAX_SFN )
                        sendSFNMUX = 0;
                    } 
                    harqNode_p = ( FAPI_harqIndQueueNode_st *)
                                ueContextInfo_p->harqNode_p[(sendSFNMUX&0x01)][sendSFMUX];
                }
                if(NULL != harqNode_p)
                {
                    harqNode_p->isScheduledOnPUSCHForMux = 1;

                }
                sendSFNMUX = temp;
                /* SPR 19679: TDD HARQ Multiplexing Changes End*/
#endif
#ifdef FDD_CONFIG
                    /* TTIB_Code Start */
                    if (dciPdu_p->rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti && 
                            dciPdu_p->rnti <= cellConfigUeSim_g[cellIndex].endSpsCrnti && (dciPdu_p->numOfRB!=0))
                    {
                        populateSpsCrnti(dciPdu_p->rnti, cellIndex);  
                    }
                    rntiInfo_p = getRntiInfofromRNTIMap(dciPdu_p->rnti, cellIndex);
                    if (rntiInfo_p)
                    {
                        ueIndex = rntiInfo_p->ueIndex;
                        ueContextInfo_p = uplinkContextInfoMap_g[ueIndex];

                        if((PNULL != ueContextInfo_p) && ueContextInfo_p->ttiBundling && dciPdu_p->numOfRB && (dciPdu_p->mcs != 31)) 
                        {
                            if(ueContextInfo_p->ttibInfo.bundleStartIndex == TTIB_INVALID_VALUE)
                            {
                                ueContextInfo_p->ttibInfo.bundleStartIndex = ((recvSFSPS+4) % TTI_BUNDLE_SIZE);
                            }

                            harqIndex = (((sendSFN * MAX_SUBFRAME) + sendSF - ueContextInfo_p->ttibInfo.bundleStartIndex) % TTI_BUNDLE_RTT) /TTI_BUNDLE_SIZE;

                            /**** Stopping data transfer while bundling is off at eNB l2 & on at UE ****/

                            diff = (globalTTITickCount_g - ueContextInfo_p->latDci0RcvdTick);
                            if (2 > diff)
                            {
                                ueContextInfo_p->ttiBundling = 0;
                                for (tick = diff ; tick >= 0; tick--)
                                {
                                    index = ((qIndex - tick) < 0)? (MAX_SUBFRAME + (qIndex - tick))  : (qIndex - tick) % MAX_SUBFRAME;
                                    queueCount = sQueueCount(&(ulDataQueue[cellIndex][index]));
                                    while ( queueCount-- )
                                    {
                                        ulschDataNode_p = (ulschDataQueueNode *)
                                            popNode(&(ulDataQueue[cellIndex][index]));
                                        if (dciPdu_p->rnti != ulschDataNode_p->rnti)
                                        {
                                            pushNode(&ulDataQueue[cellIndex][index], 
                                                    &(ulschDataNode_p->ulDataAnchor));
                                        }
                                    }
                                }
                            }
                            ueContextInfo_p->latDci0RcvdTick = globalTTITickCount_g;

                            /*** Pushing the nodes in ttib queue ***/
                            
                           pushTTIBNodes(harqIndex,delay,((phichReceiveIndex + FRESH_TRANSMISSION) % MAX_SUBFRAME),
                           qIndex,dciPdu_p,recvSFSPS,recvSFNSPS,sendSfnSf,FRESH_TRANSMISSION,cellIndex);

                            /******** Adaptive Retx check ********/

                            ulHarq_p = &ueContextInfo_p->ulharqInfo[harqIndex];
                            if (5 == (globalTTITickCount_g - ueContextInfo_p->chkNDI[harqIndex]))
                            {
                                if ((ulHarq_p->dciPdu.newDataIndication == dciPdu_p->newDataIndication) && 
                                        (ulHarq_p->currentRetransCount < (ueContextInfo_p->maxUlHarqTx)))
                                {
                                    ulHarq_p->currentRetransCount += RE_TRANSMISSION;
                                }
                                else if ((ulHarq_p->dciPdu.newDataIndication == dciPdu_p->newDataIndication) &&
                                        (ulHarq_p->currentRetransCount >= (ueContextInfo_p->maxUlHarqTx)))
                                {
                                    ulHarq_p->currentRetransCount = 0;
                                    count++;
                                    continue;
                                }
                                else
                                {
                                    ulHarq_p->currentRetransCount = FRESH_TRANSMISSION;
                                }
                                ueContextInfo_p->chkNDI[harqIndex] = 0;
                            }
                            else
                            {
                                ulHarq_p->currentRetransCount = FRESH_TRANSMISSION;
                            }
                            memcpy(&(ulHarq_p->dciPdu),dciPdu_p,sizeof(FAPI_dlDCIPduInfo_st));
                        }
                       else
                        {
                            harqIndex = (((sendSFN * MAX_SUBFRAME) + sendSF /*+ HI_DCI_DIFF*/) % MAX_HARQ_PROCESS_NB);
                            fapiProcessUlGrant(harqIndex,sendSfnSf,qIndex,
                                    phichReceiveIndex,delay,dciPdu_p,recvSFSPS,
                                    recvSFNSPS, cellIndex);

                        }
#if 0                        
                        else
                        {
                            harqIndex = (((sendSFN * MAX_SUBFRAME) + sendSF /*+ HI_DCI_DIFF*/) % MAX_HARQ_PROCESS_NB);
                            fapiProcessUlGrant(harqIndex,sendSfnSf,qIndex,phichReceiveIndex,
                                    delay,dciPdu_p,recvSFSPS,recvSFNSPS);

                        }
#endif                        
                    }
                    else 
                    /* TTIB_Code End */
#endif
                    {
			    /*TDD Config 0 And 6 Changes Start*/
#ifdef TDD_CONFIG
			    /*For TDD config 0*/
                /* CA TDD Changes Start */
			    if (0 == tddUlDlConfig_g[cellIndex])
			    {
                    /* CA TDD Changes End */
				/* For DCI0 if ulIndex is 11 and 10 ,
		                 * that means MSB of the UL Index is set to 1
                                 * We need to send ul data on n+k tick. */
				if ((ulIndex == 3 || ulIndex == 2))
				{
				    fapiProcessUlGrant(harqIndex,sendSfnSf,qIndex,phichReceiveIndex,
					    delay,dciPdu_p,recvSF,recvSFN,cellIndex);
				}
				/* For DCI0 if ulIndex is 11 and 01 ,
		                 * that means LSB of the UL Index is set to 1
                                 * We need to send ul data on n+7 tick. */
				if((ulIndex == 1 || ulIndex == 3))
				{
				    fapiProcessUlGrant(harqIdFor2ndUlSf,sendSfnSfFor2ndUlSf,qIndexFor2ndUlSf,phichReceiveIndex,
					    delay,dciPdu_p,sendSFFor2ndUlSf,sendSFNFor2ndUlSf,cellIndex);
				}
			    }
			    else
			    {
				/* For all other TDD Config, we send ul data on n+k tick */
				/* +  SPS_TDD */
				fapiProcessUlGrant(harqIndex,sendSfnSf,qIndex,phichReceiveIndex,
					delay,dciPdu_p,recvSFSPS,recvSFNSPS,cellIndex);
				/*fapiProcessUlGrant(harqIndex,sendSfnSf,qIndex,phichReceiveIndex,
					delay,dciPdu_p,recvSF,recvSFN,cellIndex);*/
				/* -  SPS_TDD */
			    }
#else
			    fapiProcessUlGrant(harqIndex,sendSfnSf,qIndex,phichReceiveIndex,
				    delay,dciPdu_p,recvSF,recvSFN,cellIndex);
#endif
			    /*TDD Config 0 And 6 Changes End*/
                    } 
#ifdef UESIM_ENHANCEMENTS
                        UInt16 rnti = MAC_PHY_CONVERT_16(dciPdu_p->rnti);
                    newUEContext_p = getDLUEContextFromRnti(rnti, cellIndex);
                        if (PNULL != newUEContext_p)
                        {
                            ueContextInfo_p = uplinkContextInfoMap_g[newUEContext_p->ueIndex];
                            ulHarq_p = &ueContextInfo_p->ulharqInfo[harqIndex];
                            ulHarq_p->numOfRB[sendSF] = dciPdu_p->numOfRB;
                        }
#endif
                        break;
                    case FAPI_UL_DCI_FORMAT_3:
                        {
                            //fprintf(stderr,"FAPI_UL_DCI_FORMAT_3 received\n");
                            /*CLPC_CHG*/
                            if(CLPC_PUCCH_ENABLE || CLPC_PUSCH_ENABLE)
                            {
                                MacRetType isMatchedForAnyIndex = FALSE;
                                TpcInfo tpcInfo =  tpcRntiInfoMap[MAC_PHY_CONVERT_16(dciPdu_p->rnti) - START_TPC_RNTI];
                                for (idx = 0;idx < 16; idx++)
                                {
                                    if(tpcInfo.isValid[idx] == TRUE)
                                    {
                                        isMatchedForAnyIndex = TRUE;
                                        ueIndex = tpcInfo.ueIndex[idx];
                                        bitmapIndex = idx;
                                        offset = ((16 - bitmapIndex) * 2) - 2;
                                        tpcCommand = (MAC_PHY_CONVERT_32(dciPdu_p->tpcBitMap) >> offset & 3 );

                                        ueContextInfo_p = uplinkContextInfoMap_g[ueIndex];
                                        newUEContext_p = dlUECtxInfoArr_g[ueIndex].dlUEContext_p;
                                        if(ueContextInfo_p == PNULL)
                                        {
                                            lteWarning("UE UL Context is NULL\n");
                                            return;
                                        }
                                        if(CLPC_PUSCH_ENABLE)
                                        {
                                            if(MAC_PHY_CONVERT_16(dciPdu_p->rnti) == 
                                                    ueContextInfo_p->tpcPdcchConfigPusch.tpcRnti)
                                            {
                                                ueContextInfo_p->tpcPUSCH =  tpcPUSCHAccInfoArr[tpcCommand] +
                                                    ueContextInfo_p->tpcPUSCH;
                                            }
                                        }
                                        if(CLPC_PUCCH_ENABLE)
                                        {
                                            if(MAC_PHY_CONVERT_16(dciPdu_p->rnti) == 
                                                    newUEContext_p->tpcPdcchConfigPucch.tpcRnti)                                                       
                                            {
                                                newUEContext_p->tpcPUCCH = tpcPUSCHAccInfoArr[tpcCommand] +
                                                    newUEContext_p->tpcPUCCH;

                                                ackNackCorrectionForTpc(newUEContext_p, cellIndex);
                                            }
                                        }
                                    }
                                }
                                if (isMatchedForAnyIndex == FALSE)
                                {
                                    fprintf(stderr," No TPCIndex configured for TPC RNTI =%d\n", 
                                            MAC_PHY_CONVERT_16(dciPdu_p->rnti));
                                }
                            }

                        }   /*CLPC_CHG*/
                        break;
                    case FAPI_UL_DCI_FORMAT_3A:
                        //fprintf(stderr,"FAPI_UL_DCI_FORMAT_3A received\n");
                        break;
                    default:
                        break;
                }
                break;
            default:
                fprintf(stderr,"got worng msg from MAC\n");
                break;
        }
        count++;
    }
}
#ifdef FDD_CONFIG
/** TTIB_code Start */
/****************************************************************************
 * Function Name  :  pushTTIBNodes 
 * Inputs         :  harqIndex - Harq Process Id for TTI Bundling
 *                   delay - delay in first packet
 *                   phichReceiveIndex  
 *                   qIndex - tick where data will go
 *                   dciPdu_p - dci0 Pdu
 *                   recvSF - tick where dci received
 *                   recvSFN - tick where dci received
 *                   sendSfnSf - 16bit value contaning sendSFN & SF
 *                   count - Fresh transmission or retransmission
 * Outputs        :  pushes 4 nodes in ttibDataQueue_g 
 * Returns        :  Nothing
 * Description    :  It pushes the 4 nodes in ttibDataQueue which are processed
 *                   in next 3 consecutive ticks one by one.
 ****************************************************************************/
void pushTTIBNodes(
                        UInt8 harqIndex,
                        UInt8 delay,
                        UInt8 phichReceiveIndex,
                        UInt8 qIndex,
                        FAPI_dlDCIPduInfo_st *dciPdu_p,                        
                        UInt8 recvSF,
                        UInt16  recvSFN,
                        UInt16 sendSfnSf,
                        UInt8 count,
/* SPR_11526_Fix Start */
                        UInt8 cellIndex
/* SPR_11526_Fix End */
                  )
{
    UInt8 sendSF = 0;
    UInt16 sendSFN = 0;
    UInt8 tick = 0;
    FAPI_dlDCIPduInfo_st dciPdu;                        
    UInt8 ttibqIndex = 0;
    ttibDataQueueNode *ttibDataNode_p;

    memcpy(&(dciPdu),dciPdu_p,sizeof(FAPI_dlDCIPduInfo_st));
    dciPdu.mcs = (count == FRESH_TRANSMISSION) ? (dciPdu.mcs) : 28;
    ttibqIndex = (count == FRESH_TRANSMISSION) ? ((globalTTITickCount_g + 1) % TTI_BUNDLE_RTT) : ((globalTTITickCount_g + 5) % TTI_BUNDLE_RTT);

    for (tick = 1; tick <= 4 ; tick++)
    {
        ttibDataNode_p = (ttibDataQueueNode *)getMemFromPool(sizeof(ttibDataQueueNode),PNULL);
        if (ttibDataNode_p != PNULL)
        {   
            ttibDataNode_p->harqIndex = harqIndex;
            ttibDataNode_p->delay = delay;
            ttibDataNode_p->sendSfnSf = sendSfnSf;
            ttibDataNode_p->phichReceiveIndex = phichReceiveIndex;
            ttibDataNode_p->ttibqIndex = ttibqIndex;
            ttibDataNode_p->qIndex = qIndex;
            memcpy(&(ttibDataNode_p->dciPdu),&dciPdu,sizeof(FAPI_dlDCIPduInfo_st));
            ttibDataNode_p->recvSFN = recvSFN;
            ttibDataNode_p->recvSF = recvSF;
        }
        else
        {
            ltePanic("not able to get memory in pushTTIBNodes for ttibDataQueueNode\n");
        }

/* SPR_11526_Fix Start */
        enQueue( &(ttibDataQueue_g[cellIndex][ttibDataNode_p->ttibqIndex]),&(ttibDataNode_p->node));
/* SPR_11526_Fix End */

    
        sendSF =    sendSfnSf & FAPI_SF_MASK;
        sendSFN =   ( sendSfnSf & FAPI_SFN_MASK ) >> FAPI_SFN_VALUE_SHIFT;

        sendSF +=1;

        if ( sendSF >= MAX_SUBFRAME )
        {
            sendSF -= MAX_SUBFRAME;
            sendSFN += 1;
            if ( sendSFN == MAX_SFN )
            {
                sendSFN = 0;
            }

        }
    
        sendSfnSf = GENERATE_SUBFRAME_SFNSF(sendSFN, sendSF);

        qIndex += 1;
        if ( qIndex >= MAX_SUBFRAME )
        {
            qIndex -= MAX_SUBFRAME;
        }

        ttibqIndex += 1;
        if ( ttibqIndex >= TTI_BUNDLE_RTT )
        {
            ttibqIndex -= TTI_BUNDLE_RTT;
        }

        dciPdu.mcs = 28 + tick;
        recvSF += 1;
        if ( recvSF >= MAX_SUBFRAME )
        {
            recvSF -= MAX_SUBFRAME;
            recvSFN += 1;
            if ( recvSFN == MAX_SFN )
            {
                recvSFN = 0;
            }
        }

    }

}
/** TTIB_code End */
#endif

/****************************************************************************
 * Function Name  :  fapiProcessUciSrPdu
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
#ifdef UESIM_PDCP_THREAD
extern LTE_SEM boSem_g;
#endif
void fapiProcessUciSrPdu(UInt8 qIndex, UInt8 *ulConfigPdu_p, UInt16 sendSfnSf,
        UInt8 uciPduType, UInt8 cellIndex)
{
    FAPI_uciSrPduInfo_st *uciSrPdu_p = PNULL;
    ueContextForUplink *ueContext_p = PNULL;
    /* SPR 1289 Start */
    FAPI_uciCqiSrPduInfo_st * uciCqiSrPdu_p = PNULL;
/* SPR 10867 Fix Start */
#ifdef FAPI_4_0_COMPLIANCE
    FAPI_uciCqiSrHarqPduInfoR9_st * uciCqiSrHarqPdu_p = PNULL;
    FAPI_uciSrHarqPduInfoR9_st *uciSrHarqPdu_p = PNULL;
#else
    FAPI_uciSrHarqPduInfo_st *uciSrHarqPdu_p = PNULL;
    FAPI_uciCqiSrHarqPduInfo_st * uciCqiSrHarqPdu_p = PNULL;
#endif
/* SPR 10867 Fix End */
    /* SPR 1289 End */
    UInt16 rnti= 0;
    UInt32 handle= 0;
    //ifdef FDD_CONFIG
    RNTIInfo *rntiInfo_p = PNULL;
    //#endif
    if (FAPI_UCI_SR == uciPduType)
    {
        uciSrPdu_p = (FAPI_uciSrPduInfo_st *) ulConfigPdu_p;
        rnti = MAC_PHY_CONVERT_16(uciSrPdu_p->rnti);
        handle = MAC_PHY_CONVERT_32(uciSrPdu_p->handle); 
    }
    else if (FAPI_UCI_SR_HARQ == uciPduType)
    {
   /* SPR 10867 Fix Start */
       #ifdef FAPI_4_0_COMPLIANCE
          uciSrHarqPdu_p = (FAPI_uciSrHarqPduInfoR9_st *) ulConfigPdu_p;
       #else
          uciSrHarqPdu_p = (FAPI_uciSrHarqPduInfo_st *) ulConfigPdu_p;
       #endif
   /* SPR 10867 Fix End */
        rnti = MAC_PHY_CONVERT_16(uciSrHarqPdu_p->rnti);
        handle = MAC_PHY_CONVERT_32(uciSrHarqPdu_p->handle); 
    }
    /* SPR 1289 Start */
    else if (FAPI_UCI_CQI_SR == uciPduType)
    {
        uciCqiSrPdu_p = (FAPI_uciCqiSrPduInfo_st *)ulConfigPdu_p;
        handle = MAC_PHY_CONVERT_32(uciCqiSrPdu_p->handle);
        rnti = MAC_PHY_CONVERT_16(uciCqiSrPdu_p->rnti);
    }
    else if (FAPI_UCI_CQI_SR_HARQ == uciPduType)
    {
    /* SPR 10867 Fix Start */
    #ifdef FAPI_4_0_COMPLIANCE
          uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfoR9_st *)ulConfigPdu_p;
    #else
           uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfo_st *)ulConfigPdu_p;
    #endif
    /* SPR 10867 Fix End */
        handle = MAC_PHY_CONVERT_32(uciCqiSrHarqPdu_p->handle);
        rnti = MAC_PHY_CONVERT_16(uciCqiSrHarqPdu_p->rnti);
    }


    /* SPR 1289 End */

    /* SPR 940 Fix Start */
    rntiInfo_p = getRntiInfofromRNTIMap(rnti, cellIndex);
    if (rntiInfo_p != PNULL) 
    {
        ueContext_p = uplinkContextInfoMap_g[rntiInfo_p->ueIndex];

        if ( ueContext_p == PNULL )
        {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
            lteWarning("Error!!  UE Context does not exist for crnti = %d, ueIndex = %d\n", 
                    rnti, rntiInfo_p->ueIndex);
#endif
            return ;
        }
        /*Check if SPS Grant is configured for this UE*/
        if ( ueContext_p->occListNode_p )
        {
            return;
        } 
    }
    else
    {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"getRntiInfofromRNTIMap returned NULL \n");
#endif
        return ;
    }

#if 0
    ueContext_p = getUEContext(rnti);
    if ( PNULL == ueContext_p )
    {
        fprintf(stderr, "Error!! [%s] no UE Context exist for rnti = %d\n",
                __func__, rnti);
        return;
    }
#endif

#ifdef UESIM_PDCP_THREAD
    semWait(&boSem_g);
#endif
    if ( PNULL == ueContext_p->srPduNode_p )
    {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"NO SR information present currently\n");
#endif
#ifdef UESIM_PDCP_THREAD
        semPost(&boSem_g);
#endif
        return;
    }

    ueContext_p->srPduNode_p->sfnsf = sendSfnSf;
    ueContext_p->srPduNode_p->srPduInfo.handle = handle;
    ueContext_p->srPduNode_p->srPduInfo.rnti = rnti;

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    {
        UInt16 recvSFN = 0;
        UInt16 recvSF = 0;
        recvSFN = sendSfnSf & FAPI_SFN_MASK;
        recvSFN >>= FAPI_SFN_VALUE_SHIFT; 
        recvSF = sendSfnSf & FAPI_SF_MASK;
        fprintf (stderr, "SR sfn [%d], sf[%d]\n", recvSFN, recvSF);
        fprintf (stderr, "current sfg [%d] \n",SF_g);
        fprintf (stderr, "sendsfnsf [%d]\n",sendSfnSf);
    }
#endif

#if 0
    for (cnt = 0; cnt < 11; cnt++)
    {
        if( 0 != ueContext_p->lcInfo[cnt].queueLoad)
        {
            fprintf (stderr, " QueueLoad non zero no need to send \n");
            freeMemPool(ueContext_p->srPduNode_p);

            ueContext_p->srPduNode_p = PNULL;
            return;
        }
    }
#endif
    pushNode(&srIndQueue[cellIndex][qIndex],
			&(ueContext_p->srPduNode_p->srNodeAnchor));
#ifdef UESIM_PDCP_THREAD
    ueContext_p->srPduNode_p = NULL;
#endif
    ueContext_p->srPduNode_p = PNULL;
#ifdef UESIM_PDCP_THREAD
    semPost(&boSem_g);
#endif
    return;
}
    /* TDD special bundling changes start*/
/*
 * Table 36213:7.3-1: Mapping between multiple ACK/NACK responses and  
 * Number of ACK among multiple (U-dai + N-sps ) ACK/NACK responses   
 *      b(0),b(1)
 *
 * 0    0   , 0  (UE detect at least one DL assignment is missed) 
 * 1    1   , 1
 * 2    1   , 0
 * 3    0   , 1
 * 4    1   , 1
 * 5    1   , 0
 * 6    0   , 1
 * 7    1   , 1
 * 8    1   , 0
 * 9    0   , 1
 * */
UInt8 tddHarqSpecialBudlingMap_g[10] = { 0, 1, 2, 3, 1, 2, 3, 1, 2, 3};
    /* TDD special bundling changes end*/
/****************************************************************************
 * Function Name  :  fapiProcessUciHarqPdu
 * Inputs         :   
 * Outputs        :  None
 * Returns        :  Void 
 * Description    :  This function chechs if The HARQ for a RNTI(As in UL Config
 *                   PDU) is scheduled or nor    
 ****************************************************************************/
//TA: SS
void fapiProcessUciHarqPdu(UInt8 qIndex, UInt8 *ulConfigPdu_p,
        UInt8 uciPduType, UInt16 recvSfnSf
#ifdef UESIM_ENHANCEMENTS
        ,DLUEContext *dlUeContext_p
#endif
        ,UInt8 cellIndex
        )  
{
    UInt16   rnti = 0;
    UInt32   queueCount = 0;
    /* TDD special bundling changes start*/
    UInt8 spBundlingFlag = 0;
    RNTIInfo *rntiInfo_p = PNULL;
    ueContextForUplink *ulUEContext_p = PNULL;
    UInt8 SF  = 0;
    UInt16 SFN  = 0;

    SFN = recvSfnSf & FAPI_SFN_MASK;
    SFN >>= FAPI_SFN_VALUE_SHIFT;
    SF = recvSfnSf & FAPI_SF_MASK;
    UInt8 harqContInd = SFN & 0x01;

    FAPI_harqIndQueueNode_st *harqIndNode_p = PNULL;

#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
    FAPI_uciCqiHarqPduInfoR9_st *uciCqiHarqPdu_p = PNULL;
#else
    FAPI_uciCqiHarqPduInfo_st *uciCqiHarqPdu_p = PNULL;
#endif
/* SPR 10867 Fix Start */
//#ifdef FAPI_4_0_COMPLIANCE
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
    FAPI_uciCqiSrHarqPduInfoR9_st *uciCqiSrHarqPdu_p = PNULL;
    FAPI_uciSrHarqPduInfoR9_st *uciSrHarqPdu_p = PNULL;
#else
    FAPI_uciSrHarqPduInfo_st *uciSrHarqPdu_p = PNULL;
    FAPI_uciCqiSrHarqPduInfo_st *uciCqiSrHarqPdu_p = PNULL;
#endif
/* SPR 10867 Fix End */
#ifdef TDD_CONFIG
    FAPI_tddHarqPduInfo_st *harqInfo_p = PNULL;
#endif
#ifdef UESIM_ENHANCEMENTS
    UInt32 recvSF = recvSfnSf & FAPI_SF_MASK;
#endif

    if (FAPI_UCI_SR_HARQ == uciPduType)
    {
/* SPR 10867 Fix Start */
//#ifdef FAPI_4_0_COMPLIANCE
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        uciSrHarqPdu_p = (FAPI_uciSrHarqPduInfoR9_st *)ulConfigPdu_p;
#else
        uciSrHarqPdu_p = (FAPI_uciSrHarqPduInfo_st *)ulConfigPdu_p;
#endif
/* SPR 10867 Fix End */
        rnti = MAC_PHY_CONVERT_16(uciSrHarqPdu_p->rnti);
#ifdef TDD_CONFIG
        spBundlingFlag = 1;
        harqInfo_p = &uciSrHarqPdu_p->harqInfo;
#endif
    }
    else if (FAPI_UCI_CQI_HARQ == uciPduType)
    {
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        uciCqiHarqPdu_p = (FAPI_uciCqiHarqPduInfoR9_st *)ulConfigPdu_p;
#else
        uciCqiHarqPdu_p = (FAPI_uciCqiHarqPduInfo_st *)ulConfigPdu_p;
#endif
        rnti = MAC_PHY_CONVERT_16(uciCqiHarqPdu_p->rnti);
#ifdef TDD_CONFIG
        spBundlingFlag = 1;
        harqInfo_p = &uciCqiHarqPdu_p->harqInfo;
#endif
    }
    else if (FAPI_UCI_CQI_SR_HARQ == uciPduType)
    {
/* SPR 10867 Fix Start */
//#ifdef FAPI_4_0_COMPLIANCE
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfoR9_st *)ulConfigPdu_p;
#else
        uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfo_st *)ulConfigPdu_p;
#endif
/* SPR 10867 Fix End */
        rnti = MAC_PHY_CONVERT_16(uciCqiSrHarqPdu_p->rnti);
#ifdef TDD_CONFIG
        spBundlingFlag = 1;
        harqInfo_p = &uciCqiSrHarqPdu_p->harqInfo;
#endif
    }

#ifdef TDD_CONFIG
    ulUEContext_p = getUEContext(MAC_PHY_CONVERT_16(rnti), cellIndex);
    harqIndNode_p = ( FAPI_harqIndQueueNode_st *)
        ulUEContext_p->harqNode_p[harqContInd][SF];
    if(harqIndNode_p)
    {
        if(spBundlingFlag)
        {
            harqIndNode_p->harqPduInfo.numOfAckNack = harqInfo_p->harqSize;
            harqIndNode_p->harqPduInfo.mode = SPL_BUNDLING;
        }
    }
#endif
    /*TDD special bundling changes end*/
 
    return;
}
//#endif
#if 0
/****************************************************************************
 * Function Name  :  fapiProcessUciCqiPdu
 * Inputs         :   
 * Outputs        :  None
 * Returns        :  Void 
 * Description    :  This function checks if there exists a UCI CQI  msg for a UL
 *                   Config PDU for a specific RNTI
 ****************************************************************************/
void fapiProcessUciCqiPdu(UInt8 qIndex, UInt8 * ulConfigPdu_p, 
        UInt8 uciPduType, UInt16 recvSfnSf)
{
    FAPI_cqiIndQueueNode_st *cqiPduNode_p = PNULL;
    FAPI_uciCqiPduInfo_st *uciCqiPdu_p = PNULL;
    FAPI_uciCqiHarqPduInfo_st *uciCqiHarqPdu_p = PNULL;
    FAPI_ulSCHCqiRiPduInfo_st *ulCqiRiPdu_p = PNULL;
    FAPI_ulSCHCqiHarqRIPduInfo_st *ulCqiHarqRiPdu_p = PNULL;
    FAPI_uciCqiSrPduInfo_st *uciCqiSrPdu_p = PNULL;
    FAPI_uciCqiSrHarqPduInfo_st *uciCqiSrHarqPdu_p = PNULL;


    cqiPduNode_p = (FAPI_cqiIndQueueNode_st *)getMemFromPool(sizeof(FAPI_cqiIndQueueNode_st),
            PNULL);
    cqiPduNode_p->sfnsf = recvSfnSf;
    cqiPduNode_p->cqiPduInfo.length = sizeof(UInt8);
    cqiPduNode_p->cqiPduInfo.dataOffset = sizeof(FAPI_cqiPduIndication_st);

    if (FAPI_UCI_CQI == uciPduType)
    {
        uciCqiPdu_p = (FAPI_uciCqiPduInfo_st *)ulConfigPdu_p;
        cqiPduNode_p->cqiPduInfo.handle = uciCqiPdu_p->handle;
        cqiPduNode_p->cqiPduInfo.rnti = uciCqiPdu_p->rnti;
    }

    else if(FAPI_UCI_CQI_HARQ == uciPduType)	
    {
        uciCqiHarqPdu_p = (FAPI_uciCqiHarqPduInfo_st *)ulConfigPdu_p;
        cqiPduNode_p->cqiPduInfo.handle = uciCqiHarqPdu_p->handle;
        cqiPduNode_p->cqiPduInfo.rnti = uciCqiHarqPdu_p->rnti;
    }

    else if(FAPI_ULSCH_CQI_RI == uciPduType)
    {
        ulCqiRiPdu_p = (FAPI_ulSCHCqiRiPduInfo_st *)ulConfigPdu_p;
        cqiPduNode_p->cqiPduInfo.handle = ulCqiRiPdu_p->ulSCHPduInfo.handle;
        cqiPduNode_p->cqiPduInfo.rnti = ulCqiRiPdu_p->ulSCHPduInfo.rnti;
    }

    else if(FAPI_ULSCH_CQI_HARQ_RI == uciPduType)
    {
        ulCqiHarqRiPdu_p = (FAPI_ulSCHCqiHarqRIPduInfo_st *)ulConfigPdu_p;
        cqiPduNode_p->cqiPduInfo.handle = ulCqiHarqRiPdu_p->ulSCHPduInfo.handle;
        cqiPduNode_p->cqiPduInfo.rnti = ulCqiHarqRiPdu_p->ulSCHPduInfo.rnti;
    }

    else if(FAPI_UCI_CQI_SR == uciPduType)
    {
        uciCqiSrPdu_p = (FAPI_uciCqiSrPduInfo_st *)ulConfigPdu_p;
        cqiPduNode_p->cqiPduInfo.handle = uciCqiSrPdu_p->handle;
        cqiPduNode_p->cqiPduInfo.rnti = uciCqiSrPdu_p->rnti;
    }
    else if(FAPI_UCI_CQI_SR_HARQ == uciPduType)
    {
        uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfo_st *)ulConfigPdu_p;
        cqiPduNode_p->cqiPduInfo.handle = uciCqiSrHarqPdu_p->handle;
        cqiPduNode_p->cqiPduInfo.rnti = uciCqiSrHarqPdu_p->rnti;
    }	
    pushNode(&cqiIndQueue[qIndex], 
            &(cqiPduNode_p->cqiNodeAnchor));

    return;
}
#endif
/****************************************************************************
 * Function Name  :  fapiProcessUciCqiPdu
 * Inputs         :   
 * Outputs        :  None
 * Returns        :  Void 
 * Description    :  This function checks if there exists a UCI CQI  msg for a UL
 *                   Config PDU for a specific RNTI
 ****************************************************************************/
void fapiProcessUciCqiPdu(UInt8 qIndex, UInt8 * ulConfigPdu_p, 
        UInt8 uciPduType, UInt16 recvSfnSf,DLUEContext *ueDLContext_p
#ifdef UESIM_ENHANCEMENTS
        ,UInt8 *numOfRBsAllocatedInUL,UInt8 harqIndex
#endif
         ,UInt8 cellIndex)
{
    RNTIInfo *rntiInfo_p = PNULL;
    ueContextForUplink *ueContext_p = PNULL;   

    FAPI_cqiIndQueueNode_st *cqiPduNode_p = PNULL;
    FAPI_uciCqiPduInfo_st *uciCqiPdu_p = PNULL;
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
    FAPI_uciCqiHarqPduInfoR9_st *uciCqiHarqPdu_p = PNULL;
#else
    FAPI_uciCqiHarqPduInfo_st *uciCqiHarqPdu_p = PNULL;
#endif
/* SPR 10867 Fix Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
    FAPI_ulSCHCqiRiPduInfoR9_st *ulCqiRiPdu_p = PNULL;
    dlcqiPmiRISizeAperiodic_st *dlCqiPmiRISize_p=PNULL;
    UInt8 riValues = 0;
    UInt8 counter = 0;
    FAPI_ulSCHCqiHarqRIPduInfoR9_st *ulCqiHarqRiPdu_p = PNULL;
    FAPI_uciCqiSrHarqPduInfoR9_st *uciCqiSrHarqPdu_p = PNULL;
#else
    FAPI_ulSCHCqiRiPduInfo_st *ulCqiRiPdu_p = PNULL;
    FAPI_ulSCHCqiHarqRIPduInfo_st *ulCqiHarqRiPdu_p = PNULL;
    FAPI_uciCqiSrHarqPduInfo_st *uciCqiSrHarqPdu_p = PNULL;
#endif
/* SPR 10867 Fix End */
    FAPI_uciCqiSrPduInfo_st *uciCqiSrPdu_p = PNULL;

    /* + CQI_5.0 */
    UInt32 recvSF = recvSfnSf & FAPI_SF_MASK;
    ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[recvSF] = 0;
    ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[recvSF] = 0;
    /* - CQI_5.0 */

#ifdef UESIM_ENHANCEMENTS
    ULHarqInfo* ulHarq_p = PNULL;
    UInt8 tempRBAllocatedInUL = 0;
    UInt8 tempSF = globalTTITickCount_g % 10;
#endif


    cqiPduNode_p = (FAPI_cqiIndQueueNode_st *)getMemFromPool(sizeof(FAPI_cqiIndQueueNode_st),
            PNULL);
    cqiPduNode_p->sfnsf = recvSfnSf;
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        cqiPduNode_p->cqiPduInfo.dataOffset = MAC_PHY_CONVERT_16(sizeof(FAPI_cqiPduIndicationR9_st));
        cqiPduNode_p->cqiPduInfo.cqiRiInformation.numberOfCCReported=1;
#else
    cqiPduNode_p->cqiPduInfo.dataOffset = MAC_PHY_CONVERT_16(sizeof(FAPI_cqiPduIndication_st));
#endif

#ifdef FAPI_4_0_COMPLIANCE
/* + SPR 11024 Fix */ 
        cqiPduNode_p->cqiPduInfo.cqiRiInformation.timingAdvance = MAC_PHY_CONVERT_16(taValues_g[cellIndex].
                taCqi[(taCntr++)%taValues_g[cellIndex].numTaCqi]) ; /* TA_CHG */
/* - SPR 11024 Fix */ 
#if (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
        cqiPduNode_p->cqiPduInfo.cqiRiInformation.timingAdvanceR9 =
             MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].rel9TACqi
							 [(rel9TaCntr++)%rel9TaValues_g[cellIndex].
							 numTaCqi]); 
  /* TA_CHG */
#ifdef UE_SIM_ENABLE_PRINTF_LOGS

        fprintf(stderr,"Timing Advance R9 in CQI INDICATION [%d]\n",cqiPduNode_p->cqiPduInfo.cqiRiInformation.timingAdvanceR9);
#endif
#endif

#ifdef FAPI_RELEASE8
/* + SPR 11024 Fix */ 

        cqiPduNode_p->cqiPduInfo.cqiRiInformation.timingAdvance = MAC_PHY_CONVERT_16(taValues_g[cellIndex].
                taCqi[(taCntr++)%taValues_g[cellIndex].numTaCqi]) ; /* TA_CHG */
/* - SPR 11024 Fix */ 
#endif
#else
/* + SPR 11024 Fix */ 
		cqiPduNode_p->cqiPduInfo.timingAdvance = MAC_PHY_CONVERT_16(taValues_g[cellIndex].
				taCqi[(taCntr++)%taValues_g[cellIndex].numTaCqi]) ; /* TA_CHG */
/* - SPR 11024 Fix */ 

#endif

    if (FAPI_UCI_CQI == uciPduType)
    {
        uciCqiPdu_p = (FAPI_uciCqiPduInfo_st *)ulConfigPdu_p;
        cqiPduNode_p->cqiPduInfo.handle = MAC_PHY_CONVERT_32(uciCqiPdu_p->handle);
        cqiPduNode_p->cqiPduInfo.rnti = MAC_PHY_CONVERT_16(uciCqiPdu_p->rnti);
        cqiPduNode_p->cqiPduInfo.length = uciCqiPdu_p->cqiInfo.dlCqiPmiSize;
    }

    else if(FAPI_UCI_CQI_HARQ == uciPduType)	
    {
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        uciCqiHarqPdu_p = (FAPI_uciCqiHarqPduInfoR9_st *)ulConfigPdu_p;
#else
        uciCqiHarqPdu_p = (FAPI_uciCqiHarqPduInfo_st *)ulConfigPdu_p;
#endif
        cqiPduNode_p->cqiPduInfo.handle = MAC_PHY_CONVERT_32(uciCqiHarqPdu_p->handle);
        cqiPduNode_p->cqiPduInfo.rnti = MAC_PHY_CONVERT_16(uciCqiHarqPdu_p->rnti);
        cqiPduNode_p->cqiPduInfo.length = uciCqiHarqPdu_p->cqiInfo.dlCqiPmiSize;

    }

    else if(FAPI_ULSCH_CQI_RI == uciPduType)
    {
/* SPR 10867 Fix Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        ulCqiRiPdu_p = (FAPI_ulSCHCqiRiPduInfoR9_st *)ulConfigPdu_p;
#else
        ulCqiRiPdu_p = (FAPI_ulSCHCqiRiPduInfo_st *)ulConfigPdu_p;
#endif

/* SPR 10867 Fix End */
        cqiPduNode_p->cqiPduInfo.handle = MAC_PHY_CONVERT_32(ulCqiRiPdu_p->ulSCHPduInfo.handle);
        cqiPduNode_p->cqiPduInfo.rnti = MAC_PHY_CONVERT_16(ulCqiRiPdu_p->ulSCHPduInfo.rnti);

/* SPR 10867 Fix Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        cqiPduNode_p->cqiPduInfo.dataOffset = ulCqiRiPdu_p->cqiRiInfo.deltaOffsetCQI;
        if (ulCqiRiPdu_p->cqiRiInfo.reportType == CQI_RI_PERIODIC_MODE)
        {
            cqiPduNode_p->cqiPduInfo.length = ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.periodicReport.dlCqiPmiSize;
            ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[recvSF] = \
                                                                  ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.periodicReport.dlCqiPmiSize;
            ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[recvSF] = \
                                                                    ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.periodicReport.dlCqiPmiSize;

        }

        else if(ulCqiRiPdu_p->cqiRiInfo.reportType == CQI_RI_APERIODIC_MODE)
        {
/* SPR 12135 Fix Start */
            UInt8 index = 0;
            UInt8  cqirequestbit = ueDLContext_p->dlCQIInfo.aperiodicCQIRequest[recvSF];
                cqiPduNode_p->cqiPduInfo.cqiRiInformation.numberOfCCReported = \
                ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.numberOfCC;
            for(index = 0; index < cqiPduNode_p->cqiPduInfo.cqiRiInformation.numberOfCCReported;
                    index++)
            {
                if(cqirequestbit & 0x1)
                {
                    /* for Pcell */
                    dlCqiPmiRISize_p = &(ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.dlCqiPmiRISize[index]);
                    riValues=CALC_RIVALUES(dlCqiPmiRISize_p->riSize);

                    for (counter = 0; counter < riValues; counter++)
                    {
                        if (0 == counter)
                        { 
                            ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[recvSF] = \
                                                                                  ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.dlCqiPmiRISize[index].dlCqiPmiSizeRankX[0];
                        }
                        else
                        { 
                            ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[recvSF] = \
                                                                                    ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.dlCqiPmiRISize[index].dlCqiPmiSizeRankX[1];
                        }
                    }
                    cqirequestbit = cqirequestbit & ~(0x1);
                }
                else if( cqirequestbit & 0x2)
                {
                    /* for Scell */
                    ueContextForUplink  *ulUEInfo_p = uplinkContextInfoMap_g[ueDLContext_p->ueIndex];
                    DLCQIInfo *dlCQIInfo_p = &ulUEInfo_p->carrierAggrConfig.scellInfo[0].dlCQIInfo;

                    dlCqiPmiRISize_p = &(ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.dlCqiPmiRISize[index]);
                    if(1 == index)
                    {
                        /* case when report for both cells */
                        dlCqiPmiRISize_p = (dlcqiPmiRISizeAperiodic_st *)((UInt8 *)dlCqiPmiRISize_p + sizeof(UInt8));
                    }
                    riValues=CALC_RIVALUES(dlCqiPmiRISize_p->riSize);

                    for (counter = 0; counter < riValues; counter++)
                    {
                        if (0 == counter)
                        { 
                            dlCQIInfo_p->dlCqiPmiSizeRank_1[recvSF] = \
                              dlCqiPmiRISize_p->dlCqiPmiSizeRankX[0]; 
                        }
                        else
                        { 
                            dlCQIInfo_p->dlCqiPmiSizeRankGT_1[recvSF] = \
                               dlCqiPmiRISize_p->dlCqiPmiSizeRankX[1];
                        }
                    }
                    cqirequestbit = cqirequestbit & ~(0x2);
                }
/* SPR 12135 Fix End */
                //            rank_1  = ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport[0]
                //          rankGT_1  = ulCqiRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport[1]

            }
        }
#else
        /* SPR 6496 changes start */ 
        /* + CQI_5.0 */ 
        cqiPduNode_p->cqiPduInfo.length = ulCqiRiPdu_p->cqiRiInfo.dlCqiPmiSizeRank_1;
        /* SPR 6496 changes end */ 
        ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[recvSF] = ulCqiRiPdu_p->cqiRiInfo.dlCqiPmiSizeRank_1;
        ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[recvSF] = ulCqiRiPdu_p->cqiRiInfo.dlCqiPmiSizeRankGT_1;
#ifdef UESIM_ENHANCEMENTS
        if(tempSF == recvSF)
        {
            *numOfRBsAllocatedInUL += ulCqiRiPdu_p->ulSCHPduInfo.numOfRB;
            tempRBAllocatedInUL = ulCqiRiPdu_p->ulSCHPduInfo.numOfRB;
            updateRAT2RBsinUL(ulCqiRiPdu_p->ulSCHPduInfo.rbStart,
                    ulCqiRiPdu_p->ulSCHPduInfo.numOfRB, cellIndex);
        }                  
#endif        

#if 0        
        /* + CQI_4.1 */
        cqiPduNode_p->cqiPduInfo.length = 
            (ulCqiRiPdu_p->cqiRiInfo.riSize + ulCqiRiPdu_p->cqiRiInfo.dlCqiPmiSizeRankGT_1 + 
             ulCqiRiPdu_p->cqiRiInfo.dlCqiPmiSizeRank_1) ;

        /* + CQI_5.0 */
        if((1 == ulCqiRiPdu_p->cqiRiInfo.riSize) &&
                ( (0 != ulCqiRiPdu_p->cqiRiInfo.dlCqiPmiSizeRankGT_1) ||(ulCqiRiPdu_p->cqiRiInfo.dlCqiPmiSizeRank_1 != 0)))
        {
            cqiPduNode_p->cqiPduInfo.length -= ulCqiRiPdu_p->cqiRiInfo.riSize;
        }

        /* - CQI_5.0 */
        /* - CQI_4.1 */
#endif        

#endif
/* SPR 10867 Fix End */
    }

    else if(FAPI_ULSCH_CQI_HARQ_RI == uciPduType)
    {
/* SPR 10867 Fix Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        ulCqiHarqRiPdu_p = (FAPI_ulSCHCqiHarqRIPduInfoR9_st *)ulConfigPdu_p;
#else
        ulCqiHarqRiPdu_p = (FAPI_ulSCHCqiHarqRIPduInfo_st *)ulConfigPdu_p;
#endif

        /* + CA_TDD_HARQ_CHANGES */
#ifdef TDD_CONFIG
        UInt32 recvSFN = recvSfnSf & FAPI_SFN_MASK;
        /* + SPR_14151 */
        UInt16 temp_recvSF = recvSF;
        recvSFN >>= FAPI_SFN_VALUE_SHIFT;
        if ( MAX_SUBFRAME == temp_recvSF )
        {
            temp_recvSF -= MAX_SUBFRAME;
            recvSFN++ ;
            if ( recvSFN == MAX_SFN )
            {
                recvSFN = 0;
            }
        }
        /* - SPR_14151 */
        ueContext_p = uplinkContextInfoMap_g[ueDLContext_p->ueIndex];
        
        if (ueContext_p)
        {
            /* + SPR_14151 */
            FAPI_harqIndQueueNode_st * harqNode_p = ( FAPI_harqIndQueueNode_st *)
                ueContext_p->harqNode_p[recvSFN & 1][temp_recvSF];
            /* - SPR_14151 */
            if (harqNode_p)
            {
                harqNode_p->isScheduledOnPUSCH = TRUE;
            }
        }
#endif
        /* - CA_TDD_HARQ_CHANGES */

/* SPR 10867 Fix End */
        cqiPduNode_p->cqiPduInfo.handle = MAC_PHY_CONVERT_32(ulCqiHarqRiPdu_p->ulSCHPduInfo.handle);
        cqiPduNode_p->cqiPduInfo.rnti = MAC_PHY_CONVERT_16(ulCqiHarqRiPdu_p->ulSCHPduInfo.rnti);

/* SPR 10867 Fix Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))

        cqiPduNode_p->cqiPduInfo.dataOffset = ulCqiHarqRiPdu_p->cqiRiInfo.deltaOffsetCQI;
        if (ulCqiHarqRiPdu_p->cqiRiInfo.reportType == CQI_RI_PERIODIC_MODE)
        {
            cqiPduNode_p->cqiPduInfo.length = ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.periodicReport.dlCqiPmiSize;
            ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[recvSF] = \
                                                                  ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.periodicReport.dlCqiPmiSize;
            ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[recvSF] = \
                                                                    ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.periodicReport.dlCqiPmiSize;

        }

        else if(ulCqiHarqRiPdu_p->cqiRiInfo.reportType == CQI_RI_APERIODIC_MODE)
        {
/* SPR 12135 Fix Start */
            UInt8 index = 0;
            UInt8  cqirequestbit = ueDLContext_p->dlCQIInfo.aperiodicCQIRequest[recvSF];
            cqiPduNode_p->cqiPduInfo.cqiRiInformation.numberOfCCReported = \
                ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.numberOfCC;
            for(index = 0; index < cqiPduNode_p->cqiPduInfo.cqiRiInformation.numberOfCCReported;
                    index++)
            {
                if(cqirequestbit & 0x1)
                {
                    /* for Pcell */
                    dlCqiPmiRISize_p = &(ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.
                            aperiodicReport.dlCqiPmiRISize[index]);
                    riValues=CALC_RIVALUES(dlCqiPmiRISize_p->riSize);

                    for (counter = 0; counter < riValues; counter++)
                    {
                        if (0 == counter)
                        { 
                            ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[recvSF] = \
                                                                                  ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.dlCqiPmiRISize[index].dlCqiPmiSizeRankX[0];
                        }
                        else
                        { 
                            ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[recvSF] = \
                                                             ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.dlCqiPmiRISize[index].dlCqiPmiSizeRankX[1];
                        }
                    }
                    cqirequestbit = cqirequestbit & ~(0x1);
                }
                else if( cqirequestbit & 0x2)
                {

                    /* for Scell */
                    ueContextForUplink  *ulUEInfo_p = uplinkContextInfoMap_g[ueDLContext_p->ueIndex];
                    DLCQIInfo *dlCQIInfo_p = &(ulUEInfo_p->carrierAggrConfig.scellInfo[0].dlCQIInfo);

                    dlCqiPmiRISize_p = &(ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport.dlCqiPmiRISize[index]);
                    if(1 == index)
                    {
                        /* case when report for both cells */
                        dlCqiPmiRISize_p = (dlcqiPmiRISizeAperiodic_st *)((UInt8 *)dlCqiPmiRISize_p + 
                                sizeof(UInt8));
                    }
                    riValues=CALC_RIVALUES(dlCqiPmiRISize_p->riSize);


                    for (counter = 0; counter < riValues; counter++)
                    {
                        if (0 == counter)
                        { 
                            dlCQIInfo_p->dlCqiPmiSizeRank_1[recvSF] = \
                                       dlCqiPmiRISize_p->dlCqiPmiSizeRankX[0];
                        }
                        else
                        { 
                            dlCQIInfo_p->dlCqiPmiSizeRankGT_1[recvSF] = \
                                       dlCqiPmiRISize_p->dlCqiPmiSizeRankX[1];
                        }
                    }
                    cqirequestbit = cqirequestbit & ~(0x2);
                }
/* SPR 12135 Fix Start */
                //            rank_1  = ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport[0]
                //          rankGT_1  = ulCqiHarqRiPdu_p->cqiRiInfo.pmiRIReport.aperiodicReport[1]

            }
        }
#else
        /* + CQI_4.1 */
        /* SPR 6496 changes start */ 
        cqiPduNode_p->cqiPduInfo.length = ulCqiHarqRiPdu_p->cqiRiInfo.dlCqiPmiSizeRank_1;
        /* SPR 6496 changes end */ 
        ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[recvSF] = ulCqiHarqRiPdu_p->cqiRiInfo.dlCqiPmiSizeRank_1;
        ueDLContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[recvSF] = ulCqiHarqRiPdu_p->cqiRiInfo.dlCqiPmiSizeRankGT_1;
#endif
/* SPR 10867 Fix End */
#ifdef UESIM_ENHANCEMENTS
        if(tempSF == recvSF)
        {
            *numOfRBsAllocatedInUL += ulCqiHarqRiPdu_p->ulSCHPduInfo.numOfRB;
            tempRBAllocatedInUL = ulCqiHarqRiPdu_p->ulSCHPduInfo.numOfRB;
            updateRAT2RBsinUL(ulCqiHarqRiPdu_p->ulSCHPduInfo.rbStart,
                    ulCqiHarqRiPdu_p->ulSCHPduInfo.numOfRB, cellIndex);
        }                  
#endif        

#if 0
        (ulCqiHarqRiPdu_p->cqiRiInfo.riSize + ulCqiHarqRiPdu_p->cqiRiInfo.dlCqiPmiSizeRankGT_1 +
         ulCqiHarqRiPdu_p->cqiRiInfo.dlCqiPmiSizeRank_1);
        /* + CQI_5.0 */
        if((1 == ulCqiHarqRiPdu_p->cqiRiInfo.riSize) &&
                ( (0 != ulCqiHarqRiPdu_p->cqiRiInfo.dlCqiPmiSizeRankGT_1) ||(ulCqiHarqRiPdu_p->cqiRiInfo.dlCqiPmiSizeRank_1 != 0)))
        {
            cqiPduNode_p->cqiPduInfo.length -= ulCqiHarqRiPdu_p->cqiRiInfo.riSize;
        }    

        /* - CQI_5.0 */
        /* - CQI_4.1 */
#endif        

    }

    else if(FAPI_UCI_CQI_SR == uciPduType)
    {
        uciCqiSrPdu_p = (FAPI_uciCqiSrPduInfo_st *)ulConfigPdu_p;
        cqiPduNode_p->cqiPduInfo.handle = MAC_PHY_CONVERT_32(uciCqiSrPdu_p->handle);
        cqiPduNode_p->cqiPduInfo.rnti = MAC_PHY_CONVERT_16(uciCqiSrPdu_p->rnti);

        cqiPduNode_p->cqiPduInfo.length = uciCqiSrPdu_p->cqiInfo.dlCqiPmiSize;

    }
    else if(FAPI_UCI_CQI_SR_HARQ == uciPduType)
    {
/* SPR 10867 Fix Start */
#ifdef FAPI_4_0_COMPLIANCE
        uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfoR9_st *)ulConfigPdu_p;
#else
        uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfo_st *)ulConfigPdu_p;
#endif
/* SPR 10867 Fix End */
        cqiPduNode_p->cqiPduInfo.handle = MAC_PHY_CONVERT_32(uciCqiSrHarqPdu_p->handle);
        cqiPduNode_p->cqiPduInfo.rnti = MAC_PHY_CONVERT_16(uciCqiSrHarqPdu_p->rnti);

        cqiPduNode_p->cqiPduInfo.length = uciCqiSrHarqPdu_p->cqiInfo.dlCqiPmiSize;

    }

#ifdef UESIM_ENHANCEMENTS
    ueContext_p = uplinkContextInfoMap_g[ueDLContext_p->ueIndex];
    ulHarq_p = &ueContext_p->ulharqInfo[harqIndex]; 
    if ((ulHarq_p->numOfRB[recvSF])&& (tempRBAllocatedInUL) &&
        (ulHarq_p->numOfRB[recvSF] != tempRBAllocatedInUL))
    {
        ltePanic("[%d] RB's allocated to UE in DCI0 = %d and in UL Config = %d are not same, sendSF = %d, harqIndex = %d, ueIndex = %d\n",
            globalTTITickCount_g,ulHarq_p->numOfRB[recvSF],tempRBAllocatedInUL,recvSF,harqIndex,ueDLContext_p->ueIndex);
    }
    else
    {
        ulHarq_p->numOfRB[recvSF] = 0;
    }
#endif

    rntiInfo_p = getRntiInfofromRNTIMap(cqiPduNode_p->cqiPduInfo.rnti, cellIndex);
    if (rntiInfo_p != PNULL) 
    {
        ueContext_p = uplinkContextInfoMap_g[rntiInfo_p->ueIndex];

        if ( ueContext_p == PNULL )
        {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
            lteWarning("Error!!  UE Context does not exist for crnti = %d, ueIndex = %d\n", 
                    cqiPduNode_p->cqiPduInfo.rnti, rntiInfo_p->ueIndex);
#endif                
            return ;
        }
    }
    else
    {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"getRntiInfofromRNTIMap returned NULL \n");
#endif
        return ;
    }

    pushNode(&cqiIndQueue[cellIndex][qIndex], 
            &(cqiPduNode_p->cqiNodeAnchor));

    return;
}

/* + CA_TDD_HARQ_CHANGES */
/****************************************************************************
 * Function Name  :  fapiProcessTDDULSchPdu
 * Inputs         :   
 * Outputs        :  None
 * Returns        :  Void 
 * Description    :  This function checks if there exists a UL SCH msg for a UL
 *                   Config PDU for a specific RNTI then it sets isScheduledOnPUSCH
 *                   in harq indication Node for that particular UE.
 ****************************************************************************/
#ifdef TDD_CONFIG
void fapiProcessTDDULSchPdu(
                                UInt16 recvSfnSf,
                                ueContextForUplink * ueContextInfo_p
                           )
{
    UInt32 recvSF = recvSfnSf & FAPI_SF_MASK;
    UInt32 recvSFN = recvSfnSf & FAPI_SFN_MASK;
    /* + SPR_14151 */
    recvSFN >>= FAPI_SFN_VALUE_SHIFT;
    if ( MAX_SUBFRAME == recvSF )
    {
        recvSF -= MAX_SUBFRAME;
        recvSFN++ ;
        if ( recvSFN == MAX_SFN )
        {
            recvSFN = 0;
        }
    }
    /* - SPR_14151 */
    FAPI_harqIndQueueNode_st * harqNode_p = ( FAPI_harqIndQueueNode_st *)
        ueContextInfo_p->harqNode_p[recvSFN & 1][recvSF];
    if (harqNode_p)
    {
        harqNode_p->isScheduledOnPUSCH = TRUE;
    }
}
#endif
/* - CA_TDD_HARQ_CHANGES */

/****************************************************************************
 * Function Name  :  fapiProcessULSchPdu
 * Inputs         :   
 * Outputs        :  None
 * Returns        :  Void 
 * Description    :  This function checks if there exists a UL SCH msg for a UL
 *                   Config PDU for a specific RNTI
 ****************************************************************************/
//TA: NON_SS
void fapiProcessULSchPdu(UInt8 qIndex, UInt8 *ulConfigPdu_p, UInt8 uciPduType,
        UInt8 cellIndex
#ifdef UESIM_ENHANCEMENTS
                         /* +- SPR 18268 */
                         ,UInt8 *numOfRBsAllocatedInUL,UInt16 ueIndex,
                         /* +- SPR 18268 */
                         UInt8 harqIndex,UInt16 sendSF
#endif                    
                         )  
{
    ulschDataQueueNode *ulschDataNode_p = PNULL;
    FAPI_ulSCHPduInfo_st *ulSchPdu_p = PNULL;
    FAPI_ulSCHHarqPduInfo_st *ulSchHarqPdu_p = PNULL;
#ifdef UESIM_ENHANCEMENTS
    ueContextForUplink *ueContextInfo_p = NULL;
    ULHarqInfo* ulHarq_p = PNULL;
    UInt8 tempRBAllocatedInUL = 0;
    UInt8 tempSF = globalTTITickCount_g % 10;
#endif    
    UInt16 queueCount = 0;
    UInt16 rnti = 0;

    if (FAPI_ULSCH_HARQ == uciPduType)
    {
        ulSchHarqPdu_p = (FAPI_ulSCHHarqPduInfo_st *)ulConfigPdu_p;
        rnti = ulSchHarqPdu_p->ulSCHPduInfo.rnti;

#ifdef UESIM_ENHANCEMENTS
        if(tempSF == sendSF)
        {
            *numOfRBsAllocatedInUL += ulSchHarqPdu_p->ulSCHPduInfo.numOfRB;
            tempRBAllocatedInUL = ulSchHarqPdu_p->ulSCHPduInfo.numOfRB;
            updateRAT2RBsinUL(ulSchHarqPdu_p->ulSCHPduInfo.rbStart,
                    ulSchHarqPdu_p->ulSCHPduInfo.numOfRB, cellIndex);
        }                  
#endif    
    }
    else if (FAPI_ULSCH == uciPduType)
    {
        ulSchPdu_p = (FAPI_ulSCHPduInfo_st *)ulConfigPdu_p;
        rnti = ulSchPdu_p->rnti;
#ifdef UESIM_ENHANCEMENTS
        if(tempSF == sendSF)
        {
            *numOfRBsAllocatedInUL += ulSchPdu_p->numOfRB;
            tempRBAllocatedInUL = ulSchPdu_p->numOfRB;
            updateRAT2RBsinUL(ulSchPdu_p->rbStart,
                    ulSchPdu_p->numOfRB, cellIndex);
        }                  
#endif    
    }

#ifdef UESIM_ENHANCEMENTS
        ueContextInfo_p = uplinkContextInfoMap_g[ueIndex];
        ulHarq_p = &ueContextInfo_p->ulharqInfo[harqIndex]; 
        if ((ulHarq_p->numOfRB[sendSF])&& (tempRBAllocatedInUL) &&
            (ulHarq_p->numOfRB[sendSF] != tempRBAllocatedInUL))
        {
            ltePanic("[%d] RB's alld DCI0 = %d  UL Config = %d are not same, sendSF = %d, harqIndex = %d, ueIndex = %d, uciPduType = %d\n",
                    globalTTITickCount_g,ulHarq_p->numOfRB[sendSF],tempRBAllocatedInUL,sendSF,harqIndex,ueIndex,uciPduType);
        }
        else
        {
            ulHarq_p->numOfRB[sendSF] = 0;
        }
#endif    

#ifdef UT_TESTING
    queueCount = sQueueCount(&(ulDataQueue[cellIndex][qIndex]));
    if (queueCount)
    {
        ulschDataNode_p = ( ulschDataQueueNode *) 
            getFirstNode(&(ulDataQueue[cellIndex][qIndex]));
        if (rnti == ulschDataNode_p->rnti)
        {
            /* Validation is successful */
            return;
        }

        queueCount--;
        while(queueCount)
        {
            ulschDataNode_p = ( ulschDataQueueNode *) 
                getNextNode(ulschDataNode_p);

            if (NULL == ulschDataNode_p)
            {
                fprintf(stderr, "Invalid scenario This should not happen\n");
                return;
            }

            if (rnti == ulschDataNode_p->rnti)
            {
                /* Validation is successful */
                return;
            }
            queueCount--;

        }
    }
#endif
    return;
}

/****************************************************************************
 * Function Name  :  fapiProcessSrsPdu
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    :
 ****************************************************************************/
void fapiProcessSrsPdu(UInt8 qIndex, UInt8 *ulConfigPdu_p,UInt16 recvsfnsf,
		UInt8 cellIndex)
{
	ueContextForUplink *ueContext_p = PNULL;
	RNTIInfo *rntiInfo_p = PNULL; 
    FAPI_srsPduInfo_st *srsPdu_p = PNULL;
    FAPI_ulSrsIndicationNode_st *srsIndNode_p = PNULL;     
    srsPdu_p =(FAPI_srsPduInfo_st *)ulConfigPdu_p;

    srsIndNode_p = (FAPI_ulSrsIndicationNode_st *)
        getMemFromPool(sizeof(FAPI_ulSrsIndicationNode_st), PNULL);
    if ( PNULL == srsIndNode_p )
    {
        fprintf(stderr,"Error!! in prepareSRSPdu allocation of SRS node for rnti = %d\n",srsPdu_p->rnti);
        return;
    }    
    srsIndNode_p->sfnsf = recvsfnsf;
    srsIndNode_p->rnti = MAC_PHY_CONVERT_16(srsPdu_p->rnti);
    srsIndNode_p->handle = MAC_PHY_CONVERT_32(srsPdu_p->handle);

    rntiInfo_p = getRntiInfofromRNTIMap(srsIndNode_p->rnti, cellIndex);
    if (rntiInfo_p != PNULL) 
    {
        ueContext_p = uplinkContextInfoMap_g[rntiInfo_p->ueIndex];

        if ( ueContext_p == PNULL )
        {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
            lteWarning("Error!!  UE Context does not exist for crnti = %d, ueIndex = %d\n", 
                    srsIndNode_p->rnti, rntiInfo_p->ueIndex);
#endif
            return ;
        }
    }
    else
    {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"getRntiInfofromRNTIMap returned NULL \n");
#endif
        return ;
    }

#if 0
    fprintf(stderr,"srsIndNode pushed into queue at index=%d with sfnsf =%d rnti =%d  handle =%d\n",qIndex,recvsfnsf,srsIndNode_p->rnti,srsIndNode_p->handle);   
#endif
    pushNode(&srsIndQueue[cellIndex][qIndex],
            &(srsIndNode_p->srsNodeAnchor) );    
    return; 
}    


/****************************************************************************
 * Function Name  :  fapiHandlePhyUlConfigRequest
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA NON_SS
void fapiHandlePhyUlConfigRequest(FAPI_l1ApiMsg_st *l1RcvMsg_p, UInt8 cellIndex)
{
    FAPI_ulConfigRequest_st *ulConfigReq_p = PNULL;
    FAPI_ulPDUConfigInfo_st *ulConfigPdu_p = PNULL;
    UInt16 currentSFN = 0, recvSFN = 0;
    UInt16 currentSfnSf = 0, recvSfnSf = 0, sendSfnSf = 0;
    UInt8  currentSF = 0, recvSF = 0, qIndex = 0;
    UInt8  *ulConfigPduDataTraverse_p = PNULL;
    /* SPR 609 changes start */
    //ControlNodeInfo ctlInfo  = {0};
    //UInt8 delay = 0;
    /* SPR 609 changes end */
    UInt16 numOfPduCount = 0;
    UInt8 srsQIndex = 0;
    /* + MEAS_GAP_CHG*/
    DLUEContext *newUEContext_p = PNULL;
    UInt16 rnti = 0;   
    /* -  MEAS_GAP_CHG*/
    /* + CQI_4.1 */
    UInt8 SF  = 0;
    UInt16 SFN  = 0;
    /* - CQI_4.1 */
#ifdef UESIM_ENHANCEMENTS
    UInt8 numOfRBsAllocatedInUL = 0;
#endif    
    UInt8 *PhyUlConfigRes_p =  PNULL;
    UInt32 PhyUlConfigRes_size = 0;

    /* Since global tick is updated on sending of SFI message, hence UL Config 
     * tick will be 1 less */
    /* SPR 15909 fix start */
    tickType_t ulConfigTick = globalTTITickCount_g - 1;
    /* SPR 15909 fix end */
/** SPR 12586 Fix : Start **/ 
    ueContextForUplink *ueUlContextInfo_p = PNULL;
    ScellInfo *scellInfo_p = PNULL;
    UInt8 scellCount = 0;
/** SPR 12586 Fix : End **/

    if ( l1RcvMsg_p->msgLen == 0 )
    {
        fprintf(stderr,"Error..!!! msgLen = 0 recevied from MAC in UL CONFIG REQ\n");  
        return;
    }
    /*FAPI_ERROR_INDICATION_CHANGES_START*/
    /* Send phy error in case of invalid phy state*/
    if ((1 == phy_err_config_g[cellIndex])&&\
        (( ulConfigTick >= phy_err_start_tti_g[cellIndex]) && \
        ( ulConfigTick <= phy_err_end_tti_g[cellIndex])) && (errorCount_g[cellIndex] == 0))
        {
        if (PHY_UL_CONFIG_REQUEST == phy_err_msg_type_g[cellIndex] && FAPI_MSG_INVALID_STATE == phy_err_error_type_g[cellIndex])
        {
            fapiSendErrorIndication(FAPI_MSG_INVALID_STATE, l1RcvMsg_p->msgId,
                    0,0, &PhyUlConfigRes_p,&PhyUlConfigRes_size, cellIndex);
#ifdef HO_SETUP_CHANGES
            sendSFItoSourceENBMac(PhyUlConfigRes_p,PhyUlConfigRes_size,cellIndex);
            if ( startRecvFlag[cellIndex] == 2 )
            {
                sendDataToTargetEnbMac(PhyUlConfigRes_p,PhyUlConfigRes_size, cellIndex);
            }
#else
            sendDatatoPeerMac( (UInt8 *)PhyUlConfigRes_p,PhyUlConfigRes_size, cellIndex);
#endif            
            freeMemPool(PhyUlConfigRes_p);
            PhyUlConfigRes_p = PNULL;
            phyState_g[cellIndex] = FAPI_CONFIGURED;
            /*Reset the global vars */
            resetGlobals(cellIndex);
            errorCount_g[cellIndex]++;
            return;
        }
    }
    /*FAPI_ERROR_INDICATION_CHANGES_END*/

#ifndef HO_SETUP_CHANGES
    if ( FAPI_RUNNING != phyState_g[cellIndex] )
    {
        /* send error indication */
        /* FAPI_MSG_INVALID_STATE */
        fapiSendErrorIndication(FAPI_MSG_INVALID_STATE, l1RcvMsg_p->msgId,
                recvSfnSf,0, &PhyDlConfigRes_p,&PhyDlConfigRes_size,cellIndex);
        sendMsgtoTargetL2Config( (UInt8 *)PhyHiDciresp_p,PhyHiDciresp_size,cellIndex);
        freeMemPool( PhyDlConfigRes_p);
        PhyDlConfigRes_p = PNULL;
        return;
    }
#endif
    ulConfigReq_p = ( FAPI_ulConfigRequest_st * ) &(l1RcvMsg_p->msgBody[0]);
    /* + CQI_4.1 */
    if ( PNULL == ulConfigReq_p->numOfPdu )
        /* - CQI_4.1 */
    {
        lteWarning("Error..!! ulConfig req has no data\n");
        return;
    }
    currentSfnSf = sfnsf_g[cellIndex];
    recvSfnSf = MAC_PHY_CONVERT_16(ulConfigReq_p->sfnsf); 
    recvSFN = recvSfnSf & FAPI_SFN_MASK;
    recvSFN >>= FAPI_SFN_VALUE_SHIFT; 
    recvSF = recvSfnSf & FAPI_SF_MASK;
    currentSFN = currentSfnSf & FAPI_SFN_MASK;
    currentSFN >>= FAPI_SFN_VALUE_SHIFT;
    currentSF = currentSfnSf & FAPI_SF_MASK;

    /* check for validation of recevied SFN & SF from MAC */ 
    if (!(validateUlConfig(recvSFN, recvSF,currentSFN, currentSF)) )
    {
        fprintf(stderr,"UL CONFIG packet Dropped:\n");
        fprintf(stderr,"C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);

        return;
    }

    //recvSF += MAX_ULCONFIG_DELAY;
    if ( MAX_SUBFRAME == recvSF )
    {
        recvSF -= MAX_SUBFRAME;
        recvSFN++ ;
        if ( recvSFN == MAX_SFN )
        {
            recvSFN = 0;
        }
    }
#ifdef FDD_CONFIG
    //Rajesh 
    qIndex = (recvSF + PEER_MAC_DELAY )%10;
#elif TDD_CONFIG
    qIndex = (recvSFN*MAX_SUBFRAME + recvSF + PEER_MAC_DELAY )%MAX_UL_ARRAY;
#endif
    srsQIndex = (recvSF + PEER_MAC_DELAY )%10;

    sendSfnSf = MAC_PHY_CONVERT_16(ulConfigReq_p->sfnsf);

    ulConfigPdu_p = (FAPI_ulPDUConfigInfo_st *) 
        &(ulConfigReq_p->ulPduConfigInfo[0]);
    ulConfigPduDataTraverse_p = ( UInt8 *) &(ulConfigReq_p->ulPduConfigInfo[0]);
    while( numOfPduCount < ulConfigReq_p->numOfPdu )
    {
        ulConfigPdu_p = (FAPI_ulPDUConfigInfo_st *) 
            ulConfigPduDataTraverse_p; 

        /* +  MEAS_GAP_CHG*/

        rnti =  getRNTIFromULConfigPdu(ulConfigPdu_p);
        newUEContext_p = getDLUEContextFromRnti(rnti, cellIndex);
        if ( PNULL != newUEContext_p &&
                RELEASE != newUEContext_p->measGapConfigType )
        {    
            if ( MAC_SUCCESS ==
                    checkIsMeasurementGapPeriodON(recvSFN,recvSF,newUEContext_p))
            {
                lteWarning( "UL Config request received during Measurement gap"
                        "period SFN = %d , SF = %d ,ueIndex = %d ."
                        ,recvSFN , recvSF,newUEContext_p->ueIndex );
                numOfPduCount++;
                ulConfigPduDataTraverse_p += ulConfigPdu_p->ulConfigPduSize;
                continue;
            }
        } 
        /* + CQI_4.1 */
        else if(PNULL == newUEContext_p)
        {
            lteWarning("Error..!! newUEContext_p is NULL, UE Context doesn't exist\n");
            /* SPR 19220 fix start */
            ulConfigPduDataTraverse_p += ulConfigPdu_p->ulConfigPduSize;
            numOfPduCount++;
            continue;
            /* SPR 19220 fix end */
        }    
        /* - MEAS_GAP_CHG*/
        SFN = recvSfnSf & 0xFFF0;
        SFN >>= 4; 
        SF = recvSfnSf & 0x000F;
        /* - CQI_4.1 */
#ifdef UESIM_ENHANCEMENTS
        UInt8 harqIndex = (((recvSFN * MAX_SUBFRAME) + recvSF ) % MAX_HARQ_PROCESS_NB);
#endif
       /*FAPI_ERROR_INDICATION_CHANGES_START*/
       /*Send phy error incase of subframe error in UL Config*/
       if ((1 == phy_err_config_g[cellIndex]) &&
            ( ( ulConfigTick >= phy_err_start_tti_g[cellIndex]) && 
              ( ulConfigTick <= phy_err_end_tti_g[cellIndex])) && (errorCount_g[cellIndex] == 0) )
       {
           if (PHY_UL_CONFIG_REQUEST == phy_err_msg_type_g[cellIndex])
           {
               if ((FAPI_MSG_SUBFRAME_ERR == phy_err_error_type_g[cellIndex]) && (ulConfigPdu_p->ulConfigPduType == phy_err_pdu_type_g[cellIndex]))
               {
                   phy_err_crnti_g[cellIndex] = rnti;
                   fapiSendErrorIndication(FAPI_MSG_SUBFRAME_ERR, l1RcvMsg_p->msgId,
                           0,0,&PhyUlConfigRes_p,&PhyUlConfigRes_size, cellIndex);

                   UInt8 errQIdx = recvSF + 1;
                   if( errQIdx >= MAX_SUBFRAME )
                   {
                       errQIdx -= MAX_SUBFRAME;
                   }
                   LP_PhyErrInd phyErrInd_p = (LP_PhyErrInd)getMemFromPool( 
                           sizeof(PhyErrInd), PNULL );
                   if( PNULL == phyErrInd_p )
                   {
                       freeMemPool(PhyUlConfigRes_p);
                       PhyUlConfigRes_p = PNULL;
                       return;
                   }
                   else
                   {
                       phyErrInd_p->data_p = PhyUlConfigRes_p;
                       phyErrInd_p->dataSize = PhyUlConfigRes_size;

                       ENQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx,cellIndex );
                   }
                   errorCount_g[cellIndex]++;
                   return;
               }
           }
       }
       /*FAPI_ERROR_INDICATION_CHANGES_END*/
        switch ( ulConfigPdu_p->ulConfigPduType )
        {
            case FAPI_ULSCH:
#ifdef FDD_CONFIG /* BMJ : Need to be reviewed for TDD */            
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"FAPI_ULSCH rcvd in ul config\n");
#endif
                fapiProcessULSchPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_ULSCH, 
                        cellIndex
#ifdef UESIM_ENHANCEMENTS
                        ,&numOfRBsAllocatedInUL,newUEContext_p->ueIndex,
                        harqIndex,recvSF
#endif                   
                        );
#endif                        
                break;
            case FAPI_ULSCH_HARQ:
#ifdef FDD_CONFIG /* BMJ : Need to be reviewed for TDD */            
                /* handle of ULSCH HARQ */
                fapiProcessULSchPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_ULSCH_HARQ,
                        cellIndex
#ifdef UESIM_ENHANCEMENTS
                        ,&numOfRBsAllocatedInUL,newUEContext_p->ueIndex,
                        harqIndex,recvSF
#endif                         
                        );
                /* + CA_TDD_HARQ_CHANGES */
#else
                if (PNULL == (ueUlContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(rnti), cellIndex)))
                {
                    fprintf (stderr, "HARQ Node has to be pushed in Queue for UE having"
                            "rnti =%d but Context Doesnot exist for this UE\n",MAC_PHY_CONVERT_16(rnti));
                    return;
                }
                fapiProcessTDDULSchPdu(recvSfnSf,ueUlContextInfo_p);
#endif                         
                /* - CA_TDD_HARQ_CHANGES */

                break;
            case FAPI_ULSCH_CQI_HARQ_RI:
                /* + CQI_4.1 */
                if (newUEContext_p->dlCQIInfo.aperiodicCQIRequest[recvSF])
                {
                    newUEContext_p->dlCQIInfo.cqiReportType[recvSF] = ULSCH_APERIODIC_REPORT_TYPE;
/* SPR 12135 Fix */
                   // newUEContext_p->dlCQIInfo.aperiodicCQIRequest[recvSF] = FALSE;
                }
                else
                {
                    newUEContext_p->dlCQIInfo.cqiReportType[recvSF] = UCI_PERIODIC_REPORT_TYPE;
                }   

                /* - CQI_4.1 */
                /* + CQI_5.0 */
                newUEContext_p->dlCQIInfo.isULSCHPDUType[recvSF] = TRUE;
                /* - CQI_5.0 */
                fapiProcessUciCqiPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_ULSCH_CQI_HARQ_RI,
                        recvSfnSf,newUEContext_p
#ifdef UESIM_ENHANCEMENTS
                        ,&numOfRBsAllocatedInUL,harqIndex
#endif                        
						,cellIndex);
                break;
            case FAPI_UCI_CQI:
                /* + CQI_4.1 */
                newUEContext_p->dlCQIInfo.cqiReportType[recvSF] = UCI_PERIODIC_REPORT_TYPE;
                /* - CQI_4.1 */
                fapiProcessUciCqiPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_UCI_CQI,
                        recvSfnSf,newUEContext_p
#ifdef UESIM_ENHANCEMENTS
                        ,&numOfRBsAllocatedInUL,harqIndex
#endif                        
						,cellIndex);
                break;
            case FAPI_ULSCH_CQI_RI:
                /* + CQI_4.1 */
                if (newUEContext_p->dlCQIInfo.aperiodicCQIRequest[recvSF])
                {
                    newUEContext_p->dlCQIInfo.cqiReportType[recvSF] = ULSCH_APERIODIC_REPORT_TYPE;
/* SPR 12135 Fix  */
                    //newUEContext_p->dlCQIInfo.aperiodicCQIRequest[recvSF] = FALSE;
                }
                else
                {
                    newUEContext_p->dlCQIInfo.cqiReportType[recvSF] = UCI_PERIODIC_REPORT_TYPE;
                }    
                /* - CQI_4.1 */
                /* + CQI_5.0 */
                newUEContext_p->dlCQIInfo.isULSCHPDUType[recvSF] = TRUE;
                /* - CQI_5.0 */
                fapiProcessUciCqiPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_ULSCH_CQI_RI,
                        recvSfnSf,newUEContext_p
#ifdef UESIM_ENHANCEMENTS
                        ,&numOfRBsAllocatedInUL,harqIndex
#endif                        
						,cellIndex);
                break;
            case FAPI_UCI_SR_HARQ:
#ifdef FDD_CONFIG /* BMJ : Need to be reviewed for TDD */            
                fapiProcessUciSrPdu(qIndex, &ulConfigPdu_p->ulPduConfigInfo[0], 
                        sendSfnSf, FAPI_UCI_SR_HARQ, cellIndex);
#endif
/* TDD special bundling changes start*/
#ifdef TDD_CONFIG
                fapiProcessUciHarqPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_UCI_SR_HARQ, 
                        recvSfnSf
#ifdef UESIM_ENHANCEMENTS
                        ,newUEContext_p
#endif                         
                        ,cellIndex
                        );
#endif
/* TDD special bundling changes end*/
                break;
            case FAPI_UCI_SR:
#ifdef FDD_CONFIG /* BMJ : Need to be reviewed for TDD */            
                fapiProcessUciSrPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0],sendSfnSf, 
						FAPI_UCI_SR, cellIndex);
#endif
                break;
            case FAPI_UCI_HARQ:
                /* + CQI_4.1 */
                /* - CQI_4.1 */
                break;
            case FAPI_UCI_CQI_HARQ:
                /* + CQI_4.1 */
                newUEContext_p->dlCQIInfo.cqiReportType[recvSF] = UCI_PERIODIC_REPORT_TYPE;
                /* - CQI_4.1 */
                fapiProcessUciCqiPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_UCI_CQI_HARQ,
                        recvSfnSf,newUEContext_p
#ifdef UESIM_ENHANCEMENTS
                        ,&numOfRBsAllocatedInUL,harqIndex
#endif                        
						,cellIndex);
/* TDD special bundling changes start*/
#ifdef TDD_CONFIG
                 fapiProcessUciHarqPdu(qIndex,
                   &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_UCI_CQI_HARQ, 
                   recvSfnSf, cellIndex);
#endif
/* TDD special bundling changes end*/
                break;

            case FAPI_UCI_CQI_SR:
                /* + CQI_4.1 */
                newUEContext_p->dlCQIInfo.cqiReportType[recvSF] = UCI_PERIODIC_REPORT_TYPE;
                /* - CQI_4.1 */
                /*SPR 1289 Start */
#ifdef FDD_CONFIG 

                fapiProcessUciSrPdu(qIndex, &ulConfigPdu_p->ulPduConfigInfo[0], 
                        sendSfnSf, FAPI_UCI_CQI_SR, cellIndex);
#endif

                /*SPR 1289 End */
                fapiProcessUciCqiPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_UCI_CQI_SR,
                        recvSfnSf,newUEContext_p
#ifdef UESIM_ENHANCEMENTS
                        ,&numOfRBsAllocatedInUL,harqIndex
#endif                        
                        ,cellIndex);
                break;
            case FAPI_UCI_CQI_SR_HARQ:
                /* + CQI_4.1 */
                newUEContext_p->dlCQIInfo.cqiReportType[recvSF] = UCI_PERIODIC_REPORT_TYPE;
                /* - CQI_4.1 */
                /*SPR 1289 Start */
#ifdef FDD_CONFIG 
                fapiProcessUciSrPdu(qIndex, &ulConfigPdu_p->ulPduConfigInfo[0], 
                        sendSfnSf, FAPI_UCI_CQI_SR_HARQ, cellIndex);
#endif
                /*SPR 1289 End */
                fapiProcessUciCqiPdu(qIndex,
                        &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_UCI_CQI_SR_HARQ,
                        recvSfnSf,newUEContext_p
#ifdef UESIM_ENHANCEMENTS
                        ,&numOfRBsAllocatedInUL,harqIndex
#endif                        
						,cellIndex); 
/* TDD special bundling changes start*/
#ifdef TDD_CONFIG
                 fapiProcessUciHarqPdu(qIndex,
                   &ulConfigPdu_p->ulPduConfigInfo[0], FAPI_UCI_CQI_SR_HARQ, 
                   recvSfnSf, cellIndex);
#endif
/* TDD special bundling changes end*/
                break;
            case FAPI_SRS:
				fapiProcessSrsPdu(srsQIndex,&ulConfigPdu_p->ulPduConfigInfo[0],
						recvSfnSf, cellIndex);
                break;
            default:
                fprintf(stderr,"got not supported pdu type = %d\n", ulConfigPdu_p->ulConfigPduType );
                break;
        }
        numOfPduCount++;
        ulConfigPduDataTraverse_p += ulConfigPdu_p->ulConfigPduSize;

        /* + CQI_4.1 */
        /*SPR 15909 fix start*/
        tickType_t currentTTI = (SFN * 10) + SF;
        /*SPR 15909 fix end*/
        if ( (TRUE == newUEContext_p->dlCQIInfo.calculateBandwidthPartFlag) &&
                (0 != newUEContext_p->dlCQIInfo.periodicModeType) &&
                ((UCI_PERIODIC_REPORT_TYPE == 
                  newUEContext_p->dlCQIInfo.cqiReportType[recvSF]) ||
                 (FAPI_UCI_HARQ == ulConfigPdu_p->ulConfigPduType)) ) 
        {
            initBandwidthPart(newUEContext_p, SFN, SF);
            if(currentTTI >= newUEContext_p->dlCQIInfo.nextWidebandOccurrence)
            {
                UPDATE_BANDWIDTHPART_ON_WIDEBAND_REPORT(newUEContext_p,SFN,SF);
            }
            else if(currentTTI >= newUEContext_p->dlCQIInfo.nextSubbandOccurrence)
            {
                UPDATE_BANDWIDTHPART_ON_SUBBAND_REPORT(newUEContext_p,SFN,SF);
            }
            else if(currentTTI >= newUEContext_p->dlCQIInfo.nextWidebandOccurrence_2) /* EICIC +*/
            {
                UPDATE_BANDWIDTHPART_ON_WIDEBAND_REPORT_2(newUEContext_p,SFN,SF);
            }
            else if(currentTTI >= newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2)
            {
                UPDATE_BANDWIDTHPART_ON_SUBBAND_REPORT_2(newUEContext_p,SFN,SF); /* EICIC - */
            }

        }
        else if( ((CQI_PERIODIC_TYPE_20 == newUEContext_p->dlCQIInfo.periodicModeType) ||
                    (CQI_PERIODIC_TYPE_21 == newUEContext_p->dlCQIInfo.periodicModeType)) &&
                (recvSfnSf != newUEContext_p->dlCQIInfo.tempRecvSfnSf) ||
                (FAPI_SRS == ulConfigPdu_p->ulConfigPduType) )
        {
            if( currentTTI == newUEContext_p->dlCQIInfo.nextWidebandOccurrence)
            {
                UPDATE_BANDWIDTHPART_ON_WIDEBAND_REPORT(newUEContext_p,SFN,SF);
                newUEContext_p->dlCQIInfo.tempRecvSfnSf = recvSfnSf;
            }
            else if(currentTTI == newUEContext_p->dlCQIInfo.nextSubbandOccurrence)
            {
                UPDATE_BANDWIDTHPART_ON_SUBBAND_REPORT(newUEContext_p,SFN,SF);
                newUEContext_p->dlCQIInfo.tempRecvSfnSf = recvSfnSf;
            }
             else if( currentTTI == newUEContext_p->dlCQIInfo.nextWidebandOccurrence_2) /* EICIC +*/
            {
                UPDATE_BANDWIDTHPART_ON_WIDEBAND_REPORT_2(newUEContext_p,SFN,SF);
                newUEContext_p->dlCQIInfo.tempRecvSfnSf = recvSfnSf;
            }
            else if(currentTTI == newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2)
            {
                UPDATE_BANDWIDTHPART_ON_SUBBAND_REPORT_2(newUEContext_p,SFN,SF);
                newUEContext_p->dlCQIInfo.tempRecvSfnSf = recvSfnSf;
            } /* EICIC - */

        }        


        /** SPR 12586 Fix : Start **/ 
        if (PNULL == (ueUlContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(rnti), cellIndex)))
        {
            fprintf (stderr, "HARQ Node has to be pushed in Queue for UE having"
                    "rnti =%d but Context Doesnot exist for this UE\n",MAC_PHY_CONVERT_16(rnti));
            return;

        }

        currentTTI = (SFN * 10) + SF;

        if (0 < ueUlContextInfo_p->carrierAggrConfig.scellCount)
        {
            scellInfo_p = &(ueUlContextInfo_p->carrierAggrConfig.scellInfo[scellCount]);
            if ( (scellInfo_p) && (TRUE == scellInfo_p->dlCQIInfo.calculateBandwidthPartFlag) &&
                    (0 != scellInfo_p->dlCQIInfo.periodicModeType) &&
                    ((UCI_PERIODIC_REPORT_TYPE == 
                      scellInfo_p->dlCQIInfo.cqiReportType[recvSF]) ||
                     (FAPI_UCI_HARQ == ulConfigPdu_p->ulConfigPduType)) ) 
            {
                initSCellBandwidthPart(scellInfo_p, SFN, SF);
                if(currentTTI >= scellInfo_p->dlCQIInfo.nextWidebandOccurrence)
                {
                    UPDATE_SCELL_BANDWIDTHPART_ON_WIDEBAND_REPORT(scellInfo_p,SFN,SF);
                }
                else if(currentTTI >= scellInfo_p->dlCQIInfo.nextSubbandOccurrence)
                {
                    UPDATE_SCELL_BANDWIDTHPART_ON_SUBBAND_REPORT(scellInfo_p,SFN,SF);
                }

                if(currentTTI >= scellInfo_p->dlCQIInfo.nextWidebandOccurrence_2)
                {
                    UPDATE_SCELL_BANDWIDTHPART_ON_WIDEBAND_REPORT_2(scellInfo_p,SFN,SF);
                }
                else if(currentTTI >= scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2)
                {
                    UPDATE_SCELL_BANDWIDTHPART_ON_SUBBAND_REPORT_2(scellInfo_p,SFN,SF);
                }
            }
            else if( (scellInfo_p) && ((CQI_PERIODIC_TYPE_20 == scellInfo_p->dlCQIInfo.periodicModeType) ||
                        (CQI_PERIODIC_TYPE_21 == scellInfo_p->dlCQIInfo.periodicModeType)) &&
                    (recvSfnSf != scellInfo_p->dlCQIInfo.tempRecvSfnSf) ||
                    (FAPI_SRS == ulConfigPdu_p->ulConfigPduType) )
            {
                if( currentTTI == scellInfo_p->dlCQIInfo.nextWidebandOccurrence)
                {
                    UPDATE_SCELL_BANDWIDTHPART_ON_WIDEBAND_REPORT(scellInfo_p,SFN,SF);
                    scellInfo_p->dlCQIInfo.tempRecvSfnSf = recvSfnSf;
                }
                else if(currentTTI == scellInfo_p->dlCQIInfo.nextSubbandOccurrence)
                {
                    UPDATE_SCELL_BANDWIDTHPART_ON_SUBBAND_REPORT(scellInfo_p,SFN,SF);
                    scellInfo_p->dlCQIInfo.tempRecvSfnSf = recvSfnSf;
                }
                 if( currentTTI == scellInfo_p->dlCQIInfo.nextWidebandOccurrence_2)
                {
                    UPDATE_SCELL_BANDWIDTHPART_ON_WIDEBAND_REPORT_2(scellInfo_p,SFN,SF);
                    scellInfo_p->dlCQIInfo.tempRecvSfnSf = recvSfnSf;
                }
                else if(currentTTI == scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2)
                {
                    UPDATE_SCELL_BANDWIDTHPART_ON_SUBBAND_REPORT_2(scellInfo_p,SFN,SF);
                    scellInfo_p->dlCQIInfo.tempRecvSfnSf = recvSfnSf;
                }
            }
        }
        /** SPR 12586 Fix : End **/
        /* - CQI_4.1 */
    }

#ifdef UESIM_ENHANCEMENTS
    if( (numOfRBsAllocatedInUL) &&  
        (numOfRBsAllocatedInUL > cellConfigUeSim_g[cellIndex].ulAvailableRBs) )
    {
        ltePanic("Total RB's allocated in UL = %d is less than equal to system bandwidth = %d\n",
                 numOfRBsAllocatedInUL,cellConfigUeSim_g[cellIndex].ulAvailableRBs);
    }
#endif
}
/****************************************************************************
 * Function Name  :  fapiReadMacMsg
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : This function is the entry point for parsing of msg 
 *                  recv from peer MAC.
 ****************************************************************************/
//TA NON_SS
/* CA */ 




void fapiReadMacMsg( UInt8 *recvDataBuffer_p, fapiMsgIdStruct *msgIdArr_p, UInt8 rxCellIndex
        )
/* CA_NA */ 
{
    FAPI_l1ApiMsg_st *l1RcvMsg_p =  ( FAPI_l1ApiMsg_st *) recvDataBuffer_p;
    FAPI_subFrameIndication_st *sfnsf_p = PNULL;

    switch ( l1RcvMsg_p->msgId )
    { 
        case PHY_DL_CONFIG_REQUEST:
            {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr," PHY_DL_CONFIG_REQUEST recived \n");
#endif
#ifdef OVERSHOOT_CORRECTION
                GET_CYCLE_COUNT(phyMsgRecv_g);
#endif

                fapiHandlePhyDlConfigRequest( l1RcvMsg_p, msgIdArr_p, rxCellIndex);
#ifdef DL_DATA_SEPARATION                 
                checkDlConfigDlTxMsg(l1RcvMsg_p, msgIdArr_p, rxCellIndex); 
#endif
            }
            break;

        case PHY_DL_TX_REQUEST:
            {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr," PHY_DL_TX_REQUEST recived \n");
#endif
#ifdef OVERSHOOT_CORRECTION
                GET_CYCLE_COUNT(phyMsgRecv_g);
#endif

#ifdef DL_DATA_SEPARATION                 
                checkDlConfigDlTxMsg(l1RcvMsg_p, msgIdArr_p, rxCellIndex); 
#else               
/* +CA */ 
                fapiHandlePhyDlTxRequest( l1RcvMsg_p, msgIdArr_p, rxCellIndex );
/* -CA */ 
#endif                
            }
            break;

        case PHY_UL_CONFIG_REQUEST:
            {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr," PHY_UL_CONFIG_REQUEST recived \n");
#endif
#ifdef OVERSHOOT_CORRECTION
                GET_CYCLE_COUNT(phyMsgRecv_g);
#endif
                fapiHandlePhyUlConfigRequest(l1RcvMsg_p, rxCellIndex);

            }
            break;

        case PHY_DL_HI_DCI0_REQUEST:
            {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr," PHY_DL_HI_DCI0_REQUEST recived \n");
#endif
#ifdef OVERSHOOT_CORRECTION
                GET_CYCLE_COUNT(phyMsgRecv_g);
#endif
                fapiHandlePhyHiDciRequest(l1RcvMsg_p, rxCellIndex);
            }
            break;
        case PHY_UL_SUBFRAME_INDICATION:
            {
            /*HD FDD Changes Start*/
#ifdef FDD_CONFIG
#ifdef HD_FDD_CONFIG
            clearUeScheduleMapContext(dlRecvSF_g);
#endif
#endif
            /*HD FDD Changes End*/
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"PHY_UL_SUBFRAME_INDICATION recived \n");
#endif
                sfnsf_p = ( FAPI_subFrameIndication_st *) &( l1RcvMsg_p->msgBody[0]);
                SFN_g[rxCellIndex] = (uint16_t)(MAC_PHY_CONVERT_16(sfnsf_p->sfnsf) & FAPI_SFN_MASK);
                SFN_g[rxCellIndex] >>= FAPI_SFN_VALUE_SHIFT;
                SF_g[rxCellIndex] = (uint8_t)(MAC_PHY_CONVERT_16(sfnsf_p->sfnsf) & FAPI_SF_MASK);
                /* send tick to UE MAC on socket used internally */

                sfnsf_g[rxCellIndex] =  GENERATE_SUBFRAME_SFNSF(SFN_g[rxCellIndex], SF_g[rxCellIndex]);    
                macSubFrameInd();
            }
            break;

/*eMBMS Code Changes Start*/
#ifdef LTE_EMBMS_SUPPORTED            
        case ENB_UESIM_MBSFN_AREA_CREATE:
            {
                if ( l1RcvMsg_p->msgLen == 0 )
                {
                    fprintf(stderr,"Error..!!! msgLen = 0 recevied from MAC in MBSFN AREA CREATE\n");  
                }
                else
                {    
                    handleSIB13InfoFromLayer2(((UInt8*)&l1RcvMsg_p->msgBody[0]),l1RcvMsg_p->msgLen,rxCellIndex);
                }    
            }
            break;
        case ENB_UESIM_SIB13_INDICATION:
            {
                handleSIB13IndFromLayer2(rxCellIndex);
            }
            /* SPR 18147 Fix Start*/
            break;
            /* SPR 18147 Fix End*/
#endif
/*eMBMS Code Changes End*/
        default:  
            fprintf(stderr, " unsupported msgId = %d received\n", l1RcvMsg_p->msgId);
            break;
    }
#ifdef OVERSHOOT_CORRECTION
    UInt64 diffCycles =0;
    GET_CYCLES_DIFF(diffCycles);
    // if(diffCycles > ccInMs_g)
    //fprintf(stderr, "######## Msg Delayed Recv #######\n");
#endif

}

#ifdef LTE_EMBMS_SUPPORTED
/****************************************************************************
 * Function Name  : fapiHandleMchPdu 
 * Inputs         :   
 * Outputs        :  
 * Returns        :  
 * Description    : 
 ****************************************************************************/
//TA: NON_SS
void  fapiHandleMchConfigPdu(FAPI_mchConfigPDUInfo_st *mchPdu_p,
                            fapiMsgIdStruct *msgIdArr_p, UInt16 *pduIndex_p
							)
{
    if ( PNULL == mchPdu_p )
    {
        fprintf(stderr,"Error..!!! pchPdu recevied no data\n");
        return;
    }
    *pduIndex_p = MAC_PHY_CONVERT_16(mchPdu_p->pduIndex);
    msgIdArr_p[*pduIndex_p].mchPdu.mchPduLen = MAC_PHY_CONVERT_16(mchPdu_p->mchPduLen);
    if(msgIdArr_p[*pduIndex_p].mchPdu.mchPduLen == 0)
    {
        return;
    }
    msgIdArr_p[*pduIndex_p].mchPdu.mchrnti = MAC_PHY_CONVERT_16(mchPdu_p->rnti);
    if(msgIdArr_p[*pduIndex_p].mchPdu.mchrnti != FAPI_MCH_RNTI_VALUE)
    {
        ltePanic("Incorrect MCH RNTI received\n");
    }
    msgIdArr_p[*pduIndex_p].mchPdu.mchAreaId = MAC_PHY_CONVERT_16(mchPdu_p->mbsfnAreaId);
    msgIdArr_p[*pduIndex_p].mchPdu.rntiType = FAPI_MCH_RNTI;
    msgIdArr_p[*pduIndex_p].mchPduCount++;
}    
#endif
#if 0
/****************************************************************************
 * Function Name  :  fapiulReceiverThread 
 * Inputs         :  
 * Outputs        :  
 * Returns        :  
 * Description    : This function is the starting point of the ulReceiverThread. 
 *                  This Thread will be listenign on socket interface or MsgQ
 *                  and receive the data from the Peer MAC. 
 ****************************************************************************/
void fapiUlReceiver(void )
{
    sleep(1);
    UInt8 *recvDataBuffer_p = PNULL;
    SInt32 bytesRead                  = -1;
    fapiMsgIdStruct  msgIdArr[MAX_MSG_ID] = {{0}};

    socklen_t length = sizeof(struct sockaddr_in);
    UInt32 noOfBytes = 0;
    noOfBytes = sizeof(recvDataBuffer_g);

    /* OAM init is not happend */
    if ( stoppedProcessing_g )
        continue;

    /******************* If Socket Interface is Enabled ***************************/
    recvDataBuffer_p = recvDataBuffer_g;
    if ( ( bytesRead = recvfrom(sockfd_g, recvDataBuffer_p,
                    noOfBytes, 0,
                    (struct sockaddr*)&phyLayerAddr_g,&length)) <= 0)
    {
        if (errno != EAGAIN)
        {
            perror("recv from error in receiver thread");
            ltePanic ("lte panic due to recv from error\n" );
        }
        continue;
    }
    /* For Wireshark */
    if(wiresharEnable_g)
    {
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        //fprintf(stderr,"sending to wireshark\n");
#endif
        sendto(wiresharkfd_g,recvDataBuffer_p,bytesRead, 0,
                (struct sockaddr*)&wiresharkAddr_g, sizeof(SockAddr));
    }

    fapiReadMacMsg(recvDataBuffer_p,msgIdArr);

}
}
#endif



//TA NON_SS
//TA NON_SS
FAPI_ulDataPduIndication_st *addUlschPdu(
        void *DataInd_p,
        void *Pdu_p,
        ulschDataQueueNode *ulschDataNode_p,
        UInt32  dataOffset, UInt8 cellIndex)
{
    /* ULA_CHG */
    ueContextForUplink *ueContextInfo_p = NULL;
    /* ULA_CHG */
    /*CLPC_CHG*/
    SInt16 tempSnr;
    /*CLPC_CHG*/
    /*SPR 13791 changes start */
#ifdef FAPI_4_0_COMPLIANCE
//#if defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
    FAPI_rxULSCHIndicationR9_st *ulschDataInd_p=(FAPI_rxULSCHIndicationR9_st *)DataInd_p;
    FAPI_ulDataPduIndicationR9_st *pNextPdu=(FAPI_ulDataPduIndicationR9_st *)Pdu_p;
    pNextPdu->release9Param.timingAdvanceR9 =	MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].rel9TAUlsch
							[(rel9TaCntr++)%rel9TaValues_g[cellIndex].
							numTaUlSch]); ;

    /*SPR 13791 changes end */
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,"Timing Advance R9 in ULSCH INDICATION [%d]\n", pNextPdu->release9Param.timingAdvanceR9);
#endif
#else
    FAPI_rxULSCHIndication_st *ulschDataInd_p=(FAPI_rxULSCHIndication_st *)DataInd_p;
    FAPI_ulDataPduIndication_st *pNextPdu=(FAPI_ulDataPduIndication_st *)Pdu_p;

#endif

    pNextPdu->handle = 1;
    pNextPdu->rnti = MAC_PHY_CONVERT_16(ulschDataNode_p->rnti);
    pNextPdu->length = MAC_PHY_CONVERT_16(ulschDataNode_p->pduLen);

/* + SPR 11024 Fix */ 
    pNextPdu->timingAdvance = MAC_PHY_CONVERT_16(taValues_g[cellIndex].taUlsch[(taCntr++)%taValues_g[cellIndex].numTaUlSch]); /* TA_CHG */
/* - SPR 11024 Fix */ 

    /* ULA_CHG */
    ueContextInfo_p = getUEContext(MAC_PHY_CONVERT_16(pNextPdu->rnti), cellIndex);
    if(ueContextInfo_p != PNULL)
    {
#if 0
        pNextPdu->ulCqi = ulschSinrValues_g[ulschProfileInfo_g[ueProfileInfo_g[ueContextInfo_p->ueProfileId].ulschProfileId].sinrSeq[ueContextInfo_p->ulschSinrSeqUsedIdx]];
#endif
        /*CLPC_CHG*/
        if(CLPC_PUSCH_ENABLE)
        {
            tempSnr =
				ulschSinrValues_g[ulschProfileInfo_g[ueProfileInfo_g
				[cellIndex][ueContextInfo_p->ueProfileId].ulschProfileId].sinrSeq
                [ueContextInfo_p->ulschSinrSeqUsedIdx]] + 
                (TPC_TO_SINR_CORR_PUSCH_STEP * ueContextInfo_p->tpcPUSCH);

            if(tempSnr < 0)
            {
                pNextPdu->ulCqi = 0;
            }
            else if(tempSnr > 255)
            {
                pNextPdu->ulCqi = 255;
            }
            else
            {
                pNextPdu->ulCqi = tempSnr;
            }
        }
        else
        {
            pNextPdu->ulCqi = 
                ulschSinrValues_g[ulschProfileInfo_g[ueProfileInfo_g[cellIndex]
                [ueContextInfo_p->ueProfileId].ulschProfileId].
                sinrSeq[ueContextInfo_p->ulschSinrSeqUsedIdx]];
        }
        /*CLPC_CHG*/

        ueContextInfo_p->ulschSinrSeqUsedIdx =
            //++ueContextInfo_p->ulschSinrSeqUsedIdx % MAX_ULSCH_SINR_PROFILES;
            ++ueContextInfo_p->ulschSinrSeqUsedIdx % ulschProfileNum;
    }
    else
    {
        pNextPdu->ulCqi = 0;
        fprintf(stderr,"%s pNextPdu->ulCqi %d \n",__func__,pNextPdu->ulCqi);
    }
    /* ULA_CHG */
    /* SPR 2333 Changes Begins */   
    if ( ulschDataNode_p->pdudata_p && ulschDataNode_p->pduLen)
    {
        /* SPR 2333 Changes Ends */   
        memcpy(((UInt8 *)(ulschDataInd_p->ulDataPduInfo))+dataOffset,
                ulschDataNode_p->pdudata_p,ulschDataNode_p->pduLen);
#ifndef FAPI_UL_HARQ_ENABLE
        freeMemPool(ulschDataNode_p->pdudata_p);
        ulschDataNode_p->pdudata_p = PNULL;
#endif
    }
    
    if( TRUE == ulschDataNode_p->isCqiSet )
    {
        pNextPdu->ulCqi = 10;
        ulschDataNode_p->isCqiSet = FALSE;
    }
    /* SPR 5050 fix*/
    /* SPR 3531 START */
    #if 0
    else
    {
        /* NACK CASE so use NACK SINR */
        pNextPdu->ulCqi = SINR_DURING_ULSCH_NACK;
    }
    #endif
    /* SPR 5050 End */
    /* SPR 3531 END */
    freeMemPool(ulschDataNode_p);
    ulschDataNode_p = PNULL;
    /* SPR 609 changes start */
    return PNULL;
    /* SPR 609 changes end */
}

//TA NON_SS
#include <stddef.h>
//TA NON_SS
void sendUlData(UInt8 qIndex, UInt8 cellIndex)
{
    UInt8 ulschDataIndBuffer[20000];
    UInt16 queueCount = 0;
    UInt16 tempSfnSf = 0;
    UInt32  numPdu = 0;
    UInt32  pduCount = 0;
    UInt32  msgLen = 0;
    UInt32  totalLength = 0;
    /* SPR 2333 Changes */
    UInt8 ackNack = 0;
    ueContextForUplink *ueContextInfo_p = NULL;
    /* SPR 2333 Changes */
    FAPI_l1ApiMsg_st          *l1ApiMsg_p = PNULL;
    /*SPR 13791 changes start */
#ifdef FAPI_4_0_COMPLIANCE
    FAPI_rxULSCHIndicationR9_st  *ulschDataInd_p = PNULL;
    /*  UInt16 timingAdvanceR9=20;*/
    FAPI_ulDataPduIndicationR9_st *pNextPdu = PNULL;
    FAPI_VendorSpecificR9_st *vendorSpecificData_p = PNULL;
    FAPI_AOA_RecievedForUE_st *aoaRel9TAInfoForUE = PNULL;
#else
    FAPI_rxULSCHIndication_st  *ulschDataInd_p = PNULL;
    FAPI_ulDataPduIndication_st *pNextPdu = PNULL;
    FAPI_VendorSpecific_st *vendorSpecificData_p = PNULL;
    FAPI_AOA_REL9TARecievedForUE_st *aoaRel9TAInfoForUE = PNULL;
#endif
    /*SPR 13791 changes end */
    

    /* SPR 609 changes start */
    //FAPI_ulDataPduIndication_st *ulDataPdu_p = PNULL;
    /* SPR 609 changes end */
    ulschDataQueueNode *ulschDataNode_p= PNULL;
    /* + TM7_8 Changes Start */
    UInt8 index = 0;
    /* +- SPR 18268 */
    UInt16 numOfUes = 0;
    /* +- SPR 18268 */
    FAPI_AOA_REL9TARecievedForUE_st aoaRel9TAInfoForUEs[MAX_UE_SUPPORTED];
    /* - TM7_8 Changes End */

    queueCount = sQueueCount(&(ulDataQueue[cellIndex][qIndex]));
    if ( queueCount )
    {
        while ( queueCount-- )
        {
            numPdu++;
        }
    }
    queueCount = sQueueCount(&(onlyBsrPhrQueue[cellIndex][qIndex]));
    if ( queueCount )
    {
        while ( queueCount-- )
        {
            numPdu++;
        }
    }
    /* send ULSCH DATA */
    l1ApiMsg_p = ( FAPI_l1ApiMsg_st *)ulschDataIndBuffer;
    l1ApiMsg_p->msgId = PHY_UL_RX_ULSCH_INDICATION;
    l1ApiMsg_p->lenVendorSpecific = 0;
    /* + TM7_8 Changes Start */
        /* + TM7_8 Changes Start */
    /*SPR 13791 changes start */
#ifdef FAPI_4_0_COMPLIANCE
    msgLen += 
        offsetof(FAPI_rxULSCHIndicationR9_st, ulDataPduInfo) +
        (numPdu * sizeof(FAPI_ulDataPduIndicationR9_st));
#else

    msgLen += 
        offsetof(FAPI_rxULSCHIndication_st, ulDataPduInfo) +
        (numPdu * sizeof(FAPI_ulDataPduIndication_st));
#endif
    /*SPR 13791 changes end */
    /* - TM7_8 Changes End */
    /*SPR 13791 changes start */
#ifdef FAPI_4_0_COMPLIANCE
    /*SPR 13791 changes end */
    ulschDataInd_p = (FAPI_rxULSCHIndicationR9_st *) &(l1ApiMsg_p->msgBody[0]);
#else
    ulschDataInd_p = (FAPI_rxULSCHIndication_st *) &(l1ApiMsg_p->msgBody[0]);
#endif

    ulschDataInd_p->numOfPdu = MAC_PHY_CONVERT_16(numPdu);
    ulschDataInd_p->sfnsf = sfnsf_g[cellIndex];


    queueCount = sQueueCount(&(ulDataQueue[cellIndex][qIndex]));
    if ( queueCount )
    {
        while ( queueCount-- )
        {
            ulschDataNode_p = ( ulschDataQueueNode *) 
                popNode(&(ulDataQueue[cellIndex][qIndex]));
            if ( PNULL == ulschDataNode_p )
            {
                continue;
            }
            /* SPR 2333 Changes Begin */
            ueContextInfo_p = getUEContext(ulschDataNode_p->rnti, cellIndex);
            if(ueContextInfo_p)
            {
                /* + TM7_8 Changes Start */
                numOfUes++;
                aoaRel9TAInfoForUEs[numOfUes - 1].rnti = ulschDataNode_p->rnti; 
                for(index = 0;index < MAX_NUM_ANTENNA ;index++)
                { 
                    if(angleOfArrivalValuesIndex_g[cellIndex] == MAX_SF_VALUE)
                    {
                        angleOfArrivalValuesIndex_g[cellIndex] = 0;
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[index] = 
                            angleOfArrivalValues_g[cellIndex][index]\
							[angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                    else
                    {
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[index] = \
                            angleOfArrivalValues_g[cellIndex][index]\
							[angleOfArrivalValuesIndex_g[cellIndex]];
                    }
				}
				angleOfArrivalValuesIndex_g[cellIndex]++;
				aoaRel9TAInfoForUEs[numOfUes-1].timingAdvanceR9 =
					MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].rel9TAUlsch
							[(rel9TaCntr++)%rel9TaValues_g[cellIndex].
							numTaUlSch]); 
                /* - TM7_8 Changes End */
#ifdef FDD_CONFIG
                ackNack= ueContextInfo_p->ulharqInfo[qIndex].ackNack;
#else
                /* For tdd crc ind will be ack until fix is done for nack */
                ackNack = 0;
#endif
            
    /*SPR 13791 changes start */
#ifdef FAPI_4_0_COMPLIANCE
    /*SPR 13791 changes end */
                pNextPdu = ( FAPI_ulDataPduIndicationR9_st *) 
                    &(ulschDataInd_p->ulDataPduInfo[pduCount]);
                pNextPdu->dataOffset = MAC_PHY_CONVERT_16(numPdu * sizeof(FAPI_ulDataPduIndicationR9_st)
                        + totalLength);
                pNextPdu->release9Param.timingAdvanceR9= MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].
							rel9TAUlsch[(rel9TaCntr++)%rel9TaValues_g
							[cellIndex].numTaUlSch]);

#else

                pNextPdu = ( FAPI_ulDataPduIndication_st *) 
                    &(ulschDataInd_p->ulDataPduInfo[pduCount]);

                pNextPdu->dataOffset = MAC_PHY_CONVERT_16(numPdu * sizeof(FAPI_ulDataPduIndication_st)
                        + totalLength);


#endif
                if(ackNack == 0)
                {
                    totalLength += ulschDataNode_p->pduLen;
                    /* Multi pdu incorrect len fix */
                    //msgLen += totalLength;
                    msgLen += ulschDataNode_p->pduLen;
                    /* Multi pdu incorrect len fix */

                }
                else
                {
                    pNextPdu->dataOffset = 0;
                    ulschDataNode_p->pduLen = 0;
                }
                ueContextInfo_p->ulschIndRefNode_p[qIndex] = PNULL;
            }
            else
            {
    /*SPR 13791 changes start */
#ifdef FAPI_4_0_COMPLIANCE
    /*SPR 13791 changes end */
                pNextPdu = ( FAPI_ulDataPduIndicationR9_st *)
                    &(ulschDataInd_p->ulDataPduInfo[pduCount]);
                pNextPdu->dataOffset = MAC_PHY_CONVERT_16(numPdu * sizeof(FAPI_ulDataPduIndicationR9_st)
                        + totalLength );
                pNextPdu->release9Param.timingAdvanceR9=
                    MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].
							rel9TAUlsch[(rel9TaCntr++)%rel9TaValues_g
							[cellIndex].numTaUlSch]);

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"Timing Advance R9 in ULSCH INDICATION [%d]\n",pNextPdu->release9Param.timingAdvanceR9);
#endif
#else

                pNextPdu = ( FAPI_ulDataPduIndication_st *)
                    &(ulschDataInd_p->ulDataPduInfo[pduCount]);
                pNextPdu->dataOffset = MAC_PHY_CONVERT_16(numPdu * sizeof(FAPI_ulDataPduIndication_st)
                        + totalLength);
#endif
                totalLength += ulschDataNode_p->pduLen;
                /* Multi pdu incorrect len fix */
                //msgLen += totalLength;
                msgLen += ulschDataNode_p->pduLen;
                /* Multi pdu incorrect len fix */

                /* + E_CID_5.3 */
                numOfUes++;
                aoaRel9TAInfoForUEs[numOfUes - 1].rnti = ulschDataNode_p->rnti; 
                for (index = 0;index < MAX_NUM_ANTENNA ;index++)
                { 
                    if (angleOfArrivalValuesIndex_g[cellIndex] == MAX_SF_VALUE)
                    {
                        angleOfArrivalValuesIndex_g[cellIndex] = 0;
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[index] = \
                            angleOfArrivalValues_g[cellIndex][index]\
                            [angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                    else
                    {
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[index] = \
                            angleOfArrivalValues_g[cellIndex][index]\
                            [angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                }
				angleOfArrivalValuesIndex_g[cellIndex]++;
				aoaRel9TAInfoForUEs[numOfUes-1].timingAdvanceR9 =
					MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].
							rel9TAUlsch[(rel9TaCntr++)%rel9TaValues_g
							[cellIndex].numTaUlSch]);
               /* - E_CID_5.3 */

            }
            /* SPR 2333 Changes Ends */
            /* BMJ SFNSF Mismactch Fix*/
            tempSfnSf = ulschDataNode_p->sendSfnSf;
            addUlschPdu(ulschDataInd_p, pNextPdu, ulschDataNode_p,
                    MAC_PHY_CONVERT_16(pNextPdu->dataOffset), cellIndex);
            pduCount ++;


        }
    }
    /* send BSR DATA */
    queueCount = sQueueCount(&(onlyBsrPhrQueue[cellIndex][qIndex]));
    if ( queueCount )
    {
        while ( queueCount-- )
        {
            ulschDataNode_p = ( ulschDataQueueNode *) 
                popNode(&(onlyBsrPhrQueue[cellIndex][qIndex]));
            if ( PNULL == ulschDataNode_p )
            {
                fprintf(stderr,"Error..!! in BSR ulschDataNode_p poped is NULL\n");
                continue;
            }
            if ( ulschDataNode_p->pdudata_p )
            {
                //fprintf(stderr, "adding bsr %d ", ulschDataNode_p->pduLen);
    /*SPR 13791 changes start */
#ifdef FAPI_4_0_COMPLIANCE
    /*SPR 13791 changes end */
                pNextPdu = ( FAPI_ulDataPduIndicationR9_st *) 
                    &(ulschDataInd_p->ulDataPduInfo[pduCount]);
                pNextPdu->dataOffset = MAC_PHY_CONVERT_16(numPdu * sizeof(FAPI_ulDataPduIndicationR9_st)
                        + totalLength);
#else
                pNextPdu = ( FAPI_ulDataPduIndication_st *) 
                    &(ulschDataInd_p->ulDataPduInfo[pduCount]);
                pNextPdu->dataOffset = MAC_PHY_CONVERT_16(numPdu * sizeof(FAPI_ulDataPduIndication_st)
                        + totalLength);
#endif
                totalLength += ulschDataNode_p->pduLen;
                /* Multi pdu incorrect len fix */
                //msgLen += totalLength;
                msgLen += ulschDataNode_p->pduLen;
                /* Multi pdu incorrect len fix */
                tempSfnSf = ulschDataNode_p->sendSfnSf;
                /* + E_CID_5.3 */
                numOfUes++;
                aoaRel9TAInfoForUEs[numOfUes - 1].rnti = MAC_PHY_CONVERT_16(ulschDataNode_p->rnti); 
                for(index = 0;index < MAX_NUM_ANTENNA ;index++)
                { 
                    if (angleOfArrivalValuesIndex_g[cellIndex] == MAX_SF_VALUE)
                    {
                        angleOfArrivalValuesIndex_g[cellIndex] = 0;
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[index] = \ 
                            angleOfArrivalValues_g[cellIndex][index]\
                            [angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                    else
                    {
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[index] = \ 
                            angleOfArrivalValues_g[cellIndex][index]\
                            [angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                }
                angleOfArrivalValuesIndex_g[cellIndex]++;
				aoaRel9TAInfoForUEs[numOfUes-1].timingAdvanceR9 =
					MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].rel9TAUlsch
							[(rel9TaCntr++)%rel9TaValues_g[cellIndex].
							numTaUlSch]);
                /* - E_CID_5.3 */
                addUlschPdu(ulschDataInd_p, pNextPdu, ulschDataNode_p,
                        MAC_PHY_CONVERT_16(pNextPdu->dataOffset), cellIndex);
                /*freeMemPool(ulschDataNode_p->pdudata_p);
                  ulschDataNode_p->pdudata_p = PNULL;
                  freeMemPool(ulschDataNode_p);
                  ulschDataNode_p = PNULL;*/
                pduCount ++;
            }
            else
            {
                fprintf(stderr,"Error...!! in BSR ulschDataNode_p->pdudata_p = \
                        PNULL in popped Node\n"); 
            }       

        }
    }

    if (numPdu > 0)
    {
#if 0    
        fprintf(stderr, "======sending total length = %d sfn = %d sf = %d sfnsf[%d]\n", msgLen, SFN_g, SF_g[cellIndex], tempSfnSf);
#endif        
        /* +- SPR 18467 */
        /* Padding length added */
        msgLen += (msgLen%4)?(4 - msgLen%4):0;
        /* +- SPR 18467 */
        l1ApiMsg_p->msgLen = MAC_PHY_CONVERT_16(msgLen);
        ulschDataInd_p->sfnsf = MAC_PHY_CONVERT_16(tempSfnSf);
        /* + TM7_8 Changes Start */
        UInt8 totalLen = 0;
        /* + E_CID_5.3 */
        if(numOfUes)
        {
            /* - E_CID_5.3 */
    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
            vendorSpecificData_p = (FAPI_VendorSpecificR9_st *) (&l1ApiMsg_p->msgBody[0] + l1ApiMsg_p->msgLen);
            l1ApiMsg_p->lenVendorSpecific = MAC_PHY_CONVERT_16((sizeof(FAPI_AOA_RecievedForUE_st) * numOfUes )+ 4);
#else
            vendorSpecificData_p = (FAPI_VendorSpecific_st *) (&l1ApiMsg_p->msgBody[0] + l1ApiMsg_p->msgLen);
            l1ApiMsg_p->lenVendorSpecific = MAC_PHY_CONVERT_16((sizeof(FAPI_AOA_REL9TARecievedForUE_st) * numOfUes )+ 4);
#endif
            vendorSpecificData_p->ueMeasInfoForUEs.numOfUEs = MAC_PHY_CONVERT_16(numOfUes);
            for(index = 0;index < numOfUes ; index++)
            {

    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
                totalLen += (sizeof(FAPI_AOA_RecievedForUE_st));
#else
                totalLen += (sizeof(FAPI_AOA_REL9TARecievedForUE_st));
#endif

                if (totalLen >= 252)
                {
                    l1ApiMsg_p->lenVendorSpecific =  MAC_PHY_CONVERT_16(244);
                    vendorSpecificData_p->ueMeasInfoForUEs.numOfUEs = MAC_PHY_CONVERT_16(20);
                    break;                     
                }     
    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
                aoaRel9TAInfoForUE = &vendorSpecificData_p->ueMeasInfoForUEs.aoaRel9Info[index];
#else
                aoaRel9TAInfoForUE = &vendorSpecificData_p->ueMeasInfoForUEs.aoaRel9TAInfo[index];
#endif
                aoaRel9TAInfoForUE->rnti = aoaRel9TAInfoForUEs[index].rnti;
                aoaRel9TAInfoForUE->AoA[0] = aoaRel9TAInfoForUEs[index].AoA[0];
                aoaRel9TAInfoForUE->AoA[1] = aoaRel9TAInfoForUEs[index].AoA[1];
                aoaRel9TAInfoForUE->AoA[2] = aoaRel9TAInfoForUEs[index].AoA[2];
                aoaRel9TAInfoForUE->AoA[3] = aoaRel9TAInfoForUEs[index].AoA[3];
    /*SPR 13791 changes start */
#if (!defined(FAPI_4_0_COMPLIANCE))
    /*SPR 13791 changes end */
                aoaRel9TAInfoForUE->timingAdvanceR9 = aoaRel9TAInfoForUEs[index].timingAdvanceR9; 
#endif
            }

            sendDatatoPeerMac((UInt8 *)l1ApiMsg_p, 
					offsetof(FAPI_l1ApiMsg_st, msgBody) + l1ApiMsg_p->msgLen +\
					l1ApiMsg_p->lenVendorSpecific, cellIndex);
		}
		else
		{
			/* SPR 609 changes start */
			sendDatatoPeerMac((UInt8 *)l1ApiMsg_p, 
					offsetof(FAPI_l1ApiMsg_st, msgBody) +\
					msgLen, cellIndex);
			/* SPR 609 changes end */
        }
        /* - E_CID_5.3 */
    }
}
/* Phase 2 Periodic CQi Changes Start*/


/****************************************************************************
 * Function Name  : updateCqiPeriodicReportType
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    : This Function will update cellId for
 *                  which cqi reporty has to be sent and will update cqi Report
 *                  type
 ****************************************************************************/

void updateCqiPeriodicReportType(UInt8 *cqiReportType, UInt8 *cellId, 
        UInt16 ueIndex, UInt8 cellIndex, UInt32 sendSFN, 
        UInt8 sendSF, UInt16 crnti )
{
    UInt8 scellCount = 0;
    UInt32 scellCqiReportMode[MAX_NUM_SCELL]= {0};
    UInt8 updatedCqiReportType = *cqiReportType;
    UInt8 updatedCellIndex = *cellId;
    /* SPR 11754 Fix Start */
    ueContextForUplink *ueContext_p = PNULL;
    /* SPR 11754 Fix End */
    UInt32 cqiPeriodicReportType = 
        (cqiPmiRiReportMap_g[sendSFN].reportType[sendSF][ueIndex]);

    if (PNULL == (ueContext_p = getUEContext(MAC_PHY_CONVERT_16(crnti), cellIndex)))
    {
        fprintf (stderr, "CQI Node has to be pushed in Queue for UE having"
                "crnti =%d but Context Doesnot exist for this UE\n",MAC_PHY_CONVERT_16(crnti));
        return;

    }

    for (scellCount = 0 ; scellCount < ueContext_p->carrierAggrConfig.\
            scellCount; scellCount++)
    {
        scellCqiReportMode[scellCount] = cqiPmiRiScellReportMap_g[scellCount][sendSFN].reportType[sendSF][ueIndex];
    /* SPR 11756 Fix Start */
        if (0 == scellCqiReportMode[scellCount])
        {
            *cqiReportType = cqiPeriodicReportType;
            *cellId = cellIndex;
             return;
        }

    /* SPR 11756 Fix End */
    }
/* SPR 12465 Fix start*/
    if (!cqiPeriodicReportType)
    {
        *cqiReportType = scellCqiReportMode[0];
        *cellId = ueContext_p->carrierAggrConfig.scellInfo[0].sCellIndex;
             return;

    } 
/* SPR 12465 Fix end */


    switch(cqiPeriodicReportType)
    {

        case RI_TYPE_3:
            {
                for (scellCount = 0 ; scellCount < ueContext_p->carrierAggrConfig.\
                        scellCount; scellCount++)
                {
                    if (RI_TYPE_3 == scellCqiReportMode[scellCount])
                    {
                        updatedCqiReportType = cqiPeriodicReportType;
                        if ( cellIndex <= scellCount)
                            updatedCellIndex = cellIndex;
                        else
                                updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                            //updatedCellIndex = scellCount;
                    }
                    else
                    {
                        updatedCqiReportType = cqiPeriodicReportType;
                        updatedCellIndex = cellIndex;
                    }

                }
            }
            break;

        case WIDE_BAND_CQI_PMI_TYPE_2:
        case WIDE_BAND_CQI_TYPE_4:
            {
                for (scellCount = 0 ; scellCount < ueContext_p->carrierAggrConfig.\
                        scellCount; scellCount++)
                {
                    if (WIDE_BAND_CQI_PMI_TYPE_2 == scellCqiReportMode[scellCount] || \
                            WIDE_BAND_CQI_TYPE_4 == scellCqiReportMode[scellCount] )
                    {
                        updatedCqiReportType = cqiPeriodicReportType;
                        if ( cellIndex <= scellCount)
                            updatedCellIndex = cellIndex;
                        else
                             updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                            //updatedCellIndex = scellCount;
                    }
                    else if ( SUB_BAND_TYPE_1 == scellCqiReportMode[scellCount])
                    {
                        updatedCqiReportType = cqiPeriodicReportType;
                        updatedCellIndex = cellIndex;
                    }
                    else
                    {   
                        updatedCqiReportType = scellCqiReportMode[scellCount];
                        updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                        //updatedCellIndex = scellCount;

                    }


                }
            }
            break;
        case SUB_BAND_TYPE_1:
            {
                for (scellCount = 0 ; scellCount < ueContext_p->carrierAggrConfig.\
                        scellCount; scellCount++)
                {
                    if ( SUB_BAND_TYPE_1 == scellCqiReportMode[scellCount])
                    {

                        updatedCqiReportType = cqiPeriodicReportType;
                        if ( cellIndex <= scellCount)
                            updatedCellIndex = cellIndex;
                        else
                                updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                            //updatedCellIndex = scellCount;
                    }
                    else
                    {
                        updatedCqiReportType = scellCqiReportMode[scellCount];
                                updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                        //updatedCellIndex = scellCount;

                    }
                    /*
                       else if ( WIDE_BAND_CQI_PMI_TYPE_2 = scellCqiReportMode[scellCount] || \
                       WIDE_BAND_CQI_TYPE_4 == scellCqiReportMode[scellCount])
                       {
                       updatedCqiReportType = scellCqiReportMode[scellCount];
                       updatedCellIndex = scellCount;
                       }
                       else if ( RI_TYPE_3 == scellCqiReportMode[scellCount])
                       {
                       updatedCqiReportType = scellCqiReportMode[scellCount];
                       updatedCellIndex = scellCount;

                       }
                       */


                }
            }
            break;

        default:
            updatedCqiReportType = PERIODIC_MODE_INVALID;
            updatedCellIndex = cellIndex;
            break;
    }

       
    *cqiReportType = updatedCqiReportType;
    *cellId = updatedCellIndex;

}
/* Phase 2 Periodic CQi Changes End*/


/*EICIC +*/
/****************************************************************************
 * Function Name  :  updateCqiPeriodicReportType_ABS
 * Inputs         :  cqiReportType
 *                   cellId
 *                   ueIndex
 *                   cellIndex
 *                   sendSFN
 *                   sendSF
 *                   crnti
 * Outputs        :  None
 * Returns        :  None
 * Description    :  This Function will update cellId for
 *                   which cqi reporty has to be sent and will update cqi Report
 *                   type
 ****************************************************************************/

void updateCqiPeriodicReportType_ABS(UInt8 *cqiReportType, UInt8 *cellId, 
        UInt16 ueIndex, UInt8 cellIndex, UInt32 sendSFN, 
        UInt8 sendSF, UInt16 crnti )
{
    UInt8 scellCount = 0;
    UInt32 scellCqiReportMode[MAX_NUM_SCELL]= {0};
    UInt8 updatedCqiReportType = *cqiReportType;
    UInt8 updatedCellIndex = *cellId;
    /* SPR 11754 Fix Start */
    ueContextForUplink *ueContext_p = PNULL;
    /* SPR 11754 Fix End */
    UInt32 cqiPeriodicReportType = 
        (cqiPmiRiReportMap2_g[sendSFN].reportType[sendSF][ueIndex]);
    if (PNULL == (ueContext_p = getUEContext(MAC_PHY_CONVERT_16(crnti), cellIndex)))
    {
        fprintf (stderr, "CQI Node has to be pushed in Queue for UE having"
                "crnti =%d but Context Doesnot exist for this UE\n",MAC_PHY_CONVERT_16(crnti));
        return;

    }

    for (scellCount = 0 ; scellCount < ueContext_p->carrierAggrConfig.\
            scellCount; scellCount++)
    {
        scellCqiReportMode[scellCount] = cqiPmiRiScellReportMap2_g[scellCount][sendSFN].reportType[sendSF][ueIndex];
    /* SPR 11756 Fix Start */
        if (0 == scellCqiReportMode[scellCount])
        {
            *cqiReportType = cqiPeriodicReportType;
            *cellId = cellIndex;
             return;
        }

    /* SPR 11756 Fix End */
    }
/* SPR 12465 Fix start*/
    if (!cqiPeriodicReportType)
    {
        *cqiReportType = scellCqiReportMode[0];
        *cellId = ueContext_p->carrierAggrConfig.scellInfo[0].sCellIndex;
             return;

    } 
/* SPR 12465 Fix end */


    switch(cqiPeriodicReportType)
    {

        case RI_TYPE_3:
            {
                for (scellCount = 0 ; scellCount < ueContext_p->carrierAggrConfig.\
                        scellCount; scellCount++)
                {
                    if (RI_TYPE_3 == scellCqiReportMode[scellCount])
                    {
                        updatedCqiReportType = cqiPeriodicReportType;
                        if ( cellIndex <= scellCount)
                            updatedCellIndex = cellIndex;
                        else
                                updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                            //updatedCellIndex = scellCount;
                    }
                    else
                    {
                        updatedCqiReportType = cqiPeriodicReportType;
                        updatedCellIndex = cellIndex;
                    }

                }
            }
            break;

        case WIDE_BAND_CQI_PMI_TYPE_2:
        case WIDE_BAND_CQI_TYPE_4:
            {
                for (scellCount = 0 ; scellCount < ueContext_p->carrierAggrConfig.\
                        scellCount; scellCount++)
                {
                    if (WIDE_BAND_CQI_PMI_TYPE_2 == scellCqiReportMode[scellCount] || \
                            WIDE_BAND_CQI_TYPE_4 == scellCqiReportMode[scellCount] )
                    {
                        updatedCqiReportType = cqiPeriodicReportType;
                        if ( cellIndex <= scellCount)
                            updatedCellIndex = cellIndex;
                        else
                             updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                            //updatedCellIndex = scellCount;
                    }
                    else if ( SUB_BAND_TYPE_1 == scellCqiReportMode[scellCount])
                    {
                        updatedCqiReportType = cqiPeriodicReportType;
                        updatedCellIndex = cellIndex;
                    }
                    else
                    {   
                        updatedCqiReportType = scellCqiReportMode[scellCount];
                        updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                        //updatedCellIndex = scellCount;

                    }


                }
            }
            break;
        case SUB_BAND_TYPE_1:
            {
                for (scellCount = 0 ; scellCount < ueContext_p->carrierAggrConfig.\
                        scellCount; scellCount++)
                {
                    if ( SUB_BAND_TYPE_1 == scellCqiReportMode[scellCount])
                    {

                        updatedCqiReportType = cqiPeriodicReportType;
                        if ( cellIndex <= scellCount)
                            updatedCellIndex = cellIndex;
                        else
                                updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                            //updatedCellIndex = scellCount;
                    }
                    else
                    {
                        updatedCqiReportType = scellCqiReportMode[scellCount];
                                updatedCellIndex = ueContext_p->carrierAggrConfig.scellInfo[scellCount].sCellIndex;
                        //updatedCellIndex = scellCount;

                    }
                    /*
                       else if ( WIDE_BAND_CQI_PMI_TYPE_2 = scellCqiReportMode[scellCount] || \
                       WIDE_BAND_CQI_TYPE_4 == scellCqiReportMode[scellCount])
                       {
                       updatedCqiReportType = scellCqiReportMode[scellCount];
                       updatedCellIndex = scellCount;
                       }
                       else if ( RI_TYPE_3 == scellCqiReportMode[scellCount])
                       {
                       updatedCqiReportType = scellCqiReportMode[scellCount];
                       updatedCellIndex = scellCount;

                       }
                       */


                }
            }
            break;

        default:
            updatedCqiReportType = PERIODIC_MODE_INVALID;
            updatedCellIndex = cellIndex;
            break;
    }
  
    *cqiReportType = updatedCqiReportType;
    *cellId = updatedCellIndex;
}

/****************************************************************************
 * Function Name  : prepareAperiodicCqiReport_ABS
 * Inputs         : dlCQIInfo
 *                  cqiReport_p
 *                  cqiCount
 *                  count
 *                  cellIndex
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepare Cqi Report for ABS configuration
 ****************************************************************************/

void prepareAperiodicCqiReport_ABS(DLCQIInfo *dlCQIInfo,
        UInt8 *cqiReport_p,
        UInt8 *cqiCount,
        UInt8 count,
        UInt8 cellIndex)
{
    UInt8 cqi_count = 0;
    cqi_count = *cqiCount;
    switch(dlCQIInfo->aperiodicModeType)
    {    
        case CQI_APERIODIC_TYPE_12:
            {
                if(1 ==  dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode12Abs_p[count].wideBandCQICW0_RI_1);
                    cqi_count = 
                        fillPMIForNSubBands_RI_1(cqiReport_p,
                                cqi_count,count,
                                dlCQIInfo, cellIndex);
                }
                else if(1 < dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode12Abs_p[count].wideBandCQICW0_RI_2));
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode12Abs_p[count].wideBandCQICW1_RI_2)) << 4));
                    cqi_count++;
                    cqi_count = 
                        fillPMIForNSubBands_RI_2(
                                cqiReport_p,cqi_count,count,
                                dlCQIInfo, cellIndex);
                }
                else
                {
                    fprintf(stderr,"INVALID RI\n");
                } 
            }
            break;
        case CQI_APERIODIC_TYPE_20:
            {
                cqiReport_p[cqi_count] = 
                    (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode20Abs_p[count].wideBandCQICW));
                cqiReport_p[cqi_count] = 
                    (cqiReport_p[cqi_count] | 
                     ((TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode20Abs_p[count].subBandDiffCQI)) << 4));
                cqi_count = 
                    fillPosOfMSelSubband(cqiReport_p,cqi_count,count,dlCQIInfo);
            }   
            break; 
        case CQI_APERIODIC_TYPE_22:
            {
                if(1 == dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22Abs_p[count].wideBandCQICW0_RI_1));
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22Abs_p[count].subBandDiffCQICW0_RI_1)) << 4));
                    cqi_count = 
                        fillPosOfMSelSubbandAndPMI_RI_1(
                                cqiReport_p,cqi_count,count
                                ,dlCQIInfo, cellIndex);
                }
                else if(1 < dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22Abs_p[count].wideBandCQICW0_RI_2));
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22Abs_p[count].subBandDiffCQICW0_RI_2)) << 4));
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22Abs_p[count].wideBandCQICW1_RI_2)) & 0x03) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22Abs_p[count].wideBandCQICW1_RI_2)) & 0x0C) >> 2);
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22Abs_p[count].subBandDiffCQICW1_RI_2)) << 2));
                    cqi_count = 
                        fillPosOfMSelSubbandAndPMI_RI_2(cqiReport_p,
                                cqi_count,count,
                                dlCQIInfo, cellIndex);
                }
                else
                {
                    fprintf(stderr,"INVALID RI\n");
                } 

            }   
            break;
        case CQI_APERIODIC_TYPE_30:
            {
                cqiReport_p[cqi_count] = 
                    (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode30Abs_p[count].wideBandCQICW));
                cqi_count = 
                    fillSubBandDiffCQIForNSubBands(cqiReport_p,cqi_count,count,dlCQIInfo);
            }   
            break;
        case CQI_APERIODIC_TYPE_31:
            {
                if(1 == dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode31Abs_p[count].wideBandCQICW0_RI_1));
                    cqi_count = 
                        fillSubBandDiffCQIForNSubBandsAndPMI_RI_1(
                                cqiReport_p,cqi_count,count,
                                dlCQIInfo, cellIndex);
                }
                else if(1 < dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode31Abs_p[count].wideBandCQICW0_RI_2));
                    cqi_count = 
                        fillSubBandDiffCQIForNSubBandsAndWB_RI_2(cqiReport_p,cqi_count,count,dlCQIInfo);
                    cqi_count = 
                        fillSubBandDiffCQIForNSubBandsAndPMI_RI_2(
                                cqiReport_p,cqi_count,count
                                ,dlCQIInfo, cellIndex);
                }
                else
                {
                    fprintf(stderr,"INVALID RI\n");
                } 
            }   
            break;
        default:
            {
                fprintf(stderr,"INVALID aperiodicModeType_g = %d\n",dlCQIInfo->aperiodicModeType);
            }
    }
    *cqiCount = cqi_count;
}

/*EICIC -*/
 /*  Aperiodic CQI Changes start*/
/****************************************************************************
 * Function Name  : prepareAperiodicCqiReport
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    : This function prepare Cqi Report 
 ****************************************************************************/

void prepareAperiodicCqiReport(DLCQIInfo *dlCQIInfo,
        UInt8 *cqiReport_p,
        UInt8 *cqiCount,
        UInt8 count,
        UInt8 cellIndex)
{
    UInt8 cqi_count = 0;
    cqi_count = *cqiCount;
    switch(dlCQIInfo->aperiodicModeType)
    {    
        case CQI_APERIODIC_TYPE_12:
            {
                if(1 ==  dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode12_p[count].wideBandCQICW0_RI_1);
                    cqi_count = 
                        fillPMIForNSubBands_RI_1(cqiReport_p,
                                cqi_count,count,
                                dlCQIInfo, cellIndex);
                }
                else if(1 < dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode12_p[count].wideBandCQICW0_RI_2));
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode12_p[count].wideBandCQICW1_RI_2)) << 4));
                    cqi_count++;
                    cqi_count = 
                        fillPMIForNSubBands_RI_2(
                                cqiReport_p,cqi_count,count,
                                dlCQIInfo, cellIndex);
                }
                else
                {
                    fprintf(stderr,"INVALID RI\n");
                } 
            }
            break;
        case CQI_APERIODIC_TYPE_20:
            {
                cqiReport_p[cqi_count] = 
                    (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode20_p[count].wideBandCQICW));
                cqiReport_p[cqi_count] = 
                    (cqiReport_p[cqi_count] | 
                     ((TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode20_p[count].subBandDiffCQI)) << 4));
                cqi_count = 
                    fillPosOfMSelSubband(cqiReport_p,cqi_count,count,dlCQIInfo);
            }   
            break; 
        case CQI_APERIODIC_TYPE_22:
            {
                if(1 == dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].wideBandCQICW0_RI_1));
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].subBandDiffCQICW0_RI_1)) << 4));
                    cqi_count = 
                        fillPosOfMSelSubbandAndPMI_RI_1(
                                cqiReport_p,cqi_count,count
                                ,dlCQIInfo, cellIndex);
                }
                else if(1 < dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].wideBandCQICW0_RI_2));
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].subBandDiffCQICW0_RI_2)) << 4));
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].wideBandCQICW1_RI_2)) & 0x03) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].wideBandCQICW1_RI_2)) & 0x0C) >> 2);
                    cqiReport_p[cqi_count] = 
                        (cqiReport_p[cqi_count] | 
                         ((TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].subBandDiffCQICW1_RI_2)) << 2));
                    cqi_count = 
                        fillPosOfMSelSubbandAndPMI_RI_2(cqiReport_p,
                                cqi_count,count,
                                dlCQIInfo, cellIndex);
                }
                else
                {
                    fprintf(stderr,"INVALID RI\n");
                } 

            }   
            break;
        case CQI_APERIODIC_TYPE_30:
            {
                cqiReport_p[cqi_count] = 
                    (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode30_p[count].wideBandCQICW));
                cqi_count = 
                    fillSubBandDiffCQIForNSubBands(cqiReport_p,cqi_count,count,dlCQIInfo);
            }   
            break;
        case CQI_APERIODIC_TYPE_31:
            {
                if(1 == dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode31_p[count].wideBandCQICW0_RI_1));
                    cqi_count = 
                        fillSubBandDiffCQIForNSubBandsAndPMI_RI_1(
                                cqiReport_p,cqi_count,count,
                                dlCQIInfo, cellIndex);
                }
                else if(1 < dlCQIInfo->RI)
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode31_p[count].wideBandCQICW0_RI_2));
                    cqi_count = 
                        fillSubBandDiffCQIForNSubBandsAndWB_RI_2(cqiReport_p,cqi_count,count,dlCQIInfo);
                    cqi_count = 
                        fillSubBandDiffCQIForNSubBandsAndPMI_RI_2(
                                cqiReport_p,cqi_count,count
                                ,dlCQIInfo, cellIndex);
                }
                else
                {
                    fprintf(stderr,"INVALID RI\n");
                } 
            }   
            break;
        default:
            {
                fprintf(stderr,"INVALID aperiodicModeType_g = %d\n",dlCQIInfo->aperiodicModeType);
            }
    }
    *cqiCount = cqi_count;
}
 /*  Aperiodic CQI Changes End*/

/****************************************************************************
 * Function Name  : ueSimSendAndUpdateSFI
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    : This function updates the SFI and sends it to eNB 
 ****************************************************************************/
void ueSimSendAndUpdateSFI(UInt8 cellIndex)
{

   /* SPR 22578 fix start*/
  if (cellStopTriggered[cellIndex] == TRUE)
   {
       sfnsf_g[cellIndex] = 0;
       SFN_g[cellIndex]   = 0;
       SF_g[cellIndex]    = 0;
   }
   /* SPR 22578 fix end*/

#ifdef UESIM_MULTI_THREAD_CELL
    UInt8 activeCell = 0;
    /* + SPR_11557_11143 */
    eventFD_t tempfd = 0;
    /* - SPR_11557_11143 */
    /* + SPR_11100 */
    activeCell = getActiveCell();
    /* + SPR_11557_11143 */
    if (cellIndex != activeCell)
    {
        eventfd_read_wrapper(ev_fd_SFI_g,&tempfd);
        if (FAPI_RUNNING == phyState_g[activeCell])
        {
            if ( (SF_g[cellIndex] == SF_g[activeCell]) 
                    && (SFN_g[cellIndex] ==  SFN_g[activeCell]))
            {
                fprintf(stderr, " This print should come at most once  sfn[%d],sf[%d] && c1: sfn[%d], sf[%d]\n",
                        SFN_g[activeCell], SF_g[activeCell], SFN_g[cellIndex], SF_g[cellIndex]);
            }

            SF_g[cellIndex] = SF_g[activeCell];
            SFN_g[cellIndex] =  SFN_g[activeCell];
            /* - SPR_11100 */
        }
        else
        {
            SF_g[cellIndex]++;
            if ( SF_g[cellIndex] == MAX_SUBFRAME )
            {
                SF_g[cellIndex] = 0;
                SFN_g[cellIndex]++ ;

                if ( SFN_g[cellIndex] == MAX_SFN )
                {
                    SFN_g[cellIndex] = 0;
                }
            }
        }
    }
    /* - SPR_11100 */
    else
    {
        /*SPR 11646*/
        /** SPR 11348 Changes Start **/
        if((FAPI_RUNNING == phyState_g[!cellIndex]) || (1 == isCellOfTargetEnb[!cellIndex]))
        {
            eventfd_write_wrapper(ev_fd_SFI_g,1);
        }
        /** SPR 11348 Changes  End**/
        /*SPR 11646*/
        /* - SPR_11557_11143 */
        SF_g[cellIndex]++;
        if ( SF_g[cellIndex] == MAX_SUBFRAME )
        {
            SF_g[cellIndex] = 0;
            SFN_g[cellIndex]++ ;

            if ( SFN_g[cellIndex] == MAX_SFN )
            {
                SFN_g[cellIndex] = 0;
            }
        }
    }
#else
    if ( ( 1 == phy_tick_miss_g[cellIndex] ) &&
            ( (globalTTITickCount_g >= phy_err_start_tti_g[cellIndex]) &&
              (globalTTITickCount_g <= phy_err_end_tti_g[cellIndex]) ) &&
            (errorCount_g[cellIndex] == 0 ) )
    {
        UInt16 deltaVal = phy_err_abs_delta_val_g[cellIndex];
        while( deltaVal-- )
        {
            SF_g[cellIndex]++;
            if( MAX_SUBFRAME <= SF_g[cellIndex] )
            {
                SF_g[cellIndex] = 0;
                SFN_g[cellIndex]++;
            }
            if ( SFN_g[cellIndex] == MAX_SFN )
            {
                SFN_g[cellIndex] = 0;
            }
        }
        phy_tick_miss_g[cellIndex] = 0;
    }
    else
    {
        SF_g[cellIndex]++;
        if ( SF_g[cellIndex] == MAX_SUBFRAME )
        {
            SF_g[cellIndex] = 0;
            SFN_g[cellIndex]++ ;

            if ( SFN_g[cellIndex] == MAX_SFN )
            {
                SFN_g[cellIndex] = 0;
            }
        }
    }
#endif

    sfnsf_g[cellIndex] = GENERATE_SUBFRAME_SFNSF(SFN_g[cellIndex],SF_g[cellIndex]);

    if (cellIndex == getActiveCell())
    {
        macSubFrameInd();
    }
#ifdef UESIM_ENHANCEMENTS
    for(i = 0; i < cellConfigUeSim_g[cellIndex].dlAvailableRBs; i++)
    {
        if(RB_CAN_BE_ALLOCATED__BUSY == dlRBInfo_g[cellIndex][i])
        {
            dlRBInfo_g[cellIndex][i] = RB_CAN_BE_ALLOCATED__FREE;
        }
    }

    for(i = 0; i < cellConfigUeSim_g[cellIndex].ulAvailableRBs; i++)
    {
        if(RB_CAN_BE_ALLOCATED__BUSY == ulRBInfo_g[cellIndex][i])
        {
            ulRBInfo_g[cellIndex][i] = RB_CAN_BE_ALLOCATED__FREE;
        }
    }
#endif        

    /* HD FDD Changes Start */
#ifdef FDD_CONFIG
#ifdef HD_FDD_CONFIG
    clearUeScheduleMapContext(dlRecvSF_g);
#endif
#endif
    /* HD FDD Changes End */
    /* Send SubFrame Indication to MAC */
    /* FAPI_ERROR_INDICATION_CHANGES_START*/
    /* Do not send subframe Indication to MAC in case FAPI_MSG_INVALID_STATE error is triggered*/
    if (!((1 == phy_err_config_g[cellIndex]) &&
                (errorCount_g[cellIndex]) && 
                (FAPI_MSG_INVALID_STATE == phy_err_error_type_g[cellIndex]) &&
                (PHY_DL_CONFIG_REQUEST <= phy_err_msg_type_g[cellIndex])))
    {
        /*SPR 12221 Fix , replacing phyState_g check with below check for HO*/  
        if (macRegFlag_g[cellIndex] == REG_SUCCESS)
        {
            fapiSendSubFrameStartIndication (cellIndex);
	   
       /*RAR_Handling:Start*/
	    /*RAR_Handling:End*/
        }
    }
    return;
}

 /* EICIC - TDD +*/

#ifdef TDD_CONFIG
/*****************************************************************************
 * Function Name  : getUplinkToGrantSubframeNumber
 * Inputs         : 
 * Returns        : 
 * Description    : 
 *****************************************************************************/
inline UInt16 getUplinkToGrantSubframeNumber( UInt8 subframe, 
        InternalCellIndex internalCellIndex
        )
{
   UInt8 tddConfig = 0;
   tddConfig = cellConfigUeSim_g[internalCellIndex].subFrameAssignment;
   if (MAX_UL_DL_CONFIG <= tddConfig)
   {
       return 0xFF;
   }
   return uplinkToGrantMap_g[tddConfig][subframe];

}
/* EICIC - TDD -*/
#endif

/****************************************************************************
 * Function Name  : fapiulDispatcher
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    : This is the starting point for fapiulDispatcher thread. 
 *                  It will call the corrsponding function which will send the 
 *                  data to ENB MAC. 
 ****************************************************************************/
#ifdef DL_DATA_SEPARATION                 
int controlmsg_g=0;
int datamsg_g=0;
#endif
//TA NON_SS
void fapiulDispatcher(UInt8 cellIndex )
{
#include <sys/time.h>
    /* SPR 609 changes start */
    //struct timeval currentTime;
    //static long long prevTime = 0;
    /* SPR 609 changes end */
    static UInt8 RI_swap = 15;
    static UInt8 PMI_swap = 3;
    UInt8 harqIndBuffer[CONTROL_API_BUFFER_SIZE] = {0};
    UInt8 crcIndBuffer[CONTROL_API_BUFFER_SIZE] = {0};
    UInt8 srIndBuffer[CONTROL_API_BUFFER_SIZE] = {0};
    UInt8 cqiIndBuffer[CONTROL_API_BUFFER_SIZE] = {0};
    UInt8 srsIndBuffer[CONTROL_API_BUFFER_SIZE]= {0};
    UInt8 measReportBuffer[CONTROL_API_BUFFER_SIZE] = {0};
    UInt16 harqPduIndLen=0;
    /* SPR 19679: TDD HARQ Multiplexing Changes Start*/
    UInt8 checkSPS = 0; 
    /* SPR 19679: TDD HARQ Multiplexing Changes End*/
    /* SPR 609 changes start */
    //UInt8 ulschDataIndBuffer[SBUFFERSIZE] = {0};
    /* SPR 609 changes end */
    UInt8 *sendBuffer_p = PNULL;
    UInt8 *start_p = PNULL; 
    UInt8 i = 0;
    /*  Aperiodic CQI Changes start*/
    UInt8 sizeOfCqiCsiField = 0;
    UInt8 scellIndex = 0;
    UInt8 scellCount = 0;
    /*  Aperiodic CQI Changes End*/
#ifdef UESIM_ENHANCEMENTS
   UInt8 j = 0;
#endif    
    UInt8 *cqiReport_p = PNULL;
    UInt16 queueCount = 0;
    FAPI_harqIndQueueNode_st *harqIndNode_p = PNULL;

    UInt16 srQueueCount = 0;
    UInt8 srHarqArrIndex = 0;
    UInt16  srHarqRntiArr[MAX_RNTI_VALUE] = {0};
#ifdef FAPI_4_0_COMPLIANCE
#if (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
    UInt8 harqTbIndex    = 0;
    UInt8 numOfAckNack   = 0;
    UInt8 arrIndx        = 0;
#endif
#endif

#ifndef FAPI_4_0_COMPLIANCE
    FAPI_harqIndication_st    *harqIndBody_p = PNULL;
#else
#if defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9)
    FAPI_harqIndicationR9_st    *harqIndBody_p = PNULL;
#else
    FAPI_harqIndicationR8_st    *harqIndBody_p = PNULL;
#endif
#endif
#ifdef FDD_CONFIG
#ifndef FAPI_4_0_COMPLIANCE
    FAPI_fddHarqPduIndication_st *harqPdu_p = PNULL;
#else
#if (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
    FAPI_fddHarqPduIndicationR9_st *harqPdu_p = PNULL;

    /* SPR 11755 Fix Start */
    UInt32 rntiCntr = 0;
    for (rntiCntr = 0; rntiCntr < cellConfigUeSim_g[cellIndex].crntiRange ; rntiCntr++)
    {
        harqIndQNode_gp[cellIndex][rntiCntr].state = FALSE;
/* + SPR 14111 Changes */
#ifdef FDD_CONFIG        
        harqIndQNode_gp[cellIndex][rntiCntr].qIndex = MAX_SUBFRAME;
#elif TDD_CONFIG        
        harqIndQNode_gp[txCellIndex][diff].qIndex = MAX_UL_ARRAY; 
#endif        
/* - SPR 14111 Changes */
        harqIndQNode_gp[cellIndex][rntiCntr].isScell = FALSE;
    }
    /* SPR 11755 Fix End */
#else
    FAPI_fddHarqPduIndicationR8_st *harqPdu_p = PNULL;
#endif
#endif
#elif TDD_CONFIG
#ifndef FAPI_4_0_COMPLIANCE
    FAPI_tddHarqPduIndication_st *harqPdu_p = PNULL;
#else
#if (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
    FAPI_tddHarqPduIndicationR9_st *harqPdu_p = PNULL;
#else
    FAPI_tddHarqPduIndicationR8_st *harqPdu_p = PNULL;
#endif
#endif
    FAPI_tddSpecialBundlingHarqInfo_st *harqSpBundleInfo_p = PNULL;
#endif
    FAPI_ulRachIndicationNode_st  *rachIndNode_p = PNULL;
    FAPI_ulCrcIndicationNode_st *crcIndNode_p = PNULL;
    FAPI_crcIndication_st *crcIndBody_p = PNULL;
    FAPI_crcPduIndication_st *crcPdu_p = PNULL;
    FAPI_rxSRIndication_st *srIndBody_p = PNULL;
    FAPI_srPduIndication_st *srPdu_p = PNULL;
    FAPI_ulSrIndicationNode_st *srIndNode_p = PNULL;
    FAPI_ulSrIndicationNode_st *srHarqIndNode_p = PNULL;
/* +DYNAMIC_ICIC */ 
    FAPI_l1MeasReport_st *l1MeasRep_p = PNULL;
    static UInt32 measOpportunity=0;
    static UInt8 profileidx = 0;
    static UInt8 rsTxNum=0;
    static UInt8 tNoiseNum=0;
 
/* -DYNAMIC_ICIC */
    /* + TM7_8 Changes Start */
    UInt8 idx = 0;
    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
    FAPI_VendorSpecificR9_st *vendorSpecificData_p = PNULL;
    FAPI_AOA_RecievedForUE_st *aoaRel9TAInfoForUE = PNULL;

#else
    FAPI_VendorSpecific_st *vendorSpecificData_p = PNULL;
    FAPI_AOA_REL9TARecievedForUE_st *aoaRel9TAInfoForUE = PNULL;

#endif
    /* +- SPR 18268 */
    UInt16 numOfUes = 0;
    /* +- SPR 18268 */
    FAPI_AOA_REL9TARecievedForUE_st aoaRel9TAInfoForUEs[MAX_UE_SUPPORTED];
    /* - TM7_8 Changes End */
    FAPI_cqiIndQueueNode_st *cqiIndNode_p = PNULL;

    /* Phase 2 Periodic CQi Changes Start*/
    UInt8 updatedCqiReportType = 0;
    UInt8 updatedCellIndex = 0;
    /* Phase 2 Periodic CQi Changes End*/
    /* SPR 609 changes start */
    //FAPI_rxULSCHIndication_st  *ulschDataInd_p = PNULL;
    //FAPI_ulDataPduIndication_st *ulDataPdu_p = PNULL;
    /* SPR 609 changes end */
    FAPI_ulSrsIndicationNode_st *srsIndNode_p = PNULL;
    /*FAPI2_1 changes start*/
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
    FAPI_srsIndicationR9_st *srsIndBody_p = PNULL;
    FAPI_srsPduIndicationR9_st *srsPdu_p = PNULL;
#else
    FAPI_srsIndication_st *srsIndBody_p = PNULL;
    FAPI_srsPduIndication_st *srsPdu_p = PNULL;
#endif

#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
    FAPI_cqiPduIndicationR9_st *cqiPdu_p = PNULL;
    FAPI_rxCqiIndicationR9_st *cqiIndBody_p = PNULL;
    UInt16 iterator=0;
#else
    FAPI_cqiPduIndication_st *cqiPdu_p = PNULL;
    FAPI_rxCqiIndication_st *cqiIndBody_p = PNULL;
#endif
    UInt16   timingAdvanceR9=20;
    /*FAPI2_1 changes end*/
    FAPI_l1ApiMsg_st          *l1ApiMsg_p = PNULL;
    /* ULA_CHG */
    UInt16 apiMsgBodyLen = 0, numOfHarq = 0, numOfCrc = 0, numRb = 0,numOfUe =0;
    UInt8 maxRb = 0, srsBw = 0;
    /* ULA_CHG */
    UInt16 numOfSr = 0;
    UInt16 numOfCqi = 0;
    UInt32 apiMsgLen = 0;
    UInt8  qIndex      = 0;
    UInt8  srsQIndex      = 0;
    UInt8 currentSF = 0;
    /* SPR 609 changes start */
#ifdef FAPI_UL_HARQ_ENABLE    
    /* SPR 609 changes end */
    UInt8  phichReceiveIndex   = 0;
    UInt8  prevPhichReceiveIndex   = 0;    
    ulschDataQueueNode *uldataNode_p = PNULL;
    UInt16 ulHarqTimerElementCount = 0;
    UInt16 ueIndex = 0;
    UInt8 harqIndex = 255;    
    UInt32 tbSize = 0;
    /* SPR 609 changes start */
#endif    
    /* SPR 609 changes end */
/* +DYNAMIC_ICIC */

    FAPI_rxMeasReport_st *l1MeasRepBody_p = PNULL;

/* +DYNAMIC_ICIC */

    /* + CQI_4.1 */
    DLUEContext *newUEContext_p = PNULL;
    UInt8 cqi_count = 0;
    UInt8 count = 0;
    /* - CQI_4.1 */
    /* + CQI_5.0 */
    UInt8 riIndex = 0;
    /* - CQI_5.0 */
    /* SPR 3924 changes start */
    UInt8 cqiPeriodicReportType = 0;
    UInt8 cqiPeriodicReportType2 = 0; /* EICIC +-*/
    UInt8 cqiPeriodicScellReportType =0;
    UInt8 cqiPeriodicScellReportType2 =0; /* EICIC +-*/
    UInt8 numBitsAbsPattern = 0; /* EICIC +-*/
    UInt8 cqirequestbit = 0;
    /* SPR 3924 changes end */
    /*SPR 12678 fix*/
    ueContextForUplink *ulUeContextInfo_p = PNULL;
#if 0
    //fprintf(stderr,"\n===== UL Dispatcher Thread Binding ==============\n");
    THREAD_TO_BIND_SET_CORE_NO( fapiUlDispatcherThread_g, 
            uldispatcherThreadCoreNum_g);

    //fprintf(stderr,"\n===== Verfiy  Dispatcher Thread Binding =========\n");
    THREAD_TO_BIND_GET_CORE_NO( fapiUlDispatcherThread_g, 
            uldispatcherThreadCoreNum_g) ;
    //fprintf(stderr,"\n=================================================\n");

    while (  1 )
    {  
        if ( macRegFlag_g  == REG_SUCCESS)
        {
            break;
        }
    }

    while (1)
    {
#endif

        queueCount = 0;
        apiMsgBodyLen = 0;
        numOfHarq = 0;
        numOfCrc = 0;
        numOfSr = 0;
        numOfCqi = 0;
        apiMsgLen = 0;
        qIndex = 0;
#ifndef UE_SIM_SPLIT
        /* Tick Indication Recieved from the PHY Timer Thread */
        //semWait(&fapiUlDispatcherThreadSem_g);

        /*TA - CA same TTI dispatching change */
        UInt8 errQIdx = SF_g[cellIndex] ;
         LP_PhyErrInd phyErrInd_p = PNULL;
        UInt32 qCount = COUNT_PHY_ERR_IND_Q( errQIdx,cellIndex );
         
         /* check the fapi error indication queue and send the same to L2 */
         while( qCount-- )
         {
            DEQUEUE_PHY_ERR_IND_Q( phyErrInd_p, errQIdx ,cellIndex);
             if( PNULL != phyErrInd_p )
             {
                 sendSFItoSourceENBMac( phyErrInd_p->data_p,
                        phyErrInd_p->dataSize, cellIndex);
                if ( startRecvFlag[cellIndex] == 2 )
                 {
                     sendDataToTargetEnbMac(phyErrInd_p->data_p, 
                            phyErrInd_p->dataSize, cellIndex);
                 }
                 freeMemPool( phyErrInd_p->data_p );
                 phyErrInd_p->data_p = PNULL;

                 freeMemPool( phyErrInd_p );
                 phyErrInd_p = PNULL;
             }
         }
        /*FAPI_ERROR_INDICATION_CHANGES_END*/
#ifdef DL_DATA_SEPARATION                 
        controlmsg_g=0;
        datamsg_g=0;
#endif
#ifdef FDD_CONFIG
        /** For TTIB_Code */
        processTTIBQueue(cellIndex);
#endif
#endif
        currentSF = SF_g[cellIndex];
        /* qIndex represent the Queue Index correspondence the SubFrame */  

        /**********ONLY FDD HARQ INDICATION **************************************/
#ifdef FDD_CONFIG

        //qIndex          = SF_g - PEER_MAC_DELAY;
        qIndex          = SF_g[cellIndex] ;

        /* Send FDD Harq Indication */
        queueCount = sQueueCount(&(harqQueue[cellIndex][qIndex]));
        /****************************************************************
         * FAPI Msg Formation
         * ---------L1 Header---------------------------------------------
         * uint8_t	Message type ID                                  |
         * uint8_t	Length of vendor-specific message body (bytes)   |
         * uint16_t	Length of message body (bytes)                   |
         * Message body                                                  |
         * ---------------------------------------------------------------
         * < Message Specific Contents>                                  |
         * --------------------------------------------------------------
         * Vendor-specific message body                                  |
         * --------------------------------------------------------------
         * < Vendor Specific Contents>                                   |
         * --------------------------------------------------------------
         *****************************************************************/
        if(queueCount)
        {
            start_p = harqIndBuffer;
            sendBuffer_p = harqIndBuffer;
            l1ApiMsg_p = ( FAPI_l1ApiMsg_st *)sendBuffer_p;
            l1ApiMsg_p->msgId = PHY_UL_HARQ_INDICATION;
            l1ApiMsg_p->lenVendorSpecific = 0;
            apiMsgLen += L1_PARTIAL_API_MSG_SIZE;
            apiMsgBodyLen = 4;
            numOfHarq = 0;
#ifndef FAPI_4_0_COMPLIANCE
            harqIndBody_p = (FAPI_harqIndication_st *) &(l1ApiMsg_p->msgBody[0]);
            harqPdu_p = ( FAPI_fddHarqPduIndication_st *)&(harqIndBody_p->harqPduInfo[0]);
            harqPduIndLen=sizeof(FAPI_fddHarqPduIndication_st);
#else 
#if (defined(FAPI_RELEASE9) ||defined(FAPI_RELEASE10))  
            harqIndBody_p = (FAPI_harqIndicationR9_st *) &(l1ApiMsg_p->msgBody[0]);
            harqPdu_p = ( FAPI_fddHarqPduIndicationR9_st *)&(harqIndBody_p->harqPduInfo[0]);
            harqPduIndLen=sizeof(FAPI_fddHarqPduIndicationR9_st);

#else
            harqIndBody_p = (FAPI_harqIndicationR8_st *) &(l1ApiMsg_p->msgBody[0]);
            harqPdu_p = ( FAPI_fddHarqPduIndicationR8_st *)&(harqIndBody_p->harqPduInfo[0]);
            harqPduIndLen=sizeof(FAPI_fddHarqPduIndicationR8_st);
#endif
#endif
            srHarqArrIndex = 0;
            srQueueCount = sQueueCount(&srIndQueue[cellIndex][qIndex]);
            srHarqIndNode_p = (FAPI_ulSrIndicationNode_st *)getFirstNode(&srIndQueue[cellIndex][qIndex] );

            while ( srQueueCount-- )
            { 
                srHarqRntiArr[srHarqIndNode_p->srPduInfo.rnti] =  SR_HARQ_NODE_PRESENT; 
                srHarqArrIndex++;
                srHarqIndNode_p = (FAPI_ulSrIndicationNode_st *)getNextNode((const LTE_SNODE *)srHarqIndNode_p);
                if (PNULL == srHarqIndNode_p)
                    continue;
            }
            while ( queueCount-- )
            {
                harqIndNode_p = ( FAPI_harqIndQueueNode_st * ) 
                    popNode ( &(harqQueue[cellIndex][qIndex]) );    
                if ( PNULL == harqIndNode_p )
                {
                    fprintf(stderr,"Error..!! pop node for cell [%d] in harqQueue at index %d is null\n",cellIndex, qIndex );
                    continue;
                }
                harqIndBody_p->sfnsf =  MAC_PHY_CONVERT_16(harqIndNode_p->sfnsf);
                numOfHarq++;
                harqPdu_p[numOfHarq - 1].rnti = harqIndNode_p->harqPduInfo.rnti;
#ifndef FAPI_4_0_COMPLIANCE
                harqPdu_p[numOfHarq - 1].harqTB1 = fddAckNackval_g[harqIndNode_p->harqPduInfo.harqTB1];
                harqPdu_p[numOfHarq - 1].harqTB2 = fddAckNackval_g[harqIndNode_p->harqPduInfo.harqTB2];
#else  
                /* CA_START_UP_PHASE_2 */
#if (defined(FAPI_RELEASE9) ||defined(FAPI_RELEASE10))    
                numOfAckNack =  harqIndNode_p->harqPduInfo.release9Param.numOfAckNack;

                if ( SR_HARQ_NODE_PRESENT == srHarqRntiArr[harqIndNode_p->harqPduInfo.rnti] )
                {
                    /* + SPR 11327 Fix */
                    harqPdu_p[numOfHarq - 1].release9Param.mode = 0;
                    /* - SPR 11327 Fix */

                    /* SPR_11270_Fix Start */

                    harqPdu_p[numOfHarq - 1].release9Param.numOfAckNack = (numOfAckNack > 2)?2:numOfAckNack;
                    for( harqTbIndex =  0 ; harqTbIndex < numOfAckNack ; harqTbIndex++)
                    {
                        harqPdu_p[numOfHarq - 1].release9Param.HARQTB[harqTbIndex] = \
                                                                                     fddAckNackval_g[harqIndNode_p->harqPduInfo.release9Param.HARQTB[harqTbIndex]];
                    }
                    /* SPR_11270_Fix End */

                    /* + SPR 11475 Changes */
                    ueContextForDownlink *tempUeUlContext_p = PNULL;
                    tempUeUlContext_p = getUEContext(MAC_PHY_CONVERT_16(harqIndNode_p->harqPduInfo.rnti), cellIndex);
                    if ( tempUeUlContext_p && tempUeUlContext_p->carrierAggrConfig.scellCount > 0)
                    {
                        harqPdu_p[numOfHarq - 1].release9Param.numOfAckNack = 2;
                    }
                    /* - SPR 11475 Changes */

                    ueContextForDownlink *ueContextInfo_p = PNULL;

                    switch (numOfAckNack)
                    {

                        case 3:

                        harqPdu_p[numOfHarq - 1].release9Param.HARQTB[0] &= \
                                                                            harqPdu_p[numOfHarq - 1].release9Param.HARQTB[1];
                        harqPdu_p[numOfHarq - 1].release9Param.HARQTB[1] &= \
                                                                            harqPdu_p[numOfHarq - 1].release9Param.HARQTB[2];

                        break;

                        case 4:

                        harqPdu_p[numOfHarq - 1].release9Param.HARQTB[0] &= \
                                                                            harqPdu_p[numOfHarq - 1].release9Param.HARQTB[1];

                        harqPdu_p[numOfHarq - 1].release9Param.HARQTB[1] = \
                                                                           harqPdu_p[numOfHarq - 1].release9Param.HARQTB[2] & \
                                                                           harqPdu_p[numOfHarq - 1].release9Param.HARQTB[3];

                        break;
                        default:
                        break;


                    }

                }
                else
                {
                    harqPdu_p[numOfHarq - 1].release9Param.mode = \
                                                                  harqIndNode_p->harqPduInfo.release9Param.mode ;/*format1a/1b*/
                    harqPdu_p[numOfHarq - 1].release9Param.numOfAckNack = numOfAckNack;
                    for( harqTbIndex =  0 ; harqTbIndex < numOfAckNack ; harqTbIndex++)
                        harqPdu_p[numOfHarq - 1].release9Param.HARQTB[harqTbIndex] = \
                                                                                     fddAckNackval_g[harqIndNode_p->harqPduInfo.release9Param.HARQTB[harqTbIndex]];
                }
                /* CA_START_UP_PHASE_2 */

#else 
                harqPdu_p[numOfHarq - 1].release8Param.harqTB1 = fddAckNackval_g[harqIndNode_p->harqPduInfo.release8Param.harqTB1];
                harqPdu_p[numOfHarq - 1].release8Param.harqTB2 = fddAckNackval_g[harqIndNode_p->harqPduInfo.release8Param.harqTB2];
#endif
#endif



                apiMsgBodyLen += harqPduIndLen;
                //apiMsgBodyLen = sizeof(FAPI_fddHarqPduIndication_st);
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr, \
                        "HARQ_IND rnti=[%d],SF=[%d] harq=[%d] sfnsf=[0x%x]\n", \
                        harqIndNode_p->harqPduInfo.rnti,qIndex,  \
                        harqIndNode_p->harqPduInfo.harqTB1, harqIndBody_p->sfnsf);
#endif


                freeMemPool(harqIndNode_p);
                harqIndNode_p = PNULL;
                //  apiMsgLen += apiMsgBodyLen;
                /* Defensive Check for Buffer Overflow*/
                if(apiMsgLen +  harqPduIndLen >= sizeof(harqIndBuffer))
                {
                    fprintf(stderr,"\n HARQ Buffer Insufficient for Sending > %d PDU!\n",numOfHarq);
                    break;
                }
            }
            apiMsgLen += apiMsgBodyLen;
            l1ApiMsg_p->msgLen= MAC_PHY_CONVERT_16(apiMsgBodyLen);
            harqIndBody_p->numOfHarq = MAC_PHY_CONVERT_16(numOfHarq);
            sendDatatoPeerMac(start_p, apiMsgLen, cellIndex);
#ifdef UT_TESTING
            fprintf(stderr,"\n DOWNLINK ACK SENT FOR %d NODES\n",numOfHarq);
#endif
        }
        /*Above code is for single tick handling*/

        /**************************************TDD Queue Idx ******************************/
#elif TDD_CONFIG
        qIndex = GET_QUEUE_IDX(cellIndex); 
        /*fapiSendHarqIndication */
        start_p = harqIndBuffer;
        sendBuffer_p = harqIndBuffer;

        /*************** DL DATA HARQ INDICATION IN TDD ****************************/

        l1ApiMsg_p = ( FAPI_l1ApiMsg_st *)sendBuffer_p;
        l1ApiMsg_p->msgId = PHY_UL_HARQ_INDICATION;
        l1ApiMsg_p->lenVendorSpecific = 0;
        apiMsgLen += L1_PARTIAL_API_MSG_SIZE;
        apiMsgBodyLen = 4;

        /* SPR 11771 Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
        harqIndBody_p = (FAPI_harqIndicationR9_st *) &(l1ApiMsg_p->msgBody[0]);
      /*TDD_FAPI_2.4 changes  START*/  
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
        harqIndBody_p = (FAPI_harqIndicationR8_st *) &(l1ApiMsg_p->msgBody[0]);
      /*TDD_FAPI_2.4 changes  END */  
#else
        harqIndBody_p = (FAPI_harqIndication_st *) &(l1ApiMsg_p->msgBody[0]);
#endif
        /* SPR 11771 End */

        UInt16 sfnSfTemp = 0;
        /* SPR 12138 Fix Start */
        UInt16 harqPduOffSet = 4;
        /* SPR 12138 Fix End */

        queueCount = sQueueCount(&(harqQueue[cellIndex][qIndex]));

        while ( queueCount-- )
        { 
            UInt8 mode_len = 0;
            ueContextForUplink *ueContextInfo_p = NULL;
            DaiTrackingRegister *daiTrackingInfo_p = NULL;
/* + CA_TDD_HARQ_CHANGES */    
            DaiTrackingRegister *scellDaiTrackingInfo_p = NULL;
/* - CA_TDD_HARQ_CHANGES */    

            harqIndNode_p = ( FAPI_harqIndQueueNode_st * ) 
                popNode ( &(harqQueue[cellIndex][qIndex]) );    
            if ( PNULL == harqIndNode_p )
            {
                fprintf(stderr,"Error..!! cell = %d pop node in harqQueue at index %d is null QCount:%d\n", 
                        cellIndex, qIndex, queueCount);
                continue;
            }

            /* SPR 11771 Start */
	    /* SPR 12138 Fix Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
            harqPdu_p = ( FAPI_tddHarqPduIndicationR9_st *)((UInt8 *) harqIndBody_p + harqPduOffSet);
      /*TDD_FAPI_2.4 changes  START*/  
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
            harqPdu_p = ( FAPI_tddHarqPduIndicationR8_st *)((UInt8 *) harqIndBody_p + harqPduOffSet);
      /*TDD_FAPI_2.4 changes  START*/  
#else
            harqPdu_p = ( FAPI_tddHarqPduIndication_st *)((UInt8 *) harqIndBody_p + harqPduOffSet);
#endif
	    /* SPR 12138 Fixend*/

            /* SPR 11771 End */
            ueContextInfo_p = getUEContext(harqIndNode_p->harqPduInfo.rnti, cellIndex);
            // The CRNTI in the control node is actually the RA-RNTI
            if ((ueContextInfo_p) && CRNTI == getRntiType(harqIndNode_p->harqPduInfo.rnti, 
                        cellIndex))
            {
                UInt16 sendSFN = ((harqIndNode_p->sfnsf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT);
                UInt8  sendSF = harqIndNode_p->sfnsf & FAPI_SF_MASK;
                UInt8 index = sendSFN & 1;
/* + CA_TDD_HARQ_CHANGES */    
                UInt8 scellIndex = ueContextInfo_p->carrierAggrConfig.scellInfo[0].sCellIndex;
/* - CA_TDD_HARQ_CHANGES */    

                /* + SPR 13929 Changes */
                daiTrackingInfo_p = &ueContextInfo_p->daiTrackingRegister[cellIndex][index][sendSF];
                /* - SPR 13929 Changes */
                /* + CA_TDD_HARQ_CHANGES */
                scellDaiTrackingInfo_p = &ueContextInfo_p->daiTrackingRegister[scellIndex][index][sendSF];
                /* - CA_TDD_HARQ_CHANGES */
                // Since any HARQ transmissions will now be dispatched reset all
                // DAI tracking information for the current UL subframe
                daiTrackingInfo_p->daiCount = 0;
                daiTrackingInfo_p->lastReceivedDai = 0;
                daiTrackingInfo_p->daiUpdated = 0;
                daiTrackingInfo_p->isTB1Valid = FALSE;
                daiTrackingInfo_p->daiValue = 4;
                daiTrackingInfo_p->isTB2Valid = FALSE;
                daiTrackingInfo_p->ackNackFieldTB1 = 0;
                daiTrackingInfo_p->ackNackFieldTB2 = 0;

                /* SPR 19679: TDD HARQ Multiplexing Changes Start*/
                daiTrackingInfo_p->vuldai = 0;
                /* SPR 19679: TDD HARQ Multiplexing Changes End*/

                /* + CA_TDD_HARQ_CHANGES */
                //if( CHANNEL_SELECTION == harqIndNode_p->harqPduInfo.mode)
                if( ueContextInfo_p->carrierAggrConfig.scellCount )
                {    
                    scellDaiTrackingInfo_p->daiCount = 0;
                    scellDaiTrackingInfo_p->lastReceivedDai = 0;
                    scellDaiTrackingInfo_p->daiUpdated = 0;
                    scellDaiTrackingInfo_p->isTB1Valid = FALSE;
                    scellDaiTrackingInfo_p->daiValue = 4;
                    scellDaiTrackingInfo_p->isTB2Valid = FALSE;
                    scellDaiTrackingInfo_p->ackNackFieldTB1 = 0;
                    scellDaiTrackingInfo_p->ackNackFieldTB2 = 0;
                }
                /* - CA_TDD_HARQ_CHANGES */

                ueContextInfo_p->harqNode_p[index][sendSF] = PNULL;
            }

            numOfHarq++;
            harqPdu_p->handle = MAC_PHY_CONVERT_32(harqIndNode_p->harqPduInfo.handle);
            harqPdu_p->rnti = MAC_PHY_CONVERT_16(harqIndNode_p->harqPduInfo.rnti);
            harqPdu_p->mode = harqIndNode_p->harqPduInfo.mode; 

            /* SPR 11621 Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
            harqPdu_p->release9Param.numOfAckNack = 
                harqIndNode_p->harqPduInfo.numOfAckNack;
      /*TDD_FAPI_2.4 changes  START*/  
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
            harqPdu_p->release8Param.numOfAckNack = 
                harqIndNode_p->harqPduInfo.numOfAckNack;
      /*TDD_FAPI_2.4 changes  END*/  
#else
            harqPdu_p->numOfAckNack = 
                harqIndNode_p->harqPduInfo.numOfAckNack;
#endif
            /* SPR 11621 End */

            sfnSfTemp = harqIndNode_p->sfnsf;

            if(BUNDLING == harqPdu_p->mode)
            {
#if 0
                *(FAPI_tddBundlingHarqInfo *)
                    &(harqPdu_p->harqBuffer[0]) = 
                    *((FAPI_tddBundlingHarqInfo *)&harqIndNode_p->harqPduInfo.harqBuffer);
#endif

                /* SPR 11621 Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                /*SPR 13884 changes start */
                if( harqPdu_p->release9Param.numOfAckNack == 1)
                { 
                  if(tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value0] == INVALID_ACK_NACK)
                  {
                     ((FAPI_tddBundlingHarqInfoR9_st *)
                      &(harqPdu_p->release9Param.harqBuffer[0]))->value0 = 
                         tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value1];

                  }
                  else
                  {
                     ((FAPI_tddBundlingHarqInfoR9_st *)
                      &(harqPdu_p->release9Param.harqBuffer[0]))->value0 = 
                         tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value0];

                  }
                }
                if( harqPdu_p->release9Param.numOfAckNack == 2)
                {
                     ((FAPI_tddBundlingHarqInfoR9_st *)
                      &(harqPdu_p->release9Param.harqBuffer[0]))->value0 = 
                         tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value0];
                     ((FAPI_tddBundlingHarqInfoR9_st *)
                      ((UInt8 *)&(harqPdu_p->release9Param.harqBuffer[0])+sizeof(FAPI_tddBundlingHarqInfoR9_st)))->value0 = 
                         tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value1];

                }    
                /*SPR 13884 changes end */
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)

                ((FAPI_tddBundlingHarqInfo *)
                 &(harqPdu_p->release8Param.harqBuffer[0]))->value0 = 
                    tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value0];
                ((FAPI_tddBundlingHarqInfo *)
                 &(harqPdu_p->release8Param.harqBuffer[0]))->value1 = 
                    tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value1];
#else
                ((FAPI_tddBundlingHarqInfo *)
                 &(harqPdu_p->harqBuffer[0]))->value0 = 
                    tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value0];
                ((FAPI_tddBundlingHarqInfo *)
                 &(harqPdu_p->harqBuffer[0]))->value1 = 
                    tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value1];
#endif
                /* SPR 11621 End */
                /*TDD_FAPI_2.4 changes  START*/
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                /*SPR 13884 changes start */
                harqPduOffSet = harqPduOffSet + 12 + sizeof(FAPI_tddBundlingHarqInfoR9_st) * (harqPdu_p->release9Param.numOfAckNack);
                mode_len = sizeof(FAPI_tddBundlingHarqInfoR9_st) * harqPdu_p->release9Param.numOfAckNack;
                /*SPR 13884 changes end */

#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                harqPduOffSet += 16;
                mode_len = sizeof(FAPI_tddBundlingHarqInfo);
#else
               
		/* SPR 12138 Fix Start */
                harqPduOffSet += 10;
		/* SPR 12138 Fix End */
                mode_len = sizeof(FAPI_tddBundlingHarqInfo);
#endif
                /*TDD_FAPI_2.4 changes  END*/
            }
            /* + CA_TDD_HARQ_CHANGES */
            else if( CHANNEL_SELECTION == harqPdu_p->mode)
            {
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                /* + SPR_14263 */
                UInt8 sendSF = harqIndNode_p->sfnsf & FAPI_SF_MASK;
                UInt8 count = 0;
                if ( 1 == getM_g[tddUlDlConfig_g[cellIndex]][sendSF] )
                     harqIndNode_p->isScheduledOnPUSCH = 0;
                /* - SPR_14263 */
                                        
                if (harqIndNode_p->isScheduledOnPUSCH)
                {
                    UInt8 cell = 0;
                    UInt8 temp = 0;
                    UInt8 harqFilled = 0;
                    UInt8 M = getM_g[tddUlDlConfig_g[cellIndex]][sendSF];
                   
                    M = ((M == 1) ? 4 : M);
                    UInt8 j[MAX_NUM_CELL] = {0,M};

                    for (count = 0; (count < (2*MAX_SUBFRAME)) && (harqFilled < M); count++)
                    {
                        if (CHECK_BIT_SET(dlAckNackBitMap[tddUlDlConfig_g[cellIndex]][sendSF],count)) 
                        {
                            for (cell = 0;cell < MAX_NUM_CELL;cell++)
                            {
                                temp = (0 == cell) ? harqFilled : (harqFilled + (cell * M));
                                if (harqIndNode_p->harqPduInfo.channelSelectionHarqBuffer[j[cell]].
                                        scheduledSF == (count%MAX_SUBFRAME))
                                {
                                    ((FAPI_tddChannelSelectionHarqInfo_st *)
                                     &(harqPdu_p->release9Param.harqBuffer[temp * sizeof(FAPI_tddChannelSelectionHarqInfo_st)]))->value0 = 
                                        tddAckNackval_g[harqIndNode_p->harqPduInfo.channelSelectionHarqBuffer[j[cell]].value0];
                                    j[cell]++;
                                }
                                else
                                {
                                    /** Filling DTX **/
                                    ((FAPI_tddChannelSelectionHarqInfo_st *)
                                     &(harqPdu_p->release9Param.harqBuffer[temp * sizeof(FAPI_tddChannelSelectionHarqInfo_st)]))->value0 = 
                                        tddAckNackval_g[1];
                                }
                            }
                            harqFilled++;
                        }
                    }
                }
                else
                {
                    for (count = 0; count < harqIndNode_p->harqPduInfo.numOfAckNack; count++)
                    {
                        ((FAPI_tddChannelSelectionHarqInfo_st *)
                         &(harqPdu_p->release9Param.harqBuffer[count * sizeof(FAPI_tddChannelSelectionHarqInfo_st)]))->value0 = 
                            tddAckNackval_g[harqIndNode_p->harqPduInfo.channelSelectionHarqBuffer[count].value0];
                    }
                }
                mode_len = harqIndNode_p->harqPduInfo.numOfAckNack * sizeof(FAPI_tddChannelSelectionHarqInfo_st);
                harqPduOffSet += 12 + ( harqIndNode_p->harqPduInfo.numOfAckNack * sizeof(FAPI_tddChannelSelectionHarqInfo_st));
#else
                ltePanic("\nChannel selection not supported");
#endif
            }
            /* - CA_TDD_HARQ_CHANGES */
            /* SPR 19679: TDD HARQ Multiplexing Changes Start */
            else if( MULTIPLEXING == harqPdu_p->mode)
            {
                UInt8 sendSF = harqIndNode_p->sfnsf & FAPI_SF_MASK;
                UInt8 M = getM_g[tddUlDlConfig_g[cellIndex]][sendSF];
                if (1 == M)
                {
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                    if( harqPdu_p->release9Param.numOfAckNack == 1)//SISO case
                    {
                        if(tddAckNackval_g[
                                harqIndNode_p->harqPduInfo.
                                multiplexingHarqBuffer[0].value0] == INVALID_ACK_NACK)
                        {
                            ((FAPI_tddMultiplexingHarqInfoR9_st *)&(harqPdu_p->
                                release9Param.harqBuffer[0]))->value0 = 
                                tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                multiplexingHarqBuffer[0].value1];
                        }
                        else
                        {
                            ((FAPI_tddMultiplexingHarqInfoR9_st *)&(harqPdu_p->
                                release9Param.harqBuffer[0]))->value0 = 
                                tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                multiplexingHarqBuffer[0].value0];
                        }
                    }
                    if( harqPdu_p->release9Param.numOfAckNack == TWO)//MIMO case
                    {
                        ((FAPI_tddMultiplexingHarqInfoR9_st *)&(harqPdu_p->
                            release9Param.harqBuffer[0]))->value0 = 
                            tddAckNackval_g[harqIndNode_p->harqPduInfo.
                            multiplexingHarqBuffer[0].value0] ;
                        
                        ((FAPI_tddMultiplexingHarqInfoR9_st *)&(harqPdu_p->release9Param.harqBuffer[0 + sizeof(FAPI_tddMultiplexingHarqInfoR9_st)]))->value0 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                            multiplexingHarqBuffer[0].value1];
                    }
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)

    ((FAPI_tddMultiplexingHarqInfo_st *)&(harqPdu_p->
                            release8Param.harqBuffer[0]))->value0 = tddAckNackval_g[3];

    ((FAPI_tddMultiplexingHarqInfo_st *)&(harqPdu_p->
                        release8Param.harqBuffer[0]))->value1 = tddAckNackval_g[3];

    ((FAPI_tddMultiplexingHarqInfo_st *)&(harqPdu_p->
                            release8Param.harqBuffer[0]))->value2 = tddAckNackval_g[3];

    ((FAPI_tddMultiplexingHarqInfo_st *)&(harqPdu_p->
                        release8Param.harqBuffer[0]))->value3 = tddAckNackval_g[3];

                    if (harqIndNode_p->harqPduInfo.numOfAckNack == 1)
                    {

                        ((FAPI_tddMultiplexingHarqInfo_st *)&(harqPdu_p->
                            release8Param.harqBuffer[0]))->value0 = tddAckNackval_g
                            [harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[0].value0];
                    }
                    if (harqIndNode_p->harqPduInfo.numOfAckNack == 2)
                    {
                    ((FAPI_tddMultiplexingHarqInfo_st *)&(harqPdu_p->
                        release8Param.harqBuffer[0]))->value0 = tddAckNackval_g
                        [harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[0].value0];
                    ((FAPI_tddMultiplexingHarqInfo_st *)&(harqPdu_p->
                        release8Param.harqBuffer[0]))->value1 = tddAckNackval_g
                        [harqIndNode_p->harqPduInfo.
                        multiplexingHarqBuffer[0].value1];
                    }

#else

                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                     (harqPdu_p->harqBuffer[0]))->value0 = tddAckNackval_g[3];
                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                     (harqPdu_p->harqBuffer[0]))->value1 = tddAckNackval_g[3];
                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                     (harqPdu_p->harqBuffer[0]))->value2 = tddAckNackval_g[3];
                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                     (harqPdu_p->harqBuffer[0]))->value3 = tddAckNackval_g[3];
                    if (harqIndNode_p->harqPduInfo.numOfAckNack == 1)
                    {
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->harqBuffer[0]))->value0 = tddAckNackval_g
                            [harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[0].value0];
                    }
                    if (harqIndNode_p->harqPduInfo.numOfAckNack == 2)
                    {
                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                     (harqPdu_p->harqBuffer[0]))->value0 = tddAckNackval_g
                        [harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[0].value0];
                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                     (harqPdu_p->harqBuffer[0]))->value1 = tddAckNackval_g
                        [harqIndNode_p->harqPduInfo.
                        multiplexingHarqBuffer[0].value1];
                    }

#endif
                }
                else 
                {
                    if ( !harqIndNode_p->isScheduledOnPUSCHForMux)
                    {
                        harqIndNode_p->harqPduInfo.numOfAckNack = M;
                    }
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                    harqPdu_p->release9Param.numOfAckNack =
                        harqIndNode_p->harqPduInfo.numOfAckNack;
                    /*TDD_FAPI_2.4 changes  START*/
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                    harqPdu_p->release8Param.numOfAckNack =
                        harqIndNode_p->harqPduInfo.numOfAckNack;
                    /*TDD_FAPI_2.4 changes  END*/
#else
                    harqPdu_p->numOfAckNack =
                        harqIndNode_p->harqPduInfo.numOfAckNack;
#endif

                    UInt8 count = 0;
                    UInt8 harqFilled = 0;
                    UInt8 temp = 0;
                    UInt8 index = 0;
                    UInt8 sendSF = harqIndNode_p->sfnsf & FAPI_SF_MASK;
                    UInt8 i = 0;
                    UInt8 fill = 0;
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                    if ( harqIndNode_p->isScheduledOnPUSCHForMux)
                    {
                        for(i = 0;i<harqIndNode_p->harqPduInfo.numOfAckNack;i++)
                        {
                            if (! harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].spsOcc )
                            {
                                ((FAPI_tddMultiplexingHarqInfoR9_st *)&
                                 (harqPdu_p->release9Param.harqBuffer[fill *
                                  sizeof(FAPI_tddMultiplexingHarqInfoR9_st)]))->value0 =
                                    tddAckNackval_g[(harqIndNode_p->harqPduInfo.
                                            multiplexingHarqBuffer[i].value0 & harqIndNode_p->harqPduInfo.
                                            multiplexingHarqBuffer[i].value1)];

                                fill++;
                            }
                            else
                            {
                                ((FAPI_tddMultiplexingHarqInfoR9_st *)&
                                 (harqPdu_p->release9Param.harqBuffer[(harqIndNode_p->harqPduInfo.numOfAckNack-1) *
                                  sizeof(FAPI_tddMultiplexingHarqInfoR9_st)]))->value0 =
                                    tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
                                harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].spsOcc = FALSE;
                            }
                        }
                        /*
                           for(i = 0; i < 4; i++)
                           {
                           fprintf(stderr, "\n [%s] [%d]DEBUG_27 ((FAPI_tddMultiplexingHarqInfoR9_st *)&(harqPdu_p->release9Param.harqBuffer[%d]))->value0 = %d SFN[%d] SF[%d]\n",__func__, __LINE__, i, (((FAPI_tddMultiplexingHarqInfoR9_st *)&(harqPdu_p->release9Param.harqBuffer[i]))->value0), ((harqIndNode_p->sfnsf & FAPI_SFN_MASK) >> FAPI_SFN_VALUE_SHIFT), (harqIndNode_p->sfnsf & FAPI_SF_MASK));
                           }*/
                    }
                    else
                    {
                        for (count = 0; (count < (2*MAX_SUBFRAME)) && 
                                (harqFilled < M); count++)
                        {
                            if (CHECK_BIT_SET(dlAckNackBitMap
                                        [tddUlDlConfig_g[cellIndex]][sendSF],count))
                            {

                                temp = tddHarqMuxIndex[tddUlDlConfig_g[cellIndex]][(count % MAX_SUBFRAME)];
                                if ( temp == 255 )
                                ltePanic("invalid value\n");

                                if (harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[index].scheduledSF == 
                                        (count % MAX_SUBFRAME))
                                {
                                    ((FAPI_tddMultiplexingHarqInfoR9_st *)&
                                     (harqPdu_p->release9Param.harqBuffer[temp * 
                                      sizeof(FAPI_tddMultiplexingHarqInfoR9_st)]))->value0 = 
                                        tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[index].value0 & 
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[index].value1];
                                    index++;
                                }
                                /** Filling DTX **/
                                else
                                {
                                    ((FAPI_tddMultiplexingHarqInfoR9_st*)&
                                     (harqPdu_p->release9Param.harqBuffer[temp * 
                                      sizeof(FAPI_tddMultiplexingHarqInfoR9_st)]))
                                        ->value0 = tddAckNackval_g[3];
                                }
                                harqFilled++;
                            }
                        }
                    }
#else
                    if ( harqIndNode_p->isScheduledOnPUSCHForMux)
                    {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[3];
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[3];
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value2 = tddAckNackval_g[3];
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value3 = tddAckNackval_g[3];
#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->value0 =
                                    tddAckNackval_g[3];
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->value1 =
                                    tddAckNackval_g[3];
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->value2 =
                                    tddAckNackval_g[3];
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->value3 =
                                    tddAckNackval_g[3];
#endif

                        /* to check if there is an sps occasion */
                        for(i = 0; i < harqIndNode_p->harqPduInfo.numOfAckNack; i++)
                        {
                            if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].spsOcc)
                            {
                                checkSPS = 1;
                                break;
                            }
                        }
                        /*to fill harqbuffer when there is no SPS occasion */
                        for(i = 0; i < harqIndNode_p->harqPduInfo.numOfAckNack; i++)
                        {
                                 if (0 == checkSPS)
                                 {
                                        if ((harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].daiIndexValue - 1)== 0)
                                        {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                            ((FAPI_tddMultiplexingHarqInfo_st *)&
                                             (harqPdu_p->release8Param.harqBuffer[0]))
                                                 ->value0 = tddAckNackval_g[harqIndNode_p->
                                                  harqPduInfo.multiplexingHarqBuffer[i].value0 &
                                                   harqIndNode_p->harqPduInfo.
                                                   multiplexingHarqBuffer[i].value1];
#else
                                            ((FAPI_tddMultiplexingHarqInfo_st *)&
                                             (harqPdu_p->harqBuffer[0]))->
                                                value0 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                                multiplexingHarqBuffer[i].value0 &
                                                harqIndNode_p->harqPduInfo.
                                                multiplexingHarqBuffer[i].value1];
#endif

                                        }
                                if ((harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].daiIndexValue - 1)== 1)
                                        {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                            ((FAPI_tddMultiplexingHarqInfo_st *)&
                                             (harqPdu_p->release8Param.harqBuffer[0]))
                                                 ->value1 = tddAckNackval_g[harqIndNode_p->
                                                 harqPduInfo.multiplexingHarqBuffer[i].value0 &
                                                 harqIndNode_p->harqPduInfo.
                                                  multiplexingHarqBuffer[i].value1];
#else
                                            ((FAPI_tddMultiplexingHarqInfo_st *)&
                                              (harqPdu_p->harqBuffer[0]))->
                                                 value1 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                                 multiplexingHarqBuffer[i].value0 &
                                                  harqIndNode_p->harqPduInfo.
                                                   multiplexingHarqBuffer[i].value1];
#endif
                                        }
                                if ((harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].daiIndexValue - 1)== 2)
                                        {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                            ((FAPI_tddMultiplexingHarqInfo_st *)&
                                             (harqPdu_p->release8Param.harqBuffer[0]))
                                                 ->value2 = tddAckNackval_g[harqIndNode_p->
                                                 harqPduInfo.multiplexingHarqBuffer[i].value0 &
                                                 harqIndNode_p->harqPduInfo.
                                                  multiplexingHarqBuffer[i].value1];
#else
                                            ((FAPI_tddMultiplexingHarqInfo_st *)&
                                              (harqPdu_p->harqBuffer[0]))->
                                                 value2 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                                 multiplexingHarqBuffer[i].value0 &
                                                  harqIndNode_p->harqPduInfo.
                                                   multiplexingHarqBuffer[i].value1];
#endif
                                        }
                                if ((harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].daiIndexValue - 1)== 3)
                                        {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                            ((FAPI_tddMultiplexingHarqInfo_st *)&
                                             (harqPdu_p->release8Param.harqBuffer[0]))
                                                 ->value3 = tddAckNackval_g[harqIndNode_p->
                                                 harqPduInfo.multiplexingHarqBuffer[i].value0 &
                                                 harqIndNode_p->harqPduInfo.
                                                  multiplexingHarqBuffer[i].value1];
#else
                                            ((FAPI_tddMultiplexingHarqInfo_st *)&
                                              (harqPdu_p->harqBuffer[0]))->
                                                 value3 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                                 multiplexingHarqBuffer[i].value0 &
                                                  harqIndNode_p->harqPduInfo.
                                                   multiplexingHarqBuffer[i].value1];
#endif
                                        }
                                 }
                        }
                        /*code to fill the last index for SPS */
                        if (1 == checkSPS)
                        {    
                        for(i = 0; i < harqIndNode_p->harqPduInfo.numOfAckNack; i++)
                        {
                            /*filling the harq buffer for SPS occasion*/
                            if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].spsOcc)
                            {
                                if ( 0 == (harqIndNode_p->harqPduInfo.numOfAckNack - 1))
                                {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->release8Param.harqBuffer[0]))
                                        ->value0 = tddAckNackval_g[harqIndNode_p->
                                        harqPduInfo.multiplexingHarqBuffer[i].value0 &
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#else
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->harqBuffer[0]))->
                                        value0 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value0 &
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#endif
                                }
                                else if ( 1 == (harqIndNode_p->harqPduInfo.numOfAckNack - 1))
                                {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->release8Param.harqBuffer[0]))
                                        ->value1 = tddAckNackval_g[harqIndNode_p->
                                        harqPduInfo.multiplexingHarqBuffer[i].value0 &
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#else
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->harqBuffer[0]))->
                                        value1 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value0 &
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#endif
                                }
                                else if ( 2 == (harqIndNode_p->harqPduInfo.numOfAckNack - 1))
                                {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->release8Param.harqBuffer[0]))
                                        ->value2 = tddAckNackval_g[harqIndNode_p->
                                        harqPduInfo.multiplexingHarqBuffer[i].value0 &
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#else
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->harqBuffer[0]))->
                                        value2 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value0 &
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#endif
                                }
                                else 
                                {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->release8Param.harqBuffer[0]))
                                        ->value3 = tddAckNackval_g[harqIndNode_p->
                                        harqPduInfo.multiplexingHarqBuffer[i].value0 &
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#else
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->harqBuffer[0]))->
                                        value3 = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value0 &
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#endif
                                }
                                harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].spsOcc = FALSE;
                            }
                        }

                        /*code to fill the other indices of harqBuffer in case
                         * of sps occasion*/
                        if(4 == harqIndNode_p->harqPduInfo.numOfAckNack)
                        {
                            if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[0].spsOcc)
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0, value1 value2*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value2 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[3].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[3].value1];

#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value2 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[3].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[3].value1];

#endif
                            }
                            else if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[1].spsOcc)
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0, value1, value2*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value2 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[3].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[3].value1];


#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value2 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[3].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[3].value1];


#endif
                            }
                            else if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[2].spsOcc)
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0, value1, value2*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value2 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[3].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[3].value1];

#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value2 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[3].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[3].value1];

#endif
                            }
                            else 
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0, value1, value2*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value2 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];


#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value2 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];
#endif
                            }

                        }
                        else if(3 == harqIndNode_p->harqPduInfo.numOfAckNack)
                        {
                            if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[0].spsOcc)
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0, value1*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];

#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];


#endif
                            }
                            else if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[1].spsOcc)
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0, value1*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];


#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[2].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[2].value1];



#endif
                            }
                            else if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[2].spsOcc)
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0, value1*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];

#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];


                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


#endif
                            }
                        }
                        else if(2 == harqIndNode_p->harqPduInfo.numOfAckNack)
                        {
                            if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[0].spsOcc)
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];

#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[1].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[1].value1];


#endif
                            }
                            else if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[1].spsOcc)
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                /*filling value0*/
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];

#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->
                                    value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[0].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[0].value1];

#endif
                            }
                        }
            }
                    }
                    else
                    {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->release8Param.harqBuffer[0]))
                            ->value0 = tddAckNackval_g[3];
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->release8Param.harqBuffer[0]))
                            ->value1 = tddAckNackval_g[3];
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->release8Param.harqBuffer[0]))
                            ->value2 = tddAckNackval_g[3];
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->release8Param.harqBuffer[0]))
                            ->value3 = tddAckNackval_g[3];
#else
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->harqBuffer[0]))->value0 =
                            tddAckNackval_g[3];
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->harqBuffer[0]))->value1 =
                            tddAckNackval_g[3];
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->harqBuffer[0]))->value2 =
                            tddAckNackval_g[3];
                        ((FAPI_tddMultiplexingHarqInfo_st *)&
                         (harqPdu_p->harqBuffer[0]))->value3 =
                            tddAckNackval_g[3];
#endif
                        if ( M == 3 || M ==4 )
                        {
                    for (count = 0; (count < (2*MAX_SUBFRAME)) &&
                            (harqFilled < M); count++)
                    {
                        if (CHECK_BIT_SET(dlAckNackBitMap
                                    [tddUlDlConfig_g[cellIndex]][sendSF],count))
                        {
                            if ( ((tddUlDlConfig_g[cellIndex] == 2)&& (((count % MAX_SUBFRAME) == 9 ) || ((count % MAX_SUBFRAME) == 4 ) )) ||
                                 ((tddUlDlConfig_g[cellIndex] == 4)&& ( ((count % MAX_SUBFRAME) == 0 ) || ((count % MAX_SUBFRAME) == 7 ) )) ||
                                 ((tddUlDlConfig_g[cellIndex] == 3)&&  ((count % MAX_SUBFRAME) == 5 ) )
                               )
                            {
                            for ( i = 0;i<M;i++ )
                            {
                            if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].
                                    scheduledSF == (count % MAX_SUBFRAME))
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value0 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[i].value0&
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->value0 =
                                    tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value0&
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
#endif
                                 break;
                            }
                            }
                            }
                            if ( ((tddUlDlConfig_g[cellIndex] == 2)&&
                                 (((count % MAX_SUBFRAME) == 0 ) || ((count % MAX_SUBFRAME) == 5 ) )) ||
                                 ((tddUlDlConfig_g[cellIndex] == 4)&&
                                 (((count % MAX_SUBFRAME) == 4 ) || ((count % MAX_SUBFRAME) == 8 ) )) ||
                                 ((tddUlDlConfig_g[cellIndex] == 3)&&
                                 ((count % MAX_SUBFRAME) == 6 ) )
                               )
                            {
                            for ( i = 0;i<M;i++ )
                            {
                            if (harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].scheduledSF
                                    == (count % MAX_SUBFRAME))
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                ((FAPI_tddMultiplexingHarqInfo_st *)
                                 &(harqPdu_p->release8Param.harqBuffer[0]))
                                    ->value1 = tddAckNackval_g[harqIndNode_p->
                                    harqPduInfo.multiplexingHarqBuffer[i].value0
                                    & harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->value1 =
                                    tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
#endif
                            }
                            }
                            }
                            if ( ((tddUlDlConfig_g[cellIndex] == 2)&&
                                ( ((count % MAX_SUBFRAME) == 3 ) || ((count % MAX_SUBFRAME) == 8 ) )) ||
                                 ((tddUlDlConfig_g[cellIndex] == 4)&&
                                 (((count % MAX_SUBFRAME) == 5 ) || ((count % MAX_SUBFRAME) == 9 ) )) ||
                                 ((tddUlDlConfig_g[cellIndex] == 3)&&
                                 ((count % MAX_SUBFRAME) == 1 ) )
                               )
                            {
                            for ( i = 0;i<M;i++ )
                            {
                            if (harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].scheduledSF
                                    == (count % MAX_SUBFRAME))
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))->value2
                                    = tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value0
                                    & harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->harqBuffer[0]))->value2 =
                                    tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
#endif
                            }
                            }
                            }
                            if ( ((tddUlDlConfig_g[cellIndex] == 2)&&
                                 (((count % MAX_SUBFRAME) == 1 ) || ((count % MAX_SUBFRAME) == 6 ) ))||
                                 ((tddUlDlConfig_g[cellIndex] == 4)&&
                               ( ((count % MAX_SUBFRAME) == 1 ) || ((count % MAX_SUBFRAME) == 6 ) ))
                               )
                            {
                            for ( i = 0;i<M;i++ )
                            {
                            if (harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].scheduledSF
                                    == (count % MAX_SUBFRAME))
                            {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                ((FAPI_tddMultiplexingHarqInfo_st *)&
                                 (harqPdu_p->release8Param.harqBuffer[0]))->value3
                                    = tddAckNackval_g[harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].value0&
                                            harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
#else
                                ((FAPI_tddMultiplexingHarqInfo_st *)
                                 &(harqPdu_p->harqBuffer[0]))->value3 =
                                    tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value0 &
                                    harqIndNode_p->harqPduInfo.
                                    multiplexingHarqBuffer[i].value1];
#endif
                            }
                            }
                            }
                            harqFilled++;
                        }
                        }
                        }
                        else
                        {
                        UInt8 temp = 255;
                        for (count = 0; (count < (2*MAX_SUBFRAME)) && 
                                (harqFilled < M); count++)
                        {
                            if (CHECK_BIT_SET(dlAckNackBitMap
                                        [tddUlDlConfig_g[cellIndex]][sendSF],count))
                            {
                                for ( i = 0;i<M;i++ )
                                {
                                temp = tddHarqMuxIndex[tddUlDlConfig_g[cellIndex]][(count % MAX_SUBFRAME)];
                                if ( temp == 255 ) 
                                ltePanic("panic case\n");
                                if (harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[i].
                                        scheduledSF == (count % MAX_SUBFRAME))
                                {
                                    if ( temp == 0 ) 
                                    {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->release8Param.harqBuffer[0]))
                                        ->value0 = tddAckNackval_g[harqIndNode_p->
                                        harqPduInfo.multiplexingHarqBuffer[i].value0 & 
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#else
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->harqBuffer[0]))->value0 = 
                                        tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value0 & 
                                        harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#endif
                                }
                                    if ( temp == 1 )
                                {
#if defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                                    ((FAPI_tddMultiplexingHarqInfo_st *)
                                     &(harqPdu_p->release8Param.harqBuffer[0]))
                                        ->value1 = tddAckNackval_g[harqIndNode_p->
                                        harqPduInfo.multiplexingHarqBuffer[i].value0 
                                        & harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#else
                                    ((FAPI_tddMultiplexingHarqInfo_st *)&
                                     (harqPdu_p->harqBuffer[0]))->value1 = 
                                        tddAckNackval_g[harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value0 
                                        & harqIndNode_p->harqPduInfo.
                                        multiplexingHarqBuffer[i].value1];
#endif
                                }
                                }
                                }
                            }
                        }
                        }
                    }
#endif
                }
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                harqPduOffSet = harqPduOffSet + 12 + 
                    sizeof(FAPI_tddMultiplexingHarqInfoR9_st) * 
                    (harqPdu_p->release9Param.numOfAckNack);
                mode_len = sizeof(FAPI_tddMultiplexingHarqInfoR9_st) * 
                    harqPdu_p->release9Param.numOfAckNack;
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                harqPduOffSet += 16;
                mode_len = sizeof(FAPI_tddMultiplexingHarqInfo_st);
#else
                harqPduOffSet += 10;
                mode_len = sizeof(FAPI_tddMultiplexingHarqInfo_st);
#endif
            }
            /* SPR 19679: TDD HARQ Multiplexing Changes End */
            /* TDD special bundling changes start*/
            else if(SPL_BUNDLING == harqPdu_p->mode)
            {
                /* + SPR 14178 Changes */                
                harqSpBundleInfo_p = &(harqIndNode_p->harqPduInfo.harqBuffer);
                if(ueContextInfo_p->carrierAggrConfig.scellCount)
                {
                    UInt32 ackNackVal = FAPI_ACK;
                    UInt32 ackNackcount = 0;
                    UInt32 loopcount = 0;
                    for(loopcount = 0;loopcount < harqIndNode_p->harqPduInfo.numOfAckNack;loopcount++)
                    {
                        if(FAPI_NACK == tddAckNackval_g[harqIndNode_p->harqPduInfo.channelSelectionHarqBuffer[loopcount].value0])
                        {
                            ackNackVal &= tddAckNackval_g[harqIndNode_p->harqPduInfo.channelSelectionHarqBuffer[loopcount].value0];

                        }
                    }
                    harqSpBundleInfo_p->value0 = ackNackVal;
                    if(harqSpBundleInfo_p->value0 != FAPI_ACK)
                    {
                        ackNackVal = FAPI_ACK;
                    }

                    if(ackNackVal == FAPI_ACK)
                    {
                        harqSpBundleInfo_p->value0 = tddHarqSpecialBudlingMap_g[harqIndNode_p->harqPduInfo.numOfAckNack];
                    }
                }
                else
                {
                    /*19679*/
                    ulUeContextInfo_p = getUEContext(harqPdu_p->rnti, cellIndex);

                    if ( ulUeContextInfo_p->ackNackMode == MULTIPLEXING)
                    {
                        UInt32 ackNackVal = FAPI_ACK;
                        UInt32 ackNackcount = 0;
                        UInt32 loopcount = 0;
                        for(loopcount = 0;loopcount < harqIndNode_p->harqPduInfo.numOfAckNack;loopcount++)
                        {
                            if(FAPI_NACK == tddAckNackval_g[harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[loopcount].value0])
                            {
                                ackNackVal &= tddAckNackval_g[harqIndNode_p->harqPduInfo.multiplexingHarqBuffer[loopcount].value0];

                            }
                        }
                        harqSpBundleInfo_p->value0 = ackNackVal;
                        if(harqSpBundleInfo_p->value0 != FAPI_ACK)
                        {
                            ackNackVal = FAPI_ACK;
                        }

                        if(ackNackVal == FAPI_ACK)
                        {
                            harqSpBundleInfo_p->value0 = tddHarqSpecialBudlingMap_g[harqIndNode_p->harqPduInfo.numOfAckNack];
                        }

                    }
                    else
                    {
                    /*19679*/

                    /* SPR 8081 fix start */
                    if ((FAPI_NACK == tddAckNackval_g[harqSpBundleInfo_p->value0])
                            ||
                            ((harqIndNode_p->harqPduInfo.numOfAckNack > 1) && 
                             (FAPI_NACK == tddAckNackval_g[harqIndNode_p->harqPduInfo.harqBuffer.value1])))
                    /* SPR 8081 fix end */
                    {
                        harqSpBundleInfo_p->value0 = 2;
                    }
                    else
                    {
                        harqSpBundleInfo_p->value0 = tddHarqSpecialBudlingMap_g[harqIndNode_p->harqPduInfo.numOfAckNack];
                    }
                    }
                }
                /* - SPR 14178 Changes */                

                /* SPR 11621 Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                ((FAPI_tddSpecialBundlingHarqInfo_st*)
                 &(harqPdu_p->release9Param.harqBuffer[0]))->value0 = harqSpBundleInfo_p->value0;
      /*TDD_FAPI_2.4 changes  START*/  
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
                ((FAPI_tddSpecialBundlingHarqInfo_st*)
                 &(harqPdu_p->release8Param.harqBuffer[0]))->value0 = harqSpBundleInfo_p->value0;
      /*TDD_FAPI_2.4 changes  END*/  
#else
                ((FAPI_tddSpecialBundlingHarqInfo_st*)
                 &(harqPdu_p->harqBuffer[0]))->value0 = harqSpBundleInfo_p->value0;
#endif
                /* SPR 11621 End */

                mode_len = sizeof(FAPI_tddSpecialBundlingHarqInfo_st);
                /*TDD_FAPI_2.4 changes  START*/
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))

                harqPduOffSet += 16;

#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)

                harqPduOffSet += 16;

#else
		/* SPR 12138 Fix Start */
                harqPduOffSet += 9;
		/* SPR 12138 Fix End */
#endif                

            }
/* TDD special bundling changes end*/
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
            fprintf(stderr,"\n\n\n####har indication pdu for rnti = %d," 
                    "at index = %d harq = %d at sfnsf = 0x%x\n\n\n\n\n", 
                    harqIndNode_p->harqPduInfo.rnti,qIndex, 
                    ((FAPI_tddBundlingHarqInfo *)
                     harqPdu_p->harqBuffer)->value0, 
                    harqIndBody_p->sfnsf);
#endif
            /* SPR 11771 Start */
	    /* SPR 12138 Fix Start */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
            apiMsgBodyLen += sizeof(FAPI_tddHarqPduIndicationR9_st) + mode_len - 4;
                /*TDD_FAPI_2.4 changes  START*/
#elif defined(FAPI_4_0_COMPLIANCE) && defined(FAPI_RELEASE8)
            apiMsgBodyLen += sizeof(FAPI_tddHarqPduIndicationR8_st) + mode_len - 4;
                /*TDD_FAPI_2.4 changes  END*/
#else
            apiMsgBodyLen += sizeof(FAPI_tddHarqPduIndication_st) + mode_len - 4;
#endif
	    /* SPR 12138 Fix End */
            /* SPR 11771 End */
            freeMemPool(harqIndNode_p);
            harqIndNode_p = PNULL;
        }

        harqIndBody_p->sfnsf = MAC_PHY_CONVERT_16(sfnSfTemp);
        harqIndBody_p->numOfHarq = MAC_PHY_CONVERT_16(numOfHarq);
        apiMsgLen += apiMsgBodyLen;
        l1ApiMsg_p->msgLen= MAC_PHY_CONVERT_16(apiMsgBodyLen);
        if ( 0 < numOfHarq )
        {
            sendDatatoPeerMac(start_p, apiMsgLen, cellIndex);
        }
        numOfHarq = 0;

#endif

        /************ Send RACH Indication ************************/
        /*SPR 11549 fix start */
        UInt8 rachQIdx = 0;
#ifdef FDD_CONFIG
        rachQIdx = (SFN_g[cellIndex] * MAX_SUBFRAME + SF_g[cellIndex] ) % 
            MAX_RACH_ARRAY;
#elif TDD_CONFIG
        rachQIdx = qIndex;
#endif
        queueCount = sQueueCount(&(rachIndQueue[cellIndex][rachQIdx]));
        while ( queueCount-- )
        {

            rachIndNode_p = ( FAPI_ulRachIndicationNode_st *) 
                popNode(&(rachIndQueue[cellIndex][rachQIdx]));
            /*SPR 11549 fix end */
            if ( PNULL == rachIndNode_p )
            {
                fprintf(stderr,"Error!! rachIndicationNode pointer is null\n");
                continue;
            }
            sendDatatoPeerMac(rachIndNode_p->rachInd_p, 
                    rachIndNode_p->msgLen +  
                    MAC_PHY_CONVERT_16(sizeof(FAPI_VendorSpecificForRACHInd_st))+ 4, 
                    cellIndex);
            freeMemPool(rachIndNode_p->rachInd_p);
            rachIndNode_p->rachInd_p = PNULL;
            freeMemPool(rachIndNode_p);
            rachIndNode_p = PNULL;
        }


        /*********** Send SRS Indication ****************************/
        /* ULA_CHG */
        UInt8 prbPosition = 0;
        UInt8 modFour = 0;
        ueContextForUplink *ueContextInf_p = PNULL;
        numOfUe = 0;
        /* ULA_CHG */
        srsQIndex = SF_g[cellIndex];
        apiMsgLen = 0;
        queueCount =sQueueCount(&srsIndQueue[cellIndex][srsQIndex]);

        /*CLPC_CHG*/
        SInt16 tempSnr = 0;
        /*CLPC_CHG*/

        if(queueCount)
        {
            start_p = srsIndBuffer;
            sendBuffer_p = srsIndBuffer;
            l1ApiMsg_p = ( FAPI_l1ApiMsg_st *)sendBuffer_p;
            l1ApiMsg_p->msgId = PHY_UL_SRS_INDICATION;
            l1ApiMsg_p->lenVendorSpecific = 0;
            apiMsgLen += L1_PARTIAL_API_MSG_SIZE;
            apiMsgBodyLen = 4;
            /*FAPI2_1 changes start*/
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
            srsIndBody_p = (FAPI_srsIndicationR9_st *) &(l1ApiMsg_p->msgBody[0]);
            srsPdu_p = (FAPI_srsPduIndicationR9_st *)&(srsIndBody_p->srsPduInfo[0]);
#else
            srsIndBody_p = (FAPI_srsIndication_st *) &(l1ApiMsg_p->msgBody[0]);
            srsPdu_p = (FAPI_srsPduIndication_st *)&(srsIndBody_p->srsPduInfo[0]);
#endif

            /*FAPI2_1 changes end*/

            srsIndBody_p = (FAPI_srsIndication_st *) &(l1ApiMsg_p->msgBody[0]);
            srsPdu_p = (FAPI_srsPduIndication_st *)&(srsIndBody_p->srsPduInfo[0]);

            while(queueCount--)
            {
                srsIndNode_p = ( FAPI_ulSrsIndicationNode_st * )\ 
                    popNode ( &(srsIndQueue[cellIndex][srsQIndex]) );
                /* ULA_CHG */
                ueContextInf_p = getUEContext(srsIndNode_p->rnti, cellIndex);
                if ( (PNULL == srsIndNode_p) || (PNULL == ueContextInf_p) )
                {
                    fprintf(stderr,"Error..!! pop node in srsQueue at index %d is null\n", srsQIndex );
                    continue;
                }
                /* ULA_CHG */
                srsIndBody_p->sfnsf = MAC_PHY_CONVERT_16(srsIndNode_p->sfnsf);

                numOfUe++;

                srsPdu_p->handle = MAC_PHY_CONVERT_32(srsIndNode_p->handle);
                srsPdu_p->rnti = MAC_PHY_CONVERT_16(srsIndNode_p->rnti);
                srsPdu_p->dopplerEstimation = MAC_PHY_CONVERT_16(DOPPLER_ESTIMATION);
                /* + SPR 11024 Fix */ 
                srsPdu_p->timingAdvance =
                    MAC_PHY_CONVERT_16(taValues_g[cellIndex].taSrs[(taCntr++)%taValues_g[cellIndex].numTaSrs]); /* SRS_TA */           
                /* - SPR 11024 Fix */ 
                /*FAPI2_1 changes start*/
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                srsPdu_p->release9Param.timingAdvanceR9 = 
                    MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].rel9TASrs
                            [(rel9TaCntr++)%rel9TaValues_g[cellIndex].
                            numTaSrs]); 
                /* SRS_TA */

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"Timing Advance R9 in SRS INDICATION [%d]\n",srsPdu_p->release9Param.timingAdvanceR9);
#endif
#endif
                /*FAPI2_1 changes end*/

                /* ULA_CHG */

                /* + TM7_8 Changes Start */
                numOfUes++;
                aoaRel9TAInfoForUEs[numOfUes - 1].rnti = srsIndNode_p->rnti; 
                idx = 0;
                for(idx = 0;idx < MAX_NUM_ANTENNA ;idx++)
                { 
                    if(angleOfArrivalValuesIndex_g[cellIndex] == MAX_SF_VALUE)
                    {
                        angleOfArrivalValuesIndex_g[cellIndex] = 0;
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[idx] = \
                                                                   angleOfArrivalValues_g[cellIndex][idx]\
                                                                   [angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                    else
                    {
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[idx] = \
                                                                   angleOfArrivalValues_g[cellIndex][idx]\
                                                                   [angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                }
                angleOfArrivalValuesIndex_g[cellIndex]++;
                /* + E_CID_5.3 */
                aoaRel9TAInfoForUEs[numOfUes-1].timingAdvanceR9 = 
                    MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].rel9TASrs
                            [(rel9TaCntr++)%rel9TaValues_g[cellIndex].
                            numTaSrs]); 
                /* - E_CID_5.3 */
                /* + TM7_8 Changes End */
                if (srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth > 
                        cellConfigUeSim_g[cellIndex].ulAvailableRBs)
                {   
                    fprintf(stderr,"srs profile bandwidth > cell configured Bandwidth,\
                            reconfiguring srs bw = srs bw % cell bw\n");

                    srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth
                        = srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth
                        % cellConfigUeSim_g[cellIndex].ulAvailableRBs;
                }

                srsPdu_p->numOfRB =  srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                    [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth;

                if (ueContextInf_p->startPosition >= cellConfigUeSim_g[cellIndex].ulAvailableRBs)
                {
                    //fprintf(stderr,"ueContext startPosition > cell configured Bandwidth,\ 
                    //        reconfiguring ueContext start pos = ueContext start pos  % cell bw\n");
                    ueContextInf_p->startPosition = ueContextInf_p->startPosition % 
                        cellConfigUeSim_g[cellIndex].ulAvailableRBs;
                }

                /*fprintf(stderr,"[%s] For ueIdx %d, ueContextInf_p->ueProfileId %d,
                  ueContextInf_p->startPosition %d,ueContextInf_p->enableHopping %d,
                  srsPdu_p->numOfRB %d\n",__func__,ueContextInf_p->ueIdx, 
                  ueContextInf_p->ueProfileId, ueContextInf_p->startPosition, 
                  ueContextInf_p->enableHopping,srsPdu_p[numOfUe - 1].numOfRB);*/

                srsPdu_p->rbStart = ueContextInf_p->startPosition;
                if (CLPC_PUSCH_ENABLE)
                {
                    numRb = 0;
                    maxRb = srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth;
                }
                else
                {
                    numRb = ueContextInf_p->startPosition;
                    maxRb = srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth
                        + ueContextInf_p->startPosition;
                }
                //fprintf(stderr, "MAX RB [%d] Number of RB [%d]\n", maxRb, numRb );

                prbPosition = 0;

                while (numRb < maxRb)
                {
                    /*CLPC_CHG*/
                    if (CLPC_PUSCH_ENABLE)
                    {

                        tempSnr = srsSinrValues_g[srsProfileInfo_g
                            [ueProfileInfo_g[cellIndex][ueContextInf_p->ueProfileId].
                            srsProfileId].sinrSeq[0]][numRb]
                            + (TPC_TO_SINR_CORR_PUSCH_STEP 
                                    * (ueContextInf_p->tpcPUSCH));
                        //fprintf(stderr,"tempSnr=%d\n",tempSnr);

                        if(tempSnr < 0)
                        {
                            srsPdu_p->snr[prbPosition++] = 0;
                        }
                        else if(tempSnr > 255)
                        {
                            srsPdu_p->snr[prbPosition++] = 255;
                        }
                        else
                        { 
                            srsPdu_p->snr[prbPosition++] = tempSnr;
                        }
                        //fprintf(stderr,"SRS value=%d,srsPdu_p->snr=%d\n",srsSinrValues_g[srsProfileInfo_g[ueProfileInfo_g[ueContextInf_p->ueProfileId].srsProfileId].sinrSeq[0]][numRb],srsPdu_p->snr[prbPosition - 1]);
                    }
                    else
                    {
                        srsPdu_p->snr[prbPosition++] = 
                            srsSinrValues_g[srsProfileInfo_g
                            [ueProfileInfo_g[cellIndex]
                            [ueContextInf_p->ueProfileId].srsProfileId].
                            sinrSeq[ueContextInf_p->srsSeqUsedIdx]][numRb];
                    }
                    /*CLPC_CHG*/
                    if(numRb == (cellConfigUeSim_g[cellIndex].ulAvailableRBs-1))
                    {
                        maxRb = maxRb - numRb;
                        numRb = 0;
                        //fprintf(stderr, " Cell Configured case hit MAX RB [%d] Number of RB [%d]\n", maxRb, numRb );
                    }
                    else
                    {
                        numRb++;   
                    }
                }

                if(ueContextInf_p->enableHopping)
                {
                    ueContextInf_p->startPosition = 
                        (ueContextInf_p->startPosition + srsProfileInfo_g
                         [ueProfileInfo_g[cellIndex][ueContextInf_p->ueProfileId]
                         .srsProfileId].srsBandwidth) % 
                        cellConfigUeSim_g[cellIndex].ulAvailableRBs;
                    ueContextInf_p->hoppedBw += srsProfileInfo_g[ueProfileInfo_g
                        [cellIndex][ueContextInf_p->ueProfileId].srsProfileId]
                        .srsBandwidth;

                    if( ueContextInf_p->hoppedBw >= cellConfigUeSim_g[cellIndex].ulAvailableRBs) 
                    {
                        ueContextInf_p->startPosition = 
                            srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                            [ueContextInf_p->ueProfileId].srsProfileId].
                            startPosition;
                        ueContextInf_p->hoppedBw = 0;
                        ueContextInf_p->srsSeqUsedIdx = 
                            //(ueContextInf_p->srsSeqUsedIdx + 1) %MAX_SRS_SINR_PROFILES;
                            ++ueContextInf_p->srsSeqUsedIdx % srsSinrProfileNum;
                    }
                }
                else
                {
                    ueContextInf_p->srsSeqUsedIdx = 
                        //(ueContextInf_p->srsSeqUsedIdx + 1) %MAX_SRS_SINR_PROFILES;
                        ++ueContextInf_p->srsSeqUsedIdx % srsSinrProfileNum;
                }
#if 0
                modFour = srsProfileInfo_g[ueProfileInfo_g
                    [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth % 4;
#endif
                 /* + E_CID_5.3 */
                 /* - E_CID_5.3 */ 
                //apiMsgBodyLen += sizeof(FAPI_srsPduIndication_st) +   srsPdu_p->numOfRB - 4;
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                apiMsgBodyLen += sizeof(FAPI_srsPduIndicationR9_st) + (srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth - 4 )  ;
                srsPdu_p = (FAPI_srsPduIndicationR9_st *)((UInt8*)srsPdu_p  + 
                        (sizeof(FAPI_srsPduIndicationR9_st) +   srsPdu_p->numOfRB - 4));
#else
                apiMsgBodyLen += sizeof(FAPI_srsPduIndication_st) + (srsProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ueContextInf_p->ueProfileId].srsProfileId].srsBandwidth - 4 )  ;
                srsPdu_p = (FAPI_srsPduIndication_st *)((UInt8*)srsPdu_p  + 
                        (sizeof(FAPI_srsPduIndication_st) +   srsPdu_p->numOfRB - 4));
#endif



                /* ULA_CHG */
                freeMemPool(srsIndNode_p);
                srsIndNode_p = PNULL;

            }
            srsIndBody_p->numOfUe = MAC_PHY_CONVERT_16(numOfUe);
            numOfUe =0;
            /* +- SPR 18467 */
            /* Padding length added */
            apiMsgBodyLen += (apiMsgBodyLen%4)?(4 - apiMsgBodyLen%4):0;
            /* +- SPR 18467 */
            apiMsgLen += apiMsgBodyLen;
            l1ApiMsg_p->msgLen= MAC_PHY_CONVERT_16(apiMsgBodyLen);
            /* + TM7_8 Changes Start */
            UInt8 totalLen = 0;
            /* + E_CID_5.3 */
            if(numOfUes)
            {
    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
                vendorSpecificData_p = (FAPI_VendorSpecificR9_st *) (&l1ApiMsg_p->msgBody[0] + apiMsgBodyLen);
                l1ApiMsg_p->lenVendorSpecific = MAC_PHY_CONVERT_16((sizeof(FAPI_AOA_RecievedForUE_st) * numOfUes) + 4);
#else

                vendorSpecificData_p = (FAPI_VendorSpecific_st *) (&l1ApiMsg_p->msgBody[0] + apiMsgBodyLen);
                l1ApiMsg_p->lenVendorSpecific = MAC_PHY_CONVERT_16((sizeof(FAPI_AOA_REL9TARecievedForUE_st) * numOfUes) + 4);
#endif

                /* +- SPR 18268 */
                UInt16 index = 0;
                /* +- SPR 18268 */
                vendorSpecificData_p->ueMeasInfoForUEs.numOfUEs = MAC_PHY_CONVERT_16(numOfUes);
                for(index = 0;index < numOfUes ; index++)
                {

    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
                    totalLen += (sizeof(FAPI_AOA_RecievedForUE_st));
#else
                    totalLen += (sizeof(FAPI_AOA_REL9TARecievedForUE_st));
#endif
                    if (totalLen >= 252)
                    {
                        l1ApiMsg_p->lenVendorSpecific =  MAC_PHY_CONVERT_16(244);
                        vendorSpecificData_p->ueMeasInfoForUEs.numOfUEs = MAC_PHY_CONVERT_16(20);
                        break;                     
                    }     
    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE) 
    /*SPR 13791 changes end */
                    aoaRel9TAInfoForUE = &vendorSpecificData_p->ueMeasInfoForUEs.aoaRel9Info[index];
#else
                    aoaRel9TAInfoForUE = &vendorSpecificData_p->ueMeasInfoForUEs.aoaRel9TAInfo[index];
#endif
                    aoaRel9TAInfoForUE->rnti = aoaRel9TAInfoForUEs[index].rnti;
                    aoaRel9TAInfoForUE->AoA[0] = aoaRel9TAInfoForUEs[index].AoA[0];
                    aoaRel9TAInfoForUE->AoA[1] = aoaRel9TAInfoForUEs[index].AoA[1];
                    aoaRel9TAInfoForUE->AoA[2] = aoaRel9TAInfoForUEs[index].AoA[2];
                    aoaRel9TAInfoForUE->AoA[3] = aoaRel9TAInfoForUEs[index].AoA[3];
    /*SPR 13791 changes start */
#if (!defined(FAPI_4_0_COMPLIANCE))
    /*SPR 13791 changes end */
                    aoaRel9TAInfoForUE->timingAdvanceR9 = aoaRel9TAInfoForUEs[index].timingAdvanceR9; 
#endif
                }


                numOfUes = 0;
                /* - TM7_8 Changes End */
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"======================\n");
                fprintf(stderr,"srs sent to MAC on current SF = %d current SFN = %d qIndex = %d\n",SF_g, SFN_g, qIndex);
                fprintf(stderr,"data SF = %d SFN = %d\n",((  srsIndBody_p->sfnsf & FAPI_SFN_MASK )>>FAPI_SFN_VALUE_SHIFT),  srsIndBody_p->sfnsf & FAPI_SF_MASK);
#endif
                /* + TM7_8 Changes Start */
                sendDatatoPeerMac(sendBuffer_p, apiMsgLen +\
                        l1ApiMsg_p->lenVendorSpecific, cellIndex);
                /* - TM7_8 Changes End */
            }
            else
            {
                sendDatatoPeerMac(sendBuffer_p, apiMsgLen, cellIndex);
            }
            /* - E_CID_5.3 */

        }

        /******* send CRC Indication ********************************/

        queueCount = sQueueCount(&(crcIndQueue[cellIndex][qIndex]));
        if(queueCount)
        {
            start_p = crcIndBuffer;
            sendBuffer_p = crcIndBuffer;
            apiMsgLen = 0;
            /*L1 Header is prepared first*/
            l1ApiMsg_p = ( FAPI_l1ApiMsg_st *)sendBuffer_p;
            l1ApiMsg_p->msgId = PHY_UL_CRC_INDICATION;
            l1ApiMsg_p->lenVendorSpecific = 0;
            /*fapiSendCrcIndication */
            crcIndBody_p = (FAPI_crcIndication_st *) &(l1ApiMsg_p->msgBody[0]);
            crcPdu_p = ( FAPI_crcPduIndication_st *)&(crcIndBody_p->crcPduInfo[0]);
            apiMsgLen += L1_PARTIAL_API_MSG_SIZE;
            apiMsgBodyLen = 4;

            while ( queueCount-- )
            {

                crcIndNode_p = ( FAPI_ulCrcIndicationNode_st * ) 
                    popNode ( &(crcIndQueue[cellIndex][qIndex]) );
                if ( PNULL == crcIndNode_p )
                {
                    //fprintf(stderr,"Error..!! pop node in crcQueue at index %d is null\n", qIndex );
                    continue;
                }
                crcIndBody_p->sfnsf = MAC_PHY_CONVERT_16(crcIndNode_p->sfnsf);
                numOfCrc++;
                crcPdu_p[numOfCrc - 1].handle = 
                    MAC_PHY_CONVERT_32(crcIndNode_p->crcPduInfo.handle);
                crcPdu_p[ numOfCrc - 1 ].rnti = 
                    MAC_PHY_CONVERT_16(crcIndNode_p->crcPduInfo.rnti);
                crcPdu_p[ numOfCrc - 1 ].crcFlag = 
                    crcIndNode_p->crcPduInfo.crcFlag;
                apiMsgBodyLen += sizeof(FAPI_crcPduIndication_st);
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"======================\n");
                fprintf(stderr,"crc sent to MAC on current SF = %d current SFN = %d qIndex = %d rnti %d\n",SF_g, SFN_g, qIndex,crcIndNode_p->crcPduInfo.rnti); 
                fprintf(stderr,"data SF = %d SFN = %d\n",((  crcIndBody_p->sfnsf & FAPI_SFN_MASK )>>FAPI_SFN_VALUE_SHIFT),  crcIndBody_p->sfnsf & FAPI_SF_MASK); 
#endif
                /*crc changes begin*/
                ueContextForUplink *ueContextCrcInfo_p = NULL;
                ueContextCrcInfo_p = getUEContext(crcIndNode_p->crcPduInfo.rnti, cellIndex);
                if(PNULL == ueContextCrcInfo_p )
                {
                    fprintf(stderr, "crc processing, UE CONTEXT is Null for rnti %d\n",crcIndNode_p->crcPduInfo.rnti);
                }
                else
                {
                    ueContextCrcInfo_p->crcIndRefNode_p[qIndex] = PNULL;
                    /* SPR 2333 Changes Begin */
#ifdef FDD_CONFIG
                    /* Not setting acknack flag for tdd for two reasons:
                     * 1. nack in uplink is not properly implemented
                     * 2. qIndex cannot be used in case of harqinfo (ranges are different - 80 vs 8)
                     */
                    ueContextCrcInfo_p->ulharqInfo[qIndex].ackNack = crcIndNode_p->crcPduInfo.crcFlag;
#endif
                    /* SPR 2333 Changes End */
                }
                /*crc changes end*/

                freeMemPool(crcIndNode_p);
                crcIndNode_p = PNULL;
            }
            apiMsgLen += apiMsgBodyLen;
            l1ApiMsg_p->msgLen= MAC_PHY_CONVERT_16(apiMsgBodyLen);
            crcIndBody_p->numOfCrc = MAC_PHY_CONVERT_16(numOfCrc);
            sendDatatoPeerMac(sendBuffer_p, apiMsgLen, cellIndex);
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
            if(numOfCrc > 1)
            {
                fprintf(stderr,"\n Sent %d CRC Packets",numOfCrc);
            }
#endif
            numOfCrc = 0;
        }
        /**********Sending ULSCH pdu ***************/
        sendUlData(qIndex, cellIndex);

        /*********** send SR Indication ***************/
        queueCount = sQueueCount(&srIndQueue[cellIndex][qIndex]);

        if ( queueCount )
        {
            ueContextForUplink *ueContext_p = PNULL;
            start_p = srIndBuffer;
            apiMsgLen = 0;
            sendBuffer_p = srIndBuffer;
            /*fapiSendSrIndication */
            l1ApiMsg_p = ( FAPI_l1ApiMsg_st *)sendBuffer_p;
            l1ApiMsg_p->msgId = PHY_UL_RX_SR_INDICATION;
            l1ApiMsg_p->lenVendorSpecific = 0;
            apiMsgLen += L1_PARTIAL_API_MSG_SIZE;
            apiMsgBodyLen = 4;
            srIndBody_p = (FAPI_rxSRIndication_st*) &(l1ApiMsg_p->msgBody[0]);
            srPdu_p = ( FAPI_srPduIndication_st *)&(srIndBody_p->srPduInfo[0]);

            while ( queueCount-- )
            { 
                srIndNode_p = ( FAPI_ulSrIndicationNode_st * ) 
                    popNode ( &srIndQueue[cellIndex][qIndex] );    
                if ( PNULL == srIndNode_p )
                {
                    fprintf(stderr,"Error..!! pop node in srQueue at index %d is null\n", qIndex );
                    continue;
                }
                srIndBody_p->sfnsf = MAC_PHY_CONVERT_16(srIndNode_p->sfnsf);
                numOfSr++;
                srPdu_p[numOfSr - 1].handle = 
                    MAC_PHY_CONVERT_32(srIndNode_p->srPduInfo.handle);
                srPdu_p[ numOfSr - 1 ].rnti = 
                    MAC_PHY_CONVERT_16(srIndNode_p->srPduInfo.rnti);
                apiMsgBodyLen += sizeof(FAPI_srPduIndication_st);
                /* Tauheed start multi SR fix start */
#ifdef TDD_CONFIG
                ueContext_p = getUEContext(srIndNode_p->srPduInfo.rnti, cellIndex);
                if(ueContext_p)
                {
                    ueContext_p->srTriggered = FALSE;
                }
#endif
                /* Tauheed start multi SR fix end */
                if(srIndNode_p != PNULL)
                {
                   /* Node should be freed irrespective of UESIM_PDCP_THRED*/
                    freeMemPool(srIndNode_p);
                    srIndNode_p = PNULL;
                }
            }
            srIndBody_p->numOfSr = MAC_PHY_CONVERT_16(numOfSr);
            apiMsgLen += apiMsgBodyLen;
            l1ApiMsg_p->msgLen= MAC_PHY_CONVERT_16(apiMsgBodyLen);
            sendDatatoPeerMac(sendBuffer_p, apiMsgLen, cellIndex);  
            //fprintf(stderr,"SR Sent to MAC at sfn[%d], sf[%d].....!!!!\n",SFN_g, SF_g);
            // Saurabh	    
        }
        /* send CQI Indication */
        /*CLPC_CHG*/
        SInt16 tempCqi;
        /*CLPC_CHG*/
        queueCount = sQueueCount(&cqiIndQueue[cellIndex][qIndex]);
        if ( queueCount )
        {
            start_p = cqiIndBuffer;
            sendBuffer_p = cqiIndBuffer;
            apiMsgLen = 0;
            /* CLPC_CHG */
            ueContextForUplink *ulUEContext_p = PNULL;
            /* CLPC_CHG */
            /*fapiSendCqiIndication */
            l1ApiMsg_p = ( FAPI_l1ApiMsg_st *)sendBuffer_p;
            l1ApiMsg_p->msgId = PHY_UL_RX_CQI_INDICATION;
            l1ApiMsg_p->lenVendorSpecific = 0;
            apiMsgLen += L1_PARTIAL_API_MSG_SIZE;
            apiMsgBodyLen = 4;
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
            cqiIndBody_p = (FAPI_rxCqiIndicationR9_st*) &(l1ApiMsg_p->msgBody[0]);
            cqiPdu_p = ( FAPI_cqiPduIndicationR9_st *)&(cqiIndBody_p->cqiPduInfo[0]);
#else
            cqiIndBody_p = (FAPI_rxCqiIndication_st*) &(l1ApiMsg_p->msgBody[0]);
            cqiPdu_p = ( FAPI_cqiPduIndication_st *)&(cqiIndBody_p->cqiPduInfo[0]);

#endif

            //cqiReport_p = start_p + 4 + 4 + sizeof(FAPI_cqiPduIndication_st);
            //*cqiReport_p = CQI_PDU_DATA;
            //*(cqiReport_p+1) = CQI_PDU_DATA;

            //apiMsgBodyLen += 2; /* for CQI report PDU */
            while ( queueCount-- )
            { 
                cqiIndNode_p = ( FAPI_cqiIndQueueNode_st * ) 
                    popNode ( &cqiIndQueue[cellIndex][qIndex] );    
                if ( PNULL == cqiIndNode_p )
                {
                    fprintf(stderr,"Error..!! pop node in cqiQueue at index %d is null\n", qIndex );
                    continue;
                }
                cqiIndBody_p->sfnsf = MAC_PHY_CONVERT_16(cqiIndNode_p->sfnsf);

                /* + CQI_5.0 */
                UInt32  sendSfnSf = 0, sendSFN = 0;
                UInt8  sendSF = 0;
              	UInt8 sendAbsReport = 0; /* EICIC +*/
                UInt8 measurementSubsetIndex = 0;/* EICIC -*/
                sendSfnSf = cqiIndBody_p->sfnsf; 
                sendSFN = sendSfnSf & FAPI_SFN_MASK;
                sendSFN >>= FAPI_SFN_VALUE_SHIFT; 
                sendSF = sendSfnSf & FAPI_SF_MASK;
                /* - CQI_5.0 */
                numOfCqi++;
                cqiPdu_p[numOfCqi - 1].handle = 
                    MAC_PHY_CONVERT_32(cqiIndNode_p->cqiPduInfo.handle);
                cqiPdu_p[ numOfCqi - 1 ].rnti = 
                    MAC_PHY_CONVERT_16(cqiIndNode_p->cqiPduInfo.rnti);

                /* + TM7_8 Changes Start */
                numOfUes++;
                aoaRel9TAInfoForUEs[numOfUes - 1].rnti = cqiIndNode_p->cqiPduInfo.rnti; 
                idx=0;
                for(idx = 0;idx < MAX_NUM_ANTENNA ;idx++)
                { 
                    if(angleOfArrivalValuesIndex_g[cellIndex] == MAX_SF_VALUE)
                    {
                        angleOfArrivalValuesIndex_g[cellIndex] = 0;
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[idx] = \
                                                                   angleOfArrivalValues_g[cellIndex][idx]\
                                                                   [angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                    else
                    {
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[idx] = \
                                                                   angleOfArrivalValues_g[cellIndex][idx]\
                                                                   [angleOfArrivalValuesIndex_g[cellIndex]];
                    }
                }
                angleOfArrivalValuesIndex_g[cellIndex]++; 
                aoaRel9TAInfoForUEs[numOfUes-1].timingAdvanceR9 =
                    MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].rel9TACqi
                            [(rel9TaCntr++)%rel9TaValues_g[cellIndex].
                            numTaCqi]); 
                /* + TM7_8 Changes End */

                /* - CL-MIMO LJA*/
                cqiPdu_p[ numOfCqi - 1].dataOffset = 
                    MAC_PHY_CONVERT_16(cqiIndNode_p->cqiPduInfo.dataOffset);
#ifndef FAPI_4_0_COMPLIANCE
                cqiPdu_p[ numOfCqi - 1].timingAdvance = 
                    cqiIndNode_p->cqiPduInfo.timingAdvance;
                cqiPdu_p[ numOfCqi - 1].ulCqi = 
                    cqiIndNode_p->cqiPduInfo.ulCqi;
                /*CLPC_CHG*/    
                /* CLPC_CHG */
#else

                cqiPdu_p[ numOfCqi - 1].cqiRiInformation.timingAdvance = 
                    cqiIndNode_p->cqiPduInfo.cqiRiInformation.timingAdvance;
                cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ulCqi = 
                    cqiIndNode_p->cqiPduInfo.cqiRiInformation.ulCqi;
                /*CLPC_CHG*/    
                /* CLPC_CHG */
                /*FAPI2_1 changes start*/
#if defined(FAPI_RELEASE9) ||defined(FAPI_RELEASE10) 
                cqiPdu_p[ numOfCqi - 1].cqiRiInformation.timingAdvanceR9 = 
                    cqiIndNode_p->cqiPduInfo.cqiRiInformation.timingAdvanceR9;
                cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported= 
                    cqiIndNode_p->cqiPduInfo.cqiRiInformation.numberOfCCReported;
                for(iterator=0;iterator< cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported;iterator++)
                {
                    cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri[iterator]=
                        cqiIndNode_p->cqiPduInfo.cqiRiInformation.ri[iterator];
                }

                /*FAPI2_1 changes end*/
#endif
#endif
                ulUEContext_p = getUEContext(cqiIndNode_p->cqiPduInfo.rnti, cellIndex);

                /* + CQI_5.0 */ 
                DLUEContext *newUEContext_p = PNULL;
                newUEContext_p = getDLUEContextFromRnti(MAC_PHY_CONVERT_16
                        (cqiPdu_p[ numOfCqi - 1 ].rnti), cellIndex);
                if(newUEContext_p == PNULL)
                {
                    return;
                }

               /*EICIC + */

#ifdef FDD_CONFIG
               numBitsAbsPattern = NUM_BITS_ABS_PATTERN;
#else

               if (UL_DL_CONFIG_0 == cellConfigUeSim_g[cellIndex].subFrameAssignment)
               {
                    numBitsAbsPattern = NUM_BITS_ABS_PATTERN;
               }
               else if (UL_DL_CONFIG_6 == cellConfigUeSim_g[cellIndex].subFrameAssignment)
               {
                    numBitsAbsPattern = NUM_BITS_ABS_PATTERN_CONFIG6;
               }
               else
               {
                    numBitsAbsPattern = NUM_BITS_ABS_PATTERN_CONFIG1_5;
               }
#endif
               /*SPR 17140 fix start*/
#ifdef FDD_CONFIG
		      measurementSubsetIndex  = (sendSFN * 10 + sendSF - 4) % numBitsAbsPattern;
#else
 		      measurementSubsetIndex  = (sendSFN * 10 + sendSF - getUplinkToGrantSubframeNumber(sendSF,cellIndex)) % numBitsAbsPattern;
#endif
               /*SPR 17140 fix end*/
             ulUEContext_p = uplinkContextInfoMap_g[newUEContext_p->ueIndex];
		     if(1 == ulUEContext_p->csiMeasurementSubset1[measurementSubsetIndex])
		     {
                	sendAbsReport = TRUE;
		     }
		     else
		     {
                	sendAbsReport = FALSE;
		     }
		
                /*EICIC -*/

                newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
/* SPR 12135 Fix Start */
                ueContextForUplink   *ulUEScellInfo_p = PNULL;
                        ulUEScellInfo_p = uplinkContextInfoMap_g[newUEContext_p->ueIndex];
                /* CLPC_CHG */
                /* RI will not be reported in SISO and Transmit diversity */
                cqirequestbit = newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF];
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
                cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported = 0;
                for(i = 0; i <  cqiIndNode_p->cqiPduInfo.cqiRiInformation.numberOfCCReported;
                        i++)
                {
                    if(cqirequestbit & 0x1)
                    {
                    if (!sendAbsReport)
	                    	{
	                        fillRIInfoAperiodic(&(newUEContext_p->dlCQIInfo),cqiPdu_p,numOfCqi,
	                              newUEContext_p->transmissionMode,i,newUEContext_p, sendSF);
	                    	}                  
	                    else
	                    	{
	                        fillRIInfoAperiodic_ABS(&(newUEContext_p->dlCQIInfo),cqiPdu_p,numOfCqi,
	                                newUEContext_p->transmissionMode,i,newUEContext_p, sendSF);
	                    	}

                        cqirequestbit = cqirequestbit & ~(0x1);
                    }
                    else if(cqirequestbit & 0x2)
                    {
                   	if (!sendAbsReport)
                    		{
	                        	fillRIInfoAperiodic(&(ulUEScellInfo_p->carrierAggrConfig.scellInfo[0]
	                                    .dlCQIInfo),cqiPdu_p,numOfCqi,
	                                ulUEScellInfo_p->carrierAggrConfig.scellInfo[0].transmissionMode,i,
	                                newUEContext_p, sendSF);

                      	}
                      	else
                      	{
                      		fillRIInfoAperiodic_ABS(&(ulUEScellInfo_p->carrierAggrConfig.scellInfo[0]
	                                    .dlCQIInfo),cqiPdu_p,numOfCqi,
	                                ulUEScellInfo_p->carrierAggrConfig.scellInfo[0].transmissionMode,i,
	                                newUEContext_p, sendSF);
                      	}

                        cqirequestbit = cqirequestbit & ~(0x2);
                    }
                }
#else
                if(cqirequestbit)
                {

                    if (!sendAbsReport)
                    	{
                        fillRIInfoAperiodic(&(newUEContext_p->dlCQIInfo),cqiPdu_p,numOfCqi,
                                newUEContext_p->transmissionMode,i,newUEContext_p, sendSF);
                    	}
                    else
                    	{
                    	    fillRIInfoAperiodic_ABS(&(newUEContext_p->dlCQIInfo),cqiPdu_p,numOfCqi,
                                newUEContext_p->transmissionMode,i,newUEContext_p, sendSF);
                    	}

                }

#endif

                DLCQIInfo scellDLCQIInfo = ulUEScellInfo_p->carrierAggrConfig.scellInfo[0].dlCQIInfo;
                if  ( (TRUE == newUEContext_p->dlCQIInfo.isULSCHPDUType[sendSF]) && 
                       ( (newUEContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[sendSF] != 0)
                         ||(scellDLCQIInfo.dlCqiPmiSizeRank_1[sendSF]!=0))) 
                {
                    if ( (newUEContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[sendSF] == newUEContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[sendSF]) &&(0 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF] )) 
                    {
                        /* Periodic report at ULSCH */
                        cqiIndNode_p->cqiPduInfo.length =  newUEContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[sendSF];                   
                    }
                    else
                    {
                        /* Aperiodic report at ULSCH with TX mode CL - MIMO */  
                        if(1 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF])
                        {
                            if (newUEContext_p->dlCQIInfo.RI == 1)
                            {
                                cqiIndNode_p->cqiPduInfo.length = newUEContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[sendSF];

                            }
                            else if ( newUEContext_p->dlCQIInfo.RI > 1 )
                            {
                                cqiIndNode_p->cqiPduInfo.length = newUEContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[sendSF];

                            }    
                            /* + SPR_14425 */
                            else
                            {
                                cqiIndNode_p->cqiPduInfo.length = newUEContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[sendSF];
                            }   
                            /* - SPR_14425 */
                        }
                        if(2 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF])
                        {
                            if (scellDLCQIInfo.RI == 1)
                            {
                                cqiIndNode_p->cqiPduInfo.length = scellDLCQIInfo.dlCqiPmiSizeRank_1[sendSF];

                            }
                            else if ( scellDLCQIInfo.RI > 1 )
                            {
                                cqiIndNode_p->cqiPduInfo.length = scellDLCQIInfo.dlCqiPmiSizeRankGT_1[sendSF];
                            }  
                            /* + SPR_14425 */
                            else
                            {
                                cqiIndNode_p->cqiPduInfo.length = scellDLCQIInfo.dlCqiPmiSizeRank_1[sendSF];                           
                            }    
                            /* - SPR_14425 */
                        }
                        if(3 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF])
                        {
                            if (newUEContext_p->dlCQIInfo.RI == 1)
                            {
                                cqiIndNode_p->cqiPduInfo.length = newUEContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[sendSF];

                            }
                            else if ( newUEContext_p->dlCQIInfo.RI > 1 )
                            {
                                cqiIndNode_p->cqiPduInfo.length = newUEContext_p->dlCQIInfo.dlCqiPmiSizeRankGT_1[sendSF];

                            }  
                            /* + SPR_14425 */
                            else
                            {
                                cqiIndNode_p->cqiPduInfo.length = newUEContext_p->dlCQIInfo.dlCqiPmiSizeRank_1[sendSF];
                            }   
                            /* - SPR_14425 */

                            if (scellDLCQIInfo.RI == 1)
                            {
                                cqiIndNode_p->cqiPduInfo.length += scellDLCQIInfo.dlCqiPmiSizeRank_1[sendSF];

                            }
                            else if ( scellDLCQIInfo.RI > 1 )
                            {
                                cqiIndNode_p->cqiPduInfo.length += scellDLCQIInfo.dlCqiPmiSizeRankGT_1[sendSF];

                            }   
                            /* + SPR_14425 */
                            else
                            {

                                cqiIndNode_p->cqiPduInfo.length += scellDLCQIInfo.dlCqiPmiSizeRank_1[sendSF];
                            }    
                            /* - SPR_14425 */

                        }

                    } //else end   
/* SPR 12135 Fix End */ 
                }    

                newUEContext_p->dlCQIInfo.isULSCHPDUType[sendSF] = FALSE;
                /* - CQI_5.0 */


                /* + CL-MIMO LJA*/
#if 0                
                if (cqiFileFp)
                {
                    /* + CQI_4.1 */
                    //cqiPdu_p[ numOfCqi - 1].length = MAC_PHY_CONVERT_16(cqiPMIReportSizeBytes_g);
                    /* - CQI_4.1 */
                    cqiPdu_p[ numOfCqi - 1].ri  = RI_g;    
                    if(ri_Toggle)
                    {
                        if(RI_swap == 0)
                        {
                            if (RI_g == 2)
                            {
                                RI_g = 1;
                            }
                            else if (RI_g == 1)
                            {
                                RI_g = 2;
                            }
                            RI_swap = 15;
                        }   
                        RI_swap--;
                        cqiPdu_p[ numOfCqi - 1].ri  = RI_g;
                    }
                }
                else
                {
                    /* + CQI_4.1 */
                    /* - CL-MIMO LJA*/
                    //cqiPdu_p[ numOfCqi - 1].length =
                    //   MAC_PHY_CONVERT_16(cqiIndNode_p->cqiPduInfo.length);
                    //cqiPdu_p[ numOfCqi - 1].length = MAC_PHY_CONVERT_16(2);
                    /* + CL-MIMO LJA*/
                    /* - CQI_4.1 */
                    cqiPdu_p[ numOfCqi - 1].ri =
                        cqiIndNode_p->cqiPduInfo.ri;
                    cqiPdu_p[ numOfCqi - 1].ri  = RI_g;    
                }
#endif                
                /* + CQI_4.1 */
                cqiPdu_p[ numOfCqi - 1].length =
                    MAC_PHY_CONVERT_16(cqiIndNode_p->cqiPduInfo.length);

                /* SPR 3709_3850 changes start */
                cqiPdu_p[numOfCqi - 1].length = (ceil((UDouble32)(cqiPdu_p[numOfCqi - 1].length)/8));        
                /* SPR 3709_3850 changes end */

                /* - CQI_4.1 */
#ifdef FAPI_4_0_COMPLIANCE                        
                if(CLPC_PUCCH_ENABLE)
                {
                    tempCqi = 
                        cqiSinrValues_g[cqiProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ulUEContext_p->ueProfileId].cqiProfileId].sinrSeq
                        [ulUEContext_p->cqiSinrSeqUsedIdx]] + 
                        (TPC_TO_SINR_CORR_PUCCH_STEP * (newUEContext_p->tpcPUCCH));
                    if(tempCqi < 0)
                    {
                        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ulCqi = 0;
                    }
                    else if(tempCqi > 255)
                    {
                        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ulCqi = 255;
                    }
                    else
                    {
                        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ulCqi = tempCqi;
                    }
                }
                else
                {
                    cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ulCqi =
                        cqiSinrValues_g[cqiProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ulUEContext_p->ueProfileId].cqiProfileId].sinrSeq
                        [ulUEContext_p->cqiSinrSeqUsedIdx]];
                }

#else
                if(CLPC_PUCCH_ENABLE)
                {
                    tempCqi = 
                        cqiSinrValues_g[cqiProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ulUEContext_p->ueProfileId].cqiProfileId].sinrSeq
                        [ulUEContext_p->cqiSinrSeqUsedIdx]] + 
                        (TPC_TO_SINR_CORR_PUCCH_STEP * (newUEContext_p->tpcPUCCH));

                    if(tempCqi < 0)
                    {
                        cqiPdu_p[ numOfCqi - 1].ulCqi = 0;
                    }
                    else if(tempCqi > 255)
                    {
                        cqiPdu_p[ numOfCqi - 1].ulCqi = 255;
                    }
                    else
                    {
                        cqiPdu_p[ numOfCqi - 1].ulCqi = tempCqi;
                    }
                }
                else
                {
                    cqiPdu_p[ numOfCqi - 1].ulCqi =
                        cqiSinrValues_g[cqiProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ulUEContext_p->ueProfileId].cqiProfileId].sinrSeq
                        [ulUEContext_p->cqiSinrSeqUsedIdx]];
                }
#endif               
                ulUEContext_p->cqiSinrSeqUsedIdx =
                    ++ulUEContext_p->cqiSinrSeqUsedIdx % cqiProfileNum;
                /* CLPC_CHG */
                /* + CL-MIMO LJA*/    
                /*cqiPdu_p[ numOfCqi - 1].ri = 
                  cqiIndNode_p->cqiPduInfo.ri;*/
                /* - CL-MIMO LJA*/

#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                apiMsgBodyLen += sizeof(FAPI_cqiPduIndicationR9_st);
#else
                apiMsgBodyLen += sizeof(FAPI_cqiPduIndication_st);
#endif
                freeMemPool(cqiIndNode_p);
                cqiIndNode_p = PNULL;
            }
            /* + CQI_4.1 */
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
            cqiReport_p = /*start_p*/ (UInt8*)cqiPdu_p+ numOfCqi * sizeof(FAPI_cqiPduIndicationR9_st);
#else
            cqiReport_p = /*start_p*/ (UInt8*)cqiPdu_p+ numOfCqi * sizeof(FAPI_cqiPduIndication_st);

#endif
            UInt32 cqiDatOffset = 0;
            UInt32 tracker = 0;/*EICIC Enhancement */
            for(queueCount = 0;queueCount < numOfCqi;queueCount++)
            {
                cqi_count = 0;
                newUEContext_p = getDLUEContextFromRnti(cqiPdu_p[queueCount].rnti
                        , cellIndex);  
                tracker =  newUEContext_p->dlCQIInfo.indexTrack;/*EICIC Enhancement */
                /* + CL-MIMO LJA*/
                /* if(cqiFileFp)
                   {read values from config file instead of hard coding*/

#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                cqiPdu_p[queueCount].dataOffset = 
                    numOfCqi * sizeof(FAPI_cqiPduIndicationR9_st) + cqiDatOffset;
#else
                    cqiPdu_p[queueCount].dataOffset = 
                        numOfCqi * sizeof(FAPI_cqiPduIndication_st) + cqiDatOffset;

#endif
                    cqiDatOffset += (cqiPdu_p[queueCount].length);
                    cqiReport_p = (UInt8*)cqiPdu_p+ cqiPdu_p[queueCount].dataOffset;
                    /* SPR 3924 changes start */
                    UInt32  sendSfnSf = 0, sendSFN = 0;
                    UInt8  sendSF = 0;
                    sendSfnSf = cqiIndBody_p->sfnsf; 
                    sendSFN = sendSfnSf & FAPI_SFN_MASK;
                    sendSFN >>= FAPI_SFN_VALUE_SHIFT; 
                    sendSF = sendSfnSf & FAPI_SF_MASK;
                /* SPR 10980 Fix Start */
                 UInt8 sendAbsReport = 0; /* EICIC +*/
                UInt8 measurementSubsetIndex = 0;/* EICIC -*/

	#ifdef FDD_CONFIG
	       numBitsAbsPattern = NUM_BITS_ABS_PATTERN;
	#else

	    if (UL_DL_CONFIG_0 == cellConfigUeSim_g[cellIndex].subFrameAssignment)
	   {
	        numBitsAbsPattern = NUM_BITS_ABS_PATTERN;
	    }
	    else if (UL_DL_CONFIG_6 == cellConfigUeSim_g[cellIndex].subFrameAssignment)
	   {
	        numBitsAbsPattern = NUM_BITS_ABS_PATTERN_CONFIG6;
	   }
	   else
	   {
	        numBitsAbsPattern = NUM_BITS_ABS_PATTERN_CONFIG1_5;
	   }
	#endif


               /*SPR 17140 fix start*/
	 #ifdef FDD_CONFIG
			measurementSubsetIndex  = (sendSFN * 10 + sendSF - 4) % numBitsAbsPattern;
	 #else
	 		 measurementSubsetIndex  = (sendSFN * 10 + sendSF - getUplinkToGrantSubframeNumber(sendSF,cellIndex)) % numBitsAbsPattern;
	 #endif
               /*SPR 17140 fix end*/

	              ulUEContext_p = uplinkContextInfoMap_g[newUEContext_p->ueIndex];

			if(1 == ulUEContext_p->csiMeasurementSubset1[measurementSubsetIndex])
			{
	                	sendAbsReport = TRUE;
	                	
			}
			else
			{
	                	sendAbsReport = FALSE;
			}
		
                /*EICIC -*/
                

              ulUEContext_p = uplinkContextInfoMap_g[ newUEContext_p->ueIndex];
                
		/* EICIC +*/
                	cqiPeriodicReportType2 = 
                    	(cqiPmiRiReportMap2_g[sendSFN].reportType[sendSF][newUEContext_p->ueIndex]);

                	
                if (ulUEContext_p->carrierAggrConfig.scellCount > 0)
                {     
                    cqiPeriodicScellReportType2 = cqiPmiRiScellReportMap2_g[0][sendSFN].reportType[sendSF][newUEContext_p->ueIndex];
                }  
               	
		if (0 == cqiPeriodicReportType2)
		{
                	cqiPeriodicReportType = 
                    	(cqiPmiRiReportMap_g[sendSFN].reportType[sendSF][newUEContext_p->ueIndex]);	         

                	               	
	                if (ulUEContext_p->carrierAggrConfig.scellCount > 0)
	                {     
	                    cqiPeriodicScellReportType =
	                         cqiPmiRiScellReportMap_g[0][sendSFN].reportType[sendSF][newUEContext_p->ueIndex];
	                }  
		}
		/* EICIC -*/
		
                /* SPR 10980 Fix End */
                /* SPR 3924 changes end */
#if 1  
                if (ULSCH_APERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF])
                {
                    /*  Aperiodic CQI Changes start*/
                    /* check for bits set in global array*/
                    /* Wrap Round the cqi_Index and */
/* SPR 12135 Fix Start */
                    
                    sizeOfCqiCsiField = aperiodicCqiCsiFieldArr[sendSFN][sendSF][newUEContext_p->ueIndex];
#ifdef FAPI_4_0_COMPLIANCE
                    if (sizeOfCqiCsiField == 1)
                    {
                        if(1 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF])
                        /* report for Pcell */
                        {
                            newUEContext_p->dlCQIInfo.ueCqiIndexNum = ( (newUEContext_p->dlCQIInfo.ueCqiIndexNum) % 
                                    ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                            count = 
                                cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                                ueProfile[newUEContext_p->dlCQIInfo.ueCqiIndexNum];
			    /*EICIC Enhancement +*/
			    tracker ++;
                            if (0 == (tracker % (cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexTracker)))
         		    {
             			newUEContext_p->dlCQIInfo.ueCqiIndexNum++;
            			tracker = 0;
        		    }
       			    newUEContext_p->dlCQIInfo.indexTrack = tracker;
			    /*EICIC Enhancement -*/
                            //newUEContext_p->dlCQIInfo.ueCqiIndexNum++;
                            newUEContext_p->dlCQIInfo.cqiReportType[sendSF] = CQI_INVALID_REPORT_TYPE;
			    /*EICIC +*/
			    if(!sendAbsReport)
			    {
                            	prepareAperiodicCqiReport(&(newUEContext_p->dlCQIInfo),
                                    cqiReport_p, &cqi_count, count, cellIndex);
			    }
		            else 
			    {
                                prepareAperiodicCqiReport_ABS(&(newUEContext_p->dlCQIInfo),
                                    cqiReport_p, &cqi_count, count, cellIndex);
			    }
			    /*EICIC -*/

                        }
                        else
                        {
                          fprintf(stderr,"\n No CSI Requested\n");
                        }
                    }

                    else if(2 == sizeOfCqiCsiField)
                    {
                        if(1 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF])
                        {
                            newUEContext_p->dlCQIInfo.ueCqiIndexNum = ( (newUEContext_p->dlCQIInfo.ueCqiIndexNum) % 
                                    ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                            count = 
                                cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                                ueProfile[newUEContext_p->dlCQIInfo.ueCqiIndexNum];
			    /*EICIC Enhancement +*/
		            tracker ++;
                            if (0 == (tracker % (cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexTracker)))
         		    {
             			newUEContext_p->dlCQIInfo.ueCqiIndexNum++;
            			tracker = 0;
        		    }
       			    newUEContext_p->dlCQIInfo.indexTrack = tracker;
			    /*EICIC Enhancement -*/
                            //newUEContext_p->dlCQIInfo.ueCqiIndexNum++;
                            newUEContext_p->dlCQIInfo.cqiReportType[sendSF] = CQI_INVALID_REPORT_TYPE;
                            /* for Pcell */
			    /*EICIC +*/
			    if(!sendAbsReport)
			    {
                            	prepareAperiodicCqiReport(&(newUEContext_p->dlCQIInfo),
                                    cqiReport_p, &cqi_count, count, cellIndex);
			    }
		            else 
			    {
                                prepareAperiodicCqiReport_ABS(&(newUEContext_p->dlCQIInfo),
                                    cqiReport_p, &cqi_count, count, cellIndex);
			    }
			    /*EICIC -*/

                        }
                        else if(2 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF])
                        {
                            ueContextForUplink *ueContextInfo_p = PNULL;
                            DLCQIInfo *scellDlCQIInfo = PNULL;
                            ueContextInfo_p = getUEContext(cqiPdu_p[queueCount].rnti, cellIndex);
                           // scellCount = ulUEContext_p->carrierAggrConfig.scellCount;
                            scellCount = ueContextInfo_p->carrierAggrConfig.scellCount;
                            scellIndex = scellCount - 1 ;

                            scellDlCQIInfo = &(ueContextInfo_p->carrierAggrConfig.scellInfo[scellIndex].dlCQIInfo);
                            scellDlCQIInfo->ueCqiIndexNum = ( (scellDlCQIInfo->ueCqiIndexNum) %
                                    ((cqiUEProfileValues_g[scellDlCQIInfo->ueCqiProfileNum].indexCount 
                                      + 1)) );
                            count = 
                                cqiUEProfileValues_g[scellDlCQIInfo->ueCqiProfileNum].
                                ueProfile[scellDlCQIInfo->ueCqiIndexNum];
			    /*EICIC Enhancement +*/
			    tracker ++;
                            if (0 == (tracker % (cqiUEProfileValues_g[scellDlCQIInfo->ueCqiProfileNum].indexTracker)))
         		    {
             			scellDlCQIInfo->ueCqiIndexNum++;
				//ewUEContext_p->dlCQIInfo.ueCqiIndexNum++;
            			tracker = 0;
        		    }
       			    scellDlCQIInfo->indexTrack = tracker;
                            /*EICIC Enhancement -*/
			    //scellDlCQIInfo->ueCqiIndexNum++;
                            scellDlCQIInfo->RI = ueContextInfo_p->carrierAggrConfig.scellInfo[scellIndex]. \
                                rankIndicator;
			    /*EICIC +*/
			    if(!sendAbsReport)
			    {
                            	prepareAperiodicCqiReport(scellDlCQIInfo, 
                                    cqiReport_p, &cqi_count, count, ueContextInfo_p->
                                    carrierAggrConfig.scellInfo[scellIndex].sCellIndex);
			    }
			    else
                            {
                                   prepareAperiodicCqiReport_ABS(scellDlCQIInfo, 
                                    cqiReport_p, &cqi_count, count, ueContextInfo_p->
                                    carrierAggrConfig.scellInfo[scellIndex].sCellIndex);

   		            }	
                        }
                        else if(3 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF])
                        {
                            newUEContext_p->dlCQIInfo.ueCqiIndexNum = ( (newUEContext_p->dlCQIInfo.ueCqiIndexNum) % 
                                    ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                            count = 
                                cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                                ueProfile[newUEContext_p->dlCQIInfo.ueCqiIndexNum];
		            /*EICIC Enhancement +*/
			    tracker ++;
                            if (0 == (tracker % (cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexTracker)))
         		    {
             			newUEContext_p->dlCQIInfo.ueCqiIndexNum++;
            			tracker = 0;
        		    }
       			    newUEContext_p->dlCQIInfo.indexTrack = tracker;
			    /*EICIC Enhancement -*/
                          //  newUEContext_p->dlCQIInfo.ueCqiIndexNum++;
                            /* CQI Report for PCELL */
		    		/*EICIC +*/
			    if(!sendAbsReport)
			    {
			    	prepareAperiodicCqiReport(&(newUEContext_p->dlCQIInfo),
                                    cqiReport_p, &cqi_count, count, cellIndex);
			    }
			    else
			    {
			    	prepareAperiodicCqiReport_ABS(&(newUEContext_p->dlCQIInfo),
                                    cqiReport_p, &cqi_count, count, cellIndex);
			    }
			    /*EICIC -*/

                            ueContextForUplink *ueContextInfo_p = PNULL;
                            DLCQIInfo *scellDlCQIInfo = PNULL;
                            ueContextInfo_p = getUEContext(cqiPdu_p[queueCount].rnti, cellIndex);
                            scellCount = ueContextInfo_p->carrierAggrConfig.scellCount;
                            scellIndex = scellCount - 1 ;
                            scellDlCQIInfo = &(ueContextInfo_p->carrierAggrConfig.scellInfo[scellIndex].dlCQIInfo);
                            scellDlCQIInfo->ueCqiIndexNum = ( (scellDlCQIInfo->ueCqiIndexNum) %
                                    ((cqiUEProfileValues_g[scellDlCQIInfo->ueCqiProfileNum].indexCount 
                                      + 1)) );
                            count = 
                                cqiUEProfileValues_g[scellDlCQIInfo->ueCqiProfileNum].
                                ueProfile[scellDlCQIInfo->ueCqiIndexNum];
			    /*EICIC Enhancement +*/
			    tracker ++;
                            if (0 == (tracker % (cqiUEProfileValues_g[scellDlCQIInfo->ueCqiProfileNum].indexTracker)))
         		    {
             			scellDlCQIInfo->ueCqiIndexNum++;
				//ewUEContext_p->dlCQIInfo.ueCqiIndexNum++;
            			tracker = 0;
        		    }
       			    scellDlCQIInfo->indexTrack = tracker;
			    /*EICIC Enhancement -*/
                            //scellDlCQIInfo->ueCqiIndexNum++;
                            /* temp fix for RI */
                            scellDlCQIInfo->RI = ueContextInfo_p->carrierAggrConfig.scellInfo[scellIndex]. \
                                                 rankIndicator;

		  	   /*EICIC +*/
			    if(!sendAbsReport)
			    {

                              	prepareAperiodicCqiReport(scellDlCQIInfo, 
                                    cqiReport_p, &cqi_count, count,  ueContextInfo_p->
                                    carrierAggrConfig.scellInfo[scellIndex].sCellIndex);
			    }
			    else
			    {
                            	prepareAperiodicCqiReport_ABS(scellDlCQIInfo, 
                                    cqiReport_p, &cqi_count, count,  ueContextInfo_p->
                                    carrierAggrConfig.scellInfo[scellIndex].sCellIndex);
			    }
			    /*EICIC -*/

                            newUEContext_p->dlCQIInfo.cqiReportType[sendSF] = CQI_INVALID_REPORT_TYPE;
                        }
                        else
                        {
                          fprintf(stderr,"\n No CSI Requested\n");
                        }
                    }
#else
                        if(1 == newUEContext_p->dlCQIInfo.aperiodicCQIRequest[sendSF])
                        {
			/*EICIC +*/
			    if(!sendAbsReport)
			    {
				prepareAperiodicCqiReport(&(newUEContext_p->dlCQIInfo),
                                cqiReport_p, &cqi_count, count, cellIndex);
			    }
			    else
			    {
				prepareAperiodicCqiReport_ABS(&(newUEContext_p->dlCQIInfo),
                                cqiReport_p, &cqi_count, count, cellIndex);
			    }
			/*EICIC -*/

                        }
                        else
                        {
                          fprintf(stderr,"\n No CSI Requested\n");
                        }

#endif
/* SPR 12135 Fix end */

                }          
                /*  Aperiodic CQI Changes End*/
                    else if ( (UCI_PERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF])
                            && (newUEContext_p->dlCQIInfo.periodicModeType) &&
                            /* SPR 3924 changes start */
                        (cqiPeriodicReportType || cqiPeriodicScellReportType) )
                        /* SPR 3924 changes end */
                    {
                    /* Phase 2 Periodic CQi Changes Start*/


                    /* SPR 11754 Fix Start */
                    if(ulUEContext_p->carrierAggrConfig.scellCount > 0 )
                        /* SPR 11754 Fix End */
                    {
                            /*SPR 12678 Reestablishment fix start, use crnti from UL Ue context*/
                            ulUeContextInfo_p = getUEContext(cqiPdu_p[queueCount].rnti, cellIndex);
                            updateCqiPeriodicReportType(&updatedCqiReportType, 
                                    &updatedCellIndex, newUEContext_p->ueIndex,
                                    cellIndex, sendSFN, sendSF, ulUeContextInfo_p->crnti);
                            /*SPR 12678 fix end*/
                            /* Scell Periodic Cqi Changes Start */
                            /*phase-3 changes start*/  
                            if (cellIndex != updatedCellIndex )
                                /* check scell status not required here as in
                                 * de-active state Scell cqi report will not be
                                 * requested in UL config*/
                                //&& checkScellStatus(newUEContext_p->ueIndex))
                            {
                                cqiPeriodicReportType = updatedCqiReportType;
                                prepareScellPeriodicCqiReport(updatedCellIndex,cqiPeriodicReportType, 
                                        ulUEContext_p,  cqiReport_p, &cqi_count, sendSF);
                            }
                            else
                            {
                                preparePcellPeriodicCqiReport(cellIndex, cqiPeriodicReportType, 
                                        newUEContext_p, cqiReport_p, &cqi_count, sendSF);
                            }
                        }
                        else
                        {
                            preparePcellPeriodicCqiReport(cellIndex, cqiPeriodicReportType, 
                                    newUEContext_p, cqiReport_p, &cqi_count, sendSF);
                        }
                        /* Scell Periodic Cqi Changes End */
                        /* Phase 2 Periodic CQi Changes End*/
                        /* Wrap Round the cqi_Index */
                        //  ulUEContext_p->carrierAggrConfig.scellInfo[0].cqiInfo.cqiMode = 11;
                        //  switch(ulUEContext_p->carrierAggrConfig.scellInfo[0].cqiInfo.cqiMode)
                }

		/* EICIC +*/
                else if ( (UCI_PERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF])
	                        && (newUEContext_p->dlCQIInfo.periodicModeType) &&
	                        /* SPR 3924 changes start */
	                        (cqiPeriodicReportType2 || cqiPeriodicScellReportType2) )
	                    /* SPR 3924 changes end */
	             {
	                    /* Phase 2 Periodic CQi Changes Start*/

	                  // fprintf (stderr,"Calling updateCqiPeriodicReportType_ABS for SFN %d\n", sendSF);

	                    /* SPR 11754 Fix Start */
	                    if(ulUEContext_p->carrierAggrConfig.scellCount > 0 )
	                        /* SPR 11754 Fix End */
	                    {
	                            /*SPR 12678 Reestablishment fix start, use crnti from UL Ue context*/
	                            ulUeContextInfo_p = getUEContext(cqiPdu_p[queueCount].rnti, cellIndex);
	                            updateCqiPeriodicReportType_ABS(&updatedCqiReportType, 
	                                    &updatedCellIndex, newUEContext_p->ueIndex,
	                                    cellIndex, sendSFN, sendSF, ulUeContextInfo_p->crnti);
	                            /*SPR 12678 fix end*/
	                            /* Scell Periodic Cqi Changes Start */
	                            /*phase-3 changes start*/  
	                            if (cellIndex != updatedCellIndex )
	                                /* check scell status not required here as in
	                                 * de-active state Scell cqi report will not be
	                                 * requested in UL config*/
	                                //&& checkScellStatus(newUEContext_p->ueIndex))
	                            {
	                                cqiPeriodicReportType2 = updatedCqiReportType; 
	                                preparePcellPeriodicCqiReport_ABS(updatedCellIndex,cqiPeriodicReportType2, 
	                                        ulUEContext_p,  cqiReport_p, &cqi_count, sendSF);
	                            }
	                            else
	                            {
	                                preparePcellPeriodicCqiReport_ABS(cellIndex, cqiPeriodicReportType2,  /* EICIC +-*/
	                                        newUEContext_p, cqiReport_p, &cqi_count, sendSF);
	                            }
	                        }
	                        else
	                        {

	                         	  //fprintf (stderr,"Calling updateCqiPeriodicReportType_ABS for SFN %d\n", sendSF);
	                            preparePcellPeriodicCqiReport_ABS(cellIndex, cqiPeriodicReportType2, 
	                                    newUEContext_p, cqiReport_p, &cqi_count, sendSF);
	                        }
	                        /* Scell Periodic Cqi Changes End */
	                        /* Phase 2 Periodic CQi Changes End*/
	                        /* Wrap Round the cqi_Index */
	                        //  ulUEContext_p->carrierAggrConfig.scellInfo[0].cqiInfo.cqiMode = 11;
	                        //  switch(ulUEContext_p->carrierAggrConfig.scellInfo[0].cqiInfo.cqiMode)
	                }

		/* EICIC -*/

#endif
                    /* - CQI_4.1 */
                    /* + CL-MIMO RSM */
#if 0                    
                    if(pmi_Toggle)
                    {
                        if(PMI_swap == 0)
                        {
                            PMI_swap = 3;
                            pmiSendIndex++;
                        }
                        PMI_swap--;

                        if(RI_g == 1)
                        {
                            pmiSendIndex = pmiSendIndex % PMI_ARRAY_SIZE;
                            for (i = 0 ;i < cqiPMIReportSizeBytes_g; i++)
                            {
                                cqiReport_p[i] = cqiPmi_dynamic_RI_1[pmiSendIndex];
                            }
                            //fprintf(stderr, "RI is 1 in PMI TOGGLE pmiSendIndex %d cqiReport_p [%d]\n", pmiSendIndex, cqiReport_p[0]);
                        }
                        else if(RI_g == 2)
                        {
                            pmiSendIndex = pmiSendIndex  % (PMI_ARRAY_SIZE/2);
                            for (i = 0 ;i < cqiPMIReportSizeBytes_g; i++)
                            {
                                cqiReport_p[i] = cqiPmi_dynamic_RI_2[pmiSendIndex];
                            }
                            //fprintf(stderr, "else RI is 2 in PMI TOGGLE pmiSendIndex %d cqiReport_p [%d]\n", pmiSendIndex, cqiReport_p[0]);
                        }
                    }
                    /* - CL-MIMO RSM */
#endif                    
                    /* + CQI_4.1 */

                    /* SPR 3709_3850 changes start */
                    apiMsgBodyLen += cqiPdu_p[queueCount].length; /* for CQI report PDU */
                    /* SPR 3709_3850 changes end */
#if 0                    
                }
                /* - CQI_4.1 */
                else
                {
                    /* - CL-MIMO LJA*/

#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                    cqiPdu_p[ queueCount].dataOffset = MAC_PHY_CONVERT_16(numOfCqi * sizeof(FAPI_cqiPduIndicationR9_st) +2 * queueCount);
#else
                    cqiPdu_p[ queueCount].dataOffset = MAC_PHY_CONVERT_16(numOfCqi * sizeof(FAPI_cqiPduIndication_st) +2 * queueCount);
#endif

                    cqiPdu_p[ queueCount].dataOffset = MAC_PHY_CONVERT_16(numOfCqi * sizeof(FAPI_cqiPduIndication_st) +2 * queueCount);
                    cqiReport_p[queueCount*2 ] = CQI_PDU_DATA;
                    cqiReport_p[queueCount*2 + 1] = CQI_PDU_DATA;
                    apiMsgBodyLen += 2; /* for CQI report PDU */
                    /* + CL-MIMO LJA*/
                }
#endif                
                /* - CL-MIMO LJA*/
            }
/*TDD SB_CQI*/
#if 0
/*TDD SB_CQI*/
            while ( queueCount-- )
            { 
                cqiIndNode_p = ( FAPI_cqiIndQueueNode_st * ) 
                    popNode ( &cqiIndQueue[qIndex] );    
                if ( PNULL == cqiIndNode_p )
                {
                    fprintf(stderr,"Error..!! pop node in cqiQueue at index %d is null\n", qIndex );
                    continue;
                }
                cqiIndBody_p->sfnsf = MAC_PHY_CONVERT_16(cqiIndNode_p->sfnsf);
                numOfCqi++;
                cqiPdu_p[numOfCqi - 1].handle = 
                    MAC_PHY_CONVERT_32(cqiIndNode_p->cqiPduInfo.handle);
                cqiPdu_p[ numOfCqi - 1 ].rnti = 
                    MAC_PHY_CONVERT_16(cqiIndNode_p->cqiPduInfo.rnti);

                /* + TM7_8 Changes Start */
                numOfUes++;
                aoaRel9TAInfoForUEs[numOfUes - 1].rnti = cqiIndNode_p->cqiPduInfo.rnti; 
                UInt8 idx=0;
                for(idx = 0;idx < MAX_NUM_ANTENNA ;idx++)
                { 
                    if(angleOfArrivalValuesIndex_g == MAX_SF_VALUE)
                    {
                        angleOfArrivalValuesIndex_g = 0;
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[idx] = angleOfArrivalValues_g[idx][angleOfArrivalValuesIndex_g];
                    }
                    else
                    {
                        aoaRel9TAInfoForUEs[numOfUes-1].AoA[idx] = angleOfArrivalValues_g[idx][angleOfArrivalValuesIndex_g];
                    }
                }
                angleOfArrivalValuesIndex_g++;  
                 aoaRel9TAInfoForUEs[numOfUes-1].timingAdvanceR9 =
                  MAC_PHY_CONVERT_16( rel9TaValues_g.rel9TACqi[(rel9TaCntr++)%rel9TaValues_g.numTaCqi]); 
                /* + TM7_8 Changes End */
                /* CLPC_CHG */
                ulUEContext_p = getUEContext(cqiIndNode_p->cqiPduInfo.rnti);
                
                DLUEContext *newUEContext_p = PNULL;
                newUEContext_p = getDLUEContextFromRnti(cqiPdu_p[ numOfCqi - 1 ].rnti);
                if(newUEContext_p == PNULL)
                {
                    return;
                }
                /* CLPC_CHG */
                /* + TM6_5.2 */
                if(6 == newUEContext_p->transmissionMode)
                {
                    RI_g = 1;

                }
                /* - TM6_5.2 */

                /* + CL-MIMO LJA*/
                if (cqiFileFp)
                {
                    cqiPdu_p[ numOfCqi - 1].length = cqiPMIReportSizeBytes_g;
                    cqiPdu_p[ numOfCqi - 1].ri  = RI_g;    
                    if(ri_Toggle)
                    {
                        if(RI_swap == 0)
                        {
                            if (RI_g == 2)
                            {
                                RI_g = 1;
                            }
                            else if (RI_g == 1)
                            {
                                RI_g = 2;
                            }
                            RI_swap = 15;
                        }   
                        RI_swap--;
                        cqiPdu_p[ numOfCqi - 1].ri  = RI_g;
                    }
                }
                else
                {
                    /* - CL-MIMO LJA*/
                    cqiPdu_p[ numOfCqi - 1].length =
                        MAC_PHY_CONVERT_16(cqiIndNode_p->cqiPduInfo.length);
                    cqiPdu_p[ numOfCqi - 1].length = 2;
                    /* + CL-MIMO LJA*/
                    cqiPdu_p[ numOfCqi - 1].ri =
                        cqiIndNode_p->cqiPduInfo.ri;
                    cqiPdu_p[ numOfCqi - 1].ri  = RI_g;    
                }
                /* - CL-MIMO LJA*/
                cqiPdu_p[ numOfCqi - 1].dataOffset = 
                    MAC_PHY_CONVERT_16(cqiIndNode_p->cqiPduInfo.dataOffset);
                cqiPdu_p[ numOfCqi - 1].timingAdvance = 
                    cqiIndNode_p->cqiPduInfo.timingAdvance;
                cqiPdu_p[ numOfCqi - 1].ulCqi = 
                    cqiIndNode_p->cqiPduInfo.ulCqi;
                /*CLPC_CHG*/    
                if(CLPC_PUCCH_ENABLE)
                {
                    tempCqi = 
                        cqiSinrValues_g[cqiProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ulUEContext_p->ueProfileId].cqiProfileId].sinrSeq
                        [ulUEContext_p->cqiSinrSeqUsedIdx]] + 
                        (TPC_TO_SINR_CORR_PUCCH_STEP * (newUEContext_p->tpcPUCCH));
                    if(tempCqi < 0)
                    {
                        cqiPdu_p[ numOfCqi - 1].ulCqi = 0;
                    }
                    else if(tempCqi > 255)
                    {
                        cqiPdu_p[ numOfCqi - 1].ulCqi = 255;
                    }
                    else
                    {
                        cqiPdu_p[ numOfCqi - 1].ulCqi = tempCqi;
                    }
                }
                else
                {
                    cqiPdu_p[ numOfCqi - 1].ulCqi =
                        cqiSinrValues_g[cqiProfileInfo_g[ueProfileInfo_g[cellIndex]
                        [ulUEContext_p->ueProfileId].cqiProfileId].sinrSeq
                        [ulUEContext_p->cqiSinrSeqUsedIdx]];
                }
                ulUEContext_p->cqiSinrSeqUsedIdx =
                    ++ulUEContext_p->cqiSinrSeqUsedIdx % cqiProfileNum;
                /* CLPC_CHG */
                /* + CL-MIMO LJA*/    
                /*cqiPdu_p[ numOfCqi - 1].ri = 
                  cqiIndNode_p->cqiPduInfo.ri;*/
                /* - CL-MIMO LJA*/
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                apiMsgBodyLen += sizeof(FAPI_cqiPduIndicationR9_st);
#else
                apiMsgBodyLen += sizeof(FAPI_cqiPduIndication_st);
#endif
                freeMemPool(cqiIndNode_p);
                cqiIndNode_p = PNULL;
            }
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
            cqiReport_p = /*start_p*/ (UInt8*)cqiPdu_p+ numOfCqi * sizeof(FAPI_cqiPduIndicationR9_st);
#else
            cqiReport_p = /*start_p*/ (UInt8*)cqiPdu_p+ numOfCqi * sizeof(FAPI_cqiPduIndication_st);
#endif

            for(queueCount = 0;queueCount < numOfCqi;queueCount++)
            {
                /* + CL-MIMO LJA*/
                if(cqiFileFp)
                {/*read values from config file instead of hard coding*/
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
                    cqiPdu_p[ queueCount].dataOffset = numOfCqi * sizeof(FAPI_cqiPduIndicationR9_st) + cqiPMIReportSizeBytes_g* queueCount;
#else
                    cqiPdu_p[ queueCount].dataOffset = numOfCqi * sizeof(FAPI_cqiPduIndication_st) + cqiPMIReportSizeBytes_g* queueCount;
#endif

                    cqiReport_p = (UInt8*)cqiPdu_p+ cqiPdu_p[ queueCount].dataOffset;
                    for (i = 0 ;i < cqiPMIReportSizeBytes_g; i++)
                    {
                        UInt8 tempCqiValue = cqiReport_p[i];
                        if(1 == RI_g)
                        {
                            cqiReport_p[i] =  (FOUR_BIT_ROTATION(cqiPmiValue_g[i]));
                            tempCqiValue = ((cqiPmiValue_g[i] & 0x30) >> 4);
                            cqiReport_p[i] |=  ((TWO_BIT_ROTATION(tempCqiValue)) << 4); 
                        }
                        else if (2 == RI_g)
                        {
                            cqiReport_p[i] =  (FOUR_BIT_ROTATION(cqiPmiValue_g[i]));
                            tempCqiValue = ((cqiPmiValue_g[i] & 0x70) >> 4);
                            cqiReport_p[i] |=  ((THREE_BIT_ROTATION(tempCqiValue)) << 4); 
                            tempCqiValue = ((cqiPmiValue_g[i] & 0x80) >> 7);
                            cqiReport_p[i] |=  (tempCqiValue << 7); 
                        }
                    }
                    /* + CL-MIMO RSM */
                    if(pmi_Toggle)
                    {
                        if(PMI_swap == 0)
                        {
                            PMI_swap = 3;
                            pmiSendIndex++;
                        }
                        PMI_swap--;

                        if(RI_g == 1)
                        {
                            pmiSendIndex = pmiSendIndex % PMI_ARRAY_SIZE;
                            for (i = 0 ;i < cqiPMIReportSizeBytes_g; i++)
                            {

                                cqiReport_p[i] = cqiPmi_dynamic_RI_1[pmiSendIndex];
                            }
                        }
                        else if(RI_g == 2)
                        {
                            pmiSendIndex = pmiSendIndex  % (PMI_ARRAY_SIZE/2);
                            for (i = 0 ;i < cqiPMIReportSizeBytes_g; i++)
                            {
                                cqiReport_p[i] = cqiPmi_dynamic_RI_2[pmiSendIndex];
                            }
                        }
                    }
                    /* - CL-MIMO RSM */
                    apiMsgBodyLen += cqiPMIReportSizeBytes_g; /* for CQI report PDU */
                }
                else
                {
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
                    /* - CL-MIMO LJA*/
                    cqiPdu_p[ queueCount].dataOffset = numOfCqi * sizeof(FAPI_cqiPduIndicationR9_st) +2 * queueCount;
#else
                    cqiPdu_p[ queueCount].dataOffset = numOfCqi * sizeof(FAPI_cqiPduIndication_st) +2 * queueCount;
#endif
                    cqiReport_p[queueCount*2 ] = CQI_PDU_DATA;
                    cqiReport_p[queueCount*2 + 1] = CQI_PDU_DATA;
                    apiMsgBodyLen += 2; /* for CQI report PDU */
                    /* + CL-MIMO LJA*/
                }
                /* - CL-MIMO LJA*/
            }
#endif
            cqiIndBody_p->numOfCqi = MAC_PHY_CONVERT_16(numOfCqi);
            /* +- SPR 18467 */
            /* Padding length added */
            apiMsgBodyLen += (apiMsgBodyLen%4)?(4 - apiMsgBodyLen%4):0;
            /* +- SPR 18467 */
            apiMsgLen += apiMsgBodyLen;
            l1ApiMsg_p->msgLen= MAC_PHY_CONVERT_16(apiMsgBodyLen);
            /* + TM7_8 Changes Start */
            /* + E_CID_5.3 */
            UInt8 totalLen = 0; 
            if (numOfUes)
            {
    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
                vendorSpecificData_p = (FAPI_VendorSpecificR9_st *) (&l1ApiMsg_p->msgBody[0] + apiMsgBodyLen);
                l1ApiMsg_p->lenVendorSpecific = MAC_PHY_CONVERT_16(((sizeof(FAPI_AOA_RecievedForUE_st) * numOfUes) + 4));
#else
                vendorSpecificData_p = (FAPI_VendorSpecific_st *) (&l1ApiMsg_p->msgBody[0] + apiMsgBodyLen);
                l1ApiMsg_p->lenVendorSpecific = MAC_PHY_CONVERT_16(((sizeof(FAPI_AOA_REL9TARecievedForUE_st) * numOfUes) + 4));
#endif
                UInt8 idx = 0;
                vendorSpecificData_p->ueMeasInfoForUEs.numOfUEs = MAC_PHY_CONVERT_16(numOfUes);
                for(idx = 0;idx < numOfUes ; idx++)
                {
    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
                    totalLen += (sizeof(FAPI_AOA_RecievedForUE_st));
#else
                    totalLen += (sizeof(FAPI_AOA_REL9TARecievedForUE_st));
#endif

                    if (totalLen >= 252)
                    {
                        l1ApiMsg_p->lenVendorSpecific =  MAC_PHY_CONVERT_16(244);
                        vendorSpecificData_p->ueMeasInfoForUEs.numOfUEs = MAC_PHY_CONVERT_16(20);
                        break;                     
                    }     
    /*SPR 13791 changes start */
#if  defined(FAPI_4_0_COMPLIANCE)
    /*SPR 13791 changes end */
                    aoaRel9TAInfoForUE = &vendorSpecificData_p->ueMeasInfoForUEs.aoaRel9Info[idx];
#else
                    aoaRel9TAInfoForUE = &vendorSpecificData_p->ueMeasInfoForUEs.aoaRel9TAInfo[idx];
#endif
                    aoaRel9TAInfoForUE->rnti = aoaRel9TAInfoForUEs[idx].rnti;
                    aoaRel9TAInfoForUE->AoA[0] = aoaRel9TAInfoForUEs[idx].AoA[0];
                    aoaRel9TAInfoForUE->AoA[1] = aoaRel9TAInfoForUEs[idx].AoA[1];
                    aoaRel9TAInfoForUE->AoA[2] = aoaRel9TAInfoForUEs[idx].AoA[2];
                    aoaRel9TAInfoForUE->AoA[3] = aoaRel9TAInfoForUEs[idx].AoA[3];
    /*SPR 13791 changes start */
#if (!defined(FAPI_4_0_COMPLIANCE))
    /*SPR 13791 changes end */
                    aoaRel9TAInfoForUE->timingAdvanceR9 = aoaRel9TAInfoForUEs[idx].timingAdvanceR9;
#endif

                }
                numOfUes = 0;
                /* + TM7_8 Changes End */
                sendDatatoPeerMac(sendBuffer_p, apiMsgLen +\
                        l1ApiMsg_p->lenVendorSpecific, cellIndex);
                /* - TM7_8 Changes Start */
            }
            else
            {
                sendDatatoPeerMac(sendBuffer_p, apiMsgLen, cellIndex);
            }
            /* - E_CID_5.3 */
            /* printf("CQI Bytes Sent: Length = %d\n ", apiMsgLen);
               printf("Actual Bytes \n ");
               for (i = 0; i < apiMsgLen; i++)
               printf("0x%x\t", *(sendBuffer_p + i)); */
        }
        sched_yield();
         
         /* +DYNAMIC_ICIC */
         /* + SPR_6009 */ 
        if ((1 == measEnabled_g[cellIndex])  && (l1MeasReportsToSend) &&
                 (getCurrentglobaltick() >= measOpportunity)
#ifdef TDD_CONFIG
                 /* CA TDD Changes Start */
                && (IS_UL_SUBFRAME(SF_g[cellIndex], cellIndex))
                 /* CA TDD Changes End */
#endif
                 )
         /* - SPR_6009 */ 
         {  
	    SInt32 bitmask=0;
	    SInt32 temp=1;
            //start_p = measReportBuffer;
#ifdef SHM_INTF
            sendBuffer_p = measReportBuffer+8;
            apiMsgLen = 8;
#else
            sendBuffer_p = measReportBuffer;
            apiMsgLen = 0;       
#endif
            
            /*fapiSendMeasReport */
            l1ApiMsg_p = ( FAPI_l1ApiMsg_st *)sendBuffer_p;
            l1ApiMsg_p->msgId = PHY_MEASUREMENT_REPORT_INDICATION;
            l1ApiMsg_p->lenVendorSpecific = 0;
            apiMsgLen += L1_PARTIAL_API_MSG_SIZE;
            apiMsgBodyLen = 4;
            l1MeasRepBody_p = (FAPI_rxMeasReport_st*) &(l1ApiMsg_p->msgBody[0]);
            l1MeasRep_p = (FAPI_l1MeasReport_st *)&(l1MeasRepBody_p->l1MeasInfo);
            
            l1MeasRepBody_p->sfnsf = sfnsf_g[cellIndex];
            for (i = 0; i < 100; i++)
            {
                l1MeasRep_p->interferencePerPRB[i]=interValues_g[cellIndex]
                    [interSequence_g[cellIndex][profileidx]][i];
            }

            profileidx++;
            if (5 == profileidx)
            {
                profileidx = 0;
            }
            
            
            l1MeasRep_p->dlRsTxPower=dlRsTxValues_g[cellIndex][rsTxNum];
            rsTxNum++;
            if(dlRsTxPowerNum_g[cellIndex] == rsTxNum)
            {
                    rsTxNum=0;
            }
            
            l1MeasRep_p->thermalNoise = thermalNoiseValues_g[cellIndex]
                [tNoiseNum];
            tNoiseNum++;
            if(thermalNoiseNum_g[cellIndex]==tNoiseNum) 
            {
                tNoiseNum=0;
            }
            if(1==interferenceEnb_g[cellIndex])
	    {
            bitmask|=INTER_PROF_ENABLED;	
	    }
            if(1==dlRsTxPowerEnb_g[cellIndex])
            {
            bitmask|=DLRSTXPOWER_ENABLED;
            }   
            if(1==thermalNoiseEnb_g[cellIndex])
            {
            bitmask|=THERMAL_NOISE_ENABLED;
            }  
             
            /* + SPR_6009 */
	    l1MeasReportsToSend = 1;
            /* - SPR_6009 */
            l1MeasRep_p->bitmask=bitmask;
            apiMsgBodyLen+= sizeof(FAPI_l1MeasReport_st);
            apiMsgLen+= apiMsgBodyLen;            
            sendDatatoPeerMac(sendBuffer_p,apiMsgLen, cellIndex);
            measOpportunity += measReportPeriodicity_g[cellIndex];
         }
         /* -DYNAMIC_ICIC */
        /* The UL HARQ PHICH which should have been received in the last tick but was not
           received in the last tick due to some reasons would now move into re-transmission
           mode 
         */
#ifdef FAPI_UL_HARQ_ENABLE
        //_NOULHARQ_TIMER_PROC_  start
        {

            ueContextForUplink   *ueContextInfo_p  = PNULL;
            ulschDataQueueNode   *uldataNode_p = PNULL;
            ControlNodeInfo    ctlInfo  = {0};
            ULHarqInfo* ulHarq_p = PNULL;
            UInt8  dataPduIndex   = 0;
            UInt16 pktqIndex,pktSFN,pktSF;
            UInt16 ulHarqTimerIndex;
            UInt16 newphichReceiveIndex;
            unsigned char* pduPointer=PNULL;
            UInt16 newtimercount,oldtimercount;
            SInt8 diffPhichIndex =0;
            UInt16 processdTimerFlag=0;
            UInt16 sendSfnSf;


            processdTimerFlag=0;
            diffPhichIndex=currentSF-SF_DIFF;

            if(diffPhichIndex < 0)
            {
                phichReceiveIndex = MAX_SUBFRAME  + diffPhichIndex;    
            }
            else
            {
                phichReceiveIndex=diffPhichIndex; 
            }

            prevPhichReceiveIndex = phichReceiveIndex;

            if(ulHarqTimerEntityList_g[phichReceiveIndex].count)
            { 
                ulHarqTimerElementCount = ulHarqTimerEntityList_g[phichReceiveIndex].count;

                //fprintf(stderr,"In TTX Count %d phichReceiveIndex %d\n",ulHarqTimerElementCount,phichReceiveIndex);

                while (ulHarqTimerElementCount--)
                {
                    //fprintf(stderr,"In TTX TIdx %d\n",ulHarqTimerElementCount);

                    if(ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid)       
                    {
                        ctlInfo.sendSF      = ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf;
                        ctlInfo.sendSFN     = ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn;
                        ctlInfo.qIndex      = ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex;

                        pktqIndex=ctlInfo.qIndex;
                        pktSFN=ctlInfo.sendSFN;
                        pktSF=ctlInfo.sendSF;
                        dataPduIndex = ctlInfo.qIndex;

                        if((SFN_g>ctlInfo.sendSFN) || ((SFN_g==ctlInfo.sendSFN) && (SF_g>ctlInfo.qIndex)))
                        {

                            processdTimerFlag=1;
                            ueIndex = ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex;
                            ueContextInfo_p  = uplinkContextInfoMap_g[ueIndex];

                            ctlInfo.sendSF += 8; 
                            if (  ctlInfo.sendSF >= MAX_SUBFRAME )
                            {
                                ctlInfo.sendSF -= MAX_SUBFRAME;
                                ctlInfo.sendSFN++;
                                if ( ctlInfo.sendSFN == MAX_SFN )
                                {
                                    ctlInfo.sendSFN = 0;
                                }
                            }                              

                            sendSfnSf = GENERATE_SUBFRAME_SFNSF(ctlInfo.sendSFN , ctlInfo.sendSF);
                            ctlInfo.qIndex += 8 ; 

                            if (  ctlInfo.qIndex >= MAX_SUBFRAME )
                            {
                                ctlInfo.qIndex -= MAX_SUBFRAME;
                            }               

                            ctlInfo.crnti       = ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti;

                            harqIndex = ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId;
                            ulHarq_p = &ueContextInfo_p->ulharqInfo[harqIndex];

                            if ( ulHarq_p->currentRetransCount < 
                                    /* max harq tx changes */
                                    (ueContextInfo_p->maxUlHarqTx -1 ))
                                /* max harq tx changes */
                            {

                                ulHarq_p->currentRetransCount++;

                                tbSize = ulHarq_p->tbSizeForNackCase;


                                ctlInfo.crc = preapreCRCIndication( ctlInfo.crnti,sendSfnSf, 
                                        ctlInfo.qIndex, FALSE);
                                if ( ctlInfo.crc == CRC_CORRECT )
                                {
                                    uldataNode_p = fapiGetULDataPduNode (ctlInfo.qIndex, sendSfnSf,
                                            ctlInfo.crnti );

                                    if(ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p)
                                    {
                                        UInt16 currentSFNSF    = 0;
                                        UInt16 sendSFNSF    = 0;

                                        uldataNode_p->pdudata_p = ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p;
                                        pduPointer=uldataNode_p->pdudata_p;
                                        uldataNode_p->pduLen = ueContextInfo_p->ulDataPduInfo[dataPduIndex].PDULength;
                                        ueContextInfo_p->ulDataPduInfo[ctlInfo.qIndex].Pdudata_p = uldataNode_p->pdudata_p;
                                        ueContextInfo_p->ulDataPduInfo[ctlInfo.qIndex].PDULength = uldataNode_p->pduLen;

                                        // _ULHARQ_RETX_  start
                                        uldataNode_p->SFN =  (uldataNode_p->sendSfnSf & FAPI_SFN_MASK ) >> FAPI_SFN_VALUE_SHIFT; 
                                        uldataNode_p->SF = (uldataNode_p->sendSfnSf & FAPI_SF_MASK );

                                        if(uldataNode_p->SFN != SFN_g)
                                        {
                                            if ((!((uldataNode_p->SFN==0)&& (SFN_g==(MAX_SFN -1)))) && (!((uldataNode_p->SFN==(MAX_SFN -1) )&& (SFN_g==0))))
                                            {
                                                currentSFNSF=SFN_g * 10 + SF_g[cellIndex];
                                                sendSFNSF= uldataNode_p->SFN * 10 + ctlInfo.qIndex;
                                            }
                                            else if((uldataNode_p->SFN==0)&& (SFN_g==(MAX_SFN -1)))
                                            {
                                                currentSFNSF=0;
                                                sendSFNSF=(MAX_SFN - 1);
                                            }
                                            else if((uldataNode_p->SFN==(MAX_SFN -1) )&& (SFN_g==0))
                                            {
                                                currentSFNSF=(MAX_SFN - 1);
                                                sendSFNSF=0;
                                            }
                                        }
                                        else
                                        {
                                            currentSFNSF=SF_g;
                                            sendSFNSF=ctlInfo.qIndex;
                                        }


                                        if (currentSFNSF<sendSFNSF)
                                        {   
                                            pushNode(&ulDataQueue[cellIndex][ctlInfo.qIndex], &(uldataNode_p->ulDataAnchor));
                                        }
                                        else
                                        {
                                            //fprintf(stderr,"In TTX INITHARQRETRY\n");
                                        }

                                        // _ULHARQ_RETX_  end                                                        
                                        ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p=NULL;
                                        ueContextInfo_p->ulDataPduInfo[dataPduIndex].PDULength=0;


                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId = 255;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid = 0;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex = INVALID_UE_INDEX;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex = 255;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti = INVALID_UE_INDEX; 
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn = 0;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf = 0;    
                                        oldtimercount=ulHarqTimerElementCount;
                                        ueContextInfo_p->ulHarqTimerNodeArrrayIndex[phichReceiveIndex] = 255;

                                        newphichReceiveIndex = (phichReceiveIndex + 8 )%10;

                                        ulHarqTimerIndex = ulHarqTimerEntityList_g[newphichReceiveIndex].count;
                                        ulHarqTimerEntityList_g[newphichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerIndex].harqProcessId = harqIndex;
                                        ulHarqTimerEntityList_g[newphichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerIndex].isValid = 1;
                                        ulHarqTimerEntityList_g[newphichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerIndex].ueIndex = ueIndex;
                                        ulHarqTimerEntityList_g[newphichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerIndex].qIndex = ctlInfo.qIndex;
                                        ulHarqTimerEntityList_g[newphichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerIndex].crnti = ctlInfo.crnti; 
                                        ulHarqTimerEntityList_g[newphichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerIndex].sfn = ctlInfo.sendSFN;
                                        ulHarqTimerEntityList_g[newphichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerIndex].sf = ctlInfo.sendSF;
                                        ulHarqTimerEntityList_g[newphichReceiveIndex].count++;
                                        newtimercount=ulHarqTimerIndex + 1;
                                        ueContextInfo_p->ulHarqTimerNodeArrrayIndex[newphichReceiveIndex] = ulHarqTimerIndex;
                                        //fprintf(stderr,"In TTX pqI %d pSFN %d pSF %d cSFN %d cSF %d sqI %d sSF %d sSFN %d cSFNSF %d sSFNSF %d\n",pktqIndex,pktSFN,pktSF,SFN_g,SF_g,ctlInfo.qIndex,uldataNode_p->SF,uldataNode_p->SFN,currentSFNSF,sendSFNSF);

                                        //fprintf(stderr,"TTX TIMERSTART  hI %d oldackSF %d oldTIdx %d oldtimercount %d newackSF %d newTIdx %d newtimercount %d \n",harqIndex,phichReceiveIndex,ulHarqTimerElementCount,oldtimercount,newphichReceiveIndex,ulHarqTimerIndex,newtimercount);
                                    }
                                    else
                                    {
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId = 255;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid = 0;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex = INVALID_UE_INDEX;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex = 255;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti = INVALID_UE_INDEX; 
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn = 0;
                                        ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf = 0;    
                                        oldtimercount=ulHarqTimerEntityList_g[phichReceiveIndex].count;
                                        ueContextInfo_p->ulHarqTimerNodeArrrayIndex[phichReceiveIndex] = 255;

                                        //fprintf(stderr,"In TTXL cSFN %d cSF %d oldackSF %d oldTIdx %d oldtimercount %d\n",SFN_g,SF_g,phichReceiveIndex,ulHarqTimerElementCount,oldtimercount);
                                    }

                                }
                                else
                                {
                                }
                            }
                            else
                            {
                                //fprintf(stderr, "MAX RE TRANS CASE HIT  for subFrame = %d and Count = %d \n",phichReceiveIndex,ulHarqTimerElementCount); 
                                ulHarq_p->tbSizeForNackCase = 0;
                                ulHarq_p->ulgrantrecvCount = 0;
                                ulHarq_p->currentRetransCount = 0;
                                dataPduIndex=ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex;
                                ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].harqProcessId = 255;
                                ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].isValid = 0;
                                ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].ueIndex = INVALID_UE_INDEX;
                                ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].qIndex = 255;
                                ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].crnti = INVALID_UE_INDEX; 
                                ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sfn = 0;
                                ulHarqTimerEntityList_g[phichReceiveIndex].ulHarqTimerNodeArr[ulHarqTimerElementCount].sf = 0;        
                                ueContextInfo_p->ulHarqTimerNodeArrrayIndex[phichReceiveIndex] = 255;
                                // _ULHARQ_RETX_  start  

                                if(ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p)
                                {    
                                    //fprintf(stderr,"TIMER BUFFER FREE \n");
                                    freeMemPool(ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p);
                                }
                                else
                                {
                                    //fprintf(stderr,"TIMER BUFFER LEAK \n");
                                }
                                ueContextInfo_p->ulDataPduInfo[dataPduIndex].Pdudata_p=NULL;
                                ueContextInfo_p->ulDataPduInfo[dataPduIndex].PDULength=0;

                                // _ULHARQ_RETX_  end  
                            }
                        }
                    } 
                }
                if(processdTimerFlag)
                {
                    processdTimerFlag=0;
                    ulHarqTimerEntityList_g[prevPhichReceiveIndex].count = 0;
                }
            }
        }
#endif

        //}
}
#if 0
/****************************************************************************
 * Function Name  : initWireSharkSocket
 * Inputs         : sockaddr_in, socketFileDescriptor,Port Number
 * Outputs        :
 * Returns        : status (0-Failure,1-Successful)
 * Description    : to intialize the Socket address with specific socket file
 descriptor and specific port
 ****************************************************************************/
static UInt8 initWireSharkSocket(UInt32 port)
{
    if ((wiresharkfd_g = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
    {
        lteWarning("Error!! Socket Failed");
        return 0;
    }
    wiresharkAddr_g.sin_family = AF_INET;
    wiresharkAddr_g.sin_port = htons(port);
    return 1;
}
/****************************************************************************
 * Function Name  : getIPAddrFromFile()
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    :
 ****************************************************************************/
void getIPAddrFromFile()
{
    FILE   *file_p;
    UInt8 length = 0;
    UInt32 wiresharkPort = 0;
    struct hostent *hp;
    UChar8 line[MAX_LINE_SIZE] = {0}, temp[MAX_LINE_SIZE];
    file_p = fopen("phySimConfig.txt", "r");
    if (file_p == PNULL)
    {
        LTE_LOG(LOG_CRITICAL,PNULL,"File opening error, provide correct file name.");
        return;
    }
    bzero(&(wiresharkAddr_g),sizeof(wiresharkAddr_g));
    while ( fgets(line,MAX_LINE_SIZE,file_p) != NULL)
    {
        if ( '#' == line[0])
            continue;
        memset(temp,0,MAX_LINE_SIZE);
        length = strlen(line);
        if( sscanf(line,"wiresharkIP =%s",temp))
        {
            //fprintf(stderr,"wireshark IP %s\n",temp);
            hp = (struct hostent *) gethostbyname((char *)temp);
            if (hp == (struct hostent *)0) 
            {  
                //fprintf(stderr,"Unknown host\n");  
                exit(1); 
            }
            memcpy((void*)&(wiresharkAddr_g.sin_addr), (void*)hp->h_addr, hp->h_length);
        }
        else if(sscanf(line,"wiresharkPort =%d",&wiresharkPort) ==0);
    }
    fclose(file_p);
    //fprintf(stderr,"wireshark port %d\n",wiresharkPort);
    initWireSharkSocket(wiresharkPort);
}


#endif

/****************************************************************************
 * Function Name  : setSocketBlockingEnabled
 * Inputs         : socketfiledecriptor, blocking (0 - Non Blocking, 1-Blocking)
 * Outputs        : NONE
 * Returns        : status (0-Failure,1-Successful)
 * Variables      :
 * Description    : to set the specific socket blocking or non blocking
 ****************************************************************************/
static UInt8 setSocketBlockingEnabled(UInt8 sockfd, UInt8 blocking)
{
    SInt32 fileflags;
    fileflags = fcntl(sockfd, F_GETFL,0);
    if(fileflags == -1)
    {
        ltePanic("fcntl F_GETFL");
        return 0;
    }
    fileflags = blocking ? (fileflags & ~FNDELAY) : (fileflags |FNDELAY);
    return (fcntl(sockfd, F_SETFL, fileflags)== 0) ? 1 : 0 ;
}
/****************************************************************************
 * Function Name  : initSocketAddress
 * Inputs         : sockaddr_in, socketFileDescriptor,Port Number
 * Outputs        :
 * Returns        : status (0-Failure,1-Successful)
 * Variables      :
 * Description    : to intialize the Socket address with specific socket file
 descriptor and specific port
 ****************************************************************************/

static UInt8 initSocketAddress(struct sockaddr_in *s,SInt32 *sockfd,UInt16 port)
{
    struct hostent *host_p;
    host_p= (struct hostent *) gethostbyname((char *)l2ModuleIP);
    if((*sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
    {
        LTE_LOG(LOG_DETAIL,PNULL,"creating socket error\n");
        return 0;
    }
    (*s).sin_family = AF_INET;
    (*s).sin_port = htons(port);
    (*s).sin_addr = *((struct in_addr *)host_p->h_addr);
    bzero(&((*s).sin_zero),8);
    return 1;
}

/* +CA*/
static UInt8 initSocketAddressTX(UInt16 port, UInt8 cellIndex
#ifdef DL_UL_SPLIT_TDD
        , UInt16 txPortULThd
#endif
				)
{
    struct hostent *host_p;
    host_p= (struct hostent *) gethostbyname((char *)macIPAddress_g);
    if((txSockFD_g[cellIndex] = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
    {
        LTE_LOG(LOG_DETAIL,PNULL,"creating socket error\n");
        return 0;
    }
    macLayerAddr_g[cellIndex].sin_family = AF_INET;
    macLayerAddr_g[cellIndex].sin_port = htons(port);
    macLayerAddr_g[cellIndex].sin_addr = *((struct in_addr *)host_p->h_addr);
    bzero(&((macLayerAddr_g[cellIndex]).sin_zero),8);

#ifdef DL_UL_SPLIT_TDD
    macLayerAddrULThd_g[cellIndex].sin_family = AF_INET;
    macLayerAddrULThd_g[cellIndex].sin_port = htons(txPortULThd);
    macLayerAddrULThd_g[cellIndex].sin_addr = *((struct in_addr *)host_p->h_addr);
    bzero(&(macLayerAddrULThd_g.sin_zero),8);
#endif

#ifdef HO_SETUP_CHANGES
    host_p= (struct hostent *) gethostbyname((char *)targetEnbIp_g);
    if((targetEnbTxFd_g[cellIndex] = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
    {
        fprintf(stderr,"creating socket for target ENB Tx fd error\n");
        return 0;
    }
    targetEnbmacLayerAddr_g[cellIndex].sin_family = AF_INET;
    targetEnbmacLayerAddr_g[cellIndex].sin_port = htons(port);
    targetEnbmacLayerAddr_g[cellIndex].sin_addr = *((struct in_addr *)host_p->h_addr);
    bzero(&(targetEnbmacLayerAddr_g[cellIndex].sin_zero),8);
#endif
    return 1;
}
/* -CA */


/* +CA */
/*****************************************************************************
 * Function Name  : parseConfigFiles 
 * Inputs         : 
 * Outputs        : 
 * Returns        : 
 * Description    : This function will call functions to parse and create 
 * 					various profiles (UE Profile, PHR , CQI profile etc.)
 *****************************************************************************/
void parseConfigFiles()
{
    UInt8 srsSinrValues[MAX_SRS_SINR_PROFILES][MAX_PRB] = {0};
    UInt8 ulschSinrValues[MAX_ULSCH_SINR_PROFILES] = {0};
    /* CLPC_CHG */
    UInt8 cqiSinrValues[MAX_CQI_SINR_PROFILES] = {0};
    /* CLPC_CHG */
    /*CLPC_CHG*/
    PHRProfile phrProfileInfo[MAX_NUM_CELLS][MAX_PHR_PROFILES];
    UInt8 phrValues[MAX_COUNT_VALUE] = {0};

    ueProfile ueProfileInfo[MAX_NUM_CELLS][MAX_UE_PROFILES];
    SRSProfile srsProfileInfo[MAX_SRS_PROFILES];
    ULSCHProfile ulschProfileInfo[MAX_ULSCH_PROFILES];
    /* CLPC_CHG */
    CQIProfile cqiProfileInfo[MAX_CQI_PROFILES];
    /* CLPC_CHG */
    //getIPAddrFromFile();
    parseAckNackConfigFile(); 

    /* ULA_CHG */
    parseUeProfileConfig(ueProfileInfo);
    createUeProfileConfig(ueProfileInfo);

	parseUeSINRConfig(srsProfileInfo,ulschProfileInfo,cqiProfileInfo,\
			srsSinrValues,ulschSinrValues,cqiSinrValues);
	createUeSINRConfig(srsProfileInfo,ulschProfileInfo,cqiProfileInfo,\
			srsSinrValues,ulschSinrValues,cqiSinrValues);
    /* ULA_CHG */
    /* + CQI_4.1 */
    // Init CQI based on Tx MODE and WB/SB/Ue Selected for Periodic and Aperiodic
    parseUeCQIProfile(); 
    parseUeCQIConfig();
    /* - CQI_4.1 */
    /* EICIC +*/
    parseUeCQIConfig_ABS();
    /* EICIC -*/
    /*CLPC_CHG*/
    parseUePHRConfig(phrProfileInfo,phrValues);
    createUePHRConfig(phrProfileInfo,phrValues);
    /* +DYNAMIC_ICIC*/
    parseL1MeasReport(); 
    /* -DYNAMIC_ICIC*/
    /* + E_CID_5.3 */
    parseUERel9TAValues();
    /* - E_CID_5.3 */
    /* + TM7_8 Changes Start */
    parseAngleOfArrivalValues();
    /* - TM7_8 Changes End */

    //initSendPeridicCQIBuffer();
    /* + CL-MIMO LJA*/
    /* - CL-MIMO LJA*/
    getPreambleRangeValuesFromFile();
    parsePhyErrorConfigFile();
}
/****************************************************************************
 * Function Name  : fapiInit 
 * Inputs         : 
 *                  
 *                  
 * Outputs        : 
 * Returns        : 
 * Description    : 
 *                  
 ****************************************************************************/
/* SPR 5313 changes start */
/* SPR 10868 Changes Start */
void fapiInit( UInt16 *rxPort, UInt16 *txPort, UInt16 *rxPorteNBMacForHO, UInt8 cellIndex
#ifdef DL_UL_SPLIT_TDD
        , *UInt16 txPortULThd
#endif
)
    /* SPR 10868 Changes End */
/* SPR 5313 changes end */
{
    /* initialize Memory from pool */
    initSocketAddress(&phyLayerAddr_g[cellIndex],&sockfd_g[cellIndex],*rxPort);

    /*set sockets Blocking or Non Blocking 0- NonBlocking/1-Blocking*/
    setSocketBlockingEnabled(sockfd_g[cellIndex],1);

    if ( bind(sockfd_g[cellIndex], (struct sockaddr*)&phyLayerAddr_g[cellIndex],
                sizeof(SockAddr)) == -1)
    {
		ltePanic("\nBind Failed, RX UE<->eNB MAC PORT = %d for cell = %d \n ", *rxPort, cellIndex);
        return;
    }
	fprintf(stderr,"\nBind Successful, RX UE<->eNB MAC PORT = %d for cell = %d \n ", *rxPort, cellIndex);

    /* SPR 5313 changes start */
/* SPR 10868 Changes Start */
    initSocketAddress(&phyLayerAddrHO_g[cellIndex],&sockfdHO_g[cellIndex],*rxPorteNBMacForHO);
/* SPR 10868 Changes End */

    /*set sockets Blocking or Non Blocking 0- NonBlocking/1-Blocking*/
    setSocketBlockingEnabled(sockfdHO_g[cellIndex],1);

    if ( bind(sockfdHO_g[cellIndex], (struct sockaddr*)&phyLayerAddrHO_g[cellIndex],
                sizeof(SockAddr)) == -1)
    {
/* SPR 10868 Changes Start */
        ltePanic("Bind Failed PHY RX PORT = %d for cell = %d \n", *rxPorteNBMacForHO, 
                cellIndex);
/* SPR 10868 Changes End */
        return;
    }
    /* -CA */
    /* CA */
    /* SPR 5313 changes end */
    /* + CA */
    initSocketAddressTX(*txPort, cellIndex
#ifdef DL_UL_SPLIT_TDD
            , *txPortULThd
#endif
);
    macLayerAddr_g[cellIndex].sin_port = htons(*txPort);
    /* - CA_NA */

}
/* -CA_NA */
/****************************************************************************
 * Function Name  : initAckNackPosition
 * Inputs         : void
 * 
 * 
 * Outputs        :
 * Returns        :
 * Description    :  
 *  
 *****************************************************************************/
static void initAckNackPosition(UInt8 numAcks, 
		UInt8 tbArray[][ACK_NACK_ARRAY_SIZE][ACK_NACK_ARRAY_SIZE],
		UInt8 cellIndex)
{
    UInt8 row, column;
    UInt8 index;

    for (row = 0; row < ACK_NACK_ARRAY_SIZE; row++)
    {
        for(column = 0; column < numAcks; column++)
        {
            index = (row + (int)(column*(((float)ACK_NACK_ARRAY_SIZE/(float)numAcks))))%ACK_NACK_ARRAY_SIZE;
            //index = (row +  column)%ACK_NACK_ARRAY_SIZE;
            tbArray[cellIndex][row][index] = 1;
        }
    }
}

/*CLPC_CHG*/
/****************************************************************************
 * Function Name  : modifyAckNackArrayForTpc
 * Inputs         : ueContextForUplink: Stores the UE Context in Uplink
 *                  perOfAck          : Percentage of Ack with which the array 
 *                                      has to be refilled
 *                  cellIndex
 * Outputs        : void
 * Returns        : void
 * Description    : This function will fill the Ack Nack Array based on the 
 *                  percentage of Ack received based on Tpc commands
 *  
 *****************************************************************************/
static void modifyAckNackArrayForTpc(DLUEContext *dlUeContext_p, 
		UInt8 cellIndex)
{
    UInt8 row = 0, column = 0;
    UInt8 index = 0;
    UInt8 numOfAckTb1 = 0, 
          numOfNackTb1 = 0,
          numOfUnsureTb1 = 0,
          numOfAckTb2 = 0, 
          numOfNackTb2 = 0,
          numOfUnsureTb2 = 0;

    UInt8 countAck = 0,
          countNack = 0,
          countUnsure = 0;

#ifdef FDD_CONFIG
    /*For TB1*/
    numOfAckTb1 = ((dlUeContext_p->tpcAckNackContext.perAckTb1UE + (ACK_NACK_ARRAY_SIZE - 1)) / ACK_NACK_ARRAY_SIZE);
    numOfNackTb1 = (dlUeContext_p->tpcAckNackContext.perNackTb1UE / ACK_NACK_ARRAY_SIZE);
    numOfUnsureTb1 = ACK_NACK_ARRAY_SIZE - (numOfAckTb1 + numOfNackTb1);
#elif TDD_CONFIG
    /*For TB1*/
    numOfAckTb1 = ((((dlUeContext_p->tpcAckNackContext.perAckTb1UE) * ACK_NACK_ARRAY_SIZE) + 99)/ 100);
    numOfNackTb1 = ((dlUeContext_p->tpcAckNackContext.perNackTb1UE * ACK_NACK_ARRAY_SIZE) / 100);
    numOfUnsureTb1 = ACK_NACK_ARRAY_SIZE - (numOfAckTb1 + numOfNackTb1);
#endif

#ifdef PHR_TESTING
    fprintf(stderr,"numOfAckTb1=%d,numOfNackTb1=%d,numOfUnsureTb1=%d\n",
            numOfAckTb1,
            numOfNackTb1,
            numOfUnsureTb1);
#endif
#ifdef FDD_CONFIG
    /*For TB2*/
    numOfAckTb2 = ((dlUeContext_p->tpcAckNackContext.perAckTb2UE + (ACK_NACK_ARRAY_SIZE - 1)) / ACK_NACK_ARRAY_SIZE);
    numOfNackTb2 = (dlUeContext_p->tpcAckNackContext.perNackTb2UE / ACK_NACK_ARRAY_SIZE);
    numOfUnsureTb2 = ACK_NACK_ARRAY_SIZE - (numOfAckTb2 + numOfNackTb2);
#elif TDD_CONFIG
    /*For TB2*/
    numOfAckTb2 = (((dlUeContext_p->tpcAckNackContext.perAckTb2UE * ACK_NACK_ARRAY_SIZE) + 99)/ 100);
    numOfNackTb2 = ((dlUeContext_p->tpcAckNackContext.perNackTb2UE * ACK_NACK_ARRAY_SIZE) / 100);
    numOfUnsureTb2 = ACK_NACK_ARRAY_SIZE - (numOfAckTb2 + numOfNackTb2);
#endif


#ifdef PHR_TESTING
    fprintf(stderr,"numOfAckTb2=%d,numOfNackTb2=%d,numOfUnsureTb2=%d\n",
            numOfAckTb2,
            numOfNackTb2,
            numOfUnsureTb2);
#endif

    /*For TB1*/
    for(row = 0; row < ACK_NACK_ARRAY_SIZE; row++)
    {
        for(column = 0; column < ACK_NACK_ARRAY_SIZE;)
        {
            countAck = 0;
            countNack = 0;
            countUnsure = 0;

            while(countAck < numOfAckTb1)
            {
                index = (row +  column)%ACK_NACK_ARRAY_SIZE;
                dlUeContext_p->tpcAckNackContext.
                    tb1_ack_nack_perUe_array[row][index] = 1;
                column++;
                countAck++;
            }
            while(countNack < numOfNackTb1)
            {
                index = (row +  column)%ACK_NACK_ARRAY_SIZE;
                dlUeContext_p->tpcAckNackContext.
                    tb1_ack_nack_perUe_array[row][index] = 0;
                column++;
                countNack++;
            }
            while(countUnsure < numOfUnsureTb1)
            {
                index = (row +  column)%ACK_NACK_ARRAY_SIZE;
                dlUeContext_p->tpcAckNackContext.
                    tb1_ack_nack_perUe_array[row][index] = 
					perUnsureTb1_g[cellIndex];
                column++;
                countUnsure++;
            }
        }
    }

#ifdef PHR_TESTING
    fprintf(stderr,"##TB1##\n");
    for(row = 0; row < ACK_NACK_ARRAY_SIZE; row++)
    {
        for(column = 0; column < ACK_NACK_ARRAY_SIZE; column++)
        {
            fprintf(stderr,"%d",dlUeContext_p->tpcAckNackContext.
                    tb1_ack_nack_perUe_array[row][column]);
        }
        fprintf(stderr,"\n");
    }
#endif
    /*For TB2*/
    for(row = 0; row < ACK_NACK_ARRAY_SIZE; row++)
    {
        for(column = 0; column < ACK_NACK_ARRAY_SIZE;)
        {
            countAck = 0;
            countNack = 0;
            countUnsure = 0;

            while(countAck < numOfAckTb2)
            {
                index = (row +  column)%ACK_NACK_ARRAY_SIZE;
                dlUeContext_p->tpcAckNackContext.
                    tb2_ack_nack_perUe_array[row][index] = 1;
                column++;
                countAck++;
            }
            while(countNack < numOfNackTb2)
            {
                index = (row +  column)%ACK_NACK_ARRAY_SIZE;
                dlUeContext_p->tpcAckNackContext.
                    tb2_ack_nack_perUe_array[row][index] = 0;
                column++;
                countNack++;
            }
            while(countUnsure < numOfUnsureTb2)
            {
                index = (row +  column)%ACK_NACK_ARRAY_SIZE;
                dlUeContext_p->tpcAckNackContext.
                    tb2_ack_nack_perUe_array[row][index] = 
					perUnsureTb2_g[cellIndex];
                column++;
                countUnsure++;
            }
        }
    }
}
/*CLPC_CHG*/




/****************************************************************************
 * Function Name  : fillAckNackOrCrc
 * Inputs         : void
 * 
 * 
 * Outputs        :
 * Returns        :
 * Description    :  
 *  
 *****************************************************************************/

static void fillAckNackOrCrc(UInt8 ack_nack_crc_array[][ACK_NACK_ARRAY_SIZE][ACK_NACK_ARRAY_SIZE],
        UInt8 value,
        UInt8 *sendAckNackCrc_p,
        UInt8 *perAck,
        UInt8 *perNack,
		UInt8 cellIndex
        )
{
    UInt8 numAcks;

    memset(ack_nack_crc_array[cellIndex], 0x0, ACK_NACK_ARRAY_SIZE*ACK_NACK_ARRAY_SIZE);

    switch(value)
    {
        case 0: //NACK
            if(NULL != perNack)
            {
                *perNack = 100;
            }
            if(NULL != perAck)
            {
                *perAck = 0;
            }
            break;
        case 1://ACK
            memset(ack_nack_crc_array[cellIndex], 0x1, ACK_NACK_ARRAY_SIZE*ACK_NACK_ARRAY_SIZE);
            if(NULL != perNack)
            {
                *perNack = 0;
            }
            if(NULL != perAck)
            {
                *perAck = 100;
            }
            break;
        case 2://Don't send ACK/NACK
            if(NULL != sendAckNackCrc_p)
            {
                *sendAckNackCrc_p = 1;
            }
            if(NULL != perAck)
            {
                *perAck = 0;
            }
            if(NULL != perNack)
            {
                *perNack = 100;
            }
            break;
        case 3: //25% Ack 75% Nack
            numAcks = ACK_NACK_ARRAY_SIZE/4;
            initAckNackPosition(numAcks, ack_nack_crc_array, cellIndex);
            if(NULL != perNack)
            {
                *perNack = 75;
            }
            if(NULL != perAck)
            {
                *perAck = 25;
            }
            break;
        case 4: // 50% Ack 50%NACK
            numAcks = ACK_NACK_ARRAY_SIZE/2;
            initAckNackPosition(numAcks, ack_nack_crc_array, cellIndex);
            if(NULL != perNack)
            {
                *perNack = 50;
            }
            if(NULL != perAck)
            {
                *perAck = 50;
            }
            break;
        case 5: // 75% Ack 25% Nack
            numAcks = (ACK_NACK_ARRAY_SIZE* 3)/4;
            initAckNackPosition(numAcks, ack_nack_crc_array, cellIndex);
            if(NULL != perNack)
            {
                *perNack = 25;
            }
            if(NULL != perAck)
            {
                *perAck = 75;
            }
            break;
        case 10: // 90% Ack 10% Nack
        case 20: // 80% Ack 20% Nack
        case 30: // 70% Ack 30% Nack
        case 40: // 60% Ack 40% Nack
        case 50: // 50% Ack 50% Nack
        case 60: // 40% Ack 60% Nack
        case 70: // 30% Ack 70% Nack
        case 80: // 20% Ack 80% Nack
        case 90: // 10% Ack 90% Nack
            numAcks = (ACK_NACK_ARRAY_SIZE* (100-value))/100;
            initAckNackPosition(numAcks, ack_nack_crc_array, cellIndex);
            if(NULL != perNack)
            {
                *perNack = (10-numAcks) *10;
            }
            if(NULL != perAck)
            {
                *perAck = numAcks * 10;
            }
            break;
        default:
            ltePanic("wrong value configured for CRC INDICATION");
            break;
    }
}
/****************************************************************************
 * Function Name  : parseAckNackConfigFile
 * Inputs         : void
 * 
 * 
 * Outputs        :
 * Returns        :
 * Description    : Parse AckNackConfig.txt file for ACK NACK testing 
 *  
 *****************************************************************************/
void parseAckNackConfigFile(void)
{
    SInt8 cellIndex = -1;
    FILE *fp;
    char* line_p = PNULL;
    size_t len = 0;
    ssize_t read;
    char temp[100] = {0};   
    UInt8 tbAckNack;
    /*CLPC_CHG*/
    UInt8 tb1Unsure;
    UInt8 tb2Unsure;
    /*CLPC_CHG*/
    UInt8 numAcks;
    UInt8 crc_indication;
    fp = fopen(HARQ_FEEDBACK_FILE_PATH,"r");
    if (fp == PNULL)
    {
        ltePanic("Unable to open file.\n");
    }

	while( ((read = getline(&line_p, &len, fp)) != -1) && cellIndex < numCells_g)
    {
		if (strncmp(line_p,"[CELL]",6) == 0)
		{
			strncpy(temp,line_p+6,read);
			cellIndex++;
		}
		if (cellIndex >= numCells_g)
			break;

        if (strncmp(line_p,"#",1) == 0)
        {
            if (line_p)
            {
                freeMemSys(line_p);
                line_p = PNULL;
            }
            continue;
        }
        else if (strncmp(line_p,"TB1_ACK_NACK",12) == 0)
        {
            strncpy(temp,line_p+13,read);
            tbAckNack = atoi(temp);

	    fillAckNackOrCrc(tb1_ack_nack_value_array, tbAckNack, &sendAckNack_g[cellIndex],
			&perAckTb1_g[cellIndex],
			&perNackTb1_g[cellIndex], 
			cellIndex);
        }
        /*CLPC_CHG*/
        else if(strncmp(line_p,"TB1_UNSURE",10) == 0)
        {
            strncpy(temp,line_p+11,read);
			perUnsureTb1_g[cellIndex] = atoi(temp);
        }
	/* + Support for toggling configured Nack percentage to 100% ack and vice-versa */
        else if (strncmp(line_p,"TB1_TOGGLE_TICKS",strlen("TB1_TOGGLE_TICKS")) == 0)
        {
            strncpy(temp,line_p+(strlen("TB1_TOGGLE_TICKS")+1),read);
            ToggleTickTB1[cellIndex] = atoi(temp);
        }
	/* - Support for toggling configured Nack percentage to 100% ack and vice-versa */
        /*CLPC_CHG*/
        else if (strncmp(line_p,"TB2_ACK_NACK",12) == 0)
        {
            strncpy(temp,line_p+13,read);
            tbAckNack = atoi(temp);
            fillAckNackOrCrc(tb2_ack_nack_value_array, tbAckNack, NULL,
			&perAckTb2_g[cellIndex],
			&perNackTb2_g[cellIndex],
			cellIndex);

        }
        /*CLPC_CHG*/
        else if(strncmp(line_p,"TB2_UNSURE",10) == 0)
        {
            strncpy(temp,line_p+11,read);
			perUnsureTb2_g[cellIndex] = atoi(temp);
        }
	/* + Support for toggling configured Nack percentage to 100% ack and vice-versa */
        else if (strncmp(line_p,"TB2_TOGGLE_TICKS",strlen("TB2_TOGGLE_TICKS")) == 0)
        {
            strncpy(temp,line_p+(strlen("TB2_TOGGLE_TICKS")+1),read);
            ToggleTickTB2[cellIndex] = atoi(temp);
        }
	/* - Support for toggling configured Nack percentage to 100% ack and vice-versa */
        /*CLPC_CHG*/
        else if (strncmp(line_p,"CRC_Indication",14) == 0)
        {
            strncpy(temp,line_p+15,read);
            crc_indication = atoi(temp);
	    fillAckNackOrCrc(crc_ind_value_array, crc_indication, &crc_indication_g[cellIndex],
             		       NULL,
			       NULL,
			       cellIndex);
        }
        else if (strncmp(line_p,"Signalling_ACK_NACK",19) == 0)
        {
            strncpy(temp,line_p+20,read);
	    signalling_ack_nack_g[cellIndex] = atoi(temp);
	    fprintf(stderr,"signalling_ack_nack_g [%d] \n",signalling_ack_nack_g[cellIndex]);
        }
	/* + Support for toggling configured Nack percentage to 100% ack and vice-versa */
        else if (strncmp(line_p,"CRC_TOGGLE_TICKS",strlen("CRC_TOGGLE_TICKS")) == 0)
        {
            strncpy(temp,line_p+(strlen("CRC_TOGGLE_TICKS")+1),read);
            ToggleTickCRC[cellIndex] = atoi(temp);
        }
	/* - Support for toggling configured Nack percentage to 100% ack and vice-versa */
    }
    if (line_p)
    {
        freeMemSys(line_p);
        line_p = PNULL;
    }
    fclose(fp);
}

/****************************************************************************
 * Function Name  : fapiPrepareSRPdu 
 * Inputs         :
 *
 *
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    : This function will becallled by updateUEAndLCGQueueLoad() 
 ****************************************************************************/
//TA NON_SS
void fapiPrepareSRPdu(UInt16 rnti, UInt8 cellIndex)
{
    FAPI_ulSrIndicationNode_st *srIndNode_p = PNULL;
#ifdef FDD_CONFIG    
    ueContextForUplink *ueContext_p = PNULL;
#endif    
    UInt8 qIndex = 0;
    UInt8 sendSF = 0;
    UInt16 sendSFN = 0;
    UInt16 sendSfnSf = 0;

    sendSF = sfnsf_g[cellIndex] & FAPI_SF_MASK;
    sendSFN = (sfnsf_g[cellIndex] & FAPI_SFN_MASK)>>FAPI_SFN_VALUE_SHIFT;
#ifdef TDD_CONFIG
    ueContextForUplink *ueContextInfo_p = getUEContext(rnti, cellIndex);
    /* CA TDD Changes Start */
    calcNextSRILocation(ueContextInfo_p, &sendSFN, &sendSF, cellIndex);
    /* CA TDD Changes End */
    qIndex = (sendSFN * MAX_SUBFRAME + sendSF + PEER_MAC_DELAY) % MAX_UL_ARRAY;
#elif FDD_CONFIG
    qIndex = ( sendSF + 4 + PEER_MAC_DELAY) % MAX_SUBFRAME;

    sendSF += 4;
    if ( sendSF >= MAX_SUBFRAME )
    {
        sendSF -= MAX_SUBFRAME;
        sendSFN++ ;
        if (  sendSFN == MAX_SFN )
        {
            sendSFN = 0;
        }
    }
#endif    
    sendSfnSf = GENERATE_SUBFRAME_SFNSF(sendSFN, sendSF);


    srIndNode_p = (FAPI_ulSrIndicationNode_st *) 
        getMemFromPool(sizeof(FAPI_ulSrIndicationNode_st), PNULL);
    if ( PNULL == srIndNode_p )
    {
        fprintf(stderr,"Error!! in prepareSRPdu allocation of SR node for rnti = %d\n", rnti);
        return;  
    }
    srIndNode_p->sfnsf = sendSfnSf;
    srIndNode_p->srPduInfo.handle = MAC_PHY_CONVERT_32(1);
    srIndNode_p->srPduInfo.rnti = MAC_PHY_CONVERT_16(rnti);
#ifdef FDD_CONFIG
    ueContext_p = getUEContext(rnti, cellIndex);  
    if ( PNULL == ueContext_p )
    {
        fprintf(stderr,"[%s]:UE Context not fuond for rnti = %d\n",__func__,rnti);
        return;
    }
    if (NULL != ueContext_p->srPduNode_p)
    {
        freeMemPool(ueContext_p->srPduNode_p);
    }
    ueContext_p->srPduNode_p = srIndNode_p;

#elif TDD_CONFIG
    pushNode(&srIndQueue[cellIndex][qIndex], 
            &(srIndNode_p->srNodeAnchor) );
#endif
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
    fprintf(stderr,"SR node pushed into queue at sfn = %d sf = %d\n",sendSFN,sendSF);
#endif
}

/* SPR 11549 fix start */
#ifdef FDD_CONFIG
/****************************************************************************
 * Function Name  : getNextRachOpportunityFdd
 * Inputs         : None
 * Outputs        : eligible sfn, sf, cellIndex
 * Returns        : SUCCESS/FAILURE
 * Description    : This function will return the eligible SFN and SF for RACH
 *                  PDU.
 ****************************************************************************/
MacRetType getNextRachOpportunityFdd(UInt16 *sfn_p, UInt8 *sf_p, 
        UInt8 cellIndex 
        )
{
    MacRetType retVal = MAC_FAILURE;
    UInt16 sfn = SFN_g[cellIndex];
    UInt8  sf = SF_g[cellIndex];
    /*SPR 15909 fix start*/
    tickType_t tick = sfn * MAX_SUBFRAME + sf;;
    tickType_t eligibleTick = sfn * MAX_SUBFRAME;
    /*SPR 15909 fix end*/
    UInt8  eligibleSF = 0;
    UInt8  sfCtr = 0;

    PRACHConfigInfo *prachConfig_p =
        &(prachConfig[cellConfigUeSim_g[cellIndex].prachConfigIndex]);

    for( sfCtr = 0; sfCtr < MAX_SUBFRAME; sfCtr++ )
    {
        /* Get the eligibleSF as per the prachConfigIndex */
        if( prachConfig_p->subFrame[sfCtr])
        {
            eligibleSF = sfCtr;

            if( PREAMBLE_FORMAT_1 == prachConfig_p->preambleFormat ||
                    PREAMBLE_FORMAT_2 == prachConfig_p->preambleFormat )
            {
                /* Preamble format 1 and 2 takes 2 SFs for RACH to reach
                 * eNB, hence adding 1 to eligibleSF */
                /* SPR 13477 fix start */
                eligibleSF = (eligibleSF + 1) % MAX_SUBFRAME ;
                /* SPR 13477 fix end */
            }
            else if( PREAMBLE_FORMAT_3 == prachConfig_p->preambleFormat )
            {
                /* Preamble format 3 takes 3 SFs for RACH to reach
                 * eNB, hence adding 2 to eligibleSF */
                /* SPR 13477 fix start */
                eligibleSF = (eligibleSF + 2) % MAX_SUBFRAME ;
                /* SPR 13477 fix end */
            }

            retVal = MAC_SUCCESS;
            break;
        }
    }

    if( MAC_SUCCESS == retVal )
    {
        if(eligibleSF <= sf)
        {
            /* Increment eligible tick by 10 in whih RACH needs to be sent */
            UpdateTick(&eligibleTick, MAX_SUBFRAME);
        }

        /* Increment eligible tick by eligibleSF in whih RACH needs to be
         * sent */
        UpdateTick(&eligibleTick, eligibleSF);

        if (eligibleTick >= tick)
        {
            /* Calculate eligible SFN-SF from the eligible tick calculated */
            *sfn_p = (eligibleTick / MAX_SUBFRAME) % MAX_SFN_VALUE;
            *sf_p = eligibleTick % MAX_SUBFRAME;
        }
        /* SPR 13477 fix start */
        if( EVEN == prachConfig_p->prachSFN )
        {
            /* Increment SFN by 1 if it is not even */
            if( 0 != (*sfn_p % 2) )
            {
                *sfn_p += 1;
            }
        }
        /* SPR 13477 fix end */
    }
    return retVal;
}
#endif
/* SPR 11549 fix end */

/****************************************************************************
 * Function Name  : fapiPrepareRAInfo 
 * Inputs         :
 *
 *
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    : This function will prepare the RACH Indication Node and 
 *                  Push into RACH Queue.
 *
 ****************************************************************************/
MacRetType fapiPrepareRAInfo(UInt8 raReqIndex, UInt8 cellIndex) 
{
    /* SPR 11549 fix end */
    MacRetType  retVal = MAC_FAILURE;
    /* SPR 11549 fix end */
    FAPI_l1ApiMsg_st    *l1ApiMsg_p = PNULL;
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
    FAPI_rachIndicationR9_st *rachIndBody_p = PNULL;
#else
    FAPI_rachIndication_st *rachIndBody_p = PNULL;
#endif
    FAPI_ulRachIndicationNode_st *ulRachIndNode_p = PNULL;
    UInt32              liApiMsgLen = 0;
    UInt16              l1ApiMsgBodyLen = 0; 
    RARequest *raRnti_p      = PNULL;
    UInt8     qIndex = 0;
    UInt16    SFN    = 0;
    UInt8     SF     = 0;
    UInt16    sfnsf = sfnsf_g[cellIndex];

    FAPI_VendorSpecificForRACHInd_st *vendorSpecificRachData_p = PNULL;

#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
    l1ApiMsgBodyLen = FAPI_RACH_INDICATION_BODY_LEN_R9;
#else
    l1ApiMsgBodyLen = FAPI_RACH_INDICATION_BODY_LEN;
#endif


     liApiMsgLen = L1_PARTIAL_API_MSG_SIZE + l1ApiMsgBodyLen;
#ifdef TDD_CONFIG
    RachResLocationQuad rachLoc = {0};
    /* SPR 11549 fix start */
    retVal = getNextRachOpportunity(&SFN, &SF, &rachLoc, cellIndex );
#elif FDD_CONFIG
    retVal = getNextRachOpportunityFdd( &SFN, &SF, cellIndex
            );
#endif
    if( retVal == MAC_SUCCESS)
    {

#ifdef TDD_CONFIG
        qIndex = (SFN * MAX_SUBFRAME + SF+ PEER_MAC_DELAY ) % MAX_UL_ARRAY;
#elif FDD_CONFIG
        qIndex = (SFN * MAX_SUBFRAME + SF+ PEER_MAC_DELAY ) % MAX_RACH_ARRAY;
#endif
        /* SPR 11549 fix end */
        fprintf(stderr,"RACH Opportunity ...SFN [%d] SF[%d] qIndex[%d]\n", SFN, SF, qIndex);
        ulRachIndNode_p = ( FAPI_ulRachIndicationNode_st * ) 
            getMemFromPool(sizeof(FAPI_ulRachIndicationNode_st), PNULL);
        if ( PNULL == ulRachIndNode_p )
        {
            fprintf(stderr,"Error!! in allocation node for rachInd Queue\n");
            return MAC_FAILURE;  
        }

        ulRachIndNode_p->rachInd_p = ( UInt8 *) getMemFromPool(liApiMsgLen+sizeof(FAPI_VendorSpecificForRACHInd_st) , PNULL);
        if ( PNULL == ulRachIndNode_p->rachInd_p )
        {
            fprintf(stderr,"Error!! in allocation of l1Api buffer for RACH Indication\n");
            return MAC_FAILURE;  
        }
        l1ApiMsg_p = (FAPI_l1ApiMsg_st *) ulRachIndNode_p->rachInd_p;
        ulRachIndNode_p->msgLen = liApiMsgLen;

        sfnsf = GENERATE_SUBFRAME_SFNSF(SFN, SF);    
        ulRachIndNode_p->sfnsf = sfnsf;

        raRnti_p = &raRntiArr_g[cellIndex][raReqIndex];


        l1ApiMsg_p->msgId = PHY_UL_RACH_INDICATION;
        l1ApiMsg_p->lenVendorSpecific = 0;
        l1ApiMsg_p->msgLen = MAC_PHY_CONVERT_16(l1ApiMsgBodyLen);
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
        rachIndBody_p = ( FAPI_rachIndicationR9_st *) &(l1ApiMsg_p->msgBody[0]);
#else
        rachIndBody_p = ( FAPI_rachIndication_st *) &(l1ApiMsg_p->msgBody[0]);
#endif       
        rachIndBody_p->sfnsf = MAC_PHY_CONVERT_16(sfnsf);
        rachIndBody_p->numOfPreamble = MAC_PHY_CONVERT_16(1);
        rachIndBody_p->rachPduInfo[0].rnti = MAC_PHY_CONVERT_16(raRnti_p->RaRnti);
        rachIndBody_p->rachPduInfo[0].preamble = raRnti_p->preamble;
        /* + SPR 11024 Fix */ 
        rachIndBody_p->rachPduInfo[0].timingAdvance = MAC_PHY_CONVERT_16(taValues_g[cellIndex].taRach); /* TA_CHG */
        /* - SPR 11024 Fix */ 
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10) || defined(FAPI_RELEASE9))
        rachIndBody_p->rachPduInfo[0].release9Param.timingAdvanceR9=
            MAC_PHY_CONVERT_16( rel9TaValues_g[cellIndex].rel9TARach\
                    [(rel9TaCntr++)%rel9TaValues_g[cellIndex].numTaRach]);;

#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"Timing Advance R9 in RACH INDICATION [%d]\n",rachIndBody_p->rachPduInfo[0].release9Param.timingAdvanceR9);
#endif
#endif
            //#endif

        vendorSpecificRachData_p = (FAPI_VendorSpecificForRACHInd_st *) ((UInt8 *)(l1ApiMsg_p->msgBody) + l1ApiMsgBodyLen);
        l1ApiMsg_p->lenVendorSpecific = MAC_PHY_CONVERT_16(sizeof(FAPI_VendorSpecificForRACHInd_st));//32;
        FAPI_UEMeasurementInRACH_st tempUeMeasInfoInRACHForUE = {0,{0}};
        vendorSpecificRachData_p->ueMeasInfoInRACHForUEs = tempUeMeasInfoInRACHForUE;
        vendorSpecificRachData_p->ueMeasInfoInRACHForUEs.numOfpreambles = MAC_PHY_CONVERT_16(1); 
        vendorSpecificRachData_p->ueMeasInfoInRACHForUEs.rel9TAInfo[0].preamble = (rachIndBody_p->rachPduInfo[0].preamble); 
        vendorSpecificRachData_p->ueMeasInfoInRACHForUEs.rel9TAInfo[0].timingAdvanceR9 = 0;

        fprintf(stderr,"RACH Indication PDU Pushed in to queue SFN [%d] SF[%d]\n",
                SFN, SF);
        pushNode(&(rachIndQueue[cellIndex][qIndex]), 
                &(ulRachIndNode_p->rachNodeAnchor));

        /*Change the state to WAIT_RAR*/
        raRnti_p->state = WAIT_RAR;

        /* increment the stats */
        statsGeneralInfo_g.statsRaResponsePending++;

        return MAC_SUCCESS;  
    }
    else
    {
        return MAC_FAILURE;  
    }
}

/****************************************************************************
 * Function Name  : getNextPreambleIndex 
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    :
 *
 ****************************************************************************/
UInt8 getNextPreambleIndex()
{
    UInt8 preambleIndex = 0;

    if(preambleCircularIndex >= preambleRangeEnd_g)
    {
        preambleCircularIndex = preambleRangeStart_g;
    }
    preambleIndex = preambleCircularIndex;

    preambleCircularIndex++;

    return preambleIndex;
}
#if 0
/****************************************************************************
 * Function Name  : initSHMInterface 
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    :
 *
 ****************************************************************************/
void initSHMInterface()
{
#ifdef LTE_MAC_UT_LOG
    LTE_LOG(LOG_INFO,&MACModuleLogDetail_g, "[%s] Entry ", __func__ );
#endif

    UInt32 uid=getuid();

    UInt32 shmMsgDlID= (uid<<16)|SHM_MSG_DL_ID;
    UInt32 shmMsgUlID= (uid<<16)|SHM_MSG_UL_ID;

#ifdef LTE_MAC_UT_LOG
    LTE_LOG(LOG_INFO,&MACModuleLogDetail_g,"Creating Shared Message Queue for Downlink");
#endif
    if ((shMsgQIdDL_g = msgget(shmMsgDlID, IPC_CREAT | IPC_EXCL|0666 )) < 0)
    {
        if(errno == 17)
        {
            shMsgQIdDL_g = msgget(shmMsgDlID, IPC_CREAT|0666 );

            if((msgctl(shMsgQIdDL_g,IPC_RMID,NULL)) ==0)
            {
                if ((shMsgQIdDL_g = msgget(shmMsgDlID, IPC_CREAT | IPC_EXCL|0666 )) < 0)
                {
#ifdef LTE_MAC_UT_LOG
                    LTE_LOG(LOG_INFO,&MACModuleLogDetail_g," msgget errno =%d",errno);
#endif
                    ltePanic("msgget failed");

                }
            }
            else
            {
#ifdef LTE_MAC_UT_LOG
                LTE_LOG(LOG_INFO,&MACModuleLogDetail_g," msgctl errno =%d",errno);
#endif
                ltePanic("msgctl failed");
            }
        }
        else
        {
#ifdef LTE_MAC_UT_LOG
            LTE_LOG(LOG_INFO,&MACModuleLogDetail_g," msgget errno =%d",errno);
#endif
            ltePanic("msgget failed");
        }
    }

#ifdef LTE_MAC_UT_LOG
    LTE_LOG(LOG_INFO,&MACModuleLogDetail_g,"Creating Shared Message Queue for Uplink");
#endif
    if ((shMsgQIdUL_g = msgget(shmMsgUlID, IPC_CREAT | IPC_EXCL|0666 )) < 0)
    {
        if(errno == 17)
        {
            shMsgQIdUL_g = msgget(shmMsgUlID, IPC_CREAT|0666 );

            if((msgctl(shMsgQIdUL_g,IPC_RMID,NULL)) ==0)
            {
                if ((shMsgQIdUL_g = msgget(shmMsgUlID, IPC_CREAT | IPC_EXCL|0666 )) < 0)
                {
#ifdef LTE_MAC_UT_LOG
                    LTE_LOG(LOG_INFO,&MACModuleLogDetail_g," msgget errno =%d",errno);
#endif
                    ltePanic("msgget failed");

                }
            }
            else
            {
#ifdef LTE_MAC_UT_LOG
                LTE_LOG(LOG_INFO,&MACModuleLogDetail_g," msgctl errno =%d",errno);
#endif
                ltePanic("msgctl failed");
            }
        }
        else
        {
#ifdef LTE_MAC_UT_LOG
            LTE_LOG(LOG_INFO,&MACModuleLogDetail_g," msgget errno =%d",errno);
#endif
            ltePanic("msgget failed");
        }
    }

#ifdef LTE_MAC_UT_LOG
    LTE_LOG(LOG_INFO,&MACModuleLogDetail_g,"[%s] Exit ", __func__ );
#endif

}

/****************************************************************************
 * Function Name  : fapiPhyTimerThread 
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    : This is the starting point for the timer thread. 
 *                  It will increment the SFN, SF and global tick once 
 *                  register with perr MAC
 *
 ****************************************************************************/

void * fapiPhyTimerThread(void * arg)
{

    /*
     **
     **  The funtionality for usage of timer based on 
     **  pselect or nanoSleep is a COMPILE TIME choice. 
     **
     */
#ifndef NANO_SLEEP_TIMER
    struct timespec timer;
    SInt32 retVal = 0;
    timer.tv_nsec = tickValue_g;
    timer.tv_sec = 0;
#else
    struct timespec t1, t2;
    /*SPR 15909 fix start*/
    tickType_t tempTickValue = tickValue_g;
    /*SPR 15909 fix end*/
    SInt8  timer_ret = 0;
#endif

    /*
     **  
     **  The Following Binding of CORE is valid only when
     **  the REAL TIME THREAD EXECUTION is not defined, as
     **  in the other case we binding to core is applied just
     **  after creation of thread.  
     **  
     */
    //fprintf(stderr, "\n========= PHY Timer Thread Binding ============\n");
    THREAD_TO_BIND_SET_CORE_NO( fapiPhyTimerThread_g , uePhyTimerThreadCoreNum_g);
    //fprintf(stderr, "\n======== Verify PHY Timer Thread Binding ======\n");
    THREAD_TO_BIND_GET_CORE_NO(fapiPhyTimerThread_g, uePhyTimerThreadCoreNum_g);
    //fprintf(stderr, "\n===============================================\n");
    //fprintf(stderr, "in PhyTimerThread before while....!!!\n");

    while (  1 )
    {  
        if ( macRegFlag_g  == REG_SUCCESS)
        {
            break;
        }
    }
    while(1)
    {
#ifndef NANO_SLEEP_TIMER
        rlcUeSimLoop_g = FALSE;
        retVal = pselect(0, NULL, NULL, NULL, &timer, NULL);
#else
        rlcUeSimLoop_g = FALSE;
        timer_ret=0;
        do{
            if(timer_ret==0)
            {
                t1.tv_sec = 0;
                t1.tv_nsec = tempTickValue;
            }
            else
            {
                t1.tv_nsec=t2.tv_nsec;
                t1.tv_sec=t2.tv_sec;
            }
            timer_ret = nanosleep(&t1, &t2);
        }while(timer_ret<0);
#endif

        semPost(&fapiUlDispatcherThreadSem_g);

        rlcUeSimLoop_g = TRUE;
        semPost(&rlcPdcprunThreadSem_g);

    }
}


/*****************************************************************************
 * Function Name  : calculateSubHeaderLength 
 * Inputs         :
 * Outputs        : None
 * Returns        : None
 * Description    : 
 *                  
 *****************************************************************************/
UInt8* calculateSubHeaderLength(UInt8 *headerPtr_p,
        UInt32 *len_p,
        UInt32 *dataPtrPos_p)
{
    /*check whether length is greater than 128 bytes 
     *or less than 128 bytes
     */

    *len_p = 0;

    /*Reffer section 6.1.2 in 36321-850.doc*/
    if (*headerPtr_p & 0x80)
    {
        /*length is greater than 128 bytes*/
        *len_p = *headerPtr_p++ & 0x7F;
        *len_p <<= 8;

        *len_p |= *headerPtr_p;
        *dataPtrPos_p = *dataPtrPos_p+3;
    }
    else
    {
        /*length is less than 128 bytes*/
        *len_p = *headerPtr_p & 0x7F;
        *dataPtrPos_p = *dataPtrPos_p + 2;
    }


    return headerPtr_p;
}


/*****************************************************************************
 * Function Name  : processDLDemuxData
 * Inputs         :  
 * Outputs        : None
 * Returns        : None
 * Description    : This function segregates the data based on LC id and 
 *                  call dlDataDeMultiplexAndSend() to break data and send to
 *                  RLC
 *****************************************************************************/
UInt32 processDLDemuxData( UInt8  *data_p,
        void   *zeroBufCpy_p,
        UInt32 dataLen,
        UInt16 ueIndex,
        UInt8 txCellIndex)
{
    UInt8  *dataPtr_p       = PNULL;
    UInt8  *headerPtr_p     = PNULL;  
    UInt32 extnFlag         = FALSE;
    UInt32 startPaddingFlag = FALSE;
    UInt32 sucessDecodeFlag = TRUE;
    UInt32 lcId        = 0;
    UInt32 pos         = 0;
    UInt32 dataPtrPos  = 0;
    UInt32 remainingPayloadLength = 0;
    DemuxDLDataBase demuxData[MAX_NUM_CHANNELS] = {{0}};
    DemuxDLDataBase *demuxData_p = PNULL;

    dataPtr_p   = (UInt8 *)data_p;
    headerPtr_p = (UInt8 *)data_p;

    demuxData_p            = &demuxData[0];
    remainingPayloadLength = dataLen;

    do
    {
        /*Reffer section 6.1.2 and 6.2 of 36321-850.doc*/
        /* <------ 1 Octet ------>
         * +++++++++++++++++++++++
         * |R |R |E |   LCID     |
         * +++++++++++++++++++++++
         * R    - Reserved (1 bit)
         * E    - Extention bit (1 bit)
         * LCID - Logical channel id (5 bits)
         */
        /*Subheader with variable length*/
        /*Reffer section 6.1.2 and 6.2 of 36321-850.doc*/
        /* ++++++++++++++++++++++
         * |R|R|E|   LCID       | Oct 1
         * ++++++++++++++++++++++
         * |F|       L          | Oct 2 
         * ++++++++++++++++++++++
         * R    - Reserved (1 bit)
         * E    - Extention bit (1 bit)
         * LCID - Logical channel id (5 bits)
         * L    - Length 
         */
        /* ++++++++++++++++++++++
         * |R|R|E|   LCID       | Oct 1
         * ++++++++++++++++++++++
         * |F|       L          | Oct 2 
         * ++++++++++++++++++++++
         * |         L          | Oct 3
         * ++++++++++++++++++++++
         * R    - Reserved (1 bit)
         * E    - Extention bit (1 bit)
         * LCID - Logical channel id (5 bits)
         * L    - Length 
         */

        lcId = (*dataPtr_p & 0x1F);
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
        fprintf(stderr,"in function processDLDemuxData: lcId = %d\n", lcId);
#endif

        if (*dataPtr_p & UL_PDU_EXTN_FLAG)
        {
            extnFlag = TRUE;
        }
        else
        {
            extnFlag = FALSE;
        }

        switch(lcId)
        {
            case LCID_1:
            case LCID_2:
            case LCID_3:
            case LCID_4:
            case LCID_5:
            case LCID_6:
            case LCID_7:
            case LCID_8:
            case LCID_9:  
            case LCID_10:
                {
                    (demuxData_p + pos)->lchId = lcId;

                    if (((TRUE == startPaddingFlag) && (FALSE == extnFlag)) ||
                            (FALSE == extnFlag))
                    {
                        /*This is the case with 1/2 byte padding at the start of 
                         *PDU or no padding. So the last subheader is of 1byte
                         *i.e no length field.
                         */
                        dataPtrPos++;
                        (demuxData_p + pos)->length = 
                            remainingPayloadLength - dataPtrPos;
                    }
                    else if (TRUE == extnFlag)
                    {
                        /*Increment the pointer to point to length field*/
                        dataPtr_p++;
                        dataPtr_p = calculateSubHeaderLength(dataPtr_p, 
                                &(demuxData_p + pos)->length,
                                &dataPtrPos);
                    }

                    remainingPayloadLength = 
                        remainingPayloadLength - (demuxData_p + pos)->length;
                    pos++;
                }
                break;

            case PADDING_LCH:
                {
                    if (FALSE == extnFlag)
                    {
                        dataPtrPos++;
                        /*case where padding is of 1 byte and present 
                         *after the last MAC PDU subheader
                         */
                        if(remainingPayloadLength > dataPtrPos)
                        {
                            (demuxData_p + pos)->length = 
                                remainingPayloadLength - dataPtrPos ;
                        }
                        else
                        {
                            (demuxData_p + pos)->length = 
                                dataPtrPos - remainingPayloadLength;
                        }

                        remainingPayloadLength = 
                            remainingPayloadLength - (demuxData_p + pos)->length;
                    }
                    else
                    {
                        dataPtrPos++;
                    }
                }
                break;

            default:
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                fprintf(stderr,"processDemuxData: Invalid lcId=%d\n",lcId);
#endif
                break;     
        }
        dataPtr_p++;
    }while ((TRUE == extnFlag) && (TRUE == sucessDecodeFlag));

#if 0
    /*now dataPtr_p reaches the 1st SDU data and header points the 1st MAC 
     *sub-header
     */
    if (sucessDecodeFlag)
    {
        UInt32 dataLenExlHeader = 0;
        UInt32 i = 0;

        /*Check the length received in the subheader to 
         *avoid segmentation fault
         */
        /*dataPtrPos incremented one byte extra*/
        dataLenExlHeader = dataLen - (dataPtrPos - 1);
        for (i = 0; i < pos; i++)
        {
            if ((demuxData_p + i)->length > dataLenExlHeader)
            {
                sucessDecodeFlag = 0;
                break;
            }
            dataLenExlHeader -= (demuxData_p + i)->length;
        }    
    }

    if (FALSE == sucessDecodeFlag)
    {
        return MAC_FAILURE;
    }
#endif

    dlDataDeMultiplexAndSend(demuxData, 
            zeroBufCpy_p,
            dataPtr_p,
            pos, 
            dataPtrPos,
            ueIndex,
            txCellIndex);
    return 1;
}



/*****************************************************************************
 * Function Name  : dlDataDeMultiplexAndSend
 * Inputs         : demuxData_p - Pointer contains the LCID and length of data 
 *                        received per lcid, in the sequence received in UL pdu.
 *                  origDataPtr_p - Points to UL pdu received (including header)
 *                  dataPtr_p - Points to data section in UL pdu (no header)
 *                  ueIndex - Index corresponds to array of UE context
 *                  rcvdRNTI - received RNTI value in UL message
 *                  pos - contains the number of lcid data received in UL pdu
 *                  dataPtrPos - Position of the dataPtr_p position
 *                  ttiCounter - TTI in which UL message received
 *                  thdIndex - Thread index
 *                  dlDelay - DL delay
 * Outputs        : None
 * Returns        : None
 * Description    : This function demultiplex the data received from PHY and
 *                  send to RLC or RRC based on the LC ID data. It also fill
 *                  container's BSR queue and update the UL context based 
 *                  on the received BSR 
 *****************************************************************************/
void dlDataDeMultiplexAndSend(DemuxDLDataBase *demuxData_p,
        UInt8   *origDataPtr_p,
        UInt8   *dataPtr_p,
        UInt32  pos,
        UInt32  dataPtrPos,
        UInt16  ueIndex,
        UInt8 txCellIndex)
{

    UInt32 rlcFlag      = FALSE;
    UInt32 idx          = 0;        
    UInt32 lcIdx     = 0;
    UInt32 lchId     = 0;
    UInt32 length    = 0;
    RLCUplinkData         *dataToRlc_p = PNULL;        
    RLCUplinkDataInfo     *rlcLCIdData_p      = PNULL;


    for (idx=0; idx < pos; idx++)
    {
        lchId  = (demuxData_p + idx)->lchId;
        length = (demuxData_p + idx)->length;

        /*find logical channel ID*/

        switch (lchId)
        {
            case LCID_1:
            case LCID_2:
            case LCID_3:
            case LCID_4:
            case LCID_5:
            case LCID_6:
            case LCID_7:
            case LCID_8:
            case LCID_9:  
            case LCID_10:
                {
                    /*data arrrived for RLC*/
                    if (PNULL == dataToRlc_p)
                    {
                        dataToRlc_p = (RLCUplinkData*)getMemFromPool(
                                (UInt32)sizeof(RLCUplinkData),PNULL);
                        if (PNULL == dataToRlc_p)
                        {
                            ltePanic("Unable to allocate memory\n");
                        }
                    }

                    {
                        UInt8 *rlcData_p;


                        void *zcb_p = NULL;
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                        //fprintf(stderr,"allocting zcb for length = %d lcId =%d\n",length, lchId);
#endif

                        zcb_p = (UInt8 *)msgAlloc(PNULL, length, 0, 0);

                        if ( PNULL == zcb_p ) 
                        {
                            ltePanic("#########msgAlloc failed in %s for length = %d",__FUNCTION__, length);
                        }

                        if(PNULL == msgInsert(zcb_p, 0, dataPtr_p, length))
                        {
                            ltePanic("#########msgInsert failed in %s",__FUNCTION__);
                        }

                        ////fprintf(stderr,"######## Length %d msgSize %d\n",length,msgSize(zcb_p, NULL));
                        rlcData_p = (UInt8*)zcb_p; 


                        rlcLCIdData_p = &dataToRlc_p->rlcDataArr[lcIdx];

                        /* fill the struct for sending data to RLC*/
                        rlcLCIdData_p->rlcdataBuffer = rlcData_p;
                        rlcLCIdData_p->dataLength    = length;
                        rlcLCIdData_p->lcId          = lchId;
                        lcIdx++;
                        dataToRlc_p->numLCInfo = lcIdx;
                        rlcFlag = TRUE;
#ifdef UE_SIM_ENABLE_PRINTF_LOGS
                        //fprintf(stderr, "Data Received at Ue Sim for lcIdx  %d of length = %d to be sent to RLC\n", lcIdx, length);
#endif
#if 0  
                        UInt32 u = 0;
                        UInt8 *x_p = NULL;
                        QSEGMENT segment;
                        //fprintf(stderr, "Data Received at Ue Sim for lcIdx  %d of length = %d to be sent to RLC\n", lcIdx, length);

                        //fprintf(stderr, "\n");

                        while(u < length)
                        {
                            //fprintf(stderr, "0X%X ", x_p[u++]);
                        }
                        //fprintf(stderr, "\n");
#endif


                    }

                    /*increment dataPtr_p by len so that dataPtr_p reaches 
                     *to start of next RLC SDU.
                     */
                    dataPtr_p += length;
                }    
                break;

            default:
                {
                    /*increment data pointer to point to next SDU*/
                    dataPtr_p+=length;
                    dataPtrPos = dataPtrPos + length;
                }    
                break;
        }
    }



    if (TRUE == rlcFlag)
    {
        if (!macUeDataInd(ueIndex, dataToRlc_p))
        {
            //fprintf(stderr,"[%s]: WARNING: macUeDataInd() returned failure\n",__func__);
        }
    }

}
#endif

//#endif /*TA: Incorrect SS Flag used*/

/* + MEAS_GAP_CHG */

/****************************************************************************
 *  Function Name  : checkIsMeasurementGapPeriodON 
 *  Inputs         : recvSFN - Received SFN
 *                      recvSF - Received SF 
 *                      ueDLInfo_p - pointer to the DLUEContext of UE
 *  Outputs        :
 *  Returns        : MAC_SUCESS or MAC_FAILURE 
 *  Description    : This function check whether any request of transmission 
 *                   (DL or UL) or any Dl and Ul config received during 
 *                    measurement gap period if so then return MAC_SUCCESS.
 * 
 ****************************************************************************/
static inline MacRetType  checkIsMeasurementGapPeriodON ( UInt16 recvSFN,
        UInt8 recvSF,
        DLUEContext  *ueDLInfo_p ) 
{
    UInt8 measGapPeriodicity =
        ueDLInfo_p->measGapContext.measGapStaticParam.measurementGapPeriodicity;

    UInt8 flooredGapoffset =
        ueDLInfo_p->measGapContext.measGapStaticParam.flooredGapOffset;

    UInt8 modGapoffset =
        ueDLInfo_p->measGapContext.measGapStaticParam.modGapOffset;

    if ( ( recvSFN % measGapPeriodicity ) == flooredGapoffset )
    {
        if (( recvSF >= modGapoffset ) && ( recvSF < ( modGapoffset + 6 ) ) ) 
        {    
            return MAC_SUCCESS;
        }
    }
    /*   to check Overlapping measGap across adjacent SFNs */

    else if ( 4 <= modGapoffset )
    { 
        if (( recvSFN % measGapPeriodicity) == 
                ( flooredGapoffset + 1 ) )
        {

            if ( recvSF < ( ( modGapoffset + 6 ) % 10 ) ) 
            {
                return MAC_SUCCESS;
            }   
        } 
    }
    return MAC_FAILURE;

}

/****************************************************************************
 *  Function Name  : getRNTIFromULConfigPdu
 *  Inputs         : ulConfigPdu_p - pointer to the FAPI_ulPDUConfigInfo_st                  
 *  Outputs        :
 *  Returns        : rnti depend upon PDU received
 *  Description    : This function shall calculate the rnti based on the UL
 *                   Config PDU received.
 *
 ****************************************************************************/
static inline UInt16 getRNTIFromULConfigPdu( FAPI_ulPDUConfigInfo_st 
        *ulConfigPdu_p )
{
    UInt16 rnti = 0;
    FAPI_ulSCHPduInfo_st *ulSchPdu_p = PNULL;
    FAPI_ulSCHHarqPduInfo_st *ulSchHarqPdu_p = PNULL;
/* SPR 10867 Fix Start */
#ifdef FAPI_4_0_COMPLIANCE
    FAPI_ulSCHCqiRiPduInfoR9_st *ulCqiRiPdu_p = PNULL;
    FAPI_ulSCHCqiHarqRIPduInfoR9_st *ulCqiHarqRiPdu_p = PNULL;
#else
    FAPI_ulSCHCqiRiPduInfo_st *ulCqiRiPdu_p = PNULL;
    FAPI_ulSCHCqiHarqRIPduInfo_st *ulCqiHarqRiPdu_p = PNULL;
#endif
/* SPR 10867 Fix End */
    FAPI_uciCqiPduInfo_st *uciCqiPdu_p = PNULL;
    FAPI_uciSrPduInfo_st  *uciSrPdu_p = PNULL;
    FAPI_uciHarqPduInfo_st *uciHarqPdu_p = PNULL;
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
    FAPI_uciCqiHarqPduInfoR9_st *uciCqiHarqPdu_p = PNULL;
#else
    FAPI_uciCqiHarqPduInfo_st *uciCqiHarqPdu_p = PNULL;
#endif
    FAPI_uciCqiSrPduInfo_st *uciCqiSrPdu_p = PNULL;
/* SPR 10867 Fix Start */
#ifdef FAPI_4_0_COMPLIANCE
    FAPI_uciSrHarqPduInfoR9_st *uciSrHarqPdu_p = PNULL;
    FAPI_uciCqiSrHarqPduInfoR9_st *uciCqiSrHarqPdu_p = PNULL;
#else
    FAPI_uciSrHarqPduInfo_st *uciSrHarqPdu_p = PNULL;
    FAPI_uciCqiSrHarqPduInfo_st *uciCqiSrHarqPdu_p = PNULL;
#endif
/* SPR 10867 Fix End */
    FAPI_srsPduInfo_st *srsPdu_p = PNULL;
    UInt8 uciPduType = ulConfigPdu_p->ulConfigPduType;

    if ( FAPI_ULSCH == uciPduType )
    {
        ulSchPdu_p = (FAPI_ulSCHPduInfo_st *)&ulConfigPdu_p->ulPduConfigInfo[0];
        rnti = MAC_PHY_CONVERT_16(ulSchPdu_p->rnti);
    }

    else if ( FAPI_ULSCH_HARQ == uciPduType )
    {
        ulSchHarqPdu_p = (FAPI_ulSCHHarqPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
        rnti = MAC_PHY_CONVERT_16(ulSchHarqPdu_p->ulSCHPduInfo.rnti);
    }
    else if(FAPI_ULSCH_CQI_RI == uciPduType)
    {
/* SPR 10867 Fix Start */
#ifdef FAPI_4_0_COMPLIANCE
        ulCqiRiPdu_p = (FAPI_ulSCHCqiRiPduInfoR9_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#else
        ulCqiRiPdu_p = (FAPI_ulSCHCqiRiPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#endif
/* SPR 10867 Fix End */
        rnti = MAC_PHY_CONVERT_16(ulCqiRiPdu_p->ulSCHPduInfo.rnti);
    }

    else if(FAPI_ULSCH_CQI_HARQ_RI == uciPduType)
    {
/* SPR 10867 Fix Start */
#ifdef FAPI_4_0_COMPLIANCE
        ulCqiHarqRiPdu_p = (FAPI_ulSCHCqiHarqRIPduInfoR9_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#else
        ulCqiHarqRiPdu_p = (FAPI_ulSCHCqiHarqRIPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#endif
/* SPR 10867 Fix End */
        rnti = MAC_PHY_CONVERT_16(ulCqiHarqRiPdu_p->ulSCHPduInfo.rnti);
    }

    else if ( FAPI_UCI_CQI == uciPduType )
    {
        uciCqiPdu_p = (FAPI_uciCqiPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
        rnti = MAC_PHY_CONVERT_16(uciCqiPdu_p->rnti);
    }

    else if ( FAPI_UCI_SR == uciPduType )
    {
        uciSrPdu_p = (FAPI_uciSrPduInfo_st *)&ulConfigPdu_p->ulPduConfigInfo[0];
        rnti = MAC_PHY_CONVERT_16(uciSrPdu_p->rnti);
    }

    else if ( FAPI_UCI_HARQ == uciPduType )
    {
        uciHarqPdu_p = (FAPI_uciHarqPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
        rnti = MAC_PHY_CONVERT_16(uciHarqPdu_p->rnti);
    }

    else if( FAPI_UCI_CQI_HARQ == uciPduType )
    {

#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
        uciCqiHarqPdu_p = (FAPI_uciCqiHarqPduInfoR9_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#else
        uciCqiHarqPdu_p = (FAPI_uciCqiHarqPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#endif
        rnti = MAC_PHY_CONVERT_16(uciCqiHarqPdu_p->rnti);
    }

    else if ( FAPI_UCI_SR_HARQ == uciPduType )
    {
/* SPR 10867 Fix Start */
#ifdef FAPI_4_0_COMPLIANCE
        uciSrHarqPdu_p = (FAPI_uciSrHarqPduInfoR9_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#else
        uciSrHarqPdu_p = (FAPI_uciSrHarqPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#endif
/* SPR 10867 Fix End */
        rnti = MAC_PHY_CONVERT_16(uciSrHarqPdu_p->rnti);
    }

    else if( FAPI_UCI_CQI_SR == uciPduType )
    {
        uciCqiSrPdu_p = (FAPI_uciCqiSrPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
        rnti = MAC_PHY_CONVERT_16(uciCqiSrPdu_p->rnti);
    }

    else if( FAPI_UCI_CQI_SR_HARQ == uciPduType )
    {
/* SPR 10867 Fix Start */
#ifdef FAPI_4_0_COMPLIANCE
        uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfoR9_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#else
        uciCqiSrHarqPdu_p = (FAPI_uciCqiSrHarqPduInfo_st *)&ulConfigPdu_p->
            ulPduConfigInfo[0];
#endif
/* SPR 10867 Fix End */
        rnti = MAC_PHY_CONVERT_16(uciCqiSrHarqPdu_p->rnti);
    }

    else if (FAPI_SRS == uciPduType )
    {
        srsPdu_p =(FAPI_srsPduInfo_st *)&ulConfigPdu_p->ulPduConfigInfo[0];
        rnti =  MAC_PHY_CONVERT_16(srsPdu_p->rnti);
    }

    return rnti;
}

/****************************************************************************
 *  Function Name  : getDLUEContextFromRnti
 *  Inputs         : rnti - Rnti of the UE
 *  				 cellIndex 
 *  Outputs        : DL context of the UE
 *  Returns        : Pointer to the DLUEContext
 *  Description    : This function shall return the pointer to the DLUEContext
 *                   of the UE which is calulate from the rnti.
 * 
 *****************************************************************************/
static inline DLUEContext* getDLUEContextFromRnti( UInt16 rnti, UInt8 cellIndex )
{    
    DLUEContext *newUEContext_p = PNULL;
	RNTIInfo *rntiInfo_p = PNULL;
	rntiInfo_p = getRntiInfofromRNTIMap(rnti, cellIndex);
    /* + SPS_TDD_CHANGES */
    if ((PNULL != rntiInfo_p) && (rntiInfo_p->ueIndex < MAX_UE_SUPPORTED))
        /* - SPS_TDD_CHANGES */
    {
#if 0
        if( rnti >= cellConfigUeSim_g[cellIndex].startSpsCrnti && rnti <= cellConfigUeSim_g[cellIndex].endSpsCrnti)
        {
            rntiInfo_p->ueIndex = (rnti) - cellConfigUeSim_g[cellIndex].startSpsCrnti;
            rntiInfo_p->rntiType = SPS_CRNTI;
        }
#endif
        newUEContext_p = dlUECtxInfoArr_g[rntiInfo_p->ueIndex].dlUEContext_p;
    }
    return newUEContext_p;
}

/* - MEAS_GAP_CHG */

/* + CQI_4.1 */
/****************************************************************************
 *  Function Name  : getReverseValue
 *  Inputs         : numOfBits
 *                   value - value to be reversed                  
 *  Outputs        : 
 *  Returns        : reverse value
 *  Description    : This function reverse the value
 ****************************************************************************/
UInt32 getReverseValue(UInt8 numOfBits,
        UInt32 value)
{
    UInt32 revValue          = 0;
    UInt32 temp1             = 0;
    UInt32 temp2             = 0;
    UInt32 y                 = 0;
    UInt32 z                 = 0;
    UInt8  i                 = 0;

    if(numOfBits % 2 != 0)
    {
        revValue = value & (1 << (numOfBits/2));
    }

    for(i = 0;i < numOfBits/2 ;i++ )
    {
        temp1 = value & (1 << i);
        temp2 = value & (1 << ((numOfBits - i)-1));
        y = temp1 << ((numOfBits - 2*i)-1);
        z = temp2 >> ((numOfBits - 2*i)-1);
        revValue |= (y | z);
    }

    return revValue;
}

/****************************************************************************
 *  Function Name  : fillPMIForNSubBands_RI_1
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode12
 *                   array                 
 *                   DLCQIInfo *dlCQIInfo
 *                   cellIndex
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the PMI value for the required 
 *                   sub bands for RI 1
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillPMIForNSubBands_RI_1(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,
        DLCQIInfo *dlCQIInfo,
        UInt8 cellIndex)
{
    UInt8 N = dlCQIInfo->N;
    UInt8* pmi_RI_1 = &(dlCQIInfo->aperiodicCQIMode12_p[count].pmi_RI_1[0]);
 /*  Aperiodic CQI Changes End*/

    switch(N)
    {
        case 2:
            {

                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
            }
            break;
        case 3:
            {

                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[2]));
            }
            break;
        case 4:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[0])) << 4);
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         (FOUR_BIT_ROTATION(pmi_RI_1[1]));
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[2])) << 4 );
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         (FOUR_BIT_ROTATION(pmi_RI_1[3]));

                 }
                 else
                 {

                     cqiReport_p[cqi_count] |= 
                        ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                     cqiReport_p[cqi_count] |=
                        ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                     cqi_count++;
                     cqiReport_p[cqi_count] = 
                        (TWO_BIT_ROTATION(pmi_RI_1[2]));
                     cqiReport_p[cqi_count] |= 
                       ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                 }
            }
            break;
        case 5:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
            }
            break;
        case 6:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[5])) << 6);
            }
            break;
        case 7:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[0])) << 4);
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         (FOUR_BIT_ROTATION(pmi_RI_1[1]));
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[2])) << 4 );
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         (FOUR_BIT_ROTATION(pmi_RI_1[3]));
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[4])) << 4);
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         ((FOUR_BIT_ROTATION(pmi_RI_1[5])));
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[6])) << 4);

                 }
                 else
                 {
                     cqiReport_p[cqi_count] |= 
                          ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                     cqiReport_p[cqi_count] |=
                          ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                     cqi_count++;
                     cqiReport_p[cqi_count] = 
                          (TWO_BIT_ROTATION(pmi_RI_1[2]));
                     cqiReport_p[cqi_count] |= 
                          ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                     cqiReport_p[cqi_count] |= 
                          ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
                     cqiReport_p[cqi_count] |= 
                          ((TWO_BIT_ROTATION(pmi_RI_1[5])) << 6);
                     cqi_count++;
                     cqiReport_p[cqi_count] = 
                          (TWO_BIT_ROTATION(pmi_RI_1[6]));
                 }
            }
            break;
        case 8:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[7])) << 2);
            }
            break;
        case 9:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[0])) << 4);
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         (FOUR_BIT_ROTATION(pmi_RI_1[1]));
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[2])) << 4 );
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         (FOUR_BIT_ROTATION(pmi_RI_1[3]));
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[4])) << 4);
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         ((FOUR_BIT_ROTATION(pmi_RI_1[5])));
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[6])) << 4);
                     cqi_count++;
                     cqiReport_p[cqi_count] =
                         ((FOUR_BIT_ROTATION(pmi_RI_1[7])) );
                     cqiReport_p[cqi_count] |=
                         ((FOUR_BIT_ROTATION(pmi_RI_1[8])) << 4);

                 }
                 else
                 {

                    cqiReport_p[cqi_count] |= 
                       ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                    cqiReport_p[cqi_count] |=
                       ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = 
                       (TWO_BIT_ROTATION(pmi_RI_1[2]));
                    cqiReport_p[cqi_count] |= 
                       ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                    cqiReport_p[cqi_count] |= 
                       ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
                    cqiReport_p[cqi_count] |= 
                       ((TWO_BIT_ROTATION(pmi_RI_1[5])) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = 
                       (TWO_BIT_ROTATION(pmi_RI_1[6]));
                    cqiReport_p[cqi_count] |=
                       ((TWO_BIT_ROTATION(pmi_RI_1[7])) << 2);
                    cqiReport_p[cqi_count] |= 
                       ((TWO_BIT_ROTATION(pmi_RI_1[8])) << 4);
                 }
              }
            break;
        case 10:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                cqiReport_p[cqi_count] |= 
                    ((FOUR_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                          (FOUR_BIT_ROTATION(pmi_RI_1[1]));
                cqiReport_p[cqi_count] |= 
                    ((FOUR_BIT_ROTATION(pmi_RI_1[2])) << 4 );
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (FOUR_BIT_ROTATION(pmi_RI_1[3]));
                cqiReport_p[cqi_count] |= 
                    ((FOUR_BIT_ROTATION(pmi_RI_1[4])) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    ((FOUR_BIT_ROTATION(pmi_RI_1[5])));
                cqiReport_p[cqi_count] |= 
                    ((FOUR_BIT_ROTATION(pmi_RI_1[6])) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    ((FOUR_BIT_ROTATION(pmi_RI_1[7])) );
                cqiReport_p[cqi_count] |= 
                    ((FOUR_BIT_ROTATION(pmi_RI_1[8])) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    ((TWO_BIT_ROTATION(pmi_RI_1[9])) );
                    
                }
                else
                {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[9])) << 6);
                }
            }
            break;
        case 11:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[6]));
                cqiReport_p[cqi_count] =
                    ((TWO_BIT_ROTATION(pmi_RI_1[7])) << 2);
                cqiReport_p[cqi_count] = 
                    ((TWO_BIT_ROTATION(pmi_RI_1[8])) << 4);
                cqiReport_p[cqi_count] = 
                    ((TWO_BIT_ROTATION(pmi_RI_1[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[10]));
            }
            break;
        case 12:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[10]));
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(pmi_RI_1[11])) << 2);
            }
            break;
        case 13:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4) /* 4x2 MIMO changes */
                {
                    cqiReport_p[cqi_count] |=
                    ((FOUR_BIT_ROTATION(pmi_RI_1[0])) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                     (FOUR_BIT_ROTATION(pmi_RI_1[1]));
                 cqiReport_p[cqi_count] |=
                    ((FOUR_BIT_ROTATION(pmi_RI_1[2]))<<4 );
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_1[3])) ;
                cqiReport_p[cqi_count] |=
                    ((FOUR_BIT_ROTATION(pmi_RI_1[4])) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_1[5]));
                cqiReport_p[cqi_count] |=
                    ((FOUR_BIT_ROTATION(pmi_RI_1[6])) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_1[7]));
                cqiReport_p[cqi_count] |=
                    ((FOUR_BIT_ROTATION(pmi_RI_1[8])) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_1[9]));
                cqiReport_p[cqi_count] |=
                    ((FOUR_BIT_ROTATION(pmi_RI_1[10])) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_1[11]));
                cqiReport_p[cqi_count] |=
                    ((FOUR_BIT_ROTATION(pmi_RI_1[12])) << 4);
                }
                else
                {
                    cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(pmi_RI_1[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(pmi_RI_1[10]));
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(pmi_RI_1[11])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(pmi_RI_1[12])) << 4);
                }
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}

/****************************************************************************
 *  Function Name  : fillPMIForNSubBands_RI_2
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode12
 *                   array                 
 *                   cellIndex
 *                   DLCQIInfo *dlCQIInfo
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the PMI value for the required 
 *                   sub bands for RI 2
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillPMIForNSubBands_RI_2(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,
        DLCQIInfo *dlCQIInfo,
        UInt8 cellIndex)
{
    UInt8 N = dlCQIInfo->N;
    UInt8* pmi_RI_2 = &(dlCQIInfo->aperiodicCQIMode12_p[count].pmi_RI_2[0]);
 /*  Aperiodic CQI Changes End*/

    switch(N)
    {
        case 2:
            {

                cqiReport_p[cqi_count] = pmi_RI_2[0];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
            }
            break;
        case 3:
            {
                cqiReport_p[cqi_count] = pmi_RI_2[0];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
            }
            break;
        case 4:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                 {
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[0]));
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[1])<<4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[2]));
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[3])<<4) ;
                 }
                 else
                 {

                    cqiReport_p[cqi_count] = pmi_RI_2[0];
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                 }
            }
            break;
        case 5:
            {
                cqiReport_p[cqi_count] = pmi_RI_2[0];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
            }
            break;
        case 6:
            {
                cqiReport_p[cqi_count] = pmi_RI_2[0];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[5]) << 5);
            }
            break;
        case 7:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                 {
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[0]));
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[1])<<4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[2]));
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[3])<<4) ;
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[4])) ;
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[5])<< 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[6])) ;
                 }
                 else
                 {
                    cqiReport_p[cqi_count] = pmi_RI_2[0];
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[5]) << 5);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[6]) << 6);
                 }
            }
            break;
        case 8:
            {
                cqiReport_p[cqi_count] = pmi_RI_2[0];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[5]) << 5);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[6]) << 6);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[7]) << 7);
            }
            break;
        case 9:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                 {
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[0]));
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[1])<<4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[2]));
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[3])<<4) ;
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[4])) ;
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[5])<< 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[6])) ;
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[7])<<4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[8])) ;
                 }
                 else
                 {

                    cqiReport_p[cqi_count] = pmi_RI_2[0];
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[5]) << 5);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[6]) << 6);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[7]) << 7);
                    cqi_count++;
                    cqiReport_p[cqi_count] = pmi_RI_2[8];
                 }
            }
            break;
        case 10:
            {
                 if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                 {
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[0]));
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[1])<<4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[2]));
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[3])<<4) ;
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[4])) ;
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[5])<< 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[6])) ;
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[7])<<4);
                    cqi_count++;
                    cqiReport_p[cqi_count] =
                        (FOUR_BIT_ROTATION(pmi_RI_2[8])) ;
                    cqiReport_p[cqi_count] |=
                        (FOUR_BIT_ROTATION(pmi_RI_2[9])<< 4);
                 }
                 else
                 {
                    cqiReport_p[cqi_count] = pmi_RI_2[0];
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[5]) << 5);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[6]) << 6);
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[7]) << 7);
                    cqi_count++;
                    cqiReport_p[cqi_count] = pmi_RI_2[8];
                    cqiReport_p[cqi_count] |= ((pmi_RI_2[9]) << 1);
                  }
            }
            break;
        case 11:
            {
                cqiReport_p[cqi_count] = pmi_RI_2[0];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[5]) << 5);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[6]) << 6);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[7]) << 7);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2[8];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[9]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[10]) << 2);
            }
            break;
        case 12:
            {
                cqiReport_p[cqi_count] = pmi_RI_2[0];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[5]) << 5);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[6]) << 6);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[7]) << 7);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2[8];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[9]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[10]) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[11]) << 3);
            }
            break;
        case 13:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   fprintf(stderr,"PMI value is filling\n");
                    cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_2[0]));
                cqiReport_p[cqi_count] |=
                    (FOUR_BIT_ROTATION(pmi_RI_2[1])<<4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_2[2]));
                cqiReport_p[cqi_count] |=
                    (FOUR_BIT_ROTATION(pmi_RI_2[3])<<4) ;
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_2[4])) ;
                cqiReport_p[cqi_count] |=
                    (FOUR_BIT_ROTATION(pmi_RI_2[5])<< 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_2[6])) ;
                cqiReport_p[cqi_count] |=
                    (FOUR_BIT_ROTATION(pmi_RI_2[7])<<4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_2[8])) ;
                cqiReport_p[cqi_count] |=
                    (FOUR_BIT_ROTATION(pmi_RI_2[9])<< 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (FOUR_BIT_ROTATION(pmi_RI_2[10])) ;
                cqiReport_p[cqi_count] |=
                    (FOUR_BIT_ROTATION(pmi_RI_2[11]) << 4);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    ((FOUR_BIT_ROTATION(pmi_RI_2[12])));
                }
                else
                {
                cqiReport_p[cqi_count] = pmi_RI_2[0];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[1]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[2]) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[3]) << 3);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[4]) << 4);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[5]) << 5);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[6]) << 6);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[7]) << 7);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2[8];
                cqiReport_p[cqi_count] |= ((pmi_RI_2[9]) << 1);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[10]) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[11]) << 3);
                cqiReport_p[cqi_count] |= ((pmi_RI_2[12]) << 4);
                }
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}

/****************************************************************************
 *  Function Name  : fillPosOfMSelSubband
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode20
 *                   array                 
 *                   DLCQIInfo *dlCQIInfo
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the position of M Selected
 *                   sub bands 
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillPosOfMSelSubband(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo)
{
    UInt32 posOfMSelSBAperiodic = dlCQIInfo->posOfMSelSBAperiodic;
    UInt32 value = 
        getReverseValue(posOfMSelSBAperiodic,dlCQIInfo->aperiodicCQIMode20_p[count].posOfMSelSubband);
 /*  Aperiodic CQI Changes End*/

    switch(posOfMSelSBAperiodic)
    {
        case 2:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);  
            }
            break;
        case 3:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = (value &  0x00000004);
            }
            break;
        case 4:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x0000000C) >> 2);
            }
            break;
        case 5:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x0000001C) >> 2);
            }
            break;
        case 6:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x0000003C) >> 2);
            }
            break;
        case 7:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x0000007C) >> 2);
            }
            break;
        case 8:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000000FC) >> 2);
            }
            break;
        case 9:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000001FC) >> 2);
            }
            break;
        case 10:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
            }
            break;
        case 11:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x00000400) >> 10);
            }
            break;
        case 12:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x00000C00) >> 10);
            }
            break;
        case 13:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x00001C00) >> 10);
            }
            break;
        case 14:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x00003C00) >> 10);
            }
            break;
        case 15:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x00007C00) >> 10);
            }
            break;
        case 16:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x0000FC00) >> 10);
            }
            break;
        case 17:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x0001FC00) >> 10);
            }
            break;
        case 18:
            {
                cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                cqi_count++;
                cqiReport_p[cqi_count] = ((value &  0x0003FC00) >> 10);
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}

/****************************************************************************
 *  Function Name  : fillPosOfMSelSubbandAndPMI_RI_1
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode22
 *                   array                 
 *                   DLCQIInfo *dlCQIInfo
 *                   cellIndex
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the position of M Selected
 *                   sub bands and PMI for RI 1
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillPosOfMSelSubbandAndPMI_RI_1(UInt8 *cqiReport_p,UInt8 cqi_count,
		UInt8 count,DLCQIInfo *dlCQIInfo, UInt8 cellIndex)
{
    UInt32 posOfMSelSBAperiodic = dlCQIInfo->posOfMSelSBAperiodic;
    UInt32 value = 
        getReverseValue(posOfMSelSBAperiodic,
                dlCQIInfo->aperiodicCQIMode22_p[count].posOfMSelSubband_RI_1);
    UInt8 pmiValue = 0;
    if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
    {
        UInt8 tmpPmiValue = dlCQIInfo->aperiodicCQIMode22_p[count].pmi_RI_2;
        pmiValue = (FOUR_BIT_ROTATION(tmpPmiValue & 0x0F));
        pmiValue |= ((FOUR_BIT_ROTATION((tmpPmiValue & 0xF0)>>4))<<4);
    }   
    else
    pmiValue = (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].pmi_RI_1));
 /*  Aperiodic CQI Changes End*/

    switch(posOfMSelSBAperiodic)
    {

        case 2:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = (pmiValue & 0xFF);
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);  
                    cqi_count++;
                    cqiReport_p[cqi_count] = (pmiValue & 0x0F);
                }
            }
            break;
        case 3:
            {
                 if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                 {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = (value &  0x00000004);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x7F) << 1);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x80)>>7);


                 }
                 else
                 {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = (value &  0x00000004);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 1);
                 }
            }
            break;
        case 4:
            {
                 if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                 {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000000C) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 2);

                 }
                 else
                 {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000000C) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x3F) << 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xC0)>>6);

                 }
            }
            break;
        case 5:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x0000001C) >> 2);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x1F) << 3);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0xE0)>>5);

                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x0000001C) >> 2);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 3);
                }
            }
            break;
        case 6:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000003C) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xF0)>>4);


                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000003C) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 4);
                }
            }
            break;
        case 7:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000007C) >> 2); 
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x07)<<5);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xF8)>>5);
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000007C) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x07) << 5);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x08) >> 3);
                }
            }
            break;
        case 8:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000000FC) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x00000003)<<6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xFC)>>6);
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000000FC) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x0C) >> 2);
                }
            }
            break;
        case 9:
            { 
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value & 0x000001FC) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x00000001)<<7);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xFE)>>7);
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000001FC) >> 2);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x01) << 7);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x0E) >> 1);
                }
            }
            break;
        case 10:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = (pmiValue & 0xFF);
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = (pmiValue & 0x0F);
                }
            }
            break;
        case 11:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000400) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0xFE) << 1);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x80) >> 7);

                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000400) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 1);
                }
            }
            break;
        case 12:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000C00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x3F) << 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xC0) >> 6);

                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000C00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 2);
                }
            }
            break;
        case 13:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00001C00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x1F) << 3);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xE0) >> 5);

                }
                else
                { 
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00001C00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 3);
                }
            }
            break;
        case 14:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00003C00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xF0) >> 4);

                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00003C00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 4);
                }
             }
            break;
        case 15:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00007C00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x07) << 5);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xF8) >> 3);
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00007C00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x07) << 5);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x08) >> 3);
                }
            }
            break;
        case 16:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000FC00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x0C) >> 2);
                 }
                 else
                 {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000FC00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xFC) >> 2);
                 }
            }
            break;
        case 17:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x0001FC00) >> 10);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x01) << 7);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0xFE) >> 1);

                }
                else
                {  
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0001FC00) >> 10);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x01) << 7);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x0E) >> 1);
                }
            }
            break;
        case 18:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0003FC00) >> 10);
                    cqi_count++;
                    cqiReport_p[cqi_count] = (pmiValue & 0xFF);
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x00000003) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000003FC) >> 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0003FC00) >> 10);
                    cqi_count++;
                    cqiReport_p[cqi_count] = (pmiValue & 0x0F);
                }
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}

/****************************************************************************
 *  Function Name  : fillPosOfMSelSubbandAndPMI_RI_2
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode22
 *                   array                 
 *                   DLCQIInfo *dlCQIInfo
 *                   cellIndex
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the position of M Selected
 *                   sub bands and PMI for RI 2
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillPosOfMSelSubbandAndPMI_RI_2(UInt8 *cqiReport_p,UInt8 cqi_count,
		UInt8 count,DLCQIInfo *dlCQIInfo, UInt8 cellIndex)
{
    UInt32 posOfMSelSBAperiodic = dlCQIInfo->posOfMSelSBAperiodic;
    UInt32 value = 
        getReverseValue(posOfMSelSBAperiodic,
                dlCQIInfo->aperiodicCQIMode22_p[count].posOfMSelSubband_RI_2);
    UInt8 pmiValue = 0;
    if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
    {
        UInt8 tmpPmiValue = dlCQIInfo->aperiodicCQIMode22_p[count].pmi_RI_2;
        pmiValue = (FOUR_BIT_ROTATION(tmpPmiValue & 0x0F));
        pmiValue |= ((FOUR_BIT_ROTATION((tmpPmiValue & 0xF0)>>4))<<4);
    }   
    else
        pmiValue = (TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode22_p[count].pmi_RI_2));
 /*  Aperiodic CQI Changes End*/

    switch(posOfMSelSBAperiodic)
    {
        case 2:
            {
               if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
               {
                  cqiReport_p[cqi_count] |= ((value & 0x00000003) << 4);  
                  cqiReport_p[cqi_count] |= ( (pmiValue & 0x03) << 6);
                  cqi_count++;
                  cqiReport_p[cqi_count] = ((pmiValue & 0xFC) >> 2);
               }
               else
               {
                  cqiReport_p[cqi_count] |= ((value & 0x00000003) << 4);
                  cqiReport_p[cqi_count] |= ( (pmiValue & 0x03) << 6);
               }
            }
            break;
        case 3:
            {
               if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
               {
                  cqiReport_p[cqi_count] |= ((value & 0x00000007) << 4);
                  cqiReport_p[cqi_count] |= ((pmiValue & 0x01) << 7);
                  cqi_count++;
                  cqiReport_p[cqi_count] = ((pmiValue & 0xFE) >> 1);
               }
               else
               {
                  cqiReport_p[cqi_count] |= ((value & 0x00000007) << 4);
                  cqiReport_p[cqi_count] |= ((pmiValue & 0x01) << 7);
                  cqi_count++;
                  cqiReport_p[cqi_count] = ((pmiValue & 0x02) >> 1);
               }
            }
            break;
        case 4:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = (pmiValue & 0xFF);
                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = (pmiValue & 0x03);
                }
             }
            break;
        case 5:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x00000010) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x7F) << 1);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0x80) >> 7);
                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x00000010) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 1);
                }
            }
            break;
        case 6:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x00000030) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0xFC) << 2);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0xC0) >> 6);
                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x00000030) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 2);
                }
            }
            break;
        case 7:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x00000070) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x1F) << 3);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0xE0) >> 5);
                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x00000070) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 3);
                }
            }
            break;
        case 8:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x000000F0) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0xF0) >> 4);
                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x000000F0) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 4);
                }
            }
            break;
        case 9:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x000001F0) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x07) << 5);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0xF8) >> 3);

                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x000001F0) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 5);
                }
            }
            break;
        case 10:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x000003F0) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0xFC) >> 2);
                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x000003F0) >> 4);
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                }
            }
            break;
        case 11:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000007F0) >> 4);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x01) << 7);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xFE) >> 1);
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x000007F0) >> 4);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x01) << 7);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x02) >> 1);
                }
            }
            break;
        case 12:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = (pmiValue & 0xFF);
                }
                else
                {
                   cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                   cqi_count++;
                   cqiReport_p[cqi_count] = (pmiValue & 0x03);
                }
            }
            break;
        case 13:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00001000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x7F) << 1);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x80) >>7) ;
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00001000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 1);
                 }
            }
            break;
        case 14:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00003000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x3F) << 2);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xC0) >>6) ;

                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00003000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 2);
                }
            }
            break;
        case 15:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00007000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x1F) << 3);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xE0) >>4) ;

                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00007000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 3);
                }
             }
            break;
        case 16:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000F000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xF0) >>4) ;
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0000F000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 4);
                }
            }
            break;
        case 17:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0001F000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x07) << 5);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0xF8) >>3) ;

                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0001F000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 5);
                 }
            }
            break;
        case 18:
            {
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0003F000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                    cqi_count++;
                    cqiReport_p[cqi_count] = (pmiValue & 0xFC) >> 2;
                }
                else
                {
                    cqiReport_p[cqi_count] |= ((value & 0x0000000F) << 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x00000FF0) >> 4);
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((value &  0x0003F000) >> 12);
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                }
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}

/****************************************************************************
 *  Function Name  : fillSubBandDiffCQIForNSubBands
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode30
 *                   array                 
 *                   DLCQIInfo *dlCQIInfo
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the sub band differential CQI 
 *                   for the required sub bands
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillSubBandDiffCQIForNSubBands(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo)
{
    UInt8 N = dlCQIInfo->N;
    UInt8* subBandDiffCQI = 
        &(dlCQIInfo->aperiodicCQIMode30_p[count].subBandDiffCQI[0]);
 /*  Aperiodic CQI Changes End*/

    switch(N)
    {
        case 2:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
            }
            break;
        case 3:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
            }
            break;
        case 4:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
            }
            break;
        case 5:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
            }
            break;
        case 6:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[5])) << 6);
            }
            break;
        case 7:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[6]));
            }
            break;
        case 8:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[7])) << 2);
            }
            break;
        case 9:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[8])) << 4);
            }
            break;
        case 10:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[9])) << 6);
            }
            break;
        case 11:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[6]));
                cqiReport_p[cqi_count] =
                    ((TWO_BIT_ROTATION(subBandDiffCQI[7])) << 2);
                cqiReport_p[cqi_count] = 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[8])) << 4);
                cqiReport_p[cqi_count] = 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[10]));
            }
            break;
        case 12:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[10]));
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(subBandDiffCQI[11])) << 2);
            }
            break;
        case 13:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQI[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQI[10]));
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(subBandDiffCQI[11])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQI[12])) << 4);
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}    

/****************************************************************************
 *  Function Name  : fillSubBandDiffCQIForNSubBandsAndPMI_RI_1
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode30
 *                   array                 
 *                   DLCQIInfo *dlCQIInfo
 *                   cellIndex
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the sub band differential CQI 
 *                   for the required sub bands and PMI for RI 1
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillSubBandDiffCQIForNSubBandsAndPMI_RI_1(UInt8 *cqiReport_p,
		UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo,
		UInt8 cellIndex)
{
    UInt8 N = dlCQIInfo->N;
    UInt8* subBandDiffCQICW0_RI_1 = 
        &(dlCQIInfo->aperiodicCQIMode31_p[count].subBandDiffCQICW0_RI_1[0]);
    UInt8 pmiValue = 0;

    if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
        pmiValue = (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode31_p[count].pmi_RI_1)); 
    else
        pmiValue = (TWO_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode31_p[count].pmi_RI_1));
 /*  Aperiodic CQI Changes End*/

    switch(N)
    {
        case 2:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = (pmiValue & 0x03);
            }
            break;
        case 3:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |=  ((pmiValue & 0x03) << 2);
            }
            break;
        case 4:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 4);
                else
                    cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 4);
            }
            break;
        case 5:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
            }
            break;
        case 6:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = (pmiValue & 0x03);
            }
            break;
        case 7:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[6]));
                /* + SPR_4557 */
                // cqi_count++;
                /* - SPR_4557 */
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x0F) << 4);
                else
                   cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 2);
            }
            break;
        case 8:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[7])) << 2);
                cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 4);
            }
            break;
        case 9:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[8])) << 4);
                cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                   cqi_count++;
                   cqiReport_p[cqi_count] = ((pmiValue & 0x0C) >> 2);
                }
            }
            break;
        case 10:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[9])) << 6);
                cqi_count++;
                if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                   cqiReport_p[cqi_count] = (pmiValue & 0x0F);
                else
                   cqiReport_p[cqi_count] = (pmiValue & 0x03);
            }
            break;
        case 11:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[6]));
                cqiReport_p[cqi_count] =
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[7])) << 2);
                cqiReport_p[cqi_count] = 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[8])) << 4);
                cqiReport_p[cqi_count] = 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[10]));
                cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 2);
            }
            break;
        case 12:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[10]));
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 2);
                cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 4);
            }
            break;
        case 13:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[10]));
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[11])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_1[12])) << 4);
                cqiReport_p[cqi_count] |= ((pmiValue & 0x03) << 6);
                if(cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                {
                    cqi_count++;
                    cqiReport_p[cqi_count] = ((pmiValue & 0x0C)>>2); 
                }
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}    

/****************************************************************************
 *  Function Name  : fillSubBandDiffCQIForNSubBandsAndWB_RI_2
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode30
 *                   array                 
 *                   DLCQIInfo *dlCQIInfo
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the sub band differential CQI 
 *                   for the required sub bands and WB CQI for RI 2
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillSubBandDiffCQIForNSubBandsAndWB_RI_2(UInt8 *cqiReport_p,UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo)
{
    UInt8 N = dlCQIInfo->N;
    UInt8* subBandDiffCQICW0_RI_2 = 
        &(dlCQIInfo->aperiodicCQIMode31_p[count].subBandDiffCQICW0_RI_2[0]);
    UInt8 wideBandCQICW1 = 
        (FOUR_BIT_ROTATION(dlCQIInfo->aperiodicCQIMode31_p[count].wideBandCQICW1_RI_2));
 /*  Aperiodic CQI Changes End*/

    switch(N)
    {
        case 2:
            {

                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = (wideBandCQICW1 & 0x0F);
            }
            break;
        case 3:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x0F) << 2);
            }
            break;
        case 4:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x0F) << 4);
            }
            break;
        case 5:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x03) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((wideBandCQICW1 & 0x0C) >> 2);
            }
            break;
        case 6:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((wideBandCQICW1 & 0x0F));
            }
            break;
        case 7:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[6]));
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x0F) << 2);
            }
            break;
        case 8:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[7])) << 2);
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x0F) << 4);
            }
            break;
        case 9:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[8])) << 4);
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x03) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((wideBandCQICW1 & 0x0C) >> 2);
            }
            break;
        case 10:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = (wideBandCQICW1 & 0x0F);
            }
            break;
        case 11:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[10]));
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x0F) << 2);
            }
            break;
        case 12:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[10]));
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 2);
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x0F) << 4);
            }
            break;
        case 13:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[10]));
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[11])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW0_RI_2[12])) << 4);
                cqiReport_p[cqi_count] |= ((wideBandCQICW1 & 0x03) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = ((wideBandCQICW1 & 0x0C) >> 2);
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}    

/****************************************************************************
 *  Function Name  : fillSubBandDiffCQIForNSubBandsAndPMI_RI_2
 *  Inputs         : cqiReport_p - cqi Report pointer 
 *                   cqi_count - containing the index from where the value 
 *                   needs to be filled
 *                   count - Index value of the cqiAperiodicReportMode30
 *                   array                
 *                   DLCQIInfo *dlCQIInfo
 *                   cellIndex
 *  Outputs        : 
 *  Returns        : cqi_count
 *  Description    : This function fills the sub band differential CQI 
 *                   for the required sub bands and PMI for RI 2
 ****************************************************************************/
 /*  Aperiodic CQI Changes start*/
UInt8 fillSubBandDiffCQIForNSubBandsAndPMI_RI_2(UInt8 *cqiReport_p,
		UInt8 cqi_count,UInt8 count,DLCQIInfo *dlCQIInfo,
		UInt8 cellIndex)
{
    UInt8 N = dlCQIInfo->N;
    UInt8* subBandDiffCQICW1_RI_2 = 
        &(dlCQIInfo->aperiodicCQIMode31_p[count].subBandDiffCQICW1_RI_2[0]);
    UInt8 pmi_RI_2 = dlCQIInfo->aperiodicCQIMode31_p[count].pmi_RI_2;
 /*  Aperiodic CQI Changes End*/
    if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
        pmi_RI_2 = FOUR_BIT_ROTATION(pmi_RI_2);

    switch(N)
    {
        case 2:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2;
            }
            break;
        case 3:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2) << 4);
            }
            break;
        case 4:
            {
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2;
            }
            break;
        case 5:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 2);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4])) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2) << 4);
            }
            break;
        case 6:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2;
            }
            break;
        case 7:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[5]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[6])) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2) << 4);
            }
            break;
        case 8:
            {
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[5])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[6])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[7])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2;
            }
            break;
        case 9:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 2);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[5])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[6])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[7]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[8])) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2) << 4);
            }
            break;
        case 10:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[5])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[6]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[7])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[8])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[9])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2;
            }
            break;
        case 11:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[5]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[6])) << 2);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[7])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[8])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[9]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[10])) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2) << 4);
            }
            break;
        case 12:
            {
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0]));
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[5])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[6])) << 4);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[7])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[8]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[9])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[10])) << 4);
                cqiReport_p[cqi_count] |=  
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = pmi_RI_2;
            }
            break;
        case 13:
            {
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[0])) << 2);
                cqiReport_p[cqi_count] |=
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[1])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[2])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] = 
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[3]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[4])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[5])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[6])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] =
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[7]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[8])) << 2);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[9])) << 4);
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[10])) << 6);
                cqi_count++;
                cqiReport_p[cqi_count] =  
                    (TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[11]));
                cqiReport_p[cqi_count] |= 
                    ((TWO_BIT_ROTATION(subBandDiffCQICW1_RI_2[12])) << 2);
                cqiReport_p[cqi_count] |= ((pmi_RI_2) << 4);
            }
            break;
        default:
            {
                fprintf(stderr,"INVALID VALUE RECEIVED\n");
            }
            break;
    }
    return cqi_count;
}

/****************************************************************************
 * Function Name  :  initBandwidthPart
 * Inputs         :  newUEContext_p - Pointer to UL context
 *
 * Output         :  Bandwidthpart
 * Returns        :  None
 * Description    :  This function determine the bandwidthpart of the first
 *                   periodic CQI report after create/reconfig.
 ******************************************************************************/
static void initBandwidthPart(DLUEContext *newUEContext_p,UInt32 SFN, UInt8 SF)
{
    UInt32 nextCQISFN = SFN;
    UInt8 nextCQISF = SF;
    /*SPR 15909 fix start*/
    tickType_t nextWidebandTTI = 0;
    tickType_t lastWidebandTTI = 0;
    /*SPR 15909 fix end*/
    newUEContext_p->dlCQIInfo.calculateBandwidthPartFlag = FALSE;
    while ( 0 != (((10*nextCQISFN) + nextCQISF - newUEContext_p->dlCQIInfo.cqiOffset) % newUEContext_p->dlCQIInfo.widebandPeriodicity) )
    {  
        GET_REQUIRED_TICK(nextCQISFN,nextCQISF,1);
    }

    nextWidebandTTI = (( nextCQISFN * MAX_SF_VALUE) + nextCQISF);
    newUEContext_p->dlCQIInfo.nextWidebandOccurrence = nextWidebandTTI;

    /*  Calculating next occurance of subband CQI.
     *  Ref. spec 36.213 sec 7.2.2.
     */
    nextCQISFN = SFN;
    nextCQISF = SF;
    while (0  != ((MAX_SF_VALUE * nextCQISFN + nextCQISF -
                    newUEContext_p->dlCQIInfo.cqiOffset) % newUEContext_p->dlCQIInfo.cqiPeriodicity ))
    {
        GET_REQUIRED_TICK( nextCQISFN,nextCQISF,1);
    }

    newUEContext_p->dlCQIInfo.nextSubbandOccurrence = ((nextCQISFN * MAX_SF_VALUE) + nextCQISF);

    /*  Calculating last occurance of wideband CQI */
    if ( nextWidebandTTI >= newUEContext_p->dlCQIInfo.widebandPeriodicity )
    {
        lastWidebandTTI = nextWidebandTTI - newUEContext_p->dlCQIInfo.widebandPeriodicity;
    }
    else
    {
        if(newUEContext_p->dlCQIInfo.nextSubbandOccurrence  >= newUEContext_p->dlCQIInfo.widebandPeriodicity)
        {
            lastWidebandTTI =   newUEContext_p->dlCQIInfo.nextSubbandOccurrence - newUEContext_p->dlCQIInfo.widebandPeriodicity;
        }
        else
        {
            lastWidebandTTI  = (MAX_SFN * MAX_SF_VALUE) - (newUEContext_p->dlCQIInfo.widebandPeriodicity - 
                    newUEContext_p->dlCQIInfo.nextSubbandOccurrence );
        }
        nextCQISFN = lastWidebandTTI / MAX_SF_VALUE;
        nextCQISF = lastWidebandTTI % MAX_SF_VALUE; 

        while (0  != ((MAX_SF_VALUE * nextCQISFN + nextCQISF -
                        newUEContext_p->dlCQIInfo.cqiOffset) % newUEContext_p->dlCQIInfo.widebandPeriodicity))
        {
            GET_REQUIRED_TICK( nextCQISFN,nextCQISF,1);
        }
        lastWidebandTTI = (MAX_SF_VALUE * nextCQISFN + nextCQISF);
    }

    /* Calculating Bandwidthpart */
    if ( newUEContext_p->dlCQIInfo.nextSubbandOccurrence > lastWidebandTTI )
    {
        newUEContext_p->dlCQIInfo.bandwidthPartCount =
            ((newUEContext_p->dlCQIInfo.nextSubbandOccurrence - lastWidebandTTI ) / newUEContext_p->dlCQIInfo.cqiPeriodicity);
        newUEContext_p->dlCQIInfo.bandwidthPartCount =
            ((newUEContext_p->dlCQIInfo.bandwidthPartCount - 1) % newUEContext_p->dlCQIInfo.bandwidthParts);
    }
    else
    {
        newUEContext_p->dlCQIInfo.bandwidthPartCount = 0;
    }

    /***********************************************/
    /* EICIC +*/
    if ((0!= newUEContext_p->dlCQIInfo.widebandPeriodicity_2) && (0 != newUEContext_p->dlCQIInfo.cqiPeriodicity_2))
   {
    while ( 0 != (((10*nextCQISFN) + nextCQISF - newUEContext_p->dlCQIInfo.cqiOffset_2) % newUEContext_p->dlCQIInfo.widebandPeriodicity_2))
    {  
        GET_REQUIRED_TICK(nextCQISFN,nextCQISF,1);
    }

    nextWidebandTTI = (( nextCQISFN * MAX_SF_VALUE) + nextCQISF);
    newUEContext_p->dlCQIInfo.nextWidebandOccurrence_2 = nextWidebandTTI;

    /*  Calculating next occurance of subband CQI.
     *  Ref. spec 36.213 sec 7.2.2.
     */
    nextCQISFN = SFN;
    nextCQISF = SF;
    while (0  != ((MAX_SF_VALUE * nextCQISFN + nextCQISF -
                    newUEContext_p->dlCQIInfo.cqiOffset_2) % newUEContext_p->dlCQIInfo.cqiPeriodicity_2))
    {
        GET_REQUIRED_TICK( nextCQISFN,nextCQISF,1);
    }

    newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 = ((nextCQISFN * MAX_SF_VALUE) + nextCQISF);

    /*  Calculating last occurance of wideband CQI */
    if ( nextWidebandTTI >= newUEContext_p->dlCQIInfo.widebandPeriodicity_2)
    {
        lastWidebandTTI = nextWidebandTTI - newUEContext_p->dlCQIInfo.widebandPeriodicity_2;
    }
    else
    {
        if(newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2  >= newUEContext_p->dlCQIInfo.widebandPeriodicity_2)
        {
            lastWidebandTTI =   newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 - newUEContext_p->dlCQIInfo.widebandPeriodicity_2;
        }
        else
        {
            lastWidebandTTI  = (MAX_SFN * MAX_SF_VALUE) - (newUEContext_p->dlCQIInfo.widebandPeriodicity_2 - 
                    newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 );
        }
        nextCQISFN = lastWidebandTTI / MAX_SF_VALUE;
        nextCQISF = lastWidebandTTI % MAX_SF_VALUE; 

        while (0  != ((MAX_SF_VALUE * nextCQISFN + nextCQISF -
                        newUEContext_p->dlCQIInfo.cqiOffset_2) % newUEContext_p->dlCQIInfo.widebandPeriodicity_2))
        {
            GET_REQUIRED_TICK( nextCQISFN,nextCQISF,1);
        }
        lastWidebandTTI = (MAX_SF_VALUE * nextCQISFN + nextCQISF);
    }

    /* Calculating Bandwidthpart */
    if ( newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 > lastWidebandTTI )
    {
        newUEContext_p->dlCQIInfo.bandwidthPartCount_2 =
            ((newUEContext_p->dlCQIInfo.nextSubbandOccurrence_2 - lastWidebandTTI ) / newUEContext_p->dlCQIInfo.cqiPeriodicity_2);
        newUEContext_p->dlCQIInfo.bandwidthPartCount_2 =
            ((newUEContext_p->dlCQIInfo.bandwidthPartCount_2 - 1) % newUEContext_p->dlCQIInfo.bandwidthParts);
    }
    else
    {
        newUEContext_p->dlCQIInfo.bandwidthPartCount_2 = 0;
    }
    }
    /* EICIC -*/


    return;
}
/** SPR 12586 Fix : Start **/ 
/****************************************************************************
 * Function Name  :  initScellBandwidthPart
 * Inputs         :  scellInfo_p - Pointer to ScellInfo
 *
 * Output         :  Bandwidthpart
 * Returns        :  None
 * Description    :  This function determine the bandwidthpart of the first
 *                   periodic CQI report after create/reconfig.
 ******************************************************************************/
static void initSCellBandwidthPart(ScellInfo *scellInfo_p,UInt32 SFN, UInt8 SF)
{
    UInt32 nextCQISFN = SFN;
    UInt8 nextCQISF = SF;
    /*SPR 15909 fix start*/
    tickType_t nextWidebandTTI = 0;
    tickType_t lastWidebandTTI = 0;
    /*SPR 15909 fix end*/
    scellInfo_p->dlCQIInfo.calculateBandwidthPartFlag = FALSE;
    while ( 0 != (((10*nextCQISFN) + nextCQISF - scellInfo_p->dlCQIInfo.cqiOffset) % scellInfo_p->dlCQIInfo.widebandPeriodicity) )
    {  
        GET_REQUIRED_TICK(nextCQISFN,nextCQISF,1);
    }

    nextWidebandTTI = (( nextCQISFN * MAX_SF_VALUE) + nextCQISF);
    scellInfo_p->dlCQIInfo.nextWidebandOccurrence = nextWidebandTTI;

    /*  Calculating next occurance of subband CQI.
     *  Ref. spec 36.213 sec 7.2.2.
     */
    nextCQISFN = SFN;
    nextCQISF = SF;
    while (0  != ((MAX_SF_VALUE * nextCQISFN + nextCQISF -
                    scellInfo_p->dlCQIInfo.cqiOffset) % scellInfo_p->dlCQIInfo.cqiPeriodicity ))
    {
        GET_REQUIRED_TICK( nextCQISFN,nextCQISF,1);
    }

    scellInfo_p->dlCQIInfo.nextSubbandOccurrence = ((nextCQISFN * MAX_SF_VALUE) + nextCQISF);

    /*  Calculating last occurance of wideband CQI */
    if ( nextWidebandTTI >= scellInfo_p->dlCQIInfo.widebandPeriodicity )
    {
        lastWidebandTTI = nextWidebandTTI - scellInfo_p->dlCQIInfo.widebandPeriodicity;
    }
    else
    {
        if(scellInfo_p->dlCQIInfo.nextSubbandOccurrence  >= scellInfo_p->dlCQIInfo.widebandPeriodicity)
        {
            lastWidebandTTI =   scellInfo_p->dlCQIInfo.nextSubbandOccurrence - scellInfo_p->dlCQIInfo.widebandPeriodicity;
        }
        else
        {
            lastWidebandTTI  = (MAX_SFN * MAX_SF_VALUE) - (scellInfo_p->dlCQIInfo.widebandPeriodicity - 
                    scellInfo_p->dlCQIInfo.nextSubbandOccurrence );
        }
        nextCQISFN = lastWidebandTTI / MAX_SF_VALUE;
        nextCQISF = lastWidebandTTI % MAX_SF_VALUE; 

        while (0  != ((MAX_SF_VALUE * nextCQISFN + nextCQISF -
                        scellInfo_p->dlCQIInfo.cqiOffset) % scellInfo_p->dlCQIInfo.widebandPeriodicity))
        {
            GET_REQUIRED_TICK( nextCQISFN,nextCQISF,1);
        }
        lastWidebandTTI = (MAX_SF_VALUE * nextCQISFN + nextCQISF);
    }

    /* Calculating Bandwidthpart */
    if ( scellInfo_p->dlCQIInfo.nextSubbandOccurrence > lastWidebandTTI )
    {
        scellInfo_p->dlCQIInfo.bandwidthPartCount =
            ((scellInfo_p->dlCQIInfo.nextSubbandOccurrence - lastWidebandTTI ) / scellInfo_p->dlCQIInfo.cqiPeriodicity);
        scellInfo_p->dlCQIInfo.bandwidthPartCount =
            ((scellInfo_p->dlCQIInfo.bandwidthPartCount - 1) % scellInfo_p->dlCQIInfo.bandwidthParts);
    }
    else
    {
        scellInfo_p->dlCQIInfo.bandwidthPartCount = 0;
    }

    /*********************/
    /* EICIC +*/
      while ( 0 != (((10*nextCQISFN) + nextCQISF - scellInfo_p->dlCQIInfo.cqiOffset_2) % scellInfo_p->dlCQIInfo.widebandPeriodicity_2) )
    {  
        GET_REQUIRED_TICK(nextCQISFN,nextCQISF,1);
    }

    nextWidebandTTI = (( nextCQISFN * MAX_SF_VALUE) + nextCQISF);
    scellInfo_p->dlCQIInfo.nextWidebandOccurrence_2 = nextWidebandTTI;

    /*  Calculating next occurance of subband CQI.
     *  Ref. spec 36.213 sec 7.2.2.
     */
    nextCQISFN = SFN;
    nextCQISF = SF;
    while (0  != ((MAX_SF_VALUE * nextCQISFN + nextCQISF -
                    scellInfo_p->dlCQIInfo.cqiOffset_2) % scellInfo_p->dlCQIInfo.cqiPeriodicity_2 ))
    {
        GET_REQUIRED_TICK( nextCQISFN,nextCQISF,1);
    }

    scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 = ((nextCQISFN * MAX_SF_VALUE) + nextCQISF);

    /*  Calculating last occurance of wideband CQI */
    if ( nextWidebandTTI >= scellInfo_p->dlCQIInfo.widebandPeriodicity_2 )
    {
        lastWidebandTTI = nextWidebandTTI - scellInfo_p->dlCQIInfo.widebandPeriodicity_2;
    }
    else
    {
        if(scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2  >= scellInfo_p->dlCQIInfo.widebandPeriodicity_2)
        {
            lastWidebandTTI =   scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 - scellInfo_p->dlCQIInfo.widebandPeriodicity_2;
        }
        else
        {
            lastWidebandTTI  = (MAX_SFN * MAX_SF_VALUE) - (scellInfo_p->dlCQIInfo.widebandPeriodicity_2 - 
                    scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 );
        }
        nextCQISFN = lastWidebandTTI / MAX_SF_VALUE;
        nextCQISF = lastWidebandTTI % MAX_SF_VALUE; 

        while (0  != ((MAX_SF_VALUE * nextCQISFN + nextCQISF -
                        scellInfo_p->dlCQIInfo.cqiOffset_2) % scellInfo_p->dlCQIInfo.widebandPeriodicity_2))
        {
            GET_REQUIRED_TICK( nextCQISFN,nextCQISF,1);
        }
        lastWidebandTTI = (MAX_SF_VALUE * nextCQISFN + nextCQISF);
    }

    /* Calculating Bandwidthpart */
    if ( scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 > lastWidebandTTI )
    {
        scellInfo_p->dlCQIInfo.bandwidthPartCount_2 =
            ((scellInfo_p->dlCQIInfo.nextSubbandOccurrence_2 - lastWidebandTTI ) / scellInfo_p->dlCQIInfo.cqiPeriodicity_2);
        scellInfo_p->dlCQIInfo.bandwidthPartCount_2 =
            ((scellInfo_p->dlCQIInfo.bandwidthPartCount_2 - 1) % scellInfo_p->dlCQIInfo.bandwidthParts);
    }
    else
    {
        scellInfo_p->dlCQIInfo.bandwidthPartCount_2 = 0;
    }
    /* EICIC -*/

    return;
}
/** SPR 12586 Fix : End **/
/* - CQI_4.1 */
/*SPS_CHG*/
void processSPSGrant(FAPI_dlDCIPduInfo_st *dciPdu_p, 
		UInt16  semiPersistentSchedIntervalUL, UInt8 recvSF, UInt16 recvSFN, 
		UInt8 cellIndex)
{
    LP_SpsOccUeContext   spsCtx_p = PNULL;
    RNTIInfo             *rntiInfo_p = PNULL;
    ueContextForUplink *ueContextInfo_p = PNULL;
    UInt16  ttiIndex               = 0;
    UInt16  ueIndex               = 0;
    UInt8 delay=0;
    UInt16 currentSFN = 0,  receivedSf = 0;
    UInt16 currentSfnSf = 0, recvSfnSf = 0;
    UInt8  currentSF = 0;
    /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
    UInt8  subFrameNum = 0;
    UInt8  ulSubFrame  = 0;
    UInt32 ulTTI       = 0;
    UInt32 ulSysFrameNum    = recvSFN;
#endif
    /* - SPS_TDD_Changes */

    rntiInfo_p = getRntiInfofromRNTIMap(dciPdu_p->rnti, cellIndex);
    ueIndex = rntiInfo_p->ueIndex;
    ueContextInfo_p = uplinkContextInfoMap_g[ueIndex];
    spsCtx_p = &ueContextInfo_p->spsOccCtx;

    memcpy(&spsCtx_p->dciPdu,dciPdu_p,sizeof(FAPI_dlDCIPduInfo_st));
#ifdef FDD_CONFIG
      /** For TTIB_Code */
    if (ueContextInfo_p && ueContextInfo_p->ttiBundling)
    {
        ttiIndex = (globalTTITickCount_g - 1) % MAX_SPS_INTERVAL;
    }
    else
#endif
    {
        /* + SPS_TDD_Changes */
#ifdef FDD_CONFIG
        ttiIndex = globalTTITickCount_g % MAX_SPS_INTERVAL;
#elif TDD_CONFIG
	    ulSubFrame = (recvSF +  ulSfForDCI0OrHiReceived_g[tddUlDlConfig_g[cellIndex]][recvSF])% MAX_SUBFRAME;
	    if (ulSubFrame < recvSF)
	    {
		    ulSysFrameNum++;
		    if (MAX_SFN < ulSysFrameNum)
		    {
			    ulSysFrameNum = 0;
		    }
	    }
	    ulTTI = ulSysFrameNum * MAX_SUBFRAME + ulSubFrame;
	    ttiIndex = ulTTI % MAX_UL_SPS_INTERVAL;
#endif
        /* - SPS_TDD_Changes */
    }

    /* Put entry in occasion list and update TTI context */
    ulAddUeInUeSimOccasionList( ueIndex, ttiIndex, ueContextInfo_p, cellIndex );
    /*add entry of occasion  node & ttiIndex in ueContext*/
    ueContextInfo_p->ttiIndex = ttiIndex;
    spsCtx_p->recvSF = recvSF;
    spsCtx_p->recvSFN = recvSFN;
    /*calculate delay*/
    currentSfnSf = sfnsf_g[cellIndex];
    currentSFN = currentSfnSf & FAPI_SFN_MASK;
    currentSFN >>= FAPI_SFN_VALUE_SHIFT;
    currentSF = currentSfnSf & FAPI_SF_MASK;

    if (( delay = validateSFNandSFAndgetDelay(recvSFN, recvSF,
                    currentSFN, currentSF)) == 0xFF )
    {
        //fprintf(stderr,"UL CONFIG packet Drooped due to delayed received in SPS OCCASION\n");
        //fprintf(stderr,"UL Control: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);
    }
    spsCtx_p->delay =delay;
}


void removeSPSGrant(FAPI_dlDCIPduInfo_st *dciPdu_p, UInt8 cellIndex)
{
    LP_MacSpsOccList             occListNode_p = PNULL;
    RNTIInfo               *rntiInfo_p = PNULL;
    ueContextForUplink *ueContextInfo_p = PNULL;
    UInt16  ttiIndex               = 0;
    UInt16  ueIndex = 0;
    LP_SpsUeSimTTIContext ttiContext_p              = PNULL;
    LP_SpsUeSimTTIContext ttiContextPeriodicity20_p = PNULL;
    /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
    LP_SpsUeSimTTIContext ttiContextPeriodicity40_p = PNULL;
    LP_SpsUeSimTTIContext ttiContextPeriodicity60_p = PNULL;
    /* Offset for two interval config in uplink SPS-TDD */    
    SInt8 subFrameOffset = SPS_TWO_INTERVAL_OFFSET_NA;
#endif
    /* - SPS_TDD_Changes */

    rntiInfo_p = getRntiInfofromRNTIMap(dciPdu_p->rnti, cellIndex);
    if(PNULL == rntiInfo_p)
        return;
    ueIndex = rntiInfo_p->ueIndex;
    ueContextInfo_p = uplinkContextInfoMap_g[ueIndex];
    if(PNULL == ueContextInfo_p)
        return;
    ttiIndex = ueContextInfo_p->ttiIndex;
/* SPR 11445 Changes Start*/
    /* + SPS_TDD_Changes */
#ifdef FDD_CONFIG
    ttiContextPeriodicity20_p = &spsSimTTIMap_g[cellIndex][ (ttiIndex + SPS_INTERVAL_20)\
                                % MAX_SPS_INTERVAL];
#elif TDD_CONFIG
    /* If twoIntervalConfig is enabled consider the subFrame offset for corresponding SubFrame*/
    /* 40ms periodicity: offset is considered at ttiIndex+40 */
    /* 20ms periodicity: offset is considered at ttiIndex+20 and ttiIndex+60 */
    if (TRUE == ueContextInfo_p->spsUplinkInfo.spsUplinkSetupInfo.isTwoIntervalConfigPresent)
    {
        subFrameOffset = getSubFrameOffsetForSpsTDD((ttiIndex % MAX_SUBFRAME), cellIndex); 
    }
    if( SPS_INTERVAL_20 == spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
            spsUplinkSetupInfo.semiPersistentSchedIntervalUL] )
    {
        ttiContextPeriodicity20_p = &spsSimTTIMap_g[cellIndex][ (ttiIndex + SPS_INTERVAL_20 +\
                subFrameOffset) % MAX_UL_SPS_INTERVAL];
        ttiContextPeriodicity40_p = &spsSimTTIMap_g[cellIndex][ 
            (ttiIndex + SPS_INTERVAL_40) % MAX_UL_SPS_INTERVAL];
        ttiContextPeriodicity60_p = &spsSimTTIMap_g[cellIndex][ (ttiIndex + SPS_INTERVAL_40 +\ 
                SPS_INTERVAL_20 + subFrameOffset)% MAX_UL_SPS_INTERVAL];
    }
    else if( SPS_INTERVAL_40 == spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
            spsUplinkSetupInfo.semiPersistentSchedIntervalUL] )
    {
        ttiContextPeriodicity40_p = &spsSimTTIMap_g[cellIndex][ 
            (ttiIndex + SPS_INTERVAL_40 + subFrameOffset) % MAX_UL_SPS_INTERVAL];
    }
#endif
    ttiContext_p = &spsSimTTIMap_g[cellIndex][ttiIndex];
    /* - SPS_TDD_Changes */
/* SPR 11445 Changes End */
    occListNode_p = ueContextInfo_p->occListNode_p ;
    if(PNULL == ueContextInfo_p->occListNode_p)
        return;
    ueContextInfo_p->ulNdi =0;
    ueContextInfo_p->isSpsOccasion = FALSE;
    //fprintf(stderr,"************* sps grant deact************* \n");
    if(ttiContext_p->numUlSpsOccasionPerTti)
    {
        DELETE_MAC_SPS_UE_LIST_PER_TTI(ttiContext_p->spsOccasionList,
                occListNode_p );
        (ttiContext_p->numUlSpsOccasionPerTti)--;
        freeMemPool( occListNode_p );
        occListNode_p = PNULL;
        /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
        occListNode_p = ueContextInfo_p->occListNode40_p;
        if (ttiContextPeriodicity40_p->numUlSpsOccasionPerTti)
        {
            DELETE_MAC_SPS_UE_LIST_PER_TTI(ttiContextPeriodicity40_p->spsOccasionList,
                    occListNode_p );
            (ttiContextPeriodicity40_p->numUlSpsOccasionPerTti)--;
            freeMemPool( occListNode_p );
            occListNode_p = PNULL;
        }
#endif
        /* - SPS_TDD_Changes */

        if( SPS_INTERVAL_20 == spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
                        spsUplinkSetupInfo.semiPersistentSchedIntervalUL] )
        {
            occListNode_p = ueContextInfo_p->occListNode20_p;
            if(ttiContextPeriodicity20_p->numUlSpsOccasionPerTti)
            {
                DELETE_MAC_SPS_UE_LIST_PER_TTI(ttiContextPeriodicity20_p->spsOccasionList, occListNode_p );
                (ttiContextPeriodicity20_p->numUlSpsOccasionPerTti)--;
                freeMemPool( occListNode_p );
                occListNode_p = PNULL;
            }
            /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
            occListNode_p = ueContextInfo_p->occListNode60_p;
            if(ttiContextPeriodicity60_p->numUlSpsOccasionPerTti)
            {
                DELETE_MAC_SPS_UE_LIST_PER_TTI(ttiContextPeriodicity60_p->spsOccasionList, occListNode_p );
                (ttiContextPeriodicity60_p->numUlSpsOccasionPerTti)--;
                freeMemPool( occListNode_p );
                occListNode_p = PNULL;
            }
#endif
            /* - SPS_TDD_Changes */
        }
        ueContextInfo_p->occListNode_p = PNULL;
        ueContextInfo_p->occListNode20_p = PNULL;
        /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
        ueContextInfo_p->occListNode40_p = PNULL;
        ueContextInfo_p->occListNode60_p = PNULL;
#endif
        /* - SPS_TDD_Changes */
    }
}

void ulAddUeInUeSimOccasionList( UInt16 ueIndex,
        UInt16 ttiIndex,
        ueContextForUplink *ueContextInfo_p,
        UInt8 cellIndex ) 
{
    LP_SpsUeSimTTIContext ttiContext_p              = PNULL;
    LP_SpsUeSimTTIContext ttiContextPeriodicity20_p = PNULL;    
    LP_MacSpsOccList     occNode_p = PNULL;
    /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
    /* used for 3rd node, Periodicity 40 and 20 */
    LP_SpsUeSimTTIContext ttiContextPeriodicity40_p = PNULL;   
    /* used for 4th node, Periodicity 20*/
    LP_SpsUeSimTTIContext ttiContextPeriodicity60_p = PNULL;   
    /* Offset for two interval config in uplink SPS-TDD */    
    SInt8 subFrameOffset = SPS_TWO_INTERVAL_OFFSET_NA; 
#endif
    /* Get the tti Context */
    ttiContext_p = &spsSimTTIMap_g[cellIndex][ttiIndex];
#ifdef FDD_CONFIG
    ttiContextPeriodicity20_p = &spsSimTTIMap_g[cellIndex][ 
        (ttiIndex + SPS_INTERVAL_20) % MAX_SPS_INTERVAL];
#elif TDD_CONFIG
    /* If twoIntervalConfig is enabled consider the subFrame offset for corresponding SubFrame*/
    /* 40ms periodicity: offset is considered at ttiIndex+40 */
    /* 20ms periodicity: offset is considered at ttiIndex+20 and ttiIndex+60 */
    if (TRUE == ueContextInfo_p->spsUplinkInfo.spsUplinkSetupInfo.isTwoIntervalConfigPresent)
    {
        subFrameOffset = getSubFrameOffsetForSpsTDD((ttiIndex % MAX_SUBFRAME), cellIndex);
    }
    if( SPS_INTERVAL_20 == spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
            spsUplinkSetupInfo.semiPersistentSchedIntervalUL] )
    {
	    ttiContextPeriodicity20_p = &spsSimTTIMap_g[cellIndex][ 
		    (ttiIndex + SPS_INTERVAL_20 + subFrameOffset) % MAX_UL_SPS_INTERVAL];
	    ttiContextPeriodicity40_p = &spsSimTTIMap_g[cellIndex][ 
		    (ttiIndex + SPS_INTERVAL_40) % MAX_UL_SPS_INTERVAL];
	    ttiContextPeriodicity60_p = &spsSimTTIMap_g[cellIndex][ 
		    (ttiIndex + SPS_INTERVAL_40 + SPS_INTERVAL_20 + subFrameOffset) % 
		    MAX_UL_SPS_INTERVAL];
    }
    else if( SPS_INTERVAL_40 == spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
            spsUplinkSetupInfo.semiPersistentSchedIntervalUL] )
    {
        ttiContextPeriodicity40_p = &spsSimTTIMap_g[cellIndex][ 
            (ttiIndex + SPS_INTERVAL_40 + subFrameOffset) % MAX_UL_SPS_INTERVAL];
    }
#endif
    /* - SPS_TDD_Changes */

    /* Allocate node for PDSCH Occasion List entry */
    occNode_p = (LP_MacSpsOccList)getMemFromPool(
            sizeof(MacSpsOccList), PNULL );
    if( PNULL == occNode_p )
    {
        ltePanic("getMemFromPool fails %s", __func__);
    }
    /* Fill the occasion list */
    occNode_p->ueIndex = ueIndex;
    /*SPR 6690 fix Start */
    occNode_p->firstFlag = 1;
    /*SPR 6690 fix End */

    ENQUEUE_MAC_SPS_UE_LIST_PER_TTI( ttiContext_p->spsOccasionList, occNode_p);
    (ttiContext_p->numUlSpsOccasionPerTti)++;

    ueContextInfo_p->occListNode_p = occNode_p; 
    //fprintf(stderr,"*************enqueued sps grant at %d************* \n",ttiIndex);
    /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
    occNode_p = PNULL;
    /* Allocate node for PDSCH Occasion List entry */
    occNode_p = (LP_MacSpsOccList)getMemFromPool(
            sizeof(MacSpsOccList), PNULL );
    if( PNULL == occNode_p )
    {
        ltePanic("getMemFromPool fails %s", __func__);
    }
    /* Fill the occasion list */
    occNode_p->ueIndex = ueIndex;
    occNode_p->firstFlag = 0;

    ENQUEUE_MAC_SPS_UE_LIST_PER_TTI( ttiContextPeriodicity40_p->spsOccasionList, occNode_p);
    (ttiContextPeriodicity40_p->numUlSpsOccasionPerTti)++;

    ueContextInfo_p->occListNode40_p = occNode_p; 
#endif
    /* - SPS_TDD_Changes */

    if( SPS_INTERVAL_20 == spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
                        spsUplinkSetupInfo.semiPersistentSchedIntervalUL] )
    {
        occNode_p = PNULL;
        /* Allocate node for PDSCH Occasion List entry */
        occNode_p = (LP_MacSpsOccList)getMemFromPool(
                 sizeof(MacSpsOccList), PNULL );
        if( PNULL == occNode_p )
        {
            ltePanic("getMemFromPool fails %s", __func__);
        }
        /* Fill the occasion list */
        occNode_p->ueIndex = ueIndex;
        /*SPR 6690 fix Start */
        occNode_p->firstFlag = 0;
        /*SPR 6690 fix End */

        ENQUEUE_MAC_SPS_UE_LIST_PER_TTI(
                ttiContextPeriodicity20_p->spsOccasionList,
                occNode_p );
        (ttiContextPeriodicity20_p->numUlSpsOccasionPerTti)++;
        ueContextInfo_p->occListNode20_p = occNode_p;
        /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
        occNode_p = PNULL;
        /* Allocate node for PDSCH Occasion List entry */
        occNode_p = (LP_MacSpsOccList)getMemFromPool(
                sizeof(MacSpsOccList), PNULL );
        if( PNULL == occNode_p )
        {
            ltePanic("getMemFromPool fails %s", __func__);
        }
        /* Fill the occasion list */
        occNode_p->ueIndex = ueIndex;
        occNode_p->firstFlag = 0;

        ENQUEUE_MAC_SPS_UE_LIST_PER_TTI(
                ttiContextPeriodicity60_p->spsOccasionList,
                occNode_p );
        (ttiContextPeriodicity60_p->numUlSpsOccasionPerTti)++;
        ueContextInfo_p->occListNode60_p = occNode_p;
#endif
        /* - SPS_TDD_Changes */
    }
}
#ifdef FDD_CONFIG
/** TTIB_Code Start */
/****************************************************************************
 * Function Name  :  processTTIBQueue 
 * Inputs         :  Nothing
 * Outputs        :  Node is inserted in given ulsch queue at qIndex where
 *                   data to send
 * Returns        :  Nothing
 * Description    :  It dequeues the element at currentTick % 16 & put that node
 *                   in ulsch queue at given index.
 ****************************************************************************/
void processTTIBQueue(UInt8 cellIndex)
{
    UInt8 ttibUeCount = 0;
    UInt8 ttibqIndex = 0;
    /*SPR 15909 fix start*/
    tickType_t currentTick = getCurrentglobaltick();
    /*SPR 15909 fix end*/
    ttibDataQueueNode *ttibQNode_p = PNULL;
    RNTIInfo               *rntiInfo_p = PNULL;
    ueContextForUplink *ueContextInfo_p = PNULL;

    ttibqIndex = currentTick % TTI_BUNDLE_RTT;
/* SPR_11526_Fix Start */
    ttibUeCount = queueCount(&(ttibDataQueue_g[cellIndex][ttibqIndex]));
/* SPR_11526_Fix End */
    while( ttibUeCount-- )
    {
/* SPR_11526_Fix Start */
        ttibQNode_p = (ttibDataQueueNode *)deQueue( &(ttibDataQueue_g[cellIndex][ttibqIndex]));
/* SPR_11526_Fix End */
        rntiInfo_p = getRntiInfofromRNTIMap(ttibQNode_p->dciPdu.rnti, cellIndex);
        if (rntiInfo_p )
        {
            ueContextInfo_p = uplinkContextInfoMap_g[rntiInfo_p->ueIndex];

            /* SPR_8413 Fix Start */
            if ( ueContextInfo_p == PNULL )
            {
                fprintf(stderr,"in function: processTTIBQueue UE Context does exist for crnti = %d\n",rntiInfo_p->ueIndex);
                freeMemPool(ttibQNode_p);
                ttibQNode_p = PNULL;
                continue;
            }
            /* SPR_8413 Fix End*/

            if(ueContextInfo_p->ttiBundling)
            {
                fapiProcessUlGrant(ttibQNode_p->harqIndex,
                        ttibQNode_p->sendSfnSf,
                        ttibQNode_p->qIndex,
                        ttibQNode_p->phichReceiveIndex,
                        ttibQNode_p->delay,
                        &ttibQNode_p->dciPdu,
                        ttibQNode_p->recvSF,
                        ttibQNode_p->recvSFN,
                        cellIndex);
            }
        }
        freeMemPool(ttibQNode_p);
        ttibQNode_p = PNULL;

    }
}
/** TTIB_Code End */
#endif

/* + SPS_TDD_Changes */
#define GET_REQUIRED_SPS_INDEX(sfn ,sf, incrementFactor)\
{\
    UInt8 sf1 = 0;\
    if (incrementFactor + sf >= 0)\
    {\
        sf1  = sf + incrementFactor;\
        \
        if (sf1 >=  MAX_SUB_FRAME)\
        {\
            sf = sf1 % 10;\
\
            sfn  += (sf1 / 10);\
\
            if ( sfn >= MAX_SFN_VALUE )\
            {\
                sfn -= MAX_SFN_VALUE;\
            }\
        }\
        else\
        {\
            sf = sf1;\
        }\
    }\
    else\
    {\
        sf  = (sf + 10) + incrementFactor;\
        if (sfn == 0)\
        {\
            sfn = MAX_SFN_VALUE - 1;\
        }\
        else\
        {\
            sfn -= 1;\
        }\
    }\
}
/* - SPS_TDD_Changes */

void processUlUeSimSpsOccasion(UInt8 cellIndex )
{
    LP_MacSpsOccList          occNode_p         = PNULL;
    UInt16                       index               = 0;
    LP_SpsUeSimTTIContext  spsSimIntervalTTI_p = PNULL;
    UInt16 currentSFN = 0, recvSFN = 0, receivedSf = 0;
    UInt16 currentSfnSf = 0, recvSfnSf = 0;
    UInt8  currentSF = 0, recvSF = 0;
    UInt16 sendSfnSf = 0;
    UInt8  delay = 0, qIndex = 0;
    UInt8 sendSF = 0;
    UInt16 sendSFN = 0;
    UInt8 harqIndex = 0;
    UInt16 spsOccasionUeCount = 0;
    UInt8  phichReceiveIndex   = 0; 
    /* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
    UInt8  subFrameNum = 0;
    UInt8  ulSubFrame  = 0;
    UInt32 ulTTI       = 0;
    UInt32 sysFrameNum = ((globalTTITickCount_g / 10) & 1023);
    UInt32 ulSysFrameNum    = sysFrameNum;
#endif
    /* - SPS_TDD_Changes */

    FAPI_dlDCIPduInfo_st     *dciPdu_p = PNULL;
    ueContextForUplink *ueContextInfo_p = PNULL; 
    LP_SpsOccUeContext   spsCtx_p = PNULL;

    currentSfnSf = sfnsf_g[cellIndex];
    currentSFN = currentSfnSf & FAPI_SFN_MASK;
    currentSFN >>= FAPI_SFN_VALUE_SHIFT;
    currentSF = currentSfnSf & FAPI_SF_MASK;
    //      index = ((10*SF_g)+SFN_g)% MAX_SPS_INTERVAL;
    /* + SPS_TDD_Changes */
#ifdef FDD_CONFIG
    index = (globalTTITickCount_g) % MAX_SPS_INTERVAL;
#elif TDD_CONFIG
    subFrameNum = globalTTITickCount_g % MAX_SUBFRAME;
    ulSubFrame = (subFrameNum +  ulSfForDCI0OrHiReceived_g[tddUlDlConfig_g[cellIndex]][subFrameNum])% MAX_SUBFRAME;
    if (ulSubFrame < subFrameNum)
    {
	    ulSysFrameNum++;
	    if (MAX_SFN < ulSysFrameNum)
	    {
		    ulSysFrameNum = 0;
	    }
    }
    ulTTI = ulSysFrameNum * MAX_SUBFRAME + ulSubFrame;
    index = ulTTI % MAX_UL_SPS_INTERVAL;
#endif
    /* - SPS_TDD_Changes */
/* SPR 11445 Changes Start */
    spsSimIntervalTTI_p = &spsSimTTIMap_g[cellIndex][index];
/* SPR 11445 Changes End */
    GET_FIRST_MAC_SPS_UE_LIST_PER_TTI(spsSimIntervalTTI_p->spsOccasionList,
            occNode_p);
    spsOccasionUeCount = spsSimIntervalTTI_p->numUlSpsOccasionPerTti;
    if(spsOccasionUeCount == 0)
        return;
    while( spsOccasionUeCount-- )
    {
        /*SPR 6690 fix Start */
        if (occNode_p->firstFlag==1)
        {
            occNode_p->firstFlag=0;
            /* TTIB_Code Start */
            ueContextInfo_p = uplinkContextInfoMap_g[occNode_p->ueIndex];
            /* + SPS_TDD_Changes */
            spsCtx_p = &ueContextInfo_p->spsOccCtx;
            if (spsCtx_p->startSFN == 0 && spsCtx_p->startSF == 0) 
            {
                spsCtx_p->startSFN = spsCtx_p->recvSFN;
                spsCtx_p->startSF = spsCtx_p->recvSF;
                spsCtx_p->N++;
            }
            /* - SPS_TDD_Changes */
            if (ueContextInfo_p && ueContextInfo_p->ttiBundling)
            {
                spsCtx_p = &ueContextInfo_p->spsOccCtx;

                dciPdu_p = &spsCtx_p->dciPdu;
                /*increase configured grant to occur in previous SF + 4(sps occasion) */
                spsCtx_p->recvSFN += (spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
                        spsUplinkSetupInfo.semiPersistentSchedIntervalUL]) / MAX_SF_VALUE ;
                if ( spsCtx_p->recvSFN >= MAX_SFN )
                {
                    spsCtx_p->recvSFN -= MAX_SFN;
                }


            }
            /* TTIB_Code End */

            GET_NEXT_MAC_SPS_UE_LIST_PER_TTI(spsSimIntervalTTI_p->spsOccasionList,
                  occNode_p);
            continue;
        }
        /*SPR 6690 fix End */
        ueContextInfo_p = uplinkContextInfoMap_g[occNode_p->ueIndex];
        spsCtx_p = &ueContextInfo_p->spsOccCtx;

        dciPdu_p = &spsCtx_p->dciPdu;
        /*increase configured grant to occur in previous SF + 4(sps occasion) */
		/* + SPS_TDD_Changes */
#ifdef TDD_CONFIG
	if (FALSE == ueContextInfo_p->spsUplinkInfo.spsUplinkSetupInfo.isTwoIntervalConfigPresent)
	{
#endif		
		spsCtx_p->recvSFN += (spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
				spsUplinkSetupInfo.semiPersistentSchedIntervalUL]) / MAX_SF_VALUE ;
		if ( spsCtx_p->recvSFN >= MAX_SFN )
		{
			spsCtx_p->recvSFN -= MAX_SFN;
		}
#ifdef TDD_CONFIG
	}
	else if (TRUE == ueContextInfo_p->spsUplinkInfo.spsUplinkSetupInfo.isTwoIntervalConfigPresent)
	{
		if (1 == tddUlDlConfig_g[cellIndex])
		{
				/* Offset for two interval config in uplink SPS-TDD */    
				SInt8 subFrameOffset = SPS_TWO_INTERVAL_OFFSET_NA;
				ulSubFrame = (spsCtx_p->recvSF +  
								ulSfForDCI0OrHiReceived_g[tddUlDlConfig_g[cellIndex]][spsCtx_p->recvSF])% MAX_SUBFRAME;
				//fprintf(stderr,"\nSFN [%u] SF [%u]\n",spsCtx_p->recvSFN, spsCtx_p->recvSF);
				/*Updating SFN - SF as per previous occassion*/
				GET_REQUIRED_SPS_INDEX(spsCtx_p->recvSFN, spsCtx_p->recvSF, 
								ulSfForDCI0OrHiReceived_g[tddUlDlConfig_g[cellIndex]][spsCtx_p->recvSF]);
				//fprintf(stderr,"\nSFN [%u] SF [%u]\n",spsCtx_p->recvSFN, spsCtx_p->recvSF);

				/*Updating SFN - SF for two interval config on previous occassion*/
				subFrameOffset = (getSubFrameOffsetForSpsTDD((ulSubFrame % MAX_SUBFRAME), cellIndex));
				GET_REQUIRED_SPS_INDEX(spsCtx_p->recvSFN, spsCtx_p->recvSF, subFrameOffset);
				//fprintf(stderr,"\n SWETA: spsCtx_p->recvSF1:[%u] , spsCtx_p->recvSFN:[%u], subFrameOffset:[%d]", spsCtx_p->recvSF, spsCtx_p->recvSFN, subFrameOffset);

				/*Updating SFN - SF to get UL occurance of current occassion*/
				spsCtx_p->recvSFN += (spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.\
								spsUplinkSetupInfo.semiPersistentSchedIntervalUL]) / MAX_SF_VALUE ;
				if ( spsCtx_p->recvSFN >= MAX_SFN )
				{
						spsCtx_p->recvSFN -= MAX_SFN;
				}
				//fprintf(stderr,"\nSFN [%u] SF [%u]\n",spsCtx_p->recvSFN, spsCtx_p->recvSF);

				/*Updating SFN-SF for DCI0 corresponding to UL Subframe 
				  of current occassion*/
				subFrameOffset = getPrevSubFrameforDCI0(spsCtx_p->recvSF, cellIndex);
				GET_REQUIRED_SPS_INDEX(spsCtx_p->recvSFN, spsCtx_p->recvSF, -(subFrameOffset));
				//fprintf(stderr,"\n SWETA: spsCtx_p->recvSF1:[%u] , spsCtx_p->recvSFN:[%u], subFrameOffset:[%d]", spsCtx_p->recvSF, spsCtx_p->recvSFN, subFrameOffset);
		}
		else
		{
				SInt8 subFrameOffset = SPS_TWO_INTERVAL_OFFSET_NA;
                UInt16 sfnSf = 0;
				/* Offset for two interval config in uplink SPS-TDD */    
				ulSubFrame = (spsCtx_p->recvSF +  
								ulSfForDCI0OrHiReceived_g[tddUlDlConfig_g[cellIndex]][spsCtx_p->recvSF])% MAX_SUBFRAME;
				/*Updating SFN - SF for two interval config on previous occassion*/
				subFrameOffset = (getSubFrameOffsetForSpsTDD((ulSubFrame % MAX_SUBFRAME), cellIndex));

                sfnSf = (((spsCtx_p->startSFN * 10) + spsCtx_p->startSF) + (spsCtx_p->N *\
                            spsIntervalMap_g[ueContextInfo_p->spsUplinkInfo.spsUplinkSetupInfo.semiPersistentSchedIntervalUL]) +\
                            subFrameOffset * (spsCtx_p->N % 2)) % 10240;
				//fprintf(stderr,"\n ulSubFrame:[%u], spsCtx_p->N:[%d] subFrameOffset:[%d] sfnSf:[%d]", ulSubFrame,spsCtx_p->N, subFrameOffset,sfnSf);

                spsCtx_p->recvSF = sfnSf % 10;
                spsCtx_p->recvSFN = (sfnSf / 10) % 1024;
                spsCtx_p->N++;
				//fprintf(stderr,"\nSFN [%u] SF [%u]\n",spsCtx_p->recvSFN, spsCtx_p->recvSF);
		}
	}
#endif		
	/* - SPS_TDD_Changes */

        recvSF = spsCtx_p->recvSF;
        recvSFN = spsCtx_p->recvSFN;

        /* + SPS_TDD_Changes */
#ifdef FDD_CONFIG
        /*calculate delay*/

        if (( delay = validateSFNandSFAndgetDelay(recvSFN, recvSF,
                        currentSFN, currentSF)) == 0xFF )
        {
            //fprintf(stderr,"UL CONFIG packet Drooped due to delayed received in SPS OCCASION\n");
            //fprintf(stderr,"UL Control: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);

            continue;
        }


        /*calculate qIndex * phichIndex */
        qIndex = recvSF + 4 + PEER_MAC_DELAY;
        phichReceiveIndex = recvSF + 8;
        if (qIndex >= MAX_SUBFRAME)
        {
            qIndex -= MAX_SUBFRAME;
        }
        if (phichReceiveIndex >= MAX_SUBFRAME)
        {
            phichReceiveIndex -= MAX_SUBFRAME;
        }


        recvSF += 4;
        if ( recvSF >= MAX_SUBFRAME )
        {
            recvSF -= MAX_SUBFRAME;
            recvSFN++ ;
            if ( recvSFN == MAX_SFN )
            {
                recvSFN = 0;
            }
        }

#elif TDD_CONFIG
        if (( delay = validateTick( recvSFN,
                        recvSF,
                        currentSFN,
                        currentSF
                        )) == 0xFF )
        {

            //fprintf(stderr,"UL CONFIG packet Drooped due to delayed received\n");
            fprintf(stderr,"UL Control: C_SFN[%d] C_SF[%d] recvSFN[%d] recvSF[%d]\n", currentSFN, currentSF, recvSFN, recvSF);
            continue;
        }

        //qIndex = (recvSFN * MAX_SUBFRAME + recvSF+ PEER_MAC_DELAY ) % MAX_UL_ARRAY;
        //phichReceiveIndex = (recvSFN * MAX_SUBFRAME + recvSF) % MAX_UL_HARQ_TIMER_ARRAY;

        Dci0HiPdu *dci0HiPdu_p = PNULL;
        Dci0HiPdu dci0HiPdu;
        dci0HiPdu_p = (Dci0HiPdu *) &dci0HiPdu;

        UInt16 enbSFN = recvSFN;
        UInt8  enbSF  = recvSF;

        calQIdxSFandSFN( recvSF,
                recvSFN,
                delay,
                dci0HiPdu_p,
                cellIndex
                );

        recvSFN = dci0HiPdu_p->hiSFN;
        recvSF  = dci0HiPdu_p->hiSF;
        qIndex  = dci0HiPdu_p->hiQIdx;

        phichReceiveIndex = (enbSFN * MAX_SUBFRAME + enbSF) % MAX_UL_HARQ_TIMER_ARRAY;

#endif				
        /* - SPS_TDD_Changes */
        sendSfnSf = GENERATE_SUBFRAME_SFNSF(recvSFN, recvSF);
        sendSF = sendSfnSf & FAPI_SF_MASK;
        sendSFN = (sendSfnSf & FAPI_SFN_MASK ) >> FAPI_SFN_VALUE_SHIFT;
        ueContextInfo_p->isSpsOccasion = TRUE;
    
#ifdef FDD_CONFIG
         /** For TTIB_Code */
        if ( ueContextInfo_p->ttiBundling && (ueContextInfo_p->ttibInfo.bundleStartIndex != TTIB_INVALID_VALUE))
        {
           harqIndex = (((sendSFN * MAX_SUBFRAME) + sendSF - ueContextInfo_p->ttibInfo.bundleStartIndex) % TTI_BUNDLE_RTT) /TTI_BUNDLE_SIZE;
            /*** Pushing the nodes in ttib queue ***/
            pushTTIBNodes(harqIndex, spsCtx_p->delay,((phichReceiveIndex + FRESH_TRANSMISSION) % MAX_SUBFRAME),qIndex,dciPdu_p,
                    spsCtx_p->recvSF,spsCtx_p->recvSFN,sendSfnSf,FRESH_TRANSMISSION,cellIndex);
        }
        else
#endif
        {
            harqIndex = (((sendSFN * MAX_SUBFRAME) + sendSF /*+ HI_DCI_DIFF*/) % MAX_HARQ_PROCESS_NB);
            fapiProcessUlGrant(harqIndex, sendSfnSf, qIndex, phichReceiveIndex,
                    spsCtx_p->delay, dciPdu_p, spsCtx_p->recvSF,
                    spsCtx_p->recvSFN, cellIndex);
        }
        GET_NEXT_MAC_SPS_UE_LIST_PER_TTI(spsSimIntervalTTI_p->spsOccasionList,
                occNode_p);
    }
}

UInt8 populateSpsCrnti(UInt16 spsCrnti, UInt8 cellIndex)
{
    if (rntiToIdxTbl_g[cellIndex][(spsCrnti - cellConfigUeSim_g[cellIndex].startSpsCrnti + 
                cellConfigUeSim_g[cellIndex].crntiRange)].rnti == spsCrnti)
    {
        /* Already updated the spsCrnti Table */
        return;
    }
    else
    {
        rntiToIdxTbl_g[cellIndex][(spsCrnti - cellConfigUeSim_g[cellIndex].startSpsCrnti + 
        cellConfigUeSim_g[cellIndex].crntiRange)].rnti = spsCrnti;
        rntiToIdxTbl_g[cellIndex][(spsCrnti - cellConfigUeSim_g[cellIndex].startSpsCrnti + 
        cellConfigUeSim_g[cellIndex].crntiRange)].state = UE_ACTIVE;
        rntiToIdxTbl_g[cellIndex][(spsCrnti - cellConfigUeSim_g[cellIndex].startSpsCrnti + 
                cellConfigUeSim_g[cellIndex].crntiRange)].ueIndex = 
            (spsCrnti - cellConfigUeSim_g[cellIndex].startSpsCrnti) * numCells_g + cellIndex ; 

        rntiToIdxTbl_g[cellIndex][(spsCrnti - cellConfigUeSim_g[cellIndex].startSpsCrnti + 
        cellConfigUeSim_g[cellIndex].crntiRange)].rntiType = FAPI_SPS_CRNTI;
    }
}
/*SPS_CHG*/
/* + PRS_CHANGES */
void  fapiHandlePrsConfigPdu(FAPI_prsPduConfigInfo_st *prsPdu_p,
                            fapiMsgIdStruct *msgIdArr_p)
{
    if ( PNULL == prsPdu_p )
    {
        fprintf(stderr,"Error..!!! prsPdu  received with no power  \n");
        return;
    }
    else
    {
        /* PRS PDU received */

    }
}
/* - PRS_CHANGES */
/*==============================================*/
#ifdef DL_DATA_SEPARATION                 
dlMsg_t dlmsg1_g={0};

/****************************************************************************
 * Function Name  :  checkDlConfigDlTxMsg
 * Inputs         :  
 * Output         :  
 * Returns        :  
 * Description    : This function checks whether DL_CONFIG is received or not 
 *                  before TX DATA. If Tx_Data is received first then store same 
 *                  and decode later once Dl_config is received.
 ******************************************************************************/

void checkDlConfigDlTxMsg( FAPI_l1ApiMsg_st *l1RcvMsg_p,
                                    fapiMsgIdStruct *msgIdArr_p,
                                    UInt8 rxCellIndex)
{
    FAPI_dlConfigPDUInfo_st *recvDlConfigPdu_p = PNULL;
    FAPI_dlConfigRequest_st  *dlConfigReq_p = PNULL;
    UInt8 *temp_p = PNULL;
    UInt16 dciPduCount = 0;
    UInt16 recvSfnSf = 0, numOfDlConfigPdu = 0;
    UInt16 recvSFN = 0;
    UInt16 pduIndex = 0;
    UInt8 recvSF = 0, delay = 0;
    UInt16 dlConfigPduSize = 0;
    UInt16 currentSFN = sfnsf_g[rxCellIndex] & FAPI_SFN_MASK;
    UInt8 currentSF = sfnsf_g[rxCellIndex] & FAPI_SF_MASK;
    DLUEContext *newUEContext_p = PNULL;
    UInt16  ackNackSFN = 0;
    UInt8   ackNackSF = 0;
    FAPI_l1ApiMsg_st*    control_l1RcvMsg_p=NULL;
    FAPI_l1ApiMsg_st*    data_l1RcvMsg_p=NULL;
    fapiMsgIdStruct*    control_msgIdArr_p=NULL;
    fapiMsgIdStruct*    data_msgIdArr_p=NULL;
    dlConfigReq_p =  ( FAPI_dlConfigRequest_st *) &(l1RcvMsg_p->msgBody[0]);
    if ( PNULL == dlConfigReq_p )
    {
        fprintf(stderr,"Error..!!! dlConfig msgBody = NULL recevied from MAC" "in DL CONFIG REQ\n");  
        return;
    }

    recvSfnSf = MAC_PHY_CONVERT_16(dlConfigReq_p->sfnsf); 
    recvSFN = recvSfnSf & FAPI_SFN_MASK;
    recvSFN >>= FAPI_SFN_VALUE_SHIFT; 
    recvSF = recvSfnSf & FAPI_SF_MASK;

    if (l1RcvMsg_p->msgId == PHY_DL_CONFIG_REQUEST)
    {
        controlmsg_g=1;

        if (datamsg_g)
        {
            if ( (dlmsg1_g.recvSFN == recvSFN) && (dlmsg1_g.recvSF == recvSF) )
            {
                fapiHandlePhyDlTxRequest(dlmsg1_g.msg, msgIdArr_p, rxCellIndex);          
            }
                else
                {
                    fprintf(stderr, "wrong seq received; dlConfig recvd SFN=%d tx SFN=%d recvd SF=%d tx SF=%d\n", 
                        recvSFN,dlmsg1_g.recvSFN  , recvSF, dlmsg1_g.recvSF);
                    fprintf(stderr,"dropping tx req");
                }
            controlmsg_g=0;
            datamsg_g = 0;
        }
        else
        {
                memcpy(&dlmsg1_g.msgIdArr, msgIdArr_p, sizeof(fapiMsgIdStruct)*MAX_MSG_ID);
                dlmsg1_g.recvSF = recvSF;
                dlmsg1_g.recvSFN = recvSFN;
        }
    }
    else if  (l1RcvMsg_p->msgId == PHY_DL_TX_REQUEST)
    {
        if (controlmsg_g)
        {
                if ( (dlmsg1_g.recvSFN == recvSFN) && (dlmsg1_g.recvSF == recvSF) )
                {
                    fapiHandlePhyDlTxRequest(l1RcvMsg_p, dlmsg1_g.msgIdArr, rxCellIndex);          
                }
                else
                {
                    fprintf(stderr, "wrong seq received; tx recvd SFN=%d dlConfig SFN=%d recvd SF=%d dlConfig SF=%d\n", 
                        recvSFN,dlmsg1_g.recvSFN  , recvSF, dlmsg1_g.recvSF);
                    fprintf(stderr,"dlconfig and tx req missing");
                }
                controlmsg_g=0;
                datamsg_g=0;
        }
        else
        {
                memcpy(&dlmsg1_g.msg, l1RcvMsg_p, (l1RcvMsg_p->msgLen + sizeof(FAPI_l1ApiMsg_st)));
                dlmsg1_g.recvSF = recvSF;
                dlmsg1_g.recvSFN = recvSFN;
                datamsg_g =1;
        }
    }
   return;
}

#endif
/*FAPI_ERROR_INDICATION_CHANGES_START*/
/****************************************************************************
 * Function Name  : parsePhyErrorConfigFile
 * Inputs         : void
 * 
 * 
 * Outputs        : Population of global variables
 * Returns        : Nothing
 * Description    : Parse PhyErrorConfig.cfg file for Phy Error Indication testing
 * *****************************************************************************/
void parsePhyErrorConfigFile(void)
{
    FILE *fp;
    UInt16  length                    = 0;
    Char8   line[PHY_ERR_MAX_LINE_SIZE]   = {0};
    Char8   temp[PHY_ERR_MAX_LINE_SIZE]   = {0};
    fp = fopen(PHY_ERROR_CONFIG_FILE_PATH,"r");
    SInt8 cellIndex = -1;
    if (fp == NULL)
    {
        fprintf(stderr,"Unable to open file - PHY_ERROR_CONFIG_FILE_PATH\n");
        return;
    }
    while((fgets((char *)line,PHY_ERR_MAX_LINE_SIZE,fp) != NULL)  && cellIndex < numCells_g)
    {

        if ((strncmp((const char*)line,"#",1) == 0) || (strncmp((const char*)line,"\n",1) == 0))
        {
            continue;
        }

        trimSpaces(line);
        length = strlen(line);
        
        if (strncmp((const char*)line,"[CELL]",6) == 0)
        {
            strncpy((char *)temp,(const char*)line+6,length-6);
            cellIndex++;
            fprintf(stderr,"cellIndex = %d",cellIndex);
        }
        
        if (cellIndex >= numCells_g)
            break;
        
        if (strncmp((const char*)line,"CONFIGURE_ERROR",15) == 0)
        {
            strncpy((char *)temp,(const char*)line+16,length-16);
            phy_err_config_g[cellIndex] = atoi(temp);
        }
        
        if (strncmp((const char*)line, "CONFIGURE_TICK_MISS", 19) == 0)
        {
            strncpy((char *)temp,(const char*)line+20,length-20);
            phy_tick_miss_g[cellIndex] = atoi(temp);
        }

        if (strncmp((const char*)line,"START_RANGE_OF_TTI",18) == 0)
        {
            strncpy((char *)temp,(const char*)line+19,length-19);
            phy_err_start_tti_g[cellIndex] = atoi(temp);

        }
        else if (strncmp((const char*)line,"END_RANGE_OF_TTI",16) == 0)
        {
            strncpy((char *)temp,(const char*)line+17,length-17);
            phy_err_end_tti_g[cellIndex] = atoi(temp);
        }
        else if (strncmp((const char*)line,"MSG_TYPE",8) == 0)
        {
            strncpy((char *)temp,(const char*)line+9,length-9);
            phy_err_msg_type_g[cellIndex] = atoi(temp);
        }
        else if (strncmp((const char*)line,"ERROR_TYPE",10) == 0)
        {
            strncpy((char *)temp,(const char*)line+11,length-11);
            phy_err_error_type_g[cellIndex] = atoi(temp);
        }
        else if (strncmp((const char*)line,"DELTA_VAL",9) == 0)
        {
            strncpy((char *)temp,(const char*)line+10,length-10);
            phy_err_delta_val_g[cellIndex] = atoi(temp);
            phy_err_abs_delta_val_g[cellIndex] = ABS(phy_err_delta_val_g[cellIndex]) + 1;
        }
        else if (strncmp((const char*)line,"PDU_TYPE",8) == 0)
        {
            strncpy((char *)temp,(const char*)line+9,length-9);
            phy_err_pdu_type_g[cellIndex] = atoi(temp);
        }
        else if (strncmp((const char*)line,"SUB_ERR_CODE",12) == 0)
        {
            strncpy((char *)temp,(const char*)line+13,length-13);
            phy_err_sub_err_code_g[cellIndex] = atoi(temp);
        }
    }
    fclose(fp);
}

/****************************************************************************
 * Function Name  : checkScellStatus
 * Inputs         : UInt8 ueIndex
 * 
 * 
 * Outputs        : State of scell
 * Returns        : Current State of scell
 * Description    : It will check the deactiavtion timer expiry and mac ce recieved 
 *                  then return the current scell state. 
 * *****************************************************************************/
/* +- SPR 18268 */
UInt8 checkScellStatus(UInt16 ueIndex)
/* +- SPR 18268 */
{
   ueContextForUplink *ulUEContext_p = PNULL;
   ulUEContext_p = uplinkContextInfoMap_g[ueIndex]; 
   if ((ulUEContext_p->carrierAggrConfig.scellInfo[1].scellDeactivationExpirytti >= getCurrentglobaltick()) || \
          ((!ulUEContext_p->carrierAggrConfig.scellInfo[1].scellActDeactFlag) && \
              (ulUEContext_p->carrierAggrConfig.scellInfo[1].isScellActivateStatus) ))
   {
      return TRUE; 
   }
   return FALSE;
}
/*phase-3 changes end*/

/* EICIC +*/
/****************************************************************************
 * Function Name  : preparePcellPeriodicCqiReport_ABS
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    : This function prepare Scell Periodic Cqi Report 
 ****************************************************************************/
void preparePcellPeriodicCqiReport_ABS(UInt8 cellIndex,UInt8 cqiPeriodicReportType,
        DLUEContext *newUEContext_p, 
        UInt8 *cqiReport_p,
        UInt8 *cqiCount,
        UInt8 sendSF)
{
    UInt8 cqi_count = *cqiCount;
    UInt8 riIndex = 0;
    UInt8 count = 0;
    /*EICIC Enhancement +*/
    UInt32 tracker = 0;
    tracker =  newUEContext_p->dlCQIInfo.indexTrack;
    /*EICIC Enhancement -*/
    newUEContext_p->dlCQIInfo.ueCqiIndexNum = ( (newUEContext_p->dlCQIInfo.ueCqiIndexNum) % 
            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
    count = 
        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
        ueProfile[newUEContext_p->dlCQIInfo.ueCqiIndexNum];
    /*EICIC Enhancement +*/
	tracker ++;
	if (0 == (tracker % (cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexTracker)))
	{ 
            newUEContext_p->dlCQIInfo.ueCqiIndexNum++;
	    tracker = 0;
	}
       newUEContext_p->dlCQIInfo.indexTrack = tracker;
   /*EICIC Enhancement -*/
    newUEContext_p->dlCQIInfo.cqiReportType[sendSF] = CQI_INVALID_REPORT_TYPE;

    
    switch(newUEContext_p->dlCQIInfo.periodicModeType)
    {
        case CQI_PERIODIC_TYPE_10:
            {    
                /* SPR 3924 changes start */
                if((RI_TYPE_3 == cqiPeriodicReportType) && ((newUEContext_p->transmissionMode == 3) ||
                            (newUEContext_p->transmissionMode == 4))) // SPR 7335 changes
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    newUEContext_p->dlCQIInfo.ueRIIndexNum = ( (newUEContext_p->dlCQIInfo.ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                        ueProfile[newUEContext_p->dlCQIInfo.ueRIIndexNum];
                    newUEContext_p->dlCQIInfo.ueRIIndexNum++;
                    if ((newUEContext_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex]);
                    }
                    else
                        cqiReport_p[cqi_count] = newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex];
                    {
                        newUEContext_p->dlCQIInfo.RI = newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex] + 1;
                        //  fprintf(stderr,"Value of RI10 [%d]\n",newUEContext_p->dlCQIInfo.RI);//SPR 7335 changes
                    }
                    /* - CQI_5.0 */
                }   
                /* SPR 3924 changes start */
                else if(WIDE_BAND_CQI_TYPE_4 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {   
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode10Abs_p[count].wideBandCQI));
                }
                newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
            }
            break;
        case CQI_PERIODIC_TYPE_11:
            {
                /* SPR 3924 changes start */
                if(WIDE_BAND_CQI_PMI_TYPE_2 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    if(1 ==  newUEContext_p->dlCQIInfo.RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11Abs_p[count].wideBandCQI_RI_1));
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            cqiReport_p[cqi_count] |= 
                                ((FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11Abs_p[count].PMI_RI_1)) << 4);
                        }
                        else
                            cqiReport_p[cqi_count] |=
                                ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11Abs_p[count].PMI_RI_1)) << 4); 
                    }    
                    else if(1  <  newUEContext_p->dlCQIInfo.RI)   
                    {
                        UInt8 tmpPMIRI_2 = 0;
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11Abs_p[count].wideBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11Abs_p[count].spatialDiffCQI_RI_2)) << 4); 
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            tmpPMIRI_2 = FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11Abs_p[count].PMI_RI_2);
                            /* SPR 7415 changes start */
                            cqiReport_p[cqi_count] |= (((tmpPMIRI_2)&0x01) << 7);
                            /* SPR 7415 changes end */
                            cqi_count++;
                            cqiReport_p[cqi_count] = (((tmpPMIRI_2)&0x0E) >> 1);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                (newUEContext_p->dlCQIInfo.periodicCQIMode11Abs_p[count].PMI_RI_2 << 7); 
                    }    
                }   
                /* SPR 3924 changes start */
                else if((RI_TYPE_3 == cqiPeriodicReportType) && ((newUEContext_p->transmissionMode == 3) ||
                            (newUEContext_p->transmissionMode == 4) || //SPR 7335 changes
                            /* + SPR 7615 Fix */
                            (newUEContext_p->transmissionMode == 8))) 
                    /* - SPR 7615 Fix */
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    newUEContext_p->dlCQIInfo.ueRIIndexNum = ( (newUEContext_p->dlCQIInfo.ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                        ueProfile[newUEContext_p->dlCQIInfo.ueRIIndexNum];
                    newUEContext_p->dlCQIInfo.ueRIIndexNum++;
                    if ( (newUEContext_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4) )
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex]);
                    }
                    else
                        cqiReport_p[cqi_count] = newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex];
                    {
                        newUEContext_p->dlCQIInfo.RI =  newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex] + 1;           
                    }
                }
                newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
                /* - CQI_5.0 */
            }
            break;

        case CQI_PERIODIC_TYPE_20:
            {
                /* SPR 3924 changes start */
                /* TDD SB_CQI */
                if(SUB_BAND_TYPE_1 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20Abs_p[count].subBandCQI));
                    if(2 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                    {    
                        if(0 == newUEContext_p->dlCQIInfo.bandwidthPartCount)
                        {  
                            if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=110)
                            {
                                cqiReport_p[cqi_count] |= (0 << 4); 
                            }
                            else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 27 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 63)   
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20Abs_p[count].subBandLabel)) << 4);
                            }
                            else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20Abs_p[count].subBandLabel % 3)) << 4);
                            }
                        }
                        /* TDD SB_CQI */
                        else
                        {
                            cqiReport_p[cqi_count] |= 
                                ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20Abs_p[count].subBandLabel)) << 4); 
                        }
                    } 
                    else if(1 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                    {    
                        cqiReport_p[cqi_count] |= 
                            (((newUEContext_p->dlCQIInfo.periodicCQIMode20Abs_p[count].subBandLabel) & 0x01) << 4); 
                    }
                }
                /* SPR 3924 changes start */
                else if ((RI_TYPE_3 == cqiPeriodicReportType) && ((newUEContext_p->transmissionMode == 3 ) ||
                            (newUEContext_p->transmissionMode == 4 ))) //SPR 7335 changes
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    /* SPR 3924 changes end */

                    newUEContext_p->dlCQIInfo.ueRIIndexNum = ( (newUEContext_p->dlCQIInfo.ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                        ueProfile[newUEContext_p->dlCQIInfo.ueRIIndexNum];
                    newUEContext_p->dlCQIInfo.ueRIIndexNum++;
                    if ((newUEContext_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex]);
                    }
                    else 
                        cqiReport_p[cqi_count] = newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex];
                    {
                        newUEContext_p->dlCQIInfo.RI =  newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex] + 1;
                    }    
                    /* - CQI_5.0 */
                } 
                /* SPR 3924 changes start */
                else if (WIDE_BAND_CQI_TYPE_4 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20Abs_p[count].subBandCQI));
                }
            }
            /* + CQI_5.0 */
            newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
            /* - CQI_5.0 */
            break;
        case CQI_PERIODIC_TYPE_21:
            {
                /* SPR 3924 changes start */
                if(SUB_BAND_TYPE_1 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    /*TDD SB_CQI*/
                    if(1 == newUEContext_p->dlCQIInfo.RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandCQI_RI_1));
                        if(2 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                        {
                            if(0 == newUEContext_p->dlCQIInfo.bandwidthPartCount)
                            {   
                                if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 110)
                                {
                                    cqiReport_p[cqi_count] |= (0 << 4);
                                }
                                else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >=27  && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 63)
                                {
                                    cqiReport_p[cqi_count] |=
                                        ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_1)) << 4);

                                }
                                else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                                {
                                    cqiReport_p[cqi_count] |=
                                        ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_1 % 3)) << 4);
                                }
                            }
                            else
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_1)) << 4);
                            }
                        }   
                        else if(1 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                        {    
                            cqiReport_p[cqi_count] |= 
                                (((newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_1) & 0x01) << 4);
                        }   
                    }    
                    else if(1 < newUEContext_p->dlCQIInfo.RI)   
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].spatialDiffCQI_RI_2)) << 4);
                        if(2 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                        {    
                            if(0 == newUEContext_p->dlCQIInfo.bandwidthPartCount)
                            {   
                                if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=110)
                                {
                                    cqiReport_p[cqi_count] |= (0 << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] |= 0;

                                }   
                                else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 27 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=63)
                                {
                                    cqiReport_p[cqi_count] |=
                                        (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] =
                                        (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2)) & 0x02) >> 1);


                                } 
                                else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                                {
                                    cqiReport_p[cqi_count] |=
                                        (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2 % 3)) & 0x01) << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] =
                                        (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2 % 3)) & 0x02) >> 1);
                                }
                            }
                            /*TDD SB_CQI*/
                            else
                            {
                                cqiReport_p[cqi_count] |= 
                                    (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                                cqi_count++;
                                cqiReport_p[cqi_count] = 
                                    (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2)) & 0x02) >> 1);
                            }
                        }  
                        else if(1 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                        {    
                            cqiReport_p[cqi_count] |= 
                                (((newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2) & 0x01) << 7);
                        }   
                    }
                }
                /* SPR 3924 changes start */
                if(WIDE_BAND_CQI_PMI_TYPE_2 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    if(1 == newUEContext_p->dlCQIInfo.RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandCQI_RI_1));
                        /* SPR 8067 Fix Start */
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            cqiReport_p[cqi_count] |=
                                ((FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].PMI_RI_1)) << 4);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].PMI_RI_1)) << 4); 
                        /* SPR 8067 Fix End */
                    }    
                    else if(1 < newUEContext_p->dlCQIInfo.RI)   
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].spatialDiffCQI_RI_2)) << 4);
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            /* 4X4 DL MIMOM CHG START */
                            UInt8 tmpPMIRI_2 = FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2);
                            /* 4X4 DL MIMOM CHG END */
                            cqiReport_p[cqi_count] |= ((tmpPMIRI_2)&0x01 << 7);
                            cqi_count++;
                            cqiReport_p[cqi_count] = ((tmpPMIRI_2&0x0E) >> 1);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21Abs_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                    }    
                }    
                /* SPR 3924 changes start */
                else if ((RI_TYPE_3 == cqiPeriodicReportType) && ((newUEContext_p->transmissionMode == 3) ||
                            (newUEContext_p->transmissionMode == 4 ) ||
                            /* + SPR 7615 Fix */
                            (newUEContext_p->transmissionMode == 8))) //SPR 7335 changes
                    /* - SPR 7615 Fix */
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    newUEContext_p->dlCQIInfo.ueRIIndexNum = ( (newUEContext_p->dlCQIInfo.ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                        ueProfile[newUEContext_p->dlCQIInfo.ueRIIndexNum];
                    newUEContext_p->dlCQIInfo.ueRIIndexNum++;
                    if ((newUEContext_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex]);
                    }
                    else 
                        cqiReport_p[cqi_count] = newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex];
                    {
                        newUEContext_p->dlCQIInfo.RI = newUEContext_p->dlCQIInfo.riValueAbs_p[riIndex] + 1;
                    }    
                }
                newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
                /* - CQI_5.0 */
            }
            break;

        default:
            break;
    }
    *cqiCount = cqi_count;
}
/*EICIC -*/

/* Scell Periodic Cqi Changes Start */
/****************************************************************************
 * Function Name  : preparePcellPeriodicCqiReport
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    : This function prepare Scell Periodic Cqi Report 
 ****************************************************************************/
void preparePcellPeriodicCqiReport(UInt8 cellIndex,UInt8 cqiPeriodicReportType,
        DLUEContext *newUEContext_p, 
        UInt8 *cqiReport_p,
        UInt8 *cqiCount,
        UInt8 sendSF)
{
    UInt8 cqi_count = *cqiCount;
    UInt8 riIndex = 0;
    UInt8 count = 0;
    /*EICIC Enhancement +*/
     UInt32 tracker = 0;
     tracker =  newUEContext_p->dlCQIInfo.indexTrack;
    
    /*EICIC Enhancement -*/
    newUEContext_p->dlCQIInfo.ueCqiIndexNum = ( (newUEContext_p->dlCQIInfo.ueCqiIndexNum) % 
            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
    count = 
        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
        ueProfile[newUEContext_p->dlCQIInfo.ueCqiIndexNum];
   /*EICIC Enhancement +*/
        tracker ++;
        if (0 == (tracker % (cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexTracker)))
         {
            newUEContext_p->dlCQIInfo.ueCqiIndexNum++;
             tracker = 0;
         }
        newUEContext_p->dlCQIInfo.indexTrack = tracker;


    /*EICIC Enhancement -*/

    newUEContext_p->dlCQIInfo.cqiReportType[sendSF] = CQI_INVALID_REPORT_TYPE;
    switch(newUEContext_p->dlCQIInfo.periodicModeType)
    {
        case CQI_PERIODIC_TYPE_10:
            {    
                /* SPR 3924 changes start */
                if((RI_TYPE_3 == cqiPeriodicReportType) && ((newUEContext_p->transmissionMode == 3) ||
                            (newUEContext_p->transmissionMode == 4))) // SPR 7335 changes
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    newUEContext_p->dlCQIInfo.ueRIIndexNum = ( (newUEContext_p->dlCQIInfo.ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                        ueProfile[newUEContext_p->dlCQIInfo.ueRIIndexNum];
                    newUEContext_p->dlCQIInfo.ueRIIndexNum++;
                    if ((newUEContext_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.riValue_p[riIndex]);
                    }
                    else
                        cqiReport_p[cqi_count] = newUEContext_p->dlCQIInfo.riValue_p[riIndex];
                    {
                        newUEContext_p->dlCQIInfo.RI = newUEContext_p->dlCQIInfo.riValue_p[riIndex] + 1;
                        //  fprintf(stderr,"Value of RI10 [%d]\n",newUEContext_p->dlCQIInfo.RI);//SPR 7335 changes
                    }
                    /* - CQI_5.0 */
                }   
                /* SPR 3924 changes start */
                else if(WIDE_BAND_CQI_TYPE_4 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {     
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode10_p[count].wideBandCQI));
                }
                newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
            }
            break;
        case CQI_PERIODIC_TYPE_11:
            {
                /* SPR 3924 changes start */
                if(WIDE_BAND_CQI_PMI_TYPE_2 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    if(1 ==  newUEContext_p->dlCQIInfo.RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11_p[count].wideBandCQI_RI_1));
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            cqiReport_p[cqi_count] |= 
                                ((FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11_p[count].PMI_RI_1)) << 4);
                        }
                        else
                            cqiReport_p[cqi_count] |=
                                ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11_p[count].PMI_RI_1)) << 4); 
                    }    
                    else if(1  <  newUEContext_p->dlCQIInfo.RI)   
                    {
                        UInt8 tmpPMIRI_2 = 0;
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11_p[count].wideBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11_p[count].spatialDiffCQI_RI_2)) << 4); 
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            tmpPMIRI_2 = FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode11_p[count].PMI_RI_2);
                            /* SPR 7415 changes start */
                            cqiReport_p[cqi_count] |= (((tmpPMIRI_2)&0x01) << 7);
                            /* SPR 7415 changes end */
                            cqi_count++;
                            cqiReport_p[cqi_count] = (((tmpPMIRI_2)&0x0E) >> 1);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                (newUEContext_p->dlCQIInfo.periodicCQIMode11_p[count].PMI_RI_2 << 7); 
                    }    
                }   
                /* SPR 3924 changes start */
                else if((RI_TYPE_3 == cqiPeriodicReportType) && ((newUEContext_p->transmissionMode == 3) ||
                            (newUEContext_p->transmissionMode == 4) || //SPR 7335 changes
                            /* + SPR 7615 Fix */
                            (newUEContext_p->transmissionMode == 8))) 
                    /* - SPR 7615 Fix */
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    newUEContext_p->dlCQIInfo.ueRIIndexNum = ( (newUEContext_p->dlCQIInfo.ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                        ueProfile[newUEContext_p->dlCQIInfo.ueRIIndexNum];
                    newUEContext_p->dlCQIInfo.ueRIIndexNum++;
                    if ( (newUEContext_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4) )
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.riValue_p[riIndex]);
                    }
                    else
                        cqiReport_p[cqi_count] = newUEContext_p->dlCQIInfo.riValue_p[riIndex];
                    {
                        newUEContext_p->dlCQIInfo.RI =  newUEContext_p->dlCQIInfo.riValue_p[riIndex] + 1;           
                    }
                }
                newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
                /* - CQI_5.0 */
            }
            break;

        case CQI_PERIODIC_TYPE_20:
            {
                /* SPR 3924 changes start */
                /* TDD SB_CQI */
                if(SUB_BAND_TYPE_1 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20_p[count].subBandCQI));
                    if(2 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                    {    
                        if(0 == newUEContext_p->dlCQIInfo.bandwidthPartCount)
                        {  
                            if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=110)
                            {
                                cqiReport_p[cqi_count] |= (0 << 4); 
                            }
                            else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 27 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 63)   
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20_p[count].subBandLabel)) << 4);
                            }
                            else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20_p[count].subBandLabel % 3)) << 4);
                            }
                        }
                        /* TDD SB_CQI */
                        else
                        {
                            cqiReport_p[cqi_count] |= 
                                ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20_p[count].subBandLabel)) << 4); 
                        }
                    } 
                    else if(1 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                    {    
                        cqiReport_p[cqi_count] |= 
                            (((newUEContext_p->dlCQIInfo.periodicCQIMode20_p[count].subBandLabel) & 0x01) << 4); 
                    }
                }
                /* SPR 3924 changes start */
                else if ((RI_TYPE_3 == cqiPeriodicReportType) && ((newUEContext_p->transmissionMode == 3 ) ||
                            (newUEContext_p->transmissionMode == 4 ))) //SPR 7335 changes
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    /* SPR 3924 changes end */

                    newUEContext_p->dlCQIInfo.ueRIIndexNum = ( (newUEContext_p->dlCQIInfo.ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                        ueProfile[newUEContext_p->dlCQIInfo.ueRIIndexNum];
                    newUEContext_p->dlCQIInfo.ueRIIndexNum++;
                    if ((newUEContext_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.riValue_p[riIndex]);
                    }
                    else 
                        cqiReport_p[cqi_count] = newUEContext_p->dlCQIInfo.riValue_p[riIndex];
                    {
                        newUEContext_p->dlCQIInfo.RI =  newUEContext_p->dlCQIInfo.riValue_p[riIndex] + 1;
                    }    
                    /* - CQI_5.0 */
                } 
                /* SPR 3924 changes start */
                else if (WIDE_BAND_CQI_TYPE_4 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode20_p[count].subBandCQI));
                }
            }
            /* + CQI_5.0 */
            newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
            /* - CQI_5.0 */
            break;
        case CQI_PERIODIC_TYPE_21:
            {
                /* SPR 3924 changes start */
                if(SUB_BAND_TYPE_1 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    /*TDD SB_CQI*/
                    if(1 == newUEContext_p->dlCQIInfo.RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandCQI_RI_1));
                        if(2 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                        {
                            if(0 == newUEContext_p->dlCQIInfo.bandwidthPartCount)
                            {   
                                if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 110)
                                {
                                    cqiReport_p[cqi_count] |= (0 << 4);
                                }
                                else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >=27  && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 63)
                                {
                                    cqiReport_p[cqi_count] |=
                                        ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_1)) << 4);

                                }
                                else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                                {
                                    cqiReport_p[cqi_count] |=
                                        ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_1 % 3)) << 4);
                                }
                            }
                            else
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_1)) << 4);
                            }
                        }   
                        else if(1 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                        {    
                            cqiReport_p[cqi_count] |= 
                                (((newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_1) & 0x01) << 4);
                        }   
                    }    
                    else if(1 < newUEContext_p->dlCQIInfo.RI)   
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].spatialDiffCQI_RI_2)) << 4);
                        if(2 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                        {    
                            if(0 == newUEContext_p->dlCQIInfo.bandwidthPartCount)
                            {   
                                if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=110)
                                {
                                    cqiReport_p[cqi_count] |= (0 << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] |= 0;

                                }   
                                else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 27 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=63)
                                {
                                    cqiReport_p[cqi_count] |=
                                        (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] =
                                        (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x02) >> 1);


                                } 
                                else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                                {
                                    cqiReport_p[cqi_count] |=
                                        (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2 % 3)) & 0x01) << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] =
                                        (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2 % 3)) & 0x02) >> 1);
                                }
                            }
                            /*TDD SB_CQI*/
                            else
                            {
                                cqiReport_p[cqi_count] |= 
                                    (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                                cqi_count++;
                                cqiReport_p[cqi_count] = 
                                    (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x02) >> 1);
                            }
                        }  
                        else if(1 == newUEContext_p->dlCQIInfo.LBitLabelForPeriodic)
                        {    
                            cqiReport_p[cqi_count] |= 
                                (((newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2) & 0x01) << 7);
                        }   
                    }
                }
                /* SPR 3924 changes start */
                if(WIDE_BAND_CQI_PMI_TYPE_2 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    if(1 == newUEContext_p->dlCQIInfo.RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandCQI_RI_1));
                        /* SPR 8067 Fix Start */
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            cqiReport_p[cqi_count] |=
                                ((FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].PMI_RI_1)) << 4);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                ((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].PMI_RI_1)) << 4); 
                        /* SPR 8067 Fix End */
                    }    
                    else if(1 < newUEContext_p->dlCQIInfo.RI)   
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].spatialDiffCQI_RI_2)) << 4);
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            /* 4X4 DL MIMOM CHG START */
                            UInt8 tmpPMIRI_2 = FOUR_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2);
                            /* 4X4 DL MIMOM CHG END */
                            cqiReport_p[cqi_count] |= ((tmpPMIRI_2)&0x01 << 7);
                            cqi_count++;
                            cqiReport_p[cqi_count] = ((tmpPMIRI_2&0x0E) >> 1);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                (((TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                    }    
                }    
                /* SPR 3924 changes start */
                else if ((RI_TYPE_3 == cqiPeriodicReportType) && ((newUEContext_p->transmissionMode == 3) ||
                            (newUEContext_p->transmissionMode == 4 ) ||
                            /* + SPR 7615 Fix */
                            (newUEContext_p->transmissionMode == 8))) //SPR 7335 changes
                    /* - SPR 7615 Fix */
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    newUEContext_p->dlCQIInfo.ueRIIndexNum = ( (newUEContext_p->dlCQIInfo.ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[newUEContext_p->dlCQIInfo.ueCqiProfileNum].
                        ueProfile[newUEContext_p->dlCQIInfo.ueRIIndexNum];
                    newUEContext_p->dlCQIInfo.ueRIIndexNum++;
                    if ((newUEContext_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(newUEContext_p->dlCQIInfo.riValue_p[riIndex]);
                    }
                    else 
                        cqiReport_p[cqi_count] = newUEContext_p->dlCQIInfo.riValue_p[riIndex];
                    {
                        newUEContext_p->dlCQIInfo.RI = newUEContext_p->dlCQIInfo.riValue_p[riIndex] + 1;
                    }    
                }
                newUEContext_p->dlCQIInfo.periodicRIAtULSCH = FALSE;
                /* - CQI_5.0 */
            }
            break;

        default:
            break;
    }
    *cqiCount = cqi_count;
}

/****************************************************************************
 * Function Name  : prepareScellPeriodicCqiReport
 * Inputs         :
 * Outputs        :
 * Returns        :
 * Description    : This function prepare Scell Periodic Cqi Report 
 ****************************************************************************/

void prepareScellPeriodicCqiReport(UInt8 cellIndex, UInt8 cqiPeriodicReportType,
        ueContextForUplink  *ulUEInfo_p,
        UInt8 *cqiReport_p,
        UInt8 *cqiCount,
        UInt8 sendSF
        )
{
    UInt8 cqi_count = *cqiCount;
    UInt8 count = 0;
    DLCQIInfo *scellUlCQIInfo = PNULL;
    ScellInfo *scellInfo_p = PNULL;
    UInt8 scellCount = 0;
    UInt8 riIndex = 0;
    /*EICIC Enhancement +*/
    UInt32 tracker = 0;
    /*EICIC Enhancement -*/
    scellCount = ulUEInfo_p->carrierAggrConfig.scellCount - 1;
    scellInfo_p = &(ulUEInfo_p->carrierAggrConfig.scellInfo[scellCount]);
    scellUlCQIInfo = &(ulUEInfo_p->carrierAggrConfig.scellInfo[scellCount].dlCQIInfo);
    tracker =  scellUlCQIInfo->indexTrack;
    /* SPR 12465 Fix  */
    scellUlCQIInfo->ueCqiIndexNum = ( (scellUlCQIInfo->ueCqiIndexNum) %
            ((cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].indexCount + 1)) );
    count = 
        cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].
        ueProfile[scellUlCQIInfo->ueCqiIndexNum];
    /*EICIC Enhancement +*/
       tracker ++;
        if (0 == (tracker % (cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].indexTracker)))
         {
            scellUlCQIInfo->ueCqiIndexNum++;
            tracker = 0;
        }
       scellUlCQIInfo->indexTrack = tracker;
   /*EICIC Enhancement -*/
     /* SPR 12465 FIX start */
    //scellUlCQIInfo->ueCqiIndexNum++;
     /* SPR 12465 FIX end */
    scellUlCQIInfo->cqiReportType[sendSF] = CQI_INVALID_REPORT_TYPE;
    switch(scellUlCQIInfo->periodicModeType)
    {
        case CQI_PERIODIC_TYPE_10:
            {    
                /* SPR 3924 changes start */
                if((RI_TYPE_3 == cqiPeriodicReportType) && ((scellInfo_p->transmissionMode == 3) ||
                            (scellInfo_p->transmissionMode == 4))) // SPR 7335 changes
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    scellUlCQIInfo->ueRIIndexNum = ( (scellUlCQIInfo->ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].
                        ueProfile[scellUlCQIInfo->ueRIIndexNum];
                    scellUlCQIInfo->ueRIIndexNum++;
                    if ((ulUEInfo_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(scellUlCQIInfo->riValue_p[riIndex]);
                    }
                    else
                        cqiReport_p[cqi_count] = scellUlCQIInfo->riValue_p[riIndex];
                    {
                        scellUlCQIInfo->RI = scellUlCQIInfo->riValue_p[riIndex] + 1;
                        //  fprintf(stderr,"Value of RI10 [%d]\n",newUEContext_p->dlCQIInfo.RI);//SPR 7335 changes
                    }
                    /* - CQI_5.0 */
                }   
                /* SPR 3924 changes start */
                else if(WIDE_BAND_CQI_TYPE_4 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {     
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode10_p[count].wideBandCQI));
                }
                scellUlCQIInfo->periodicRIAtULSCH = FALSE;
            }
            break;
        case CQI_PERIODIC_TYPE_11:
            {
                /* SPR 3924 changes start */
                if(WIDE_BAND_CQI_PMI_TYPE_2 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    if(1 ==  scellUlCQIInfo->RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode11_p[count].wideBandCQI_RI_1));
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            cqiReport_p[cqi_count] |= 
                                ((FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode11_p[count].PMI_RI_1)) << 4);
                        }
                        else
                            cqiReport_p[cqi_count] |=
                                ((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode11_p[count].PMI_RI_1)) << 4); 
                    }    
                    else if(1  <  scellUlCQIInfo->RI)   
                    {
                        UInt8 tmpPMIRI_2 = 0;
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode11_p[count].wideBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode11_p[count].spatialDiffCQI_RI_2)) << 4); 
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            tmpPMIRI_2 = FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode11_p[count].PMI_RI_2);
                            /* SPR 7415 changes start */
                            cqiReport_p[cqi_count] |= (((tmpPMIRI_2)&0x01) << 7);
                            /* SPR 7415 changes end */
                            cqi_count++;
                            cqiReport_p[cqi_count] = (((tmpPMIRI_2)&0x0E) >> 1);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                (scellUlCQIInfo->periodicCQIMode11_p[count].PMI_RI_2 << 7); 
                    }    
                }   
                /* SPR 3924 changes start */
                else if((RI_TYPE_3 == cqiPeriodicReportType) && ((scellInfo_p->transmissionMode == 3) ||
                            (scellInfo_p->transmissionMode == 4) || //SPR 7335 changes
                            /* + SPR 7615 Fix */
                            (scellInfo_p->transmissionMode == 8))) 
                    /* - SPR 7615 Fix */
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    scellUlCQIInfo->ueRIIndexNum = ( (scellUlCQIInfo->ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].
                        ueProfile[scellUlCQIInfo->ueRIIndexNum];
                    scellUlCQIInfo->ueRIIndexNum++;
                    if ( (ulUEInfo_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4) )
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(scellUlCQIInfo->riValue_p[riIndex]);
                    }
                    else
                        cqiReport_p[cqi_count] = scellUlCQIInfo->riValue_p[riIndex];
                    {
                        scellUlCQIInfo->RI =  scellUlCQIInfo->riValue_p[riIndex] + 1;           
                    }
                }
                scellUlCQIInfo->periodicRIAtULSCH = FALSE;
                /* - CQI_5.0 */
            }
            break;

        case CQI_PERIODIC_TYPE_20:
            {
                /* SPR 3924 changes start */
                /* TDD SB_CQI */
                if(SUB_BAND_TYPE_1 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode20_p[count].subBandCQI));
                    if(2 == scellUlCQIInfo->LBitLabelForPeriodic)
                    {    
                        if(0 == scellUlCQIInfo->bandwidthPartCount)
                        {  
                            if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=110)
                            {
                                cqiReport_p[cqi_count] |= (0 << 4); 
                            }
                            else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 27 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 63)   
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode20_p[count].subBandLabel)) << 4);
                            }
                            else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode20_p[count].subBandLabel % 3)) << 4);
                            }
                        }
                        /* TDD SB_CQI */
                        else
                        {
                            cqiReport_p[cqi_count] |= 
                                ((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode20_p[count].subBandLabel)) << 4); 
                        }
                    } 
                    else if(1 == scellUlCQIInfo->LBitLabelForPeriodic)
                    {    
                        cqiReport_p[cqi_count] |= 
                            (((scellUlCQIInfo->periodicCQIMode20_p[count].subBandLabel) & 0x01) << 4); 
                    }
                }
                /* SPR 3924 changes start */
                else if ((RI_TYPE_3 == cqiPeriodicReportType) && ((scellInfo_p->transmissionMode == 3 ) ||
                            (scellInfo_p->transmissionMode == 4 ))) //SPR 7335 changes
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    /* SPR 3924 changes end */

                    scellUlCQIInfo->ueRIIndexNum = ( (scellUlCQIInfo->ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].
                        ueProfile[scellUlCQIInfo->ueRIIndexNum];
                    scellUlCQIInfo->ueRIIndexNum++;
                    if ((ulUEInfo_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(scellUlCQIInfo->riValue_p[riIndex]);
                    }
                    else 
                        cqiReport_p[cqi_count] = scellUlCQIInfo->riValue_p[riIndex];
                    {
                        scellUlCQIInfo->RI =  scellUlCQIInfo->riValue_p[riIndex] + 1;
                    }    
                    /* - CQI_5.0 */
                } 
                /* SPR 3924 changes start */
                else if (WIDE_BAND_CQI_TYPE_4 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    cqiReport_p[cqi_count] = 
                        (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode20_p[count].subBandCQI));
                }
            }
            /* + CQI_5.0 */
            scellUlCQIInfo->periodicRIAtULSCH = FALSE;
            /* - CQI_5.0 */
            break;
        case CQI_PERIODIC_TYPE_21:
            {
                /* SPR 3924 changes start */
                if(SUB_BAND_TYPE_1 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    /*TDD SB_CQI*/
                    if(1 == scellUlCQIInfo->RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandCQI_RI_1));
                        if(2 == scellUlCQIInfo->LBitLabelForPeriodic)
                        {
                            if(0 == scellUlCQIInfo->bandwidthPartCount)
                            {   
                                if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 110)
                                {
                                    cqiReport_p[cqi_count] |= (0 << 4);
                                }
                                else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >=27  && cellConfigUeSim_g[cellIndex].dlAvailableRBs <= 63)
                                {
                                    cqiReport_p[cqi_count] |=
                                        ((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_1)) << 4);

                                }
                                else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                                {
                                    cqiReport_p[cqi_count] |=
                                        ((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_1 % 3)) << 4);
                                }
                            }
                            else
                            {
                                cqiReport_p[cqi_count] |=
                                    ((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_1)) << 4);
                            }
                        }   
                        else if(1 == scellUlCQIInfo->LBitLabelForPeriodic)
                        {    
                            cqiReport_p[cqi_count] |= 
                                (((scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_1) & 0x01) << 4);
                        }   
                    }    
                    else if(1 < scellUlCQIInfo->RI)   
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].spatialDiffCQI_RI_2)) << 4);
                        if(2 == scellUlCQIInfo->LBitLabelForPeriodic)
                        {    
                            if(0 == scellUlCQIInfo->bandwidthPartCount)
                            {   
                                if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 64 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=110)
                                {
                                    cqiReport_p[cqi_count] |= (0 << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] |= 0;

                                }   
                                else if(cellConfigUeSim_g[cellIndex].dlAvailableRBs >= 27 && cellConfigUeSim_g[cellIndex].dlAvailableRBs <=63)
                                {
                                    cqiReport_p[cqi_count] |=
                                        (((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] =
                                        (((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x02) >> 1);


                                } 
                                else if(25 == cellConfigUeSim_g[cellIndex].dlAvailableRBs)
                                {
                                    cqiReport_p[cqi_count] |=
                                        (((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2 % 3)) & 0x01) << 7);
                                    cqi_count++;
                                    cqiReport_p[cqi_count] =
                                        (((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2 % 3)) & 0x02) >> 1);
                                }
                            }
                            /*TDD SB_CQI*/
                            else
                            {
                                cqiReport_p[cqi_count] |= 
                                    (((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                                cqi_count++;
                                cqiReport_p[cqi_count] = 
                                    (((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x02) >> 1);
                            }
                        }  
                        else if(1 == scellUlCQIInfo->LBitLabelForPeriodic)
                        {    
                            cqiReport_p[cqi_count] |= 
                                (((scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2) & 0x01) << 7);
                        }   
                    }
                }
                /* SPR 3924 changes start */
                if(WIDE_BAND_CQI_PMI_TYPE_2 == cqiPeriodicReportType)
                    /* SPR 3924 changes end */
                {
                    if(1 == scellUlCQIInfo->RI)
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandCQI_RI_1));
                        /* SPR 8067 Fix Start */
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            cqiReport_p[cqi_count] |=
                                ((FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].PMI_RI_1)) << 4);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                ((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].PMI_RI_1)) << 4); 
                        /* SPR 8067 Fix End */
                    }    
                    else if(1 < scellUlCQIInfo->RI)   
                    {
                        cqiReport_p[cqi_count] = 
                            (FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandCQI_RI_2));
                        cqiReport_p[cqi_count] |= 
                            ((THREE_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].spatialDiffCQI_RI_2)) << 4);
                        if (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4)
                        {
                            /* 4X4 DL MIMOM CHG START */
                            UInt8 tmpPMIRI_2 = FOUR_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2);
                            /* 4X4 DL MIMOM CHG END */
                            cqiReport_p[cqi_count] |= ((tmpPMIRI_2)&0x01 << 7);
                            cqi_count++;
                            cqiReport_p[cqi_count] = ((tmpPMIRI_2&0x0E) >> 1);
                        }
                        else
                            cqiReport_p[cqi_count] |= 
                                (((TWO_BIT_ROTATION(scellUlCQIInfo->periodicCQIMode21_p[count].subBandLabel_RI_2)) & 0x01) << 7);
                    }    
                }    
                /* SPR 3924 changes start */
                else if ((RI_TYPE_3 == cqiPeriodicReportType) && ((scellInfo_p->transmissionMode == 3) ||
                            (scellInfo_p->transmissionMode == 4 ) ||
                            /* + SPR 7615 Fix */
                            (scellInfo_p->transmissionMode == 8))) //SPR 7335 changes
                    /* - SPR 7615 Fix */
                    /* SPR 3924 changes end */
                {
                    /* + CQI_5.0 */
                    scellUlCQIInfo->ueRIIndexNum = ( (scellUlCQIInfo->ueRIIndexNum ) %
                            ((cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].indexCount + 1)) );
                    riIndex =
                        cqiUEProfileValues_g[scellUlCQIInfo->ueCqiProfileNum].
                        ueProfile[scellUlCQIInfo->ueRIIndexNum];
                    scellUlCQIInfo->ueRIIndexNum++;
                    if ((ulUEInfo_p->ueCategory == 5) &&
                            (cellConfigUeSim_g[cellIndex].numOfTxAnteenas == 4))
                    {
                        cqiReport_p[cqi_count] = TWO_BIT_ROTATION(scellUlCQIInfo->riValue_p[riIndex]);
                    }
                    else 
                        cqiReport_p[cqi_count] = scellUlCQIInfo->riValue_p[riIndex];
                    {
                        scellUlCQIInfo->RI = scellUlCQIInfo->riValue_p[riIndex] + 1;
                    }    
                }
                scellUlCQIInfo->periodicRIAtULSCH = FALSE;
                /* - CQI_5.0 */
            }
            break;

        default:
            break;
    }

    *cqiCount = cqi_count;

}
/* Scell Periodic Cqi Changes End */

/* Phase 2 Periodic CQi Changes End*/

void fillRIInfoAperiodic(DLCQIInfo *dlCQIInfo_p,  
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
FAPI_cqiPduIndicationR9_st *cqiPdu_p,
#else
FAPI_cqiPduIndication_st *cqiPdu_p,
#endif
        UInt16 numOfCqi,TransmissonMode transmissionMode, UInt8 index,
         DLUEContext *newUEContext_p,UInt8  sendSF)
{
    //cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported = 0;
    UInt8 riIndex = 0;
    if( ((3 == transmissionMode) || (4 == transmissionMode) ||
                /* + TM7_8 Chnages Start */
                ((8 == transmissionMode) && (TRUE == newUEContext_p->isPmiRiConfigured_V920))) 
            /* - TM7_8 Chnages End */

            &&(
                (TRUE == newUEContext_p->dlCQIInfo.isULSCHPDUType[sendSF]) &&
                (ULSCH_APERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF]) 
              )
      )
    {
        dlCQIInfo_p->ueRIIndexNum = ( (dlCQIInfo_p->ueRIIndexNum ) %
                ((cqiUEProfileValues_g[dlCQIInfo_p->ueCqiProfileNum].indexCount + 1)) );
        riIndex =
            cqiUEProfileValues_g[dlCQIInfo_p->ueCqiProfileNum].
            ueProfile[dlCQIInfo_p->ueRIIndexNum];
#ifdef FAPI_4_0_COMPLIANCE
#if defined(FAPI_RELEASE9) ||defined(FAPI_RELEASE10) 
        /*TODO*/
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri[index] = dlCQIInfo_p->riValue_p[riIndex] + 1;
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported++;
#else

        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri = dlCQIInfo_p->riValue_p[riIndex] + 1;
#endif
#else
        cqiPdu_p[ numOfCqi - 1].ri = dlCQIInfo_p->riValue_p[riIndex] + 1;
#endif
        if (ULSCH_APERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF])
        {
            dlCQIInfo_p->ueRIIndexNum++;
            dlCQIInfo_p->RI = dlCQIInfo_p->riValue_p[riIndex] + 1;
        } 
    }
    /* + TM6_5.2 */
    else if((6 == transmissionMode) &&
            (ULSCH_APERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF]))
    {

#if defined(FAPI_4_0_COMPLIANCE)
#if defined(FAPI_RELEASE9) ||defined(FAPI_RELEASE10) 
        /*TODO*/
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri[index] = 1;
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported++;
#else
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri = 1;
#endif
#else
        cqiPdu_p[ numOfCqi - 1].ri = 1;
#endif
    }
    /* - TM6_5.2 */
    else
    {

#if defined(FAPI_4_0_COMPLIANCE)
#if defined(FAPI_RELEASE9)||defined(FAPI_RELEASE10) 
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri[index] = 0;

#else

        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri = 0;
#endif
#else

        cqiPdu_p[ numOfCqi - 1].ri = 0;
#endif
    }
}

/* EICIC +*/
void fillRIInfoAperiodic_ABS(DLCQIInfo *dlCQIInfo_p,  
#if  defined(FAPI_4_0_COMPLIANCE) && (defined(FAPI_RELEASE10)|| defined(FAPI_RELEASE9))
FAPI_cqiPduIndicationR9_st *cqiPdu_p,
#else
FAPI_cqiPduIndication_st *cqiPdu_p,
#endif
        UInt16 numOfCqi,TransmissonMode transmissionMode, UInt8 index,
         DLUEContext *newUEContext_p,UInt8  sendSF)
{
    //cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported = 0;
    UInt8 riIndex = 0;
    if( ((3 == transmissionMode) || (4 == transmissionMode) ||
                /* + TM7_8 Chnages Start */
                ((8 == transmissionMode) && (TRUE == newUEContext_p->isPmiRiConfigured_V920))) 
            /* - TM7_8 Chnages End */

            &&(
                (TRUE == newUEContext_p->dlCQIInfo.isULSCHPDUType[sendSF]) &&
                (ULSCH_APERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF]) 
              )
      )
    {
        dlCQIInfo_p->ueRIIndexNum = ( (dlCQIInfo_p->ueRIIndexNum ) %
                ((cqiUEProfileValues_g[dlCQIInfo_p->ueCqiProfileNum].indexCount + 1)) );
        riIndex =
            cqiUEProfileValues_g[dlCQIInfo_p->ueCqiProfileNum].
            ueProfile[dlCQIInfo_p->ueRIIndexNum];
#ifdef FAPI_4_0_COMPLIANCE
#if defined(FAPI_RELEASE9) ||defined(FAPI_RELEASE10) 
        /*TODO*/
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri[index] = dlCQIInfo_p->riValueAbs_p[riIndex] + 1;
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported++;
#else

        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri = dlCQIInfo_p->riValueAbs_p[riIndex] + 1;
#endif
#else
        cqiPdu_p[ numOfCqi - 1].ri = dlCQIInfo_p->riValueAbs_p[riIndex] + 1;
#endif
        if (ULSCH_APERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF])
        {
            dlCQIInfo_p->ueRIIndexNum++;
            dlCQIInfo_p->RI = dlCQIInfo_p->riValueAbs_p[riIndex] + 1;
        } 
    }
    /* + TM6_5.2 */
    else if((6 == transmissionMode) &&
            (ULSCH_APERIODIC_REPORT_TYPE == newUEContext_p->dlCQIInfo.cqiReportType[sendSF]))
    {

#if defined(FAPI_4_0_COMPLIANCE)
#if defined(FAPI_RELEASE9) ||defined(FAPI_RELEASE10) 
        /*TODO*/
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri[index] = 1;
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.numberOfCCReported++;
#else
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri = 1;
#endif
#else
        cqiPdu_p[ numOfCqi - 1].ri = 1;
#endif
    }
    /* - TM6_5.2 */
    else
    {

#if defined(FAPI_4_0_COMPLIANCE)
#if defined(FAPI_RELEASE9)||defined(FAPI_RELEASE10) 
        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri[index] = 0;

#else

        cqiPdu_p[ numOfCqi - 1].cqiRiInformation.ri = 0;
#endif
#else

        cqiPdu_p[ numOfCqi - 1].ri = 0;
#endif
    }
}
/* EICIC -*/
/* SPR 21958 PUSCH RAT1 Support Start */
#ifdef FDD_CONFIG
/*************************************************************************************
 * Function Name      : calcBinomialCoef
 * Inputs             : tempVar1-variable 1
 *                    : tempVar2-variable 2
 * Outputs            : Binomial coefficient
 * Returns            : Binomial coefficient of two variables
 * Description        : Calculates binomial coefficient of two variable
 ****************************************************************************************/
UInt16 calcBinomialCoef(UInt8 tempVar1,UInt8 tempVar2)
{
	UInt16 binoCoeff = 1;
	UInt8  loopCounter = 0;
	UInt8  min = 0;
	if((tempVar2>tempVar1))
	{
		return 0;
	}
	else if((0==tempVar2)||(tempVar2==tempVar1))
	{
		return 1;
	}
	else
	{
		if(tempVar1<=tempVar2)
			min = tempVar1;
		else
			min = tempVar2;

		for(loopCounter=0;loopCounter<min;loopCounter++)
		{
			binoCoeff = (binoCoeff*(tempVar1-loopCounter))/(loopCounter+1);

		}
		return binoCoeff;
	}
}
#endif
/* SPR 21958 PUSCH RAT1 Support End */
