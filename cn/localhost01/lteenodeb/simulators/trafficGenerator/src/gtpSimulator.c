
/* gtpusimulator.c source file for DL TG*/
#ifndef LAYER2_DLTG_THREAD
#define _GNU_SOURCE
#endif
#include <sched.h>
#include <sys/types.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <time.h>
#include <assert.h>
#include <pthread.h>
#include <math.h>
#include <string.h>
#include <malloc.h>
#include <errno.h>
/* SPR 20526 Changes Start*/
#include "lteTypes.h"
/* SPR 20526 Changes End*/
#ifdef LAYER2_DLTG_THREAD
#include "lteMemPool.h"
#endif

/* DEEPAK -- For adding colours to the console output*/
#include <stdarg.h>
#define CLR_BLACK   0
#define CLR_RED     1
#define CLR_GREEN   2
#define CLR_YELLOW  3
#define CLR_BLUE    4
#define CLR_MAGENTA 5
#define CLR_CYAN    6
#define CLR_WHITE   7

#define ATTR_NONE       0
#define ATTR_BOLD       1
#define ATTR_DIM        2
#define ATTR_UNDERLINE  4
#define ATTR_BLINK      5
#define ATTR_REVERSE    7

#ifdef TG_REAL_EPC
#define memCpy memcpy
#define memSet memset
#endif
/*CA changes start*/
/*SPR 21653 changes start*/
#define INTERFACE_API_HEADER_LEN    16
/*SPR 21653 changes end*/
#define API_HEADER_CELL_INDEX_OFFSET 10
/*CA changes end*/

void cprint_init(int fg, int attr, int bg)
{
    if(bg != -1){
        printf("%c[%d;%d;%dm",27,attr,(30+fg),(40+bg));
    }
    else{
        printf("%c[%d;%dm",27,attr,(30+fg));
    }
}
void cprint_rst(void)
{
    printf("%c[%dm", 27, 0);
}
    
/*COVERITY FIX-23205 START*/
void cprintf(int fg, int a, int bg, char * fmt, ...)
/*COVERITY FIX-23205 END*/
{
    va_list args;
    va_start(args, fmt);

    cprint_init(fg,a,bg);
    vprintf(fmt, args);
    cprint_rst();

    va_end(args);
}
/********************COLOUR CODING ENDS**********************************/
#define SEQ_MISMATCH_VALIDATION
#ifndef LAYER2_DLTG_THREAD
/* SPR 20526 Changes Start*/
/*Code Removed*/
/* SPR 20526 Changes End*/
#endif

#define TRUE 1
#define FALSE 0
#define MAX_PROF 5
/* Sweta Changes Start */
/** MBMS Changes Start */
#ifndef LAYER2_DLTG_THREAD
#ifdef MULTISECTOR_ENABLE
#define MAX_NUM_CELLS_TG 8
#else
#define MAX_NUM_CELLS_TG 1
#endif
SInt8 		   sockRxTGFd = -1;
struct sockaddr_in 	   sockAddr_sync;

/*MAXIMUM SYNC Period value*/
#define MAX_SYNC_PERIOD_VAL 59999
typedef struct tgSfnCellIndex_stT
{
    /* A 16-bit value SFN, range 0 . 1023 */
    UInt16   sfn;
    UInt16   cellIndex;
    UInt32   currentTti; 
}tgSfnCellIndex_st;
#define                TGIP         "1.1.1.1"
#define                TGPORT       10061

tgSfnCellIndex_st tgSfnCellIndexVal_g;
UInt8	isCellStopOccurred_g = FALSE;
UInt32 syncPeriod_g = 0;

UInt32 getSFN()
{
   return (tgSfnCellIndexVal_g.sfn);
}
UInt32 getPlatformTti()
{
   return (tgSfnCellIndexVal_g.currentTti / 10 ) % syncPeriod_g;
}
/*SPR 18697 fix end*/ 
#define LTE_EMBMS_GET_U32BIT(p_buff)                                        \
    ((UInt32)(*(p_buff) << 24) |                                       \
     (UInt32)(*(p_buff + 1) << 16) |                                \
     (UInt32)(*(p_buff + 2) << 8) |                                 \
     (UInt32)(*(p_buff + 3)))
#endif
/** MBMS Changes End */
/* Sweta Changes End */


/*Sampling Data Structures*/

/*Sampling Data Structures*/
/* SPR 13326 Changes Start */
/*SPR 21653 changes Start */
/* SPR 13326 Changes End */
#define MAX_SECTORS	1
/*SPR 21836 Changes Start*/
/*Code Removed*/
/*SPR 21836 Changes End*/
/*SPR 21727 changes start*/
#ifdef PDCP_GTPU_INTF
#define MAX_INSTANCE 3
#endif
/*SPR 21727 changes end*/
/*SPR 21653 changes end */
/* 128 UE changes start */
/* SPR 20526 Fix Start */
#define MAX_MULTI_UE  MAX_UE_SUPPORTED
/* SPR 20526 Fix End */
/* 128 UE changes end */
#define MAX_LC_ID 8 
#define TIME_TO_BURST_IN_SECONDS 30
#define BURST_FLAG 1

#define MSG_POOL_HIGH_WATERMARK 70
#define MSG_POOL_LOW_WATERMARK 60
#define MEM_POOL_HIGH_WATERMARK 70
#define MEM_POOL_LOW_WATERMARK 60

// RoHC test enhancements
#define TS_PERIOD 20
/* Number of different packet sizes that can be used in single traffic 
 * profile seperated by comas */
#define MAX_PACKET_TYPE 3
#define LTE_IP_UDP_PROTO 0x11
#define LTE_IP_TCP_PROTO 0x06
#define COUNTDOWN 1000
#define DSCP_COUNT 53
#define PUSH_COUNT 101
#define URGENT_COUNT 211
#define ACK_COUNT 307
#define ECN_COUNT 401
typedef struct
{
    UDouble64 	txData;  	/* Transmitted data*/
    UDouble64 	rxData;  	/* Received Data*/
    UInt32 	rxPkts;  	/* Received Pkts*/
    UInt64 	txPkts;  	/* Transmitted Pkts*/
    UInt64 	txOldPkt;	/* old tx Pkts till */
    UInt32 	rxOldPkt;	/* old rx pkts till */
    UInt32 	rxMiss;  	/* Missed Packets*/
    UInt32 	rxMiss_per_display;  /* Missed Packets Per Display*/
    UInt32 	txSeq;   	/* Transmission Sequence*/
    UInt32 	rxSeq;   	/* Reception Sequence*/
}t_ueStats;

/*Sampling Database*/
/* Compilation 12-Jun-2014 Fix start */
t_ueStats 	ueDataFlow_g[MAX_MULTI_UE][MAX_LC_ID]={{{0}}};
/* Compilation 12-Jun-2014 Fix end */
/* + SPR 8669 Fix*/
/*SPR 21836 Changes Start*/
UInt32          totalLcCount_g = 0; 
/*SPR 21836 Changes End*/
/* + SPR 8669 Fix*/
/* Compilation 12-Jun-2014 Fix start */
/*SPR 21836 Changes Start*/
UInt32 	firstBlockReceived_dltg[MAX_MULTI_UE][MAX_LC_ID] = {{0}};
/*SPR 21836 Changes End*/
/* Compilation 12-Jun-2014 Fix end */
/*Scheduled UE*/
UInt32    	tId_gp       = 0;/* Temp for Tunnel Access*/
FILE      	*MissCntrs_g = NULL;
#ifdef LAYER2_DLTG_THREAD
void initBufferForDlQue(UInt8 * sendBuffer, UInt32 packetSize);
extern UInt16           ueStart_g;
extern UInt16          lcId_g;
extern UInt16          ueTurn_g;
#else
#ifndef PDCP_GTPU_INTF
UInt16    	ueTurn_g     = 0;
UInt16    	lcId_g 	     = 0;
#endif
UInt16    	ueStart_g    = 0;
UInt16 ext_hdr_noti_g    = 0;/* SPR 18822 Fix*/
/* tg-change --- declare and define variable for
                 11th command line argument */ 
#ifdef LTE_EMBMS_SUPPORTED
UInt8    	uniMultiCastData_g = 0;
#else
UInt8       uniMultiCastData_g = 1;
#endif
#endif
/* tg-change --- macro declaration and expansion */
#define UNICAST_DATA    1
#define MULTICAST_DATA  2
/*SPR 21727 changes start*/
UInt8 dataParse_g =0;
UInt8 dataDispatch_g =0;
#ifdef PDCP_GTPU_INTF
UInt8 instThread_g[3]={0,1,2};
UInt8 num_instance = 0; /*number of L2 instance running*/
UInt8 instance_id[MAX_INSTANCE] = {0}; 
UInt16 start_ue_id[MAX_INSTANCE] = {0}; /*start-ue id*/
UInt16 num_of_data_ue[MAX_INSTANCE] = {0}; /*total number of ue with data*/
UInt16 total_ue[MAX_INSTANCE] = {0}; 
UInt16 data_to_pump[MAX_INSTANCE] = {0}; /*data pump on which cell 1-First Cell, 2-Second Cell, 3- Both*/
UInt8 instance_ctr = 0;
UInt8 sector_counter = 0;
#endif
#ifdef ENDC_ENABLED
UInt8 bearType[MAX_UE_SUPPORTED][MAX_LC_ID] = {0};
typedef struct 
{
	UInt8  snSize;
	UInt8  containerLen;
	UInt8  dataOffset;
	UInt32 nrPdcpSn;
	UInt32 nrX2Sn;

}NrPdcpInfo;
NrPdcpInfo nrPdcpInfo[MAX_UE_SUPPORTED][MAX_LC_ID]; 
typedef enum bearType_enT
{
    NORMAL_BEARER,
    DL_FORWARDING, 
    UL_FORWARDING,
	SCG_SPLIT_BEARER,
	INVALID_BEARER

}bearType_en;

#endif
/*SPR 21727 changes end*/
/* SPR 18822 Fix Start*/
UInt64 invalid_teid_count = 0;
/* SPR 18822 Fix End*/
/*RX_Throughput Calculation*/
                    /* SPR 20441 Changes Start*/
/*SPR 21836 Changes Start*/
#define CALC_LOAD_RX(a,x,y)    sectorDb_g.ueDataFlow_g[x][y].rxData *=1000;\
                    /* SPR 20441 Changes End*/\
sectorDb_g.ueDataFlow_g[x][y].rxData *=8;\
sectorDb_g.ueDataFlow_g[x][y].rxData /= diff
/*TX Throughput Calculation*/
                    /* SPR 20441 Changes Start*/
#define CALC_LOAD_TX(a,x,y)    sectorDb_g.ueDataFlow_g[x][y].txData *=1000;\
                    /* SPR 20441 Changes End*/\
sectorDb_g.ueDataFlow_g[x][y].txData *=8;\
sectorDb_g.ueDataFlow_g[x][y].txData /= diff
/*SPR 2987 Fix*/
#define CALC_ERROR_RATE(a,x,y)  (sectorDb_g.ueDataFlow_g[x][y].rxPkts)?(((UDouble32) sectorDb_g.ueDataFlow_g[x][y].rxMiss) / (UDouble32)(sectorDb_g.ueDataFlow_g[x][y].rxPkts + sectorDb_g.ueDataFlow_g[x][y].rxMiss))*100.0000f:0.00f
/*SPR 2987 Fix*/
#define CALC_ERROR_RATE_PER_DISPLAY(a,x,y)  (sectorDb_g.ueDataFlow_g[x][y].rxPkts-sectorDb_g.ueDataFlow_g[x][y].rxOldPkt)?(((UDouble32)sectorDb_g.ueDataFlow_g[x][y].rxMiss_per_display) / (UDouble32)(sectorDb_g.ueDataFlow_g[x][y].rxPkts-sectorDb_g.ueDataFlow_g[x][y].rxOldPkt+sectorDb_g.ueDataFlow_g[x][y].rxMiss_per_display)) *100.0000f:0.00f

/* Printing of Throughput and relative Params*/
#ifdef TG_REAL_EPC
#define MbPS_LOAD(a,x,y)  if( x%2 == 0)\
{\
    cprintf(CLR_MAGENTA,ATTR_UNDERLINE,-1,"SEC-ID: %d UEID: %02x LC-ID %d\n",a,x,y);\
    printf ("%c[%dm", 27, 0);\
}\
else \
{\
    cprintf(CLR_BLUE,ATTR_UNDERLINE,-1,"SEC-ID: %d UEID: %02x LC-ID %d\n",a,x,y);\
    printf ("%c[%dm", 27, 0);\
}\
CALC_LOAD_TX(a,x,y);\
printf("TX: ThrPut: %.3f  NoOfLostTicks:%3d  LostTime:%9ld[ns]   PktsSinceLastDisp: %4ld  |  TotalPkts:%5ld \n",sectorDb_g.ueDataFlow_g[x][y].txData,missTickCount_g,missTimeCount_g,sectorDb_g.ueDataFlow_g[x][y].txPkts-sectorDb_g.ueDataFlow_g[x][y].txOldPkt,sectorDb_g.ueDataFlow_g[x][y].txPkts);\
sectorDb_g.ueDataFlow_g[x][y].txData = 0;\
missTickCount_g = 0; missTimeCount_g =0;\
sectorDb_g.ueDataFlow_g[x][y].txOldPkt = sectorDb_g.ueDataFlow_g[x][y].txPkts;
#else
#define MbPS_LOAD(a,x,y)  if( x%2 == 0)\
{\
    cprintf(CLR_MAGENTA,ATTR_UNDERLINE,-1,"SEC-ID: %d UEID: %02x LC-ID %d\n",a,x,y);\
    printf ("%c[%dm", 27, 0);\
}\
else \
{\
    cprintf(CLR_BLUE,ATTR_UNDERLINE,-1,"SEC-ID: %d UEID: %02x LC-ID %d\n",a,x,y);\
    printf ("%c[%dm", 27, 0);\
}\
CALC_LOAD_RX(a,x,y);\
printf("RX: ThrPut: %.3f  MissSeqperDisp:%2ld  ErrorPerDisp:   %.4f   PktsSinceLastDisp: %4ld  |  TotalPkts:%5ld  MissSeq:%08x  ErrorSession:%.4f  \n",sectorDb_g.ueDataFlow_g[x][y].rxData,sectorDb_g.ueDataFlow_g[x][y].rxMiss_per_display,CALC_ERROR_RATE_PER_DISPLAY(a,x,y),sectorDb_g.ueDataFlow_g[x][y].rxPkts-sectorDb_g.ueDataFlow_g[x][y].rxOldPkt,sectorDb_g.ueDataFlow_g[x][y].rxPkts,sectorDb_g.ueDataFlow_g[x][y].rxMiss,CALC_ERROR_RATE(a,x,y));\
sectorDb_g.ueDataFlow_g[x][y].rxMiss_per_display = 0;\
CALC_LOAD_TX(a,x,y);\
printf("TX: ThrPut: %.3f  NoOfLostTicks:%3d  LostTime:%9ld[ns]   PktsSinceLastDisp: %4ld  |  TotalPkts:%5ld \n",sectorDb_g.ueDataFlow_g[x][y].txData,missTickCount_g,missTimeCount_g,sectorDb_g.ueDataFlow_g[x][y].txPkts-sectorDb_g.ueDataFlow_g[x][y].txOldPkt,sectorDb_g.ueDataFlow_g[x][y].txPkts);\
sectorDb_g.ueDataFlow_g[x][y].rxData =0;sectorDb_g.ueDataFlow_g[x][y].txData = 0;missTickCount_g = 0;missTimeCount_g =0;sectorDb_g.ueDataFlow_g[x][y].txOldPkt = sectorDb_g.ueDataFlow_g[x][y].txPkts;sectorDb_g.ueDataFlow_g[x][y].rxOldPkt=sectorDb_g.ueDataFlow_g[x][y].rxPkts
#endif

/*SPR 21836 Changes End*/
/* to read a 32 bit value starting at the location p_buff */
#define LTE_GET_U32BIT(p_buff)                                        \
    ((UInt32)(*(p_buff) << 24) |                                       \
     (UInt32)(*(p_buff + 1) << 16) |                                \
     (UInt32)(*(p_buff + 2) << 8) |                                 \
     (UInt32)(*(p_buff + 3)))

UInt32 	expectedSegNum_g;
UInt32 	seqNum_g;
UInt32 	numMissedSeq_g = 0;
UInt8 TSandSNValueChange_g = 0;
UInt8 IPIDValueChange_g = 0; /* 1-Random, 2-Sequence 3-Byte Swapped */

#ifndef LAYER2_DLTG_THREAD
SInt16 	ueId_g = 0;
#else
extern SInt16  ueId_g;
void * dlTgThreadExecutionSchedular(void * param);
#endif
/*** Packet Related Information ***/
#define GTP_HDR 8
#define HEADER_LEN 8
#ifndef LAYER2_DLTG_THREAD
#define MAX_PAYLOAD_SIZE 4096 
#endif
#define PNULL NULL

#define VALUE_INVALID 0xFFFFFFFF
#ifdef LIPA_GW
#define MU_GTPSIM_PORT 7777
#else
#define MU_GTPSIM_PORT 6666
#endif
#define MU_GTPSIM_IP   "127.0.0.1"
/* +- SPR 18268 */
/* SPR 20526 Fix Start */
#define MAX_UE  MAX_UE_SUPPORTED 
/* SPR 20526 Fix End */
/* +- SPR 18268 */
#define GTPU_TID_INFO        6
#define GTPU_UE_INFO_FOR_DEL 4

UInt16 decodeFromUeIdentifer(UInt32 *tId,UInt16 ueId,UInt8 lcId);
static UInt16 ipCksumCalc( UInt16 lenIPHeader, UInt8 buffIP[],UInt16 headerStart);
static UInt16 udpCksumCalc(UInt16 lenUDPHeader, UInt8 buffIP[], 
    UInt16 headerStart, UInt8 version);

#define MAX_PROFILES 10
UInt32 processSpsDLPacket(void *ipAddr);
typedef struct SpsProfile_t
{
    UInt16  pktSize;	      /* Packet Size */
    UInt8  interPktArvlTm;    /* Inter Packet Arrival Time */
    UInt16  repetition;	      /* Number of repetition */
    UInt8  *SendBuffer;
}SpsProfile_t;

typedef struct lcInfo_t
{
    UInt8	lc_id;
    UInt8	numPkt;
    UInt8 	data;
    UInt32    packet_size;
    UInt8     *SendBuffer;
}lcInfo_t;
typedef struct ueInfo_t
{
    UInt8     num_lc;
    UInt16     ue_id;
    lcInfo_t  lcInfo[8]; 
}ueInfo_t;
typedef struct sectorInfo_t
{
    /* +- SPR 18268 */
    UInt16    num_ue;
    /* +- SPR 18268 */
    ueInfo_t   ueInfo[MAX_UE];
}sectorInfo_t;
typedef struct spsTraffic_t
{
    UInt8 	 data_present;
/*SPR 21836 Changes Start*/
    sectorInfo_t sectorInfo;
/*SPR 21836 Changes End*/
}spsTraffic_t;

UInt16 g_offset_tracker;
spsTraffic_t spsTraffic[1000];

typedef struct TgProfileInfoT
{
    UInt32 packetSize[MAX_PROF];
    UDouble32   throughput[MAX_PROF];
    UInt32 	varPacketSize[MAX_PROF];
    UDouble32 totalNoOfPktVar[MAX_PROF];
    UDouble32 fixedPktPerTick[MAX_PROF];
    UInt32 remainingPkt[MAX_PROF];
    UInt32 profileTimer;
    UInt16 mixProfileCount;
    UInt32 profileTimerCount;
    UInt8  	*SendBuffer[MAX_PACKET_TYPE];
}TgProfileInfo;

typedef struct RbInfoT 
{
    UInt8 	txActiveFlag;
    UInt8 	lcId;
    UInt32 	tId; /* Tunnel Id*/
    UInt8 	sps_lc;
    UInt8 	tpId[MAX_PROF];
    UInt32 	packet_size[MAX_PACKET_TYPE];
    UDouble32  	throughput[MAX_PACKET_TYPE];
    
    UDouble32 	totalNoOfPktVar[MAX_PACKET_TYPE];
    UDouble32	 fixedPktPerTick[MAX_PACKET_TYPE];
    UDouble32	token;
    UInt8	maxPkt;
    UInt8	minPkt;
    UInt8       PktInCurrTTI ;
    UInt32 	remainingPkt[MAX_PACKET_TYPE];
    UInt32 	noOfTicks;
    UInt32 	extraBurstCounter[MAX_PACKET_TYPE];
    UInt64 	txTickCount;
    UInt64 	lastDisplayTick;
    UInt8  	bitRateFlag;
    UInt32 	varPacketSize;
    UInt8  	extraBurstFlag;
    UInt8  	upDownFlag;
#ifndef NO_GTPU_STACK
    UInt32 	tId_self; /*Tunnel id */
#endif
    SpsProfile_t  spsProfile[MAX_PROFILES];
    UInt16 ipId_ip;
    UInt16 sn_rtp;
    UInt32 ts_rtp;
    UInt8	tpCount;
    UInt8 profileIdx;
    UInt8 isLCTimerPresent;
    UInt32 totalExecTime;
    UInt8 synack_tcp;           /* Variable to keep a count of number of tcp packets */
    UInt32 totalBytes;          /* total bytes sent, no handling done for wrap around in UE Sim */
    TgProfileInfo tgProfileInfo[MAX_PROF];
#ifdef TG_REAL_EPC
    SInt8 sockTxFd;
    struct sockaddr_in sockAddr;
#endif
}RbInfo;

void
setSYNnACKinTCPPkt
(
    /* +- SPR 18268 */
    UInt16 ueIndex,
    /* +- SPR 18268 */
    UInt8 lcIndex,
    UInt8 sendBuffer[],
    UInt32 bytes
);

void sendDATAinTCPPkt
(
    /* +- SPR 18268 */
    UInt16 ueIndex,
    /* +- SPR 18268 */
    UInt8 lcIndex,
    UInt8 sendBuffer[],
    UInt32 bytesSent,
    UInt32 counter
);

#ifdef ROHC_PROFILE_6
void initProfile6Params(void);
#endif

typedef struct
{
    UInt16	ueId;      /* UE Index*/
    UInt16 	lcCnt;
    RbInfo   	rbInfo[8]; /* LC Id*/
    SInt64     	timeDiff;
}gtpDataBase_t;

SInt32 		sockRxTid_g;/* Socket Descriptor for Tunnel ID reception*/

/* Table for storing the tunnel id corresponding to ue id */
gtpDataBase_t 	gtpDb_g[MAX_UE];
gtpDataBase_t 	tp_dbase_g;
/* CA DL_TG CHANGES start */
/*SPR 21727 changes start*/
/*SPR 21836 Changes Start*/
#ifdef PDCP_GTPU_INTF
UInt16 		    lastUeInSystemTG_g = 0;
#else
SInt16          lastUeInSystemTG_g = -1;
#endif
/*SPR 21836 Changes End*/
/*SPR 21727 changes End*/
/* CA DL_TG CHANGES end */

/* TCP structure for modifying different field behavior in TCP header */
typedef struct rohcProfile6T
{
    UInt8 isInitiator;          /* Set if UL is the initiator of data connection */
    UInt8 isFin;                /* Set if UL is the initiator of data termination */
    UInt8 isGenerator;          /* It keeps a check on the behavior of data type (genarator/consumer/both) */
}rohcProfile6;
/*- Structures */ 		
/*+ For Multisector*/
typedef struct
{
    UInt16		ueCount;
    gtpDataBase_t   	gtpDb_g[MAX_UE];
    t_ueStats      	ueDataFlow_g[MAX_MULTI_UE][MAX_LC_ID]; 
}sectorDataBase_t;

/*SPR 21836 Changes Start*/
static sectorDataBase_t	sectorDb_g;
/*SPR 21836 Changes End*/
rohcProfile6    profile6Params_g;       /* Object for TCP structure */
UInt8		sectorCount_g = 1;
/*- For Multisector*/

UInt32 		TID_g = 0;
UInt32 		mode_g = 0;
/* AUTOMATION_DLTG */
#ifdef AUTOMATION_DLTG
UInt32 ulTrafficRcv = 0;
#endif
/* AUTOMATION_DLTG */

#ifndef TG_REAL_EPC
UInt16 	decodeFromTunnelIdentifer(UInt32 tId,UInt16 *ueId,UInt8 *lcId);
#endif

#ifndef IPV6_ENABLE
void 	initGtpuGlueSocket_fn(SInt8* srcAddr);
#else
void    initGtpuGlueSocket_fn(UInt8 *srcAddr);
#endif

#ifndef NO_GTPU_STACK
void 	addRecordToTable(UInt32 tId_self,UInt32 tunnelId, UInt16 ueId,UInt8 lcId);
#else
void 	addRecordToTable(UInt32 tunnelId,UInt16 ueId,UInt8 lcId);
#endif
/* + SPR 8669 Fix*/
#ifndef TG_REAL_EPC
UInt32 	deleteRecordFromTable(UInt32 tId_peer, UInt16 ueId, UInt8 lcIdty);
#endif
/* - SPR 8669 Fix*/
UInt16 	deleteInfoInDb( UInt16 ueId);
#define PRINT_TIME()\
{\
    char buff[100];\
    time_t now = time (0);\
    strftime (buff, 100, "%d-%m-%Y %H:%M:%S", localtime (&now));\
    printf ("%s\n", buff);\
}
enum tgModeT
{
    TG_DL_MODE,
    TG_UL_MODE,
    TG_UL_DL_MODE
}tgMode;

enum socketTypeT
{
    OPEN_TX_SOCKET,
    OPEN_RX_SOCKET
}socketType;

#ifndef LAYER2_DLTG_THREAD
#define LTE_SET_U16BIT(p_buff, val              )\
    do {                                                \
        *(p_buff) = (UInt8)((val) >> 8) ;               \
        *(p_buff + 1) = (UInt8)(val);                 \
    } while (0)
#define LTE_SET_U32BIT(p_buff, val)                 \
    do {                                                \
        *(p_buff) = (UInt8)(((val) >> 24) & 0xFF) ;               \
        *(p_buff+1) = (UInt8)(((val) >> 16)& 0xFF) ;               \
        *(p_buff+2) = (UInt8)(((val) >> 8)& 0xFF) ;               \
        *(p_buff+3) = (UInt8)(val);                 \
    } while (0)

#define LTE_GET_U16BIT(p_buff)  (UInt16)(*(p_buff) << 8) | (UInt16)(*(p_buff + 1))
#define LTE_SET_U24BIT(p_buff, val)                                   \
	do {                                                               \
	    *(p_buff) = (UInt8)((val) >> 16);                              \
	    *(p_buff + 1) = (UInt8)((val) >> 8);                           \
	    *(p_buff + 2) = (UInt8)(val);                                  \
	} while (0)

#endif


UInt32 		throughputDisplayVar_g;
UDouble32  	totalThrputVar_g , totalNoOfPktVar_g ;

#ifdef LAYER2_DLTG_THREAD
extern UInt32           noOfPktVar_g;
extern UInt32           dlTgCoreNum_g ;
extern UInt32           timeInMs_g ;
extern UInt32           putDisplayVar_g;
extern UInt32           trafficProfileVar_g ;
extern UInt32           packetSize_g;
#else
UInt32          noOfPktVar_g;
UInt32          timeInMs_g;
UInt32          trafficProfileVar_g =0;
UInt8          ext_hdr_prof_g = 0; /* SPR 18822 Fix*/
#ifndef IPV6_ENABLE
 struct sockaddr_in 	sockAddr_g;
#ifdef ENDC_ENABLED
 struct sockaddr_in 	sgnbsockAddr_g;
#endif
#else
 struct sockaddr_in6 	sockAddr_g = {0};
#endif
 SInt8 			sockTxFd_g = -1;
#endif

/* LAYER2_DLTG_THREAD Compilation fix start */
typedef UInt64 tickType_t;

extern tickType_t noOfTicks_g; 
/* LAYER2_DLTG_THREAD Compilation fix End */

/* LAYER2_DLTG_THREAD Compilation fix start */
UInt32 		fixedPktPerTick_g, remainingPkt_g, extraBurstCounter_g;
/* LAYER2_DLTG_THREAD Compilation fix End */
pthread_t 	ulThreadId_g;
UInt32 		pktCounter_g = 0;
UInt32 		missTickCount_g =0;
UInt64 		missTimeCount_g = 0;
UInt8 		traffic_profile_id_g = 0;
/* +- SPR 18268 */
UInt16 		ueCount_g = 0;
/* +- SPR 18268 */
/*SPR 21836 Changes Start*/
UDouble32 	load_variation_g= 0;
/*+ TG Changes for QOS Testing */
UDouble32 	burst_time_g = 0;
UDouble32 	total_duration_g = 0;
/*SPR 21836 Changes End*/
/*- TG Changes for QOS Testing */
long 		timer_g = 0;
struct timeval 	t1;

#ifndef LAYER2_DLTG_THREAD
SInt8       *srcIpAddr_g = NULL;
#endif
#ifdef ENDC_ENABLED
SInt8 	     sgnbTxFd_g = -1;
SInt8       *sgnbIpAddr_g = NULL;
#endif

/* LAYER2_DLTG_THREAD Compilation fix start */
#define START_OFFSET_DL_GTP1 8 
/* LAYER2_DLTG_THREAD Compilation fix End */

/* MBMS Changes Start */
#ifndef LAYER2_DLTG_THREAD
#define MAX_SUPPORTED_AREA                  256
#define MAX_TRAFFIC_PROFILE_SUPPORTED       10

#define PAYLOAD_SIZE 48
#define POLYNOMIAL 0x623

#define TYPE0_HEADER_SIZE_EXCLUDING_CRC     3
#define TYPE1_HEADER_SIZE_EXCLUDING_CRC     3
#define TYPE3_HEADER_SIZE_EXCLUDING_CRC     TYPE0_HEADER_SIZE_EXCLUDING_CRC

//DUPLICATE 
#define MAX_PKT_SIZE    1200
#define MAX_PKT_SIZE_MBMS 1024
#define START_OFFSET_DL_GTP 64 

#define SYNC_HEADER_LENGTH      0x0B
#define SYNC_HDR_SPARE_EXT_LEN  0x04

typedef struct lcInfo
{
    // Constant variables
    UInt8   lcID;
    UInt8   trafficProfile;
    UInt8   isTimerPresent;
    UInt32  lcTimer;
    // Sync sequences
    // there can be one or more sync sequences withing an MSP
    UInt32  syncSeq;
    UInt32  endPduType;
    UInt32  teId;
    UInt32  pktSize;
    UInt32  dlThpt;
    UInt32  timerVal;
    //Duration of MSP is always a integer multiple of sync sequences. 
    UInt32  msp;
    // Sync Period in seconds
    UInt32  syncPeriod; 
    // Variables used in computation
    // Used to fill SYNC pdu
    // Variables perSYNC Sequence
    UInt16  timeStamp;
    UInt16  packetNumber;
    UInt32  elapsedOctetCounter;
    // Variables per SYNC Period
    /*verification parameters*/
    UInt8   type1Missing;    
    UInt8   type0Missing;    
    UInt8   type2Filled;    
    /*verification parameters*/
    UInt8   controlPacketSend;
    UInt8   dataPacketSend;
    UInt8   firstMspReached;
    UInt32  totalNoOfPackets;
    UInt64  totalNoOfOctets;
    UInt32  totalPacketsToBeSent;
    UInt32  packetToBeSentInTTI;
    UInt32  remainingPktsToBeSentInTti;
    UInt32  currentSyncSeqToUse;
    UInt32  packetsToBeSentInSynSeq;
    UInt16  prevTimeStampToUse;
    UInt32  profileTimerCount;
    UInt32  txData;

    /// TODO : list of packets length for Type 3 

}eMBMSlcInfo_t;

typedef struct areaInfo
{
    UInt8       areaId;
    UInt8       lcCount;
    eMBMSlcInfo_t    lcInfo[32];
}areaInfo_t;

typedef struct syncAreaDB
{
    UInt8           areaCount;
    areaInfo_t      areainfo[MAX_SUPPORTED_AREA];
}syncAreaDB_t;

static syncAreaDB_t syncAreaDB_g;

typedef struct syncDLTrafficProfileDB
{
    UInt8   isValid;
    UInt32  TPID;
    UInt32  packetSize;
    UInt32  throughput;
    UInt32  time;
} syncDLTrafficProfileDB_t;


static syncDLTrafficProfileDB_t syncDLTrafficProfileDb[MAX_TRAFFIC_PROFILE_SUPPORTED];


#ifndef IPV6_ENABLE
struct sockaddr_in localInterface;
struct sockaddr_in groupSock;
#else
struct sockaddr_in6 localInterface_IPV6;
struct sockaddr_in6 groupSock_IPV6;
#endif
int sd;

#endif //(defined(LTE_EMBMS_SUPPORTED) && !defined(LAYER2_DLTG_THREAD))
/*MBMS Changes End*/
static unsigned short byte_crc10_table[256];


#if 0
static const uint16_t crc10_table[256] =
{
    0x0000, 0x0233, 0x0255, 0x0066, 0x0299, 0x00aa, 0x00cc, 0x02ff,
    0x0301, 0x0132, 0x0154, 0x0367, 0x0198, 0x03ab, 0x03cd, 0x01fe,
    0x0031, 0x0202, 0x0264, 0x0057, 0x02a8, 0x009b, 0x00fd, 0x02ce,
    0x0330, 0x0103, 0x0165, 0x0356, 0x01a9, 0x039a, 0x03fc, 0x01cf,
    0x0062, 0x0251, 0x0237, 0x0004, 0x02fb, 0x00c8, 0x00ae, 0x029d,
    0x0363, 0x0150, 0x0136, 0x0305, 0x01fa, 0x03c9, 0x03af, 0x019c,
    0x0053, 0x0260, 0x0206, 0x0035, 0x02ca, 0x00f9, 0x009f, 0x02ac,
    0x0352, 0x0161, 0x0107, 0x0334, 0x01cb, 0x03f8, 0x039e, 0x01ad,
    0x00c4, 0x02f7, 0x0291, 0x00a2, 0x025d, 0x006e, 0x0008, 0x023b,
    0x03c5, 0x01f6, 0x0190, 0x03a3, 0x015c, 0x036f, 0x0309, 0x013a,
    0x00f5, 0x02c6, 0x02a0, 0x0093, 0x026c, 0x005f, 0x0039, 0x020a,
    0x03f4, 0x01c7, 0x01a1, 0x0392, 0x016d, 0x035e, 0x0338, 0x010b,
    0x00a6, 0x0295, 0x02f3, 0x00c0, 0x023f, 0x000c, 0x006a, 0x0259,
    0x03a7, 0x0194, 0x01f2, 0x03c1, 0x013e, 0x030d, 0x036b, 0x0158,
    0x0097, 0x02a4, 0x02c2, 0x00f1, 0x020e, 0x003d, 0x005b, 0x0268,
    0x0396, 0x01a5, 0x01c3, 0x03f0, 0x010f, 0x033c, 0x035a, 0x0169,
    0x0188, 0x03bb, 0x03dd, 0x01ee, 0x0311, 0x0122, 0x0144, 0x0377,
    0x0289, 0x00ba, 0x00dc, 0x02ef, 0x0010, 0x0223, 0x0245, 0x0076,
    0x01b9, 0x038a, 0x03ec, 0x01df, 0x0320, 0x0113, 0x0175, 0x0346,
    0x02b8, 0x008b, 0x00ed, 0x02de, 0x0021, 0x0212, 0x0274, 0x0047,
    0x01ea, 0x03d9, 0x03bf, 0x018c, 0x0373, 0x0140, 0x0126, 0x0315,
    0x02eb, 0x00d8, 0x00be, 0x028d, 0x0072, 0x0241, 0x0227, 0x0014,
    0x01db, 0x03e8, 0x038e, 0x01bd, 0x0342, 0x0171, 0x0117, 0x0324,
    0x02da, 0x00e9, 0x008f, 0x02bc, 0x0043, 0x0270, 0x0216, 0x0025,
    0x014c, 0x037f, 0x0319, 0x012a, 0x03d5, 0x01e6, 0x0180, 0x03b3,
    0x024d, 0x007e, 0x0018, 0x022b, 0x00d4, 0x02e7, 0x0281, 0x00b2,
    0x017d, 0x034e, 0x0328, 0x011b, 0x03e4, 0x01d7, 0x01b1, 0x0382,
    0x027c, 0x004f, 0x0029, 0x021a, 0x00e5, 0x02d6, 0x02b0, 0x0083,
    0x012e, 0x031d, 0x037b, 0x0148, 0x03b7, 0x0184, 0x01e2, 0x03d1,
    0x022f, 0x001c, 0x007a, 0x0249, 0x00b6, 0x0285, 0x02e3, 0x00d0,
    0x011f, 0x032c, 0x034a, 0x0179, 0x0386, 0x01b5, 0x01d3, 0x03e0,
    0x021e, 0x002d, 0x004b, 0x0278, 0x0087, 0x02b4, 0x02d2, 0x00e1
};
#endif


static const UInt16 crc10_table[256] =
{
    0x0000, 0x0233, 0x0255, 0x0066, 0x0299, 0x00aa, 0x00cc, 0x02ff,
    0x0301, 0x0132, 0x0154, 0x0367, 0x0198, 0x03ab, 0x03cd, 0x01fe,
    0x0031, 0x0202, 0x0264, 0x0057, 0x02a8, 0x009b, 0x00fd, 0x02ce,
    0x0330, 0x0103, 0x0165, 0x0356, 0x01a9, 0x039a, 0x03fc, 0x01cf,
    0x0062, 0x0251, 0x0237, 0x0004, 0x02fb, 0x00c8, 0x00ae, 0x029d,
    0x0363, 0x0150, 0x0136, 0x0305, 0x01fa, 0x03c9, 0x03af, 0x019c,
    0x0053, 0x0260, 0x0206, 0x0035, 0x02ca, 0x00f9, 0x009f, 0x02ac,
    0x0352, 0x0161, 0x0107, 0x0334, 0x01cb, 0x03f8, 0x039e, 0x01ad,
    0x00c4, 0x02f7, 0x0291, 0x00a2, 0x025d, 0x006e, 0x0008, 0x023b,
    0x03c5, 0x01f6, 0x0190, 0x03a3, 0x015c, 0x036f, 0x0309, 0x013a,
    0x00f5, 0x02c6, 0x02a0, 0x0093, 0x026c, 0x005f, 0x0039, 0x020a,
    0x03f4, 0x01c7, 0x01a1, 0x0392, 0x016d, 0x035e, 0x0338, 0x010b,
    0x00a6, 0x0295, 0x02f3, 0x00c0, 0x023f, 0x000c, 0x006a, 0x0259,
    0x03a7, 0x0194, 0x01f2, 0x03c1, 0x013e, 0x030d, 0x036b, 0x0158,
    0x0097, 0x02a4, 0x02c2, 0x00f1, 0x020e, 0x003d, 0x005b, 0x0268,
    0x0396, 0x01a5, 0x01c3, 0x03f0, 0x010f, 0x033c, 0x035a, 0x0169,
    0x0188, 0x03bb, 0x03dd, 0x01ee, 0x0311, 0x0122, 0x0144, 0x0377,
    0x0289, 0x00ba, 0x00dc, 0x02ef, 0x0010, 0x0223, 0x0245, 0x0076,
    0x01b9, 0x038a, 0x03ec, 0x01df, 0x0320, 0x0113, 0x0175, 0x0346,
    0x02b8, 0x008b, 0x00ed, 0x02de, 0x0021, 0x0212, 0x0274, 0x0047,
    0x01ea, 0x03d9, 0x03bf, 0x018c, 0x0373, 0x0140, 0x0126, 0x0315,
    0x02eb, 0x00d8, 0x00be, 0x028d, 0x0072, 0x0241, 0x0227, 0x0014,
    0x01db, 0x03e8, 0x038e, 0x01bd, 0x0342, 0x0171, 0x0117, 0x0324,
    0x02da, 0x00e9, 0x008f, 0x02bc, 0x0043, 0x0270, 0x0216, 0x0025,
    0x014c, 0x037f, 0x0319, 0x012a, 0x03d5, 0x01e6, 0x0180, 0x03b3,
    0x024d, 0x007e, 0x0018, 0x022b, 0x00d4, 0x02e7, 0x0281, 0x00b2,
    0x017d, 0x034e, 0x0328, 0x011b, 0x03e4, 0x01d7, 0x01b1, 0x0382,
    0x027c, 0x004f, 0x0029, 0x021a, 0x00e5, 0x02d6, 0x02b0, 0x0083,
    0x012e, 0x031d, 0x037b, 0x0148, 0x03b7, 0x0184, 0x01e2, 0x03d1,
    0x022f, 0x001c, 0x007a, 0x0249, 0x00b6, 0x0285, 0x02e3, 0x00d0,
    0x011f, 0x032c, 0x034a, 0x0179, 0x0386, 0x01b5, 0x01d3, 0x03e0,
    0x021e, 0x002d, 0x004b, 0x0278, 0x0087, 0x02b4, 0x02d2, 0x00e1
};
/* LAYER2_DLTG_THREAD Compilation fix start */
unsigned char crc6_table_1[] =
/* LAYER2_DLTG_THREAD Compilation fix End */
{
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,
    0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0f,0x0c,0x0d,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1a,0x1b,0x18,0x19,0x1e,0x1f,0x1c,0x1d,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2b,0x28,0x29,0x2e,0x2f,0x2c,0x2d,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3c,0x3d,
    0x2d,0x2c,0x2f,0x2e,0x29,0x28,0x2b,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x3d,0x3c,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x0d,0x0c,0x0f,0x0e,0x09,0x08,0x0b,0x0a,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x1d,0x1c,0x1f,0x1e,0x19,0x18,0x1b,0x1a,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3d,0x3c,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2e,0x2d,0x2c,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1a,0x19,0x18,0x1f,0x1e,0x1d,0x1c,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0a,0x09,0x08,0x0f,0x0e,0x0d,0x0c,
    0x1c,0x1d,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x0c,0x0d,0x0e,0x0f,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,0x29,0x28,0x2b,0x2a,0x2d,0x2c,0x2f,0x2e,
    0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,0x39,0x38,0x3b,0x3a,0x3d,0x3c,0x3f,0x3e,
    0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0b,0x0a,0x0d,0x0c,0x0f,0x0e,
    0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1b,0x1a,0x1d,0x1c,0x1f,0x1e,
    0x0e,0x0f,0x0c,0x0d,0x0a,0x0b,0x08,0x09,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,
    0x1e,0x1f,0x1c,0x1d,0x1a,0x1b,0x18,0x19,0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,
    0x2e,0x2f,0x2c,0x2d,0x2a,0x2b,0x28,0x29,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,
    0x3e,0x3f,0x3c,0x3d,0x3a,0x3b,0x38,0x39,0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,
    0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,
    0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
    0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,
    0x2c,0x2d,0x2e,0x2f,0x28,0x29,0x2a,0x2b,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,
    0x3c,0x3d,0x3e,0x3f,0x38,0x39,0x3a,0x3b,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,
    0x0C,0x0d,0x0E,0x0F,0x08,0x09,0x0a,0x0b,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,
    0x1C,0x1D,0x1e,0x1f,0x18,0x19,0x1a,0x1b,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,
    0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x0b,0x0A,0x09,0x08,0x0f,0x0E,0x0d,0x0C,
    0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,0x1b,0x1A,0x19,0x18,0x1f,0x1e,0x1D,0x1C,
    0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,0x2b,0x2a,0x29,0x28,0x2f,0x2E,0x2D,0x2C,
    0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3D,0x3C,
    0x1D,0x1C,0x1f,0x1e,0x19,0x18,0x1b,0x1A,0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,
    0x0d,0x0C,0x0F,0x0E,0x09,0x08,0x0b,0x0A,0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,
    0x3D,0x3C,0x3f,0x3e,0x39,0x38,0x3b,0x3a,0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,
    0x2D,0x2C,0x2F,0x2E,0x29,0x28,0x2B,0x2a,0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,
    0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3C,0x3D,
    0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,0x2a,0x2B,0x28,0x29,0x2e,0x2F,0x2C,0x2D,
    0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,0x1A,0x1b,0x18,0x19,0x1e,0x1f,0x1C,0x1D,
    0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,0x0a,0x0b,0x08,0x09,0x0e,0x0F,0x0C,0x0d,
    0x3b,0x3a,0x39,0x38,0x3f,0x3e,0x3D,0x3C,0x33,0x32,0x31,0x30,0x37,0x36,0x35,0x34,
    0x2B,0x2a,0x29,0x28,0x2f,0x2E,0x2D,0x2C,0x23,0x22,0x21,0x20,0x27,0x26,0x25,0x24,
    0x1b,0x1A,0x19,0x18,0x1f,0x1e,0x1D,0x1C,0x13,0x12,0x11,0x10,0x17,0x16,0x15,0x14,
    0x0b,0x0A,0x09,0x08,0x0f,0x0E,0x0d,0x0C,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,
    0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x1c,0x1D,0x1e,0x1f,0x18,0x19,0x1a,0x1b,
    0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x0c,0x0d,0x0E,0x0F,0x08,0x09,0x0a,0x0b,
    0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x3c,0x3D,0x3e,0x3f,0x38,0x39,0x3a,0x3b,
    0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x2c,0x2D,0x2E,0x2F,0x28,0x29,0x2a,0x2B,
    0x0A,0x0b,0x08,0x09,0x0e,0x0F,0x0C,0x0d,0x02,0x03,0x00,0x01,0x06,0x07,0x04,0x05,
    0x1A,0x1b,0x18,0x19,0x1e,0x1f,0x1C,0x1D,0x12,0x13,0x10,0x11,0x16,0x17,0x14,0x15,
    0x2a,0x2B,0x28,0x29,0x2e,0x2F,0x2C,0x2D,0x22,0x23,0x20,0x21,0x26,0x27,0x24,0x25,
    0x3a,0x3b,0x38,0x39,0x3e,0x3f,0x3C,0x3D,0x32,0x33,0x30,0x31,0x36,0x37,0x34,0x35,
    0x25,0x24,0x27,0x26,0x21,0x20,0x23,0x22,0x2d,0x2C,0x2F,0x2E,0x29,0x28,0x2b,0x2a,
    0x35,0x34,0x37,0x36,0x31,0x30,0x33,0x32,0x3d,0x3C,0x3f,0x3e,0x39,0x38,0x3b,0x3a,
    0x05,0x04,0x07,0x06,0x01,0x00,0x03,0x02,0x0d,0x0C,0x0F,0x0E,0x09,0x08,0x0b,0x0A,
    0x15,0x14,0x17,0x16,0x11,0x10,0x13,0x12,0x1d,0x1C,0x1f,0x1e,0x19,0x18,0x1b,0x1A,
    0x36,0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3e,0x3f,0x3C,0x3D,0x3a,0x3b,0x38,0x39,
    0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2e,0x2F,0x2C,0x2D,0x2a,0x2B,0x28,0x29,
    0x16,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1e,0x1f,0x1C,0x1D,0x1A,0x1b,0x18,0x19,
    0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0e,0x0F,0x0C,0x0d,0x0A,0x0b,0x08,0x09,
    0x19,0x18,0x1b,0x1A,0x1D,0x1C,0x1f,0x1e,0x11,0x10,0x13,0x12,0x15,0x14,0x17,0x16,
    0x09,0x08,0x0b,0x0A,0x0d,0x0C,0x0F,0x0E,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,
    0x39,0x38,0x3b,0x3a,0x3D,0x3C,0x3f,0x3e,0x31,0x30,0x33,0x32,0x35,0x34,0x37,0x36,
    0x29,0x28,0x2b,0x2a,0x2D,0x2C,0x2F,0x2E,0x21,0x20,0x23,0x22,0x25,0x24,0x27,0x26,
    0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00,0x0f,0x0E,0x0d,0x0C,0x0b,0x0A,0x09,0x08,
    0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x1f,0x1e,0x1D,0x1C,0x1b,0x1A,0x19,0x18,
    0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x2f,0x2E,0x2D,0x2C,0x2B,0x2a,0x29,0x28,
    0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x3f,0x3e,0x3D,0x3C,0x3b,0x3a,0x39,0x38,
    0x28,0x29,0x2a,0x2B,0x2C,0x2D,0x2E,0x2F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
    0x38,0x39,0x3a,0x3b,0x3C,0x3D,0x3e,0x3f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
    0x08,0x09,0x0a,0x0b,0x0C,0x0d,0x0E,0x0F,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x18,0x19,0x1a,0x1b,0x1C,0x1D,0x1e,0x1f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17 
};



/* tg-change --- function prototype updated */
extern void populateMBMSConfig(SInt8 *srcAddr, SInt8 *dstAddr);
extern void sendMBMSTraffic();
extern void initDLBufferForSync(UInt8 * sendBuffer, UInt32 offset, UInt32 packetSize);

/*MBMS Changes End*/

/****************************************************************************
 *  * Function Definitions
 *****************************************************************************/
/*SPR 21727 Changes start*/
#ifdef PDCP_GTPU_INTF
UInt8 isDataToSchedule(UInt8 data_on_cell_num, UInt8 current_active_ue)
{
    if(3 == data_on_cell_num)
    {
        return TRUE;
    }
    else if(1 == data_on_cell_num)
    {
        if(0 == (current_active_ue & 0x01))
        {
            return TRUE ; 
        }
        else
        { 
            return FALSE;
        }
    }
    else
    {
        if(0 != (current_active_ue & 0x01))
        {
            return TRUE ; 
        }
        else
        { 
            return FALSE;
        }
    }
}

#endif
/*SPR 21727 Changes end*/
/******************************************************************************
 *   FUNCTION NAME : ipCksumCalc 
 *   INPUT         : lenIPHeader,buffIP[]
 *   OUTPUT        : None
 *   RETURNS       : IPcksum
 *   DESCRIPTION   : This function calculates the 16 bit IP checksum  *
 * *************************************************************************/
UInt16 ipCksumCalc( UInt16 lenIPHeader, UInt8 buffIP[],UInt16 headerStart)
{
    UInt16 ipWord;
    UInt32 sum=0;
    UInt16 index ;

    /* To Nullify Checksum */
    buffIP[headerStart + 10] = buffIP[headerStart + 11] = 0;

    for (index = headerStart; index < lenIPHeader+headerStart; index = index +2)
    {
        ipWord =((buffIP[index]<<8) & 0xFF00) + (buffIP[index+1] & 0xFF);
        sum = sum + (UInt32)ipWord;
    }
    while (sum>>16)
        sum = (sum & 0xFFFF) + (sum >> 16);

    // one's complement the result
    sum = ~sum;
    return ((UInt16) sum);
}

/******************************************************************************
 *   *   FUNCTION NAME : udpCksumCalc
 *   *   INPUT         : lenUDPHeader,buffIP[]
 *   *   OUTPUT        : None
 *   *   RETURNS       : UDPcksum
 *   *   DESCRIPTION   : This function calculates the 16 bit UDP checksum   *
 *   * *************************************************************************/

UInt16 udpCksumCalc(UInt16 lenUDPHeader, UInt8 buffIP[],UInt16 headerStart, UInt8 version)
{
#ifndef ROHC_PROFILE_6
  UInt16 prot=LTE_IP_UDP_PROTO;
#else
  UInt16 prot=LTE_IP_TCP_PROTO;
#endif

    UInt16 word;
    UInt32 udpSum = 0 ;
    UInt16 index ;
	UInt8 srcAddrIndex ;
	UInt8 destAddrIndex ;
	UInt8 sizeOfAddr ;

    for (index = headerStart; index < lenUDPHeader; index = index+2)
    {
        word =((buffIP[index]<<8)&0xFF00)+(buffIP[index + 1]&0xFF);
        udpSum = udpSum + (unsigned long)word;
    }	
    /*adding the UDP pseudo header which contains the IP source and destinationn addresses */
	if(version ==4)
	{
		srcAddrIndex = 20;
		destAddrIndex = 24;
		sizeOfAddr = 4;
	}
	else
	{
		srcAddrIndex = 16;
		destAddrIndex = 32;
		sizeOfAddr = 16;
	}
	for (index = srcAddrIndex; index < srcAddrIndex + sizeOfAddr; index = index +2)
    {
        word =(((buffIP[index]<<8)&0xFF00)+(buffIP[index +1]&0xFF));
        udpSum=udpSum+word;	
    }
	for (index = destAddrIndex; index < destAddrIndex + sizeOfAddr; index = index +2)
    {
        word =(((buffIP[index ]<<8)&0xFF00)+(buffIP[index +1]&0xFF));
        udpSum=udpSum+word; 	
    }
    /* the protocol number and the length of the UDP packet*/
    udpSum = udpSum + prot + lenUDPHeader;

    /*  keeping last 16 bits of calculated sum and adding the carries */
    while (udpSum>>16)
        udpSum = (udpSum & 0xFFFF)+(udpSum >> 16);

    udpSum = ~udpSum;
    return ((UInt16) udpSum);
}

/******************************************************************************
 *   FUNCTION NAME : prepareSendBuffer
 *   INPUT         : sendBuffer, headerStart, packet_size
 *   OUTUT         : None
 *   RETURNS       : None
 *   DESCRIPTION   : This function prepares the downlink buffer.
 ***************************************************************************/
void prepareSendBuffer(UInt8 sendBuffer[], UInt16 headerStart, UInt32 packet_size) 
{
    UInt8 		ipHeaderLen = 0;
    UInt8 		ipLenOffsetMsb = 0;
    UInt8 		ipLenOffsetLsb = 0;
    UInt8 		udpHLenMsb = 0;
    UInt8 		udpHLenLsb = 0;
    UInt8 		udpChecksumMsb = 0;
    UInt8 		udpChecksumLsb = 0;
    UInt8 		ipChecksumMsb = 0;
    UInt8 		ipChecksumLsb = 0;
    //UInt8       version       =  (sendBuffer[8] >> 4) & 0xF; 
    UInt8       version       =  (sendBuffer[headerStart] >> 4) & 0xF; 
    UInt16      udpChecksum = 0;
    UInt16      ipChecksum = 0;
    UInt8       proto = 0; 
    if(version == 4)             
    {                    
        //proto = sendBuffer[17];    
        proto = sendBuffer[(headerStart-START_OFFSET_DL_GTP1)+17];    
        ipHeaderLen = 20;       
        ipLenOffsetMsb = 2; 
        ipLenOffsetLsb = 3; 
        udpHLenMsb = 24;
        udpHLenLsb = 25; 
        udpChecksumMsb = 26;
        udpChecksumLsb = 27;
        ipChecksumMsb = 10;
        ipChecksumLsb = 11;
        
        sendBuffer[headerStart+ipLenOffsetMsb] = 
            ((UInt16)packet_size>>8) & (0xFF);
        sendBuffer[headerStart+ipLenOffsetLsb] = 
            ((UInt16)packet_size & 0xFF);  
    }
    else  
    {    
        //proto = sendBuffer[14];
        proto = sendBuffer[(headerStart-START_OFFSET_DL_GTP1)+14];
        ipHeaderLen = 40; 
        ipLenOffsetMsb = 4;
        ipLenOffsetLsb = 5;
        udpHLenMsb = 44; 
        udpHLenLsb = 45; 
        udpChecksumMsb = 46;
        udpChecksumLsb = 47;
        
        /* In case of IPv6 we fill only payload length */  
        sendBuffer[headerStart+ipLenOffsetMsb] =  
            ((UInt16)(packet_size - ipHeaderLen)>>8) & (0xFF); 
        sendBuffer[headerStart+ipLenOffsetLsb] = 
            ((UInt16)(packet_size - ipHeaderLen) & 0xFF); 
    }
    if (proto == LTE_IP_TCP_PROTO)
    {
        if(version == 4)
        {
            udpChecksumMsb = 36;
            udpChecksumLsb = 37;
        }
        else
        {
            udpChecksumMsb = 59;
            udpChecksumLsb = 60;
        }
    }
    if (proto == LTE_IP_UDP_PROTO)
    {
        sendBuffer[headerStart+udpHLenMsb] = 
            ((UInt16)(packet_size - ipHeaderLen )>>8) & (0xFF); 
        sendBuffer[headerStart+udpHLenLsb] = 
            ((UInt16)(packet_size - ipHeaderLen) & 0xFF); 
    }

    udpChecksum = udpCksumCalc(    
            (UInt16)(packet_size - ipHeaderLen), 
            sendBuffer,headerStart+ipHeaderLen, version);
    sendBuffer[headerStart+udpChecksumMsb] = 
        (udpChecksum >>8) & (0xFF); 
    sendBuffer[headerStart+udpChecksumLsb] =  
        (udpChecksum & 0xFF);  
    /* IP Checksum required in case of Ipv4 only */
    if(version == 4) 
    {  
        ipChecksum =  ipCksumCalc( 
                (UInt16) ipHeaderLen, 
                sendBuffer,
                headerStart);
        sendBuffer[headerStart+ipChecksumMsb] = 
            (ipChecksum >>8) & (0xFF);
        sendBuffer[headerStart+ipChecksumLsb] = 
            (ipChecksum & 0xFF); 
    }
}

/******************************************************************************
 *   FUNCTION NAME : setSchedulePolicy
 *   INPUT         : priority,policy
 *   OUTUT         : None
 *   RETURNS       : None
 *   DESCRIPTION   : This function sets the scheduling priority according to
 *                   policy and priority entered
 * ***************************************************************************/
void setSchedulePolicy (int priority,int policy)
{
#ifdef HIGH_GEN_PRIORITY
    struct sched_param param;
    param.sched_priority = priority;

    if (pthread_setschedparam(pthread_self(),policy, &param) != 0)
        fprintf(stderr,"----setting prioity failed------\n ");
#endif
}

#ifndef TG_REAL_EPC
/****************************************************************************
 * * Function Name  : appendGtpHeader 
 * * Inputs         : None
 * * Outputs        : None
 * * Returns        : gtp_packet and length
 * * Description    : This function append the GTP Header in the front of packet 
 * ****************************************************************************/
UInt32 appendGtpHeader(UInt8 *gtp_packet,UInt32 length
#ifdef PDCP_GTPU_INTF
	,UInt32 localUeTurn,UInt32 localLcId
#endif
	)
{
    UInt32 current = 0;
    UInt32 tId = 0;
    if (decodeFromUeIdentifer(&tId,
#ifndef PDCP_GTPU_INTF
			    ueTurn_g, lcId_g))
#else
	    		    localUeTurn, localLcId))
#endif
    {
        if(lcId_g == 4)
		{
		gtp_packet[current++] = 0x34;
		}
		else
		{
        gtp_packet[current++] = 0x30;
        }
        gtp_packet[current++] = 0xff;
        gtp_packet[current++] = (length & 0xFF00)>>8;
        gtp_packet[current++] = (length & 0x00FF)>>0;
        /* Finding the Tunnel Id from Table DB */
        LTE_SET_U32BIT(&gtp_packet[current],tId);
        current +=4;
    }
    else
    {
        return VALUE_INVALID;
    }
    return current;
}
#ifdef ENDC_ENABLED
void prepareNRRanContainer(UInt16 ueId, UInt16 lcId, UInt8 *gtp_packet)
{
	UInt32 current = 0;
	UInt8 pollingreport = 0;
	if(12 == nrPdcpInfo[ueId][lcId].snSize && 
			4095 <= nrPdcpInfo[ueId][lcId].nrPdcpSn)
    {
        nrPdcpInfo[ueId][lcId].nrPdcpSn = 0;
        pollingreport = 1;
    }
    else if(18 == nrPdcpInfo[ueId][lcId].snSize &&
    		262144 <= nrPdcpInfo[ueId][lcId].nrPdcpSn)
    {
    	nrPdcpInfo[ueId][lcId].nrPdcpSn = 0;
        pollingreport = 1;

    }

        gtp_packet[current++] = 0;
        gtp_packet[current++] = 0;
        gtp_packet[current++] = 0;
        gtp_packet[current++] = 0x84;
        gtp_packet[current++] = 2;
    gtp_packet[current++] = pollingreport;
        gtp_packet[current++] = 0;
    LTE_SET_U24BIT(&gtp_packet[current],nrPdcpInfo[ueId][lcId].nrX2Sn);
        current +=3;
        LTE_SET_U24BIT(&gtp_packet[current],0);
        current +=2;
        gtp_packet[current] |= 0x80;
	if(12 == nrPdcpInfo[ueId][lcId].snSize)
	{
    gtp_packet[current++] |= ((0x0F00 & nrPdcpInfo[ueId][lcId].nrPdcpSn) >> 8);
    gtp_packet[current] |= (0xFF & nrPdcpInfo[ueId][lcId].nrPdcpSn);
    }
    else
    {
  		gtp_packet[current++] |= ((0x000F0000 & nrPdcpInfo[ueId][lcId].nrPdcpSn) >> 16);
    	gtp_packet[current++] |= ((0x0000FF00 & nrPdcpInfo[ueId][lcId].nrPdcpSn)>>8);
    	gtp_packet[current] |= (0x000000FF & nrPdcpInfo[ueId][lcId].nrPdcpSn);
    }



    nrPdcpInfo[ueId][lcId].nrPdcpSn++;
    nrPdcpInfo[ueId][lcId].nrX2Sn++;
    if(16777215 == nrPdcpInfo[ueId][lcId].nrX2Sn)
        {
        nrPdcpInfo[ueId][lcId].nrX2Sn = 0;
        }
}
#endif
/****************************************************************************
 * * Function Name  : appendMbmsGtpHeader 
 * * Inputs         : gtp_packet and length
 * * Outputs        : None
 * * Returns        : void
 * * Description    : This function append the GTP Header for Multicast packets 
 * ****************************************************************************/
void appendMbmsGtpHeader(UInt8 *gtp_packet, UInt32 length, UInt32 tId)
{
    UInt32 current = 0;
    /*UInt32 tId = 305419896;*/

    gtp_packet[current++] = 0x30;
    gtp_packet[current++] = 0xff;
    gtp_packet[current++] = (length & 0xFF00)>>8;
    gtp_packet[current++] = (length & 0x00FF)>>0;
    LTE_SET_U32BIT(&gtp_packet[current],tId);
    current +=4;
}
/* SPR 18822 Fix Start */
/****************************************************************************
 * * Function Name  : appendGtpHeaderInvalidTeid 
 * * Inputs         : gtp_packet,length
 * * Outputs        : None
 * * Returns        : gtp_packet and length
 * * Description    : This function append the GTP Header in the front of packet 
 * ****************************************************************************/
UInt32 appendGtpHeaderInvalidTeid(UInt8 *gtp_packet,UInt32 length
#ifdef PDCP_GTPU_INTF
	,UInt32 localUeTurn,UInt32 localLcId
#endif
	)
{
    UInt32 current = 0;
    UInt32 tId = 0;
    if (decodeFromUeIdentifer(&tId,
#ifndef PDCP_GTPU_INTF
			    ueTurn_g, lcId_g))
#else
	    		    localUeTurn, localLcId))
#endif
    {
        gtp_packet[current++] = 0x30;
        gtp_packet[current++] = 0xff;
        gtp_packet[current++] = (length & 0xFF00)>>8;
        gtp_packet[current++] = (length & 0x00FF)>>0;
        /* Fill invalid TEID to create Error indiation */
        if(!(invalid_teid_count %10000))
        {
            tId = 0xFFFFFFFF;
        }
        invalid_teid_count++;
        LTE_SET_U32BIT(&gtp_packet[current],tId);
        current +=4;
    }
    else
    {
        return VALUE_INVALID;
    }
    return current;
}
/* SPR 18822 Fix End */
/****************************************************************************
 * * Function Name  : createDownlinkPacket
 * * Inputs         : None
 * * Outputs        : None
 * * Returns        : diffInMicroseconds
 * * Description    : This function send the downlink packet to GTP-U
 * ****************************************************************************/
UInt8 createDownlinkPacket(UInt8 *buff,UInt32 length
#ifdef PDCP_GTPU_INTF
	,UInt32 localUeTurn,UInt32 localLcId
#endif
	)
{
    UInt32 current = 0;
    /* SPR 18822 Fix Start */
    /* Check whether Extensionheader Noti and Error indicaion Sceanrio Required by DLTG*/
#ifndef LAYER2_DLTG_THREAD    
    if(ext_hdr_prof_g == 3 || ext_hdr_prof_g == 4)
    {
        current = appendGtpHeaderInvalidTeid(buff,length
#ifdef PDCP_GTPU_INTF
			,localUeTurn, localLcId
#endif
	);
    }
    else
    {

        current = appendGtpHeader(buff,length
#ifdef PDCP_GTPU_INTF
			,localUeTurn, localLcId
#endif
	);
    }
#else
    current = appendGtpHeader(buff,length
#ifdef PDCP_GTPU_INTF
			,localUeTurn, localLcId
#endif
	);
 #endif    
    /* SPR 18822 Fix End */
    if(VALUE_INVALID == current)
    {
        return 0;
    }
    return 1;
}
#endif
/* SPR 18822 Fix Start */
#ifndef LAYER2_DLTG_THREAD
/****************************************************************************
 * * Function Name  : createExtensionHeaderNoti 
 * * Inputs         : gtp_packet,length
 * * Outputs        : None
 * * Returns        : length of buffer
 * * Description    : This function created the Extension Header Notification
 * ****************************************************************************/
UInt8 createExtensionHeaderNoti(UInt8 *gtp_packet,UInt32 length)
{
    UInt8 current = 0;

    gtp_packet[current++] = 0x32;/* GTP Header info*/
    gtp_packet[current++] = 0x1f;/* GTP Message EGTPU_MSGT_SUPP_EXT_HDR_NOTI*/
    gtp_packet[current++] = (length & 0xFF00)>>8;
    gtp_packet[current++] = (length & 0x00FF)>>0;
    /* Finding the Tunnel Id from Table DB */
    gtp_packet[current++] = 0x00;/*TEID*/
    gtp_packet[current++] = 0x00;/*TEID*/
    gtp_packet[current++] = 0x00;/*TEID*/
    gtp_packet[current++] = 0x00;/*TEID*/
    gtp_packet[current++] = 0x00;/* Spare*/
    gtp_packet[current++] = 0x00;/* Spare*/
    gtp_packet[current++] = 0x04;
    gtp_packet[current++] = 0x00;
    gtp_packet[current++] = 0x8d;/* Extension Header type list*/
    if(ext_hdr_prof_g == 4 || ext_hdr_prof_g == 2)
    {
    gtp_packet[current++] = 0x02;/* Length=n how many headers supported*/
    gtp_packet[current++] = 0xc0;/* PDCP PDU Number header supported value*/
    gtp_packet[current++] = 0x40;/* UDP Port Extension Header suppported value*/
    }
    else if(ext_hdr_prof_g == 3 || ext_hdr_prof_g == 1)
    {
        gtp_packet[current++] = 0x01;/* Length=n how many headers supported*/
        gtp_packet[current++] = 0xc0;/* PDCP PDU Number header supported value*/
    }

    return current;
}
/* SPR 18822 Fix End */

/****************************************************************************
 * * Function Name  : openUdpSocket
 * * Inputs         : None
 * * Outputs        : None
 * * Returns        : 0 on success 
 * * Description    : This function open udp socket for sending and receving
 * ****************************************************************************/

#ifndef IPV6_ENABLE
UInt32 openUdpSocket(
        UInt8 flag,
        SInt8 *dstIPAddr_p, 
        SInt8 *srcIPAddr_p,
        SInt8* sockFd_p, 
        struct sockaddr_in *sockAddr,
        UInt16 txPort )
{
#ifdef LTE_EMBMS_SUPPORTED
    /*DLTG EMBMS FIX*/
	SInt32 enabled=1;
#endif
	if(OPEN_TX_SOCKET == flag)
	{
		assert(dstIPAddr_p);
		if((*sockFd_p = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		{
			perror("SOCKET CREATION ERROR :\n");
			return 0;
		}
		if (srcIPAddr_p != NULL)
		{
			sockAddr->sin_family = AF_INET;
			sockAddr->sin_port = htons( txPort );
			//	sockAddr->sin_addr.s_addr = inet_addr(dstIPAddr_p);

			inet_pton(AF_INET, srcIPAddr_p, &sockAddr->sin_addr);
#ifdef LTE_EMBMS_SUPPORTED
    /*DLTG EMBMS FIX*/
        if(setsockopt_wrapper(*sockFd_p, SOL_SOCKET, SO_REUSEADDR, &enabled, sizeof(enabled))<0)
        {
            ltePanic("setsockopt_wrapper SO_REUSEADDR failed");
        }
#endif

			if(bind(*sockFd_p,(struct sockaddr *)sockAddr, sizeof(struct sockaddr_in)))
				printf("\nBind Failed, errno :%d\n",errno);
		}
		memset(sockAddr, 0 , sizeof(struct sockaddr_in));

		sockAddr->sin_family = AF_INET;
		sockAddr->sin_port = htons(2152);
		inet_pton(AF_INET, dstIPAddr_p, &sockAddr->sin_addr);
	}
	else if (OPEN_RX_SOCKET == flag) 
	{
		assert(srcIPAddr_p);
		if((*sockFd_p = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		{
			perror("SOCKET CREATION ERROR :\n");
			return 0;
		}
		sockAddr->sin_family = AF_INET;
		sockAddr->sin_port = htons(2152);
		sockAddr->sin_addr.s_addr = inet_addr(srcIPAddr_p);
#ifdef LTE_EMBMS_SUPPORTED
    /*DLTG EMBMS FIX*/
        if(setsockopt_wrapper(*sockFd_p, SOL_SOCKET, SO_REUSEADDR, &enabled, sizeof(enabled))<0)
        {
            ltePanic("setsockopt_wrapper SO_REUSEADDR failed");
        }
#endif
		if(bind(*sockFd_p,(struct sockaddr *)sockAddr, sizeof(struct sockaddr_in)))
			perror("Bind Failed :");
	}
	else
	{
		assert(srcIPAddr_p && dstIPAddr_p);
		if((*sockFd_p = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		{
			perror("SOCKET CREATION ERROR :\n");
			return 0;
		}
		sockAddr->sin_family = AF_INET;
		sockAddr->sin_port = htons(2152);
		sockAddr->sin_addr.s_addr = inet_addr(dstIPAddr_p);
		if((*sockFd_p = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		{
			perror("SOCKET CREATION ERROR :\n");
			return 0;
		}
		sockAddr->sin_family = AF_INET;
		sockAddr->sin_port = htons(2152);
		sockAddr->sin_addr.s_addr = inet_addr(srcIPAddr_p);
#ifdef LTE_EMBMS_SUPPORTED
    /*DLTG EMBMS FIX*/
        if(setsockopt_wrapper(*sockFd_p, SOL_SOCKET, SO_REUSEADDR, &enabled, sizeof(enabled))<0)
        {
            ltePanic("setsockopt_wrapper SO_REUSEADDR failed");
        }
#endif
		if(bind(*sockFd_p,(struct sockaddr *)sockAddr, sizeof(struct sockaddr_in)))
			abort(); 
	}
	return 1;
}

#else
UInt32 openUdpSocket (
        UInt8 flag, 
        UInt8 *dstIPAddr_p, 
        UInt8 *srcIPAddr_p,
        SInt8* sockFd_p, 
        struct sockaddr_in6 *sockAddr,
        UInt16 txPort )
{
#ifdef LTE_EMBMS_SUPPORTED
	SInt32 enabled=1;
#endif
	if(OPEN_TX_SOCKET == flag)
	{
		assert(dstIPAddr_p);
		if((*sockFd_p = socket(AF_INET6, SOCK_DGRAM, 0)) == -1)
		{
			perror("SOCKET CREATION ERROR :\n");
			return 0;
		}
        if (srcIPAddr_p != NULL)
        {
            sockAddr->sin6_family = AF_INET6;
            sockAddr->sin6_port = htons(txPort);
            inet_pton(AF_INET6, srcIPAddr_p, &sockAddr->sin6_addr);
            if(bind(*sockFd_p,(struct sockaddr *)sockAddr, sizeof(struct sockaddr_in6)))
                printf("\nBind Failed, errno :%d\n",errno);
        }
        memset(sockAddr, 0 , sizeof(struct sockaddr_in6));
		sockAddr->sin6_family = AF_INET6;
		sockAddr->sin6_port = htons(2152);
		inet_pton(AF_INET6, dstIPAddr_p, &sockAddr->sin6_addr);
	}
	else if (OPEN_RX_SOCKET == flag) 
	{
		assert(srcIPAddr_p);
		if((*sockFd_p = socket(AF_INET6, SOCK_DGRAM, 0)) == -1)
		{
			perror("SOCKET CREATION ERROR :\n");
			return 0;
		}
		sockAddr->sin6_family = AF_INET6;
		sockAddr->sin6_port = htons(2152);
		inet_pton(AF_INET6, srcIPAddr_p, &sockAddr->sin6_addr);
#ifdef LTE_EMBMS_SUPPORTED
        //ipv6 change
        if(setsockopt_wrapper(*sockFd_p, SOL_SOCKET, SO_REUSEADDR, &enabled, sizeof(enabled))<0)
        {
            ltePanic("setsockopt_wrapper SO_REUSEADDR failed");
        }
#endif
		if(bind(*sockFd_p,(struct sockaddr *)sockAddr, sizeof(struct sockaddr_in6)))
		perror("Bind Failed :");
	}
	else
	{
		assert(srcIPAddr_p && dstIPAddr_p);
		if((*sockFd_p = socket(AF_INET6, SOCK_DGRAM, 0)) == -1)
		{
			perror("SOCKET CREATION ERROR :\n");
			return 0;
		}
		sockAddr->sin6_family = AF_INET6;
		sockAddr->sin6_port = htons(2152);
		inet_pton(AF_INET6, dstIPAddr_p, &sockAddr->sin6_addr);
		if((*sockFd_p = socket(AF_INET6, SOCK_DGRAM, 0)) == -1)
		{
			perror("SOCKET CREATION ERROR :\n");
			return 0;
		}
		sockAddr->sin6_family = AF_INET6;
		sockAddr->sin6_port = htons(2152);
		inet_pton(AF_INET6, srcIPAddr_p, &sockAddr->sin6_addr);
		if(bind(*sockFd_p,(struct sockaddr *)sockAddr, sizeof(struct sockaddr_in6)))
			abort(); 
	}
	return 1;
}
#endif
#endif
/*SPR 21727 changes start*/
#ifdef PDCP_GTPU_INTF
UInt16 getLocalUeStart(UInt8 instNum)
{
    switch(instNum)
    {
        case 0:
        return start_ue_id[0];
        case 1:
        return (total_ue[0]+start_ue_id[1]);
        case 2:
        return(total_ue[0]+total_ue[1]+start_ue_id[2]) ;
    }
}
UInt16 getLocalUeCount(UInt8 instNum)
{
    switch(instNum)
    {
        case 0:
        return total_ue[0];
        case 1:
        return (total_ue[0]+total_ue[1]);
        case 2:
        return(total_ue[0]+total_ue[1]+total_ue[2]) ;
    }
}
#endif
/*SPR 21727 changes End*/
#ifndef TG_REAL_EPC
/****************************************************************************
 * * Function Name  : processULPacket
 * * Inputs         : None
 * * Outputs        : None
 * * Returns        : bytes
 * * Description    : This function process UL packets.
 * ****************************************************************************/
#ifndef  LAYER2_DLTG_THREAD
void* processULPacket(void *ipAddr)
#else
void lteMacprocessULPacketInDLTG ( UInt8 *data_p,
                UInt32 payLoadLen,
                UInt32 teid)
#endif
{
#ifdef LTE_EMBMS_SUPPORTED
    UInt16                 cellIndex = 0;
#endif
UInt16 localUeStart = 0;
UInt16 localUeCnt = 0;
    UDouble64 		        datavolume = 0;
    UInt8 			lcId = 0;
    UInt32 			diff = 0;
    UInt32 			recvdSeqNum = 0, temp_teid = 0; 
    UInt16 			i_ueId = 0xFFFF;   
    UInt16 	     		loop_counter=0;
    UInt16 	     		lc_counter=0;
    static struct timespec 	currRxTime, lastDispTime;
    UInt64 			loadCalcTimeDiff =0;
    UInt8			sector_counter = 0;
#ifndef LAYER2_DLTG_THREAD
#ifndef IPV6_ENABLE
    struct sockaddr_in 	sockAddr;
#ifdef ENDC_ENABLED
	struct sockaddr_in    sgnbRxAddr = {0};
	struct sockaddr_in    tempAddr = {0};
	SInt8 sgNBRxFd = -1;
	SInt8 temRxFd = -1;
#endif
#else
    struct sockaddr_in6 	sockAddr = {0};
#endif
    UInt32 			i_Tid;  
    SInt8 			sockRxFd = -1;
    UInt32 			addrLen =0;
    SInt32 			bytesRead =0;
    UInt8 			recvBuffer[MAX_PAYLOAD_SIZE] = {0}; 

#ifndef IPV6_ENABLE
    openUdpSocket(OPEN_RX_SOCKET,NULL,(SInt8 *)ipAddr,&sockRxFd,&sockAddr, 55353);
    addrLen = sizeof(struct sockaddr_in);
#else
    openUdpSocket(OPEN_RX_SOCKET,NULL,(UInt8 *)ipAddr,&sockRxFd,&sockAddr, 55353);
    addrLen = sizeof(struct sockaddr_in6);
#endif

    UInt32          	tId      = 0;
#ifndef NO_GTPU_STACK
    UInt32             	tId_self = 0;
#endif
    UInt8           	lcIdty   = 0;
    UInt16          	ueId     = 0;
    UInt16          	apiId    = 0;
    UInt16          	counter  = 0;
    SInt32          	selectReturn;
    fd_set          	fdSock;
    UInt8           	*dataPtr = NULL;
    struct timeval 		wTime;
    socklen_t 		addrLenTid = 0; 
    setSchedulePolicy (9,SCHED_RR);
    printf("Starting time\n");
    PRINT_TIME();
#else
#if defined(__powerpc__)
        UInt8 *tempPtr = NULL;
#endif
#endif


#ifndef LAYER2_DLTG_THREAD
    while(1)
    {
        /* FD for listening the Tid Info */
        FD_ZERO( &fdSock );
        FD_SET(sockRxFd, &fdSock );
        FD_SET(sockRxTid_g, &fdSock );
#ifdef ENDC_ENABLED
		if(-1 != sgNBRxFd)
        FD_SET(sgNBRxFd, &fdSock );
#endif
        wTime.tv_sec  = 0;
        wTime.tv_usec = 1;

        selectReturn = select( FD_SETSIZE - 1, &fdSock, 0, 0, &wTime );
        if( selectReturn < 0 )
        {
#ifdef LIPA_GW
            perror("LIPA_GTPSIM Glue Select Failed!");
#else
            perror("MU_GTPSIM Glue Select Failed!");
#endif
        }
#ifdef ENDC_ENABLED
        if( (FD_ISSET(sockRxFd, &fdSock) && (mode_g >= 1)))
        {
             temRxFd = sockRxFd;
             tempAddr = sockAddr;
        }
        
        else if (FD_ISSET(sgNBRxFd, &fdSock) && (mode_g >= 1))
        {
             temRxFd = sgNBRxFd;
             tempAddr = sgnbRxAddr;
        }
#endif

        if( FD_ISSET(sockRxTid_g, &fdSock) )
        {
            addrLenTid = sizeof(sockAddr);
            /* Rotate in while loop for receiving messages on socket */
            bytesRead = recvfrom(sockRxTid_g, recvBuffer, MAX_PAYLOAD_SIZE,
                    0,(struct sockaddr *)&sockAddr, &addrLenTid);
            if ( -1 == bytesRead )
            {
                fprintf(stderr,"UL TG read Error bytesRead = %d\n",bytesRead);
            }
#ifdef LTE_EMBMS_SUPPORTED
            if( sizeof(tgSfnCellIndex_st) == bytesRead )
            {
                 //   fprintf(stderr,"\n************[RECEIVED 1] - **********\n");
                /* tg-change --- only for multicast data */
                if(MULTICAST_DATA == uniMultiCastData_g)
                {
                    cellIndex = LTE_GET_U16BIT(&recvBuffer[2]);
/*SPR 18697 fix start*/ 
                    tgSfnCellIndexVal_g.sfn = LTE_GET_U16BIT(&recvBuffer[0]);
                    tgSfnCellIndexVal_g.cellIndex = LTE_GET_U16BIT(&recvBuffer[2]);
                    tgSfnCellIndexVal_g.currentTti = LTE_EMBMS_GET_U32BIT(&recvBuffer[4]);
/*SPR 18697 fix end*/ 
                fprintf(stderr,"\n\nReceived SFN: %d %d\n\n",tgSfnCellIndexVal_g.sfn);
                    sendMBMSTraffic();
                }
            }
            else if(bytesRead > 0 )
#else
            if(bytesRead > 0)
#endif
            {
                /* Finding the API Id */
                apiId = LTE_GET_U16BIT(&recvBuffer[6]);

                fprintf(stderr,"\n************[RECEIVED] - %d**********\n",apiId);
                if (GTPU_TID_INFO == apiId) 
                {
                    /* Ignoring 16 bytes header */
/*CA changes start*/
                    dataPtr = recvBuffer + INTERFACE_API_HEADER_LEN;
/*CA changes end*/

                    /* Getting into correct postion */
                    counter = 0;

#ifndef NO_GTPU_STACK
                    tId_self = LTE_GET_U32BIT(&dataPtr[counter]);
                    fprintf(stderr,"\nGLUE TID_SELF [%d]\n",tId_self);
                    counter += 4;
#endif
                    /* Getting the tunel Id */
                    tId = LTE_GET_U32BIT(&dataPtr[counter]);
                    fprintf(stderr,"GLUE TID_PEER [%d]\n",tId);
                    counter += 4;

                    /* SPR 18822 Fix Start */
                    ext_hdr_noti_g =1;
                    /* SPR 18822 Fix End */
                    /* Getting the ueId */
                    ueId = LTE_GET_U16BIT(&dataPtr[counter]);
                    counter += 2;

/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
/*code removed*/
/*SPR 21653 changes end*/
                    fprintf(stderr,"GLUE UE ID [%d]\n",ueId);

                    /* Getting lc Id */
                    lcIdty = dataPtr[counter];
#ifdef ENDC_ENABLED
                    counter++;
					struct sockaddr_in locateAdd;
					struct in_addr ip_addr;
				    locateAdd = sockAddr_g;
				    SInt8       *temp = NULL;
                    bearType[ueId][lcIdty] = dataPtr[counter++];
                    nrPdcpInfo[ueId][lcIdty].snSize = dataPtr[counter++];
                    if(12 == nrPdcpInfo[ueId][lcIdty].snSize)
                    {
                    	nrPdcpInfo[ueId][lcIdty].containerLen = 14;
                    	nrPdcpInfo[ueId][lcIdty].dataOffset = 22;
                    }
                    else if(18 == nrPdcpInfo[ueId][lcIdty].snSize)
                    {
 						nrPdcpInfo[ueId][lcIdty].containerLen = 15;
                    	nrPdcpInfo[ueId][lcIdty].dataOffset = 23;

                    }
                    if((bearType[ueId][lcIdty]) == SCG_SPLIT_BEARER && (bytesRead > 30))
                    {
    				    ip_addr.s_addr = LTE_GET_U32BIT(&dataPtr[counter]);
                        counter += 4;
    				    temp = inet_ntoa(ip_addr);
    				    if(temp != sgnbIpAddr_g)
    				    {
    				    	sgnbIpAddr_g = temp;
    				    	openUdpSocket(OPEN_TX_SOCKET,(UInt8 *)&locateAdd, sgnbIpAddr_g,&sgnbTxFd_g,&locateAdd, 55353);
    						openUdpSocket(OPEN_RX_SOCKET,NULL,sgnbIpAddr_g,&sgNBRxFd,&sgnbRxAddr, 55353);

    				    }
                    }
                    if(0xFFFFFFFF == tId_self)
                    bearType[ueId][lcIdty] = INVALID_BEARER;
                    

#endif              
                    fprintf(stderr,"GLUE LC ID [%d]\n",lcIdty);

/* + SPR 8669 Fix*/
                    if ( 0xFFFFFFFF == tId_self )
                    {
                    	if( 0 == deleteRecordFromTable(tId, ueId, lcIdty) )
                        {
                            /* Adding the information in gtpSim Data base */
#ifndef NO_GTPU_STACK
                            addRecordToTable(tId_self,tId,ueId,lcIdty);
#else
                            addRecordToTable(tId,ueId,lcIdty);
#endif
                        }
                    }
                    else
                    { 
/* - SPR 8669 Fix*/
 
                    /* Adding the information in gtpSim Data base */
#ifndef NO_GTPU_STACK
                    addRecordToTable(tId_self,tId,ueId,lcIdty);
#else
                    addRecordToTable(tId,ueId,lcIdty);
#endif
/* + SPR 8669 Fix*/
                    }
/* - SPR 8669 Fix*/
                }
                else if (GTPU_UE_INFO_FOR_DEL == apiId)
                {

                    /* Ignoring 10 bytes header */
                    /* SPR 4806 FIX */
/*CA changes start*/
                    dataPtr = recvBuffer + INTERFACE_API_HEADER_LEN;
/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
/*code removed*/
/*SPR 21653 changes end*/
/*CA changes end*/
                    /* SPR 4806 FIX */

                    /* Getting into correct postion */
                    counter = 0;

                    /* Getting the ueId */
                    ueId = LTE_GET_U16BIT(&dataPtr[counter]);
                    counter += 2;

                    fprintf(stderr,"GLUE UE ID [%d] for RELEASE \n",ueId);

                    if(!deleteInfoInDb(ueId))
                    {
                        fprintf(stderr,"UE [%d] is not Admitted\n",ueId);
                    }
                }
                else
                {
                    fprintf(stderr,"GLUE--->Wrong API Id[%d]\n",apiId);
                }
            }
        }

#ifndef ENDC_ENABLED
        if( FD_ISSET(sockRxFd, &fdSock) && (mode_g >= 1))
#else

        if(FD_ISSET(temRxFd, &fdSock) && (mode_g >= 1))
#endif
        {
#ifndef ENDC_ENABLED
            bytesRead = recvfrom(sockRxFd, recvBuffer, MAX_PAYLOAD_SIZE, 0,
                    (struct sockaddr *)&sockAddr, &addrLen);
#else
	       bytesRead = recvfrom(temRxFd, recvBuffer, MAX_PAYLOAD_SIZE, 0,
                    (struct sockaddr *)&tempAddr, &addrLen);

#endif
            if ( bytesRead == -1  || bytesRead == 0)
            {
                fprintf(stderr,"UL TG read Error bytesRead = %d\n",bytesRead);
            }
            memcpy ( &recvdSeqNum, (recvBuffer + bytesRead - 4), 4);  

            if(bytesRead > 0)
            {
#ifndef NO_GTPU_STACK
                i_Tid = LTE_GET_U32BIT(&recvBuffer[4]);
#else
                i_Tid = LTE_GET_U32BIT(&recvBuffer[3]);
#endif
#else
            if(payLoadLen)
	    {
#ifdef L2_FAST_PATH
		    msgExtract(data_p, (payLoadLen -4), (UInt8*)(&recvdSeqNum), 4);
#else
		    memCpy(&recvdSeqNum,(data_p + payLoadLen - 4),4);
#endif
#if defined(__powerpc__)
		    tempPtr = (UInt8 *)&recvdSeqNum;
		    recvdSeqNum =  LTE_GET_U32BIT(tempPtr);
#endif
#endif
#ifdef LAYER2_DLTG_THREAD
		    temp_teid = teid;
#else
		    temp_teid = i_Tid;
#endif
                    /* ECHO support in TG */
		    if (temp_teid == 0)
		    {
			    /* Handle the Echo Req/resp from eNB */
#ifndef LAYER2_DLTG_THREAD
			    UInt8 echoBuffer[128] = {0};
			    UInt32 current = 0;
			    SInt32 bytesSend = 0;

			    echoBuffer[current++] = 0x32;
			    echoBuffer[current++] = 0x02;
			    echoBuffer[current++] = (6 & 0xFF00)>>8;
			    echoBuffer[current++] = (6 & 0x00FF)>>0;
			    /* Filling the Tunnel Id = 0, buffer already memset to 0 */
			    current +=4;

			    /* Filling the SN = 0, buffer already memset to 0 */
			    current +=2;

			    /* Filling the N(PDU) = 0, from req buffer */
			    echoBuffer[current++] = recvBuffer[current];

			    /* Filling the ext = 0, buffer already memset to 0 */
			    current +=1;

			    echoBuffer[current++] = 0x0e;
			    echoBuffer[current++] = 0x00;

			    /* Copy the echo request message in response */
			    bytesSend = sendto(sockTxFd_g, echoBuffer, current, 0,
					    (struct sockaddr*)&sockAddr_g, sizeof(struct sockaddr_in));

			    if ( bytesSend == -1 )
			    {
				    fprintf(stderr,"\nDL TG send to failed\n");
			    }
#else
			#ifdef PRINT
			    fprintf(stderr,"\n***Echo req handling not supported in TG****\n");
			#endif 
#endif
                            /* ECHO support in TG */
		    }
		    else if (!decodeFromTunnelIdentifer(temp_teid,&i_ueId,&lcId))
		    {
			    fprintf(stderr,"\n Invalid Tunnel Id teid %d\n", temp_teid);
		    }
		    /*SPR 21836 Changes Start*/
		    if(i_ueId < sectorDb_g.ueCount)
		    {
			    /* AUTOMATION_DLTG */
#ifdef AUTOMATION_DLTG
			    ulTrafficRcv = 1;
#endif
			    /* AUTOMATION_DLTG */
			    sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxPkts++;
#ifndef LAYER2_DLTG_THREAD 
			    sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxData += 
				    (bytesRead - GTP_HDR);
#else
			    sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxData +=
				    (payLoadLen - GTP_HDR);
#endif
		    }
#ifdef LAYER2_DLTG_THREAD
	    }
#else
            }
#endif
            if(i_ueId < sectorDb_g.ueCount)
            {
                if((sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxSeq !=
                            recvdSeqNum))
                {
                    if(MissCntrs_g)
                        fprintf(MissCntrs_g,"\n [%01x] ==>[0x%04x != 0x%04x][0x%04x/0x%04x],%d",
                                i_ueId,
                                sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxSeq,
                                recvdSeqNum,
                                sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxMiss,
                                sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxPkts,
                                recvdSeqNum - 
                                sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxSeq);

                    if((firstBlockReceived_dltg[i_ueId][lcId])&& 
                            ((recvdSeqNum - sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxSeq)<1000))
                    {
                        sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxMiss += 
                            (recvdSeqNum - sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxSeq);
                        /*SPR 3323 & 2987 Fix*/
                        sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxMiss_per_display+= 
                            (recvdSeqNum - sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxSeq);
                        /*SPR 3323 & 2987 Fix*/
                    }
                    else
                    {
                        sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxMiss++;
                        /*SPR 3323 & 2987 Fix*/
                        sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxMiss_per_display++;
                        /*SPR 3323 & 2987 Fix*/
                    }
                    sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxSeq = recvdSeqNum + 1;
                }
                else
                {
                    sectorDb_g.ueDataFlow_g[i_ueId][lcId].rxSeq++;
                }
                firstBlockReceived_dltg[i_ueId][lcId]= 1;
            }
/*SPR 21836 Changes End*/
#ifndef LAYER2_DLTG_THREAD 
            datavolume += bytesRead;
#else
            datavolume += payLoadLen;
#endif

            clock_gettime(CLOCK_REALTIME,&currRxTime);
            loadCalcTimeDiff = ((currRxTime.tv_sec - lastDispTime.tv_sec)*1000 +
                    ((currRxTime.tv_nsec - lastDispTime.tv_nsec)/1000000));
            diff = (UInt32)loadCalcTimeDiff;
           
            /*SPR 21727 changes start*/
#ifdef PDCP_GTPU_INTF
            localUeStart=localUeCnt=0;
#endif
/*SPR 21836 Changes Start*/
/*Code Removed*/
/*SPR 21836 Changes End*/
            {
#ifdef PDCP_GTPU_INTF
		    UInt8 instCount=0;
		    for(instCount=0;instCount<num_instance;instCount++)
		    {
                UInt16 dataUe = 0;
                localUeStart = getLocalUeStart(instCount);
                localUeCnt = getLocalUeCount(instCount);
#endif                 
                /*20868 +*/
#ifdef PDCP_GTPU_INTF
                for(loop_counter=localUeStart;(loop_counter< localUeCnt)&&(dataUe<num_of_data_ue[instCount]);loop_counter++)
#else
                    for(loop_counter=ueStart_g;loop_counter< ueId_g;loop_counter++)
#endif
                /*20868 -*/
                {
#ifdef PDCP_GTPU_INTF

                    if(isDataToSchedule(data_to_pump[sector_counter],localUeCnt))
                    {		
                        dataUe++;
#endif
/*SPR 21836 Changes Start*/
                    for(lc_counter= 0;lc_counter < sectorDb_g.gtpDb_g[loop_counter].lcCnt; lc_counter++)
                    {
                        if(sectorDb_g.gtpDb_g[loop_counter].rbInfo[lc_counter].tId_self != 0)
                        {	
                            if (loadCalcTimeDiff >= (throughputDisplayVar_g/timeInMs_g))
                            {
                                /* SPR 20441 Changes Start*/
                                datavolume *= 1000;
                                /* SPR 20441 Changes End*/
                                datavolume *= 8;
                                datavolume /= diff;

                                MbPS_LOAD(sector_counter,
                                        loop_counter,
                                        sectorDb_g.gtpDb_g[loop_counter].rbInfo[lc_counter].lcId);
                                datavolume =0;
                                sectorDb_g.gtpDb_g[loop_counter].rbInfo[lc_counter].lastDisplayTick=
                                    sectorDb_g.gtpDb_g[loop_counter].rbInfo[lc_counter].txTickCount;
                                lastDispTime.tv_sec = currRxTime.tv_sec;
                                lastDispTime.tv_nsec = currRxTime.tv_nsec;
                            }
                        }
                    }
/*SPR 21836 Changes End*/
#ifdef PDCP_GTPU_INTF
                    }
#endif

#ifdef PDCP_GTPU_INTF
                    else 
                        continue ;
#endif
                }
            }
#ifdef PDCP_GTPU_INTF
}
#endif
                    /*SPR 21727 changes end*/
#ifndef  LAYER2_DLTG_THREAD
        }
    }
    return NULL;
#endif
}
#endif

#ifndef TG_REAL_EPC
/******************************************************************/
/* Function to vary the IPID value in IP Header */
/* +- SPR 18268 */
void setIPIDinIPPkt(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
#ifndef UE_IPV6_ADDR
#ifdef  LAYER2_DLTG_THREAD
    UInt16 headerStart = START_OFFSET_DL_GTP+8, ipid = 0, ipid_lsb;
#else
    UInt16 headerStart = 8, ipid = 0, ipid_lsb;
#endif
    UInt16          ipChecksum = 0;
    /* if RoHC test enhancements set */
    if (IPIDValueChange_g)
    {
        /* Set IPID value in IP header and increment by 1 */
        sendBuffer[headerStart+4] = ( gtpDb_g[ueIndex].rbInfo[lcIndex].ipId_ip >> 8) & 0xFF;
        sendBuffer[headerStart+5] =  gtpDb_g[ueIndex].rbInfo[lcIndex].ipId_ip & 0xFF;

        /* Generate new IP-ID field */
        // RANDOM
        if (IPIDValueChange_g == 1)
        {
          ipid = (UInt16)random();
        }
        // Sequence
        else if (IPIDValueChange_g == 2)
        {
          ipid = gtpDb_g[ueIndex].rbInfo[lcIndex].ipId_ip + 1;
        }
        // Byte Swapped but in sequence
        else if (IPIDValueChange_g == 3)
        {
          ipid = gtpDb_g[ueIndex].rbInfo[lcIndex].ipId_ip;
          ipid_lsb= ipid & 0xFF;
          ipid = ((ipid >> 8) & 0xFF) | ((ipid_lsb << 8) & 0xFF00);
          ipid++;
          ipid_lsb= ipid & 0xFF;
          ipid = ((ipid >> 8) & 0xFF) | ((ipid_lsb << 8) & 0xFF00);
        }
        ipChecksum =  ipCksumCalc( 20, sendBuffer, headerStart);
        sendBuffer[headerStart+10 ] = (ipChecksum >>8) & (0xFF);
        sendBuffer[headerStart+11] = (ipChecksum & 0xFF);

        gtpDb_g[ueIndex].rbInfo[lcIndex].ipId_ip = ipid;
    }
    /* otherwise no changes */
#endif
    return;
}
/****************************************************************************************************************/
/* Function to vary the TS and SN values */
/* +- SPR 18268 */
void setSNnTSinRTPPkt(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
#ifdef ROHC_PROFILE_1
#ifdef  LAYER2_DLTG_THREAD
    UInt16 headerStart = START_OFFSET_DL_GTP + 8;
#else
    UInt16 headerStart = 8;
#endif
    UInt8 version = (sendBuffer[headerStart] >> 4) & 0xF;

    /* Add IP and UDP header length */
    if(version == 4)
    {
        headerStart = headerStart + 20 + 8;
    }
    else /* IPv6 */
    {
        headerStart = headerStart + 40 + 8;
    }

    if (TSandSNValueChange_g == 1)
    {
        /* Set SN value in RTP header and increment the SN by 1 in RTP header */
        sendBuffer[headerStart+2] = ( gtpDb_g[ueIndex].rbInfo[lcIndex].sn_rtp >> 8) & 0xFF;
        sendBuffer[headerStart+3] =  gtpDb_g[ueIndex].rbInfo[lcIndex].sn_rtp & 0xFF;

        /* Set TS value in RTP header and increment the TS by TS_PERIOD in RTP header */
        sendBuffer[headerStart+4] = (gtpDb_g[ueIndex].rbInfo[lcIndex].ts_rtp >> 24) & 0xFF;
        sendBuffer[headerStart+5] = (gtpDb_g[ueIndex].rbInfo[lcIndex].ts_rtp >> 16) & 0xFF;
        sendBuffer[headerStart+6] = (gtpDb_g[ueIndex].rbInfo[lcIndex].ts_rtp >> 8) & 0xFF;
        sendBuffer[headerStart+7] = gtpDb_g[ueIndex].rbInfo[lcIndex].ts_rtp & 0xFF;

        gtpDb_g[ueIndex].rbInfo[lcIndex].sn_rtp++;
        gtpDb_g[ueIndex].rbInfo[lcIndex].ts_rtp += TS_PERIOD;
    }
#endif
    return;
}

/*Inserting data part in packet after TCP options*/
    /* +- SPR 18268 */
void addDataAtEnd(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
    #ifdef ROHC_PROFILE_6
    #ifdef  LAYER2_DLTG_THREAD
    UInt16 headerStart = START_OFFSET_DL_GTP+8;
    #else
    UInt16 headerStart = 8;
    #endif
    UInt8 version = (sendBuffer[headerStart] >> 4) & 0xF;
    UInt8 offset = 0;
    UInt8 pos = 0, maxPos = 0;
    /* Add IP header length */
    if(version == 4)
    {
        headerStart = headerStart + 20;
    }
    else /* IPv6 */
    {
        headerStart = headerStart + 40;
    }
    offset = ((sendBuffer[headerStart + 12]>>4)*4);
    pos = headerStart + offset;
    maxPos = pos +10;
    sendBuffer[pos++] = 0x61;
    sendBuffer[pos++] = 0x6e;
    sendBuffer[pos++] = 0x69;
    sendBuffer[pos++] = 0x6c;
    while(pos != maxPos)
    {
        sendBuffer[pos++] = 0x00;
    }
    #endif
}


/* Function to call control flow functions for TCP header */
    /* +- SPR 18268 */
void controlflowCallforTCP(UInt16 ueIndex, UInt8 lcIndex,UInt8 sendBuffer[], UInt32 bytes)
    /* +- SPR 18268 */
{
#ifdef ROHC_PROFILE_6
        /* Set SYN and ACK fields in TCP header */
        setSYNnACKinTCPPkt(ueIndex, lcIndex, sendBuffer, bytes);

#endif
    return;
}

/* Function to set SYN and ACK fields in TCP header */
    /* +- SPR 18268 */
void setSYNnACKinTCPPkt(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[], UInt32 bytes)
    /* +- SPR 18268 */
{
#ifdef ROHC_PROFILE_6
#ifdef  LAYER2_DLTG_THREAD
    UInt16 headerStart = START_OFFSET_DL_GTP + GTP_HDR;
#else
    UInt16 headerStart = GTP_HDR;
#endif
	UInt8 version = (sendBuffer[headerStart] >> 4) & 0xF;
	UInt8 flag = 0;
	static UInt32 counter = 0;
        if (counter == 0)
        {
            gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp = 0; /* FOR FIRST PACKET */
            gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes = 0;
        }

	/* Add IP header length */
	if(version == 4)
	{
		headerStart = headerStart + 20;
	}
	else /* IPv6 */
	{
		headerStart = headerStart + 40;
	}

	if (COUNTDOWN == gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp)
	{
		if (1 != profile6Params_g.isFin)
		{
			gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp++;
		}
	}


	/* if UL is the initiator for a TCP connection */
	if (1 == profile6Params_g.isInitiator)
	{
		if (0 == gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp)
		{
			/* Set SYN flag in TCP header */
			sendBuffer[headerStart+13] =  0x02;
			gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes += gtpDb_g[ueIndex].rbInfo[lcIndex].packet_size[0];
		}
		else
		{
			if (1 == gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp)
			{
				/* Set ACK flag in TCP header */
				sendBuffer[headerStart+13] = 0x10;
				gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes += gtpDb_g[ueIndex].rbInfo[lcIndex].packet_size[0];
			}
		}
	}
	else
	{
		if (0 == gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp)
		{
			/* Set ACK and SYN flags in TCP header */
			sendBuffer[headerStart+13] = 0x12;
			/* ACK byte increameneted by one */
			//sendBuffer[headerStart+11]++;
			gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes += gtpDb_g[ueIndex].rbInfo[lcIndex].packet_size[0];
		}
	}
	if (COUNTDOWN <= gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp)
	{
		switch(gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp)
		{
			case COUNTDOWN:
				/* Set FIN flag in TCP header */
				sendBuffer[headerStart+13] =  0x01;
				gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp += 2;
				break;
			case COUNTDOWN+1:
				/* Set ACK flag in TCP header */
				sendBuffer[headerStart+13] =  0x10;
				break;
			case COUNTDOWN+2:
				/* Set FIN flag in TCP header */
				sendBuffer[headerStart+13] =  0x01;
				flag = 1;
				break;
			case COUNTDOWN+3:
				/* Set ACK flag in TCP header */
				sendBuffer[headerStart+13] =  0x10;
				flag = 1;
				break;
		}
	}
	else
	{
		/* Data Part of TCP */
		sendDATAinTCPPkt(ueIndex, lcIndex, sendBuffer, bytes, counter);
	}
        /* ADDING OPTIONS IN TCP PACKET START */
	if(1 == counter)
	{
		/* change window scale option */
		sendBuffer[headerStart+39] =  0x08;
	}
	if( counter >= 10 && counter <50)
	{
		/* set SACK option in tcp header */
		sendBuffer[headerStart+40] =  0x05; /*sack kind*/
		sendBuffer[headerStart+41] =  0x0a; /*sack length*/
		UInt32 ref_val;
		UInt8 offset;

		memcpy(&ref_val,&sendBuffer[headerStart+8],4);
		ref_val = ntohl(ref_val);
		ref_val = ref_val + 0x1f4;
		ref_val = ntohl(ref_val);
		memcpy(&sendBuffer[headerStart+42],&ref_val,4);
		ref_val = ntohl(ref_val);
		ref_val = ref_val + 0x1f4;
		ref_val = ntohl(ref_val);
		memcpy(&sendBuffer[headerStart+46],&ref_val,4);

		/* set EOL option */
		sendBuffer[headerStart+50] = 0x00;
		sendBuffer[headerStart+51] = 0x00;
		if(10 == counter)
		{	
			/* set new data offset */
			offset = (sendBuffer[headerStart+12]&0xf0)>>4;
			offset = offset + 3;
			sendBuffer[headerStart+12] &= 0x0f;
			sendBuffer[headerStart+12]|= offset <<4;
		}
		if(counter >=20 && counter <30)
		{
			/* set 2 SACK blocks */
			sendBuffer[headerStart+41] =  0x12; /*sack length*/
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4;
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+50],&ref_val,4);
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4;
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+54],&ref_val,4);
			/* adjust EOL option */
			sendBuffer[headerStart+58] = 0x00;
			sendBuffer[headerStart+59] = 0x00;
			/* change data offset value */

			if(20 == counter)
			{
				offset = (sendBuffer[headerStart+12]&0xf0)>>4;
				offset = offset + 2;
				sendBuffer[headerStart+12] &= 0x0f;
				sendBuffer[headerStart+12]|= offset <<4;
			}
		}
		if(counter >=30)
		{
			/* List structure changes and 3 SACK blocks+ 2 EOL  are sent */
			offset = 12;
			sendBuffer[headerStart+12] &= 0x0f;
			sendBuffer[headerStart+12]|= offset <<4;
			/* set SACK option in tcp header */
			sendBuffer[headerStart+20] =  0x05; /*sack kind*/
			sendBuffer[headerStart+21] =  0x1a; /*sack length*/

			memcpy(&ref_val,&sendBuffer[headerStart+8],4);
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4;
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+22],&ref_val,4);

			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4;
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+26],&ref_val,4);
			/* 2nd sack block */
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4;
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+30],&ref_val,4);
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4;
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+34],&ref_val,4);
			/* 3rd sack block */
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4;
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+38],&ref_val,4);
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4;
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+42],&ref_val,4);
			/* set EOL option */
			sendBuffer[headerStart+46] = 0x00;
			sendBuffer[headerStart+47] = 0x00;
			if(counter >=40)
			{
				/* send 4 sack blocks */
				sendBuffer[headerStart+21] =  0x22; /*sack length*/
				/* set 4th SACK Block */
				ref_val = ntohl(ref_val);
				ref_val = ref_val + 0x1f4;
				ref_val = ntohl(ref_val);
				memcpy(&sendBuffer[headerStart+46],&ref_val,4);
				ref_val = ntohl(ref_val);
				ref_val = ref_val + 0x1f4;
				ref_val = ntohl(ref_val);
				memcpy(&sendBuffer[headerStart+50],&ref_val,4);

				/* set EOL option */
				sendBuffer[headerStart+54] = 0x00;
				sendBuffer[headerStart+55] = 0x00;
				/* set updated offset*/
				offset = 14;
				sendBuffer[headerStart+12] &= 0x0f;
				sendBuffer[headerStart+12]|= offset <<4;
			}
		}
		if(counter <30)
		{
			/* change TS option */
			ref_val = 0;
			memcpy(&ref_val,&sendBuffer[headerStart+28],4);
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x3e8; /* increment ts val by 1000*/
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+28],&ref_val,4);
			/* change ts echo */
			ref_val = 0;
			memcpy(&ref_val,&sendBuffer[headerStart+32],4);
			ref_val = ntohl(ref_val);
			ref_val = ref_val + 0x1f4; /* increment ts echo by 500*/
			ref_val = ntohl(ref_val);
			memcpy(&sendBuffer[headerStart+32],&ref_val,4);
		}
	}
	if(counter >= 50 )
	{
		/* List structure changes TS+SACK PERMITTED+SACK+ALTERNATE CKSUM REQ+WS */
		UInt8 offset;
		UInt32 ts_val = 0x10023890;
		UInt32 ts_echo = 0xc20fb5b4;
		ts_val = ntohl(ts_val);
		ts_echo = ntohl(ts_echo);
		offset = 12;
		sendBuffer[headerStart+12] &= 0x0f;
		sendBuffer[headerStart+12]|= offset <<4;
		/* set TS option */
		sendBuffer[headerStart+20] =  0x08; /* TS kind*/
		sendBuffer[headerStart+21] =  0x0a; /* TS length*/
		memcpy(&sendBuffer[headerStart+22],&ts_val,4);
		memcpy(&sendBuffer[headerStart+26],&ts_echo,4);
		/* set SACK Permitted option */
		sendBuffer[headerStart+30] =  0x04; /* SP kind*/
		sendBuffer[headerStart+31] =  0x02; /* SP length*/
		/* set SACK option */
		sendBuffer[headerStart+32] =  0x05; /*sack kind*/
		sendBuffer[headerStart+33] =  0x0a; /*sack length*/
		UInt32 ref_val;
		memcpy(&ref_val,&sendBuffer[headerStart+8],4);
		ref_val = ntohl(ref_val);
		ref_val = ref_val + 0x1f4;
		ref_val = ntohl(ref_val);
		memcpy(&sendBuffer[headerStart+34],&ref_val,4);
		ref_val = ntohl(ref_val);
		ref_val = ref_val + 0x1f4;
		ref_val = ntohl(ref_val);
		memcpy(&sendBuffer[headerStart+38],&ref_val,4);
		/* set ALternate CKSUM REQUEST Option */
		sendBuffer[headerStart+42] =  0x0e; /* ALT CKSUM REQ kind*/
		sendBuffer[headerStart+43] =  0x03; /* ALT CKSUM REQ length*/
		sendBuffer[headerStart+44] =  0x21; /* value */

		/* set window scale Option */
		sendBuffer[headerStart+45] =  0x03; /* WS kind*/
		sendBuffer[headerStart+46] =  0x03; /* WS length*/
		sendBuffer[headerStart+47] =  0x24; /* value */
		if(counter >= 60 && counter <70)
		{
			/* add alt cksum data + eol option */
			sendBuffer[headerStart+45] =  0x0f; /* ALT CKSUM DATA kind*/
			sendBuffer[headerStart+46] =  0x04; /* ALT CKSUM DATA length*/
			sendBuffer[headerStart+47] =  0x17; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+48] =  0x18; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+49] =  0x00; /* EOL KIND */
			sendBuffer[headerStart+50] =  0x00;
			sendBuffer[headerStart+51] =  0x00;
			/* set new offset */
			offset = 13;
			sendBuffer[headerStart+12] &= 0x0f;
			sendBuffer[headerStart+12]|= offset <<4;
		}

		if(counter >= 70 && counter < 80)
		{
			/* add alt cksum data with changed length + eol option */
			sendBuffer[headerStart+45] =  0x0f; /* ALT CKSUM DATA kind*/
			sendBuffer[headerStart+46] =  0x06; /* ALT CKSUM DATA length*/
			sendBuffer[headerStart+47] =  0x17; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+48] =  0x18; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+49] =  0x19; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+50] =  0x20; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+51] =  0x00; /* EOL KIND */
			sendBuffer[headerStart+52] =  0x00;
			sendBuffer[headerStart+53] =  0x00;
			sendBuffer[headerStart+54] =  0x00;
			sendBuffer[headerStart+55] =  0x00;
			/* set new offset */
			offset = 14;
			sendBuffer[headerStart+12] &= 0x0f;
			sendBuffer[headerStart+12]|= offset <<4;
		}
		if(counter >= 80 && counter <90)
		{
			/* rainy day case: add one more generic option other than 2 known ones
			 * with kind 16 */
			sendBuffer[headerStart+45] =  0x0f; /* ALT CKSUM DATA kind*/
			sendBuffer[headerStart+46] =  0x06; /* ALT CKSUM DATA length*/
			sendBuffer[headerStart+47] =  0x17; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+48] =  0x18; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+49] =  0x19; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+50] =  0x20; /* ALT CKSUM DATA value */
			sendBuffer[headerStart+51] =  0x10; /* generic opt kind 16 */
			sendBuffer[headerStart+52] =  0x04;
			sendBuffer[headerStart+53] =  0x30;
			sendBuffer[headerStart+54] =  0x31;
			sendBuffer[headerStart+55] =  0x00; /* EOL KIND */
			sendBuffer[headerStart+56] =  0x00;
			sendBuffer[headerStart+57] =  0x00;
			sendBuffer[headerStart+58] =  0x00;
			sendBuffer[headerStart+59] =  0x00;
			/* set new offset */
			offset = 15;
			sendBuffer[headerStart+12] &= 0x0f;
			sendBuffer[headerStart+12]|= offset <<4;
		}
		if(counter >= 90)
		{
			/* change structure of options and add NOP also in between */

			sendBuffer[headerStart+45] =  0x01; /* NOP kind*/
			sendBuffer[headerStart+46] =  0x10; /* gen opt kind 16*/
			sendBuffer[headerStart+47] =  0x03; 
			sendBuffer[headerStart+48] =  0x18; 
			sendBuffer[headerStart+49] =  0x01; /* NOP kind */
			sendBuffer[headerStart+50] =  0x0f; /* ALT CKSUM DATA kind */
			sendBuffer[headerStart+51] =  0x06; 
			sendBuffer[headerStart+52] =  0x04; 
			sendBuffer[headerStart+53] =  0x30; 
			sendBuffer[headerStart+54] =  0x31; 
			sendBuffer[headerStart+55] =  0x00; 
			/* set new offset */
			offset = 14;
			sendBuffer[headerStart+12] &= 0x0f;
			sendBuffer[headerStart+12]|= offset <<4;
			if(95 == counter)
			{
				/* chnage value of generic option */

				sendBuffer[headerStart+48] =  0x19; 
				sendBuffer[headerStart+52] =  0x05; 
				sendBuffer[headerStart+53] =  0x31; 
				sendBuffer[headerStart+54] =  0x32; 
				sendBuffer[headerStart+55] =  0x01; 
			}
		}
	}
        /* ADDING OPTIONS IN TCP PACKET END */
        addDataAtEnd(ueIndex,lcIndex,sendBuffer);
	gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp++;
	counter++;

	if (1 == flag)
	{
		/* Reset the value so that again TCP connection procedure starts */
		gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp = 0;
		gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes = 0;
        counter = 0;
		/* Reset of Connection */
	}
	return;
#endif
}

/* TO CHANGE SN more than 16bits */
    /* +- SPR 18268 */
void setAckNum_morethan16bits(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
    UInt32 ACKvalue = 0;
    UInt32 *sendBuffer_p;
    sendBuffer_p = (UInt32 *)&sendBuffer[0];
    *sendBuffer_p = ntohl(*sendBuffer_p);
    ACKvalue = 131072  + *sendBuffer_p;
    /* Set SN field of the TCP header */
    sendBuffer[0] = (ACKvalue >> 24) & 0xFF;
    sendBuffer[1] = (ACKvalue >> 16) & 0xFF;
    sendBuffer[2] = (ACKvalue >> 8) & 0xFF;
    sendBuffer[3] = (ACKvalue) & 0xFF;
}

/* TO CHANGE SN more than 16bits */
    /* +- SPR 18268 */
void setSeqNum_morethan16bits(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
    UInt32 SNvalue = 0;
    UInt32 *sendBuffer_p;
    sendBuffer_p = (UInt32 *)&sendBuffer[0];
    *sendBuffer_p = ntohl(*sendBuffer_p);
    SNvalue = 131072  + *sendBuffer_p;
    /* Set SN field of the TCP header */
    sendBuffer[0] = (SNvalue >> 24) & 0xFF;
    sendBuffer[1] = (SNvalue >> 16) & 0xFF;
    sendBuffer[2] = (SNvalue >> 8) & 0xFF;
    sendBuffer[3] = (SNvalue) & 0xFF;
}

/* +- SPR 18268 */
void setUnscaledSeqNum(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
    UInt32 unScaledSNvalue = 0;
    UInt32 *sendBuffer_p;
    sendBuffer_p = (UInt32 *)&sendBuffer[0];
    *sendBuffer_p = ntohl(*sendBuffer_p);
    unScaledSNvalue = gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes + *sendBuffer_p;
    /* Set SN field of the TCP header */
    sendBuffer[0] = (unScaledSNvalue >> 24) & 0xFF;
    sendBuffer[1] = (unScaledSNvalue >> 16) & 0xFF;
    sendBuffer[2] = (unScaledSNvalue >> 8) & 0xFF;
    sendBuffer[3] = (unScaledSNvalue) & 0xFF;
}

    /* +- SPR 18268 */
void setScaledSeqNum(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
    UInt32 scaledSNvalue = 0;
    UInt32 *sendBuffer_p;
    UInt8   ipHeaderLen = 20; /*FOR IPV4 (need to change for IPV6)*/
    sendBuffer_p = (UInt32 *)&sendBuffer[0];
    *sendBuffer_p = ntohl(*sendBuffer_p);
#ifdef LAYER2_DLTG_THREAD
    scaledSNvalue = gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes - (START_OFFSET_DL_GTP +GTP_HDR + ipHeaderLen + ((sendBuffer[8]>>4)*4));
#else    
    scaledSNvalue = gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes - (GTP_HDR + ipHeaderLen + ((sendBuffer[8]>>4)*4));
#endif    
    scaledSNvalue += *sendBuffer_p;
    /* Set SN field of the TCP header */
    sendBuffer[0] = (scaledSNvalue >> 24) & 0xFF;
    sendBuffer[1] = (scaledSNvalue >> 16) & 0xFF;
    sendBuffer[2] = (scaledSNvalue >> 8) & 0xFF;
    sendBuffer[3] = (scaledSNvalue) & 0xFF;
}

    /* +- SPR 18268 */
void setUnscaledAckNum(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
    UInt32 *sendBuffer_p;
    UInt32 unScaledAckValue = 0;
    sendBuffer_p = (UInt32 *)&sendBuffer[0];
    *sendBuffer_p = ntohl(*sendBuffer_p);
    unScaledAckValue = (*sendBuffer_p + gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes ) + (*sendBuffer_p % 10);
    sendBuffer[0] = (unScaledAckValue >> 24) & 0xFF;
    sendBuffer[1] = (unScaledAckValue >> 16) & 0xFF;
    sendBuffer[2] = (unScaledAckValue >> 8) & 0xFF;
    sendBuffer[3] = (unScaledAckValue) & 0xFF;

}

    /* +- SPR 18268 */
void setScaledAckNum(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
    UInt32 *sendBuffer_p;
    UInt32 scaledAckValue = 0;
    sendBuffer_p = (UInt32 *)&sendBuffer[0];
    *sendBuffer_p = ntohl(*sendBuffer_p);
    scaledAckValue = *sendBuffer_p + gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes;
    sendBuffer[0] = (scaledAckValue >> 24) & 0xFF;
    sendBuffer[1] = (scaledAckValue >> 16) & 0xFF;
    sendBuffer[2] = (scaledAckValue >> 8) & 0xFF;
    sendBuffer[3] = (scaledAckValue) & 0xFF;

}

    /* +- SPR 18268 */
void alterWindowSize(UInt16 ueIndex, UInt8 lcIndex,UInt8 sendBuffer[])
    /* +- SPR 18268 */
{
    /*ALTER THE WINDOW SIZE*/
    sendBuffer[6] = (sendBuffer[3]) & 0xFF;
    sendBuffer[7] = (sendBuffer[2]) & 0xFF;
}

/* Function to send Data in TCP header */
    /* +- SPR 18268 */
void sendDATAinTCPPkt(UInt16 ueIndex, UInt8 lcIndex, UInt8 sendBuffer[],UInt32 bytesSent, UInt32 counter)
    /* +- SPR 18268 */
{
    #ifdef ROHC_PROFILE_6
    #ifdef  LAYER2_DLTG_THREAD
    UInt16 headerStart = START_OFFSET_DL_GTP + GTP_HDR;
    UInt16 ipStart  = START_OFFSET_DL_GTP + GTP_HDR;
    #else
    UInt16 headerStart = GTP_HDR;
    UInt16 ipStart = GTP_HDR;
    #endif

    UInt8 version = (sendBuffer[headerStart] >> 4) & 0xF;

    gtpDb_g[ueIndex].rbInfo[lcIndex].totalBytes = bytesSent;

    /* Add IP header length to reach at start of TCP header */
    if(version == 4)
    {
        headerStart = headerStart + 20;
    }
    else /* IPv6 */
    {
        headerStart = headerStart + 40;
    }

    /* Data Part of TCP */
    if (0 !=  profile6Params_g.isGenerator)
    {
        if (0 == gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp % PUSH_COUNT)
        {
            /* Set push flag after every 11th packet and increment push
             * count by 1*/
            //sendBuffer[headerStart+13] =  0x08;
            /* TOGGLE PUSH FLAG */
            sendBuffer[headerStart+13] = sendBuffer[headerStart + 13] ^ (1 << 3);

        }
        else
        {
            sendBuffer[headerStart+13] &= 0xF7;
        }

        if (0 == gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp % URGENT_COUNT)
        {
            /* Set urgent flag after every 17th packet and increment urgent
             * count by 1*/
            /*TOGGLE URG FLAG */
            sendBuffer[headerStart+13] = sendBuffer[headerStart + 13] ^ (1 << 5);
            if (sendBuffer[headerStart+13] & 0x20 )
            {
                sendBuffer[headerStart+18] =  (counter % 255);
                sendBuffer[headerStart+19] =  (counter / 255);
            }
        }
        else
        {
            sendBuffer[headerStart+13] &= 0xDF;
            sendBuffer[headerStart+18] =  0x00;
            sendBuffer[headerStart+19] =  0x00;           
        }            

        if (0 == gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp % ACK_COUNT) 
        {
            /*TOGGLE ACK FLAG */
            sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] ^ (1 << 4);
        }
        else
        {
            sendBuffer[headerStart + 13] &= 0xEF;    
        }
        
        /* TOGGLING DSCP */
        if (0 == gtpDb_g[ueIndex].rbInfo[lcIndex].synack_tcp % DSCP_COUNT)
        {
            sendBuffer[ipStart + 1] |= ((counter % 10) << 3);
            UInt16 ipChecksum =  ipCksumCalc((UInt16) 20,
                                            sendBuffer,
                                            ipStart);

            sendBuffer[ipStart+10] = (ipChecksum >>8) & (0xFF);
            sendBuffer[ipStart+11] = (ipChecksum & 0xFF);
            
        }
        
    }
    /* GENERATE DIFFERNT RND PACKET TYPES */ 
    if (counter <= 100 )
    {
        /*MAKING CO_COMMON (SN >16bits change and TTL-HOP CHANGE)leading to CO_COMMON */
        if (counter >10 && counter <25)
        { 
            /* ONLY TTL CHANGE */ 
            sendBuffer[ipStart + 8] = counter;
            UInt16 ipChecksum =  ipCksumCalc((UInt16) 20,
                                            sendBuffer,
                                            ipStart);

            sendBuffer[ipStart+10] = (ipChecksum >>8) & (0xFF);
            sendBuffer[ipStart+11] = (ipChecksum & 0xFF);
 
        }
        else if (counter >25 && counter < 35)
        {
            /* TTL AND SN > 16 bits CHANGE leading to CO_COMMON*/
            setSeqNum_morethan16bits(ueIndex,lcIndex,&sendBuffer[headerStart + 4]);
                        sendBuffer[ipStart + 8] = counter;
            UInt16 ipChecksum =  ipCksumCalc((UInt16) 20,
                                            sendBuffer,
                                            ipStart);

            sendBuffer[ipStart+10] = (ipChecksum >>8) & (0xFF);
            sendBuffer[ipStart+11] = (ipChecksum & 0xFF);

        }
        else
        {
        /* GENERATE REST RND1 PACKETS */
        setUnscaledSeqNum(ueIndex,lcIndex,&sendBuffer[headerStart + 4]);
        }
    }
    else if ( counter > 100 && counter <= 200)
    {
        if (counter > 120 && counter < 135 )
        {
            /*CHANGE RSF FLAG ONLY leading to CO_COMMON*/
            if (counter % 2)
            {
                sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] ^ (1);
                sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] & (0xF9);
            }
            else if (counter % 3)
            {
                sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] ^ (1<<1);
                sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] & (0xFA);
            }
            else
            {
                sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] ^ (1<<2);
                sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] & (0xFC);
            }
        }
        else if (counter > 135 && counter < 145)
        {
            /* TTL AND SN > 16 bits CHANGE leading to CO_COMMON*/
            setAckNum_morethan16bits(ueIndex,lcIndex,&sendBuffer[headerStart + 8]);
                        sendBuffer[ipStart + 8] = counter;
            UInt16 ipChecksum =  ipCksumCalc((UInt16) 20,
                                            sendBuffer,
                                            ipStart);

            sendBuffer[ipStart+10] = (ipChecksum >>8) & (0xFF);
            sendBuffer[ipStart+11] = (ipChecksum & 0xFF);
            
           
        }
        else
        {
            /* GENERATE REST RND2 */
            setScaledSeqNum(ueIndex,lcIndex,&sendBuffer[headerStart + 4]);
        }
    }
    else if (counter > 200 && counter <= 300)
    {
        /*CHANGE in ECN oly to generate CO_COMMON */
        if (counter > 210 && counter < 220)
        {
             if (counter % 2)
            {
                /*Set ECN bits to 11*/
                sendBuffer[headerStart + 13] |= 0xc0;
                sendBuffer[ipStart + 1] |= 0x03;
            }
            else
            {
                /*Set ECN bits to 00*/
                sendBuffer[headerStart + 13] &= 0x3f;
                sendBuffer[ipStart + 1] &= 0xfc;
            }
            //ip checksum calculate
                UInt16 ipChecksum =  ipCksumCalc((UInt16) 20,
                                                  sendBuffer,
                                                  ipStart);

                sendBuffer[ipStart+10] = (ipChecksum >>8) & (0xFF);
                sendBuffer[ipStart+11] = (ipChecksum & 0xFF);
        
        }
        else
        {
            /* GENERATE 100 PACKETS RND3 */
            setUnscaledAckNum(ueIndex,lcIndex,&sendBuffer[headerStart + 8]);
        }
    }
    else if (counter > 300 && counter <= 400)
    {
        /*CHANGING DF FLAG TO GENERATE CO_COMMON*/
        if (counter > 310 && counter < 321)
        { 
            sendBuffer[ipStart + 6] = sendBuffer[ipStart + 6] ^ (1<<6);
            /*
            if (sendBuffer[GTP_HDR + 6] & 0x20)
            {
                sendBuffer[GTP_HDR + 7] = counter % 255;
            }
            else
            {
                sendBuffer[GTP_HDR + 6] &= 0x60; 
                sendBuffer[GTP_HDR + 7] = 0x00;
            }*/
                UInt16 ipChecksum =  ipCksumCalc((UInt16) 20,
                                                  sendBuffer,
                                                  ipStart);

                sendBuffer[ipStart+10] = (ipChecksum >>8) & (0xFF);
                sendBuffer[ipStart+11] = (ipChecksum & 0xFF);
         }
         else
         {    
             /* GENERATE 100 PACKETS RND4 */
            setScaledAckNum(ueIndex,lcIndex,&sendBuffer[headerStart + 8]);
         }
    }
    else if (counter > 400 && counter <= 500)
    {
        /* GENERATE 100 PACKETS RND5 */
        setUnscaledSeqNum(ueIndex,lcIndex,&sendBuffer[headerStart + 4]);
        setUnscaledAckNum(ueIndex,lcIndex,&sendBuffer[headerStart + 8]);
    }
    else if (counter > 500 && counter <= 600)
    {
        /* GENERATE 100 PACKETS RND6 */
       setScaledSeqNum(ueIndex,lcIndex,&sendBuffer[headerStart + 4]);
       setUnscaledAckNum(ueIndex,lcIndex,&sendBuffer[headerStart + 8]);
    }
    else if (counter > 600 && counter <= 700)
    {
        /* GENERATE 100 PACKETS RND7 */
        setUnscaledAckNum(ueIndex,lcIndex,&sendBuffer[headerStart + 8]);
        alterWindowSize(ueIndex,lcIndex,&sendBuffer[headerStart + 8]); 
    }
    else if (counter > 700 && counter <= 800)
    {
        setUnscaledAckNum(ueIndex,lcIndex,&sendBuffer[headerStart + 8]);
        /* GENERATE 100 PACKETS RND8 */
        if (counter < 730)
        {
            /*TOGGLE RESET FLAG AND reset SYN and FIN */
           sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] ^ (1 << 2);
           sendBuffer[headerStart + 13] = sendBuffer[headerStart + 13] & 0xFC;
        }
        else if ( counter < 760)
        {
            /*change ttl hop*/
            sendBuffer[ipStart + 8 ]++;
            //ip checksum calculate
                UInt16 ipChecksum =  ipCksumCalc((UInt16) 20,
                                                  sendBuffer,
                                                  ipStart);

                sendBuffer[ipStart+10] = (ipChecksum >>8) & (0xFF);
                sendBuffer[ipStart+11] = (ipChecksum & 0xFF);
        } 
        else if ( counter < 798)
        {
            /*ECN flag*/
            if (counter % 2)
            {
                /*Set ECN bits to 11*/
                sendBuffer[headerStart + 13] |= 0xc0;
                sendBuffer[ipStart + 1] |= 0x03;
            }
            else
            {
                /*Set ECN bits to 00*/
                sendBuffer[headerStart + 13] &= 0x3f;
                sendBuffer[ipStart + 1] &= 0xfc;
            }
            //ip checksum calculate
                UInt16 ipChecksum =  ipCksumCalc((UInt16) 20,
                                                  sendBuffer,
                                                  ipStart);

                sendBuffer[ipStart+10] = (ipChecksum >>8) & (0xFF);
                sendBuffer[ipStart+11] = (ipChecksum & 0xFF);

        }
    }
    return;
    #endif
}
#endif

void initProfile6Params()
{
    profile6Params_g.isInitiator = 1;       /* Set if UL is the initiator for TCP connection */
    profile6Params_g.isFin = 1;             /* Set if UL is the first to send FIN request */
    profile6Params_g.isGenerator = 1;       /* 0 - Data Consumer, 1 - Data Generator, 2 - Both */
}

#ifdef PDCP_GTPU_INTF
/****************************************************************************
 * * Function Name  : dlPacketDispatcher 
 * * Inputs         : None
 * * Outputs        : None
 * * Returns        : return 0 on success
 * * Description    : This function ENQ DL packet on multiple instances
 * ****************************************************************************/
void* dlPacketDispatcher(void *params_p)
{
    UInt8 instId= *((UInt8 *)params_p);

    //TODO thread bind /priority
    struct timespec 	timer;
    struct timespec 	oldStartTime, startTime, endTime;
    UInt32 			mytickcount =0 ;
    UInt32 			startflag_g =1;
    UInt64 			adaptiveDiff =0;
    UInt64 			sleepTime =0;
    struct 			timeval t2;
    UInt16 			i_ueCnt = 0;
    UInt32          trxSeq = 0;
    UInt16 profileIdx = 0;
    UInt16 mixProfileCount = 0;
    UInt16 packetType = 0;
    UInt32 			loopVar[3] ={0};
    SInt32 			bytesSend = 0;
    UInt32 			tempVar =0;
    UInt8 pktcount=0;
    static UInt16       tick_tracker = 0;
    FILE  *sps_logs;
    int mulB = 0; 
    UDouble64 		datavolume = 0;
    UInt32 memPoolUsage = 0;
    static UInt8 memPoolOverFlow = 0;
    UInt32          maxNumOfPktPerTick = 100;
    UInt32          remainPktLcCount   = 0;
    UInt32          maxNumOfPktPerTickRemaining = 0;
    UInt16 localUeStart = 0; 
    UInt16 localUeCnt = 0;
    UInt16 localUeTurn = 0;
    UInt16 localLcId = 0;
    while(1)
    {
        if(dataParse_g ==1)
        {
            localUeStart = getLocalUeStart(instId); 
            localUeCnt = getLocalUeCount(instId);
            break;
        }
        else
        {
            sleep(5);
        }
    }
    UInt16 dataUe = 0;
    while(1)
    {
        if((mode_g != 1) && (dataParse_g !=0))
        {

            clock_gettime(CLOCK_REALTIME,&startTime);


            if(0==startflag_g)
            {
                if(startTime.tv_sec == oldStartTime.tv_sec)
                {
                    adaptiveDiff = (startTime.tv_nsec - oldStartTime.tv_nsec) - sleepTime;
                }
                else if (startTime.tv_sec > oldStartTime.tv_sec)
                {
                    adaptiveDiff = 1000000000 - (oldStartTime.tv_nsec - startTime.tv_nsec) - sleepTime;
                }

                if(adaptiveDiff > 700000)
                {
                    missTimeCount_g = missTimeCount_g + adaptiveDiff;
                    adaptiveDiff = 0;
                    missTickCount_g ++;
                }
            }
            else
            {
                adaptiveDiff =0;
                startflag_g =0;
            }
            sleepTime = 1000000*timeInMs_g-adaptiveDiff;

            oldStartTime.tv_sec = startTime.tv_sec;
            oldStartTime.tv_nsec = startTime.tv_nsec;
            timer.tv_sec = 0;
            timer.tv_nsec = sleepTime;

            dataUe = 0;
            /*SPR 21727 changes start*/
            //for(instCount=0;instCount<num_instance;instCount++)
            {
                for(i_ueCnt=localUeStart;(i_ueCnt< localUeCnt)&&(dataUe<num_of_data_ue[instId]);i_ueCnt++)
                    /*20868 -*/
                    /*SPR 21653 changes end*/
                {
                    //                    if(isDataToSchedule(data_to_pump[sector_counter],localUeCnt))
                    {		
                        dataUe++;
                        mulB =0;
                        profileIdx = 0;
                        /* using local variable for mix profile per lc per tp id wise info */
                        localUeTurn = i_ueCnt;
                        gettimeofday(&t2,NULL);
/*SPR 21836 Changes Start*/
                        gtpDataBase_t *gtpDb_p = &sectorDb_g.gtpDb_g[localUeTurn];
                        gtpDb_p->timeDiff = t2.tv_sec - timer_g;

                        /* Storing number of mixed profiles for packet size and thruput */
                        mixProfileCount = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].mixProfileCount;

                        for ( ; mulB < gtpDb_p->lcCnt ; mulB++ ) 
                        {
                            if (sectorDb_g.gtpDb_g[i_ueCnt].rbInfo[mulB].sps_lc == 1)
                            {
                                if(spsTraffic[tick_tracker].data_present == 1)
                                {
                                    if(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].data == 1)
                                    {
                                        for(pktcount=0;pktcount<=spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].numPkt; pktcount++)
                                        {
                                            localUeTurn = spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].ue_id;
                                            localLcId = spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].lc_id;
                                            spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer =
                                                getMemFromPool(MAX_PKT_SIZE, NULL);
                                            if (spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer)
                                            {
                                                memSet(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer,
                                                        0, MAX_PKT_SIZE);
                                                initBufferForDlQue(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer,
                                                        spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size);
                                                createDownlinkPacket(
                                                        &(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].
                                                            lcInfo[mulB].SendBuffer[START_OFFSET_DL_GTP]),
                                                        spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size,localUeTurn,localLcId);
}
                                            memcpy ( ( &(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].
                                                            lcInfo[mulB].SendBuffer[START_OFFSET_DL_GTP]) +
                                                        spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].
                                                        lcInfo[mulB].packet_size + GTP_HDR - 4 ),
                                                    &sectorDb_g.ueDataFlow_g[localUeTurn][localLcId].txSeq, 4);
                                            sectorDb_g.ueDataFlow_g[localUeTurn][localLcId].txSeq++;
                                            dlTgDataPkt* dlTgDataPkt_p = (dlTgDataPkt*)getMemFromPool(sizeof(dlTgDataPkt), NULL);
                                            if (NULL != dlTgDataPkt_p)
                                            {
                                                dlTgDataPkt_p->dataLength = spsTraffic[tick_tracker].sectorInfo.
                                                    ueInfo[i_ueCnt].lcInfo[mulB].packet_size + GTP_HDR + START_OFFSET_DL_GTP ;
                                                dlTgDataPkt_p->dlTgDataPktBuf_p = spsTraffic[tick_tracker].sectorInfo.
                                                    ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer;
                                                ENQUEUE_DLTG_DATA_PKT_Q(dlTgDataPkt_p);
                                                bytesSend =  spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].
                                                    lcInfo[mulB].packet_size + GTP_HDR + START_OFFSET_DL_GTP;
                                                sectorDb_g.ueDataFlow_g[localUeTurn][localLcId].txData += bytesSend - GTP_HDR - START_OFFSET_DL_GTP;
                                            }
                                            else
                                                bytesSend = -1;
                                            fprintf(sps_logs,"\nSENT DATA PACKET SIZE = %d",
                                                    spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size);
                                            if ( bytesSend == -1 )
                                            {
                                                fprintf(stderr,"\nDL TG send to failed\n");
                                            }
                                            datavolume += (bytesSend - GTP_HDR - START_OFFSET_DL_GTP);
                                            seqNum_g++;
                                            sectorDb_g.ueDataFlow_g[localUeTurn][localLcId].txPkts++;

                                        }
                                    }
                                }
                            }
/*SPR 21836 Changes End*/
                            else
                            {
                                if (FALSE == gtpDb_p->rbInfo[mulB].txActiveFlag)
                                {
                                    continue;
                                }
                                profileIdx = gtpDb_p->rbInfo[mulB].profileIdx;
                                for( packetType =0; packetType < mixProfileCount; packetType++)
                                {
                                    gtpDb_p->rbInfo[mulB].packet_size[packetType] = 
                                        gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].packetSize[packetType];
                                    gtpDb_p->rbInfo[mulB].throughput[packetType] = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].throughput[packetType];
                                    gtpDb_p->rbInfo[mulB].varPacketSize = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].varPacketSize[packetType];
                                    gtpDb_p->rbInfo[mulB].fixedPktPerTick[packetType] = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].fixedPktPerTick[packetType];
                                    gtpDb_p->rbInfo[mulB].remainingPkt[packetType] = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].remainingPkt[packetType];
                                    gtpDb_p->rbInfo[mulB].totalNoOfPktVar[packetType] = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].totalNoOfPktVar[packetType];

                                    /* + SPR 8669 Fix*/
                                    /* LOAD DISTRIBUTION */
/*SPR 21836 Changes Start*/
                                    maxNumOfPktPerTick = (totalLcCount_g * gtpDb_p->rbInfo[mulB].remainingPkt[packetType])/
                                        gtpDb_p->rbInfo[mulB].noOfTicks;
                                    maxNumOfPktPerTickRemaining = ((totalLcCount_g * 
                                                gtpDb_p->rbInfo[mulB].remainingPkt[packetType]) % 
                                            gtpDb_p->rbInfo[mulB].noOfTicks)/totalLcCount_g;
/*SPR 21836 Changes End*/
                                    /* LOAD DISTRIBUTION */
                                    /* - SPR 8669 Fix*/

                                    localLcId =  gtpDb_p->rbInfo[mulB].lcId;
                                    gtpDb_p->rbInfo[mulB].txTickCount++;
                                    if(noOfPktVar_g != 0)
                                    {
                                        loopVar[packetType] = noOfPktVar_g;
                                        gtpDb_p->rbInfo[mulB].extraBurstCounter[packetType] = 0;
                                    }  
                                    else
                                    {
                                        loopVar[packetType] = gtpDb_p->rbInfo[mulB].fixedPktPerTick[packetType]+1;
                                        gtpDb_p->rbInfo[mulB].extraBurstCounter[packetType] = 
                                            gtpDb_p->rbInfo[mulB].remainingPkt[packetType];
                                    }


                                    if(noOfPktVar_g == 0)
                                    {
                                        /* LOAD DISTRIBUTION */
/*SPR 21836 Changes Start*/
                                        UInt32 minLcBound = 0, maxLcBound = 0;
                                        minLcBound = (((gtpDb_p->rbInfo[mulB].txTickCount%
                                                        gtpDb_p->rbInfo[mulB].noOfTicks )*
                                                    maxNumOfPktPerTick)%totalLcCount_g);
                                        maxLcBound = (minLcBound+maxNumOfPktPerTick);
                                        if(((maxLcBound < totalLcCount_g) &&
                                                    (remainPktLcCount >= minLcBound) && 
                                                    (remainPktLcCount <  maxLcBound)) ||
                                                ( (maxLcBound >= totalLcCount_g) &&
                                                  ( (remainPktLcCount >= minLcBound && 
                                                     remainPktLcCount <  totalLcCount_g) ||
                                                    /* +COVERITY 27492 */
                                                    (remainPktLcCount < maxLcBound%totalLcCount_g))))
/*SPR 21836 Changes End*/
                                            /* -COVERITY 27492 */
                                            /* LOAD DISTRIBUTION */
                                        {
                                            loopVar[packetType] = gtpDb_p->rbInfo[mulB].fixedPktPerTick[packetType]+1;
                                        }
                                        else
                                        {
                                            loopVar[packetType] = gtpDb_p->rbInfo[mulB].fixedPktPerTick[packetType];
                                        }
                                        /* LOAD DISTRIBUTION */
                                        if(maxNumOfPktPerTickRemaining && ((gtpDb_p->rbInfo[mulB].txTickCount%
                                                        gtpDb_p->rbInfo[mulB].noOfTicks) < maxNumOfPktPerTickRemaining))
                                        {
                                            loopVar[packetType]++;
                                        }
                                        remainPktLcCount++;
                                        /* + SPR 8669 Fix */                                    
/*SPR 21836 Changes Start*/
                                        if(remainPktLcCount >= totalLcCount_g)
                                            /* - SPR 8669 Fix */                                    
                                            remainPktLcCount=0;
                                        /* LOAD DISTRIBUTION */
/*SPR 21836 Changes End*/
                                    }
                                    else
                                    {
                                        loopVar[packetType] = noOfPktVar_g;
                                    }
                                    /*+ TG Changes for QOS Testing */
/*SPR 21836 Changes Start*/
                                    if((gtpDb_p->rbInfo[mulB].upDownFlag & 0x01 ) == 0 )
                                    {
                                        if((gtpDb_p->timeDiff >= total_duration_g) && 
                                                BURST_FLAG )
                                        {
/*SPR 21836 Changes End*/
                                            if( (gtpDb_p->rbInfo[mulB].bitRateFlag == 1)  &&
                                                    (gtpDb_p->rbInfo[mulB].extraBurstFlag == 1))
                                            {
                                                gtpDb_p->rbInfo[mulB].packet_size[packetType] += 
                                                    gtpDb_p->rbInfo[mulB].varPacketSize;
                                                gtpDb_p->rbInfo[mulB].upDownFlag++;
                                                timer_g = t2.tv_sec;
                                            }
                                        }
                                    }
/*SPR 21836 Changes Start*/
                                    else
                                    {
                                        if((gtpDb_p->timeDiff >= burst_time_g) && 
                                                BURST_FLAG )
                                        {
/*SPR 21836 Changes End*/
                                            if( (gtpDb_p->rbInfo[mulB].bitRateFlag == 1)  &&
                                                    (gtpDb_p->rbInfo[mulB].extraBurstFlag == 1))
                                            {
                                                gtpDb_p->rbInfo[mulB].packet_size[packetType] -= 
                                                    gtpDb_p->rbInfo[mulB].varPacketSize;
                                                gtpDb_p->rbInfo[mulB].upDownFlag++;
                                                timer_g = t2.tv_sec;
                                            }
                                        }
                                    }
                                }
                                /*- TG Changes for Qos testing */
                                for(packetType = 0;packetType < mixProfileCount; packetType++)
                                {
                                    for(tempVar = loopVar[packetType];tempVar;tempVar--) 
                                    {
/*SPR 21836 Changes Start*/
                                        trxSeq = sectorDb_g.ueDataFlow_g[localUeTurn][localLcId].txSeq;
/*SPR 21836 Changes End*/
#if defined(__powerpc__)
                                        tmpPtr = (UInt8 *)&trxSeq;
                                        trxSeq = LTE_GET_U32BIT(tmpPtr);
#endif

                                        /* Start 128 UE: Memory Changes */
                                        memPoolUsage = qvMemPoolGetUsagePercentage();
                                        if (MSG_POOL_HIGH_WATERMARK < memPoolUsage)
                                        {
                                            if (memPoolOverFlow == 0)
                                            {
				#ifdef PRINT
                                                fprintf(stderr, "DLTG Memory overflow memPoolUsage[%d]\n", memPoolUsage);
				#endif 
                                            }
                                            memPoolOverFlow = 1;
                                        }
                                        else if (MSG_POOL_LOW_WATERMARK > memPoolUsage)
                                        {
                                            if (memPoolOverFlow)
                                            {
				#ifdef PRINT
                                                fprintf(stderr, "DLTG Memory overflow cleared memPoolUsage[%d]\n", memPoolUsage);
				#endif 
                                            }
                                            memPoolOverFlow = 0;
                                        }
                                        if (memPoolOverFlow == 0)
                                        {
                                            if (gtpDb_p->rbInfo[mulB].packet_size[packetType] != 0)
                                            {
                                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType] = getMemFromPool(MAX_PKT_SIZE, NULL);
                                                if (gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType])
                                                {
                                                    memSet(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType], 0, MAX_PKT_SIZE);
                                                    initBufferForDlQue(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType], 
                                                            gtpDb_p->rbInfo[mulB].packet_size[packetType]);

#ifdef LAYER2_DLTG_THREAD
#ifdef ROHC_PROFILE_6 
                                                    if (oneTimeFlag)
                                                    {
                                                        memCpy  ( tempBuffer,&(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]),sizeof(tempBuffer));
                                                        oneTimeFlag = 0;
                                                    }
                                                    else
                                                    {
                                                        memCpy  ( &(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]),tempBuffer,sizeof(tempBuffer));
                                                    }
#endif
#endif

                                                    createDownlinkPacket(
                                                            &(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]),
                                                            gtpDb_p->rbInfo[mulB].packet_size[packetType],localUeTurn,localLcId);
                                                    memcpy ( ( &(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]) +
                                                                gtpDb_p->rbInfo[mulB].packet_size[packetType] + GTP_HDR - 4 ),
                                                            &trxSeq, 4);  
/*SPR 21836 Changes Start*/
                                                    sectorDb_g.ueDataFlow_g[localUeTurn][localLcId].txSeq++;
/*SPR 21836 Changes End*/
                                                }
                                                else
                                                    ltePanic( "getMemFromPool failed at func [%s] Line[%d]\n", __func__, __LINE__ );
                                            }

                                            /* Set TS and SN value in RTP header */
                                            setSNnTSinRTPPkt(localUeTurn,mulB,gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType]);
                                            /* Set SYN and ACK fields in TCP header */
                                            controlflowCallforTCP(localUeTurn,mulB,
                                                    gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType],bytesSend);

                                            /* Set IP-ID value in IP header */
                                            setIPIDinIPPkt(localUeTurn,mulB,
                                                    gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType]);

#ifdef LAYER2_DLTG_THREAD
#ifdef ROHC_PROFILE_6 
                                            memCpy( tempBuffer,&(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]),sizeof(tempBuffer));
#endif
#endif                                         

                                            if (gtpDb_p->rbInfo[mulB].packet_size[packetType] != 0&& 
                                                    gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType] )
                                            {
                                                dlTgDataPkt* dlTgDataPkt_p = (dlTgDataPkt*)getMemFromPool(sizeof(dlTgDataPkt), NULL);
                                                if (NULL != dlTgDataPkt_p)
                                                {
                                                    dlTgDataPkt_p->dataLength = gtpDb_p->rbInfo[mulB].packet_size[packetType] + 
                                                        GTP_HDR + START_OFFSET_DL_GTP ;
                                                    dlTgDataPkt_p->dlTgDataPktBuf_p = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType];
                                                    ENQUEUE_DLTG_DATA_PKT_Q(dlTgDataPkt_p);
                                                    bytesSend =  gtpDb_p->rbInfo[mulB].packet_size[packetType] + GTP_HDR + START_OFFSET_DL_GTP;
/*SPR 21836 Changes Start*/
                                                    sectorDb_g.ueDataFlow_g[localUeTurn][localLcId].txData += bytesSend - GTP_HDR - START_OFFSET_DL_GTP;
/*SPR 21836 Changes End*/
                                                }
                                                else
                                                {
                                                    freeMemPool( gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType] );
                                                    ltePanic( "getMemFromPool failed at func [%s] Line[%d]\n", __func__, __LINE__ );
                                                }
                                            }
                                            else
                                                bytesSend = -1;

                                            datavolume += (bytesSend - GTP_HDR - START_OFFSET_DL_GTP);
                                            seqNum_g++;
                                            if (trafficProfileVar_g) {
                                            }
/*SPR 21836 Changes Start*/
                                            sectorDb_g.ueDataFlow_g[localUeTurn][localLcId].txPkts++;
/*SPR 21836 Changes End*/
                                            pktCounter_g++;
                                        }
                                    }
                                }
                                if((gtpDb_p->rbInfo[mulB].txTickCount%
                                            gtpDb_p->rbInfo[mulB].noOfTicks)==0)
                                { 
#ifdef PACKETS_SENT_PER_SEC
                                    fprintf(stderr,"No of packets sent in %d Ticks(1sec): %d \n",
                                            gtpDb_p->rbInfo[mulB].noOfTicks,
                                            pktCounter_g);
#endif
                                    pktCounter_g = 0;
                                }
                                if( gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].profileTimerCount == 0 )
                                {
                                    profileIdx++;
                                    if(profileIdx == gtpDb_p->rbInfo[mulB].tpCount)
                                    {
                                        profileIdx = 0;
                                    }
                                    gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].profileTimerCount = 
                                        gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].profileTimer;
                                }
                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].profileTimerCount--;
                                gtpDb_p->rbInfo[mulB].profileIdx = profileIdx;

                                /* resetting the entries if an LC timer equals to total ecexution time */
                                if(gtpDb_p->rbInfo[mulB].isLCTimerPresent)
                                {
                                    if(gtpDb_p->rbInfo[mulB].totalExecTime == 0)
                                    {
                                        for(profileIdx = 0; profileIdx<gtpDb_p->rbInfo[mulB].tpCount;profileIdx++)
                                        {
                                            for(packetType = 0;
                                                    packetType < gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].mixProfileCount;
                                                    packetType++)
                                            {
                                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].packetSize[packetType] = 0;
                                            }
                                        }
                                        gtpDb_p->rbInfo[mulB].isLCTimerPresent = 0;
                                    }
                                    else
                                    {
                                        gtpDb_p->rbInfo[mulB].totalExecTime--;
                                    }
                                }
                            }
                        }
                    }

                }
            }
            /*SPR 21727 changes end*/
            tick_tracker++;
            if( tick_tracker == 1000)
                tick_tracker = 0;

            localUeTurn = 0; /*Reset Round Robin ID to 0*/
            localLcId = 0; /*Reset Round Robin ID to 0*/
            mytickcount++;
            mytickcount%=1000;
            clock_gettime(CLOCK_REALTIME,&endTime);
            if(timer.tv_nsec > (((endTime.tv_sec - startTime.tv_sec)*1000000000)+
                        (endTime.tv_nsec - startTime.tv_nsec)))
            {
                timer.tv_nsec = timer.tv_nsec -
                    (((endTime.tv_sec - startTime.tv_sec)*1000000000)+
                     (endTime.tv_nsec - startTime.tv_nsec));
            }
            else
            {
                timer.tv_nsec = 1000000*timeInMs_g -  ((((endTime.tv_sec - startTime.tv_sec)*1000000000)+
                            (endTime.tv_nsec - startTime.tv_nsec)) - timer.tv_nsec);
            }
            if(timer.tv_nsec > 1000000*timeInMs_g)
            {
                timer.tv_nsec=1000000*timeInMs_g;
            }
        }
        else
        {
            timer.tv_sec = 1;
        }
        pselect(0,NULL,NULL,NULL,&timer,NULL);
    }


}
#endif
/****************************************************************************
 * * Function Name  : processDLPacket
 * * Inputs         : None
 * * Outputs        : None
 * * Returns        : return 0 on success
 * * Description    : This function process DL Packets.  
 * ****************************************************************************/

UInt32 processDLPacket(void *ipAddr)
{
    /* COmpilation 12-JUN-2014 Fix start */
    //UInt16 profileTimerCount = 0;
    /* COmpilation 12-JUN-2014 Fix end */
    UInt16 localUeStart = 0;
    UInt16 localUeCnt = 0;
    UInt16 profileIdx = 0;
    UInt16 mixProfileCount = 0;
    UInt16 packetType = 0;
    UInt32 			loopVar[3] ={0};
/*SPR 21727 changes start*/
#ifdef PDCP_GTPU_INTF
    UInt8 instCount=0;
#endif
/*SPR 21727 changes end*/
    /* COmpilation 12-JUN-2014 Fix start */
    //UInt16 count = 0;
    /* COmpilation 12-JUN-2014 Fix end */
    int mulB = 0; 
    /*COVERITY FIX-23459 START*/
    UDouble64 		datavolume = 0;
    /*COVERITY FIX-23459 END*/
    struct timespec 	timer;
    struct timespec 	oldStartTime, startTime, endTime;
#ifdef TG_REAL_EPC
    UInt32 			diff = 0;
    UInt64                      loadCalcTimeDiff =0;
    static struct timespec      lastDispTime;
    UInt8 sector_counter = 0;
    UInt8 loop_counter = 0;
    UInt8 lc_counter = 0;
#endif
    SInt32 			bytesSend = 0;
    UInt32 			tempVar =0;
    /* COmpilation 12-JUN-2014 Fix start */
    // static UInt32 counter;
    /* COmpilation 12-JUN-2014 Fix end */
#ifndef LAYER2_DLTG_THREAD
    UInt8 			sendBuffer1[MAX_PAYLOAD_SIZE] = {0};
    UInt8 			sendBuffer2[MAX_PAYLOAD_SIZE] = {0};
#endif
    UInt32 			mytickcount =0 ;
    UInt32 			startflag_g =1;
    UInt64 			adaptiveDiff =0;
    UInt64 			sleepTime =0;
    struct 			timeval t2;
    /* +- SPR 18268 */
    UInt16 			i_ueCnt = 0;
    UInt16          cntr;
    /* +- SPR 18268 */
    UInt32          trxSeq = 0;
    /* COmpilation 12-JUN-2014 Fix start */
    SInt32          sockTxFd = -1;
    /* COmpilation 12-JUN-2014 Fix end */


    /*SPR  9136 change start */
#ifndef IPV6_ENABLE    
/* COmpilation 12-Jun-2014 Fix start */
    struct sockaddr_in    sockAddr = {0};
/* COmpilation 12-Jun-2014 Fix end */
#else
    struct sockaddr_in6   sockAddr = {0};
#endif
    /*SPR  9136 change end */

#if defined(__powerpc__)
    UInt8           *tmpPtr = NULL;
#endif
#ifdef LAYER2_DLTG_THREAD    
#ifdef ROHC_PROFILE_6
    UInt8           tempBuffer[88] = {0};
    static UInt8 oneTimeFlag  = 1;
#endif
#endif    
    UInt8 pktcount=0;
    static UInt16       tick_tracker = 0;
    FILE  *sps_logs;
    sps_logs = fopen("dl_packet_trace.log","w+");
    if(sps_logs == NULL)
    {
        fprintf(stderr,"Unable to open the file dl_packet_trace for writing.......\n");
        exit(0);
    }

#ifdef LAYER2_DLTG_THREAD
    /* Start 128 UE: Memory Changes */
    UInt32 memPoolUsage = 0;
    static UInt8 memPoolOverFlow = 0;
    /* End 128 UE: Memory Changes */
#endif
/*+COVERITY 5.2.2 - 32680*/
    /*Removed sockaddrInSize*/
/*-COVERITY 5.2.2 - 32680*/

/* LOAD DISTRIBUTION */
    UInt32          maxNumOfPktPerTick = 100;
    UInt32          remainPktLcCount   = 0;
/*SPR 21836 Changes Start*/
    UInt32          totalLcCount       = 0;
/*SPR 21836 Changes End*/
    UInt32          maxNumOfPktPerTickRemaining = 0;
/* LOAD DISTRIBUTION */

#ifndef LAYER2_DLTG_THREAD
#ifdef TG_REAL_EPC
    UInt8 isSockCreateFlag[10] = {0};
    SInt32 sockTxFdEpc[10] = {-1};
    UInt8 tempFlag = 0;
    UInt16 lastNum = 0;
    UInt8 tempbuf[20] = "";
/*SPR 21836 Changes Start*/
        for(loop_counter=0;loop_counter< sectorDb_g.ueCount;loop_counter++)
        {
            gtpDataBase_t *gtpDb_p = &sectorDb_g.gtpDb_g[loop_counter];
/*SPR 21836 Changes End*/
            for(lc_counter= 0;lc_counter < gtpDb_p->lcCnt; lc_counter++)
            {
                if (!isSockCreateFlag[lc_counter])
                {
                    /* Open TX socket for each LC instance of differnet UE 
                       and store it into global context */
                    gtpDb_p->rbInfo[lc_counter].sockTxFd = -1;
                    openUdpSocket( OPEN_TX_SOCKET, (UInt8 *)ipAddr, srcIpAddr_g, 
                            &(gtpDb_p->rbInfo[lc_counter].sockTxFd), 
                            &(gtpDb_p->rbInfo[lc_counter].sockAddr),
                            (UInt16)(55353 + lc_counter));

                    isSockCreateFlag[lc_counter] = 1;
                    sockTxFdEpc[lc_counter] = gtpDb_p->rbInfo[lc_counter].sockTxFd;
                }
                else
                {
                    UInt8 modifiedTempbuf[20] = "";

                    if ( 0 == tempFlag )
                    {
                        UInt8 *curr = PNULL;

                        /* Parsing destination IP address for subsequent UEs */ 
                        curr = strtok( ((UInt8 *)ipAddr), ".");
                        strcat( tempbuf, curr);
                        strcat( tempbuf, ".");

                        curr = strtok( NULL, ".");                         
                        strcat( tempbuf, curr);
                        strcat( tempbuf, ".");

                        curr = strtok( NULL, ".");                         
                        strcat( tempbuf, curr);

                        curr = strtok( NULL, "."); 
                    
                        lastNum = atoi(curr);

                        tempFlag = 1;
                    }
                    strncpy( modifiedTempbuf, tempbuf, 20 );
                    UInt16 num = lastNum + loop_counter;

                    UInt8 str[5] = {0};
                    sprintf(str, ".%d", num);
                    strcat( modifiedTempbuf, str);

                    memset(&(gtpDb_p->rbInfo[lc_counter].sockAddr), 0 , sizeof(struct sockaddr_in));

                    gtpDb_p->rbInfo[lc_counter].sockAddr.sin_family = AF_INET;
                    gtpDb_p->rbInfo[lc_counter].sockAddr.sin_port = htons(2152);
                    inet_pton(AF_INET, modifiedTempbuf, &(gtpDb_p->rbInfo[lc_counter].sockAddr.sin_addr));
                    gtpDb_p->rbInfo[lc_counter].sockTxFd = sockTxFdEpc[lc_counter];
                }
            }
        }
#else
    openUdpSocket(OPEN_TX_SOCKET,(UInt8 *)ipAddr, srcIpAddr_g,&sockTxFd_g,&sockAddr_g, 55353);
#endif
#endif

#ifndef TG_REAL_EPC
#ifndef AUTOMATION_DLTG
#ifdef LIPA_GW
    fprintf(stderr,"\n------ Hit Any Key To Start LIPA Downlink Traffic");
#else
    fprintf(stderr,"\n------ Hit Any Key To Start Downlink Traffic");
#endif
    getc(stdin);
    /* AUTOMATION_DLTG */
#else
    if(mode_g == TG_UL_DL_MODE)
    {
        ulTrafficRcv = 0;
        while(!ulTrafficRcv)
        {
            usleep(400000);
        }
        ulTrafficRcv = 0;
    }
    else
    {
#ifdef LIPA_GW
        fprintf(stderr,"\n------  Hit Any Key To Start LIPA Downlink Traffic");
#else
        fprintf(stderr,"\n------  Hit Any Key To Start Downlink Traffic");
#endif
        getc(stdin);
        dataDispatch_g =1;
    }
#endif /* AUTOMATION_DLTG */
#else
    fprintf(stderr, "\nIn case of real EPC, throughput pumped will be not be "
            "same as given in TGConfig.txt but will be less because of CENT OS "
            "system!!!\n" );
#endif /* TG_REAL_EPC */
    gettimeofday(&t1,NULL);
    timer_g = t1.tv_sec;
    sleepTime = 1000000;
    setSchedulePolicy (10,SCHED_FIFO);

#ifdef LAYER2_DLTG_THREAD
            QINIT_DLTG_DATA_PKT_Q();
#endif

/*SPR 21836 Changes Start*/
/*Code Removed*/
/*SPR 21836 Changes End*/
#ifndef TG_REAL_EPC
/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
        /* CA DL-TG CHANGES start */
        /* CA DL-TG CHANGES end */
        /*20868 +*/
        /*SPR 21727 changes start*/
#ifdef PDCP_GTPU_INTF
        for(instCount=0;instCount<num_instance;instCount++)
        {
            UInt16 dataUe = 0;
            localUeStart = getLocalUeStart(instCount); 
            localUeCnt = getLocalUeCount(instCount);
            for(cntr=localUeStart;(cntr< localUeCnt)&&(dataUe<num_of_data_ue[instCount]);cntr++)
#else
                for( cntr = ueStart_g ; cntr < ueId_g;cntr++)
#endif
        /*20868 -*/
/*SPR 21653 changes end*/
#else
#ifdef PDCP_GTPU_INTF
/*SPR 21836 Changes Start*/
        for( cntr = ueStart_g ; cntr < sectorDb_g.ueCount;)
#else
        for( cntr = ueStart_g ; cntr < sectorDb_g.ueCount; cntr++)
/*SPR 21836 Changes End*/
#endif
#endif
        {
#ifdef PDCP_GTPU_INTF
            if(isDataToSchedule(data_to_pump[sector_counter],localUeCnt))
            {		
                dataUe++;
#endif
            /* LOAD DISTRIBUTION */
/*SPR 21836 Changes Start*/
            totalLcCount += sectorDb_g.gtpDb_g[cntr].lcCnt;
/*SPR 21836 Changes End*/
            /* LOAD DISTRIBUTION */

#ifdef PDCP_GTPU_INTF
            }
#endif
        }
        /* + SPR 8669 Fix*/
/*SPR 21836 Changes Start*/
      //  totalLcCount_g = totalLcCount;
/*SPR 21836 Changes End*/
#ifdef PDCP_GTPU_INTF
#ifndef TG_REAL_EPC
      }
#endif
#endif
            /*SPR 21727 changes end*/
        /* - SPR 8669 Fix*/
#ifndef PDCP_GTPU_INTF
    while(1)
    {
        /* SPR 18822 Fix Start */
#ifndef LAYER2_DLTG_THREAD
        if ((ext_hdr_noti_g == 1) &&(ext_hdr_prof_g >0 && ext_hdr_prof_g <5 ))
        {
            /* Handle the Echo Req/resp from eNB */
            ext_hdr_noti_g =0;
            UInt8 extBuffer[128] = {0};
            UInt32 current = 0;
            SInt32 bytesSend = 0;
            if(ext_hdr_prof_g == 4 || ext_hdr_prof_g == 2)
            {
            current = createExtensionHeaderNoti(&extBuffer,8);
            }
            else
            {
                current = createExtensionHeaderNoti(&extBuffer,7);
            }
            /* send supoprted extension header notification*/
            bytesSend = sendto(sockTxFd_g, extBuffer, current, 0,
                    (struct sockaddr*)&sockAddr_g, sizeof(struct sockaddr_in));

            if ( bytesSend == -1 )
            {
                fprintf(stderr,"\nDL TG send to failed\n");
            }
        }
#else
        /* SPR 20441 Changes Start*/
//        fprintf(stderr,"\n***Extension Header notification not supported inside TG****\n");
        /* SPR 20441 Changes End*/
#endif
        /* SPR 18822 Fix End */
        if(mode_g != 1)
        {

            clock_gettime(CLOCK_REALTIME,&startTime);


            if(0==startflag_g)
            {
                if(startTime.tv_sec == oldStartTime.tv_sec)
                {
                    adaptiveDiff = (startTime.tv_nsec - oldStartTime.tv_nsec) - sleepTime;
                }
                else if (startTime.tv_sec > oldStartTime.tv_sec)
                {
                    adaptiveDiff = 1000000000 - (oldStartTime.tv_nsec - startTime.tv_nsec) - sleepTime;
                }

                if(adaptiveDiff > 700000)
                {
                    missTimeCount_g = missTimeCount_g + adaptiveDiff;
                    adaptiveDiff = 0;
                    missTickCount_g ++;
                }
            }
            else
            {
                adaptiveDiff =0;
                startflag_g =0;
            }
            sleepTime = 1000000*timeInMs_g-adaptiveDiff;

            oldStartTime.tv_sec = startTime.tv_sec;
            oldStartTime.tv_nsec = startTime.tv_nsec;
            timer.tv_sec = 0;
            timer.tv_nsec = sleepTime;

/*SPR 21836 Changes Start*/
/*Code Removed*/
/*SPR 21836 Changes End*/
#ifndef TG_REAL_EPC
/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
                /*20868 +*/
            /*SPR 21727 changes start*/
		for( i_ueCnt = ueStart_g ; i_ueCnt < ueId_g;i_ueCnt++)
                /*20868 -*/
/*SPR 21653 changes end*/
#else
		for( i_ueCnt = ueStart_g ; i_ueCnt < ueId_g;i_ueCnt++)
#endif
                {
            /*SPR 21727 changes end*/
                    mulB =0;
                    profileIdx = 0;
                    /* using local variable for mix profile per lc per tp id wise info */
                    ueTurn_g = i_ueCnt;
                    gettimeofday(&t2,NULL);
/*SPR 21836 Changes Start*/
                    gtpDataBase_t *gtpDb_p = &sectorDb_g.gtpDb_g[ueTurn_g];
/*SPR 21836 Changes End*/
                    gtpDb_p->timeDiff = t2.tv_sec - timer_g;

                    /* Storing number of mixed profiles for packet size and thruput */
                    mixProfileCount = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].mixProfileCount;

                    for ( ; mulB < gtpDb_p->lcCnt ; mulB++ ) 
                    {
#ifdef TG_REAL_EPC
                        sockTxFd = gtpDb_p->rbInfo[mulB].sockTxFd;
                        sockAddr = gtpDb_p->rbInfo[mulB].sockAddr;
#else
#ifndef LAYER2_DLTG_THREAD
                        sockTxFd = sockTxFd_g;
                        sockAddr = sockAddr_g;
#endif
#endif
/*SPR 21836 Changes Start*/
                        if (sectorDb_g.gtpDb_g[i_ueCnt].rbInfo[mulB].sps_lc == 1)
                        {
                            if(spsTraffic[tick_tracker].data_present == 1)
                            {
                                if(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].data == 1)
                                {
                                    for(pktcount=0;pktcount<=spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].numPkt; pktcount++)
                                    {
                                        ueTurn_g = spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].ue_id;
                                        lcId_g = spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].lc_id;
#ifdef LAYER2_DLTG_THREAD
                                        spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer =
                                            getMemFromPool(MAX_PKT_SIZE, NULL);
                                        if (spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer)
                                        {
                                            memSet(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer,
                                                    0, MAX_PKT_SIZE);
                                            initBufferForDlQue(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer,
                                                    spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size);
#ifndef TG_REAL_EPC
                                            createDownlinkPacket(
                                                    &(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].
                                                        lcInfo[mulB].SendBuffer[START_OFFSET_DL_GTP]),
                                                    spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size);
#endif
                                        }
                                        memcpy ( ( &(spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].
                                                        lcInfo[mulB].SendBuffer[START_OFFSET_DL_GTP]) +
                                                    spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].
                                                    lcInfo[mulB].packet_size + GTP_HDR - 4 ),
                                                &sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txSeq, 4);
#else

#ifndef TG_REAL_EPC
                                        createDownlinkPacket(
                                                spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer,
                                                spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size
                                                );
#endif
                                        memcpy(( spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer +
                                                    spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size +
                                                    GTP_HDR - 4 ), &sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txSeq, 4);
#endif
#ifndef LIPA_GW_SEQ_CHK
                                        sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txSeq++;
#endif
#ifndef LAYER2_DLTG_THREAD
                                        bytesSend = sendto(sockTxFd,
                                                spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer,
                                                spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size +
                                                GTP_HDR,0,
                                                (struct sockaddr*)&sockAddr,
                                                sizeof(struct sockaddr_in));
#else
                                        dlTgDataPkt* dlTgDataPkt_p = (dlTgDataPkt*)getMemFromPool(sizeof(dlTgDataPkt), NULL);
                                        if (NULL != dlTgDataPkt_p)
                                        {
                                            dlTgDataPkt_p->dataLength = spsTraffic[tick_tracker].sectorInfo.
                                                ueInfo[i_ueCnt].lcInfo[mulB].packet_size + GTP_HDR + START_OFFSET_DL_GTP ;
                                            dlTgDataPkt_p->dlTgDataPktBuf_p = spsTraffic[tick_tracker].sectorInfo.
                                                ueInfo[i_ueCnt].lcInfo[mulB].SendBuffer;
                                            ENQUEUE_DLTG_DATA_PKT_Q(dlTgDataPkt_p);
                                            bytesSend =  spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].
                                                lcInfo[mulB].packet_size + GTP_HDR + START_OFFSET_DL_GTP;
                                            sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txData += bytesSend - GTP_HDR - START_OFFSET_DL_GTP;
                                        }
                                        else
                                            bytesSend = -1;
#endif
                                        fprintf(sps_logs,"\nSENT DATA PACKET SIZE = %d",
                                                spsTraffic[tick_tracker].sectorInfo.ueInfo[i_ueCnt].lcInfo[mulB].packet_size);
                                        if ( bytesSend == -1 )
                                        {
                                            fprintf(stderr,"\nDL TG send to failed\n");
                                        }
#ifndef LAYER2_DLTG_THREAD
                                        sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txData += bytesSend - GTP_HDR ;
                                        datavolume += (bytesSend - GTP_HDR);
#else
                                        datavolume += (bytesSend - GTP_HDR - START_OFFSET_DL_GTP);
#endif
                                        seqNum_g++;
                                        sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txPkts++;

/*SPR 21836 Changes End*/
                                    }
                                }
                            }
                        }
                        else
                        {
/* + SPR 8669 Fix*/
#ifndef TG_REAL_EPC
                            if (FALSE == gtpDb_p->rbInfo[mulB].txActiveFlag)
                            {
                                continue;
                            }
#endif
/* - SPR 8669 Fix*/
                            profileIdx = gtpDb_p->rbInfo[mulB].profileIdx;
                            for( packetType =0; packetType < mixProfileCount; packetType++)
                            {
                                gtpDb_p->rbInfo[mulB].packet_size[packetType] = 
                                    gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].packetSize[packetType];
                                gtpDb_p->rbInfo[mulB].throughput[packetType] = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].throughput[packetType];
                                gtpDb_p->rbInfo[mulB].varPacketSize = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].varPacketSize[packetType];
                                gtpDb_p->rbInfo[mulB].fixedPktPerTick[packetType] = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].fixedPktPerTick[packetType];
                                gtpDb_p->rbInfo[mulB].remainingPkt[packetType] = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].remainingPkt[packetType];
                                gtpDb_p->rbInfo[mulB].totalNoOfPktVar[packetType] = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].totalNoOfPktVar[packetType];

                                /* + SPR 8669 Fix*/
                                /* LOAD DISTRIBUTION */
/*SPR 21836 Changes Start*/
                                maxNumOfPktPerTick = (totalLcCount_g * gtpDb_p->rbInfo[mulB].remainingPkt[packetType])/
                                    gtpDb_p->rbInfo[mulB].noOfTicks;
                                maxNumOfPktPerTickRemaining = ((totalLcCount_g * 
                                            gtpDb_p->rbInfo[mulB].remainingPkt[packetType]) % 
                                        gtpDb_p->rbInfo[mulB].noOfTicks)/totalLcCount_g;
/*SPR 21836 Changes End*/
                                /* LOAD DISTRIBUTION */
                                /* - SPR 8669 Fix*/

                                lcId_g =  gtpDb_p->rbInfo[mulB].lcId;
                                gtpDb_p->rbInfo[mulB].txTickCount++;

                                if(noOfPktVar_g != 0)
                                {
                                    loopVar[packetType] = noOfPktVar_g;
                                    gtpDb_p->rbInfo[mulB].extraBurstCounter[packetType] = 0;
                                }  
                                else
                                {
                                    loopVar[packetType] = gtpDb_p->rbInfo[mulB].fixedPktPerTick[packetType]+1;
                                    gtpDb_p->rbInfo[mulB].extraBurstCounter[packetType] = 
                                        gtpDb_p->rbInfo[mulB].remainingPkt[packetType];
                                }
#ifndef LAYER2_DLTG_THREAD 
#ifndef TG_REAL_EPC
                                createDownlinkPacket(
                                        gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType],
                                        gtpDb_p->rbInfo[mulB].packet_size[packetType]);
#endif
#endif


                                if(noOfPktVar_g == 0)
                                {
                                    /* LOAD DISTRIBUTION */
/*SPR 21836 Changes Start*/
                                    UInt32 minLcBound = 0, maxLcBound = 0;
                                    minLcBound = (((gtpDb_p->rbInfo[mulB].txTickCount%
                                                    gtpDb_p->rbInfo[mulB].noOfTicks )*
                                                maxNumOfPktPerTick)%totalLcCount_g);
                                    maxLcBound = (minLcBound+maxNumOfPktPerTick);
                                    if(((maxLcBound < totalLcCount_g) &&
                                                (remainPktLcCount >= minLcBound) && 
                                                (remainPktLcCount <  maxLcBound)) ||
                                            ( (maxLcBound >= totalLcCount_g) &&
                                              ( (remainPktLcCount >= minLcBound && 
                                                 remainPktLcCount <  totalLcCount_g) ||
                                                /* +COVERITY 27492 */
                                                (remainPktLcCount < maxLcBound%totalLcCount_g))))
                                        /* -COVERITY 27492 */
/*SPR 21836 Changes End*/
                                        /* LOAD DISTRIBUTION */
                                    {
                                        loopVar[packetType] = gtpDb_p->rbInfo[mulB].fixedPktPerTick[packetType]+1;
                                    }
                                    else
                                    {
                                        loopVar[packetType] = gtpDb_p->rbInfo[mulB].fixedPktPerTick[packetType];
                                    }
                                    /* LOAD DISTRIBUTION */
                                    if(maxNumOfPktPerTickRemaining && ((gtpDb_p->rbInfo[mulB].txTickCount%
                                                    gtpDb_p->rbInfo[mulB].noOfTicks) < maxNumOfPktPerTickRemaining))
                                    {
                                        loopVar[packetType]++;
                                    }
                                    remainPktLcCount++;
                                    /* + SPR 8669 Fix */                                    
/*SPR 21836 Changes Start*/
                                    if(remainPktLcCount >= totalLcCount_g)
/*SPR 21836 Changes End*/
                                    /* - SPR 8669 Fix */                                    
                                        remainPktLcCount=0;
                                    /* LOAD DISTRIBUTION */
                                }
                                else
                                {
                                    loopVar[packetType] = noOfPktVar_g;
                                }
                                /*+ TG Changes for QOS Testing */
/*SPR 21836 Changes Start*/
                                if((gtpDb_p->rbInfo[mulB].upDownFlag & 0x01 ) == 0 )
                                {
                                    if((gtpDb_p->timeDiff >= total_duration_g) && 
                                            BURST_FLAG )
                                    {
/*SPR 21836 Changes End*/
                                        if( (gtpDb_p->rbInfo[mulB].bitRateFlag == 1)  &&
                                                (gtpDb_p->rbInfo[mulB].extraBurstFlag == 1))
                                        {
                                            gtpDb_p->rbInfo[mulB].packet_size[packetType] += 
                                                gtpDb_p->rbInfo[mulB].varPacketSize;
                                            gtpDb_p->rbInfo[mulB].upDownFlag++;
                                            timer_g = t2.tv_sec;
                                        }
                                    }
                                }
/*SPR 21836 Changes Start*/
                                else 
                                {
                                    if((gtpDb_p->timeDiff >= burst_time_g) && 
                                            BURST_FLAG )
                                    {
/*SPR 21836 Changes End*/
                                        if( (gtpDb_p->rbInfo[mulB].bitRateFlag == 1)  &&
                                                (gtpDb_p->rbInfo[mulB].extraBurstFlag == 1))
                                        {
                                            gtpDb_p->rbInfo[mulB].packet_size[packetType] -= 
                                                gtpDb_p->rbInfo[mulB].varPacketSize;
                                            gtpDb_p->rbInfo[mulB].upDownFlag++;
                                            timer_g = t2.tv_sec;
                                        }
                                    }
                                }
                            }
                            /*- TG Changes for Qos testing */
                            for(packetType = 0;packetType < mixProfileCount; packetType++)
                            {
                                for(tempVar = loopVar[packetType];tempVar;tempVar--) 
                                {
/*SPR 21836 Changes Start*/
                                    trxSeq = sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txSeq;
/*SPR 21836 Changes End*/
#if defined(__powerpc__)
                                    tmpPtr = (UInt8 *)&trxSeq;
                                    trxSeq = LTE_GET_U32BIT(tmpPtr);
#endif

#ifdef LAYER2_DLTG_THREAD
                                    /* Start 128 UE: Memory Changes */
                                    memPoolUsage = qvMemPoolGetUsagePercentage();
                                    if (MSG_POOL_HIGH_WATERMARK < memPoolUsage)
                                    {
                                        if (memPoolOverFlow == 0)
                                        {
				#ifdef PRINT
                                            fprintf(stderr, "DLTG Memory overflow memPoolUsage[%d]\n", memPoolUsage);
				#endif
                                        }
                                        memPoolOverFlow = 1;
                                    }
                                    else if (MSG_POOL_LOW_WATERMARK > memPoolUsage)
                                    {
                                        if (memPoolOverFlow)
                                        {
				#ifdef PRINT
                                            fprintf(stderr, "DLTG Memory overflow cleared memPoolUsage[%d]\n", memPoolUsage);
				#endif
                                        }
                                        memPoolOverFlow = 0;
                                    }
                                    if (memPoolOverFlow == 0)
                                    {
                                        if (gtpDb_p->rbInfo[mulB].packet_size[packetType] != 0)
                                        {
                                            gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType] = getMemFromPool(MAX_PKT_SIZE, NULL);
                                            if (gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType])
                                            {
                                                memSet(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType], 0, MAX_PKT_SIZE);
                                                initBufferForDlQue(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType], 
                                                        gtpDb_p->rbInfo[mulB].packet_size[packetType]);

#ifdef LAYER2_DLTG_THREAD
#ifdef ROHC_PROFILE_6 
                                                if (oneTimeFlag)
                                                {
                                                    memCpy  ( tempBuffer,&(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]),sizeof(tempBuffer));
                                                    oneTimeFlag = 0;
                                                }
                                                else
                                                {
                                                    memCpy  ( &(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]),tempBuffer,sizeof(tempBuffer));
                                                }
#endif
#endif

                                                createDownlinkPacket(
                                                        &(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]),
                                                        gtpDb_p->rbInfo[mulB].packet_size[packetType]);
                                                memcpy ( ( &(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]) +
                                                            gtpDb_p->rbInfo[mulB].packet_size[packetType] + GTP_HDR - 4 ),
                                                        &trxSeq, 4);  
#ifndef LIPA_GW_SEQ_CHK
/*SPR 21836 Changes Start*/
                                                sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txSeq++;
/*SPR 21836 Changes End*/
#endif
                                            }
                                            else
                                                ltePanic( "getMemFromPool failed at func [%s] Line[%d]\n", __func__, __LINE__ );
                                        }
#else
#ifndef TG_REAL_EPC
                                        /*SPR 8293 Fix Start*/
                                        /*Prepare GTPU Header*/
#ifdef ENDC_ENABLED
										if(bearType[ueTurn_g][lcId_g] == SCG_SPLIT_BEARER)
										{
											/*Include RAN CONTAINER LEN 12 bytes + 2/3 bytes NR PDCP HEADER*/
 											createDownlinkPacket(
                                                	gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType],
                                                	gtpDb_p->rbInfo[mulB].packet_size[packetType] + nrPdcpInfo[ueTurn_g][lcId_g].containerLen);

										}
										else
#endif
                                        createDownlinkPacket(
                                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType],
                                                gtpDb_p->rbInfo[mulB].packet_size[packetType]);
                                        /*SPR 8293 Fix End*/
#endif
                                        memCpy ( ( gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType] +
                                                    gtpDb_p->rbInfo[mulB].packet_size[packetType] + GTP_HDR - 4 ),
                                                &trxSeq, 4);  
#endif

#ifndef TG_REAL_EPC
                                        /* Set TS and SN value in RTP header */
                                        setSNnTSinRTPPkt(ueTurn_g,mulB,gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType]);
                                        /* Set SYN and ACK fields in TCP header */
                                        controlflowCallforTCP(ueTurn_g,mulB,
                                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType],bytesSend);

                                        /* Set IP-ID value in IP header */
                                        setIPIDinIPPkt(ueTurn_g,mulB,
                                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType]);
#endif                                         

#ifdef LAYER2_DLTG_THREAD
#ifdef ROHC_PROFILE_6 
                                        memCpy( tempBuffer,&(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType][START_OFFSET_DL_GTP]),sizeof(tempBuffer));
#endif
#endif                                         

#ifndef LAYER2_DLTG_THREAD
#ifndef LIPA_GW_SEQ_CHK
/*SPR 21836 Changes Start*/
                                        sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txSeq++;
/*SPR 21836 Changes End*/
#endif
#ifdef ENDC_ENABLED
                                     if(bearType[ueTurn_g][lcId_g] == SCG_SPLIT_BEARER)
                                     {

                           			 	 UInt8 msg_p[1200] = {0};
    						         	 memset(msg_p, 0, MAX_PKT_SIZE);
                                     	 memCpy ( (msg_p),(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType]),8);
                                     	 prepareNRRanContainer(ueTurn_g,lcId_g,msg_p+8);
                                     	 /*8 bytest mandatory GTPU HDR + 12 bytest NR RAN container + 2/3 NR PDCP HDR + Data*/
                                     	 memCpy ( (msg_p+nrPdcpInfo[ueTurn_g][lcId_g].dataOffset),(gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType]+8),gtpDb_p->rbInfo[mulB].packet_size[packetType]);
		   								 bytesSend = sendto(sgnbTxFd_g,
                                                 msg_p, 
                                                 gtpDb_p->rbInfo[mulB].packet_size[packetType] + GTP_HDR +nrPdcpInfo[ueTurn_g][lcId_g].containerLen, 0,
                                                 (struct sockaddr*)&sockAddr,
#ifndef IPV6_ENABLE
                                                 sizeof(struct sockaddr_in)
#else
                                                 sizeof(struct sockaddr_in6)
#endif
                                                 );

                                     }
                                     else
#endif
                                     {
                                        bytesSend = sendto(sockTxFd,
                                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType], 
                                                gtpDb_p->rbInfo[mulB].packet_size[packetType] + GTP_HDR, 0,
                                                (struct sockaddr*)&sockAddr,
#ifndef IPV6_ENABLE
                                                sizeof(struct sockaddr_in)
#else
                                                sizeof(struct sockaddr_in6)
#endif
                                                );
                                     }

#else
                                        if (gtpDb_p->rbInfo[mulB].packet_size[packetType] != 0&& 
                                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType] )
                                        {
                                            dlTgDataPkt* dlTgDataPkt_p = (dlTgDataPkt*)getMemFromPool(sizeof(dlTgDataPkt), NULL);
                                            if (NULL != dlTgDataPkt_p)
                                            {
                                                dlTgDataPkt_p->dataLength = gtpDb_p->rbInfo[mulB].packet_size[packetType] + 
                                                    GTP_HDR + START_OFFSET_DL_GTP ;
                                                dlTgDataPkt_p->dlTgDataPktBuf_p = gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType];
                                                ENQUEUE_DLTG_DATA_PKT_Q(dlTgDataPkt_p);
                                                bytesSend =  gtpDb_p->rbInfo[mulB].packet_size[packetType] + GTP_HDR + START_OFFSET_DL_GTP;
/*SPR 21836 Changes Start*/
                                                sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txData += bytesSend - GTP_HDR - START_OFFSET_DL_GTP;
/*SPR 21836 Changes End*/
                                            }
                                            else
                                            {
                                                freeMemPool( gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].SendBuffer[packetType] );
                                                ltePanic( "getMemFromPool failed at func [%s] Line[%d]\n", __func__, __LINE__ );
                                            }
                                        }
                                        else
                                            bytesSend = -1;
#endif

#ifndef LAYER2_DLTG_THREAD
/*SPR 21836 Changes Start*/
                                        sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txData += (bytesSend - GTP_HDR) ;
/*SPR 21836 Changes End*/
                                        if ( bytesSend == -1 )
                                        {
                                            fprintf(stderr,"\nDL TG send to failed\n");
                                        }
                                        datavolume += (bytesSend - GTP_HDR);
#endif
#ifdef LAYER2_DLTG_THREAD
                                        datavolume += (bytesSend - GTP_HDR - START_OFFSET_DL_GTP);
#endif
                                        seqNum_g++;
                                        if (trafficProfileVar_g) {
#ifndef LAYER2_DLTG_THREAD
                                            bytesSend = sendto(sockTxFd,
                                                    sendBuffer1,
                                                    136 + GTP_HDR,0,
                                                    (struct sockaddr*)&sockAddr,
#ifndef IPV6_ENABLE
                                                    sizeof(struct sockaddr_in)
#else
                                                    sizeof(struct sockaddr_in6)
#endif
                                                    );
                                            bytesSend = sendto(sockTxFd,
                                                    sendBuffer2,
                                                    40 + GTP_HDR,0,
                                                    (struct sockaddr*)&sockAddr,
#ifndef IPV6_ENABLE
                                                    sizeof(struct sockaddr_in)
#else
                                                    sizeof(struct sockaddr_in6)
#endif
                                                    );
                                            bytesSend = sendto(sockTxFd,
                                                    sendBuffer2,
                                                    40 + GTP_HDR,0,
                                                    (struct sockaddr*)&sockAddr,
#ifndef IPV6_ENABLE
                                                    sizeof(struct sockaddr_in)
#else
                                                    sizeof(struct sockaddr_in6)
#endif
                                                    );
#endif
                                        }
/*SPR 21836 Changes Start*/
                                        sectorDb_g.ueDataFlow_g[ueTurn_g][lcId_g].txPkts++;
/*SPR 21836 Changes End*/
                                        pktCounter_g++;
#ifdef LAYER2_DLTG_THREAD
                                    }
#endif
                                }
                            }
                            if((gtpDb_p->rbInfo[mulB].txTickCount%
                                        gtpDb_p->rbInfo[mulB].noOfTicks)==0)
                            { 
#ifdef PACKETS_SENT_PER_SEC
                                fprintf(stderr,"No of packets sent in %d Ticks(1sec): %d \n",
                                        gtpDb_p->rbInfo[mulB].noOfTicks,
                                        pktCounter_g);
#endif
                                pktCounter_g = 0;
                            }
                            if( gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].profileTimerCount == 0 )
                            {
                                profileIdx++;
                                if(profileIdx == gtpDb_p->rbInfo[mulB].tpCount)
                                {
                                    profileIdx = 0;
                                }
                                gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].profileTimerCount = 
                                    gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].profileTimer;
                            }
                            gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].profileTimerCount--;
                            gtpDb_p->rbInfo[mulB].profileIdx = profileIdx;

                            /* resetting the entries if an LC timer equals to total ecexution time */
                            if(gtpDb_p->rbInfo[mulB].isLCTimerPresent)
                            {
                                if(gtpDb_p->rbInfo[mulB].totalExecTime == 0)
                                {
                                    for(profileIdx = 0; profileIdx<gtpDb_p->rbInfo[mulB].tpCount;profileIdx++)
                                    {
                                        for(packetType = 0;
                                                packetType < gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].mixProfileCount;
                                                packetType++)
                                        {
                                            gtpDb_p->rbInfo[mulB].tgProfileInfo[profileIdx].packetSize[packetType] = 0;
                                        }
                                    }
                                    gtpDb_p->rbInfo[mulB].isLCTimerPresent = 0;
                                }
                                else
                                {
                                    gtpDb_p->rbInfo[mulB].totalExecTime--;
                                }
                            }
                        }
                    }

                }
#ifndef TG_REAL_EPC
#endif
            tick_tracker++;
            if( tick_tracker == 1000)
                tick_tracker = 0;

            ueTurn_g = 0; /*Reset Round Robin ID to 0*/
            lcId_g = 0; /*Reset Round Robin ID to 0*/
            mytickcount++;
            mytickcount%=1000;
            clock_gettime(CLOCK_REALTIME,&endTime);
            if(timer.tv_nsec > (((endTime.tv_sec - startTime.tv_sec)*1000000000)+
                        (endTime.tv_nsec - startTime.tv_nsec)))
            {
                timer.tv_nsec = timer.tv_nsec -
                    (((endTime.tv_sec - startTime.tv_sec)*1000000000)+
                     (endTime.tv_nsec - startTime.tv_nsec));
            }
            else
            {
                timer.tv_nsec = 1000000*timeInMs_g -  ((((endTime.tv_sec - startTime.tv_sec)*1000000000)+
                            (endTime.tv_nsec - startTime.tv_nsec)) - timer.tv_nsec);
            }
            if(timer.tv_nsec > 1000000*timeInMs_g)
            {
                timer.tv_nsec=1000000*timeInMs_g;
            }
        }
        else
        {
            timer.tv_sec = 1;
        }
#ifdef TG_REAL_EPC
        loadCalcTimeDiff = ((endTime.tv_sec - lastDispTime.tv_sec)*1000 +
                ((endTime.tv_nsec - lastDispTime.tv_nsec)/1000000));
        diff = (UInt32)loadCalcTimeDiff;
        if(loadCalcTimeDiff >= (throughputDisplayVar_g/timeInMs_g) )
        {
/*SPR 21836 Changes Start*/
                for(loop_counter=0;loop_counter< sectorDb_g.ueCount;loop_counter++)
                {
                    for(lc_counter= 0;lc_counter < sectorDb_g.gtpDb_g[loop_counter].lcCnt; lc_counter++)
                    {
                        datavolume /= 1024;
                        datavolume *= 1000;
                        datavolume /= 1024;
                        datavolume *= 8;
                        datavolume /= diff;
                        MbPS_LOAD( sector_counter, loop_counter,
                                sectorDb_g.gtpDb_g[loop_counter].rbInfo[lc_counter].lcId);
                        sectorDb_g.gtpDb_g[loop_counter].rbInfo[lc_counter].lastDisplayTick=
                            sectorDb_g.gtpDb_g[loop_counter].rbInfo[lc_counter].txTickCount;
/*SPR 21836 Changes End*/
                        datavolume =0;
                        lastDispTime.tv_sec = endTime.tv_sec;
                        lastDispTime.tv_nsec = endTime.tv_nsec;
                    }
                } 
            }
#endif
#ifndef CAVIUM_BOARD
        pselect(0,NULL,NULL,NULL,&timer,NULL);
#else
        struct timespec rem_time = {0};
        SInt32 ret_value = -1;
        do
        {
            ret_value = nanosleep(&timer,&rem_time);
            if(ret_value < 0)
            {
                timer.tv_nsec = rem_time.tv_nsec;
                timer.tv_sec = rem_time.tv_sec;
            }
        }
        while(ret_value < 0);
#endif
    }
#endif
}
/****************************************************************************
 * * Function Name  : initDownlinkTrafficGen
 * * Inputs         : None
 * * Outputs        : None
 * * Returns        : None
 * * Description    : This function calls ul and dl processing based on mode. 
 * ****************************************************************************/

void initDownlinkTrafficGen(void *srcAddr, void *dstAddr, UInt32 tgMode)
{
    mode_g = tgMode; 
    switch(tgMode)
    {
        case TG_UL_MODE:
        /*processULPacket(srcAddr);
          break;*/
        case TG_DL_MODE:
        case TG_UL_DL_MODE:
/*SPR 22575 Changes Start*/
#ifdef LTE_EMBMS_SUPPORTED
/*SPR 22575 Changes End*/
#ifndef LAYER2_DLTG_THREAD 
#ifndef TG_REAL_EPC
        /* tg-change --- updated below code unicast and multicast data */ 
        if(UNICAST_DATA == uniMultiCastData_g)
        {
        if(pthread_create(&ulThreadId_g,PNULL,processULPacket,srcAddr)< 0)
        {
            abort();
        }
        }
/* LAYER2_DLTG_THREAD Compilation fix Start */
        if(UNICAST_DATA == uniMultiCastData_g)
        {
            processDLPacket(dstAddr);
        }
        else
        {
            processULPacket(srcAddr);
        }
#endif
#endif
/*SPR 22575 Changes Start*/
#else
#ifndef LAYER2_DLTG_THREAD 
#ifndef TG_REAL_EPC
        if(pthread_create(&ulThreadId_g,PNULL,processULPacket,srcAddr)< 0)
        {
            abort();
        }
#endif
#endif
/* LAYER2_DLTG_THREAD Compilation fix End */
        processDLPacket(dstAddr);
#endif
/*SPR 22575 Changes End*/
#ifdef PDCP_GTPU_INTF
        UInt8 inst=0;
        ULong32 threadId = 0;
        for(inst=0;inst<num_instance;inst++)
        {
            threadId = 0;
            fprintf(stderr,"THread created ins[%d]\n",inst);
            if(0 != threadCreate(&(threadId), THREAD_CREATE_DETACHED,
                        THREAD_SCHED_DEFAULT, 0,
                        THREAD_INHERIT_SCHED_DEFAULT,
                        THREAD_SCOPE_SYSTEM,
                        dlPacketDispatcher, 
                        (void*) (&instThread_g[inst])))
            {
                ltePanic(" Unable to initialise the Layer2 because"
                        "encoder thread creation Failed.\n");
            }


        }
#endif
        break;
        default:
        fprintf(stderr, "Invalid TG Mode received");
        exit(0);
    }
}
/****************************************************************************
 * * Function Name  : main
 * * Inputs         : None
 * * Outputs        : None
 * * Returns        : return 0. 
 * * Description    : This function is entry point for downlink TG. It takes 
 * *                : runtime paramters for thread binding and other processing. 
 * ****************************************************************************/
#ifdef LAYER2_DLTG_THREAD
void * dlTgThreadExecutionSchedular(void * param)
#else
SInt32 main(SInt32 argc, SInt8 *argv[])
#endif
{
    /*+COVERITY 5.2.2 - 32679*/
    FILE 		*traffic_profile_fp,*fp;
    /*-COVERITY 5.2.2 - 32679*/
    /* Compilation 12-JUN-2014 fix start */
    //FILE		*sps_profile_fp;
    /* Compilation 12-JUN-2014 fix end */
    UInt8		spsIndex = 0;
    char 		buf[100],*current;
    char 		str1[100],str2[100];
    UInt32 		temp,loopvar,lc_counter;
#ifndef LAYER2_DLTG_THREAD
    UInt16      ipChecksum = 0;
    UInt16      udpChecksum = 0;
    UInt16      headerStart = 8;
    UInt16      packetType = 0;
#endif
    UInt8 		lc_count = 0;
    /* +- SPR 18268 */
    UInt16 		ueIndex = 0;
    /* +- SPR 18268 */
    UInt64 		coreNum = 0;
    UInt16 count = 0;
    UInt8 		tpCounter = 0;
    UInt8 isTimerPresent = 0;
    UInt8		sectorId_g = 0;
    char * tempCurrent = NULL;
    char * currentPktSz = NULL;
    char * currentThruput = NULL;
    UInt16 i = 0;
    pid_t 		p = 0;

    UInt16 repetition = 0;
    UInt8 interPktArvlTm = 0;
    UInt16 offset = 0;

    fprintf(stderr,"DL-Traffic Generator is starting......................\n");
#ifndef LAYER2_DLTG_THREAD
/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
/* tg-change --- updated command line arguments from 11 to 12 */
#ifdef LTE_EMBMS_SUPPORTED
    if (argc < 12) 
#else
    if (argc < 11) 
#endif
    {
#ifndef TG_REAL_EPC
#ifdef LIPA_GW
        /* SPR 18822 Fix Start */
        fprintf(stderr,"Usage is ./lgwDlTrafficGen <core num to bind> \
                <source ip address> <destination ip address> <traffic gen mode> \
                <number of packets > <Time in ms to pump> \
                <throuhput display in ms> <traffic-profile> <lastUE> <start_ueID> \
                <ext_Header_support(optional)>\n"); 
#else
#ifdef LTE_EMBMS_SUPPORTED
        fprintf(stderr,"Usage is ./dlTrafficGen <core num to bind> \
                <source ip address> <destination ip address> <traffic gen mode> \
                <number of packets > <Time in ms to pump> \
                    <throuhput display in ms> <traffic-profile> <lastUE> <start_ueID> <U(1)/M(2)>\n"); 
#else
        fprintf(stderr,"Usage is ./dlTrafficGen <core num to bind> \
                <source ip address> <destination ip address> <traffic gen mode> \
                <number of packets > <Time in ms to pump> \
                    <throuhput display in ms> <traffic-profile> <lastUE> <start_ueID> <U(1)/M(2) data> \
                <ext_Header_support(optional)>\n"); 
#endif
        /* SPR 18822 Fix End */
#endif
#else
        fprintf(stderr,"Usage is ./dlTgGen <core num to bind> \
                <source ip address> <destination ip address of first UE> <traffic gen mode> \
                <number of packets > <Time in ms to pump> \
                <throuhput display in ms> <traffic-profile> <lastUE> <start_ueID>\n"); 
#endif
            return 0;
    }
/*SPR 21653 changes end*/
#endif
#ifdef LAYER2_DLTG_THREAD
    coreNum = dlTgCoreNum_g;
    throughputDisplayVar_g = putDisplayVar_g ;
#else
    coreNum = atoi(argv[1]);
    noOfPktVar_g = atoi(argv[5]);
    timeInMs_g = atoi(argv[6]);
    throughputDisplayVar_g = atoi(argv[7]);
    trafficProfileVar_g = atoi(argv[8]);
    /* tg-change --- get 11th command line argument */
#ifdef LTE_EMBMS_SUPPORTED
    uniMultiCastData_g = atoi(argv[11]);
#endif
    /* SPR 18822 Fix Start */
    if(argc > 12)
    {
        /*  1-->extension header noti with PDCP support
         *  2--> extension header noti with PDCP and UDP support
         *  3--> extension header noti with PDCP support and invalid TEID to create Error indication
         *  4--> extension header noti with PDCP and UDP support and invalid TEID to create Error indication */
        ext_hdr_prof_g = atoi(argv[12]);
        if (ext_hdr_prof_g >4)
        {
            fprintf(stderr,"Inavlid argument for Etension Header Notificaion value range:1-4");
            ext_hdr_prof_g = 0;
        }
    }
    /* SPR 18822 Fix End */
#endif
    cpu_set_t cpuSetSch;
    CPU_ZERO(&cpuSetSch);
    CPU_SET(coreNum ,&cpuSetSch);
    CPU_SET(coreNum ,&cpuSetSch);
    assert( -1 != sched_setaffinity(p, sizeof(cpu_set_t), &cpuSetSch));

#if defined( LAYER2_DLTG_THREAD) && !defined(PDCP_GTPU_INTF)
#ifdef LAYER2_PHYSIM_THREAD
    threadSetRtPriority(SCHED_FIFO,40);
#else
    threadSetRtPriority(SCHED_FIFO,10);
#endif
#else
    threadSetRtPriority(SCHED_FIFO,98);
#endif

    if(timeInMs_g == 0)
    {
        fprintf(stderr, " \nTime in Ms to pump cannot be equal to 0\n");
#ifndef LAYER2_DLTG_THREAD
        return 0;
#else
        return NULL;
#endif

    } 	
    if(noOfPktVar_g != 0)
    {
        fprintf(stderr," \nNo of Packets should be equal to zero as it is" 
                " calculated from throughput mentioned in TGConfig.txt\n");

#ifndef LAYER2_DLTG_THREAD
        return 0;
#else
        return NULL;
#endif

    }	

#ifndef LAYER2_DLTG_THREAD
/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
    if(argc > 9)
    {
        ueId_g = atoi(argv[9]);
        if(ueId_g < 0 || ueId_g > MAX_UE)
        {
            ueId_g = 0;
        }
        fprintf(stderr,"Right ueId is %d\n",ueId_g);
    }
/*SPR 21653 changes end*/
    MissCntrs_g= fopen("UL_dropped_seq.txt","w+");
/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
    if(argc > 10)
    {
        ueStart_g = atoi(argv[10]);
        if(ueStart_g < 0 || ueStart_g >= MAX_UE)
        {
            ueStart_g = ueId_g;
        }
        if(ueId_g < ueStart_g)
        {
            ueStart_g = ueId_g;
        }
    }
    /* tg-change ---- no print required for multicast data */
    if(UNICAST_DATA == uniMultiCastData_g)
    {
#ifdef LIPA_GW
    fprintf(stderr,"\n LIPA DL TG Traffic Started %d to %d UE \n", ueStart_g,ueId_g);
#else
    fprintf(stderr,"\n DL TG Traffic Started %d to %d UE \n", ueStart_g,ueId_g);
#endif
    }
/*SPR 21653 changes end*/
#endif

#ifndef LAYER2_DLTG_THREAD 
    srcIpAddr_g = argv[2];
#endif

    loopvar=0;
#ifdef LIPA_GW
/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
    fp = fopen("../cfg/secUlTrafficGen.txt","rb");
/*SPR 21653 changes end*/
#else
/* SPR 13326 Changes Start */
/*SPR 21653 changes start*/
/* SPR 13326 Changes End */
    fp = fopen("../cfg/ulTrafficGen.txt","rb");
/*SPR 21653 changes end*/
#endif
    if(fp == NULL)
    {
        fprintf(stderr,"Unable to open the file ulTrafficGen.......\n");
        exit(0);
    }

/* CA DL-TG CHANGES start */
/*SPR 21836 Changes Start*/
    memset((void *)&sectorDb_g, 0, sizeof(sectorDataBase_t));
    /** MBMS CHANGES start */
#ifndef LAYER2_DLTG_THREAD
     /* tg-change --- if condition and arguments added
                      to function populateMBMSConfig */ 
    if(MULTICAST_DATA == uniMultiCastData_g)
    {
        memset((void *)&syncAreaDB_g, 0, sizeof(syncAreaDB_t)); 

        // Fill MBMS sp[ecific information in global DS 
        populateMBMSConfig(argv[2], argv[3]);
    }
#endif
    /** MBMS CHANGES end */
/* CA DL-TG CHANGES end */
    while(fgets(buf,100,fp))
    {
        if(sscanf(buf,"UE-COUNT=%d",&temp)>0)
        {
            ueCount_g = sectorDb_g.ueCount=temp;
		/* SPR 22015 Fix Start */
		if(sectorDb_g.ueCount > MAX_UE)
		{
			sectorDb_g.ueCount = ueCount_g = MAX_UE;
		}
		/* SPR 22015 Fix End */
            fprintf(stderr, "UE-COUNT=%d\n",temp);
        }
        else if(sscanf(buf,"UE-ID=%d",&temp)>0)
        {
           if( temp < MAX_UE )
	   {
            ueIndex = sectorDb_g.gtpDb_g[temp].ueId = temp ;
	   }
           else
           {
		   ueIndex = MAX_UE;
	   }
            fprintf(stderr, "UE-ID=%d\n",temp);
        }
        else if(sscanf(buf,"LC-COUNT=%d",&temp)>0)
        {
            if(ueIndex < MAX_UE)
            {
            fprintf(stderr, "LC-COUNT=%d\n",temp);
            /* The below assignment is from ulTrafficGen.txt based on assumption 
             * that the same lc-count will be received 
             * from eGTPU after successful signaling of same number of LCs */      
            sectorDb_g.gtpDb_g[ueIndex].lcCnt=temp;
            for(lc_count=0;lc_count<sectorDb_g.gtpDb_g[ueIndex].lcCnt;lc_count++)
            {
                memset(buf,0,sizeof(buf));
                fgets(buf,100,fp);
                if(sscanf(buf,"LC-ID=%d",&temp)>0)
                {
                    fprintf(stderr, "\tLC-ID=%d\n",temp);
                    sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].lcId = temp;
#ifdef LIPA_GW_SEQ_CHK
                    /* in case of LIPA GW is running, this flag removes the sequence number from SGW */
                    /* because otw LIPA and SGW both generating packet will show mismatch at ulTrafficGen */
                    sectorDb_g.ueDataFlow_g[ueIndex][temp].txSeq = 0xFFFFFFFF;
#endif
                    current=strtok(buf," ");
                    current=strtok(NULL," ");
                    strcpy(str1,current);

                    if( (strncmp(str1,"SPS",3)) == 0)
                    {
                        sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].sps_lc = 1;
                        current=strtok(NULL," ");
                        strcpy(str1,current);
                    }

                    /* parsing for total execution timer */
                    current=strtok(NULL," ");
                    if (current!= NULL)
                    {
                        strcpy(str2,current);
                        isTimerPresent = 1;
                    }

                    sscanf(str1,"TP-ID=%d",&temp);
                    fprintf(stderr, "\tTP-ID=%d\n",temp);

                    current = strtok(str1,",");
                    sscanf(str1,"TP-ID=%d",&temp);
                    sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].tpId[count]= temp;
                    current = strtok(NULL,",");
                    count++;
                    while(current != NULL)
                    {
                        sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].tpId[count]= atoi(current);
                        current = strtok(NULL,",");
                        count++;
                    }
                    sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].tpCount = count;
                    count = 0; //Resetting the count

                    /* process only if timer is set */
                    if(isTimerPresent)
                    {
                        /* processing for LC-TIMER */
                        sscanf(str2,"LC-TIMER=%d",&temp);
                        fprintf(stderr, "\tLC-TIMER=%d\n",temp);
                        sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].totalExecTime = temp;
                        if (temp)
                        {
                            sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].isLCTimerPresent = 1;
                        }
                    }
                    else
                    {
                        sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].totalExecTime = 0;
                        sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].isLCTimerPresent = 0;
                    }
                    if(current != NULL)
                    {
                        strcpy(str1,current);
                    }
                    temp = strncmp(str1,"NON-GBR",7);

                    if(temp == 0)
                    {
                        sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].bitRateFlag = 1;	
                        printf("Bit rate flag is set for LC-ID : %d\n", 
                                sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].lcId);

                    }
                    else  
                    {
                        sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].bitRateFlag = 0;
                        fprintf(stderr,"nothing for LC-ID= %d\n",
                                sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].lcId);
                    }
                }


            }
	    
	    }
        }
        else if (sscanf(buf,"Load Variation Percentage=%d",&temp))
        {
            if(ueIndex < MAX_UE)
            {
            load_variation_g = temp;
            printf("load variation is %f\n",load_variation_g);
            if(load_variation_g == 0 )
            {
                sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].bitRateFlag = 0;
            }
        }	
        }	
        else if (sscanf(buf,"Time for the burst(in seconds)=%d",&temp))
        {
            if(ueIndex < MAX_UE)
            {
            burst_time_g = temp;
            printf("burst_time_g is %f\n",burst_time_g);
            if(burst_time_g == 0 )
            {
                sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].bitRateFlag = 0;
            }
        }
        }
        /*+ TG Changes for QOS Testing */
        else if(sscanf(buf,"Burst Periodicity(in seconds)=%d",&temp))
        {
            if(ueIndex < MAX_UE)
            {
            total_duration_g = temp;
            printf("total_duration_g is %f\n",total_duration_g);
            if(total_duration_g == 0)
            {
                sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].bitRateFlag = 0;
/*SPR 21836 Changes End*/
            }
	    }
        }
        /*SPR 21727 changes start*/
#ifdef PDCP_GTPU_INTF
	else if(sscanf(buf,"NUM_INSTANCE=%d",&temp)>0)
	{
		num_instance = temp;
                UInt8 index = 0; 
		for(instance_ctr=0; instance_ctr < num_instance*5;instance_ctr++)
		{
			fgets(buf,100,fp);	
				if(sscanf(buf,"INSTANCE_ID=%d",&temp)>0)
				{
					instance_id[index] = temp;
					fprintf(stderr,"INSTANCE_ID=%d\n",instance_id[index]);
				}
				if(sscanf(buf,"START_UE_ID=%d",&temp)>0)
				{
					start_ue_id[index]  = temp;
					fprintf(stderr,"START_UE_ID=%d\n",start_ue_id[index]);
				}
				else if(sscanf(buf,"NUM_OF_DATA_UE=%d",&temp)>0)
				{
					num_of_data_ue[index] = temp;
					fprintf(stderr,"NUM_OF_DATA_UE=%d\n",num_of_data_ue[index]);
				}
				else if(sscanf(buf,"TOTAL_UE=%d",&temp)>0)
				{
					total_ue[index]= temp;
					fprintf(stderr,"TOTAL_UE=%d\n",total_ue[index]);

					/*SPR 21836 Changes Start*/
					if(num_of_data_ue[index] > total_ue[index])
					{       
						num_of_data_ue[index] = total_ue[index];
						fprintf(stderr," Number of active UE's cannot be more than connected UE's ! \n Setting NUM_OF_DATA_UE [%d] \n",num_of_data_ue[index]);
					}
					/*SPR 21836 Changes End*/
				}
				else if(sscanf(buf,"DATA_TO_PUMP=%d",&temp)>0)
				{
					data_to_pump[index] = temp;
					fprintf(stderr,"data_to_pump=%d\n",data_to_pump[index]);
                                    index++;
				}
		}
	}
    dataParse_g = 1;
#endif
    /*SPR 21727 changes start*/

#ifdef ROHC_PROFILE_6
/*SPR 21836 Changes Start*/
        sectorDb_g.gtpDb_g[ueIndex].rbInfo[lc_count].synack_tcp = 0;
/*SPR 21836 Changes End*/
#endif

         }
/*SPR 21727 changes end*/
/*SPR 21836 Changes Start*/

        printf("UE Count is [%d]\n",sectorDb_g.ueCount); 
        for(loopvar = 0; loopvar <sectorDb_g.ueCount  ; loopvar++)
        {
            printf("For UE-ID[%d]----- LC Count is [%d]\n",
                    sectorDb_g.gtpDb_g[loopvar].ueId, 
                    sectorDb_g.gtpDb_g[loopvar].lcCnt);

/*SPR 21836 Changes End*/
    }
#ifdef ROHC_PROFILE_6
    initProfile6Params();
#endif

#ifdef LIPA_GW
    traffic_profile_fp = fopen("../cfg/secTGConfig.txt","rb");
#else
    traffic_profile_fp = fopen("../cfg/TGConfig.txt","rb");
#endif
    if (traffic_profile_fp == PNULL)
    {
#ifdef LIPA_GW
        fprintf(stderr,"unable to open the configuration file secTGConfig.txt............EXITING NOW ");
#else
        fprintf(stderr,"unable to open the configuration file TGConfig.txt............EXITING NOW ");
#endif
        exit(0);
    }
    memset(buf,sizeof(buf),0);
/*SPR 21836 Changes Start*/
        sectorDataBase_t *secDb_p = &sectorDb_g;
/*SPR 21836 Changes End*/
        for (loopvar=0; loopvar< secDb_p->ueCount;loopvar++)
        {
            gtpDataBase_t *gtpDb_p = &secDb_p->gtpDb_g[loopvar];
            rewind(traffic_profile_fp);
            fgets(buf,sizeof(buf),traffic_profile_fp);
            fgets(buf,sizeof(buf),traffic_profile_fp);
            for(lc_counter= 0;lc_counter < gtpDb_p->lcCnt; lc_counter++)
            {
                RbInfo * rbInfo_p = &gtpDb_p->rbInfo[lc_counter];
                offset = 0;
                interPktArvlTm = 0;
                rewind(traffic_profile_fp);  // sets the file pointer to the beginning of the file of that stream
                fgets(buf,sizeof(buf),traffic_profile_fp); // reads the file pointed by FP and stores it in buf 
                fgets(buf,sizeof(buf),traffic_profile_fp);
                while(fgets(buf,sizeof(buf),traffic_profile_fp))
                {
                    if(sscanf(buf,"TP-ID=%d",&temp)>0 ) // reads the formatted string and stores in temp 
                    {
                        for(tpCounter = 0;tpCounter < rbInfo_p->tpCount; tpCounter++)
                        {
                            count = 0;
                            if( rbInfo_p->tpId[tpCounter] == temp)
                            {
                                current= strtok_r(buf," ",(char **)&buf);
                                current= strtok_r(NULL," ",(char **)&buf); //Moving current to next substring i.e. packetSize
                                strcpy(str1,current);
                                tempCurrent = strtok(str1,",");
                                while(tempCurrent != NULL)
                                {
                                    tempCurrent = strtok(NULL,",");
                                    count++;
                                }

                                /* Storing the count in the inner structure in
                                    order to process per LC per TP ID information */
                                rbInfo_p->tgProfileInfo[tpCounter].mixProfileCount = count;

                                currentPktSz = strtok(current,",");

                                if ( rbInfo_p->sps_lc == 1)
                                {
                                    rbInfo_p->spsProfile[spsIndex].pktSize = atoi(currentPktSz);
                                }
                                else
                                {
                                    for(i = 0;i<count&&(currentPktSz != NULL);i++)
                                    {
                                        rbInfo_p->tgProfileInfo[tpCounter].packetSize[i] = atoi(currentPktSz);
                                        currentPktSz = strtok(NULL,",");
                                    }
                                }

                                current = strtok_r(NULL," ",(char **)&buf); //Moving current to next substring i.e. thruput
                                currentThruput = strtok(current,",");
                                for(i = 0;i<count&&(currentThruput != NULL);i++)
                                {
                                    rbInfo_p->tgProfileInfo[tpCounter].throughput[i] = atof(currentThruput);
                                    currentThruput = strtok(NULL,",");
                                }

                                current = strtok_r(NULL," ",(char **)&buf); //Moving current to next substring i.e. profileTimer

                                if ( rbInfo_p->sps_lc == 1 )
                                {
                                    rbInfo_p->spsProfile[spsIndex].interPktArvlTm = atoi(current);
                                    rbInfo_p->spsProfile[spsIndex].repetition = rbInfo_p->totalExecTime;
                                    if (rbInfo_p->spsProfile[spsIndex].repetition == 0)
                                    {
                                        rbInfo_p->spsProfile[spsIndex].repetition = 1000;
                                    }
                                }
                                else
                                {
                                    rbInfo_p->tgProfileInfo[tpCounter].profileTimer = atoi(current);
                                    /* Initialize the profileTimerCount */
                                    rbInfo_p->tgProfileInfo[tpCounter].profileTimerCount = 
                                        rbInfo_p->tgProfileInfo[tpCounter].profileTimer;
                                }
#ifndef TG_REAL_EPC
#ifndef LAYER2_DLTG_THREAD
#ifdef ROHC_PROFILE_6 // profile TCP
#ifndef UE_IPV6_ADDR
                                /*  This buffer is  used as a hardcoded value which contains IP/TCP header
                                 *  for UE (containing UE IP address). The same packet is sent for multiple UE
                                 *  (w/o change in UE IP Address)*/
                                UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
                                    0x45,0x02,0x00,0x00,0x23,0x21,0x40,0x00, /* IP header */
                                    0xff,0x06,0x00,0x00,0xe0,0x00,0x00,0xfb,
                                    0xac,0x10,0x51,0x15,
                                    0x14, 0xe9, 0x14, 0xea, 0x03, 0x46, 0xd0, 0x0a, /* TCP Header */
                                    0x10, 0x02, 0x30, 0x04, 0xa0, 0x00, 0x39, 0x08,
                                    0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,
                                    0x04, 0x02, 0x08, 0x0a, 0xe2, 0x08, 0x2f, 0x90,
                                    0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07,
                                    0x61,0x6e,0x69,0x6c};  /* Payload */



#else

                                UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,0x60,
                                    0x60,0x20,0x00,0x00,0x00,0x00,0x06,0xff, /* IPv6 Header */
                                    0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
                                    0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x14,
                                    0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
                                    0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x13,
                                    0x14, 0xe9, 0x14, 0xea, 0x03, 0x46, 0xd0, 0x0a, /* TCP Header */
                                    0x10, 0x02, 0x30, 0x04, 0xa0, 0x00, 0x39, 0x08,
                                    0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,
                                    0x04, 0x02, 0x08, 0x0a, 0xe2, 0x08, 0x2f, 0x90,
                                    0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07,
                                    0x61,0x6e,0x69,0x6c};  /* Payload */

#endif
#elif ROHC_PROFILE_1

                                /*  This buffer is  used as a hardcoded value which contains IP/UDP/RTP header
                                 *  for UE (containing UE IP address). The same packet is sent for multiple UE 
                                 *  (w/o change in UE IP Address)	*/		
#ifndef UE_IPV6_ADDR
                                UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,0x45,
                                    0x02,0x00,0x00,0x23,0x21,0x40,0x00,0xff,0x11,
                                    0x00,0x00,0xac,0x10,0x51,0x15,0xe0,0x00,0x00,
                                    0xfb,0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00,
                                    0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x5d,
                                    0x7c,0x95,0x7c,0x61,0x6e,0x69,0x6c} ;


#else


                                UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,0x60,
                                    0x20,0x00,0x00,0x00,0x00,0x11,0xff,0x07,0xD1,
                                    0x07,0xDA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                    0x00,0x00,0x18,0x00,0x14,0x07,0xD1,0x07,0xDA,
                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                    0x18,0x00,0x13,0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00,
                                    0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x5d,
                                    0x7c,0x95,0x7c,0x61,0x6e,0x69,0x6c} ;
#endif
#else
                                /*  This buffer is  used as a hardcoded value which contains IP/UDP header
                                 *  for UE (containing UE IP address). The same packet is sent for multiple UE 
                                 *  (w/o change in UE IP Address)	*/		
#ifndef UE_IPV6_ADDR
                                UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,0x45,
                                    0x02,0x00,0x00,0x23,0x21,0x40,0x00,0xff,0x11,
                                    0x00,0x00,0xac,0x10,0x51,0x15,0xe0,0x00,0x00,
                                    0xfb,0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00,
                                    0x61,0x6e,0x69,0x6c};
#else
                                UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] =  {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,0x60,
                                    0x20,0x00,0x00,0x00,0x00,0x11,0xff,0x07,0xD1,
                                    0x07,0xDA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                    0x00,0x00,0x18,0x00,0x14,0x07,0xD1,0x07,0xDA,
                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                    0x18,0x00,0x13,0x14,0xe9,0x14,0xea,0x00,0x00,
                                    0x00,0x00,0x61,0x6e,0x69,0x6c};

#endif
#endif
#endif
#else
                               UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x61,0x6e,0x69,0x6c,0x61,0x6e,0x69,0x6c};
#endif
                               if( rbInfo_p->sps_lc == 1 )
                               {
#ifndef LAYER2_DLTG_THREAD
                                    /*SPS Buffer changes start*/
                                    UInt8 spsBuffer[1024];
                                    memcpy(spsBuffer,sendBuffer3,60);
                                    rbInfo_p->spsProfile[spsIndex].SendBuffer = spsBuffer;
#ifndef TG_REAL_EPC
                                    prepareSendBuffer(
                                      rbInfo_p->spsProfile[spsIndex].SendBuffer,
                                      headerStart,
                                      rbInfo_p->spsProfile[spsIndex].pktSize);                                    
                                    /*SPS Buffer changes stop*/                                          
#endif
#endif
                                    for(repetition=0; repetition < rbInfo_p->spsProfile[tpCounter].repetition ; repetition++)
                                    {
                                        offset = offset + interPktArvlTm;
                                        if (offset >= 1000)
                                        {
                                            break;
                                        }
/*SPR 21836 Changes Start*/
                                        spsTraffic[offset].sectorInfo.ueInfo[loopvar].lcInfo[lc_counter].data = 1;
                                        spsTraffic[offset].data_present = 1;
                                        spsTraffic[offset].sectorInfo.num_ue = loopvar +1;
                                        spsTraffic[offset].sectorInfo.ueInfo[loopvar].ue_id = loopvar;
                                        spsTraffic[offset].sectorInfo.ueInfo[loopvar].num_lc = lc_counter + 1;
                                        spsTraffic[offset].sectorInfo.ueInfo[loopvar].lcInfo[lc_counter].lc_id = lc_counter+3;
                                        spsTraffic[offset].sectorInfo.ueInfo[loopvar].lcInfo[lc_counter].packet_size =
                                            rbInfo_p->spsProfile[tpCounter].pktSize;
#ifndef LAYER2_DLTG_THREAD
                                        spsTraffic[offset].sectorInfo.ueInfo[loopvar].lcInfo[lc_counter].SendBuffer =
                                            rbInfo_p->spsProfile[tpCounter].SendBuffer ;
#endif
                                        printf("\nrepetition = %d spsTraffic[%d].ueInfo[%d].lcInfo[%d].packet_size=%d\n",repetition,offset,loopvar,lc_counter,spsTraffic[offset].sectorInfo.ueInfo[loopvar].lcInfo[lc_counter].packet_size);
                                        interPktArvlTm = rbInfo_p->spsProfile[tpCounter].interPktArvlTm;
                                        if(interPktArvlTm == 0)
                                        {
                                            spsTraffic[offset].sectorInfo.ueInfo[loopvar].lcInfo[lc_counter].numPkt+=1;
/*SPR 21836 Changes End*/
                                        }
                                    }
                                    spsIndex++;
                                }
                                else
                                {
                                    /* Calculating the values of the other parameters per LC*/
                                    rbInfo_p->noOfTicks = 1000/timeInMs_g;
                                    rbInfo_p->lastDisplayTick = 0;
                                    rbInfo_p->upDownFlag = 0;
                                    rbInfo_p->txTickCount = 0;
                                    rbInfo_p->extraBurstFlag = 1;
                                    if( rbInfo_p->bitRateFlag == 1)
                                    {
/*SPR 21836 Changes Start*/
                                        for(i = 0;i < count; i++)
                                        {
                                            rbInfo_p->tgProfileInfo[tpCounter].varPacketSize[i] = 
                                                roundf((rbInfo_p->tgProfileInfo[tpCounter].packetSize[i])*
                                                        (load_variation_g/100));
                                        }	
/*SPR 21836 Changes End*/
                                    }
                                    fprintf(stderr,"No of tick is %d\n", rbInfo_p->noOfTicks);
                                    if( noOfPktVar_g == 0 )
                                    {
                                        for(i = 0;i < count;i++)
                                        {
                                            /* SPR 20441 Changes Start*/
                                            rbInfo_p->tgProfileInfo[tpCounter].totalNoOfPktVar[i] = 
                                                roundf((rbInfo_p->tgProfileInfo[tpCounter].
                                                            throughput[i]*1000 *1000)/
                                                (rbInfo_p->tgProfileInfo[tpCounter].packetSize[i]*8));
                                            /* SPR 20441 Changes End*/
                                            fprintf(stderr," total no of packets for UE-ID=[%d] LC-ID=[%d] is %f \n",
                                                    gtpDb_p->ueId, 
                                                    rbInfo_p->lcId, 
                                                    rbInfo_p->tgProfileInfo[tpCounter].
                                                    totalNoOfPktVar[i] );
                                            rbInfo_p->tgProfileInfo[tpCounter].fixedPktPerTick[i] = 
                                                rbInfo_p->tgProfileInfo[tpCounter].totalNoOfPktVar[i]/
                                                rbInfo_p->noOfTicks;
                                            fprintf(stderr,"fixed pkt per tick for UE-ID=[%d] LC-ID=[%d] is %f \n",
                                                    gtpDb_p->ueId, 
                                                    rbInfo_p->lcId, 
                                                    rbInfo_p->tgProfileInfo[tpCounter].fixedPktPerTick[i] );

                                            rbInfo_p->tgProfileInfo[tpCounter].remainingPkt[i] = 
                                                (UInt32)rbInfo_p->tgProfileInfo[tpCounter].totalNoOfPktVar[i]%
                                                rbInfo_p->noOfTicks;
                                            fprintf(stderr,"remaining pkt per tick for UE-ID=[%d] LC-ID=[%d] is %d \n",
                                                    gtpDb_p->ueId, 
                                                    rbInfo_p->lcId, 
                                                    rbInfo_p->tgProfileInfo[tpCounter].remainingPkt[i]);
                                        }
                                    }
                                    rbInfo_p->sn_rtp = 0;
                                    rbInfo_p->ts_rtp = 0;
                                    rbInfo_p->ipId_ip = 0;
#ifndef LAYER2_DLTG_THREAD
                                    /* loop for multiple packet size and throughput */
                                    for( packetType =0; 
                                         packetType < rbInfo_p->tgProfileInfo[tpCounter].mixProfileCount; 
                                         packetType++ )
                                    {
                                        rbInfo_p->tgProfileInfo[tpCounter].SendBuffer[packetType] = sendBuffer3;
#ifndef TG_REAL_EPC
                                        if(rbInfo_p->tgProfileInfo[tpCounter].packetSize[packetType] !=70)
                                        { 
                                            prepareSendBuffer(rbInfo_p->tgProfileInfo[tpCounter].SendBuffer[packetType], 
                                                   headerStart,
                                                   rbInfo_p->tgProfileInfo[tpCounter].packetSize[packetType]);

                                        }
                                        else if(rbInfo_p->tgProfileInfo[tpCounter].packetSize[packetType] == 70)
                                        {
#ifdef ROHC_PROFILE_1
                                            prepareSendBuffer(rbInfo_p->tgProfileInfo[tpCounter].SendBuffer[packetType], 
                                                    headerStart,
                                                    rbInfo_p->tgProfileInfo[tpCounter].packetSize[packetType]);
#else
                                            memset(rbInfo_p->tgProfileInfo[tpCounter].SendBuffer[packetType],0,
                                                    MAX_PAYLOAD_SIZE);
#endif   
                                        }
#endif
                                    }
#endif
                                    break;
                                }
                            }
                        }
                    }
                }		
                spsIndex = 0;
                offset = 0;
            }
        }

#ifdef LAYER2_DLTG_THREAD
    /* Compilation 12-JUN-2014 Fix start */
    initGtpuGlueSocket_fn((SInt8 *)"127.0.0.1");// Need source Ip from L2 TODO
    /* Compilation 12-JUN-2014 Fix end */
#else
    initGtpuGlueSocket_fn(argv[2]);
#endif
    fprintf(stderr,"\n !!!!!!!!!!!!!!!!PLEASE IGNORE THE FIRST DISPLAY AT THE CONSOLE!!!!!!!!!!!!!!!!!!!");
#ifdef LAYER2_DLTG_THREAD
    initDownlinkTrafficGen("127.0.0.1","127.0.0.1",2);// source ip, destination ip,tg mode from L2 TODO
#else
    initDownlinkTrafficGen(argv[2],argv[3],atoi(argv[4])); 
    return 0;
#endif
/* Compilation 12-Jun-2014 Fix start */
return 0;
/* Compilation 12-Jun-2014 Fix end */
}

/****************** A NEW SOCKET HAS BEEN CREATED FOR rx ****************************/



#ifndef IPV6_ENABLE
void initGtpuGlueSocket_fn(SInt8 *srcAddr)
{
    struct sockaddr_in sockAddrTidRx;
    memset( &sockAddrTidRx, 0, sizeof(sockAddrTidRx) );
    do
    {
        sockAddrTidRx.sin_family      = AF_INET;
        sockAddrTidRx.sin_addr.s_addr = inet_addr((const char *)srcAddr);
        sockAddrTidRx.sin_port = htons(MU_GTPSIM_PORT);

        if( (sockRxTid_g = socket(AF_INET, SOCK_DGRAM, 0 )) < 0 )
        {
            perror("MU_GTPSIM_GLUE SockError in socket creation");
            break;
        }
        if( bind(sockRxTid_g, (struct sockaddr *)&sockAddrTidRx, sizeof(sockAddrTidRx) ) < 0 )
        {
            perror("MU_GTPSIM_GLUE Socket Bind Error");
            break;
        }
        fprintf(stderr,"MU_GTPSIM_GLUE Socket Created Successfully!");
    }
    while(0);

}
#else
void initGtpuGlueSocket_fn(UInt8 *srcAddr)
{
    struct sockaddr_in6 sockAddr;
    memset( &sockAddr, 0, sizeof(struct sockaddr_in6) );
    do
    {
        sockAddr.sin6_family      = AF_INET6;
        inet_pton(AF_INET6, srcAddr, &sockAddr.sin6_addr);
        sockAddr.sin6_port = htons(MU_GTPSIM_PORT);

        if( (sockRxTid_g = socket(AF_INET6, SOCK_DGRAM, 0 )) < 0 )
        {
            perror("MU_GTPSIM_GLUE SockError in socket creation");
            break;
        }
        if( bind(sockRxTid_g, (struct sockaddr_in6 *)&sockAddr, sizeof(struct sockaddr_in6) ) < 0 )
        {	
            perror("\nMU_GTPSIM_GLUE Socket Bind Error\n");
            break;
        }
        fprintf(stderr,"MU_GTPSIM_GLUE Socket Created Successfully!");
    }
    while(0);

}
#endif

/******************************************************************************
 *
 *   FUNCTION NAME : addRecordToTable 
 *   INPUT         : tunnelId, UeId, LcId
 *   OUTUT         : 
 *   RETURNS       : 
 *   DESCRIPTION   : This function extracts Tunnel Id from the table
 *                   and adds the entry of tunnel id to lc id to record.
 *
 * ***************************************************************************/
#ifndef NO_GTPU_STACK
void addRecordToTable(UInt32 tid_self, UInt32 tunnelId, UInt16 ueId,UInt8 lcId)
#else
void addRecordToTable(UInt32 tunnelId,UInt16 ueId,UInt8 lcId)
#endif

{
    UInt8 i = 0;
    if(ueId >= MAX_UE)
    {
        fprintf(stderr,"Wrong Information of UEId/LcId %d/%d",ueId,lcId);
        return;
    }
/*SPR 21836 Changes Start*/
    if(lastUeInSystemTG_g < ueId)
    {
        lastUeInSystemTG_g = ueId;
    }
#ifdef LAYER2_DLTG_THREAD
	fprintf(stderr,"Max UE = %d : ueId : %d LCID[%d]  TIDSELF [%u] TID [%u] LCCOUNT[%u]\n", lastUeInSystemTG_g, ueId, lcId, tid_self, tunnelId, sectorDb_g.gtpDb_g[ueId].lcCnt);
#endif
    /* SPR 2681 */
    if ( sectorDb_g.gtpDb_g[ueId].lcCnt > 8 )
    {
        fprintf(stderr,"add request received for more than 8 lc%d", 
                sectorDb_g.gtpDb_g[ueId].lcCnt);
        return;

    }
    sectorDb_g.gtpDb_g[ueId].ueId = ueId;
    if ( sectorDb_g.gtpDb_g[ueId].lcCnt )
    {
        /* look for already existing Lc context */
        for ( i = 0 ; i < sectorDb_g.gtpDb_g[ueId].lcCnt; i++ )
        {
            if ( sectorDb_g.gtpDb_g[ueId].rbInfo[i].lcId == lcId  && 
                    sectorDb_g.gtpDb_g[ueId].rbInfo[i].txActiveFlag  == FALSE)
            {
                sectorDb_g.gtpDb_g[ueId].rbInfo[i].txActiveFlag = TRUE;
                sectorDb_g.gtpDb_g[ueId].rbInfo[i].tId_self 	= tid_self;
                sectorDb_g.gtpDb_g[ueId].rbInfo[i].tId 	= tunnelId;
                fprintf(stderr,"i[%d] Self[%d] Peer[%d] ue[%d] lc[%d]\n",i,
                        sectorDb_g.gtpDb_g[ueId].rbInfo[i].tId_self,
                        sectorDb_g.gtpDb_g[ueId].rbInfo[i].tId,
                        ueId,lcId);
                totalLcCount_g++;
                break;
/*SPR 21836 Changes End*/
            }
        }
    }
}


/******************************************************************************
 *
 *   FUNCTION NAME : deleteRecordFromTable 
 *   INPUT         : self tId, UeId, LcId
 *   OUTUT         : 
 *   RETURNS       : 
 *   DESCRIPTION   : This function extracts Tunnel Id from the table
 *                   and delte the entry of tunnel;id to lc id from record.
 *
 * ***************************************************************************/
/* + SPR 8669 Fix */                                
UInt32 deleteRecordFromTable
(
/* - SPR 8669 Fix */                                
 UInt32 	tId,
 UInt16 	ueId,
 UInt8 	lcId
 )
{
    int i = 0;
/*SPR 21836 Changes Start*/
    for ( i=0; i< sectorDb_g.gtpDb_g[ueId].lcCnt; i++)
    {
        fprintf(stderr,"inside del lcId = %d tid = %d\n",
                sectorDb_g.gtpDb_g[ueId].rbInfo[i].lcId, 
                sectorDb_g.gtpDb_g[ueId].rbInfo[i].tId);

        /* + SPR 8669 Fix */                                
        if ( lcId == sectorDb_g.gtpDb_g[ueId].rbInfo[i].lcId  && 
             tId == sectorDb_g.gtpDb_g[ueId].rbInfo[i].tId && 
             TRUE == sectorDb_g.gtpDb_g[ueId].rbInfo[i].txActiveFlag) 
        {
            sectorDb_g.gtpDb_g[ueId].rbInfo[i].txActiveFlag = FALSE;
            fprintf(stderr,"active flag set to zero for tid = %d LcId = %d Deleted \n",
                    tId, 
                    sectorDb_g.gtpDb_g[ueId].rbInfo[i].lcId);
            totalLcCount_g -= 1; 
/*SPR 21836 Changes End*/
            return 1;
        }
    }
    return 0;
      /* - SPR 8669 Fix */                                
}
/******************************************************************************
 *
 *   FUNCTION NAME : deleteInfoInDb
 *   INPUT         : Ue Id
 *   OUTUT         : 
 *   RETURNS       : 1 in case of success, 0 in case of Failure
 *   DESCRIPTION   : This function extracts Tunnel Id from the table
 *                   stored with the help of ueId and lcId.
 *
 * ***************************************************************************/

UInt16 deleteInfoInDb
(
 UInt16 	ueId
 )
{
    UInt16 i_ueIter = 0;
    UInt16 mulB =0;
    /* Finding the Tunnel Id from the Table */
/*SPR 21836 Changes Start*/
    for(; i_ueIter <= lastUeInSystemTG_g; i_ueIter++)
    {
        if (ueId == sectorDb_g.gtpDb_g[i_ueIter].ueId)
        {
            fprintf(stderr,"\n UE ID %d Deleted",i_ueIter);
            sectorDb_g.gtpDb_g[i_ueIter].ueId  = 0;
            for (;mulB<sectorDb_g.gtpDb_g[i_ueIter].lcCnt;mulB++) 
            { 
                /* SPR 12207 Fix Start */
                sectorDb_g.gtpDb_g[i_ueIter].rbInfo[mulB].tId   = 0;
                sectorDb_g.gtpDb_g[i_ueIter].rbInfo[mulB].txActiveFlag = FALSE;
/*SPR 21836 Changes End*/
            }
                /* SPR 12207 Fix end */
            return 1;
        }
    }
    return 0;
}
/********************** UEID & LCID CORRESPONDING TO TID HAS BEEN SAVED IN TABLE ****************************/


#ifndef TG_REAL_EPC
UInt16 decodeFromTunnelIdentifer(UInt32 tId,UInt16 *ueId,UInt8 *lcId)
{
    UInt16 i_ueIter = 0;
    UInt16 j	= 0;
/*SPR 21836 Changes Start*/
        for(i_ueIter=0; i_ueIter < sectorDb_g.ueCount; i_ueIter++)
    {
            for (j=0; j<sectorDb_g.gtpDb_g[i_ueIter].lcCnt; j++)
            {
                /* Match Corresponding TID from table */	
                if(tId == sectorDb_g.gtpDb_g[i_ueIter].rbInfo[j].tId_self)  
                {
                    *ueId = sectorDb_g.gtpDb_g[i_ueIter].ueId;        	/* Save Corresponding UeId */
                    *lcId = sectorDb_g.gtpDb_g[i_ueIter].rbInfo[j].lcId;    /* Save Corresponding LCID */
/*SPR 21836 Changes End*/
                    return 1;
                }
            }

        }
    return 0;
}
#endif
UInt16 decodeFromUeIdentifer(UInt32 *tId,UInt16 ueId,UInt8 lcId)
{
    UInt16 i_ueIter = 0;
    UInt8 i =0;
/*SPR 21836 Changes Start*/
    for(; i_ueIter <= lastUeInSystemTG_g; i_ueIter++)
    {
        if ((ueId == sectorDb_g.gtpDb_g[i_ueIter].ueId))
        {
            for (i=0;i< sectorDb_g.gtpDb_g[i_ueIter].lcCnt;i++)
            {
                if ( (lcId == sectorDb_g.gtpDb_g[i_ueIter].rbInfo[i].lcId)  && 
                        (TRUE == sectorDb_g.gtpDb_g[i_ueIter].rbInfo[i].txActiveFlag) )
                {
                    *tId = sectorDb_g.gtpDb_g[i_ueIter].rbInfo[i].tId;
/*SPR 21836 Changes End*/
                    return 1;
                }
            }
        }
    }
    return 0;
}
#ifdef LAYER2_DLTG_THREAD
/******************************************************************************
 *   FUNCTION NAME : initBufferForDlQue 
 *   INPUT         : None
 *   OUTPUT        : None
 *   RETURNS       : None
 *   DESCRIPTION   : This function init buffer for DL TG
 * *************************************************************************/
void initBufferForDlQue(UInt8 * sendBuffer, UInt32 packetSize)
{
    unsigned short headerStart = 8;

    /*  This buffer is  used as a hardcoded value which contains IP/UDP/RTP
     *  header for UE (containing UE IP address). The same packet is sent for
     *  multiple UE (w/o change in UE IP Address)   */
#ifdef ROHC_PROFILE_6 // profile TCP
#ifndef UE_IPV6_ADDR
                            /*  This buffer is  used as a hardcoded value which contains IP/TCP header
                             *  for UE (containing UE IP address). The same packet is sent for multiple UE
                             *  (w/o change in UE IP Address)*/
                                                                  
                            UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
                                0x45,0x00,0x00,0x00,0x23,0x21,0x40,0x00, /* IP header */
                                0xff,0x06,0x00,0x00,0xac,0x10,0x51,0x15,
                                0xe0,0x00,0x00,0xfb,
                                0x14, 0xe9, 0x14, 0xea, 0x03, 0x46, 0xd0, 0x0a, /* TCP Header */
                                0x10, 0x02, 0x30, 0x04, 0xa0, 0x00, 0x39, 0x08,
                                0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,
                                0x04, 0x02, 0x08, 0x0a, 0xe2, 0x08, 0x2f, 0x90,
                                0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07,
                                0x61,0x6e,0x69,0x6c};  /* Payload */
                     
                             memcpy(&sendBuffer[START_OFFSET_DL_GTP],sendBuffer3,80);



#else

                            UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,0x60,
                                0x60,0x20,0x00,0x00,0x00,0x00,0x06,0xff, /* IPv6 Header */
                                0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
                                0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x14,
                                0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
                                0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x13,
                                0x14, 0xe9, 0x14, 0xea, 0x03, 0x46, 0xd0, 0x0a, /* TCP Header */
                                0x10, 0x02, 0x30, 0x04, 0xa0, 0x00, 0x39, 0x08,
                                0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,
                                0x04, 0x02, 0x08, 0x0a, 0xe2, 0x08, 0x2f, 0x90,
                                0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07,
                                0x61,0x6e,0x69,0x6c};  /* Payload */
                              
                              memcpy(&sendBuffer[START_OFFSET_DL_GTP],sendBuffer3,80);

#endif
#elif ROHC_PROFILE_1 
#ifndef UE_IPV6_ADDR
	  UInt8 sendBuffer3[] = {
                    0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
                    0x45,0x00,0x00,0x00,0x23,0x21,0x40,0x00, /* IP header */
                    0xff,0x11,0x00,0x00,0xac,0x10,0x51,0x15,
                    0xe0,0x00,0x00,0xfb,
                    0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00, /* UDP header */
                    0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x5d,0x7c,0x95,0x7c, /* RTP header */
                    0x61,0x6e,0x69,0x6c}; /* Payload */
                                

    memcpy(&sendBuffer[START_OFFSET_DL_GTP],sendBuffer3,60);

#else
    UInt8 sendBuffer3[] = {
                   0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
                   0x60,0x20,0x00,0x00,0x00,0x00,0x11,0xff, /* IPv6 Header */
                   0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
                   0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x13,
                   0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
                   0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x14,
                   0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00, /* UDP header */
                   0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x5d,0x7c,0x95,0x7c, /* RTP header */
                   0x61,0x6e,0x69,0x6c}; /* Payload */

    memcpy(&sendBuffer[START_OFFSET_DL_GTP],sendBuffer3,80);

#endif

#else /* Profile - 0/2, UDP packet */

#ifndef UE_IPV6_ADDR
	  UInt8 sendBuffer3[] = {
                 0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
                 0x45,0x00,0x00,0x00,0x23,0x21,0x40,0x00, /* IPv4 header */
                 0xff,0x11,0x00,0x00,0xac,0x10,0x51,0x15,
                 0xe0,0x00,0x00,0xfb,
                 0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00, /* UDP Header */
                 0x61,0x6e,0x69,0x6c};

    memcpy(&sendBuffer[START_OFFSET_DL_GTP],sendBuffer3,40);/* COVERITY 26428 */
#else
    UInt8 sendBuffer3[] =  {
                   0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
                   0x60,0x20,0x00,0x00,0x00,0x00,0x11,0xff, /* IPv6 Header */
                   0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
                   0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x13,
                   0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
                   0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x14,
                   0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00, /* UDP header */
                   0x61,0x6e,0x69,0x6c}; /* Payload */

    memcpy(&sendBuffer[START_OFFSET_DL_GTP],sendBuffer3,60);
#endif
#endif
    if(packetSize_g != 70)
    {
        prepareSendBuffer(&sendBuffer[START_OFFSET_DL_GTP], headerStart,packetSize);
    }
    else if(packetSize_g == 70)
    {
#ifdef ROHC_PROFILE_1
        prepareSendBuffer(&sendBuffer[START_OFFSET_DL_GTP], headerStart,packetSize);
#else
        memSet(&sendBuffer[0], 0, MAX_PKT_SIZE);
#endif
    }
}
#endif
UInt16 update_crc10_by_bytes(UInt8* data_blk_ptr, UInt16 data_blk_size)
{
    /* update the data block's CRC-10 remainder one byte at a time */
    UInt16 index = 0;
    UInt16 crc10_accum = 0;
    UInt16 i;

       /* fprintf(stderr,"\n");
    for(index =0;index < 20 ;index ++)
    {
        fprintf(stderr,"[%x] ",data_blk_ptr[index]);
    }
        fprintf(stderr,"\n");*/
    if (data_blk_size >62)
    {
        data_blk_size = 62;
    }
    for ( i = 0;  i < data_blk_size;  i++ )
    {
        crc10_accum = ((crc10_accum << 8) & 0x3ff) ^ crc10_table[( crc10_accum >> 2) & 0xff] ^ *(data_blk_ptr++) ;
    }
    return crc10_accum;
}

UInt8 crc6_compute (unsigned char * BUFF, unsigned int buffLength)
{ 
    unsigned short h; 
    unsigned int byteIndex;

    h = 0; byteIndex = 0;

    if (buffLength == 0) { return 0; }

    do 
    { 
        h = (h << 8) | BUFF [byteIndex];

/* LAYER2_DLTG_THREAD Compilation fix Start */
        h = crc6_table_1 [h];  byteIndex ++;
/* LAYER2_DLTG_THREAD Compilation fix End */

    } while (byteIndex <buffLength);   

    return h; 
}


#ifndef LAYER2_DLTG_THREAD
#define MAX_SYNC_CFG_LEN	256
void populateMBMSConfig(SInt8 *srcAddr, SInt8 *dstAddr)
{
    FILE        *traffic_profile_fp,*fp;
    char        buf[MAX_SYNC_CFG_LEN],*current;
    char        str1[MAX_SYNC_CFG_LEN],str2[MAX_SYNC_CFG_LEN];
    UInt32      temp,loopvar,lc_counter,secCnt;
    UInt8       areaIndex=0;
    UInt8       lc_count = 0;
	SInt32 enabled=1;

fprintf(stderr,"\n\nsrc: %s dst %s\n\n",srcAddr,dstAddr);
    fp = fopen("../cfg/syncTrafficGen.txt","rb");

    if(fp == NULL)
    {
        fprintf(stderr,"Unable to open the file syncTrafficGen.txt...\n");
        exit(0);
    }

    // Open socket  for multicast
#ifndef IPV6_ENABLE
    sd = socket(AF_INET, SOCK_DGRAM, 0);
    if(sd < 0)
    {
        perror("Opening datagram socket error");
        exit(1);
    }
    else
    {
        fprintf(stderr,"Opening the datagram socket...OK.\n");
    }

    /* Initialize the group sockaddr structure with a */
    /* group address of 225.1.1.1 and port 5555. */
    memset((char *) &groupSock, 0, sizeof(groupSock));
    groupSock.sin_family = AF_INET;
    /* tg-change --- pass function argument */
    groupSock.sin_addr.s_addr = inet_addr((const char *)dstAddr);
    groupSock.sin_port = htons(2152);

    /* Set local interface for outbound multicast datagrams. */
    /* The IP address specified must be associated with a local, */
    /* multicast capable interface. */
    memset((char *) &localInterface, 0, sizeof(localInterface));
    localInterface.sin_family = AF_INET;
    /* tg-change --- pass function argument */
    localInterface.sin_addr.s_addr = inet_addr((const char *)srcAddr);
    localInterface.sin_port = htons(55555); 

    if(bind(sd,(struct sockaddr *)&localInterface, sizeof(struct sockaddr_in))<0)
    {    
        abort();
    } 
#else
    sd = socket(AF_INET6, SOCK_DGRAM, 0);
    if(sd < 0)
    {
        perror("Opening datagram socket error");
        exit(1);
    }
    else
    {
        fprintf(stderr,"Opening the datagram socket...OK.\n");
    }

    memset((char *) &groupSock_IPV6, 0, sizeof(groupSock_IPV6));
    memset((char *) &localInterface_IPV6, 0, sizeof(localInterface_IPV6));

    groupSock_IPV6.sin6_family = AF_INET6;
    localInterface_IPV6.sin6_family = AF_INET6;

    inet_pton(AF_INET6,dstAddr,(void*)&groupSock_IPV6.sin6_addr.s6_addr);

    groupSock_IPV6.sin6_port = htons(2152);

    inet_pton(AF_INET6,srcAddr,(void*)&localInterface_IPV6.sin6_addr.s6_addr);

    localInterface_IPV6.sin6_port = htons(55555); 
    localInterface_IPV6.sin6_flowinfo=0;
    localInterface_IPV6.sin6_scope_id=0;

    /*if(setsockopt_wrapper(sd, SOL_SOCKET, SO_REUSEADDR, &enabled, sizeof(enabled))<0)
    {
        ltePanic("setsockopt_wrapper SO_REUSEADDR failed");
    }*/
    if(bind(sd,(struct sockaddr *)&localInterface_IPV6, sizeof(struct sockaddr_in6)) < 0)
    { 
        perror("V1: Bind failed");
        abort();
    } 

#endif
#if 0
    if(setsockopt(sd, IPPROTO_IP, IP_MULTICAST_IF, (char *)&localInterface, sizeof(localInterface)) < 0)
    {
        perror("Setting local interface error");
        exit(1);
    }
    else
    {
        printf("Setting the local interface...OK\n");
    }
#endif
    /* Sweta Changes Start */
    /*openUdpRxSocket(TGIP, &sockRxTGFd, &sockAddr_sync, TGPORT);
    fprintf(stderr,"\n Socket for Platform update time created. [%d]\n",sockRxTGFd);*/
    /* Sweta Changes End */

    while(fgets(buf,MAX_SYNC_CFG_LEN,fp))
    {
        if(sscanf(buf,"AREA-COUNT=%d",&temp)>0)
        {
            syncAreaDB_g.areaCount = temp;
            fprintf(stderr, "AREA-COUNT=%d\n",temp);
        }
        else if(sscanf(buf,"AREA-ID=%d",&temp)>0)
        {
            if(temp > MAX_SUPPORTED_AREA)
            {
                exit(0);
            }
        //    syncAreaDB_g.areainfo[temp].areaId = temp;
            syncAreaDB_g.areainfo[0].areaId = temp;
            areaIndex = temp;
            fprintf(stderr, "AREA-ID=%d\n",temp);
        }
        else if(sscanf(buf,"LC-COUNT=%d",&temp)>0)
        {
            fprintf(stderr, "LC-COUNT=%d\n",temp);
            /* The below assignment is from ulTrafficGen.txt based on assumption 
             * that the same lc-count will be received 
             * from eGTPU after successful signaling of same number of LCs */      
            syncAreaDB_g.areainfo[areaIndex].lcCount=temp;
            for(lc_count=0;lc_count<syncAreaDB_g.areainfo[areaIndex].lcCount ;lc_count++)
            {
                memset(buf,0,sizeof(buf));
                fgets(buf,MAX_SYNC_CFG_LEN,fp);
                if(sscanf(buf,"LC-ID=%d",&temp)>0)
                {
                    fprintf(stderr, "\tLC-ID=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].lcID = temp;

                    current=strtok(buf," ");
                    current=strtok(NULL," ");
                    strcpy(str1,current);

                    sscanf(str1,"TP-ID=%d",&temp);
                    fprintf(stderr, "\tTP-ID=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].trafficProfile = temp; 

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"LC-TIMER=%d",&temp);
                    fprintf(stderr, "\tLC-TIMER=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].lcTimer = temp;
                    if(syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].lcTimer != 0)
                    {
                        syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].isTimerPresent = 1;
                    }
                    else
                    {
                        syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].lcTimer = 0;
                    }

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"SYNC-SEQ=%d",&temp);
                    fprintf(stderr, "\tSYNC-SEQ=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].syncSeq = temp;

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"MSP=%d",&temp);
                    fprintf(stderr, "\tMSP=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].msp = temp  ;
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].timeStamp =0; 
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].prevTimeStampToUse =0; 
                         //syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].msp;
                    fprintf(stderr, "\tTS=%d\n",syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].timeStamp);

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"SYN-PERIOD=%d",&temp);
                    fprintf(stderr, "\tSYN-PERIOD=%d\n",temp);
                    /*syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].syncPeriod = temp*100; // multiply by 100 to convert seconds into SFNs*/
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].syncPeriod = temp; /*Keeping SYNC period same as defined in CFG*/
                    syncPeriod_g = temp; /* Sync period */

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"END-PDU-TYPE=%d",&temp);
                    fprintf(stderr, "\tEND-PDU-TYPE=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].endPduType = temp;

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"TYPE1-MISSING=%d",&temp);
                    fprintf(stderr, "\tTYPE1-MISSING=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].type1Missing = temp;

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"TYPE0-MISSING=%d",&temp);
                    fprintf(stderr, "\tTYPE0-MISSING=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].type0Missing = temp;

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"TYPE2-FILLED=%d",&temp);
                    fprintf(stderr, "\tTYPE2-FILLED=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].type2Filled = temp;

                    current=strtok(NULL," ");
                    strcpy(str1,current);
                    sscanf(str1,"TE-ID=%d",&temp);
                    fprintf(stderr, "\tTE-ID=%d\n",temp);
                    syncAreaDB_g.areainfo[areaIndex].lcInfo[lc_count].teId = temp;
                }
            }
        }
    }


    traffic_profile_fp = fopen("../cfg/TGConfig.txt","rb");
    if (traffic_profile_fp == PNULL)
    {
        fprintf(stderr,"unable to open the configuration file TGConfig.txt............EXITING NOW ");
        exit(0);
    }
    memset(buf,sizeof(buf),0);
    fgets(buf,sizeof(buf),traffic_profile_fp); // reads the file pointed by FP and stores it in buf 

    while(fgets(buf,sizeof(buf),traffic_profile_fp))
    {
        if(sscanf(buf,"TP-ID=%d",&temp)>0 ) // reads the formatted string and stores in temp 
        {
            syncDLTrafficProfileDb[temp].isValid = 1;
            syncDLTrafficProfileDb[temp].TPID = temp;

            current= strtok_r(buf," ",(char **)&buf);
            current= strtok_r(NULL," ",(char **)&buf); //Moving current to next substring i.e. packetSize
            syncDLTrafficProfileDb[temp].packetSize = atoi(current);

            current= strtok_r(NULL," ",(char **)&buf); //Moving current to next substring i.e. throughput
            syncDLTrafficProfileDb[temp].throughput = atoi(current);

            current= strtok_r(NULL," ",(char **)&buf); //Moving current to next substring i.e. time
            syncDLTrafficProfileDb[temp].time = atoi(current);;
        }
    }
    // start populating the syncDB with respective TP info
    int i=0;//puneet
    int j=0;
    for(i=0; i<syncAreaDB_g.areaCount; i++)
    {
        areaInfo_t *area_p = &(syncAreaDB_g.areainfo[i]);

        for (j=0; j<area_p->lcCount; j++)
        {
            int profileId = area_p->lcInfo[j].trafficProfile;
            area_p->lcInfo[j].pktSize = syncDLTrafficProfileDb[profileId].packetSize;
            area_p->lcInfo[j].dlThpt = syncDLTrafficProfileDb[profileId].throughput;
            area_p->lcInfo[j].timerVal = syncDLTrafficProfileDb[profileId].time;
            area_p->lcInfo[j].profileTimerCount = area_p->lcInfo[j].timerVal;
            area_p->lcInfo[j].packetToBeSentInTTI = roundf((area_p->lcInfo[j].dlThpt*1024*1024)/(area_p->lcInfo[j].pktSize*8));
            area_p->lcInfo[j].packetsToBeSentInSynSeq = (area_p->lcInfo[j].packetToBeSentInTTI * (area_p->lcInfo[j].syncSeq * 10))/(1000/timeInMs_g);
            area_p->lcInfo[j].remainingPktsToBeSentInTti = area_p->lcInfo[j].packetToBeSentInTTI;
            area_p->lcInfo[j].packetToBeSentInTTI = (area_p->lcInfo[j].packetToBeSentInTTI)/(1000/timeInMs_g);
            area_p->lcInfo[j].firstMspReached = TRUE;
            //area_p->lcInfo[j].currentSyncSeqToUse = area_p->lcInfo[j].syncSeq/area_p->lcInfo[j].numOfSyncSeq;
        }
    }

}

void sendMBMSTraffic()
{
    int         i=0, j=0;
    UInt16      headerStart = 8;
    UInt32 bytesSend = 0;
    UInt32 dataLength = 0;
    UInt8 isType2Enabled = FALSE;
    UInt8 isChksumErrEnabled = FALSE;
    UInt8 isType0MissingEnabled = FALSE;
    UInt8 isType1MissingEnabled = FALSE;
    UInt8 type1MissingCount = 0;
    /*static UInt8 firstTime = TRUE;*/
//puneet
           /* fprintf(stderr,"\nsyncAreaDB_g.areaCount %d lcCount [%u] SFN [%u] TICK[%u] \n",syncAreaDB_g.areaCount, syncAreaDB_g.areainfo[i].lcCount,
                    tgSfnCellIndexVal[0].sfn, tgSfnCellIndexVal[0].currentTti);*/
    for(i=0; i<syncAreaDB_g.areaCount; i++)
    {
        areaInfo_t *area_p = &(syncAreaDB_g.areainfo[i]);

        for (j=0; j<area_p->lcCount; j++)
        {
           // fprintf(stderr,"\n area_p->lcCount %d\n\n",area_p->lcCount);
           // int pktsToBeSent = area_p->lcInfo[j].remainingPktsToBeSentInTti = area_p->lcInfo[j].packetToBeSentInTTI;
            int pktsToBeSent = 0;
            UInt8 isEndPduIncluded = 0;
            UInt8 syncBuffer[MAX_PKT_SIZE];
            pktsToBeSent = area_p->lcInfo[j].packetsToBeSentInSynSeq; //Including one extra packet for type0/3
            if ((area_p->lcInfo[j].type1Missing >= 1) && (area_p->lcInfo[j].type1Missing <= 2) && 
                (pktsToBeSent > area_p->lcInfo[j].type1Missing))
            {
                isType1MissingEnabled = TRUE;
                type1MissingCount = area_p->lcInfo[j].type1Missing;
            }
            if (area_p->lcInfo[j].type0Missing == 1)
            {
                isType0MissingEnabled = TRUE;
            }
            if (area_p->lcInfo[j].type2Filled == 1)
            {
                isType2Enabled = TRUE;
                isChksumErrEnabled = TRUE;
            }
            
            /*for (pktsToBeSent = area_p->lcInfo[j].remainingPktsToBeSentInTti; pktsToBeSent >=0; pktsToBeSent--)*/
            for (; pktsToBeSent >0; pktsToBeSent--)
            {
                //fprintf(stderr,"\n area_p->lcInfo[j].remainingPktsToBeSentInTti %d pktsToBeSent %d\n\n",
            //            area_p->lcInfo[j].remainingPktsToBeSentInTti, pktsToBeSent);

                memset(syncBuffer, 0, MAX_PKT_SIZE);

                // irrespective of PDU Type following things will be done for each packet:
                // 1. calculate TS
                // 2. claculate packet number
                // 3. calculate elapsed Octet counter. 
                // 4. calculate total number of packets
                // 5. Calculate total number of octets.
               // Calculate TS

                appendMbmsGtpHeader(&syncBuffer[0],MAX_PKT_SIZE_MBMS,area_p->lcInfo[j].teId);

            /*    fprintf(stderr,"\narea_p->lcInfo[j].msp: %d area_p->lcInfo[j].syncSeq:%d\n ",
                        area_p->lcInfo[j].msp,area_p->lcInfo[j].syncSeq);*/
/*SPR 18697 fix start*/ 
                if(((getSFN() % area_p->lcInfo[j].msp) == 0) && (area_p->lcInfo[j].firstMspReached == TRUE))
/*SPR 18697 fix end*/ 
                {
                        area_p->lcInfo[j].firstMspReached = FALSE;
                        /*Setting controlPacketSend to TRUE to skip first Type-0 for blank data*/
                        area_p->lcInfo[j].controlPacketSend = TRUE;
                        /*if (area_p->lcInfo[j].controlPacketSend == TRUE)
                            continue;*/

                        // store the previous TS because a type0/3 PDU needs to be sent before new syn seq start.
                        isEndPduIncluded = 1;
                 // Update the totalNoOfPackets and reset packetNumber to 0 to mark end or begining of new syn seq
                        /*area_p->lcInfo[j].totalNoOfPackets += area_p->lcInfo[j].packetNumber;
                        area_p->lcInfo[j].packetNumber = 0;
                        area_p->lcInfo[j].elapsedOctetCounter =0;*/
/*SPR 18697 fix start*/ 
                        area_p->lcInfo[j].timeStamp = area_p->lcInfo[j].timeStamp + getPlatformTti();
/*SPR 18697 fix end*/ 
                        area_p->lcInfo[j].prevTimeStampToUse = area_p->lcInfo[j].timeStamp;
                        //fprintf(stderr,"\n1area_p->lcInfo[j].timeStamp: %d SFN [%d] TICK[%u] \n",area_p->lcInfo[j].timeStamp,tgSfnCellIndexVal_g.sfn, tgSfnCellIndexVal_g.currentTti);
                        continue;
                }
                else
                {
/*SPR 18697 fix start*/ 
                    if (getSFN() % area_p->lcInfo[j].syncSeq == 0)
/*SPR 18697 fix end*/ 
                    {
                        if (area_p->lcInfo[j].controlPacketSend == TRUE)
                        {
                            area_p->lcInfo[j].dataPacketSend = FALSE;
                            continue;
                        }

                        // store the previous TS because a type0/3 PDU needs to be sent before new syn seq start.
                        area_p->lcInfo[j].prevTimeStampToUse = area_p->lcInfo[j].timeStamp;
                        isEndPduIncluded = 1;
                 // Update the totalNoOfPackets and reset packetNumber to 0 to mark end or begining of new syn seq
                        area_p->lcInfo[j].totalNoOfPackets += area_p->lcInfo[j].packetNumber;
                        /*area_p->lcInfo[j].packetNumber = 0;
                        area_p->lcInfo[j].elapsedOctetCounter =0;
                        area_p->lcInfo[j].timeStamp = area_p->lcInfo[j].timeStamp + area_p->lcInfo[j].syncSeq;*/ 
                        //area_p->lcInfo[j].timeStamp = 0x19;
                        /*fprintf(stderr,"\n2area_p->lcInfo[j].timeStamp: %d %d %d SFN:%d TICK[%u]\n",area_p->lcInfo[j].timeStamp
                                ,(area_p->lcInfo[j].timeStamp & 0x00FF),
                                (area_p->lcInfo[j].timeStamp >> 8 & 0x00FF),
                                tgSfnCellIndexVal_g.sfn,tgSfnCellIndexVal_g.currentTti);*/
                    }
                    else if ((pktsToBeSent -1 == 0) && (area_p->lcInfo[j].dataPacketSend == FALSE))
                    {
                        isEndPduIncluded = 1;
                        area_p->lcInfo[j].prevTimeStampToUse = area_p->lcInfo[j].timeStamp;
                        area_p->lcInfo[j].totalNoOfPackets += area_p->lcInfo[j].packetNumber;
/*                        fprintf(stderr,"\n3area_p->lcInfo[j].timeStamp: %d %d %d SFN:%d TICK[%u]\n",area_p->lcInfo[j].timeStamp
                                ,(area_p->lcInfo[j].timeStamp & 0x00FF),
                                (area_p->lcInfo[j].timeStamp >> 8 & 0x00FF),
                                tgSfnCellIndexVal_g.sfn,tgSfnCellIndexVal_g.currentTti);*/
                    }
                }

                /*Skip the packets till first MSP boundry does not reached*/
                if (area_p->lcInfo[j].firstMspReached == TRUE || area_p->lcInfo[j].dataPacketSend == TRUE)
                    continue;

                if (area_p->lcInfo[j].dataPacketSend == FALSE)
                {
                    if (pktsToBeSent - 1 == 0)
                        area_p->lcInfo[j].dataPacketSend = TRUE;
                }

                if (isEndPduIncluded == 0)
                {
                    /*area_p->lcInfo[j].packetNumber++;*/ 
                    // update the totalNoOfPackets per sync period
                    // EOC will not include the SYNC header + Spare Ext bytes (1024 - (11+4) = 1009)
                    area_p->lcInfo[j].elapsedOctetCounter += (area_p->lcInfo[j].pktSize - SYNC_HEADER_LENGTH - SYNC_HDR_SPARE_EXT_LEN);
                    area_p->lcInfo[j].totalNoOfPackets++;
                }

                // Fill Timestamp
                syncBuffer[START_OFFSET_DL_GTP1+ 2] = area_p->lcInfo[j].timeStamp & 0x00FF;
                syncBuffer[START_OFFSET_DL_GTP1+ 1] = area_p->lcInfo[j].timeStamp >> 8 & 0x00FF;

                // increment the packet number and fill SyncHeader

                if (isEndPduIncluded == 0)
                {
                    syncBuffer[START_OFFSET_DL_GTP1+ 4] = area_p->lcInfo[j].packetNumber & 0xFF;
                    syncBuffer[START_OFFSET_DL_GTP1+ 3] = area_p->lcInfo[j].packetNumber >> 8 & 0x00FF;
                }
                else
                {
                    /*resetting packet number to last pdu*/
                    area_p->lcInfo[j].packetNumber = area_p->lcInfo[j].packetNumber - 1;
                    syncBuffer[START_OFFSET_DL_GTP1+ 4] = (area_p->lcInfo[j].packetNumber) & 0xFF;
                    syncBuffer[START_OFFSET_DL_GTP1+ 3] = (area_p->lcInfo[j].packetNumber) >> 8 & 0x00FF;
                }

                // Increment the elapsed octet counter by packet size
                //  syncBuffer[5-8] for Elapsed Octet Counter

                // byte 5-8
                syncBuffer[START_OFFSET_DL_GTP1+ 8] = area_p->lcInfo[j].elapsedOctetCounter       & 0x000000FF;
                syncBuffer[START_OFFSET_DL_GTP1+ 7] = area_p->lcInfo[j].elapsedOctetCounter >> 8  & 0x0000FF;
                syncBuffer[START_OFFSET_DL_GTP1+ 6] = area_p->lcInfo[j].elapsedOctetCounter >> 16 & 0x00FF;
                syncBuffer[START_OFFSET_DL_GTP1+ 5] = area_p->lcInfo[j].elapsedOctetCounter >> 24 & 0xFF;

                /*fprintf(stderr,"\nNitin Packet Number[%u] timeStamp [%u] elapsedOctetCounter[%u]\n",
                        area_p->lcInfo[j].packetNumber, area_p->lcInfo[j].timeStamp, area_p->lcInfo[j].elapsedOctetCounter);*/
                // update the totalNoOfOctets per sync period
                area_p->lcInfo[j].totalNoOfOctets += area_p->lcInfo[j].elapsedOctetCounter;

                if (isEndPduIncluded == 0)
                {
                    area_p->lcInfo[j].controlPacketSend = FALSE;
                    /*Packet Number should be started from 0*/
                    area_p->lcInfo[j].packetNumber++;
                 //   syncBuffer[12] = 0x0b;
                   // syncBuffer[15] = 0x00;
                    // PDU Type = 1
                    // Set Type2 in PDU Type for the first PDU
					if ((FALSE == isChksumErrEnabled) && (TRUE == isType2Enabled))
					{
						syncBuffer[START_OFFSET_DL_GTP1+0] = 0x20;
                        isType2Enabled = FALSE;
					}
					else
					{
						syncBuffer[START_OFFSET_DL_GTP1+0] = 0x10;
					}

                    // syncBuffer[9-10] for CRC
                    //type 1 PDU will be sent. Header in 9 bytes excluding CRC header and CRC payload feilds. 
                    // calculate header CRC
                    UInt8 headerCRC = crc6_compute(&syncBuffer[START_OFFSET_DL_GTP1], 
                                                        TYPE1_HEADER_SIZE_EXCLUDING_CRC);
                    // fill data from position 11
                    initDLBufferForSync(syncBuffer, 11, area_p->lcInfo[j].pktSize);
                    // calculate payload CRC
                    /*UInt16 payloadCRC = update_crc10_by_bytes(&syncBuffer[START_OFFSET_DL_GTP1+11], 
                                (area_p->lcInfo[j].pktSize-11));
                    fprintf(stderr,"payload crc CaLCULATED =%d\n",payloadCRC);*/
                    // fill the header CRC in bit 3-8
                    if (isChksumErrEnabled == TRUE)
                    {
                        syncBuffer[START_OFFSET_DL_GTP1+9] = (!headerCRC << 2) & 0xFC;
                        isChksumErrEnabled = FALSE;
                    }
                    else
                    {
                        syncBuffer[START_OFFSET_DL_GTP1+9] = (headerCRC << 2) & 0xFC;
                    }
               //     fprintf(stderr,"\n\n PDU :1 headerCRC %d %x\n\n",headerCRC,syncBuffer[START_OFFSET_DL_GTP1+9]);
                    // fill the payload CRC in bit 1-2
                    /*syncBuffer[START_OFFSET_DL_GTP1+9] |= payloadCRC & 0x03;
                    syncBuffer[START_OFFSET_DL_GTP1+10] = (payloadCRC >> 2) & 0xFF;
*/

                    //prepareSendBuffer(&syncBuffer[START_OFFSET_DL_GTP1], headerStart, area_p->lcInfo[j].pktSize);
                    prepareSendBuffer(&syncBuffer[START_OFFSET_DL_GTP1], (headerStart+11), 
                                                                area_p->lcInfo[j].pktSize);
                    UInt16 payloadCRC = update_crc10_by_bytes(&syncBuffer[START_OFFSET_DL_GTP1+11], 
                                (area_p->lcInfo[j].pktSize-11));
                //    fprintf(stderr,"payload crc CaLCULATED =%d\n",payloadCRC);
                    syncBuffer[START_OFFSET_DL_GTP1+9] |= (payloadCRC>>8) & 0x03;
                    syncBuffer[START_OFFSET_DL_GTP1+10] = ((UInt8)(payloadCRC)) & 0xFF;
                    //dataLength = area_p->lcInfo[j].pktSize + GTP_HDR + START_OFFSET_DL_GTP1;
                    dataLength = area_p->lcInfo[j].pktSize + START_OFFSET_DL_GTP1;

#ifdef LAYER2_DLTG_THREAD
                    dlTgDataPkt* dlTgDataPkt_p = (dlTgDataPkt*)getMemFromPool(sizeof(dlTgDataPkt), NULL);
                    if (NULL != dlTgDataPkt_p)
                    {
                        dlTgDataPkt_p->dataLength = dataLength;
                        dlTgDataPkt_p->dlTgDataPktBuf_p = syncBuffer;
                        ENQUEUE_DLTG_DATA_PKT_Q(dlTgDataPkt_p);
                        bytesSend =  area_p->lcInfo[j].pktSize + GTP_HDR + START_OFFSET_DL_GTP1;

                    }
                    else
                    {
                        ltePanic( "getMemFromPool failed at func [%s] Line[%d]\n", __func__, __LINE__ );
                    }
#else
                    
                 /*   fprintf(stderr,"\n to be sent");
                    int index = 19;
                    for(; index < (19+62) ;index ++)
                    {
                        fprintf(stderr,"[%x] ",syncBuffer[index]);
                    }
                    fprintf(stderr,"\n");
*/
                /*if(!(((area_p->lcInfo[j].timeStamp + area_p->lcInfo[j].syncSeq)% area_p->lcInfo[j].msp ==0)||
                        (area_p->lcInfo[j].timeStamp ==area_p->lcInfo[j].syncPeriod )))*/
                        //varun
                    //Drop 2nd last Type1 Packet
					if (((pktsToBeSent - 1) == type1MissingCount) && (TRUE == isType1MissingEnabled))
					{
                        type1MissingCount--;
                        if (type1MissingCount == 0)
                        {
						    isType1MissingEnabled = FALSE;
                        }
						fprintf(stderr,"\nType 1 PDU Dropped for LCID[%u]. Packet No [%u]\n",
                                area_p->lcInfo[j].lcID,area_p->lcInfo[j].packetNumber);
					}
					else
                    {
#ifndef IPV6_ENABLE
                        bytesSend = sendto(sd, syncBuffer, dataLength, 0, (struct sockaddr*)&groupSock, sizeof(groupSock)); 
#else
                        bytesSend = sendto(sd, syncBuffer, dataLength, 0, (struct sockaddr*)&groupSock_IPV6, sizeof(groupSock_IPV6)); 
#endif

                        if(bytesSend < 0)
                        {
                            perror("Sending datagram message error");
                        }
                        else
                        {
                            //fprintf(stderr,"Sending datagram message...OK\n");
                        }
                    }
              //      abort();
#endif
                    //area_p->lcInfo[j].txData += bytesSend - GTP_HDR - START_OFFSET_DL_GTP1;
                    area_p->lcInfo[j].txData += bytesSend -  START_OFFSET_DL_GTP1;

                    //memset(&syncBuffer[0], 0, MAX_PKT_SIZE);
                }
                else
                {
                    area_p->lcInfo[j].controlPacketSend = TRUE;
                    area_p->lcInfo[j].packetNumber = 0;
                    area_p->lcInfo[j].elapsedOctetCounter =0;
                    
                    if (FALSE == area_p->lcInfo[j].firstMspReached){
                        area_p->lcInfo[j].timeStamp = (area_p->lcInfo[j].timeStamp + area_p->lcInfo[j].syncSeq);
                        area_p->lcInfo[j].prevTimeStampToUse = area_p->lcInfo[j].timeStamp;
                    }

                    if (area_p->lcInfo[j].endPduType == 0)
                    {
                    //syncBuffer[12] = 0x12;
                    //syncBuffer[15] = 0x00;
                        // send TYPE 0
                        // PDU Type = 0
                /*        fprintf(stderr,"\n puneet : comming to fill sync pdu syncBuffer[%d] [%d] [%d] [%d] [%d]\n",syncBuffer[3] ,syncBuffer[4],syncBuffer[8] ,syncBuffer[9], syncBuffer[10]);*/
                        syncBuffer[START_OFFSET_DL_GTP1+0] = 0x00; 

                        UInt8 headerCRC = crc6_compute(&syncBuffer[START_OFFSET_DL_GTP1], TYPE0_HEADER_SIZE_EXCLUDING_CRC);
                       /* fprintf(stderr,"\n\n PDU:0 headerCRC : %d totalNoOfPackets %d totalNoOfOctets %d\n\n",
                                headerCRC,area_p->lcInfo[j].totalNoOfPackets,
                                area_p->lcInfo[j].totalNoOfOctets);*/
                        // Fill no of packets 9-11
                        syncBuffer[START_OFFSET_DL_GTP1+9] = (area_p->lcInfo[j].totalNoOfPackets ) & 0x0000FF;
                        syncBuffer[START_OFFSET_DL_GTP1+10] = (area_p->lcInfo[j].totalNoOfPackets >> 8) & 0x00FF;
                        syncBuffer[START_OFFSET_DL_GTP1+11] = (area_p->lcInfo[j].totalNoOfPackets >> 16) & 0xFF;
                        // Fill no of OCTETS 12-16

                        syncBuffer[START_OFFSET_DL_GTP1+12] = (area_p->lcInfo[j].totalNoOfOctets) & 0x00000000000000FF;
                        syncBuffer[START_OFFSET_DL_GTP1+13] = (area_p->lcInfo[j].totalNoOfOctets >> 8)   &   0x000000000000FF;
                        syncBuffer[START_OFFSET_DL_GTP1+14] = (area_p->lcInfo[j].totalNoOfOctets >> 16)  &   0x0000000000FF;
                        syncBuffer[START_OFFSET_DL_GTP1+15] = (area_p->lcInfo[j].totalNoOfOctets >> 24)  &   0x00000000FF;
                        syncBuffer[START_OFFSET_DL_GTP1+16] = (area_p->lcInfo[j].totalNoOfOctets >> 32)  &   0x000000FF;
                        // fill CRC byte 17
                        syncBuffer[START_OFFSET_DL_GTP1+17] = (headerCRC << 2) & 0xFC;
                        // fill data from position 18
                        //initDLBufferForSync(syncBuffer, 18, area_p->lcInfo[j].pktSize);

                    //    prepareSendBuffer(&syncBuffer[START_OFFSET_DL_GTP1], headerStart, START_OFFSET_DL_GTP1 + TYPE0_HEADER_SIZE_EXCLUDING_CRC+1);
                        //dataLength = TYPE0_HEADER_SIZE_EXCLUDING_CRC +1 + GTP_HDR + START_OFFSET_DL_GTP1;
                        dataLength = 17 +1 + START_OFFSET_DL_GTP1;

                    //    fprintf(stderr,"\n\n PDU:0 in header: %d dataLength %d\n\n",syncBuffer[START_OFFSET_DL_GTP1+17],dataLength);
                        UInt8 current=2;
                        UInt32 length1=dataLength-START_OFFSET_DL_GTP1;
                        syncBuffer[current++] = (length1 & 0xFF00)>>8;
                        syncBuffer[current++] = (length1 & 0x00FF)>>0;
#ifdef LAYER2_DLTG_THREAD
                        dlTgDataPkt* dlTgDataPkt_p = (dlTgDataPkt*)getMemFromPool(sizeof(dlTgDataPkt), NULL);
                        if (NULL != dlTgDataPkt_p)
                        {
                            dlTgDataPkt_p->dataLength = dataLength;
                            dlTgDataPkt_p->dlTgDataPktBuf_p = syncBuffer;
                            ENQUEUE_DLTG_DATA_PKT_Q(dlTgDataPkt_p);
                            bytesSend = TYPE0_HEADER_SIZE_EXCLUDING_CRC + 1 + GTP_HDR + START_OFFSET_DL_GTP1;
                        }
                        else
                        {
                            ltePanic( "getMemFromPool failed at func [%s] Line[%d]\n", __func__, __LINE__ );
                        }
#else
//                    fprintf(stderr,"\n to be sent pdu: 0");
  //                  int index = 8;
    //                for(; index < (8+18) ;index ++)
      //            {
       //               fprintf(stderr,"[%x] ",syncBuffer[index]);
        //            }
          //          fprintf(stderr,"\n");
                //if(!(((area_p->lcInfo[j].prevTimeStampToUse + area_p->lcInfo[j].syncSeq)% area_p->lcInfo[j].msp ==0)))
                        //||(area_p->lcInfo[j].prevTimeStampToUse ==area_p->lcInfo[j].syncPeriod )))
                        //varun
						//Drop Type0 Packet
						if (TRUE == isType0MissingEnabled)
						{
							isType0MissingEnabled = FALSE;
							fprintf(stderr,"\nType 0 PDU Dropped for LCID[%u]. Timestamp [%u]\n",
									area_p->lcInfo[j].lcID,area_p->lcInfo[j].timeStamp);
						}
						else
						{
#ifndef IPV6_ENABLE
                        bytesSend = sendto(sd, syncBuffer, dataLength, 0, (struct sockaddr*)&groupSock, sizeof(groupSock)); 
#else
                        bytesSend = sendto(sd, syncBuffer, dataLength, 0, (struct sockaddr*)&groupSock_IPV6, sizeof(groupSock_IPV6)); 
#endif
#endif
							if(bytesSend < 0)
							{
								perror("Sending datagram message error");
							}
							else
							{
								//       fprintf(stderr,"\nSending datagram message...OK\n");
							}
							area_p->lcInfo[j].txData += bytesSend - GTP_HDR - START_OFFSET_DL_GTP1;
						}

                       // memset(&syncBuffer[0], 0, MAX_PKT_SIZE);
                        // GC -- ADDED
                        isEndPduIncluded = 0;
                    }
                    else if(area_p->lcInfo[j].endPduType = 3)
                    {
                        // send TYPE 3 PDU
                        // PDU Type = 3
                        syncBuffer[START_OFFSET_DL_GTP1+0] = 0x30; 
                        UInt8 headerCRC = crc6_compute(&syncBuffer[START_OFFSET_DL_GTP1], TYPE0_HEADER_SIZE_EXCLUDING_CRC);
                        //TODO : Fill Type 3 structure.. 
                        // Currently unsupported. 
                    }
                    else
                    {
                        fprintf(stderr, "Invalid END PDU TYPE %d \n", area_p->lcInfo[j].endPduType);
                    }
                }
                if ((area_p->lcInfo[j].prevTimeStampToUse >= area_p->lcInfo[j].syncPeriod) && ((area_p->lcInfo[j].controlPacketSend = TRUE) || 
                                                              (area_p->lcInfo[j].dataPacketSend == TRUE)))
                {
                    area_p->lcInfo[j].prevTimeStampToUse = area_p->lcInfo[j].timeStamp %= area_p->lcInfo[j].syncPeriod;
                    // reset totalNoOfPackets and totalNoOfOctets as SYNC period is finished
                    area_p->lcInfo[j].totalNoOfPackets = 0;
                    area_p->lcInfo[j].totalNoOfOctets = 0;
                }
            }
        }        
    }

#if 0
#define CALC_LOAD_TX(a,x,y)    sectorDb_g[a].ueDataFlow_g[x][y].txData /=1024;\
    sectorDb_g[a].ueDataFlow_g[x][y].txData *=1000;\
    sectorDb_g[a].ueDataFlow_g[x][y].txData /= 1024;\
    sectorDb_g[a].ueDataFlow_g[x][y].txData *=8;\
    sectorDb_g[a].ueDataFlow_g[x][y].txData /= diff
    clock_gettime(CLOCK_REALTIME,&currRxTime);
    loadCalcTimeDiff = ((currRxTime.tv_sec - lastDispTime.tv_sec)*1000 +
            ((currRxTime.tv_nsec - lastDispTime.tv_nsec)/1000000));
    for(i=0; i<syncAreaDB_g.areaCount; i++)
    {
        areareaInfo_t *area_p = &(syncAreaDB_g.areainfo[i]);

        for (j=0; j<area_p->lcCount; j++)
        {
            int txData = area_p->lcInfo[j].txData/1024;

        }
    }
#endif
}



void initDLBufferForSync(UInt8 * sendBuffer, UInt32 offset, UInt32 packetSize)
{
    unsigned short headerStart = 8;

    /*  This buffer is  used as a hardcoded value which contains IP/UDP/RTP
     *  header for UE (containing UE IP address). The same packet is sent for
     *  multiple UE (w/o change in UE IP Address)   */
#ifdef ROHC_PROFILE_6 // profile TCP
#ifndef UE_IPV6_ADDR
    /*  This buffer is  used as a hardcoded value which contains IP/TCP header
     *  for UE (containing UE IP address). The same packet is sent for multiple UE
     *  (w/o change in UE IP Address)*/

    UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
        0x45,0x00,0x00,0x00,0x23,0x21,0x40,0x00, /* IP header */
        0xff,0x06,0x00,0x00,0xac,0x10,0x51,0x15,
        0xe0,0x00,0x00,0xfb,
        0x14, 0xe9, 0x14, 0xea, 0x03, 0x46, 0xd0, 0x0a, /* TCP Header */
        0x10, 0x02, 0x30, 0x04, 0xa0, 0x00, 0x39, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,
        0x04, 0x02, 0x08, 0x0a, 0xe2, 0x08, 0x2f, 0x90,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07,
        0x61,0x6e,0x69,0x6c};  /* Payload */

    memcpy(&sendBuffer[START_OFFSET_DL_GTP1+offset],sendBuffer3,80);



#else

    UInt8 sendBuffer3[MAX_PAYLOAD_SIZE] = {0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,0x60,
        0x60,0x20,0x00,0x00,0x00,0x00,0x06,0xff, /* IPv6 Header */
        0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x14,
        0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x13,
        0x14, 0xe9, 0x14, 0xea, 0x03, 0x46, 0xd0, 0x0a, /* TCP Header */
        0x10, 0x02, 0x30, 0x04, 0xa0, 0x00, 0x39, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4,
        0x04, 0x02, 0x08, 0x0a, 0xe2, 0x08, 0x2f, 0x90,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07,
        0x61,0x6e,0x69,0x6c};  /* Payload */

    memcpy(&sendBuffer[START_OFFSET_DL_GTP1 + offset],sendBuffer3,80);

#endif
#elif ROHC_PROFILE_1 
#ifndef UE_IPV6_ADDR
    UInt8 sendBuffer3[] = {
        0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
        0x45,0x00,0x00,0x00,0x23,0x21,0x40,0x00, /* IP header */
        0xff,0x11,0x00,0x00,0xac,0x10,0x51,0x15,
        0xe0,0x00,0x00,0xfb,
        0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00, /* UDP header */
        0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x5d,0x7c,0x95,0x7c, /* RTP header */
        0x61,0x6e,0x69,0x6c}; /* Payload */


    memcpy(&sendBuffer[START_OFFSET_DL_GTP1 + offset],sendBuffer3,60);

#else
    UInt8 sendBuffer3[] = {
        0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
        0x60,0x20,0x00,0x00,0x00,0x00,0x11,0xff, /* IPv6 Header */
        0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x13,
        0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x14,
        0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00, /* UDP header */
        0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x5d,0x7c,0x95,0x7c, /* RTP header */
        0x61,0x6e,0x69,0x6c}; /* Payload */

    memcpy(&sendBuffer[START_OFFSET_DL_GTP1 + offset],sendBuffer3,80);

#endif

#else /* Profile - 0/2, UDP packet */

#ifndef UE_IPV6_ADDR
    UInt8 sendBuffer3[] = {
        0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
        0x45,0x00,0x00,0x00,0x23,0x21,0x40,0x00, /* IPv4 header */
        0xff,0x11,0x00,0x00,0xac,0x10,0x51,0x15,
        0xe0,0x00,0x00,0xfb,
        0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00, /* UDP Header */
        0x61,0x6e,0x69,0x6c};

    memcpy(&sendBuffer[START_OFFSET_DL_GTP1 + offset],sendBuffer3,40);/* COVERITY 26428 */
#else
    UInt8 sendBuffer3[] =  {
        0x00,0x00,0x20,0x00,0x00,0x40,0x00,0x40,
        0x60,0x20,0x00,0x00,0x00,0x00,0x11,0xff, /* IPv6 Header */
        0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x13,
        0x07,0xD1,0x07,0xDA,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x14,
        0x14,0xe9,0x14,0xea,0x00,0x00,0x00,0x00, /* UDP header */
        0x61,0x6e,0x69,0x6c}; /* Payload */

    memcpy(&sendBuffer[START_OFFSET_DL_GTP1 + offset],sendBuffer3,60);
#endif
#endif
}
#endif
