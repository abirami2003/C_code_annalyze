/*********************************************************************
 *
 *  FILE NAME   : umts_sib_decoder.c
 *
 *  DESCRIPTION : File contains the sib decoder implementaion.
 *
 *  REVISION HISTORY :

 *
 *  DATE              Name           Reference               Comments
 *  Feb 01,2013      Ravi Gupta                              Initial
 *  Mar 01,2014      Rashi Agrawal                           Initial
 *  Mar 01,2014      Sankar Pradhan                          Initial
 *
 *  Copyright (c) 2011, Aricent Inc.
 *
 *******************************************************************/
#include "umts_sib_type_defines.h"
#include "umts_sib_decoder_intf.h"
#include "umtsSibParsing.h"

umts_sib_decoder_global_ctxt_t g_umts_ctxt = {0};

/******************************************************************************
 *   FUNCTION NAME: fill_plmn_identity 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMN_Identity to
 *       umts_plmn_identity_t 
 *
 *******************************************************************************/
void fill_plmn_identity
(
 UMTS_PLMN_Identity       *p_asn_plmn_identity,
 umts_plmn_identity_t     *p_umts_plmn_identity
 )
{

    /* MCC Decoding */
    p_umts_plmn_identity->mcc.n = p_asn_plmn_identity->mcc.n;

    memcpy(p_umts_plmn_identity->mcc.digit_elem, 
            p_asn_plmn_identity->mcc.elem,
            sizeof(U8) * p_asn_plmn_identity->mcc.n);

    /* MNC Decoding */
    p_umts_plmn_identity->mnc.n = p_asn_plmn_identity->mnc.n;

    memcpy(p_umts_plmn_identity->mnc.digit_elem, 
            p_asn_plmn_identity->mnc.elem,
            sizeof(U8) * p_asn_plmn_identity->mnc.n);

    return; 
}

/******************************************************************************
 *   FUNCTION NAME: fill_plmn_type_gsm_map
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMN_Type_gsm_MAP to
 *       plmn_type_gsm_map_t
 *
 *******************************************************************************/
void fill_plmn_type_gsm_map
(   
 UMTS_PLMN_Type_gsm_MAP *p_asn_plmn_type_gsm,
 plmn_type_gsm_map_t    *p_umts_plmn_type_gsm
 )
{
    fill_plmn_identity( &(p_asn_plmn_type_gsm->plmn_Identity),
            &(p_umts_plmn_type_gsm->plmn_identity));

    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_plmn_type_ansi_41
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMN_Type_ansi_41 to
 *       plmn_type_ansi_41_t
 *
 *******************************************************************************/
void fill_plmn_type_ansi_41 
(
 UMTS_PLMN_Type_ansi_41     *asn_plmn_type_ansi_41,
 plmn_type_ansi_41_t        *umts_plmn_type_ansi_41
 )
{
    memcpy ( umts_plmn_type_ansi_41->p_rev,
            asn_plmn_type_ansi_41->p_REV.data,
            sizeof(U8) * P_REV_OCTET_SIZE );

    memcpy ( umts_plmn_type_ansi_41->min_p_rev,
            asn_plmn_type_ansi_41->min_P_REV.data,
            sizeof(U8) * MIN_P_REV_OCTET_SIZE );

    memcpy ( umts_plmn_type_ansi_41->sid,
            asn_plmn_type_ansi_41->sid.data,
            sizeof(U8) * SID_OCTET_SIZE );

    memcpy ( umts_plmn_type_ansi_41->nid,
            asn_plmn_type_ansi_41->nid.data,
            sizeof(U8) * NID_OCTET_SIZE );

    return;
}


/******************************************************************************
 *   FUNCTION NAME:fill_plmn_type_gsm_map_ansi_41
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMN_Type_gsm_MAP_and_ANSI_41 to
 *       plmn_type_gsm_map_and_ansi_41_t
 *
 *******************************************************************************/
void fill_plmn_type_gsm_map_ansi_41
(   
 UMTS_PLMN_Type_gsm_MAP_and_ANSI_41   *asn_plmn_type_gsm_map_ansi_41,
 plmn_type_gsm_map_and_ansi_41_t *umts_plmn_type_gsm_map_ansi_41
 )
{
    fill_plmn_identity( &(asn_plmn_type_gsm_map_ansi_41->plmn_Identity),
            &(umts_plmn_type_gsm_map_ansi_41->plmn_Identity));

    memcpy ( umts_plmn_type_gsm_map_ansi_41->p_rev,
            asn_plmn_type_gsm_map_ansi_41->p_REV.data,
            sizeof(U8) * P_REV_OCTET_SIZE );

    memcpy ( umts_plmn_type_gsm_map_ansi_41->min_p_rev,
            asn_plmn_type_gsm_map_ansi_41->min_P_REV.data,
            sizeof(U8) * MIN_P_REV_OCTET_SIZE );

    memcpy ( umts_plmn_type_gsm_map_ansi_41->sid,
            asn_plmn_type_gsm_map_ansi_41->sid.data,
            sizeof(U8) * SID_OCTET_SIZE );

    memcpy ( umts_plmn_type_gsm_map_ansi_41->nid,
            asn_plmn_type_gsm_map_ansi_41->nid.data,
            sizeof(U8) * NID_OCTET_SIZE );

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_plmn_type 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMN_Type to plmn_type_t 
 *
 *******************************************************************************/
void convert_plmn_type
(
 UMTS_PLMN_Type *asn_plmn_type,
 plmn_type_t    *umts_plmn_type
 )
{
    umts_plmn_type->t = asn_plmn_type->t;

    if ( asn_plmn_type->t == T_UMTS_PLMN_Type_gsm_MAP)
    {
        fill_plmn_type_gsm_map( asn_plmn_type->u.gsm_MAP,
                &(umts_plmn_type->u.gsm_map));
    }
    else if ( asn_plmn_type->t == T_UMTS_PLMN_Type_ansi_41)
    {
        fill_plmn_type_ansi_41( asn_plmn_type->u.ansi_41,
                &(umts_plmn_type->u.ansi_41));
    }
    else if ( asn_plmn_type->t == T_UMTS_PLMN_Type_gsm_MAP_and_ANSI_41)
    {
        fill_plmn_type_gsm_map_ansi_41( asn_plmn_type->u.gsm_MAP_and_ANSI_41,
                &(umts_plmn_type->u.gsm_map_and_ansi_41));
    }
    else if ( asn_plmn_type->t == T_UMTS_PLMN_Type_spare )
    {
        /* for future use */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: fill_sib_sb_type
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SIBSb_TypeAndTag to
 *       sib_sb_type_and_tag_t 
 *
 *******************************************************************************/
void fill_sib_sb_type
(
 UMTS_SIBSb_TypeAndTag  *asn_sib_type_tag,
 sib_sb_type_and_tag_t  *umts_sib_type_tag
 )
{
    umts_sib_type_tag->t = asn_sib_type_tag->t;

    switch(asn_sib_type_tag->t)
    {
        case T_UMTS_SIBSb_TypeAndTag_sysInfoType1:
            umts_sib_type_tag->u.sysInfoType1 = asn_sib_type_tag->u.sysInfoType1;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType2:
            umts_sib_type_tag->u.sysInfoType2 = asn_sib_type_tag->u.sysInfoType2;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType3:
            umts_sib_type_tag->u.sysInfoType3 = asn_sib_type_tag->u.sysInfoType3;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType4:
            umts_sib_type_tag->u.sysInfoType4 = asn_sib_type_tag->u.sysInfoType4;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType5:
            umts_sib_type_tag->u.sysInfoType5 = asn_sib_type_tag->u.sysInfoType5;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType6:
            umts_sib_type_tag->u.sysInfoType6 = asn_sib_type_tag->u.sysInfoType6;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType7:
            printf("fill_sib_sb_type: option not available\n");
            break;

        case T_UMTS_SIBSb_TypeAndTag_dummy:
            umts_sib_type_tag->u.dummy = asn_sib_type_tag->u.dummy;
            break;

        case T_UMTS_SIBSb_TypeAndTag_dummy2:
            printf("fill_sib_sb_type: option not available\n");
            break;

        case T_UMTS_SIBSb_TypeAndTag_dummy3:
            printf("fill_sib_sb_type: option not available\n");
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType11:
            umts_sib_type_tag->u.sysInfoType11 = asn_sib_type_tag->u.sysInfoType11;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType12:
            umts_sib_type_tag->u.sysInfoType12 = asn_sib_type_tag->u.sysInfoType12;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType13:
            umts_sib_type_tag->u.sysInfoType13 = asn_sib_type_tag->u.sysInfoType13;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType13_1:
            umts_sib_type_tag->u.sysInfoType13_1 = asn_sib_type_tag->u.sysInfoType13_1;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType13_2:
            umts_sib_type_tag->u.sysInfoType13_2 = asn_sib_type_tag->u.sysInfoType13_2;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType13_3:
            umts_sib_type_tag->u.sysInfoType13_3 = asn_sib_type_tag->u.sysInfoType13_3;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType13_4:
            umts_sib_type_tag->u.sysInfoType13_4 = asn_sib_type_tag->u.sysInfoType13_4;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType14:
            printf("fill_sib_sb_type: option not available\n");
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType15:
            umts_sib_type_tag->u.sysInfoType15 = asn_sib_type_tag->u.sysInfoType15;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType16:
            {
                umts_sib_type_tag->u.sysInfoType16.predefined_config_identity = 
                    asn_sib_type_tag->u.sysInfoType16->predefinedConfigIdentity;

                umts_sib_type_tag->u.sysInfoType16.predefined_config_value_tag =
                    asn_sib_type_tag->u.sysInfoType16->predefinedConfigValueTag;
            }
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType17:
            printf("fill_sib_sb_type: option not available\n");
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoTypeSB1:
            umts_sib_type_tag->u.sysInfoTypeSB1 = asn_sib_type_tag->u.sysInfoTypeSB1;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoTypeSB2:
            umts_sib_type_tag->u.sysInfoTypeSB2 = asn_sib_type_tag->u.sysInfoTypeSB2;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType15_1:
            umts_sib_type_tag->u.sysInfoType15_1 = asn_sib_type_tag->u.sysInfoType15_1;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType15_2:
            {
                umts_sib_type_tag->u.sysInfoType15_2.sib_occur_identity = 
                    asn_sib_type_tag->u.sysInfoType15_2->sibOccurIdentity;

                umts_sib_type_tag->u.sysInfoType15_2.sib_occur_value_tag =
                    asn_sib_type_tag->u.sysInfoType15_2->sibOccurValueTag;
            }
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType15_3:
            {
                umts_sib_type_tag->u.sysInfoType15_3.sib_occur_identity = 
                    asn_sib_type_tag->u.sysInfoType15_3->sibOccurIdentity;

                umts_sib_type_tag->u.sysInfoType15_3.sib_occur_value_tag =
                    asn_sib_type_tag->u.sysInfoType15_3->sibOccurValueTag;
            }
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType15_4:
            umts_sib_type_tag->u.sysInfoType15_4 = asn_sib_type_tag->u.sysInfoType15_4;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType18:
            umts_sib_type_tag->u.sysInfoType18 = asn_sib_type_tag->u.sysInfoType18;
            break;
        case T_UMTS_SIBSb_TypeAndTag_sysInfoType15_5:
            umts_sib_type_tag->u.sysInfoType15_5 = asn_sib_type_tag->u.sysInfoType15_5;
            break;

        case T_UMTS_SIBSb_TypeAndTag_sysInfoType5bis:
            umts_sib_type_tag->u.sysInfoType5bis = asn_sib_type_tag->u.sysInfoType5bis;
            break;

        case T_UMTS_SIBSb_TypeAndTag_spare2:
            printf("fill_sib_sb_type: option not available\n");
            break;

        case T_UMTS_SIBSb_TypeAndTag_spare1:
            printf("fill_sib_sb_type: option not available\n");
            break;

        default:
            printf("fill_sib_sb_type: No such option available\n");
            break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: fill_scheduling_pos
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SchedulingInformation_scheduling_sib_Pos
 *       to schedulingInformation_scheduling_sib_pos_t 
 *
 *******************************************************************************/
void fill_scheduling_pos
(
 UMTS_SchedulingInformation_scheduling_sib_Pos  *asn_scheduling_sib_pos,
 schedulingInformation_scheduling_sib_pos_t     *umts_scheduling_sib_pos
 )
{
    umts_scheduling_sib_pos->t = asn_scheduling_sib_pos->t;

    switch(asn_scheduling_sib_pos->t)
    {
        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep4:
            umts_scheduling_sib_pos->u.rep4 = asn_scheduling_sib_pos->u.rep4;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep8:
            umts_scheduling_sib_pos->u.rep8 = asn_scheduling_sib_pos->u.rep8;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep16:
            umts_scheduling_sib_pos->u.rep16 = asn_scheduling_sib_pos->u.rep16;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep32:
            umts_scheduling_sib_pos->u.rep32 = asn_scheduling_sib_pos->u.rep32;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep64:
            umts_scheduling_sib_pos->u.rep64 = asn_scheduling_sib_pos->u.rep64;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep128:
            umts_scheduling_sib_pos->u.rep128 = asn_scheduling_sib_pos->u.rep128;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep256:
            umts_scheduling_sib_pos->u.rep256 = asn_scheduling_sib_pos->u.rep256;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep512:
            umts_scheduling_sib_pos->u.rep512 = asn_scheduling_sib_pos->u.rep512;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep1024:
            umts_scheduling_sib_pos->u.rep1024 = asn_scheduling_sib_pos->u.rep1024;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep2048:
            umts_scheduling_sib_pos->u.rep2048 = asn_scheduling_sib_pos->u.rep2048;
            break;

        case T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep4096:
            umts_scheduling_sib_pos->u.rep4096 = asn_scheduling_sib_pos->u.rep4096;
            break;

        default:
            printf("fill_scheduling_pos:No such option available\n");
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: fill_scheduling_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SchedulingInformation
 *       to scheduling_information_t 
 *
 *******************************************************************************/
void fill_scheduling_info
(
 UMTS_SchedulingInformation *asn_scheduling,
 scheduling_information_t   *umts_scheduling
 )
{
    umts_scheduling->scheduling.seg_count =
        asn_scheduling->scheduling.segCount;

    fill_scheduling_pos( &(asn_scheduling->scheduling.sib_Pos),
            &(umts_scheduling->scheduling.sib_Pos));

    if (asn_scheduling->scheduling.m.sib_PosOffsetInfoPresent == 1)
    {
        umts_scheduling->scheduling.presence_bitmask |= 
            UMTS_SCHEDULING_INFO_SIB_OFF_LIST_PRESENCE_FLAG;

        umts_scheduling->scheduling.sib_pos_offset_info.count = 
            asn_scheduling->scheduling.sib_PosOffsetInfo.n;

        memcpy(umts_scheduling->scheduling.sib_pos_offset_info.sib_off_elem,
                asn_scheduling->scheduling.sib_PosOffsetInfo.elem,
                ( sizeof(U32) * umts_scheduling->scheduling.sib_pos_offset_info.count));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_scheduling_info_sib_sb
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SchedulingInformationSIBSb to
 *       scheduling_information_sib_sb_t 
 *
 *******************************************************************************/
void fill_scheduling_info_sib_sb
(  
 UMTS_SchedulingInformationSIBSb    *asn_scheduling_info_sibsb,
 scheduling_information_sib_sb_t    *umts_scheduling_info_sibsb
 )
{
    fill_sib_sb_type(&(asn_scheduling_info_sibsb->sibSb_Type),
            &(umts_scheduling_info_sibsb->sib_sb_Type));

    fill_scheduling_info(&(asn_scheduling_info_sibsb->scheduling),
            &(umts_scheduling_info_sibsb->scheduling));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sibsb_reference_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SIBSb_ReferenceList to
 *       sibsb_reference_list_t 
 *
 *******************************************************************************/
void convert_sibsb_reference_list
(
 UMTS_SIBSb_ReferenceList   *asn_sibsb_reference_list,
 sibsb_reference_list_t     *umts_sibsb_reference_list
 )
{
    OSRTDListNode                       *pnode  = NULL;
    UMTS_SchedulingInformationSIBSb     *pdata0 = NULL;
    U32                                 index;

    umts_sibsb_reference_list->count = asn_sibsb_reference_list->count;
    pnode = asn_sibsb_reference_list->head;

    for (index=0; index<umts_sibsb_reference_list->count; index++)
    {
        pdata0 = (UMTS_SchedulingInformationSIBSb*)pnode->data;

        fill_scheduling_info_sib_sb(
                pdata0,
                &(umts_sibsb_reference_list->scheduling_informationi_sib_sb[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mnc
 *
 *   DESCRIPTION:
 *       This function converts UMTS_mnc to
 *       umts_mnc_t 
 *
 *******************************************************************************/
void convert_mnc
(
 UMTS_MNC       *pvalue,
 umts_mnc_t     *p_mnc 
 )
{
    p_mnc->n = pvalue->n;

    memcpy (p_mnc->digit_elem, 
            pvalue->elem,
            (sizeof (U8) * pvalue->n));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mcc
 *
 *   DESCRIPTION:
 *       This function converts UMTS_mcc to
 *       mcc_t 
 *
 *******************************************************************************/
void convert_mcc
(
 UMTS_MCC   *pvalue,
 mcc_t      *p_mcc 
 )
{
    p_mcc->n = pvalue->n;

    memcpy (p_mcc->digit_elem, pvalue->elem,
            (sizeof (U8) * pvalue->n));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_plmn_identity_with_optional_mcc_r6
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMN_IdentityWithOptionalMCC_r6 to
 *       plmn_identity_with_optional_mcc_r6_t 
 *
 *******************************************************************************/
void convert_plmn_identity_with_optional_mcc_r6
(
 UMTS_PLMN_IdentityWithOptionalMCC_r6   *p_asn_plmn_id_with_optional_mcc_r6,
 plmn_identity_with_optional_mcc_r6_t   *p_umts_plmn_id_with_optional_mcc_r6
 )
{
    if (p_asn_plmn_id_with_optional_mcc_r6->m.mccPresent == 1)
    {
        p_umts_plmn_id_with_optional_mcc_r6->presence_bitmask |=
            UMTS_PLMN_IDENTITY_WITH_OPTIONAL_MCC_R6_MCC_PRESENCE_FLAG;

        convert_mcc(
                &p_asn_plmn_id_with_optional_mcc_r6->mcc,
                &p_umts_plmn_id_with_optional_mcc_r6->mcc);
    }

    convert_mnc(
            &p_asn_plmn_id_with_optional_mcc_r6->mnc,
            &p_umts_plmn_id_with_optional_mcc_r6->mnc);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: decode_multiple_plmn_list_r6_multiple_plmns
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MultiplePLMN_List_r6_multiplePLMNs to
 *       multiple_plmn_list_r6_multiple_plmns_t 
 *
 *******************************************************************************/
void decode_multiple_plmn_list_r6_multiple_plmns
(
 UMTS_MultiplePLMN_List_r6_multiplePLMNs    *pvalue,
 multiple_plmn_list_r6_multiple_plmns_t     *p_multiple_plmns
 )
{

    UMTS_PLMN_IdentityWithOptionalMCC_r6    *pdata0 = NULL;
    OSRTDListNode                           *pnode  = NULL;
    U32                                     index;

    p_multiple_plmns->count = pvalue->count;
    pnode = pvalue->head;

    for ( index=0; index < pvalue->count; index++)
    {
        pdata0 = (UMTS_PLMN_IdentityWithOptionalMCC_r6*)pnode->data;

        convert_plmn_identity_with_optional_mcc_r6(
                pdata0,
                &(p_multiple_plmns->plmn_identity_with_optional_mcc_r6[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: decode_multiple_plmn_list_r6
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MultiplePLMN_List_r6 to
 *       multiple_plmn_list_r6_t 
 *
 *******************************************************************************/
void decode_multiple_plmn_list_r6
(
 UMTS_MultiplePLMN_List_r6  *pvalue,
 multiple_plmn_list_r6_t    *p_multiple_plmn_list_r6
 )
{
    p_multiple_plmn_list_r6->mib_plmn_identity =
        pvalue->mibPLMN_Identity;

    decode_multiple_plmn_list_r6_multiple_plmns( 
            &(pvalue->multiplePLMNs),
            &(p_multiple_plmn_list_r6->multiple_plmn_list_r6_multiple_plmns));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: decode_mib_v690ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MasterInformationBlock_v690ext to
 *       mib_v690ext_t 
 *
 *******************************************************************************/
void decode_mib_v690ext
(
 UMTS_MasterInformationBlock_v690ext    *pvalue,
 mib_v690ext_t                          *p_mib_v690ext
 )
{
    if (pvalue->m.multiplePLMN_ListPresent)
    {
        p_mib_v690ext->presence_bitmask |= UMTS_MULTIPLE_PLMN_LIST_R6_PRESENCE_FLAG;

        decode_multiple_plmn_list_r6(
                &(pvalue->multiplePLMN_List),
                &(p_mib_v690ext->multiple_plmn_list_r6));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mib_v860ext_ies
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MasterInformationBlock_v860ext_IEs to
 *       mib_v860ext_ies_t 
 *
 *******************************************************************************/
void convert_mib_v860ext_ies
(
 UMTS_MasterInformationBlock_v860ext_IEs    *pvalue,
 mib_v860ext_ies_t                          *p_mib_v860ext_ies 
 )
{
    if (pvalue->m.extSIBTypeInfoSchedulingInfo_ListPresent)
    {
        p_mib_v860ext_ies->presence_bitmask |=
            UMTS_EXT_SIB_TYPE_INFO_SCHEDULING_INFO_LIST2_PRESENCE_FLAG;

        convert_ext_sib_type_info_scheduling_info_list2(
                &pvalue->extSIBTypeInfoSchedulingInfo_List,
                &p_mib_v860ext_ies->ext_sib_type_info_scheduling_info_list2); 
    }

    if (pvalue->m.extGANSS_SIBTypeInfoSchedulingInfoListPresent)
    {
        p_mib_v860ext_ies->presence_bitmask |=
            UMTS_EXT_GANSS_SIB_TYPE_INFO_SCHEDULING_INFO_LIST_PRESENCE_FLAG;

        convert_ext_ganss_sib_type_info_scheduling_info_list(
                &pvalue->extGANSS_SIBTypeInfoSchedulingInfoList,
                &p_mib_v860ext_ies->ext_ganss_sib_type_info_scheduling_info_list); 
    }

    if (pvalue->m.csg_IndicatorPresent)
    {
        p_mib_v860ext_ies->presence_bitmask |=
            UMTS_V860_EXT_IE_CSG_INDICATOR_PRESENCE_FLAG;

        p_mib_v860ext_ies->csg_indicator = pvalue->csg_Indicator; 
    }

    return;
}

/**************************************************************************************************************************************
 *   FUNCTION NAME: convert_mib_v690_nce_v6b0_nce_v860_nce
 *
 *   DESCRIPTION:
 *       This function converts
 *       UMTS_MasterInformationBlock_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions to
 *       mib_v690_nce_v6b0_nce_v860_nce_nce_t
 *
 ***************************************************************************************************************************************/
void convert_mib_v690_nce_v6b0_nce_v860_nce_nce
(
 UMTS_MasterInformationBlock_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions    *pvalue,
 mib_v690_nce_v6b0_nce_v860_nce_nce_t           *p_nce
 )
{
    p_nce->__dummy__ = pvalue->__dummy__;

    return;
}

/*************************************************************************************************************************
 *   FUNCTION NAME: convert_mib_v690_nce_v6b0_nce_v860_nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MasterInformationBlock_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v860NonCriticalExtensions to
 *       mib_v690_nce_v6b0_nce_v860_nce_t 
 *
 *****************************************************************************************************************************/
void convert_mib_v690_nce_v6b0_nce_v860_nce
(
 UMTS_MasterInformationBlock_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v860NonCriticalExtensions  *pvalue,
 mib_v690_nce_v6b0_nce_v860_nce_t                                                                           *p_nce
 )
{
    convert_mib_v860ext_ies(
            &pvalue->masterInformationBlock_v860ext,
            &p_nce->mib_v860ext_ies);

    if (pvalue->m.nonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_MIB_V690_NCE_V6B0_NCE_V860_NCE_NCE_PRESENCE_FLAG;

        convert_mib_v690_nce_v6b0_nce_v860_nce_nce(
                &pvalue->nonCriticalExtensions,
                &p_nce->mib_v690_nce_v6b0_nce_v860_nce_nce);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mib_v6b0_ext_ie
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MasterInformationBlock_v6b0ext_IEs to
 *       mib_v6b0_ext_ie_t 
 *
 *******************************************************************************/
void convert_mib_v6b0_ext_ie
(
 UMTS_MasterInformationBlock_v6b0ext_IEs    *pvalue,
 mib_v6b0_ext_ie_t                          *p_mib_v6b0_ext_ie 
 )
{
    if (pvalue->m.extSIBTypeInfoSchedulingInfo_ListPresent)
    {
        p_mib_v6b0_ext_ie->presence_bitmask |=
            UMTS_MIB_EXT_SIB_TYPE_INFO_SCHEDULING_INFO_LIST_PRESENCE_FLAG;

        convert_ext_sib_type_info_scheduling_info_list(
                &pvalue->extSIBTypeInfoSchedulingInfo_List,
                &p_mib_v6b0_ext_ie->ext_sib_type_info_scheduling_info_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: decode_mib_v690_nce_v6b0_nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MasterInformationBlock_v690NonCriticalExtensions_v6b0NonCriticalExtensions to
 *       mib_v690_nce_v6b0_nce_t 
 *
 *******************************************************************************/
void decode_mib_v690_nce_v6b0_nce
(
 UMTS_MasterInformationBlock_v690NonCriticalExtensions_v6b0NonCriticalExtensions    *pvalue,
 mib_v690_nce_v6b0_nce_t                                                            *p_nce
 )
{
    convert_mib_v6b0_ext_ie(
            &pvalue->masterInformationBlock_v6b0ext,
            &p_nce->mib_v6b0_ext_ie);

    if (pvalue->m.v860NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_MIB_V690_NCE_V6B0_NCE_V860_NCE_PRESENCE_FLAG;

        convert_mib_v690_nce_v6b0_nce_v860_nce(
                &(pvalue->v860NonCriticalExtensions),
                &(p_nce->mib_v690_nce_v6b0_nce_v860_nce));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: decode_mib_v690_nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MasterInformationBlock_v690NonCriticalExtensions to
 *       mib_v690_nce_t 
 *
 *******************************************************************************/
void decode_mib_v690_nce
(
 UMTS_MasterInformationBlock_v690NonCriticalExtensions  *pvalue,
 mib_v690_nce_t                                         *p_mib_v690_nce
 )
{
    decode_mib_v690ext(
            &(pvalue->masterInformationBlock_v690ext),
            &(p_mib_v690_nce->mib_v690ext));

    if (pvalue->m.v6b0NonCriticalExtensionsPresent)
    {
        p_mib_v690_nce->presence_bitmask |= UMTS_MIB_V690_NCE_V6B0_PRESENCE_FLAG;

        decode_mib_v690_nce_v6b0_nce(
                &(pvalue->v6b0NonCriticalExtensions),
                &(p_mib_v690_nce->mib_v690_nce_v6b0_nce));      
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_mib
 *
 *   DESCRIPTION:
 *       This function decodes MIB
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_mib
(
 umts_mib_info_t    *umts_mib_info
 )
{
    UMTS_MasterInformationBlock  asn_mib_info;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_MIB_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&asn_mib_info, 0, sizeof(UMTS_MasterInformationBlock));

    if( 0 != (asn1PD_UMTS_MasterInformationBlock(&ctxt, &asn_mib_info)))
    {
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    asn1Print_UMTS_MasterInformationBlock("Decoded MIB\n",&asn_mib_info);
    memset( umts_mib_info, 0 , sizeof(umts_mib_info_t));

    umts_mib_info->mib_value_tag = asn_mib_info.mib_ValueTag;

    convert_plmn_type(
            &(asn_mib_info.plmn_Type), 
            &(umts_mib_info->plmn_Type));

    convert_sibsb_reference_list(
            &(asn_mib_info.sibSb_ReferenceList),
            &(umts_mib_info->sibsb_reference_list));

    if (asn_mib_info.m.v690NonCriticalExtensionsPresent == 1)
    {
        umts_mib_info->presence_bitmask |= UMTS_MIB_NON_CRITICAL_EXTN_PRESENCE_FLAG;

        decode_mib_v690_nce(
                &(asn_mib_info.v690NonCriticalExtensions),
                &(umts_mib_info->mib_v690_nce));
    }

    rtFreeContext(&ctxt);

    return SUCCESS; 
}

/******************************************************************************
 *   FUNCTION NAME: fill_sib_type
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SIB_TypeAndTag to
 *       sib_type_and_tag_t 
 *
 *******************************************************************************/
void fill_sib_type
(
 UMTS_SIB_TypeAndTag    *asn_sib_type_tag,
 sib_type_and_tag_t     *umts_sib_type_tag
 )
{
    umts_sib_type_tag->t = asn_sib_type_tag->t;

    switch(asn_sib_type_tag->t)
    {
        case T_UMTS_SIB_TypeAndTag_sysInfoType1:
            umts_sib_type_tag->u.sysInfoType1 = asn_sib_type_tag->u.sysInfoType1;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType2:
            umts_sib_type_tag->u.sysInfoType2 = asn_sib_type_tag->u.sysInfoType2;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType3:
            umts_sib_type_tag->u.sysInfoType3 = asn_sib_type_tag->u.sysInfoType3;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType4:
            umts_sib_type_tag->u.sysInfoType4 = asn_sib_type_tag->u.sysInfoType4;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType5:
            umts_sib_type_tag->u.sysInfoType5 = asn_sib_type_tag->u.sysInfoType5;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType6:
            umts_sib_type_tag->u.sysInfoType6 = asn_sib_type_tag->u.sysInfoType6;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType7:
            printf("fill_sib_type: option not available\n");
            break;

        case T_UMTS_SIB_TypeAndTag_dummy:
            umts_sib_type_tag->u.dummy = asn_sib_type_tag->u.dummy;
            break;

        case T_UMTS_SIB_TypeAndTag_dummy2:
            printf("fill_sib_type: option not available\n");
            break;
        case T_UMTS_SIB_TypeAndTag_dummy3:
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType11:
            umts_sib_type_tag->u.sysInfoType11 = asn_sib_type_tag->u.sysInfoType11;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType12:
            umts_sib_type_tag->u.sysInfoType12 = asn_sib_type_tag->u.sysInfoType12;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType13:
            umts_sib_type_tag->u.sysInfoType13 = asn_sib_type_tag->u.sysInfoType13;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType13_1:
            umts_sib_type_tag->u.sysInfoType13_1 = asn_sib_type_tag->u.sysInfoType13_1;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType13_2:
            umts_sib_type_tag->u.sysInfoType13_2 = asn_sib_type_tag->u.sysInfoType13_2;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType13_3:
            umts_sib_type_tag->u.sysInfoType13_3 = asn_sib_type_tag->u.sysInfoType13_3;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType13_4:
            umts_sib_type_tag->u.sysInfoType13_4 = asn_sib_type_tag->u.sysInfoType13_4;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType14:
            printf("fill_sib_type: option not available\n");
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType15:
            umts_sib_type_tag->u.sysInfoType15 = asn_sib_type_tag->u.sysInfoType15;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType16:
            {
                umts_sib_type_tag->u.sysInfoType16.predefined_config_identity = 
                    asn_sib_type_tag->u.sysInfoType16->predefinedConfigIdentity;

                umts_sib_type_tag->u.sysInfoType16.predefined_config_value_tag =
                    asn_sib_type_tag->u.sysInfoType16->predefinedConfigValueTag;
            }
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType17:
            printf("fill_sib_type: option not available\n");
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType15_1:
            umts_sib_type_tag->u.sysInfoType15_1 = asn_sib_type_tag->u.sysInfoType15_1;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType15_2:
            {
                umts_sib_type_tag->u.sysInfoType15_2.sib_occur_identity = 
                    asn_sib_type_tag->u.sysInfoType15_2->sibOccurIdentity;

                umts_sib_type_tag->u.sysInfoType15_2.sib_occur_value_tag =
                    asn_sib_type_tag->u.sysInfoType15_2->sibOccurValueTag;
            }
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType15_3:
            {
                umts_sib_type_tag->u.sysInfoType15_3.sib_occur_identity = 
                    asn_sib_type_tag->u.sysInfoType15_3->sibOccurIdentity;

                umts_sib_type_tag->u.sysInfoType15_3.sib_occur_value_tag =
                    asn_sib_type_tag->u.sysInfoType15_3->sibOccurValueTag;
            }
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType15_4:
            umts_sib_type_tag->u.sysInfoType15_4 = asn_sib_type_tag->u.sysInfoType15_4;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType18:
            umts_sib_type_tag->u.sysInfoType18 = asn_sib_type_tag->u.sysInfoType18;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType15_5:
            umts_sib_type_tag->u.sysInfoType15_5 = asn_sib_type_tag->u.sysInfoType15_5;
            break;

        case T_UMTS_SIB_TypeAndTag_sysInfoType5bis:
            umts_sib_type_tag->u.sysInfoType5bis = asn_sib_type_tag->u.sysInfoType5bis;
            break;

        case T_UMTS_SIB_TypeAndTag_spare4:
            printf("fill_sib_type: option not available\n");
            break;

        case T_UMTS_SIB_TypeAndTag_spare3:
            printf("fill_sib_type: option not available\n");
            break;

        case T_UMTS_SIB_TypeAndTag_spare2:
            printf("fill_sib_type: option not available\n");
            break;

        case T_UMTS_SIB_TypeAndTag_spare1:
            printf("fill_sib_type: option not available\n");
            break;

        default:
            printf("\nfill_sib_type: No such option available\n");
            break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_scheduling_info_sib
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SchedulingInformationSIB
 *       to scheduling_information_sib_t 
 *
 *******************************************************************************/
void fill_scheduling_info_sib
(  
 UMTS_SchedulingInformationSIB  *asn_scheduling_info_sib,
 scheduling_information_sib_t   *umts_scheduling_info_sib
 )
{
    fill_sib_type( &(asn_scheduling_info_sib->sib_Type),
            &(umts_scheduling_info_sib->sib_Type));

    fill_scheduling_info( &(asn_scheduling_info_sib->scheduling),
            &(umts_scheduling_info_sib->scheduling));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sib_reference_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SIB_ReferenceList
 *       to sib_reference_list_t 
 *
 *******************************************************************************/
void convert_sib_reference_list
(
 UMTS_SIB_ReferenceList     *asn_sib_reference_list,
 sib_reference_list_t       *umts_sib_reference_list
 )
{
    OSRTDListNode                   *pnode  = NULL;
    UMTS_SchedulingInformationSIB   *pdata0 = NULL;
    U32                             index;

    umts_sib_reference_list->count = asn_sib_reference_list->count;
    pnode = asn_sib_reference_list->head;

    for (index=0; index<umts_sib_reference_list->count; index++)
    {
        pdata0 = (UMTS_SchedulingInformationSIB*)pnode->data;

        fill_scheduling_info_sib( 
                pdata0,
                &(umts_sib_reference_list->scheduling_informationi_sib[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sib_type_ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SIB_TypeExt
 *       to sib_type_ext_t 
 *
 *******************************************************************************/
void convert_sib_type_ext
(
 UMTS_SIB_TypeExt   *pvalue,
 sib_type_ext_t     *p_sib_type_ext 
 )
{
    p_sib_type_ext->t = pvalue->t;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_schedulingInformation_scheduling_sib_pos
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SchedulingInformation_scheduling_sib_Pos
 *       to schedulingInformation_scheduling_sib_pos_t 
 *
 *******************************************************************************/
void convert_schedulingInformation_scheduling_sib_pos
(
 UMTS_SchedulingInformation_scheduling_sib_Pos  *pvalue,
 schedulingInformation_scheduling_sib_pos_t     *p_sib_pos 
 )
{
    p_sib_pos->t = pvalue->t;

    if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep4)
    {
        p_sib_pos->u.rep4 = pvalue->u.rep4;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep8)
    {
        p_sib_pos->u.rep8 = pvalue->u.rep8;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep16)
    {
        p_sib_pos->u.rep16 = pvalue->u.rep16;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep32)
    {
        p_sib_pos->u.rep32 = pvalue->u.rep32;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep64)
    {
        p_sib_pos->u.rep64 = pvalue->u.rep64;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep128)
    {
        p_sib_pos->u.rep128 = pvalue->u.rep128;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep256)
    {
        p_sib_pos->u.rep256 = pvalue->u.rep256;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep512)
    {
        p_sib_pos->u.rep512 = pvalue->u.rep512;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep1024)
    {
        p_sib_pos->u.rep1024 = pvalue->u.rep1024;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep2048)
    {
        p_sib_pos->u.rep2048 = pvalue->u.rep2048;
    }
    else if (pvalue->t == T_UMTS_SchedulingInformation_scheduling_sib_Pos_rep4096)
    {
        p_sib_pos->u.rep4096 = pvalue->u.rep4096;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sib_off_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SibOFF_List
 *       to sib_off_list_t 
 *
 *******************************************************************************/
void convert_sib_off_list
(
 UMTS_SibOFF_List   *pvalue,
 sib_off_list_t     *p_sib_off_list 
 )
{
    p_sib_off_list->count = pvalue->n;

    memcpy(p_sib_off_list->sib_off_elem, 
            pvalue->elem,
            (sizeof(U32) * p_sib_off_list->count));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_scheduling_information_scheduling
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SchedulingInformation_scheduling
 *       to scheduling_information_scheduling_t 
 *
 *******************************************************************************/
void convert_scheduling_information_scheduling
(
 UMTS_SchedulingInformation_scheduling  *pvalue,
 scheduling_information_scheduling_t    *p_scheduling_information_scheduling 
 )
{
    p_scheduling_information_scheduling->seg_count = pvalue->segCount;

    convert_schedulingInformation_scheduling_sib_pos(
            &pvalue->sib_Pos,
            &p_scheduling_information_scheduling->sib_Pos);

    if (pvalue->m.sib_PosOffsetInfoPresent)
    {
        p_scheduling_information_scheduling->presence_bitmask |=
            UMTS_SCHEDULING_INFO_SIB_OFF_LIST_PRESENCE_FLAG;

        convert_sib_off_list(
                &pvalue->sib_PosOffsetInfo,
                &p_scheduling_information_scheduling->sib_pos_offset_info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_scheduling_info
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SchedulingInformation
 *       to scheduling_info_t 
 *
 *******************************************************************************/
void convert_scheduling_info
(
 UMTS_SchedulingInformation     *pvalue,
 scheduling_info_t              *p_scheduling_info 
 )
{
    convert_scheduling_information_scheduling(
            &pvalue->scheduling,
            &p_scheduling_info->scheduling);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sib_occurrence_identity_value_tag
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SIBOccurrenceIdentityAndValueTag
 *       to sib_occurrence_identity_value_tag_t 
 *
 *******************************************************************************/
void convert_sib_occurrence_identity_value_tag
(
 UMTS_SIBOccurrenceIdentityAndValueTag      *pvalue,
 sib_occurrence_identity_value_tag_t        *p_sib_occurrence_identity_value_tag
 )
{
    p_sib_occurrence_identity_value_tag->sib_occur_identity =
        pvalue->sibOccurIdentity;

    p_sib_occurrence_identity_value_tag->sib_occur_value_tag =
        pvalue->sibOccurValueTag;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_value_tag_info
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ValueTagInfo
 *       to value_tag_info_t 
 *
 *******************************************************************************/
void convert_value_tag_info
(
 UMTS_ValueTagInfo  *pvalue,
 value_tag_info_t   *p_value_tag_info 
 )
{
    p_value_tag_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_ValueTagInfo_none)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_ValueTagInfo_cellValueTag)
    {
        p_value_tag_info->u.cell_value_tag = pvalue->u.cellValueTag;
    }
    else if (pvalue->t == T_UMTS_ValueTagInfo_plmn_ValueTag)
    {
        p_value_tag_info->u.plmn_value_tag = pvalue->u.plmn_ValueTag;
    }
    else if (pvalue->t == T_UMTS_ValueTagInfo_sIBOccurrenceIdentityAndValueTag)
    {
        convert_sib_occurrence_identity_value_tag(
                pvalue->u.sIBOccurrenceIdentityAndValueTag,
                &(p_value_tag_info->u.sib_occurrence_identity_value_tag));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ext_sib_type_info_scheduling_info_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ExtSIBTypeInfoSchedulingInfo_List
 *       to ext_sib_type_info_scheduling_info_list_t 
 *
 *******************************************************************************/
void convert_ext_sib_type_info_scheduling_info_list
(
 UMTS_ExtSIBTypeInfoSchedulingInfo_List     *pvalue,
 ext_sib_type_info_scheduling_info_list_t   *p_ext_sib_type_info_scheduling_info_list 
 )
{
    UMTS_ExtSIBTypeInfoSchedulingInfo   *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_ext_sib_type_info_scheduling_info_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ExtSIBTypeInfoSchedulingInfo*)pnode->data;

        convert_sib_type_ext(
                &pdata->extensionSIB_Type,
                &p_ext_sib_type_info_scheduling_info_list->ext_sib_type_info_scheduling_info[index].extension_sib_type);

        convert_scheduling_info(
                &pdata->schedulingInfo,
                &p_ext_sib_type_info_scheduling_info_list->ext_sib_type_info_scheduling_info[index].scheduling_info);

        convert_value_tag_info(
                &pdata->valueTagInfo,
                &p_ext_sib_type_info_scheduling_info_list->ext_sib_type_info_scheduling_info[index].value_tag_info);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb1_v6b0_ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB1_v6b0ext
 *       to sysinfotypesb1_v6b0_ext_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb1_v6b0_ext
(
 UMTS_SysInfoTypeSB1_v6b0ext    *pvalue,
 sysinfotypesb1_v6b0_ext_t      *p_sysinfotypesb1_v6b0_ext 
 )
{
    if (pvalue->m.extSIBTypeInfoSchedulingInfo_ListPresent)
    {
        p_sysinfotypesb1_v6b0_ext->presence_bitmask |=
            UMTS_SB1_EXT_SIB_TYPE_INFO_SCHEDULING_INFO_LIST_PRESENCE_FLAG;

        convert_ext_sib_type_info_scheduling_info_list(
                &pvalue->extSIBTypeInfoSchedulingInfo_List,
                &p_sysinfotypesb1_v6b0_ext->ext_sib_type_info_scheduling_info_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sib_type_ext2
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SIB_TypeExt2
 *       to sib_type_ext2_t 
 *
 *******************************************************************************/
void convert_sib_type_ext2
(
 UMTS_SIB_TypeExt2      *pvalue,
 sib_type_ext2_t        *p_sib_type_ext2 
 )
{
    p_sib_type_ext2->t = pvalue->t;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_scheduling_information
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SchedulingInformation
 *       to scheduling_information_t 
 *
 *******************************************************************************/
void convert_scheduling_information
(
 UMTS_SchedulingInformation     *pvalue,
 scheduling_information_t       *p_scheduling_information 
 )
{
    convert_scheduling_information_scheduling(
            &pvalue->scheduling,
            &p_scheduling_information->scheduling);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ext_sib_type_info_scheduling_info_list2
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ExtSIBTypeInfoSchedulingInfo_List2
 *       to ext_sib_type_info_scheduling_info_list2_t 
 *
 *******************************************************************************/
void convert_ext_sib_type_info_scheduling_info_list2
(
 UMTS_ExtSIBTypeInfoSchedulingInfo_List2    *pvalue,
 ext_sib_type_info_scheduling_info_list2_t  *p_list2 
 )
{
    UMTS_ExtSIBTypeInfoSchedulingInfo2  *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_list2->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ExtSIBTypeInfoSchedulingInfo2*)pnode->data;

        convert_sib_type_ext2(
                &pdata->extensionSIB_Type2,
                &p_list2->ext_sib_type_info_scheduling_info2[index].sib_type_ext2);

        convert_scheduling_information(
                &pdata->schedulingInfo,
                &p_list2->ext_sib_type_info_scheduling_info2[index].scheduling_information);

        convert_value_tag_info(
                &pdata->valueTagInfo,
                &p_list2->ext_sib_type_info_scheduling_info2[index].value_tag_info);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sib_type_ext_ganss
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SIB_TypeExtGANSS
 *       to sib_type_ext_ganss_t 
 *
 *******************************************************************************/
void convert_sib_type_ext_ganss
(
 UMTS_SIB_TypeExtGANSS  *pvalue,
 sib_type_ext_ganss_t   *p_sib_type_ext_ganss 
 )
{
    p_sib_type_ext_ganss->t = pvalue->t;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ext_ganss_sib_type_info_scheduling_info_ganss_scheduling
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ExtGANSS_SIBTypeInfoSchedulingInfo_ganssScheduling
 *       to ext_ganss_sib_type_info_scheduling_info_ganss_scheduling_t 
 *
 *******************************************************************************/
void convert_ext_ganss_sib_type_info_scheduling_info_ganss_scheduling
(
 UMTS_ExtGANSS_SIBTypeInfoSchedulingInfo_ganssScheduling    *pvalue,
 ext_ganss_sib_type_info_scheduling_info_ganss_scheduling_t *p_ganss_scheduling 
 )
{
    UMTS_ExtGANSS_SchedulingInfo    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_ganss_scheduling->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ExtGANSS_SchedulingInfo*)pnode->data;

        convert_sib_type_ext_ganss(
                &pdata->extensionGANSS_SIBType,
                &p_ganss_scheduling->ext_ganss_scheduling_info[index].sib_type_ext_ganss);

        convert_scheduling_information(
                &pdata->schedulingInfo,
                &p_ganss_scheduling->ext_ganss_scheduling_info[index].scheduling_information);

        convert_value_tag_info(
                &pdata->valueTagInfo,
                &p_ganss_scheduling->ext_ganss_scheduling_info[index].value_tag_info);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ext_ganss_sib_type_info_scheduling_info_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ExtGANSS_SIBTypeInfoSchedulingInfoList
 *       to ext_ganss_sib_type_info_scheduling_info_list_t 
 *
 *******************************************************************************/
void convert_ext_ganss_sib_type_info_scheduling_info_list
(
 UMTS_ExtGANSS_SIBTypeInfoSchedulingInfoList    *pvalue,
 ext_ganss_sib_type_info_scheduling_info_list_t *p_scheduling_info_list 
 )
{
    UMTS_ExtGANSS_SIBTypeInfoSchedulingInfo *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_scheduling_info_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ExtGANSS_SIBTypeInfoSchedulingInfo*)pnode->data;

        if (pdata->m.ganssIDPresent)
        {
            p_scheduling_info_list->ext_ganss_sib_type_info_scheduling_info[index].presence_bitmask |=
                UMTS_EXT_GANSS_SIB_TYPE_INFO_SCHEDULING_INFO_GANSS_ID_PRESENCE_FLAG;

            p_scheduling_info_list->ext_ganss_sib_type_info_scheduling_info[index].ganss_id = pdata->ganssID;
        }

        if (pdata->m.sbasIDPresent)
        {
            p_scheduling_info_list->ext_ganss_sib_type_info_scheduling_info[index].presence_bitmask |=
                UMTS_EXT_GANSS_SIB_TYPE_INFO_SCHEDULING_INFO_SBAS_ID_PRESENCE_FLAG;

            p_scheduling_info_list->ext_ganss_sib_type_info_scheduling_info[index].ue_positioning_ganss_sbas_id =
                pdata->sbasID;
        }

        convert_ext_ganss_sib_type_info_scheduling_info_ganss_scheduling(
                &pdata->ganssScheduling,
                &p_scheduling_info_list->ext_ganss_sib_type_info_scheduling_info[index].ganss_scheduling);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb1_v860_ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB1_v860ext
 *       to sysinfotypesb1_v860_ext_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb1_v860_ext
(
 UMTS_SysInfoTypeSB1_v860ext    *pvalue,
 sysinfotypesb1_v860_ext_t      *p_sysinfotypesb1_v860_ext 
 )
{
    if (pvalue->m.extSIBTypeInfoSchedulingInfo_ListPresent)
    {
        p_sysinfotypesb1_v860_ext->presence_bitmask |=
            UMTS_SB1_EXT_SIB_TYPE_INFO_SCHEDULING_INFO_LIST_PRESENCE_FLAG;

        convert_ext_sib_type_info_scheduling_info_list2(
                &pvalue->extSIBTypeInfoSchedulingInfo_List,
                &p_sysinfotypesb1_v860_ext->ext_sib_type_info_scheduling_info_list2);
    }

    if (pvalue->m.extGANSS_SIBTypeInfoSchedulingInfoListPresent)
    {
        p_sysinfotypesb1_v860_ext->presence_bitmask |=
            UMTS_SB1_EXT_GANSS_SIB_TYPE_INFO_SCHEDULING_INFO_LIST_PRESENCE_FLAG;

        convert_ext_ganss_sib_type_info_scheduling_info_list(
                &pvalue->extGANSS_SIBTypeInfoSchedulingInfoList,
                &p_sysinfotypesb1_v860_ext->ext_ganss_sib_type_info_scheduling_info_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions_nc_extensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB1_v6b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions
 *       to sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions_nc_extensions_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions_nc_extensions
(
 UMTS_SysInfoTypeSB1_v6b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions  *pvalue,
 sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions_nc_extensions_t                           *p_nc_extensions 
 )
{
    p_nc_extensions->__dummy__ = pvalue->__dummy__;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB1_v6b0NonCriticalExtensions_v860NonCriticalExtensions
 *       to sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions
(
 UMTS_SysInfoTypeSB1_v6b0NonCriticalExtensions_v860NonCriticalExtensions    *pvalue,
 sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions_t                     *p_nc_extensions
 )
{
    convert_sysinfotypesb1_v860_ext(
            &pvalue->sysInfoTypeSB1_v860ext,
            &p_nc_extensions->sysinfotypesb1_v860_ext);

    if (pvalue->m.nonCriticalExtensionsPresent)
    {
        p_nc_extensions->presence_bitmask |= UMTS_SB1_V6B0_V860_NCE_NCE_PRESENCE_FLAG;

        convert_sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions_nc_extensions(
                &pvalue->nonCriticalExtensions,
                &p_nc_extensions->nc_extensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb1_v6b0_nc_extensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB1_v6b0NonCriticalExtensions
 *       to sysinfotypesb1_v6b0_nc_extensions_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb1_v6b0_nc_extensions
(
 UMTS_SysInfoTypeSB1_v6b0NonCriticalExtensions      *pvalue,
 sysinfotypesb1_v6b0_nc_extensions_t                *p_nce 
 )
{
    convert_sysinfotypesb1_v6b0_ext(
            &pvalue->sysInfoTypeSB1_v6b0ext,
            &p_nce->sysinfotypesb1_v6b0_ext);

    if (pvalue->m.v860NonCriticalExtensionsPresent) 
    {
        p_nce->presence_bitmask |=
            UMTS_SB1_V6B0_V860_NCE_PRESENCE_FLAG;

        convert_sysinfotypesb1_v6b0_nc_extensions_v860_nc_extensions(
                &pvalue->v860NonCriticalExtensions,
                &p_nce->v860_nc_extensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_scheduling_block1
 *
 *   DESCRIPTION:
 *       This function decodes Scheduling Block 1
 *
 *   INPUT:
 *       umts_sb_1_info         - Pointer to decoded SB1
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code convert_scheduling_block1
(
 umts_scheduling_block_1_info_t *umts_sb_1_info
 )
{
    UMTS_SysInfoTypeSB1 asn_sb_1_info;
    OSCTXT   ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("convert_scheduling_block1:ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SB_BLOCK_1_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&asn_sb_1_info, 0, sizeof(UMTS_SysInfoTypeSB1));

    if ( 0 != (asn1PD_UMTS_SysInfoTypeSB1(&ctxt, &asn_sb_1_info)))
    {
        printf("asn1PD_UMTS_SysInfoTypeSB1:asn Decoding Failed\n");
        rtFreeContext(&ctxt);

        return FAILURE;
    }
    asn1Print_UMTS_SysInfoTypeSB1("Decoded SysInfoTypeSB1\n",&asn_sb_1_info);

    memset( umts_sb_1_info, 0 , sizeof(umts_scheduling_block_1_info_t));

    convert_sib_reference_list(
            &(asn_sb_1_info.sib_ReferenceList),
            &(umts_sb_1_info->sib_reference_list));

    if (asn_sb_1_info.m.v6b0NonCriticalExtensionsPresent == 1)
    {
        umts_sb_1_info->presence_bitmask |= UMTS_SB1_V6B0_NC_EXTN_PRESENCE_FLAG;

        convert_sysinfotypesb1_v6b0_nc_extensions(
                &asn_sb_1_info.v6b0NonCriticalExtensions,
                &umts_sb_1_info->v6b0_nc_extensions);
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb2_v6b0_ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB2_v6b0ext
 *       to sysinfotypesb2_v6b0_ext_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb2_v6b0_ext
(
 UMTS_SysInfoTypeSB2_v6b0ext    *pvalue,
 sysinfotypesb2_v6b0_ext_t      *p_sysinfotypesb2_v6b0_ext 
 )
{
    if (pvalue->m.extSIBTypeInfoSchedulingInfo_ListPresent)
    {
        p_sysinfotypesb2_v6b0_ext->presence_bitmask |=
            UMTS_SB2_EXT_SIB_TYPE_INFO_SCHEDULING_INFO_LIST_PRESENCE_FLAG;

        convert_ext_sib_type_info_scheduling_info_list(
                &pvalue->extSIBTypeInfoSchedulingInfo_List,
                &p_sysinfotypesb2_v6b0_ext->ext_sib_type_info_scheduling_info_list);
    }

    return;
}
/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb2_v860_ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB2_v860ext
 *       to sysinfotypesb2_v860_ext_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb2_v860_ext
(
 UMTS_SysInfoTypeSB2_v860ext    *pvalue,
 sysinfotypesb2_v860_ext_t      *p_sysinfotypesb2_v860_ext 
 )
{
    if (pvalue->m.extSIBTypeInfoSchedulingInfo_ListPresent)
    {
        p_sysinfotypesb2_v860_ext->presence_bitmask |=
            UMTS_SB2_EXT_SIB_TYPE_INFO_SCHEDULING_INFO_LIST2_PRESENCE_FLAG;

        convert_ext_sib_type_info_scheduling_info_list2(
                &pvalue->extSIBTypeInfoSchedulingInfo_List,
                &p_sysinfotypesb2_v860_ext->ext_sib_type_info_scheduling_info_list2);
    }

    if (pvalue->m.extGANSS_SIBTypeInfoSchedulingInfoListPresent)
    {
        p_sysinfotypesb2_v860_ext->presence_bitmask |=
            UMTS_SB2_EXT_GANSS_SIB_TYPE_INFO_SCHEDULING_INFO_LIST_PRESENCE_FLAG;

        convert_ext_ganss_sib_type_info_scheduling_info_list(
                &pvalue->extGANSS_SIBTypeInfoSchedulingInfoList,
                &p_sysinfotypesb2_v860_ext->ext_ganss_sib_type_info_scheduling_info_list); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions_nc_extensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB2_v6b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions
 *       to sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions_nc_extensions_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions_nc_extensions
(
 UMTS_SysInfoTypeSB2_v6b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions  *pvalue,
 sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions_nc_extensions_t                           *p_nc_extensions 
 )
{
    p_nc_extensions->__dummy__ = pvalue->__dummy__;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB2_v6b0NonCriticalExtensions_v860NonCriticalExtensions
 *       to sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions
(
 UMTS_SysInfoTypeSB2_v6b0NonCriticalExtensions_v860NonCriticalExtensions    *pvalue,
 sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions_t                     *p_nc_extensions 
 )
{
    convert_sysinfotypesb2_v860_ext(
            &pvalue->sysInfoTypeSB2_v860ext,
            &p_nc_extensions->sysinfotypesb2_v860_ext);

    if (pvalue->m.nonCriticalExtensionsPresent)
    {
        p_nc_extensions->presence_bitmask |=
            UMTS_SB2_V6B0_V860_NCE_NCE_PRESENCE_FLAG;

        convert_sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions_nc_extensions(
                &pvalue->nonCriticalExtensions,
                &p_nc_extensions->nc_extensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotypesb2_v6b0_nc_extensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoTypeSB2_v6b0NonCriticalExtensions
 *       to sysinfotypesb2_v6b0_nc_extensions_t 
 *
 *******************************************************************************/
void convert_sysinfotypesb2_v6b0_nc_extensions
(
 UMTS_SysInfoTypeSB2_v6b0NonCriticalExtensions      *pvalue,
 sysinfotypesb2_v6b0_nc_extensions_t                *p_sysinfotypesb2_v6b0_nc_extensions 
 )
{
    convert_sysinfotypesb2_v6b0_ext(
            &pvalue->sysInfoTypeSB2_v6b0ext,
            &p_sysinfotypesb2_v6b0_nc_extensions->sysinfotypesb2_v6b0_ext);

    if (pvalue->m.v860NonCriticalExtensionsPresent)
    {
        p_sysinfotypesb2_v6b0_nc_extensions->presence_bitmask |=
            UMTS_SB2_V6B0_V860_NCE_PRESENCE_FLAG;

        convert_sysinfotypesb2_v6b0_nc_extensions_v860_nc_extensions(
                &pvalue->v860NonCriticalExtensions,
                &p_sysinfotypesb2_v6b0_nc_extensions->v860_nc_extensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_scheduling_block2
 *
 *   DESCRIPTION:
 *       This function decodes Scheduling Block 2 

 *   INPUT:
 *       umts_sb_2_info         - Pointer to decoded SB2
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code convert_scheduling_block2
(
 umts_scheduling_block_2_info_t *umts_sb_2_info
 )
{
    UMTS_SysInfoTypeSB2 asn_sb_2_info;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SB_BLOCK_2_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&asn_sb_2_info, 0, sizeof(UMTS_SysInfoTypeSB2));

    if ( 0 != (asn1PD_UMTS_SysInfoTypeSB2(&ctxt, &asn_sb_2_info)))
    {
        printf("asn1PD_UMTS_SysInfoTypeSB1:asn Decoding Failed\n");

        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoTypeSB2("Decoded SysInfoTypeSB2\n", &asn_sb_2_info);

    memset(umts_sb_2_info, 0, sizeof(umts_scheduling_block_2_info_t));

    convert_sib_reference_list(
            &(asn_sb_2_info.sib_ReferenceList),
            &(umts_sb_2_info->sib_reference_list));

    if ( asn_sb_2_info.m.v6b0NonCriticalExtensionsPresent == 1)
    {
        umts_sb_2_info->presence_bitmask |= UMTS_SB2_V6B0_NC_EXTN_PRESENCE_FLAG;

        convert_sysinfotypesb2_v6b0_nc_extensions(
                &asn_sb_2_info.v6b0NonCriticalExtensions,
                &umts_sb_2_info->v6b0_nc_extensions);
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME:decode_explicit_discard
 *
 *   DESCRIPTION:
 *       This function converts UMTS_ExplicitDiscard
 *       to explicit_discard_t.
 *       
 *******************************************************************************/
void decode_explicit_discard
(
 UMTS_ExplicitDiscard         *asn_explicit_discard,
 explicit_discard_t      *umts_explicit_discard
 )
{
    umts_explicit_discard->timer_mrw = asn_explicit_discard->timerMRW ;
    umts_explicit_discard->timer_discard = asn_explicit_discard->timerDiscard ;
    umts_explicit_discard->max_mrw = asn_explicit_discard->maxMRW ;
}

/******************************************************************************
 *   FUNCTION NAME:decode_max_dat_retransmissions
 *
 *   DESCRIPTION:
 *       This function converts UMTS_MaxDAT_Retransmissions
 *       to max_dat_retransmissions_t.   
 *
 *
 *******************************************************************************/
void decode_max_dat_retransmissions
(
 UMTS_MaxDAT_Retransmissions      *asn_max_dat_retransmissions,
 max_dat_retransmissions_t   *umts_max_dat_retransmissions
 )
{
    umts_max_dat_retransmissions->max_dat = asn_max_dat_retransmissions->maxDAT;
    umts_max_dat_retransmissions->timer_mrw = asn_max_dat_retransmissions->timerMRW;
    umts_max_dat_retransmissions->max_mrw = asn_max_dat_retransmissions->maxMRW;
}

/******************************************************************************
 *   FUNCTION NAME: decode_transmission_rlc_discard
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TransmissionRLC_Discard 
 *       to transmission_rlc_discard_t.
 *
 *******************************************************************************/
void decode_transmission_rlc_discard
(
 UMTS_TransmissionRLC_Discard       *asn_transmission_rlc_discard,
 transmission_rlc_discard_t         *umts_transmission_rlc_discard
 )
{
    umts_transmission_rlc_discard->t = 
        asn_transmission_rlc_discard->t;

    switch( asn_transmission_rlc_discard->t)
    {
        case 1:
            {
                decode_explicit_discard (   
                        (asn_transmission_rlc_discard->u.timerBasedExplicit),
                        &(umts_transmission_rlc_discard->u.timer_based_explicit));
                break;
            }
        case 2:
            {
                umts_transmission_rlc_discard->u.timer_based_no_explicit = 
                    asn_transmission_rlc_discard->u.timerBasedNoExplicit;

                break;
            }
        case 3:
            {
                decode_max_dat_retransmissions( 
                        (asn_transmission_rlc_discard->u.maxDAT_Retransmissions),
                        &(umts_transmission_rlc_discard->u.max_dat_retransmissions));
                break;
            }
        case 4:
            {
                umts_transmission_rlc_discard->u.no_discard = 
                    asn_transmission_rlc_discard->u.noDiscard;
                break;
            }
        default:
            printf("\ndecode_transmission_rlc_discard:No such option available\n");
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME:decode_polling_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PollingInfo
 *       to polling_info_t.
 *
 *
 *******************************************************************************/
void decode_polling_info
(
 UMTS_PollingInfo           *asn_polling_info,
 polling_info_t             *umts_polling_info
 )
{
    if( asn_polling_info->m.timerPollProhibitPresent)
    {
        umts_polling_info->presence_bitmask |=
            UMTS_SIB_POLLING_INFO_TIMER_POLL_PROHIBIT_PRESENCE_FLAG;

        umts_polling_info->timer_poll_prohibit = 
            asn_polling_info->timerPollProhibit;
    }

    if( asn_polling_info->m.timerPollPresent)
    {
        umts_polling_info->presence_bitmask |=
            UMTS_SIB_POLLING_INFO_TIMER_POLL_PRESENCE_FLAG;

        umts_polling_info->timer_poll = 
            asn_polling_info->timerPoll;
    }

    if( asn_polling_info->m.poll_PDUPresent)
    {
        umts_polling_info->presence_bitmask |=
            UMTS_SIB_POLLING_INFO_POLL_PDU_PRESENCE_FLAG;

        umts_polling_info->poll_pdu = asn_polling_info->poll_PDU;
    }

    if( asn_polling_info->m.poll_SDUPresent)
    {
        umts_polling_info->presence_bitmask |=
            UMTS_SIB_POLLING_INFO_POLL_SDU_PRESENCE_FLAG;

        umts_polling_info->poll_sdu = asn_polling_info->poll_SDU;
    }

    umts_polling_info->last_transmission_pdu_poll= asn_polling_info->
        lastTransmissionPDU_Poll;

    umts_polling_info->last_retransmission_pdu_poll= asn_polling_info->
        lastRetransmissionPDU_Poll;

    if( asn_polling_info->m.pollWindowPresent)
    {
        umts_polling_info->presence_bitmask |=
            UMTS_SIB_POLLING_INFO_POLL_WINDOW_PRESENCE_FLAG;

        umts_polling_info->poll_window = asn_polling_info->pollWindow;
    }

    if( asn_polling_info->m.timerPollPeriodicPresent)
    {
        umts_polling_info->presence_bitmask |=
            UMTS_SIB_POLLING_INFO_TIMERPOLLPERIODIC_PRESENCE_FLAG;

        umts_polling_info->timerPollPeriodic = 
            asn_polling_info->timerPollPeriodic;
    }
    
    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_ul_am_rlc_mode
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_AM_RLC_Mode 
 *       to ul_am_rlc_mode_t.
 *      
 *
 *******************************************************************************/
void decode_ul_am_rlc_mode
(
 UMTS_UL_AM_RLC_Mode    *asn_ul_am_rlc_mode,
 ul_am_rlc_mode_t       *umts_ul_am_rlc_mode
 )
{
    decode_transmission_rlc_discard(   
            &(asn_ul_am_rlc_mode->transmissionRLC_Discard),
            &(umts_ul_am_rlc_mode->transmission_rlc_discard));

    umts_ul_am_rlc_mode->transmission_window_size = 
        asn_ul_am_rlc_mode->transmissionWindowSize;

    umts_ul_am_rlc_mode->timer_rst = asn_ul_am_rlc_mode->timerRST;

    umts_ul_am_rlc_mode->max_RST = asn_ul_am_rlc_mode->max_RST;

    if (asn_ul_am_rlc_mode->m.pollingInfoPresent)
    {
        umts_ul_am_rlc_mode->presence_bitmask |= 
            UMTS_SIB_UL_AM_RLC_MODE_POLLING_INFO_PRESENCE_FLAG;

        decode_polling_info( &(asn_ul_am_rlc_mode->pollingInfo),
                &(umts_ul_am_rlc_mode->polling_info));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_ul_um_rlc_mode
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_UM_RLC_Mode
 *       to ul_um_rlc_mode_t.
 *
 *******************************************************************************/
void decode_ul_um_rlc_mode
(
 UMTS_UL_UM_RLC_Mode   *asn_ul_um_rlc_mode,
 ul_um_rlc_mode_t      *umts_ul_um_rlc_mode
 )
{
    if( asn_ul_um_rlc_mode->m.transmissionRLC_DiscardPresent)
    {
        umts_ul_um_rlc_mode->presence_bitmask |=
            UMTS_SIB_UL_UM_RLC_MODE_TRANSMISSION_RLC_DISCARD_PRESENCE_FLAG;

        decode_transmission_rlc_discard(   
                &(asn_ul_um_rlc_mode->transmissionRLC_Discard),
                &(umts_ul_um_rlc_mode->transmission_rlc_discard));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_ul_tm_rlc_mode
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_TM_RLC_Mode 
 *       to ul_tm_rlc_mode_t.
 *
 *******************************************************************************/
void decode_ul_tm_rlc_mode
(
 UMTS_UL_TM_RLC_Mode   *asn_ul_tm_rlc_mode,
 ul_tm_rlc_mode_t      *umts_ul_tm_rlc_mode
 )
{
    if( asn_ul_tm_rlc_mode->m.transmissionRLC_DiscardPresent)
    {
        umts_ul_tm_rlc_mode->presence_bitmask |= 
            UMTS_SIB_UL_TM_RLC_MODE_TRANSMISSION_RLC_DISCARD_PRESENCE_FLAG;

        decode_transmission_rlc_discard(   
                &(asn_ul_tm_rlc_mode->transmissionRLC_Discard),
                &(umts_ul_tm_rlc_mode->transmission_rlc_discard));
    }

    umts_ul_tm_rlc_mode->segmentation_indication = 
        asn_ul_tm_rlc_mode->segmentationIndication;

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_ul_rlc_mode
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_RLC_Mode
 *       to ul_rlc_mode_t.
 *
 *******************************************************************************/
void decode_ul_rlc_mode
(
 UMTS_UL_RLC_Mode   *asn_ul_rlc_mode,
 ul_rlc_mode_t      *umts_ul_rlc_mode
 )
{
    umts_ul_rlc_mode->t = asn_ul_rlc_mode->t;

    switch(asn_ul_rlc_mode->t)
    {
        case 1:
            {
                decode_ul_am_rlc_mode( (asn_ul_rlc_mode->u.ul_AM_RLC_Mode),
                        &(umts_ul_rlc_mode->u.ul_am_rlc_mode));
                break;
            }
        case 2:
            {
                decode_ul_um_rlc_mode( (asn_ul_rlc_mode->u.ul_UM_RLC_Mode),
                        &(umts_ul_rlc_mode->u.ul_um_rlc_mode));
                break;
            }
        case 3:
            {
                decode_ul_tm_rlc_mode( (asn_ul_rlc_mode->u.ul_TM_RLC_Mode),
                        &(umts_ul_rlc_mode->u.ul_tm_rlc_mode));
                break;
            }
        default:printf("\ndecode_ul_rlc_mode:No such option available\n");
                break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_dl_rlc_status_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_DL_RLC_StatusInfo
 *       to dl_rlc_status_info_t.
 *
 *******************************************************************************/
void decode_dl_rlc_status_info
(
 UMTS_DL_RLC_StatusInfo    *asn_dl_rlc_status_info,
 dl_rlc_status_info_t      *umts_dl_rlc_status_info
 )
{
    umts_dl_rlc_status_info->missing_pdu_indicator = 
        asn_dl_rlc_status_info->missingPDU_Indicator;

    if( asn_dl_rlc_status_info->m.timerStatusProhibitPresent)
    {
        umts_dl_rlc_status_info->presence_bitmask |=
            UMTS_SIB_DL_RLC_STATUS_INFO_TIMER_STATUS_PROHIBIT_PRESENCE_FLAG;

        umts_dl_rlc_status_info->timer_status_prohibit = 
            asn_dl_rlc_status_info->timerStatusProhibit;
    }
    if( asn_dl_rlc_status_info->m.dummyPresent)
    {
        umts_dl_rlc_status_info->presence_bitmask |=
            UMTS_SIB_DL_RLC_STATUS_INFO_DUMMY_PRESENCE_FLAG;

        umts_dl_rlc_status_info->dummy = 
            asn_dl_rlc_status_info->dummy;
    }
    if( asn_dl_rlc_status_info->m.timerStatusPeriodicPresent)
    {
        umts_dl_rlc_status_info->presence_bitmask |=
            UMTS_SIB_DL_RLC_STATUS_INFO_TIMER_STATUS_PERIODIC_PRESENCE_FLAG;

        umts_dl_rlc_status_info->timer_status_periodic = 
            asn_dl_rlc_status_info->timerStatusPeriodic;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_dl_am_rlc_mode
 *
 *   DESCRIPTION:
 *       This function converts UMTS_DL_AM_RLC_Mode
 *       to dl_am_rlc_mode_t.
 *
 *******************************************************************************/
void decode_dl_am_rlc_mode
(
 UMTS_DL_AM_RLC_Mode     *asn_dl_am_rlc_mode,
 dl_am_rlc_mode_t   *umts_dl_am_rlc_mode
 )
{
    umts_dl_am_rlc_mode->in_sequence_delivery = 
        asn_dl_am_rlc_mode->inSequenceDelivery;
    umts_dl_am_rlc_mode->receiving_window_size = 
        asn_dl_am_rlc_mode->receivingWindowSize;
    decode_dl_rlc_status_info( &(asn_dl_am_rlc_mode->dl_RLC_StatusInfo),
            &(umts_dl_am_rlc_mode->dl_rlc_status_info));
}

/******************************************************************************
 *   FUNCTION NAME:decode_dl_tm_rlc_mode
 *
 *   DESCRIPTION:
 *       This function converts UMTS_DL_TM_RLC_Mode 
 *       to dl_tm_rlc_mode_t.
 *
 *******************************************************************************/
void decode_dl_tm_rlc_mode
(
 UMTS_DL_TM_RLC_Mode      *asn_dl_tm_rlc_mode,
 dl_tm_rlc_mode_t    *umts_dl_tm_rlc_mode
 )
{
    umts_dl_tm_rlc_mode->segmentation_indication = 
        asn_dl_tm_rlc_mode->segmentationIndication;
}
/******************************************************************************
 *   FUNCTION NAME:decode_dl_rlc_mode
 *
 *   DESCRIPTION:
 *       This function converts UMTS_DL_RLC_Mode 
 *       to dl_rlc_mode_t.
 *
 *******************************************************************************/
void decode_dl_rlc_mode
(
 UMTS_DL_RLC_Mode      *asn_dl_rlc_mode,   
 dl_rlc_mode_t         *umts_dl_rlc_mode
 )
{
    umts_dl_rlc_mode->t = asn_dl_rlc_mode->t;

    switch(asn_dl_rlc_mode->t)
    {
        case 1:
            {
                decode_dl_am_rlc_mode( (asn_dl_rlc_mode->u.dl_AM_RLC_Mode),
                        &(umts_dl_rlc_mode->u.dl_am_rlc_mode));
                break;
            }
        case 2:
            {
                decode_dl_tm_rlc_mode( (asn_dl_rlc_mode->u.dl_TM_RLC_Mode),
                        &(umts_dl_rlc_mode->u.dl_tm_rlc_mode));
                break;
            }
        default:printf("\ndecode_dl_rlc_mode:No such option available\n");
                break;
    }
}

/******************************************************************************
 *   FUNCTION NAME:decode_rlc_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_RLC_Info
 *       to rlc_info_t.
 *
 *******************************************************************************/
void decode_rlc_info
(
 UMTS_RLC_Info      *asn_rlc_Info,
 rlc_info_t         *umts_rlc_Info
 )
{
    if ( asn_rlc_Info->m.ul_RLC_ModePresent)
    {
        umts_rlc_Info->presence_bitmask |=
            UMTS_SIB_RLC_INFO_UL_RLC_MODE_PRESENCE_FLAG;

        decode_ul_rlc_mode ( &(asn_rlc_Info->ul_RLC_Mode),
                &(umts_rlc_Info->ul_rlc_mode));

    }
    if( asn_rlc_Info->m.dl_RLC_ModePresent)
    {
        umts_rlc_Info->presence_bitmask |=
            UMTS_SIB_RLC_INFO_DL_RLC_MODE_PRESENCE_FLAG;

        decode_dl_rlc_mode ( &(asn_rlc_Info->dl_RLC_Mode),
                &(umts_rlc_Info->dl_rlc_mode));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_rlc_info_choice
 *
 *   DESCRIPTION:
 *       This function converts UMTS_RLC_InfoChoice
 *       to rlc_info_choice_t.
 *      
 *******************************************************************************/
void decode_rlc_info_choice
(
 UMTS_RLC_InfoChoice   *asn_rlc_info_choice,
 rlc_info_choice_t     *umts_rlc_info_choice
 )
{
    umts_rlc_info_choice->t = asn_rlc_info_choice->t;

    switch(asn_rlc_info_choice->t)
    {
        case 1:
            {
                decode_rlc_info(    (asn_rlc_info_choice->u.rlc_Info),
                        &(umts_rlc_info_choice->u.rlc_Info));
                break;
            }
        case 2:
            {
                umts_rlc_info_choice->u.same_as_rb = 
                    asn_rlc_info_choice->u.same_as_RB;
                break;
            }
        default:
            printf("\ndecode_rlc_info_choice:No such option available\n");
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME:decode_ul_transport_channel_type
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_TransportChannelType  
 *       to ul_transport_channel_type_t.
 *
 *******************************************************************************/
void decode_ul_transport_channel_type
(
 UMTS_UL_TransportChannelType         *asn_ul_transport_channel_type,
 ul_transport_channel_type_t     *umts_ul_transport_channel_type
 )
{
    umts_ul_transport_channel_type->t = 
        asn_ul_transport_channel_type->t;

    switch( asn_ul_transport_channel_type->t)
    {
        case 1: 
            {
                umts_ul_transport_channel_type->u.dch = 
                    asn_ul_transport_channel_type->u.dch;
            }    
            break;
        case 2: 
            printf("decode_ul_transport_channel_type: Not used\n");
            break;
        case 3: 
            printf("decode_ul_transport_channel_type: Not used\n");
            break;
        case 4: 
            {
                umts_ul_transport_channel_type->u.usch = 
                    asn_ul_transport_channel_type->u.usch;
            }    
            break;
        default:
            printf("\ndecode_ul_transport_channel_type:No such option available\n");

            break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_rlc_size_explicit_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_RLC_SizeExplicitList 
 *       to rlc_size_explicit_list_t.
 *
 *******************************************************************************/
void fill_rlc_size_explicit_list
(
 UMTS_RLC_SizeExplicitList        *asn_explicit_list,
 rlc_size_explicit_list_t    *umts_explicit_list
 )
{
	OSRTDListNode               *pnode    = NULL;
	UMTS_RLC_SizeInfo                *pdata0   = NULL;
	U32                         index;

	umts_explicit_list->count = asn_explicit_list->count;
	pnode = asn_explicit_list->head;

	/* Coverity ID 80633 Fix Start */
	for ( index=0; ((index<umts_explicit_list->count) && (pnode != NULL)); index++)
		/* Coverity ID 80633 Fix Start */
	{
		pdata0 = (UMTS_RLC_SizeInfo*)pnode->data;

		umts_explicit_list->rlc_size_info[index].rlc_size_index = 
			pdata0->rlc_SizeIndex;
		/* Coverity ID 80633 Fix Start */
		pnode = pnode->next;
	}
	/* Coverity ID 80633 Fix End */
}

/******************************************************************************
 *   FUNCTION NAME:fill_ul_logical_channel_mapping_rlc_size_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_LogicalChannelMapping_rlc_SizeList 
 *       to ul_logical_channel_mapping_rlc_size_list_t.
 *
 *******************************************************************************/
void fill_ul_logical_channel_mapping_rlc_size_list
(
 UMTS_UL_LogicalChannelMapping_rlc_SizeList        *asn_rlc_size_list,
 ul_logical_channel_mapping_rlc_size_list_t        *umts_rlc_size_list
 )
{
    umts_rlc_size_list->t = asn_rlc_size_list->t;

    switch( asn_rlc_size_list->t)
    {
        case 1:
            printf("\nfill_ul_logical_channel_mapping_rlc_size_list: Option not used\n");
            break;
        case 2:
            printf("\nfill_ul_logical_channel_mapping_rlc_size_list: Option not used\n");
            break;
        case 3:
            {
                fill_rlc_size_explicit_list (
                        (asn_rlc_size_list->u.explicitList),
                        &(umts_rlc_size_list->u.explicit_list));
            }
            break;
        default:
            printf("\nfill_ul_logical_channel_mapping_rlc_size_list:No such option available\n");
            break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_one_ul_logical_channel_mapping
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_LogicalChannelMapping
 *       to ul_logical_channel_mapping_t.
 *
 *******************************************************************************/
void decode_one_ul_logical_channel_mapping
(
 UMTS_UL_LogicalChannelMapping         *asn_one_ul_logical_channel_mapping,
 ul_logical_channel_mapping_t     *umts_one_ul_logical_channel_mapping
 )
{
    decode_ul_transport_channel_type(  
            &(asn_one_ul_logical_channel_mapping-> ul_TransportChannelType),
            &(umts_one_ul_logical_channel_mapping-> ul_transport_channel_type));

    if (asn_one_ul_logical_channel_mapping->m.logicalChannelIdentityPresent)
    {
        umts_one_ul_logical_channel_mapping->presence_bitmask |=
            UMTS_SIB_UL_LOGICAL_CHANNEL_MAPPING_LOGICALCHANNELIDENTITY_PRESENCE_FLAG;

        umts_one_ul_logical_channel_mapping->logicalChannelIdentity = 
            asn_one_ul_logical_channel_mapping->logicalChannelIdentity;
    }

    fill_ul_logical_channel_mapping_rlc_size_list(  
            &(asn_one_ul_logical_channel_mapping-> rlc_SizeList),
            &(umts_one_ul_logical_channel_mapping-> rlc_size_list));

    umts_one_ul_logical_channel_mapping->mac_LogicalChannelPriority =
        asn_one_ul_logical_channel_mapping->mac_LogicalChannelPriority;

    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_ul_logicalchannelmappinglist_ul_logicalchannelmapping
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_LogicalChannelMappingList_ul_LogicalChannelMapping 
 *       to ul_logicalchannelmappinglist_ul_logicalchannelmapping_t.
 *
 *******************************************************************************/
void fill_ul_logicalchannelmappinglist_ul_logicalchannelmapping
(
 UMTS_UL_LogicalChannelMappingList_ul_LogicalChannelMapping   *asn_mapping_list,
 ul_logicalchannelmappinglist_ul_logicalchannelmapping_t *umts_mapping_list
 )
{
    OSRTDListNode               *pnode    = NULL;
    UMTS_UL_LogicalChannelMapping    *pdata0    = NULL;
    U32                         index;

    umts_mapping_list->count = asn_mapping_list->count;
    pnode = asn_mapping_list->head;

    for ( index=0; index<umts_mapping_list->count; index++)
    {
        pdata0 = (UMTS_UL_LogicalChannelMapping*)pnode->data;

        decode_one_ul_logical_channel_mapping( pdata0,
                &(umts_mapping_list->ul_logical_channel_mapping[index]));

        pnode = pnode->next;
    }
    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_ul_logical_channel_mapping_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_LogicalChannelMappingList
 *       to ul_logical_channel_mapping_list_t.
 *
 *******************************************************************************/
void fill_ul_logical_channel_mapping_list
(
 UMTS_UL_LogicalChannelMappingList        *asn_ul_logical_channel_mapping_list,
 ul_logical_channel_mapping_list_t   *umts_ul_logical_channel_mapping_list
 )
{
    umts_ul_logical_channel_mapping_list->rlc_logical_channel_mapping_indicator= 
        asn_ul_logical_channel_mapping_list->rlc_LogicalChannelMappingIndicator;
    fill_ul_logicalchannelmappinglist_ul_logicalchannelmapping( 
            &(asn_ul_logical_channel_mapping_list->ul_LogicalChannelMapping),
            &(umts_ul_logical_channel_mapping_list->ul_logical_channel_mapping));
}

/******************************************************************************
 *   FUNCTION NAME:decode_ul_logical_channel_mappings_s
 *
 *   DESCRIPTION:
 *       This function converts UMTS_UL_LogicalChannelMappings 
 *       to ul_logical_channel_mappings_t.
 *
 *******************************************************************************/
void decode_ul_logical_channel_mappings_s
(
 UMTS_UL_LogicalChannelMappings       *asn_ul_logical_channel_mappings,
 ul_logical_channel_mappings_t   *umts_ul_logical_channel_mappings
 )
{
    umts_ul_logical_channel_mappings->t = 
        asn_ul_logical_channel_mappings->t;

    switch(asn_ul_logical_channel_mappings->t)
    {
        case 1:
            {
                decode_one_ul_logical_channel_mapping(  
                        (asn_ul_logical_channel_mappings->u.oneLogicalChannel),
                        &(umts_ul_logical_channel_mappings->
                            u.one_logical_channel));
                break;
            }
        case 2:
            {
                fill_ul_logical_channel_mapping_list( 
                        (asn_ul_logical_channel_mappings->u.twoLogicalChannels),
                        &(umts_ul_logical_channel_mappings->
                            u.two_logical_channels));
                break;
            }
        default:
            printf("\ndecode_ul_logical_channel_mappings_s:No such option available\n");

            break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_dl_transport_channel_type
 *
 *   DESCRIPTION:
 *       This function converts UMTS_DL_TransportChannelType
 *       to dl_transport_channel_type_t.
 *
 *******************************************************************************/
void decode_dl_transport_channel_type
(
 UMTS_DL_TransportChannelType         *asn_dl_transport_channel_type,
 dl_transport_channel_type_t     *umts_dl_transport_channel_type
 )
{
    umts_dl_transport_channel_type->t = 
        asn_dl_transport_channel_type->t;

    switch( asn_dl_transport_channel_type->t)
    {
        case 1:
            {
                umts_dl_transport_channel_type->u.dch = 
                    asn_dl_transport_channel_type->u.dch;
            }
            break;
        case 2:
            printf("\ndecode_dl_transport_channel_type: Option not used\n");
            break;
        case 3:
            {
                umts_dl_transport_channel_type->u.dsch = 
                    asn_dl_transport_channel_type->u.dsch;
            }
            break;
        case 4:
            {
                umts_dl_transport_channel_type->u.dch_and_dsch.
                    dch_transport_ch_id = 
                    asn_dl_transport_channel_type->
                    u.dch_and_dsch->dch_transport_ch_id;

                umts_dl_transport_channel_type->u.dch_and_dsch.
                    dsch_transport_ch_id = 
                    asn_dl_transport_channel_type->
                    u.dch_and_dsch->dsch_transport_ch_id;
            }
            break;
        default:
            printf("\ndecode_dl_transport_channel_type:No such option available\n");

            break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_dl_logical_channel_mapping
 *
 *   DESCRIPTION:
 *       This function converts UMTS_DL_LogicalChannelMapping 
 *       to dl_logical_channel_mapping_t.
 *
 *******************************************************************************/
void decode_dl_logical_channel_mapping
(
 UMTS_DL_LogicalChannelMapping        *asn_dl_logical_channel_mapping,
 dl_logical_channel_mapping_t    *umts_dl_logical_channel_mapping
 )
{
    if ( asn_dl_logical_channel_mapping->m.logicalChannelIdentityPresent)
    {
        umts_dl_logical_channel_mapping->presence_bitmask |=
            UMTS_SIB_DL_LOGICAL_CHANNEL_MAPPING_LOGICAL_CHANNEL_IDENTITY_PRESENCE_FLAG;

        umts_dl_logical_channel_mapping->logical_channel_identity = 
            asn_dl_logical_channel_mapping->logicalChannelIdentity;
    }

    decode_dl_transport_channel_type( 
            &(asn_dl_logical_channel_mapping->dl_TransportChannelType),
            &(umts_dl_logical_channel_mapping->dl_transport_channel_type));

    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_dl_logical_channel_mappings
 *
 *   DESCRIPTION:
 *       This function converts UMTS_DL_LogicalChannelMappingList 
 *       to dl_logical_channel_mapping_list_t.
 *
 *******************************************************************************/
void fill_dl_logical_channel_mappings
(
 UMTS_DL_LogicalChannelMappingList        *asn_dl_logical_channel_mapping_list,
 dl_logical_channel_mapping_list_t   *umts_dl_logical_channel_mapping_list
 )
{
	OSRTDListNode               *pnode    = NULL;
	UMTS_DL_LogicalChannelMapping    *pdata0    = NULL;
	U32                         index;

	umts_dl_logical_channel_mapping_list->count = 
		asn_dl_logical_channel_mapping_list->count;
	pnode = asn_dl_logical_channel_mapping_list->head;

	/* Coverity ID 79544 Fix Start */
	for ( index=0; ((index<umts_dl_logical_channel_mapping_list->count) && (pnode != NULL)); index++)
		/* Coverity ID 79544 Fix Start */
	{
		pdata0 = (UMTS_DL_LogicalChannelMapping*)pnode->data;
		decode_dl_logical_channel_mapping( pdata0,
				&(umts_dl_logical_channel_mapping_list->
					dl_logical_channel_mapping[index]));
		/* Coverity ID 79544 Fix Start */
		pnode = pnode->next;
	}
	/* Coverity ID 79544 Fix End */
}

/******************************************************************************
 *   FUNCTION NAME:decode_rb_mapping_option
 *
 *   DESCRIPTION:
 *       This function converts UMTS_RB_MappingOption 
 *       to rb_mapping_option_t.
 *
 *******************************************************************************/
void decode_rb_mapping_option
(
 UMTS_RB_MappingOption      *asn_rb_mapping_option,
 rb_mapping_option_t        *umts_rb_mapping_option
 )
{
    if ( asn_rb_mapping_option->m.ul_LogicalChannelMappingsPresent)
    {
        umts_rb_mapping_option->presence_bitmask |=
            UMTS_SIB_RB_MAPPING_OPTION_UL_LOGICAL_CHANNEL_MAPPINGS_PRESENCE_FLAG;

        decode_ul_logical_channel_mappings_s (   
                &(asn_rb_mapping_option->ul_LogicalChannelMappings),
                &(umts_rb_mapping_option->ul_logical_channel_mappings));
    }
    if ( asn_rb_mapping_option->m.dl_LogicalChannelMappingListPresent)
    {
        umts_rb_mapping_option->presence_bitmask |=
            UMTS_SIB_RB_MAPPING_OPTION_DL_LOGICAL_CHANNEL_MAPPING_LIST_PRESENCE_FLAG;

        fill_dl_logical_channel_mappings(
                &(asn_rb_mapping_option->dl_LogicalChannelMappingList),
                &(umts_rb_mapping_option->dl_logical_channel_mapping_list));
    }
}

/******************************************************************************
 *   FUNCTION NAME:fill_rb_mapping_info_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_RB_MappingInfo
 *       to rb_mapping_info_list_t.
 *
 *******************************************************************************/
void fill_rb_mapping_info_list
(  
 UMTS_RB_MappingInfo              *asn_rb_mapping_info_list,
 rb_mapping_info_list_t      *umts_rb_mapping_info_list
 )
{
	OSRTDListNode               *pnode    = NULL;
	UMTS_RB_MappingOption            *pdata0    = NULL;
	U32                         index;

	umts_rb_mapping_info_list->count = asn_rb_mapping_info_list->count;
	pnode = asn_rb_mapping_info_list->head;

	/* Coverity ID 81148 Fix Start */
	for ( index=0; ((index<umts_rb_mapping_info_list->count) && (pnode !=NULL)); index++)
		/* Coverity ID 81148 Fix Start */
	{
		pdata0 = (UMTS_RB_MappingOption*)pnode->data;

		decode_rb_mapping_option( pdata0,
				&(umts_rb_mapping_info_list->rb_mapping_option[index]));
		/* Coverity ID 81148 Fix Start */
		pnode = pnode->next;
	}
	/* Coverity ID 81148 Fix End */
}

/******************************************************************************
 *   FUNCTION NAME:decode_srb_information_setup
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SRB_InformationSetup 
 *       to srb_information_setup_t.
 *
 *******************************************************************************/
void decode_srb_information_setup
(
 UMTS_SRB_InformationSetup         *asn_srb_info_setup,
 srb_information_setup_t           *umts_srb_info_setup
 )
{
    if(asn_srb_info_setup->m.rb_IdentityPresent == 1)
    {
        umts_srb_info_setup->presence_bitmask |=
            UMTS_SIB_SRB_INFORMATION_SETUP_RB_IDENTITY_PRESENCE_FLAG;

        umts_srb_info_setup->rb_identity = asn_srb_info_setup->rb_Identity;
    }

    decode_rlc_info_choice( 
            &(asn_srb_info_setup->rlc_InfoChoice),
            &(umts_srb_info_setup->rlc_info_choice));
    fill_rb_mapping_info_list(  
            &(asn_srb_info_setup->rb_MappingInfo),
            &(umts_srb_info_setup->rb_mapping_info_list));

    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_srb_information_setup_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SRB_InformationSetupList
 *       to srb_information_setup_list_t.
 *
 *******************************************************************************/
void fill_srb_information_setup_list
(
 UMTS_SRB_InformationSetupList        *asn_srb_info_setup_list,
 srb_information_setup_list_t    *umts_srb_info_setup_list
 )
{
	OSRTDListNode               *pnode    = NULL;
	UMTS_SRB_InformationSetup        *pdata0    = NULL;
	U32                         index;

	umts_srb_info_setup_list->count = asn_srb_info_setup_list->count;
	pnode = asn_srb_info_setup_list->head;

	/* Coverity ID 80765 Fix Start */
	for ( index=0; ((index<umts_srb_info_setup_list->count) && (pnode != NULL)); index++)
		/* Coverity ID 80765 Fix Start */
	{
		pdata0 = (UMTS_SRB_InformationSetup*)pnode->data;
		decode_srb_information_setup( pdata0,
				&(umts_srb_info_setup_list->srb_information_setup[index]));
		/* Coverity ID 80765 Fix Start */
		pnode = pnode->next;
	}
	/* Coverity ID 80765 Fix End */
}

/******************************************************************************
 *   FUNCTION NAME:decode_lossless_srns_reloc_support
 *
 *   DESCRIPTION:
 *       This function converts UMTS_LosslessSRNS_RelocSupport 
 *       to lossless_srns_reloc_support_t.
 *
 *******************************************************************************/
void decode_lossless_srns_reloc_support
(
 UMTS_LosslessSRNS_RelocSupport    *asn_lossless_srns_reloc_support,
 lossless_srns_reloc_support_t     *umts_lossless_srns_reloc_support
 )
{
    umts_lossless_srns_reloc_support->t = 
        asn_lossless_srns_reloc_support->t;

    switch (asn_lossless_srns_reloc_support->t)
    {
        case 1:
            {
                umts_lossless_srns_reloc_support->u.supported =
                    asn_lossless_srns_reloc_support->u.supported;
            }
            break;
        default:
            printf("decode_lossless_srns_reloc_support:no such option available\n"); 
            break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_rfc2507_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_RFC2507_Info 
 *       to rfc2507_info_t.
 *
 *******************************************************************************/
void decode_rfc2507_info
(
 UMTS_RFC2507_Info        *asn_rfc2507_info,
 rfc2507_info_t      *umts_rfc2507_info
 )
{
    umts_rfc2507_info->f_MAX_PERIOD = asn_rfc2507_info->f_MAX_PERIOD;
    umts_rfc2507_info->f_MAX_TIME = asn_rfc2507_info->f_MAX_TIME;
    umts_rfc2507_info->max_HEADER = asn_rfc2507_info->max_HEADER;
    umts_rfc2507_info->tcp_SPACE = asn_rfc2507_info->tcp_SPACE;
    umts_rfc2507_info->non_TCP_SPACE = asn_rfc2507_info->non_TCP_SPACE;
    umts_rfc2507_info->expect_reordering = asn_rfc2507_info->expectReordering;
}

/******************************************************************************
 *   FUNCTION NAME:decode_algorithm_specific_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_AlgorithmSpecificInfo
 *       to algorithm_specific_info_t.
 *
 *******************************************************************************/
void decode_algorithm_specific_info
(
 UMTS_AlgorithmSpecificInfo       *asn_algorithm_specific_info,
 algorithm_specific_info_t   *umts_algorithm_specific_info
 )
{
    umts_algorithm_specific_info->t = 
        asn_algorithm_specific_info->t;

    switch(asn_algorithm_specific_info->t)
    {
        case 1:
            {
                decode_rfc2507_info( 
                        (asn_algorithm_specific_info->u.rfc2507_Info),
                        &(umts_algorithm_specific_info->u.rfc2507_info));
            }
            break;
        default:
            printf("decode_algorithm_specific_info:No such option available\n");
            break;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_header_compression_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_HeaderCompressionInfo 
 *       to header_compression_info_t.
 *
 *******************************************************************************/
void decode_header_compression_info
(
 UMTS_HeaderCompressionInfo       *asn_header_compression_info,
 header_compression_info_t   *umts_header_compression_info
 )
{
    decode_algorithm_specific_info ( 
            &(asn_header_compression_info->algorithmSpecificInfo),
            &(umts_header_compression_info->algorithm_specific_info));
}
/******************************************************************************
 *   FUNCTION NAME:decode_header_compression_info_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_HeaderCompressionInfoList
 *       to header_compression_info_list_t.
 *
 *******************************************************************************/
void decode_header_compression_info_list
(
 UMTS_HeaderCompressionInfoList           *asn_header_compression_info_list,
 header_compression_info_list_t      *umts_header_compression_info_list
 )
{
	OSRTDListNode               *pnode    = NULL;
	UMTS_HeaderCompressionInfo       *pdata0    = NULL;
	U32                         index;

	umts_header_compression_info_list->count = 
		asn_header_compression_info_list->count;
	pnode = asn_header_compression_info_list->head;

	/* Coverity ID 81117 Fix Start */
	for ( index=0; ((index<umts_header_compression_info_list->count) && (pnode != NULL)); index++)
		/* Coverity ID 81117 Fix Start */
	{
		pdata0 = (UMTS_HeaderCompressionInfo*)pnode->data;
		decode_header_compression_info( pdata0,
				&(umts_header_compression_info_list->
					header_compression_info[index]));
		/* Coverity ID 81117 Fix Start */
		pnode = pnode->next;
	}
	/* Coverity ID 81117 Fix End */
}

/******************************************************************************
 *   FUNCTION NAME:decode_pdcp_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PDCP_Info 
 *       to pdcp_info_t.
 *
 *******************************************************************************/
void decode_pdcp_info
(
 UMTS_PDCP_Info     *asn_pdcp_info,
 pdcp_info_t        *umts_pdcp_info
 )
{
    if ( asn_pdcp_info->m.losslessSRNS_RelocSupportPresent)
    {
        umts_pdcp_info->presence_bitmask |=
            UMTS_SIB_PDCP_INFO_LOSSLESS_SRNS_RELOC_SUPPORT_PRESENCE_FLAG;

        decode_lossless_srns_reloc_support ( 
                &(asn_pdcp_info->losslessSRNS_RelocSupport),
                &(umts_pdcp_info->lossless_srns_reloc_support));                        
    }

    umts_pdcp_info->pdcp_pdu_header = asn_pdcp_info->pdcp_PDU_Header;

    if ( asn_pdcp_info->m.headerCompressionInfoListPresent)
    {
        umts_pdcp_info->presence_bitmask |=
            UMTS_SIB_PDCP_INFO_HEADER_COMPRESSION_INFO_LIST_PRESENCE_FLAG;

        decode_header_compression_info_list(
                &(asn_pdcp_info->headerCompressionInfoList),
                &(umts_pdcp_info->header_compression_info_list));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:decode_rb_information_setup
 *
 *   DESCRIPTION:
 *       This function converts UMTS_RB_InformationSetup 
 *       to rb_information_setup_t.
 *
 *******************************************************************************/
void decode_rb_information_setup
(
 UMTS_RB_InformationSetup      *asn_rb_info_setup,
 rb_information_setup_t        *umts_rb_info_setup
 )
{
    if(asn_rb_info_setup->m.pdcp_InfoPresent == 1)
    {
        umts_rb_info_setup->presence_bitmask |= 
            UMTS_SIB_RB_INFORMATION_SETUP_PDCP_INFO_PRESENCE_FLAG;

        decode_pdcp_info( &(asn_rb_info_setup->pdcp_Info),
                &(umts_rb_info_setup->pdcp_info));
    }
    umts_rb_info_setup->rb_identity = asn_rb_info_setup->rb_Identity;

    decode_rlc_info_choice( &(asn_rb_info_setup->rlc_InfoChoice),
            &(umts_rb_info_setup->rlc_info_choice));

    fill_rb_mapping_info_list(  &(asn_rb_info_setup->rb_MappingInfo),
            &(umts_rb_info_setup->rb_mapping));

    return;
}

/******************************************************************************
 *   FUNCTION NAME:fill_rb_information_setup_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_RB_InformationSetupList 
 *       to rb_information_setup_list_t.
 *
 *******************************************************************************/
void fill_rb_information_setup_list
(  
 UMTS_RB_InformationSetupList         *asn_rb_information_setup_list,
 rb_information_setup_list_t     *umts_rb_information_setup_list
 )
{
	OSRTDListNode               *pnode    = NULL;
	UMTS_RB_InformationSetup         *pdata0    = NULL;
	U32                         index;

	umts_rb_information_setup_list->count = 
		asn_rb_information_setup_list->count;
	pnode = asn_rb_information_setup_list->head;

	/* Coverity ID 79971 Fix Start */
	for ( index=0; ((index<umts_rb_information_setup_list->count) && (pnode != NULL)); index++)
		/* Coverity ID 79971 Fix Start */
	{
		pdata0 = (UMTS_RB_InformationSetup*)pnode->data;
		decode_rb_information_setup( pdata0,
				&(umts_rb_information_setup_list->
					rb_information_setup[index]));
		/* Coverity ID 79971 Fix Start */
		pnode = pnode->next;
	}
	/* Coverity ID 79971 Fix End */
}

/******************************************************************************
 *   FUNCTION NAME:decode_predefined_rb_configuration
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PredefinedRB_Configuration 
 *       to predefined_rb_configuration_t.
 *
 *******************************************************************************/
void decode_predefined_rb_configuration 
(  
 UMTS_PredefinedRB_Configuration      *asn_predefined_rb_configuration,
 predefined_rb_configuration_t   *umts_predefined_rb_configuration
 )
{
    umts_predefined_rb_configuration->re_establishment_timer = 
        asn_predefined_rb_configuration->re_EstablishmentTimer;
    fill_srb_information_setup_list( 
            &(asn_predefined_rb_configuration->srb_InformationList),
            &(umts_predefined_rb_configuration->srb_information_setup_list));

    fill_rb_information_setup_list( 
            &(asn_predefined_rb_configuration->rb_InformationList),
            &(umts_predefined_rb_configuration->rb_information_setup_list));
}
/******************************************************************************
 *   FUNCTION NAME:decode_pre_def_radio_configuration
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PreDefRadioConfiguration
 *       to pre_def_radio_configuration_t.
 *
 *******************************************************************************/
void decode_pre_def_radio_configuration
(  
 UMTS_PreDefRadioConfiguration        *asn_pre_def_radio_configuration,
 pre_def_radio_configuration_t   *umts_pre_def_radio_configuration
 )
{
    decode_predefined_rb_configuration( 
            &(asn_pre_def_radio_configuration->predefinedRB_Configuration),
            &(umts_pre_def_radio_configuration->predefined_rb_configuration));

    /* -support left in thie release
       decode_predef_trans_ch_configuration( 
       &(asn_pre_def_radio_configuration->preDefTransChConfiguration),
       &(umts_pre_def_radio_configuration->predef_trans_ch_configuration));

       decode_pre_def_phy_ch_configuration( 
       &(asn_pre_def_radio_configuration->preDefPhyChConfiguration),
       &(umts_pre_def_radio_configuration->pre_def_phy_ch_configuration));
       */
}

/******************************************************************************
 *   FUNCTION NAME: convert_plmn_intra_freq_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMNsOfIntraFreqCellsList to
 *       plmns_of_intra_freq_cells_list_t 
 *
 *******************************************************************************/
void convert_plmn_intra_freq_list
(
 UMTS_PLMNsOfIntraFreqCellsList    *asn_plmn_intra_freq_list,
 plmns_of_intra_freq_cells_list_t  *plmn_intra_freq_list
 )
{
    OSRTDListNode                           *pnode = NULL;
    UMTS_PLMNsOfIntraFreqCellsList_element  *pdata0 = NULL;
    U32                                     index;

    plmn_intra_freq_list->count = asn_plmn_intra_freq_list->count;
    pnode = asn_plmn_intra_freq_list->head;

    for( index=0; index<plmn_intra_freq_list->count; index++)
    {
        pdata0 = (UMTS_PLMNsOfIntraFreqCellsList_element*)pnode->data;

        if( pdata0->m.plmn_IdentityPresent == 1)
        {
            plmn_intra_freq_list->plmns_of_intra_freq_cells[index].presence_bitmask |=
                UMTS_SIB_TYPE_18_PLMN_IDENTITIES_INTRA_FREQ_CELLS_LIST_PLMN_ID_PRESENCE_FLAG;

            fill_plmn_identity(
                    &pdata0->plmn_Identity,
                    &plmn_intra_freq_list->plmns_of_intra_freq_cells[index].plmn_identity);
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_plmn_inter_freq_list 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMNsOfInterFreqCellsList to
 *       plmns_of_inter_freq_cells_list_t 
 *
 ******************************************************************************/
void convert_plmn_inter_freq_list
(
 UMTS_PLMNsOfInterFreqCellsList     *p_asn_plmn_inter_freq_list,
 plmns_of_inter_freq_cells_list_t   *p_plmn_inter_freq_list
 )
{
    OSRTDListNode                           *pnode = NULL;
    UMTS_PLMNsOfInterFreqCellsList_element  *pdata = NULL;
    U32                                     index;

    p_plmn_inter_freq_list->count = p_asn_plmn_inter_freq_list->count;
    pnode = p_asn_plmn_inter_freq_list->head;

    for (index=0; index < p_plmn_inter_freq_list->count; index++)
    {
        pdata = (UMTS_PLMNsOfInterFreqCellsList_element*)pnode->data;

        if( pdata->m.plmn_IdentityPresent == 1)
        {
            p_plmn_inter_freq_list->plmns_of_inter_freq_cells[index].presence_bitmask |=
                UMTS_SIB_TYPE_18_PLMN_IDENTITIES_INTER_FREQ_CELLS_LIST_PLMN_ID_PRESENCE_FLAG;

            fill_plmn_identity(
                    &pdata->plmn_Identity,
                    &p_plmn_inter_freq_list->plmns_of_inter_freq_cells[index].plmn_identity); 
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_plmn_inter_rat_list 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMNsOfInterRATCellsList to
 *       plmns_of_inter_rat_cells_list_t 
 *
 *******************************************************************************/
void convert_plmn_inter_rat_list
(
 UMTS_PLMNsOfInterRATCellsList     *p_asn_plmn_inter_rat_list,
 plmns_of_inter_rat_cells_list_t   *p_plmn_inter_rat_list
 )
{
    OSRTDListNode                           *pnode = NULL;
    UMTS_PLMNsOfInterRATCellsList_element   *pdata = NULL;
    U32                                     index;

    p_plmn_inter_rat_list->count = p_asn_plmn_inter_rat_list->count;
    pnode   =   p_asn_plmn_inter_rat_list->head;

    for (index = 0; index < p_plmn_inter_rat_list->count; index++)
    {
        pdata = (UMTS_PLMNsOfInterRATCellsList_element*)pnode->data;

        if (pdata->m.plmn_IdentityPresent == 1)
        {
            p_plmn_inter_rat_list->plmns_of_inter_rat_cells[index].presence_bitmask |=
                UMTS_SIB_TYPE_18_PLMN_IDENTITIES_INTER_RAT_CELLS_LIST_PLMN_ID_PRESENCE_FLAG;

            fill_plmn_identity(
                    &pdata->plmn_Identity,
                    &p_plmn_inter_rat_list->plmns_of_inter_rat_cells[index].plmn_identity);
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_nas_system_ansi_41_info
 *
 *   DESCRIPTION:
 *       This function converts UMTS_NAS_SystemInformationANSI_41 to
 *       nas_system_ansi_41_info_t 
 *
 *******************************************************************************/
void convert_nas_system_ansi_41_info
(
 UMTS_NAS_SystemInformationANSI_41  *pvalue,
 nas_system_ansi_41_info_t          *p_nas_system_ansi_41_info 
 )
{
    U32 index;

    p_nas_system_ansi_41_info->count = pvalue->numbits;

    for (index = 0; index < pvalue->numbits; index ++)
    {
        p_nas_system_ansi_41_info->data[index] = pvalue->data[index];
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_nas_system_gsm_map_info 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_NAS_SystemInformationGSM_MAP to
 *       nas_system_gsm_map_info_t 
 *       and checks whether input data are valid.
 *
 *******************************************************************************/
void convert_nas_system_gsm_map_info
(
 UMTS_NAS_SystemInformationGSM_MAP  *pvalue,
 nas_system_gsm_map_info_t          *p_nas_system_gsm_map_info 
 )
{
    U32 index;

    p_nas_system_gsm_map_info->count = pvalue->numocts;

    for (index = 0; index < pvalue->numocts; index ++)
    {
        p_nas_system_gsm_map_info->data[index] = pvalue->data[index];
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cn_domainsysinfo_cn_type
 *
 *   DESCRIPTION:
 *       This function converts UMTS_CN_DomainSysInfo_cn_Type to
 *       cn_domainsysinfo_cn_type_t 
 *
 *******************************************************************************/
void convert_cn_domainsysinfo_cn_type
(
 UMTS_CN_DomainSysInfo_cn_Type  *pvalue,
 cn_domainsysinfo_cn_type_t     *p_cn_domainsysinfo_cn_type 
 )
{
    p_cn_domainsysinfo_cn_type->t = pvalue->t;

    if (pvalue->t == T_UMTS_CN_DomainSysInfo_cn_Type_gsm_MAP)
    {
        convert_nas_system_gsm_map_info(
                pvalue->u.gsm_MAP,
                &p_cn_domainsysinfo_cn_type->u.nas_system_gsm_map_info); 
    }
    else if (pvalue->t == T_UMTS_CN_DomainSysInfo_cn_Type_ansi_41)
    {
        convert_nas_system_ansi_41_info(
                pvalue->u.ansi_41,
                &p_cn_domainsysinfo_cn_type->u.nas_system_ansi_41_info); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cn_domain_sysinfo_list
 *
 *   DESCRIPTION:
 *       This function converts CN_DomainSysInfoList to
 *      cn_domainsys_info_list_t 
 *
 *******************************************************************************/
void convert_cn_domain_sysinfo_list
(
 UMTS_CN_DomainSysInfoList  *asn_DomainSysInfoList,
 cn_domainsys_info_list_t   *cn_domainsys_info_list
 )
{
    OSRTDListNode           *pnode      = NULL;
    UMTS_CN_DomainSysInfo   *pdata0     = NULL;
    U32                     index;

    cn_domainsys_info_list->count = asn_DomainSysInfoList->count;
    pnode = asn_DomainSysInfoList->head;

    for(index=0; index<cn_domainsys_info_list->count; index++)
    {
        pdata0 = (UMTS_CN_DomainSysInfo*)pnode->data;

        cn_domainsys_info_list->cn_domainsys_info[index].cn_domain_identity = 
            pdata0->cn_DomainIdentity;

        convert_cn_domainsysinfo_cn_type(
                &pdata0->cn_Type,
                &cn_domainsys_info_list->cn_domainsys_info[index].cn_type);

        cn_domainsys_info_list->cn_domainsys_info[index].
            cn_drx_cyclelenghtcoefficient = pdata0->cn_DRX_CycleLengthCoeff;

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_mapping_function_parameter_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       MappingFunctionParameterList to
 *       mappingFunctionParameter_list_t
 *
 *******************************************************************************/
void convert_mapping_function_parameter_list 
(
 UMTS_MappingFunctionParameterList  *pvalue,
 mapping_function_parameter_list_t  *p_mappingFunction_Parameter_list
 )
{
    UMTS_MappingFunctionParameter   *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_mappingFunction_Parameter_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_MappingFunctionParameter*)pnode->data;

        p_mappingFunction_Parameter_list->mapping_function_parameter[index].mapping_function_type = 
            pdata->functionType;

        if ( pdata->m.mapParameter1Present )
        {
            p_mappingFunction_Parameter_list->mapping_function_parameter[index].presence_bitmask |=
                UMTS_SIB_TYPE_3_MAPPING_FUNCTION_PARAM_MAP_PARAM1_PRESENCE_FLAG; 

            p_mappingFunction_Parameter_list->mapping_function_parameter[index].map_parameter1 = 
                pdata->mapParameter1;
        }

        p_mappingFunction_Parameter_list->mapping_function_parameter[index].map_parameter2 = 
            pdata->mapParameter2;

        if ( pdata->m.upperLimitPresent )
        {
            p_mappingFunction_Parameter_list->mapping_function_parameter[index].presence_bitmask |=
                UMTS_SIB_TYPE_3_MAPPING_FUNCTION_PARAM_UPPER_LIMIT_PRESENCE_FLAG;

            p_mappingFunction_Parameter_list->mapping_function_parameter[index].upper_limit = 
                pdata->upperLimit;
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mapping_info
 *
 *   DESCRIPTION:
 *       This function converts MappingInfo to
 *      mappingInfo_list_t
 *       and checks whether input data are valid.
 *
 *******************************************************************************/
void convert_mapping_info
(
 UMTS_MappingInfo       *pvalue,
 mapping_info_t         *p_mapping_Info_list
 )
{
    UMTS_Mapping        *pdata  = NULL;
    OSRTDListNode       *pnode  = NULL;
    U32                 index;

    pnode = pvalue->head;
    p_mapping_Info_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_Mapping*)pnode->data;

        p_mapping_Info_list->mapping[index].rat = pdata->rat;

        convert_mapping_function_parameter_list(
                &(pdata->mappingFunctionParameterList), 
                &(p_mapping_Info_list->mapping[index].mapping_function_parameter_list));

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME:fill_sysinfotype1_v3a0_nce 
 *
 *   DESCRIPTION:
 *       This function converts CN_DomainSysInfoList to
 *      cn_domainsys_info_list_t 
 *       and checks whether input data are valid.
 *
 *******************************************************************************/
void fill_sysinfotype1_v3a0_nce
(
 UMTS_SysInfoType1_v3a0NonCriticalExtensions    *v3a0NonCriticalExtensions,
 sysinfotype1_v3a0_nce_t                        *sysinfotype1_v3a0_nce
 )
{
    memset (sysinfotype1_v3a0_nce, 0, sizeof(sysinfotype1_v3a0_nce_t));

    if ( v3a0NonCriticalExtensions->sysInfoType1_v3a0ext.ue_ConnTimersAndConstants_v3a0ext.m.n_312Present)
    {
        sysinfotype1_v3a0_nce->sysinfotype1_v3a0ext_ies.ue_conntimers_constants_v3a0ext.presence_bitmask |=
            UMTS_SIB_TYPE_1_UE_CONNTIMERS_CONST_V3A0EXT_N_312_PRESENCE_FLAG;

        sysinfotype1_v3a0_nce->sysinfotype1_v3a0ext_ies.ue_conntimers_constants_v3a0ext.n_312 = 
            v3a0NonCriticalExtensions->sysInfoType1_v3a0ext.ue_ConnTimersAndConstants_v3a0ext.n_312;
    }

    if ( v3a0NonCriticalExtensions->sysInfoType1_v3a0ext.ue_ConnTimersAndConstants_v3a0ext.m.n_315Present)
    {
        sysinfotype1_v3a0_nce->sysinfotype1_v3a0ext_ies.ue_conntimers_constants_v3a0ext.presence_bitmask |=
            UMTS_SIB_TYPE_1_UE_CONNTIMERS_CONST_V3A0EXT_N_315_PRESENCE_FLAG;

        sysinfotype1_v3a0_nce->sysinfotype1_v3a0ext_ies.ue_conntimers_constants_v3a0ext.n_315 = 
            v3a0NonCriticalExtensions->sysInfoType1_v3a0ext.ue_ConnTimersAndConstants_v3a0ext.n_315;
    }

    if (v3a0NonCriticalExtensions->sysInfoType1_v3a0ext.ue_IdleTimersAndConstants_v3a0ext.m.n_312Present)
    {
        sysinfotype1_v3a0_nce->sysinfotype1_v3a0ext_ies.ue_idletimers_constants_v3a0ext.presence_bitmask |=
            UMTS_SIB_TYPE_1_UE_IDLETIMERS_CONST_V3A0EXT_N_312_PRESENCE_FLAG;

        sysinfotype1_v3a0_nce->sysinfotype1_v3a0ext_ies.ue_idletimers_constants_v3a0ext.n_312 = 
            v3a0NonCriticalExtensions->sysInfoType1_v3a0ext.ue_IdleTimersAndConstants_v3a0ext.n_312;
    }

    if (v3a0NonCriticalExtensions->m.v860NonCriticalExtentionsPresent)
    {
        sysinfotype1_v3a0_nce->presence_bitmask |=
            UMTS_SIB_TYPE_1_SYSINFOTYPE1_V3A0_NCE_V860_NCE_PRESENCE_FLAG;

        if (v3a0NonCriticalExtensions->v860NonCriticalExtentions.sysInfoType1_v860ext.
                ue_ConnTimersAndConstants.m.t_323Present)
        {
            sysinfotype1_v3a0_nce->sysInfotype1_v3a0_nce_v860_nce.sysinfotype1_v860ext_ies.
                ue_conntimers_constants_v860ext.presence_bitmask |=
                UMTS_SIB_TYPE_1_UE_CONNTIMERS_CONST_V860EXT_T_323_PRESENCE_FLAG;

            sysinfotype1_v3a0_nce->sysInfotype1_v3a0_nce_v860_nce.sysinfotype1_v860ext_ies.
                ue_conntimers_constants_v860ext.t_323 = 
                v3a0NonCriticalExtensions->v860NonCriticalExtentions.sysInfoType1_v860ext.
                ue_ConnTimersAndConstants.t_323;
        }

        if ( v3a0NonCriticalExtensions->v860NonCriticalExtentions.m.nonCriticalExtensionsPresent)
        {
            sysinfotype1_v3a0_nce->sysInfotype1_v3a0_nce_v860_nce.presence_bitmask |=
                UMTS_SIB_TYPE_1_SYSINFOTYPE1_V3A0_NCE_V860_NCE_NCES_PRESENCE_FLAG;

            sysinfotype1_v3a0_nce->sysInfotype1_v3a0_nce_v860_nce.sysinfotype1_v3a0_nce_v860_nce_nces.__dummy__ = 
                v3a0NonCriticalExtensions->v860NonCriticalExtentions.nonCriticalExtensions.__dummy__;
        }
    }
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib16
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType16 to
 *       umts_sib_type_16_info_t and checks if input data are valid.
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib16
(
 OSCTXT                 *pctxt,
 UMTS_CompleteSIB *pcomplete_sib_segment,
 umts_sib_type_16_info_t  *umts_sib16
 )
{
    return_code   ret_val      = SUCCESS;

    if (pcomplete_sib_segment == NULL )
    {
        return FAILURE;
    }

    UMTS_SysInfoType16 *sys_info_type_16 = NULL;
    sys_info_type_16 = ((UMTS_SysInfoType16*)pcomplete_sib_segment->
            sib_Data_fixed.data);
    ret_val = (return_code )asn1PD_UMTS_SysInfoType16( pctxt, sys_info_type_16);

    memset( umts_sib16, 0 , sizeof(umts_sib_type_16_info_t));
    if ( sys_info_type_16->m.v770NonCriticalExtensionsPresent == 1)
    {
        /* Decoding left in thie release for following non 
           critical extension parameter
           SysInfoType16_v770NonCriticalExtensions v770NonCriticalExtensions;
           */
        umts_sib16->presence_bitmask |= UMTS_SIB_TYPE_16_NC_EXTN_PRESENCE_FLAG;
    }
    decode_pre_def_radio_configuration( 
            &(sys_info_type_16->preDefinedRadioConfiguration),
            &(umts_sib16->pre_def_radio_configuration));

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: convert_fach_measurement_occasion_info_inter_rat_meas_ind 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FACH_MeasurementOccasionInfo_inter_RAT_meas_ind to
 *       fach_measurement_occasion_info_inter_rat_meas_ind_t 
 *
 *******************************************************************************/
void convert_fach_measurement_occasion_info_inter_rat_meas_ind
(
 UMTS_FACH_MeasurementOccasionInfo_inter_RAT_meas_ind   *pvalue,
 fach_measurement_occasion_info_inter_rat_meas_ind_t    *p_inter_rat_meas_ind
 )
{
    memcpy(p_inter_rat_meas_ind, pvalue, 
            sizeof(fach_measurement_occasion_info_inter_rat_meas_ind_t));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_fach_measurement_occasion_info 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_FACH_MeasurementOccasionInfo to
 *       fach_measurement_occasion_info_t 
 *       and checks whether input data are valid.
 *
 *******************************************************************************/
void convert_fach_measurement_occasion_info
(
 UMTS_FACH_MeasurementOccasionInfo  *pvalue,
 fach_measurement_occasion_info_t   *p_fach_measurement_occasion_info
 )
{
    if (pvalue->m.fACH_meas_occasion_coeffPresent)
    {
        p_fach_measurement_occasion_info->presence_bitmask |=
            UMTS_SIB_TYPE_11_FACH_MEAS_OCCASION_INFO_MEAS_OCCASION_COEFF_PRESENCE_FLAG;

        p_fach_measurement_occasion_info->fach_meas_occasion_coeff =
            pvalue->fACH_meas_occasion_coeff; 
    }

    p_fach_measurement_occasion_info->inter_freq_fdd_meas_ind =
        pvalue->inter_freq_FDD_meas_ind;

    p_fach_measurement_occasion_info->inter_freq_tdd_meas_ind =
        pvalue->inter_freq_TDD_meas_ind;

    if (pvalue->m.inter_RAT_meas_indPresent)
    {
        p_fach_measurement_occasion_info->presence_bitmask |=
            UMTS_SIB_TYPE_11_FACH_MEAS_OCCASION_INFO_INTER_RAT_MEAS_IND_PRESENCE_FLAG;

        convert_fach_measurement_occasion_info_inter_rat_meas_ind(
                &pvalue->inter_RAT_meas_ind,
                &p_fach_measurement_occasion_info->inter_rat_meas_ind);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:  convert_measurement_control_sys_info_use_of_hcs
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_MeasurementControlSysInfo_use_of_HCS to 
 *       measurement_control_sys_info_use_of_hcs_t
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_use_of_hcs
(
 UMTS_MeasurementControlSysInfo_use_of_HCS  *pvalue,
 measurement_control_sys_info_use_of_hcs_t  *p_use_of_hcs
 )
{
    p_use_of_hcs->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used)
    {
        convert_measurement_control_sys_info_use_of_hcs_hcs_not_used(
                pvalue->u.hcs_not_used,
                &p_use_of_hcs->u.hcs_not_used); 
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used)
    {
        convert_measurement_control_sys_info_use_of_hcs_hcs_used(
                pvalue->u.hcs_used,
                &p_use_of_hcs->u.hcs_used);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_traffic_volume_measurement_object_list 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TrafficVolumeMeasurementObjectList to
 *       traffic_volume_measurement_object_list_t 
 *
 *******************************************************************************/
void convert_traffic_volume_measurement_object_list
(
 UMTS_TrafficVolumeMeasurementObjectList    *pvalue,
 traffic_volume_measurement_object_list_t   *p_traffic_volume_measurement_object_list_t
 )
{
    UMTS_UL_TrCH_Identity   *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_traffic_volume_measurement_object_list_t->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_UL_TrCH_Identity*)pnode->data;

        p_traffic_volume_measurement_object_list_t->ul_tr_ch_identity[index].t = 
            pdata->t;

        if (pdata->t == T_UMTS_UL_TrCH_Identity_dch)      
        {
            p_traffic_volume_measurement_object_list_t->ul_tr_ch_identity[index].u.dch =
                pdata->u.dch; 
        }
        else if (pdata->t == T_UMTS_UL_TrCH_Identity_rachorcpch)
        {
            /* for future use */
        }
        else if (pdata->t == T_UMTS_UL_TrCH_Identity_usch)
        {
            p_traffic_volume_measurement_object_list_t->ul_tr_ch_identity[index].u.usch =
                pdata->u.usch;
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_traffic_volume_meas_quantity 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TrafficVolumeMeasQuantity to
 *       traffic_volume_meas_quantity_t 
 *
 *******************************************************************************/
void convert_traffic_volume_meas_quantity
(
 UMTS_TrafficVolumeMeasQuantity *pvalue,
 traffic_volume_meas_quantity_t *p_traffic_volume_meas_quantity
 )
{
    p_traffic_volume_meas_quantity->t = pvalue->t;

    if (pvalue->t == T_UMTS_TrafficVolumeMeasQuantity_rlc_BufferPayload)
    {
        /* for future use */ 
    }
    else if(pvalue->t == T_UMTS_TrafficVolumeMeasQuantity_averageRLC_BufferPayload)
    {
        p_traffic_volume_meas_quantity->u.average_rlc_buffer_payload = 
            pvalue->u.averageRLC_BufferPayload;
    }
    else if(pvalue->t == T_UMTS_TrafficVolumeMeasQuantity_varianceOfRLC_BufferPayload)
    {
        p_traffic_volume_meas_quantity->u.variance_of_rlc_buffer_payload = 
            pvalue->u.varianceOfRLC_BufferPayload;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_traffic_volume_reporting_quantity 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TrafficVolumeReportingQuantity to
 *       traffic_volume_reporting_quantity_t 
 *
 *******************************************************************************/
void convert_traffic_volume_reporting_quantity
(
 UMTS_TrafficVolumeReportingQuantity    *pvalue,
 traffic_volume_reporting_quantity_t    *p_traffic_volume_reporting_quantity
 )
{
    p_traffic_volume_reporting_quantity->rlc_rb_buffer_payload =
        pvalue->rlc_RB_BufferPayload;

    p_traffic_volume_reporting_quantity->rlc_rb_buffer_payload_average = 
        pvalue->rlc_RB_BufferPayloadAverage;

    p_traffic_volume_reporting_quantity->rlc_rb_buffer_payload_variance = 
        pvalue->rlc_RB_BufferPayloadVariance;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ul_tr_ch_identity 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_UL_TrCH_Identity to
 *       ul_tr_ch_identity_t 
 *
 *******************************************************************************/
void convert_ul_tr_ch_identity
(
 UMTS_UL_TrCH_Identity  *pvalue,
 ul_tr_ch_identity_t    *p_ul_tr_ch_identity 
 )
{
    memcpy(p_ul_tr_ch_identity, pvalue, sizeof(ul_tr_ch_identity_t));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_traffic_volume_event_param 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TrafficVolumeEventParam to
 *       traffic_volume_event_param_t 
 *
 *******************************************************************************/
void convert_traffic_volume_event_param
(
 UMTS_TrafficVolumeEventParam   *pvalue,
 traffic_volume_event_param_t   *p_traffic_volume_event_param 
 )
{
    p_traffic_volume_event_param->event_id =
        pvalue->eventID;

    p_traffic_volume_event_param->reporting_threshold =
        pvalue->reportingThreshold;

    if (pvalue->m.timeToTriggerPresent)
    {
        p_traffic_volume_event_param->presence_bitmask |=
            UMTS_SIB_TRAFFIC_VOL_EVENT_PARAM_TIME_TO_TRIGGET_PRESENCE_FLAG;

        p_traffic_volume_event_param->time_to_trigger =
            pvalue->timeToTrigger;
    }

    if (pvalue->m.pendingTimeAfterTriggerPresent)
    {
        p_traffic_volume_event_param->presence_bitmask |=
            UMTS_SIB_TRAFFIC_VOL_EVENT_PARAM_PENDING_TIME_AFTER_TRIGGER_PRESENCE_FLAG;

        p_traffic_volume_event_param->pending_time_after_trigger =
            pvalue->pendingTimeAfterTrigger;
    }

    if (pvalue->m.tx_InterruptionAfterTriggerPresent)
    {
        p_traffic_volume_event_param->presence_bitmask |=
            UMTS_SIB_TRAFFIC_VOL_EVENT_PARAM_TX_INTERRUPT_AFTER_TRIGGER_PRESENCE_FLAG;

        p_traffic_volume_event_param->tx_interrupt_after_trigger =
            pvalue->tx_InterruptionAfterTrigger; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_trans_ch_criteria_event_specific_parameters 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TransChCriteria_eventSpecificParameters to
 *       trans_ch_criteria_event_specific_parameters_t 
 *
 *******************************************************************************/
void convert_trans_ch_criteria_event_specific_parameters
(
 UMTS_TransChCriteria_eventSpecificParameters   *pvalue,
 trans_ch_criteria_event_specific_parameters_t  *p_parameters 
 )
{
    UMTS_TrafficVolumeEventParam    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_parameters->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TrafficVolumeEventParam*)pnode->data;

        convert_traffic_volume_event_param(
                pdata,
                &p_parameters->traffic_volume_event_param[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_trans_ch_criteria 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TransChCriteria to
 *       trans_ch_criteria_t 
 *
 *******************************************************************************/
void convert_trans_ch_criteria
(
 UMTS_TransChCriteria   *pvalue,
 trans_ch_criteria_t    *p_trans_ch_criteria 
 )
{
    if (pvalue->m.ul_transportChannelIDPresent)
    {
        p_trans_ch_criteria->presence_bitmask |=
            UMTS_SIB_TRANS_CH_CRITERIA_UL_TR_CH_IDENTITY_PRESENCE_FLAG;

        convert_ul_tr_ch_identity(
                &pvalue->ul_transportChannelID,
                &p_trans_ch_criteria->ul_tr_ch_identity);
    }

    if (pvalue->m.eventSpecificParametersPresent)
    {
        p_trans_ch_criteria->presence_bitmask |=
            UMTS_SIB_TRANS_CH_CRITERIA_EVENT_SPECIFIC_PARAMS_PRESENCE_FLAG;

        convert_trans_ch_criteria_event_specific_parameters(
                &pvalue->eventSpecificParameters,
                &p_trans_ch_criteria->trans_ch_criteria_event_specific_parameters);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_trans_ch_criteria_list 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TransChCriteriaList to
 *       trans_ch_criteria_list_t 
 *
 *******************************************************************************/
void convert_trans_ch_criteria_list
(
 UMTS_TransChCriteriaList   *pvalue,
 trans_ch_criteria_list_t   *p_trans_ch_criteria_list 
 )
{
    UMTS_TransChCriteria    *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_trans_ch_criteria_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TransChCriteria*)pnode->data;

        convert_trans_ch_criteria(
                pdata,
                &p_trans_ch_criteria_list->trans_ch_criteria[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_traffic_volume_reporting_criteria 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TrafficVolumeReportingCriteria to
 *       traffic_volume_reporting_criteria_t 
 *
 *******************************************************************************/
void convert_traffic_volume_reporting_criteria 
(
 UMTS_TrafficVolumeReportingCriteria *pvalue,
 traffic_volume_reporting_criteria_t *p_traffic_volume_reporting_criteria
 )
{
    if(pvalue->m.transChCriteriaListPresent )
    {
        p_traffic_volume_reporting_criteria->presence_bitmask|=
            UMTS_SIB_TRAFFIC_VOL_REPORTING_CRITERIA_TRANS_CH_CRITERIA_LIST_PRESENCE_FLAG;

        convert_trans_ch_criteria_list(
                &pvalue->transChCriteriaList,
                &p_traffic_volume_reporting_criteria->trans_ch_criteria_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_validity 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementValidity to
 *       measurement_validity_t 
 *
 *******************************************************************************/
void convert_measurement_validity
(
 UMTS_MeasurementValidity   *pvalue,
 measurement_validity_t     *p_measurement_validity
 )
{
    p_measurement_validity->ue_state = pvalue->ue_State;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_reporting_mode 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementReportingMode to
 *       measurement_reporting_mode_t 
 *
 *******************************************************************************/
void convert_measurement_reporting_mode
(  
 UMTS_MeasurementReportingMode  *pvalue,
 measurement_reporting_mode_t   *p_measurement_reporting_mode
 )
{
    p_measurement_reporting_mode->measurement_report_transfer_mode = 
        pvalue->measurementReportTransferMode;

    p_measurement_reporting_mode->periodical_or_event_trigger = 
        pvalue->periodicalOrEventTrigger;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_periodical_reporting_criteria
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_PeriodicalReportingCriteria to 
 *       periodical_reporting_criteria_t
 *
 ******************************************************************************/
void convert_periodical_reporting_criteria
(
 UMTS_PeriodicalReportingCriteria   *pvalue,
 periodical_reporting_criteria_t    *p_periodical_reporting_criteria 
 )
{
    p_periodical_reporting_criteria->reporting_amount =
        pvalue->reportingAmount;

    p_periodical_reporting_criteria->reporting_interval =
        pvalue->reportingInterval;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_traffic_volume_report_criteria_sys_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TrafficVolumeReportCriteriaSysInfo to
 *       traffic_volume_report_criteria_sys_info_t 
 *
 *******************************************************************************/
void convert_traffic_volume_report_criteria_sys_info
( 
 UMTS_TrafficVolumeReportCriteriaSysInfo    *pvalue,
 traffic_volume_report_criteria_sys_info_t  *p_traffic_volume_report_criteria_sys_info
 )
{
    p_traffic_volume_report_criteria_sys_info->t =
        pvalue->t;

    if(pvalue->t == T_UMTS_TrafficVolumeReportCriteriaSysInfo_trafficVolumeReportingCriteria)
    {
        convert_traffic_volume_reporting_criteria(
                pvalue->u.trafficVolumeReportingCriteria,
                &p_traffic_volume_report_criteria_sys_info->u.traffic_volume_reporting_criteria);
    }
    else if(pvalue->t == T_UMTS_TrafficVolumeReportCriteriaSysInfo_periodicalReportingCriteria)
    {
        convert_periodical_reporting_criteria(
                pvalue->u.periodicalReportingCriteria,
                &p_traffic_volume_report_criteria_sys_info->u.periodical_reporting_criteria);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_traffic_vol_meas_sys_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TrafficVolumeMeasSysInfo to
 *       traffic_vol_meas_sys_info_t 
 *
 *******************************************************************************/
void  convert_traffic_vol_meas_sys_info
(
 UMTS_TrafficVolumeMeasSysInfo  *pvalue,
 traffic_vol_meas_sys_info_t    *p_traffic_vol_meas_sys_info
 )
{
    p_traffic_vol_meas_sys_info->traffic_vol_meas_id =
        pvalue->trafficVolumeMeasurementID;

    if( pvalue->m.trafficVolumeMeasurementObjectListPresent )
    {
        p_traffic_vol_meas_sys_info->presence_bitmask |=
            UMTS_SIB_TRAFFIC_VOL_MEAS_SYSINFO_MEAS_OBJ_LIST_PRESENCE_FLAG;

        convert_traffic_volume_measurement_object_list(
                &pvalue->trafficVolumeMeasurementObjectList,
                &p_traffic_vol_meas_sys_info->traffic_volume_measurement_object_list);
    }  

    if( pvalue->m.trafficVolumeMeasQuantityPresent )
    { 
        p_traffic_vol_meas_sys_info->presence_bitmask |=
            UMTS_SIB_TRAFFIC_VOL_MEAS_SYSINFO_MEAS_QTY_PRESENCE_FLAG ;

        convert_traffic_volume_meas_quantity(
                &pvalue->trafficVolumeMeasQuantity,
                &p_traffic_vol_meas_sys_info->traffic_volume_meas_quantity);
    }

    if( pvalue->m.trafficVolumeReportingQuantityPresent )
    {
        p_traffic_vol_meas_sys_info->presence_bitmask |=
            UMTS_SIB_TRAFFIC_VOL_MEAS_SYSINFO_REPORTING_QTY_PRESENCE_FLAG;

        convert_traffic_volume_reporting_quantity(
                &pvalue->trafficVolumeReportingQuantity,
                &p_traffic_vol_meas_sys_info->traffic_volume_reporting_quantity);
    }

    if( pvalue->m.dummyPresent)
    {
        p_traffic_vol_meas_sys_info->presence_bitmask |=
            UMTS_SIB_TRAFFIC_VOL_MEAS_SYSINFO_DUMMY_PRESENCE_FLAG;

        convert_traffic_volume_reporting_criteria(
                &pvalue->dummy,
                &p_traffic_vol_meas_sys_info->dummy);
    }

    if( pvalue->m.measurementValidityPresent)
    {
        p_traffic_vol_meas_sys_info->presence_bitmask |=
            UMTS_SIB_TRAFFIC_VOL_MEAS_SYSINFO_MEAS_VALIDITY_PRESENCE_FLAG;

        convert_measurement_validity(
                &pvalue->measurementValidity,
                &p_traffic_vol_meas_sys_info->measurement_validity);
    }

    convert_measurement_reporting_mode(  
            &pvalue-> measurementReportingMode,
            &p_traffic_vol_meas_sys_info->measurement_reporting_mode);

    convert_traffic_volume_report_criteria_sys_info( 
            &pvalue->reportCriteriaSysInf,
            &p_traffic_vol_meas_sys_info->traffic_volume_report_criteria_sys_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ue_internal_meas_quantity 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_UE_InternalMeasQuantity to
 *       ue_internal_meas_quantity_t 
 *
 *******************************************************************************/
void convert_ue_internal_meas_quantity
( 
 UMTS_UE_InternalMeasQuantity   *pvalue,
 ue_internal_meas_quantity_t    *ue_internal_meas_quantity
 )
{
    ue_internal_meas_quantity->ue_meas_quantity = pvalue->measurementQuantity;
    ue_internal_meas_quantity->filter_coefficient = pvalue->filterCoefficient;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ue_internal_meas_sys_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_UE_InternalMeasurementSysInfo to
 *       ue_internal_meas_sys_info_t 
 *
 *******************************************************************************/
void convert_ue_internal_meas_sys_info
( 
 UMTS_UE_InternalMeasurementSysInfo *pvalue,
 ue_internal_meas_sys_info_t        *p_ue_internal_meas_sys_info
 )
{
    p_ue_internal_meas_sys_info->ue_internal_meas_id = 
        pvalue->ue_InternalMeasurementID;

    convert_ue_internal_meas_quantity(
            &pvalue->ue_InternalMeasQuantity,
            &p_ue_internal_meas_sys_info->ue_internal_meas_quantity);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo to
 *       measurement_control_sys_info_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info
(
 UMTS_MeasurementControlSysInfo  *pvalue,
 measurement_control_sys_info_t  *p_measurement_control_sys_info
 )
{
    convert_measurement_control_sys_info_use_of_hcs(
            &pvalue->use_of_HCS,
            &p_measurement_control_sys_info->use_of_hcs);

    if (pvalue->m.trafficVolumeMeasSysInfoPresent)
    {
        p_measurement_control_sys_info->presence_bitmask |=
            UMTS_SIB_TYPE_11_MEAS_CTRL_SYSINFO_TRAFFIC_VOL_MEAS_SYSINFO_PRESENCE_FLAG;

        convert_traffic_vol_meas_sys_info(
                &pvalue->trafficVolumeMeasSysInfo,
                &p_measurement_control_sys_info->traffic_vol_meas_sys_info);
    }

    if (pvalue->m.dummyPresent)
    {
        p_measurement_control_sys_info->presence_bitmask |=
            UMTS_SIB_TYPE_11_MEAS_CTRL_SYSINFO_DUMMY_PRESENCE_FLAG;

        convert_ue_internal_meas_sys_info( 
                &pvalue->dummy,
                &p_measurement_control_sys_info->dummy);
    }

    return;
}

/* SIB 11 NCE  START*/

/******************************************************************************
 *   FUNCTION NAME: convert_removeSomeIntraFreqCells
 *
 *   DESCRIPTION:
 *       This function converts 
 *         UMTS_RemovedIntraFreqCellList_removeSomeIntraFreqCells
 *         to removedintrafreqcelllist_removesomeintrafreqcells_t
 *
 *******************************************************************************/
void convert_removeSomeIntraFreqCells
(
 UMTS_RemovedIntraFreqCellList_removeSomeIntraFreqCells *removeSomeIntraFreqCells,
 removedintrafreqcelllist_removesomeintrafreqcells_t *remove_someIntra_freq_cells
 )
{
    remove_someIntra_freq_cells->n = removeSomeIntraFreqCells->n;
    memcpy(remove_someIntra_freq_cells->elem, 
            removeSomeIntraFreqCells->elem, 
            remove_someIntra_freq_cells->n * sizeof(U8));
}

/******************************************************************************
 *   FUNCTION NAME: convert_RemovedIntraFreqCellListi
 *
 *   DESCRIPTION:
 *       This function converts 
 *      UMTS_RemovedIntraFreqCellList to removedintrafreqcelllist_t
 *******************************************************************************/
void convert_RemovedIntraFreqCellList
(
 UMTS_RemovedIntraFreqCellList *removedIntraFreqCellList,
 removedintrafreqcelllist_t *removed_intra_freq_cell_list
 )
{
    removed_intra_freq_cell_list->t = removedIntraFreqCellList->t;
    switch (removedIntraFreqCellList->t)
    {
        case RRC_UMTS_RemovedIntraFreqCellList_removeAllIntraFreqCells:
            break;
        case RRC_UMTS_RemovedIntraFreqCellList_removeSomeIntraFreqCells:
            convert_removeSomeIntraFreqCells(
                    removedIntraFreqCellList->u.removeSomeIntraFreqCells,
                    &removed_intra_freq_cell_list->u.remove_someIntra_freq_cells);
            break;
        case RRC_UMTS_RemovedIntraFreqCellList_removeNoIntraFreqCells:
            break;
        default:
            break;
    }
    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ReferenceTimeDifferenceToCell
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ReferenceTimeDifferenceToCell
 *       to referencetimedifferencetocell_t
 *
 *******************************************************************************/
void convert_ReferenceTimeDifferenceToCell
(
 UMTS_ReferenceTimeDifferenceToCell *referenceTimeDifferenceToCell,
 referencetimedifferencetocell_t *referencetime_differencetocell
 )
{
    referencetime_differencetocell->t = referenceTimeDifferenceToCell->t;
    switch(referenceTimeDifferenceToCell->t)
    {
        case RRC_UMTS_ReferenceTimeDifferenceToCell_accuracy40:
            referencetime_differencetocell->u.accuracy40 = 
                referenceTimeDifferenceToCell->u.accuracy40;
            break;
        case RRC_UMTS_ReferenceTimeDifferenceToCell_accuracy256:
            referencetime_differencetocell->u.accuracy256 = 
                referenceTimeDifferenceToCell->u.accuracy256;
            break;
        case RRC_UMTS_ReferenceTimeDifferenceToCell_accuracy2560:
            referencetime_differencetocell->u.accuracy2560 = 
                referenceTimeDifferenceToCell->u.accuracy2560;
            break;
        default:
            break;
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_PrimaryCCPCH_Info_LCR_r4
 *
 *   DESCRIPTION: convert_PrimaryCCPCH_Info_LCR_r4
 *       This function converts 
 *       UMTS_PrimaryCCPCH_Info_LCR_r4 to primaryccpch_info_lcr_r4_t
 *
 *******************************************************************************/
void convert_PrimaryCCPCH_Info_LCR_r4
(
 UMTS_PrimaryCCPCH_Info_LCR_r4 *primaryCCPCH_Info,
 primaryccpch_info_lcr_r4_t *primaryccpch_info
 )
{
    primaryccpch_info->presence_bitmask = 0;

    if(primaryCCPCH_Info->m.cellParametersIDPresent)
    {
        primaryccpch_info->presence_bitmask |= 
            UMTS_SIB_PRIMARYCCPCH_INFO_LCR_R4_CELLPARAMETERSID_PRESENCE_FLAG;

        primaryccpch_info->cellparameters_id = primaryCCPCH_Info->cellParametersID;
    }
    primaryccpch_info->tstd_Indicator = primaryCCPCH_Info->tstd_Indicator;
    primaryccpch_info->sctd_Indicator = primaryCCPCH_Info->sctd_Indicator;

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_TimeslotInfo_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TimeslotInfo_LCR_r4 to timeslotinfo_lcr_r4_t
 *
 *******************************************************************************/
void convert_TimeslotInfo_LCR_r4
(
 UMTS_TimeslotInfo_LCR_r4  *TimeslotInfo_LCR_r4,
 timeslotinfo_lcr_r4_t *timeslotinfo_lcr_r4
 )
{
    timeslotinfo_lcr_r4->timeslot_number =
        TimeslotInfo_LCR_r4->timeslotNumber;
}

/******************************************************************************
 *   FUNCTION NAME: convert_TimeslotInfoList_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TimeslotInfoList_LCR_r4
 *       to timeslotinfolist_lcr_r4_t
 *
 *******************************************************************************/
void convert_TimeslotInfoList_LCR_r4
(
 UMTS_TimeslotInfoList_LCR_r4 *timeslotInfoList,
 timeslotinfolist_lcr_r4_t *timeslotinfo_list
 )
{
    OSRTDListNode                       *pnode  = NULL;
    UMTS_TimeslotInfo_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    timeslotinfo_list->count = timeslotInfoList->count;
    pnode = timeslotInfoList->head;

    for (index=0; index<timeslotinfo_list->count; index++)
    {
        pdata0 = (UMTS_TimeslotInfo_LCR_r4*)pnode->data;

        convert_TimeslotInfo_LCR_r4(
                pdata0,
                &(timeslotinfo_list->timeslotinfo_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}



/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd
 *       cellselectreselectinfosib_11_12_rscp_modespecificinfo_fdd_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd *asn_fdd,
 cellselectreselectinfosib_11_12_rscp_modespecificinfo_fdd_t *umts_fdd
 )
{
    umts_fdd->presence_bitmask = 0;

    if (asn_fdd->m.q_QualMinPresent)
    {
        umts_fdd->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_RSCP_MODESPECIFICINFO_FDD_Q_QUALMIN_PRESENCE_FLAG;
        umts_fdd->q_QualMin = asn_fdd->q_QualMin;
    }
    if (asn_fdd->m.q_RxlevMinPresent)
    {
        umts_fdd->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_RSCP_MODESPECIFICINFO_FDD_Q_RXLEVMIN_PRESENCE_FLAG;
        umts_fdd->q_RxlevMin = asn_fdd->q_RxlevMin;
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *      UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd
 *      to cellselectreselectinfosib_11_12_rscp_modespecificinfo_tdd_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd *asn_tdd,
 cellselectreselectinfosib_11_12_rscp_modespecificinfo_tdd_t *umts_tdd
 )
{
    umts_tdd->presence_bitmask = 0;
    if (asn_tdd->m.q_RxlevMinPresent)
    {
        umts_tdd->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_RSCP_MODESPECIFICINFO_TDD_Q_RXLEVMIN_PRESENCE_FLAG;
        umts_tdd->q_rx_lev_min = asn_tdd->q_RxlevMin;
    }

}


/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm
 *       to cellselectreselectinfosib_11_12_rscp_modespecificinfo_gsm_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm *asn_gsm,
 cellselectreselectinfosib_11_12_rscp_modespecificinfo_gsm_t *umts_gsm
 )
{
    umts_gsm->presence_bitmask = 0;
    if (asn_gsm->m.q_RxlevMinPresent)
    {
        umts_gsm->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_RSCP_MODESPECIFICINFO_GSM_Q_RXLEVMIN_PRESENCE_FLAG;
        umts_gsm->q_RxlevMin = asn_gsm->q_RxlevMin;
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo
 *       to cellselectreselectinfosib_11_12_rscp_modespecificinfo_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo *modeSpecificInfo,
 cellselectreselectinfosib_11_12_rscp_modespecificinfo_t *mode_specific_info
 )
{
    mode_specific_info->t = modeSpecificInfo->t;
    switch(modeSpecificInfo->t)
    {
        case  RRC_UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd:

            convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd(
                    modeSpecificInfo->u.fdd, &mode_specific_info->u.fdd);
            break;
        case  RRC_UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd:

            convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd(
                    modeSpecificInfo->u.tdd, &mode_specific_info->u.tdd);
            break;
        case  RRC_UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm:

            convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm(
                    modeSpecificInfo->u.gsm, &mode_specific_info->u.gsm);
            break;
        default:
            break;
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_RSCP
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP
 *       to cellselectreselectinfosib_11_12_rscp_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_RSCP
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP *cellSelectionReselectionInfo,
 cellselectreselectinfosib_11_12_rscp_t *cellselection_reselection_info
 )
{
    cellselection_reselection_info->q_OffsetS_N =
        cellSelectionReselectionInfo->q_OffsetS_N;

    cellselection_reselection_info->presence_bitmask = 0;
    if (cellSelectionReselectionInfo->m.maxAllowedUL_TX_PowerPresent)
    {
        cellselection_reselection_info->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_RSCP_MAXALLOWEDUL_TX_POWER_PRESENCE_FLAG;
        cellselection_reselection_info->maxAllowedUL_TX_Power =
            cellSelectionReselectionInfo->maxAllowedUL_TX_Power;
    }

    convert_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo(
            &cellSelectionReselectionInfo->modeSpecificInfo,
            &cellselection_reselection_info->mode_specific_info);

}


/******************************************************************************
 *   FUNCTION NAME: convert_CellInfoSI_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_RSCP_LCR_r4
 *       to cellinfosi_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_CellInfoSI_RSCP_LCR_r4
(
 UMTS_CellInfoSI_RSCP_LCR_r4 *asn_cellInfo,
 cellinfosi_rscp_lcr_r4_t *umts_cell_info
 )
{
    umts_cell_info->cell_individual_offset = 
        asn_cellInfo->cellIndividualOffset;

    umts_cell_info->readsfn_indicator =
        asn_cellInfo->readSFN_Indicator;

    convert_PrimaryCCPCH_Info_LCR_r4(
            &asn_cellInfo->primaryCCPCH_Info,
            &umts_cell_info->primaryCCPCH_Info);

    umts_cell_info->presence_bitmask = 0;
    if (asn_cellInfo->m.referenceTimeDifferenceToCellPresent)
    {
        umts_cell_info->presence_bitmask |=
            UMTS_SIB_CELLINFOSI_RSCP_LCR_R4_REFERENCETIMEDIFFERENCETO_CELL_PRESENCE_FLAG;

        convert_ReferenceTimeDifferenceToCell(
                &asn_cellInfo->referenceTimeDifferenceToCell,
                &umts_cell_info->reference_time_difference_to_cell);
    }
    if (asn_cellInfo->m.primaryCCPCH_TX_PowerPresent)
    {
        umts_cell_info->presence_bitmask |=
            UMTS_SIB_CELLINFOSI_RSCP_LCR_R4_PRIMARYCCPCH_TX_POWER_PRESENCE_FLAG;

        umts_cell_info->primaryccpch_tx_power =
            asn_cellInfo->primaryCCPCH_TX_Power;
    }
    if (asn_cellInfo->m.timeslotInfoListPresent)
    {
        umts_cell_info->presence_bitmask |=
            UMTS_SIB_CELLINFOSI_RSCP_LCR_R4_TIMESLOTINFOLIST_PRESENCE_FLAG;
        convert_TimeslotInfoList_LCR_r4(
                &asn_cellInfo->timeslotInfoList,
                &umts_cell_info->timeslotinfo_list);
    }
    if (asn_cellInfo->m.cellSelectionReselectionInfoPresent)
    {
        umts_cell_info->presence_bitmask |=
            UMTS_SIB_CELLINFOSI_RSCP_LCR_R4_CELLSELECTIONRESELECTIONINFO_PRESENCE_FLAG;
        convert_CellSelectReselectInfoSIB_11_12_RSCP(
                &asn_cellInfo->cellSelectionReselectionInfo,
                &umts_cell_info->cellselection_reselection_info);
    }

}

/******************************************************************************
 *   FUNCTION NAME: convert_NewIntraFreqCellSI_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_RSCP_LCR_r4
 *       to newintrafreqcellsi_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewIntraFreqCellSI_RSCP_LCR_r4(
        UMTS_NewIntraFreqCellSI_RSCP_LCR_r4 *NewIntraFreqCellSI_HCS_RSCP_LCR_r4,
        newintrafreqcellsi_rscp_lcr_r4_t *newintrafreqcellsi_rscp_lcr_r4)
{

    newintrafreqcellsi_rscp_lcr_r4->presence_bitmask = 0;
    if (NewIntraFreqCellSI_HCS_RSCP_LCR_r4->m.intraFreqCellIDPresent)
    {
        newintrafreqcellsi_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTRAFREQCELLSI_RSCP_LCR_R4_INTRAFREQCELL_ID_PRESENCE_FLAG;
        newintrafreqcellsi_rscp_lcr_r4->intra_freq_cell_id =
            NewIntraFreqCellSI_HCS_RSCP_LCR_r4->intraFreqCellID;
        convert_CellInfoSI_RSCP_LCR_r4(
                &NewIntraFreqCellSI_HCS_RSCP_LCR_r4->cellInfo,
                &newintrafreqcellsi_rscp_lcr_r4->cell_info);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_NewIntraFreqCellSI_List_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_RSCP_LCR_r4
 *       to newintrafreqcellsi_list_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewIntraFreqCellSI_List_RSCP_LCR_r4(
        UMTS_NewIntraFreqCellSI_List_RSCP_LCR_r4 *newIntraFreqCellList,
        newintrafreqcellsi_list_rscp_lcr_r4_t	*newintra_freq_cell_list)
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewIntraFreqCellSI_RSCP_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    newintra_freq_cell_list->count = newIntraFreqCellList->count;
    pnode = newIntraFreqCellList->head;

    for (index=0; index<newintra_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewIntraFreqCellSI_RSCP_LCR_r4*)pnode->data;

        convert_NewIntraFreqCellSI_RSCP_LCR_r4(
                pdata0,
                &(newintra_freq_cell_list->newintrafreqcellsi_rscp_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqCellInfoSI_List_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqCellInfoSI_List_RSCP_LCR_r4
 *       to intrafreqcellinfosi_list_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqCellInfoSI_List_RSCP_LCR_r4
(
 UMTS_IntraFreqCellInfoSI_List_RSCP_LCR_r4 *intraFreqCellInfoSI_List,
 intrafreqcellinfosi_list_rscp_lcr_r4_t	*intra_freq_cellinfosi_list
 )
{

    intra_freq_cellinfosi_list->presence_bitmask = 0;
    if (intraFreqCellInfoSI_List->m.removedIntraFreqCellListPresent)
    {
        intra_freq_cellinfosi_list->presence_bitmask |= 
            UMTS_SIB_INTRAFREQCELLINFOSI_LIST_RSCP_LCR_R4_REMOVEDINTRAFREQCELLLIST_PRESENCE_FLAG;

        convert_RemovedIntraFreqCellList(
                &intraFreqCellInfoSI_List->removedIntraFreqCellList,
                &intra_freq_cellinfosi_list->removed_intra_freq_cell_list);
    }
    convert_NewIntraFreqCellSI_List_RSCP_LCR_r4(
            &intraFreqCellInfoSI_List->newIntraFreqCellList,
            &intra_freq_cellinfosi_list->newintra_freq_cell_list);

}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqMeasQuantity_modeSpecificInfo_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasQuantity_modeSpecificInfo_fdd
 *       to intrafreqmeasquantity_modespecificinfo_fdd_t
 *
 *******************************************************************************/
void convert_IntraFreqMeasQuantity_modeSpecificInfo_fdd
(
 UMTS_IntraFreqMeasQuantity_modeSpecificInfo_fdd *asn_fdd,
 intrafreqmeasquantity_modespecificinfo_fdd_t *umts_fdd
 )
{
    umts_fdd->intra_freq_meas_quantity_fdd = 
        asn_fdd->intraFreqMeasQuantity_FDD;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intraFreqMeasQuantity_TDDList
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasQuantity_TDDList to
 *       intrafreqmeasquantity_tddlist_t
 *
 *******************************************************************************/
void convert_intraFreqMeasQuantity_TDDList
(
 UMTS_IntraFreqMeasQuantity_TDDList *intraFreqMeasQuantity_TDDList,
 intrafreqmeasquantity_tddlist_t  *intra_freq_meas_quantity_tddlist
 )
{
    intra_freq_meas_quantity_tddlist->n = intraFreqMeasQuantity_TDDList->n;
    memcpy( intra_freq_meas_quantity_tddlist->elem, 
            intraFreqMeasQuantity_TDDList->elem, 
            intra_freq_meas_quantity_tddlist->n * sizeof(U32));

}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqMeasQuantity_modeSpecificInfo_tdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasQuantity_modeSpecificInfo_tdd
 *       intrafreqmeasquantity_modespecificinfo_tdd_t
 *
 *******************************************************************************/
void convert_IntraFreqMeasQuantity_modeSpecificInfo_tdd
(
 UMTS_IntraFreqMeasQuantity_modeSpecificInfo_tdd *asn_tdd,
 intrafreqmeasquantity_modespecificinfo_tdd_t *umts_tdd
 )
{
    convert_intraFreqMeasQuantity_TDDList(
            &asn_tdd->intraFreqMeasQuantity_TDDList,
            &umts_tdd->intra_freq_meas_quantity_tddlist);
}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqMeasQuantity_modeSpecificInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasQuantity_modeSpecificInfo
 *       to intrafreqmeasquantity_modespecificinfo_t
 *
 *******************************************************************************/
void convert_IntraFreqMeasQuantity_modeSpecificInfo
(
 UMTS_IntraFreqMeasQuantity_modeSpecificInfo  *modeSpecificInfo,
 intrafreqmeasquantity_modespecificinfo_t  *mode_specific_info
 )
{
    mode_specific_info->t = modeSpecificInfo->t;
    switch(mode_specific_info->t)
    {
        case RRC_UMTS_IntraFreqMeasQuantity_modeSpecificInfo_fdd:
            convert_IntraFreqMeasQuantity_modeSpecificInfo_fdd(
                    modeSpecificInfo->u.fdd,
                    &mode_specific_info->u.fdd);
            break;
        case RRC_UMTS_IntraFreqMeasQuantity_modeSpecificInfo_tdd:
            convert_IntraFreqMeasQuantity_modeSpecificInfo_tdd(
                    modeSpecificInfo->u.tdd,
                    &mode_specific_info->u.tdd);
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqMeasQuantity
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasQuantity
 *       to intrafreqmeasquantity_t
 *
 *******************************************************************************/
void convert_IntraFreqMeasQuantity
(
 UMTS_IntraFreqMeasQuantity *intraFreqMeasQuantity,
 intrafreqmeasquantity_t *intra_freq_meas_quantity
 )
{
    intra_freq_meas_quantity->filter_coefficient =
        intraFreqMeasQuantity->filterCoefficient;
    convert_IntraFreqMeasQuantity_modeSpecificInfo(
            &intraFreqMeasQuantity->modeSpecificInfo,
            &intra_freq_meas_quantity->mode_specific_info);

}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd
 *       to intrafreqreportingquantityforrach_modespecificinfo_fdd_t
 *
 *******************************************************************************/
void convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd
(
 UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd *asn_fdd,
 intrafreqreportingquantityforrach_modespecificinfo_fdd_t *umts_fdd
 )
{
    umts_fdd->intrafreqrepquantityrach_fdd = asn_fdd->intraFreqRepQuantityRACH_FDD;
}

/******************************************************************************
 *   FUNCTION NAME:convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd
 *       to intrafreqreportingquantityforrach_modespecificinfo_tdd_t
 *
 *
 *******************************************************************************/
void convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd
(
 UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd *asn_tdd,
 intrafreqreportingquantityforrach_modespecificinfo_tdd_t *umts_tdd
 )
{
    umts_tdd->intrafreqrepquantityrach_tddlist.n = 
        asn_tdd->intraFreqRepQuantityRACH_TDDList.n;
    memcpy(umts_tdd->intrafreqrepquantityrach_tddlist.elem,
            asn_tdd->intraFreqRepQuantityRACH_TDDList.elem,
            (asn_tdd->intraFreqRepQuantityRACH_TDDList.n * sizeof(U32)));
}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo
 *       to intrafreqreportingquantityforrach_modeSpecificInfo_t
 *
 *******************************************************************************/
void convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo
(
 UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo *modeSpecificInfo,
 intrafreqreportingquantityforrach_modeSpecificInfo_t	*mode_specific_info
 )
{
    mode_specific_info->t = modeSpecificInfo->t;

    switch (modeSpecificInfo->t)
    {
        case RRC_UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd:
            convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd(
                    modeSpecificInfo->u.fdd,
                    &mode_specific_info->u.fdd);
            break;
        case RRC_UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd:
            convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd(
                    modeSpecificInfo->u.tdd,
                    &mode_specific_info->u.tdd);
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqReportingQuantityForRACH
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingQuantityForRACH
 *       to intrafreqreportingquantityforrach_t
 *
 *******************************************************************************/
void convert_IntraFreqReportingQuantityForRACH
(
 UMTS_IntraFreqReportingQuantityForRACH  *intraFreqReportingQuantityForRACH,
 intrafreqreportingquantityforrach_t	*intra_freq_reporting_quantity_for_rach
 )
{
    intra_freq_reporting_quantity_for_rach->sfn_sfn_otd_type = 
        intraFreqReportingQuantityForRACH->sfn_SFN_OTD_Type;
    convert_IntraFreqReportingQuantityForRACH_modeSpecificInfo(
            &intraFreqReportingQuantityForRACH->modeSpecificInfo,
            &intra_freq_reporting_quantity_for_rach->mode_specific_info);

}

/******************************************************************************
 *   FUNCTION NAME: convert_CellReportingQuantities_modeSpecificInfo_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellReportingQuantities_modeSpecificInfo_fdd to
 *       cellreportingquantities_modespecificInfo_fdd_t
 *
 *******************************************************************************/
void convert_CellReportingQuantities_modeSpecificInfo_fdd
(
 UMTS_CellReportingQuantities_modeSpecificInfo_fdd *asn_fdd,
 cellreportingquantities_modespecificInfo_fdd_t *umts_fdd
 )
{
    umts_fdd->cpich_ec_no_reportingindicator =
        asn_fdd->cpich_Ec_N0_reportingIndicator;

    umts_fdd->cpich_rscp_reportingindicator =
        asn_fdd->cpich_RSCP_reportingIndicator;

    umts_fdd->pathloss_reportingIndicator =
        asn_fdd->pathloss_reportingIndicator;
}

/******************************************************************************
 *   FUNCTION NAME: convert_CellReportingQuantities_modeSpecificInfo_tdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellReportingQuantities_modeSpecificInfo_tdd
 *       to cellreportingquantities_modespecificInfo_tdd_t
 *
 *******************************************************************************/
void convert_CellReportingQuantities_modeSpecificInfo_tdd
(
 UMTS_CellReportingQuantities_modeSpecificInfo_tdd *asn_tdd,
 cellreportingquantities_modespecificInfo_tdd_t *umts_tdd
 )
{
    umts_tdd->timeslotiscp_reporting_indicator =
        asn_tdd->timeslotISCP_reportingIndicator;

    umts_tdd->proposedtgsn_reporting_required =
        asn_tdd->proposedTGSN_ReportingRequired;

    umts_tdd->primaryccpch_rscp_reporting_indicator =
        asn_tdd->primaryCCPCH_RSCP_reportingIndicator;

    umts_tdd->pathloss_reporting_indicator =
        asn_tdd->pathloss_reportingIndicator;
}

/******************************************************************************
 *   FUNCTION NAME: convert_CellReportingQuantities_modeSpecificInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellReportingQuantities_modeSpecificInfo
 *       to cellreportingquantities_modespecificinfo_t
 *
 *******************************************************************************/
void convert_CellReportingQuantities_modeSpecificInfo
(
 UMTS_CellReportingQuantities_modeSpecificInfo *modeSpecificInfo,
 cellreportingquantities_modespecificinfo_t  *mode_specific_info
 )
{
    mode_specific_info->t = modeSpecificInfo->t;
    switch (mode_specific_info->t)
    {
        case RRC_UMTS_CellReportingQuantities_modeSpecificInfo_fdd:
            convert_CellReportingQuantities_modeSpecificInfo_fdd(
                    modeSpecificInfo->u.fdd,
                    &mode_specific_info->u.fdd);
            break;
        case RRC_UMTS_CellReportingQuantities_modeSpecificInfo_tdd:
            convert_CellReportingQuantities_modeSpecificInfo_tdd(
                    modeSpecificInfo->u.tdd,
                    &mode_specific_info->u.tdd);
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_detectedSetReportingQuantities
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellReportingQuantities
 *       to cellreportingquantities_t
 *
 *******************************************************************************/
void convert_detectedSetReportingQuantities
(
 UMTS_CellReportingQuantities *detectedSetReportingQuantities,
 cellreportingquantities_t  *detected_set_reporting_quantities
 )
{
    convert_CellReportingQuantities_modeSpecificInfo(
            &detectedSetReportingQuantities->modeSpecificInfo,
            &detected_set_reporting_quantities->mode_specific_info);

    detected_set_reporting_quantities->dummy = detectedSetReportingQuantities->dummy;
    detected_set_reporting_quantities->cell_identity_reporting_indicator =
        detectedSetReportingQuantities->cellIdentity_reportingIndicator;
    detected_set_reporting_quantities->cell_synchronisation_info_reporting_indicator =
        detectedSetReportingQuantities->cellSynchronisationInfoReportingIndicator;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intraFreqReportingQuantity
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingQuantity
 *       to intrafreqreportingquantity_t
 *
 *******************************************************************************/
void convert_intraFreqReportingQuantity
(
 UMTS_IntraFreqReportingQuantity *intraFreqReportingQuantity,
 intrafreqreportingquantity_t	*intra_freq_reporting_quantity
 )
{
    intra_freq_reporting_quantity->presence_bitmask = 0;
    if (intraFreqReportingQuantity->m.detectedSetReportingQuantitiesPresent)
    {
        intra_freq_reporting_quantity->presence_bitmask |= 
            UMTS_SIB_INTRAFREQREPORTINGQUANTITY_DETECTEDSETREPORTINGQUANTITIES_PRESENCE_FLAG;

        convert_detectedSetReportingQuantities(
                &intraFreqReportingQuantity->detectedSetReportingQuantities,
                &intra_freq_reporting_quantity->detected_set_reporting_quantities);
    }

    convert_detectedSetReportingQuantities(
            &intraFreqReportingQuantity->activeSetReportingQuantities,
            &intra_freq_reporting_quantity->active_set_reporting_quantities);

    convert_detectedSetReportingQuantities(
            &intraFreqReportingQuantity->monitoredSetReportingQuantities,
            &intra_freq_reporting_quantity->monitored_set_reporting_quantities);

}


/******************************************************************************
 *   FUNCTION NAME: convert_measurementReportingMode
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementReportingMode
 *       to measurementreportingmode_t
 *
 *******************************************************************************/
void convert_measurementReportingMode(
        UMTS_MeasurementReportingMode *measurementReportingMode,
        measurementreportingmode_t  *measurement_reporting_mode)
{
    measurement_reporting_mode->measurement_report_transfer_mode =
        measurementReportingMode->measurementReportTransferMode;
    measurement_reporting_mode->periodical_or_event_trigger =
        measurementReportingMode->periodicalOrEventTrigger;
}



/******************************************************************************
 *   FUNCTION NAME: convert_ForbiddenAffectCell_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ForbiddenAffectCell_LCR_r4
 *       to forbiddenaffectcell_lcr_r4_t
 *
 *******************************************************************************/
void convert_ForbiddenAffectCell_LCR_r4
(
 UMTS_ForbiddenAffectCell_LCR_r4 *ForbiddenAffectCell_LCR_r4,
 forbiddenaffectcell_lcr_r4_t  *forbiddenaffectcell_lcr_r4
 )
{
    convert_PrimaryCCPCH_Info_LCR_r4(
            &ForbiddenAffectCell_LCR_r4->tdd,
            &forbiddenaffectcell_lcr_r4->tdd);
}

/******************************************************************************
 *   FUNCTION NAME: convert_ForbiddenAffectCellList_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ForbiddenAffectCellList_LCR_r4
 *       to forbiddenaffectcelllist_lcr_r4_t
 *
 *******************************************************************************/
void convert_ForbiddenAffectCellList_LCR_r4
(
 UMTS_ForbiddenAffectCellList_LCR_r4 *forbiddenAffectCellList,
 forbiddenaffectcelllist_lcr_r4_t *forbidden_affect_cell_list
 )
{
    OSRTDListNode                       *pnode  = NULL;
    UMTS_ForbiddenAffectCell_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    forbidden_affect_cell_list->count = forbiddenAffectCellList->count;
    pnode = forbiddenAffectCellList->head;

    for (index=0; index<forbidden_affect_cell_list->count; index++)
    {
        pdata0 = (UMTS_ForbiddenAffectCell_LCR_r4*)pnode->data;

        convert_ForbiddenAffectCell_LCR_r4(
                pdata0,
                &(forbidden_affect_cell_list->forbiddenaffectcell_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_Event1a_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Event1a_LCR_r4 to event1a_lcr_r4_t
 *
 *******************************************************************************/
void convert_Event1a_LCR_r4
(
 UMTS_Event1a_LCR_r4 *asn_e1a,
 event1a_lcr_r4_t *umts_e1a
 )
{

    umts_e1a->presence_bitmask = 0;
    if (asn_e1a->m.forbiddenAffectCellListPresent)
    {
        umts_e1a->presence_bitmask |=
            UMTS_SIB_EVENT1A_LCR_R4_FORBIDDENAFFECTCELLLIST_PRESENCE_FLAG;
        convert_ForbiddenAffectCellList_LCR_r4(
                &asn_e1a->forbiddenAffectCellList,
                &umts_e1a->forbidden_affect_cell_list);
    }

    umts_e1a->triggering_condition = 
        asn_e1a->triggeringCondition;
    umts_e1a->reporting_range =
        asn_e1a->reportingRange;
    umts_e1a->w = asn_e1a->w;
    umts_e1a->report_deactivation_threshold = 
        asn_e1a->reportDeactivationThreshold;
    umts_e1a->reporting_amount =
        asn_e1a->reportingAmount;
    umts_e1a->reporting_interval =
        asn_e1a->reportingInterval;
}


/******************************************************************************
 *   FUNCTION NAME: convert_Event1b_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Event1b_LCR_r4
 *       to event1b_lcr_r4_t
 *
 *******************************************************************************/
void convert_Event1b_LCR_r4
(
 UMTS_Event1b_LCR_r4 *asn_e1b,
 event1b_lcr_r4_t *umts_e1b
 )
{
    umts_e1b->triggering_condition = 
        asn_e1b->triggeringCondition;
    umts_e1b->reporting_range =
        asn_e1b->reportingRange;
    umts_e1b->w = asn_e1b->w;

    umts_e1b->presence_bitmask = 0;
    if (asn_e1b->m.forbiddenAffectCellListPresent)
    {
        umts_e1b->presence_bitmask |=
            UMTS_SIB_EVENT1B_LCR_R4_FORBIDDENAFFECTCELLLIST_PRESENCE_FLAG;
        convert_ForbiddenAffectCellList_LCR_r4(
                &asn_e1b->forbiddenAffectCellList,
                &umts_e1b->forbiddenAffectCellList);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_Event1c
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Event1c to event1c_t
 *
 *******************************************************************************/
void convert_Event1c
(
 UMTS_Event1c *asn_e1c,
 event1c_t *umts_e1c
 )
{
    umts_e1c->replacementActivationThreshold =
        asn_e1c->replacementActivationThreshold;

    umts_e1c->reportingAmount =
        asn_e1c->reportingAmount;

    umts_e1c->reportingInterval =
        asn_e1c->reportingInterval;
}

/******************************************************************************
 *   FUNCTION NAME:convert_Event1e
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Event1e to event1e_t
 *
 *******************************************************************************/
void convert_Event1e
(
 UMTS_Event1e *asn_e1e,
 event1e_t *umts_e1e
 )
{
    umts_e1e->triggeringCondition =
        asn_e1e->triggeringCondition;
    umts_e1e->thresholdUsedFrequency =
        asn_e1e->thresholdUsedFrequency;
}

/******************************************************************************
 *   FUNCTION NAME: convert_Event1f
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Event1f to event1f_t
 *
 *******************************************************************************/
void convert_Event1f
(
 UMTS_Event1f *asn_e1f,
 event1f_t *umts_e1f
 ) 
{
    umts_e1f->triggeringCondition =
        asn_e1f->triggeringCondition;
    umts_e1f->thresholdUsedFrequency =
        asn_e1f->thresholdUsedFrequency;
}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqEvent_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqEvent_LCR_r4
 *       to intrafreqevent_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqEvent_LCR_r4
(
 UMTS_IntraFreqEvent_LCR_r4 *asn_event, 
 intrafreqevent_lcr_r4_t *umts_event
 )
{
    umts_event->t = asn_event->t;
    switch (asn_event->t)
    {
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1a:
            convert_Event1a_LCR_r4(
                    asn_event->u.e1a, &umts_event->u.e1a);
            break;
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1b:
            convert_Event1b_LCR_r4(
                    asn_event->u.e1b, &umts_event->u.e1b);
            break;
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1c:
            convert_Event1c(
                    asn_event->u.e1c, &umts_event->u.e1c);
            break;
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1d:
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1e:
            convert_Event1e(
                    asn_event->u.e1e, &umts_event->u.e1e);
            break;
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1f:
            convert_Event1f(
                    asn_event->u.e1f, &umts_event->u.e1f); 
            break;
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1g:
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1h:
            umts_event->u.e1h = asn_event->u.e1h;
            break;
        case RRC_UMTS_IntraFreqEvent_LCR_r4_e1i:
            umts_event->u.e1i = asn_event->u.e1i;
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_ReportingCellStatus
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ReportingCellStatus
 *       to inreportingcellstatus_t
 *
 *******************************************************************************/
void convert_ReportingCellStatus
(
 UMTS_ReportingCellStatus *reportingCellStatus,
 inreportingcellstatus_t *reporting_cell_status
 )
{

    reporting_cell_status->t = reportingCellStatus->t;
    switch (reportingCellStatus->t)

    {
        case RRC_UMTS_ReportingCellStatus_withinActiveSet:

            reporting_cell_status->u.withinActiveSet =
                reportingCellStatus->u.withinActiveSet;
            break;
        case RRC_UMTS_ReportingCellStatus_withinMonitoredSetUsedFreq:

            reporting_cell_status->u.withinMonitoredSetUsedFreq =
                reportingCellStatus->u.withinMonitoredSetUsedFreq;
            break;
        case RRC_UMTS_ReportingCellStatus_withinActiveAndOrMonitoredUsedFreq:

            reporting_cell_status->u.withinActiveAndOrMonitoredUsedFreq =
                reportingCellStatus->u.withinActiveAndOrMonitoredUsedFreq;
            break;
        case RRC_UMTS_ReportingCellStatus_withinDetectedSetUsedFreq:

            reporting_cell_status->u.withinDetectedSetUsedFreq =
                reportingCellStatus->u.withinDetectedSetUsedFreq;
            break;
        case RRC_UMTS_ReportingCellStatus_withinMonitoredAndOrDetectedUsedFreq:

            reporting_cell_status->u.withinMonitoredAndOrDetectedUsedFreq =
                reportingCellStatus->u.withinMonitoredAndOrDetectedUsedFreq;
            break;
        case RRC_UMTS_ReportingCellStatus_allActiveplusMonitoredSet:

            reporting_cell_status->u.allActiveplusMonitoredSet =
                reportingCellStatus->u.allActiveplusMonitoredSet;
            break;
        case RRC_UMTS_ReportingCellStatus_allActivePlusDetectedSet:

            reporting_cell_status->u.allActivePlusDetectedSet =
                reportingCellStatus->u.allActivePlusDetectedSet;
            break;
        case RRC_UMTS_ReportingCellStatus_allActivePlusMonitoredAndOrDetectedSet:

            reporting_cell_status->u.allActivePlusMonitoredAndOrDetectedSet =
                reportingCellStatus->u.allActivePlusMonitoredAndOrDetectedSet;
            break;
        case RRC_UMTS_ReportingCellStatus_withinVirtualActSet:

            reporting_cell_status->u.withinVirtualActSet =
                reportingCellStatus->u.withinVirtualActSet;
            break;
        case RRC_UMTS_ReportingCellStatus_withinMonitoredSetNonUsedFreq:

            reporting_cell_status->u.withinMonitoredSetNonUsedFreq =
                reportingCellStatus->u.withinMonitoredSetNonUsedFreq;
            break;
        case RRC_UMTS_ReportingCellStatus_withinMonitoredAndOrVirtualActiveSetNonUsedFreq:

            reporting_cell_status->u.withinMonitoredAndOrVirtualActiveSetNonUsedFreq =
                reportingCellStatus->u.withinMonitoredAndOrVirtualActiveSetNonUsedFreq;
            break;
        case RRC_UMTS_ReportingCellStatus_allVirtualActSetplusMonitoredSetNonUsedFreq:

            reporting_cell_status->u.allVirtualActSetplusMonitoredSetNonUsedFreq =
                reportingCellStatus->u.allVirtualActSetplusMonitoredSetNonUsedFreq;
            break;
        case RRC_UMTS_ReportingCellStatus_withinActSetOrVirtualActSet_InterRATcells:

            reporting_cell_status->u.withinActSetOrVirtualActSet_InterRATcells =
                reportingCellStatus->u.withinActSetOrVirtualActSet_InterRATcells;
            break;
        case RRC_UMTS_ReportingCellStatus_withinActSetAndOrMonitoredUsedFreqOrVirtualActSetAndOrMonitoredNonUsedFreq:

            reporting_cell_status->u.withinActSetAndOrMonitoredUsedFreqOrVirtualActSetAndOrMonitoredNonUsedFreq =
                reportingCellStatus->u.withinActSetAndOrMonitoredUsedFreqOrVirtualActSetAndOrMonitoredNonUsedFreq;
            break;
        default:
            break;

    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqEventCriteria_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqEventCriteria_LCR_r4
 *       to intrafreqeventcriteria_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqEventCriteria_LCR_r4
(
 UMTS_IntraFreqEventCriteria_LCR_r4 *IntraFreqEventCriteria_LCR_r4,
 intrafreqeventcriteria_lcr_r4_t *intrafreqeventcriteria_lcr_r4
 )
{
    intrafreqeventcriteria_lcr_r4->presence_bitmask = 0;
    intrafreqeventcriteria_lcr_r4->hysteresis =
        IntraFreqEventCriteria_LCR_r4->hysteresis;

    intrafreqeventcriteria_lcr_r4->timeToTrigger =
        IntraFreqEventCriteria_LCR_r4->timeToTrigger;

    if (IntraFreqEventCriteria_LCR_r4->m.reportingCellStatusPresent)
    {
        intrafreqeventcriteria_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRAFREQEVENTCRITERIA_LCR_R4_REPORTINGCELLSTATUS_PRESENCE_FLAG;
        convert_ReportingCellStatus(
                &IntraFreqEventCriteria_LCR_r4->reportingCellStatus,
                &intrafreqeventcriteria_lcr_r4->reporting_cell_status);
    }
    convert_IntraFreqEvent_LCR_r4(
            &IntraFreqEventCriteria_LCR_r4->event, 
            &intrafreqeventcriteria_lcr_r4->event);

}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqEventCriteriaList_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqEventCriteriaList_LCR_r4
 *       to intrafreqeventcriterialist_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqEventCriteriaList_LCR_r4
(
 UMTS_IntraFreqEventCriteriaList_LCR_r4 *eventCriteriaList,
 intrafreqeventcriterialist_lcr_r4_t *event_criteria_list
 )
{
    OSRTDListNode                       *pnode  = NULL;
    UMTS_IntraFreqEventCriteria_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    event_criteria_list->count = eventCriteriaList->count;
    pnode = eventCriteriaList->head;

    for (index=0; index<event_criteria_list->count; index++)
    {
        pdata0 = (UMTS_IntraFreqEventCriteria_LCR_r4*)pnode->data;

        convert_IntraFreqEventCriteria_LCR_r4(
                pdata0,
                &(event_criteria_list->intrafreqeventcriteria_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;

}

/******************************************************************************
 *   FUNCTION NAME: convert_intraFreqReportingCriteria
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingCriteria_LCR_r4
 *       to intrafreqreportingcriteria_lcr_r4_t
 *
 *******************************************************************************/
void convert_intraFreqReportingCriteria
(
 UMTS_IntraFreqReportingCriteria_LCR_r4 *intraFreqReportingCriteria,
 intrafreqreportingcriteria_lcr_r4_t	*intra_freq_reporting_criteria
 )
{
    intra_freq_reporting_criteria->presence_bitmask = 0;
    if (intraFreqReportingCriteria->m.eventCriteriaListPresent)
    {
        intra_freq_reporting_criteria->presence_bitmask |=
            UMTS_SIB_INTRAFREQREPORTINGCRITERIA_LCR_R4_EVENTCRITERIALIST_PRESENCE_FLAG;

        convert_IntraFreqEventCriteriaList_LCR_r4(
                &intraFreqReportingCriteria->eventCriteriaList,
                &intra_freq_reporting_criteria->event_criteria_list);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_periodicalReportingCriteria
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PeriodicalReportingCriteria
 *       to periodicalreportingcriteria_t
 *
 *******************************************************************************/
void convert_periodicalReportingCriteria(
        UMTS_PeriodicalReportingCriteria *periodicalReportingCriteria,
        periodicalreportingcriteria_t		*periodical_reporting_criteria)
{
    periodical_reporting_criteria->reporting_amount = 
        periodicalReportingCriteria->reportingAmount;

    periodical_reporting_criteria->reporting_interval = 
        periodicalReportingCriteria->reportingInterval;
}



/******************************************************************************
 *   FUNCTION NAME: convert_CellDCH_ReportCriteria_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellDCH_ReportCriteria_LCR_r4
 *       to celldch_reportcriteria_lcr_r4_t
 *
 *******************************************************************************/
void convert_CellDCH_ReportCriteria_LCR_r4
(
 UMTS_CellDCH_ReportCriteria_LCR_r4 *reportCriteria,
 celldch_reportcriteria_lcr_r4_t	*report_criteria
 )
{
    report_criteria->t = reportCriteria->t;
    switch(report_criteria->t)
    {
        case RRC_UMTS_CellDCH_ReportCriteria_LCR_r4_intraFreqReportingCriteria:
            convert_intraFreqReportingCriteria(
                    reportCriteria->u.intraFreqReportingCriteria,
                    &report_criteria->u.intra_freq_reporting_criteria);
            break;
        case RRC_UMTS_CellDCH_ReportCriteria_LCR_r4_periodicalReportingCriteria:
            convert_periodicalReportingCriteria(
                    reportCriteria->u.periodicalReportingCriteria,
                    &report_criteria->u.periodical_reporting_criteria);
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_ReportingInfoForCellDCH_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ReportingInfoForCellDCH_LCR_r4
 *       to reportinginfoforcelldch_lcr_r4_t
 *
 *******************************************************************************/
void convert_ReportingInfoForCellDCH_LCR_r4
(
 UMTS_ReportingInfoForCellDCH_LCR_r4 *reportingInfoForCellDCH,
 reportinginfoforcelldch_lcr_r4_t   *reporting_info_for_celldch
 )
{
    convert_intraFreqReportingQuantity(
            &reportingInfoForCellDCH->intraFreqReportingQuantity,
            &reporting_info_for_celldch->intra_freq_reporting_quantity);

    convert_measurementReportingMode(
            &reportingInfoForCellDCH->measurementReportingMode,
            &reporting_info_for_celldch->measurement_reporting_mode);

    convert_CellDCH_ReportCriteria_LCR_r4(
            &reportingInfoForCellDCH->reportCriteria,
            &reporting_info_for_celldch->report_criteria);

}

/******************************************************************************
 *   FUNCTION NAME: convert_intraFreqMeasurementSysInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasurementSysInfo_RSCP_LCR_r4
 *       to intrafreqmeasurementsysinfo_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_intraFreqMeasurementSysInfo
(
 UMTS_IntraFreqMeasurementSysInfo_RSCP_LCR_r4 *intraFreqMeasurementSysInfo,
 intrafreqmeasurementsysinfo_rscp_lcr_r4_t *intra_freq_measurement_sysInfo
 )
{
    intra_freq_measurement_sysInfo->presence_bitmask = 0;
    intra_freq_measurement_sysInfo->intra_freq_measurement_id =
        intraFreqMeasurementSysInfo->intraFreqMeasurementID;

    if (intraFreqMeasurementSysInfo->m.intraFreqCellInfoSI_ListPresent)
    {
        intra_freq_measurement_sysInfo->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_RSCP_LCR_R4_INTRAFREQCELLINFOSI_LIST_PRESENCE_FLAG;
        convert_IntraFreqCellInfoSI_List_RSCP_LCR_r4(
                &intraFreqMeasurementSysInfo->intraFreqCellInfoSI_List,
                &intra_freq_measurement_sysInfo->intra_freq_cellinfosi_list);

    }

    if (intraFreqMeasurementSysInfo->m.intraFreqMeasQuantityPresent)
    {
        intra_freq_measurement_sysInfo->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_RSCP_LCR_R4_INTRAFREQMEASQUANTITY_PRESENCE_FLAG;
        convert_IntraFreqMeasQuantity(
                &intraFreqMeasurementSysInfo->intraFreqMeasQuantity,
                &intra_freq_measurement_sysInfo->intra_freq_meas_quantity);;
    }
    if (intraFreqMeasurementSysInfo->m.intraFreqReportingQuantityForRACHPresent)
    {
        intra_freq_measurement_sysInfo->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_RSCP_LCR_R4_INTRAFREQREPORTINGQUANTITYFORRACH_PRESENCE_FLAG;

        convert_IntraFreqReportingQuantityForRACH(
                &intraFreqMeasurementSysInfo->intraFreqReportingQuantityForRACH,
                &intra_freq_measurement_sysInfo->intra_freq_reporting_quantity_for_rach);
    }
    if (intraFreqMeasurementSysInfo->m.maxReportedCellsOnRACHPresent)
    {
        intra_freq_measurement_sysInfo->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_RSCP_LCR_R4_MAXREPORTEDCELLSONRACH_PRESENCE_FLAG;

        intra_freq_measurement_sysInfo->max_reported_cell_son_rach =
            intraFreqMeasurementSysInfo->maxReportedCellsOnRACH;
    }
    if (intraFreqMeasurementSysInfo->m.reportingInfoForCellDCHPresent)
    {
        intra_freq_measurement_sysInfo->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_RSCP_LCR_R4_REPORTINGINFOFORCELLDCH_PRESENCE_FLAG;

        convert_ReportingInfoForCellDCH_LCR_r4(
                &intraFreqMeasurementSysInfo->reportingInfoForCellDCH,
                &intra_freq_measurement_sysInfo->reporting_info_for_celldch);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_RemovedInterFreqCellList_removeSomeInterFreqCells
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_RemovedInterFreqCellList_removeSomeInterFreqCells
 *       to removedinterfreqcelllist_removesomeinterfreqcells_t
 *
 *******************************************************************************/
void convert_RemovedInterFreqCellList_removeSomeInterFreqCells
(
 UMTS_RemovedInterFreqCellList_removeSomeInterFreqCells *removeSomeInterFreqCells,
 removedinterfreqcelllist_removesomeinterfreqcells_t *remove_some_inter_freqCells
 )
{
    remove_some_inter_freqCells->n = removeSomeInterFreqCells->n;
    memcpy(remove_some_inter_freqCells->elem, removeSomeInterFreqCells->elem,
            removeSomeInterFreqCells->n * sizeof (U32));
}

/******************************************************************************
 *   FUNCTION NAME: convert_RemovedInterFreqCellList
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_RemovedInterFreqCellList
 *       to removedinterfreqcelllist_t
 *
 *******************************************************************************/
void convert_RemovedInterFreqCellList
(
 UMTS_RemovedInterFreqCellList *removedInterFreqCellList,
 removedinterfreqcelllist_t *removed_inter_freq_cell_list
 )
{
    removed_inter_freq_cell_list->t = removedInterFreqCellList->t;
    switch(removedInterFreqCellList->t)
    {
        case RRC_UMTS_RemovedInterFreqCellList_removeAllInterFreqCells:
            break;
        case RRC_UMTS_RemovedInterFreqCellList_removeSomeInterFreqCells:
            convert_RemovedInterFreqCellList_removeSomeInterFreqCells(
                    removedInterFreqCellList->u.removeSomeInterFreqCells,
                    &removed_inter_freq_cell_list->u.removeSomeInterFreqCells);
            break;
        case RRC_UMTS_RemovedInterFreqCellList_removeNoInterFreqCells:
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_FrequencyInfoFDD
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FrequencyInfoFDD
 *       to frequency_info_fdd_t
 *
 *******************************************************************************/
void convert_FrequencyInfoFDD
(
 UMTS_FrequencyInfoFDD *asn_fdd,
 frequency_info_fdd_t *umts_fdd
 )
{
    umts_fdd->presence_bitmask = 0;

    if (asn_fdd->m.uarfcn_ULPresent)
    {
        umts_fdd->presence_bitmask |=
            UMTS_SIB_FREQ_INFO_FDD_UARFCN_UL_PRESENCE_FLAG;
        umts_fdd->uarfcn_ul = asn_fdd->uarfcn_UL;
    }
    umts_fdd->uarfcn_dl = asn_fdd->uarfcn_DL;
}

/******************************************************************************
 *   FUNCTION NAME: convert_FrequencyInfo_modeSpecificInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FrequencyInfo_modeSpecificInfo
 *       to frequencyinfo_modespecificinfo_t
 *
 *******************************************************************************/
void convert_FrequencyInfo_modeSpecificInfo
(
 UMTS_FrequencyInfo_modeSpecificInfo *modeSpecificInfo,
 frequency_info_mode_specific_info_t  *mode_specific_info
 )
{
    mode_specific_info->t   = modeSpecificInfo->t; 
    switch (mode_specific_info->t)
    {

        case RRC_UMTS_FrequencyInfo_modeSpecificInfo_fdd:
            convert_FrequencyInfoFDD( modeSpecificInfo->u.fdd,
                    &mode_specific_info->u.fdd);
            break;

        case RRC_UMTS_FrequencyInfo_modeSpecificInfo_tdd:
            mode_specific_info->u.tdd.uarfcn_nt = modeSpecificInfo->u.tdd->uarfcn_Nt;
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_FrequencyInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FrequencyInfo
 *       to frequency_info_t 
 *
 *******************************************************************************/
void convert_FrequencyInfo
( 
 UMTS_FrequencyInfo *frequencyInfo,
 frequency_info_t *frequency_info
 )
{
    convert_FrequencyInfo_modeSpecificInfo(
            &frequencyInfo->modeSpecificInfo,
            &frequency_info->mode_specific_info);
}

/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellSI_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_RSCP_LCR_r4
 *       newinterfreqcellsi_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellSI_RSCP_LCR_r4
(
 UMTS_NewInterFreqCellSI_RSCP_LCR_r4 *NewInterFreqCellSI_RSCP_LCR_r4,
 newinterfreqcellsi_rscp_lcr_r4_t *newinterfreqcellsi_rscp_lcr_r4
 )
{
    newinterfreqcellsi_rscp_lcr_r4->presence_bitmask = 0;

    if (NewInterFreqCellSI_RSCP_LCR_r4->m.interFreqCellIDPresent)
    {
        newinterfreqcellsi_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTERFREQCELLSI_RSCP_LCR_R4_INTERFREQCELLID_PRESENCE_FLAG;
        newinterfreqcellsi_rscp_lcr_r4->inter_freq_cell_id =
            NewInterFreqCellSI_RSCP_LCR_r4->interFreqCellID;
    }
    if (NewInterFreqCellSI_RSCP_LCR_r4->m.frequencyInfoPresent)
    {
        newinterfreqcellsi_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTERFREQCELLSI_RSCP_LCR_R4_FREQUENCYINFO_PRESENCE_FLAG;
        convert_FrequencyInfo(
                &NewInterFreqCellSI_RSCP_LCR_r4->frequencyInfo,
                &newinterfreqcellsi_rscp_lcr_r4->frequency_info);
    }

    convert_CellInfoSI_RSCP_LCR_r4(
            &NewInterFreqCellSI_RSCP_LCR_r4->cellInfo,
            &newinterfreqcellsi_rscp_lcr_r4->cell_info);
}


/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellSI_List_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_RSCP_LCR_r4
 *       to newinterfreqcellsi_list_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellSI_List_RSCP_LCR_r4
(
 UMTS_NewInterFreqCellSI_List_RSCP_LCR_r4 *newInterFreqCellList,
 newinterfreqcellsi_list_rscp_lcr_r4_t *new_inter_freq_cell_list
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewInterFreqCellSI_RSCP_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    new_inter_freq_cell_list->count = newInterFreqCellList->count;
    pnode = newInterFreqCellList->head;

    for (index=0; index < new_inter_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewInterFreqCellSI_RSCP_LCR_r4*)pnode->data;

        convert_NewInterFreqCellSI_RSCP_LCR_r4(
                pdata0,
                &(new_inter_freq_cell_list->newinterfreqcellsi_rscp_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqCellInfoSI_List_RSCP_LCR
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqCellInfoSI_List_RSCP_LCR
 *       to interfreqcellinfosi_list_rscp_lcr_t
 *
 *******************************************************************************/
void convert_InterFreqCellInfoSI_List_RSCP_LCR
(
 UMTS_InterFreqCellInfoSI_List_RSCP_LCR *interFreqCellInfoSI_List,
 interfreqcellinfosi_list_rscp_lcr_t *inter_freq_cell_info_si_list
 )
{
    inter_freq_cell_info_si_list->presence_bitmask = 0;
    if (interFreqCellInfoSI_List->m.newInterFreqCellListPresent)
    {
        inter_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTERFREQCELLINFOSI_LIST_RSCP_LCR_NEWiNTERFREQCELLLIST_PRESENCE_FLAG;
        convert_NewInterFreqCellSI_List_RSCP_LCR_r4(
                &interFreqCellInfoSI_List->newInterFreqCellList,
                &inter_freq_cell_info_si_list->new_inter_freq_cell_list);
    }

    if (interFreqCellInfoSI_List->m.removedInterFreqCellListPresent)
    {
        inter_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTERFREQCELLINFOSI_LIST_RSCP_LCR_REMOVEDINTERFREQCELLLIST_PRESENCE_FLAG;
        convert_RemovedInterFreqCellList(
                &interFreqCellInfoSI_List->removedInterFreqCellList,
                &inter_freq_cell_info_si_list->removedInterFreqCellList);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqMeasurementSysInfo_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqMeasurementSysInfo_RSCP_LCR_r4
 *       to interfreqmeasurementsysinfo_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_InterFreqMeasurementSysInfo_RSCP_LCR_r4
(
 UMTS_InterFreqMeasurementSysInfo_RSCP_LCR_r4 *interFreqMeasurementSysInfo,
 interfreqmeasurementsysinfo_rscp_lcr_r4_t *inter_freq_measurement_sysInfo
 )
{
    inter_freq_measurement_sysInfo->presence_bitmask = 0;
    if (interFreqMeasurementSysInfo->m.interFreqCellInfoSI_ListPresent)
    {
        inter_freq_measurement_sysInfo->presence_bitmask |= 
            UMTS_SIB_INTERFREQMEASUREMENTSYSINFO_RSCP_LCR_R4_INTERFREQCELLINFOSI_LIST_PRESENCE_FLAG;
        convert_InterFreqCellInfoSI_List_RSCP_LCR(
                &interFreqMeasurementSysInfo->interFreqCellInfoSI_List,
                &inter_freq_measurement_sysInfo->inter_freq_cell_info_si_list);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP
 *       to measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_not_used_cellselectqualitymeasure_cpich_rscp_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP *cpich_RSCP,
 measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_not_used_cellselectqualitymeasure_cpich_rscp_t	*cpich_rscp
 )
{
    cpich_rscp->presence_bitmask =  0;
    if (cpich_RSCP->m.intraFreqMeasurementSysInfoPresent)
    {
        cpich_rscp->presence_bitmask |= 
            UMTS_SIB_MEASUREMENTCONTROLSYSINFO_LCR_R4_EXT_USE_OF_HCS_HCS_NOT_USED_CELLSELECTQUALITYMEASURE_CPICH_RSCP_INTRAFREQMEASUREMENTSYSINFO_PRESENCE_FLAG;
        convert_intraFreqMeasurementSysInfo(
                &cpich_RSCP->intraFreqMeasurementSysInfo,
                &cpich_rscp->intra_freq_measurement_sysInfo);
    }

    if (cpich_RSCP->m.interFreqMeasurementSysInfoPresent)
    {
        cpich_rscp->presence_bitmask |= 
            UMTS_SIB_MEASUREMENTCONTROLSYSINFO_LCR_R4_EXT_USE_OF_HCS_HCS_NOT_USED_CELLSELECTQUALITYMEASURE_CPICH_RSCP_INTERFREQMEASUREMENTSYSINFO_PRESENCE_FLAG;
        convert_InterFreqMeasurementSysInfo_RSCP_LCR_r4(
                &cpich_RSCP->interFreqMeasurementSysInfo,
                &cpich_rscp->inter_freq_measurement_sysInfo);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd
 *       cellselectreselectinfosib_11_12_ecn0_modespecificinfo_fdd_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd *asn_fdd,
 cellselectreselectinfosib_11_12_ecn0_modespecificinfo_fdd_t *umts_fdd
 )
{
    umts_fdd->presence_bitmask = 0;

    if (asn_fdd->m.q_QualMinPresent)
    {
        umts_fdd->presence_bitmask |= 
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_ECN0_MODESPECIFICINFO_FDD_Q_QUALMIN_PRESENCE_FLAG;
        umts_fdd->q_QualMin = asn_fdd->q_QualMin;
    }
    if (asn_fdd->m.q_RxlevMinPresent)
    {
        umts_fdd->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_ECN0_MODESPECIFICINFO_FDD_Q_RXLEVMIN_PRESENCE_FLAG;
        umts_fdd->q_RxlevMin = asn_fdd->q_RxlevMin;
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd
 *       to cellselectreselectinfosib_11_12_ecn0_modespecificinfo_tdd_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd *asn_tdd,
 cellselectreselectinfosib_11_12_ecn0_modespecificinfo_tdd_t *umts_tdd
 )
{
    umts_tdd->presence_bitmask = 0;
    if (asn_tdd->m.q_RxlevMinPresent)
    {
        umts_tdd->q_RxlevMin = asn_tdd->q_RxlevMin;

        umts_tdd->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_ECN0_MODESPECIFICINFO_TDD_Q_RXLEVMIN_PRESENCE_FLAG;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm
 *       cellselectreselectinfosib_11_12_ecn0_modespecificinfo_gsm_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm *asn_gsm,
 cellselectreselectinfosib_11_12_ecn0_modespecificinfo_gsm_t *umts_gsm
 )
{
    umts_gsm->presence_bitmask = 0;
    if (asn_gsm->m.q_RxlevMinPresent)
    {
        umts_gsm->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_ECN0_MODESPECIFICINFO_GSM_Q_RXLEVMIN_PRESENCE_FLAG;
        umts_gsm->q_RxlevMin = asn_gsm->q_RxlevMin;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo
 *       to cellselectreselectinfosib_11_12_ecn0_modespecificinfo_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo *modeSpecificInfo,
 cellselectreselectinfosib_11_12_ecn0_modespecificinfo_t *mode_specific_info
 )
{

    mode_specific_info->t = modeSpecificInfo->t;
    switch (mode_specific_info->t)
    {
        case RRC_UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd:
            convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd(
                    modeSpecificInfo->u.fdd,
                    &mode_specific_info->u.fdd);
            break;
        case RRC_UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd:
            convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd(
                    modeSpecificInfo->u.tdd,
                    &mode_specific_info->u.tdd);
            break;
        case RRC_UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm:
            convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm(
                    modeSpecificInfo->u.gsm,
                    &mode_specific_info->u.gsm);
            break;
        default:
            break;

    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_ECN0
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0
 *       to cellselectreselectinfosib_11_12_ecn0_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_ECN0
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0 *cellSelectionReselectionInfo,
 cellselectreselectinfosib_11_12_ecn0_t *cell_selection_reselection_info
 )
{
    cell_selection_reselection_info->presence_bitmask = 0;
    if (cellSelectionReselectionInfo->m.maxAllowedUL_TX_PowerPresent)
    {
        cell_selection_reselection_info->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_ECN0_MAXALLOWEDUL_TX_POWER_PRESENCE_FLAG;
        cell_selection_reselection_info->maxAllowedUL_TX_Power =
            cellSelectionReselectionInfo->maxAllowedUL_TX_Power;
    }

    cell_selection_reselection_info->q_Offset1S_N = cellSelectionReselectionInfo->q_Offset1S_N;
    cell_selection_reselection_info->q_Offset2S_N = cellSelectionReselectionInfo->q_Offset2S_N;

    convert_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo(
            &cellSelectionReselectionInfo->modeSpecificInfo,
            &cell_selection_reselection_info->mode_specific_info);
}

/******************************************************************************
 *   FUNCTION NAME: convert_CellInfoSI_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_ECN0_LCR_r4
 *       to cellinfosi_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_CellInfoSI_ECN0_LCR_r4
(
 UMTS_CellInfoSI_ECN0_LCR_r4 *cellInfo,
 cellinfosi_ecn0_lcr_r4_t *cell_info
 )
{
    cell_info->presence_bitmask = 0;
    cell_info->cellIndividualOffset = cellInfo->cellIndividualOffset;
    cell_info->readsfn_indicator = cellInfo->readSFN_Indicator;

    if (cellInfo->m.referenceTimeDifferenceToCellPresent)
    {
        cell_info->presence_bitmask |=
            UMTS_SIB_INCELLINFOSI_ECN0_LCR_R4_REFERENCETIMEDIFFERENCETOCELL_PRESENCE_FLAG;

        convert_ReferenceTimeDifferenceToCell(
                &cellInfo->referenceTimeDifferenceToCell,
                &cell_info->reference_time_difference_to_cell);
    }
    if (cellInfo->m.primaryCCPCH_TX_PowerPresent)
    {
        cell_info->presence_bitmask |=
            UMTS_SIB_INCELLINFOSI_ECN0_LCR_R4_PRIMARYCCPCH_TX_POWER_PRESENCE_FLAG;
        cell_info->primaryccpch_tx_power = cellInfo->primaryCCPCH_TX_Power;
    }
    if (cellInfo->m.timeslotInfoListPresent)
    {
        cell_info->presence_bitmask |=
            UMTS_SIB_INCELLINFOSI_ECN0_LCR_R4_TIMESLOTINFOLIST_PRESENCE_FLAG;
        convert_TimeslotInfoList_LCR_r4(
                &cellInfo->timeslotInfoList,
                &cell_info->timeslot_info_list);
    }
    if (cellInfo->m.cellSelectionReselectionInfoPresent)
    {
        cell_info->presence_bitmask |=
            UMTS_SIB_INCELLINFOSI_ECN0_LCR_R4_CELLSELECTIONRESELECTIONINFO_PRESENCE_FLAG;
        convert_PrimaryCCPCH_Info_LCR_r4(
                &cellInfo->primaryCCPCH_Info,
                &cell_info->primaryccpch_info);
    }

    convert_CellSelectReselectInfoSIB_11_12_ECN0(
            &cellInfo->cellSelectionReselectionInfo,
            &cell_info->cell_selection_reselection_info);
}


/******************************************************************************
 *   FUNCTION NAME: convert_NewIntraFreqCellSI_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_ECN0_LCR_r4
 *       to newintrafreqcellsi_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewIntraFreqCellSI_ECN0_LCR_r4
(
 UMTS_NewIntraFreqCellSI_ECN0_LCR_r4 *NewIntraFreqCellSI_ECN0_LCR_r4,
 newintrafreqcellsi_ecn0_lcr_r4_t *newintrafreqcellsi_ecn0_lcr_r4
 ) 
{
    newintrafreqcellsi_ecn0_lcr_r4->presence_bitmask = 0;

    if (NewIntraFreqCellSI_ECN0_LCR_r4->m.intraFreqCellIDPresent)
    {
        newintrafreqcellsi_ecn0_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTRAFREQCELLSI_ECN0_LCR_R4_INTRAFREQCELLID_PRESENCE_FLAG;
        newintrafreqcellsi_ecn0_lcr_r4->intrafreqcell_id = 
            NewIntraFreqCellSI_ECN0_LCR_r4->intraFreqCellID;
    }

    convert_CellInfoSI_ECN0_LCR_r4(
            &NewIntraFreqCellSI_ECN0_LCR_r4->cellInfo,
            &newintrafreqcellsi_ecn0_lcr_r4->cell_info);
}


/******************************************************************************
 *   FUNCTION NAME: convert_NewIntraFreqCellSI_List_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_ECN0_LCR_r4
 *       to newintrafreqcellsi_list_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewIntraFreqCellSI_List_ECN0_LCR_r4
(
 UMTS_NewIntraFreqCellSI_List_ECN0_LCR_r4 *newIntraFreqCellList,
 newintrafreqcellsi_list_ecn0_lcr_r4_t *new_intra_freq_cell_list
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewIntraFreqCellSI_ECN0_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    new_intra_freq_cell_list->count = newIntraFreqCellList->count;
    pnode = newIntraFreqCellList->head;

    for (index=0; index<new_intra_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewIntraFreqCellSI_ECN0_LCR_r4*)pnode->data;
        convert_NewIntraFreqCellSI_ECN0_LCR_r4(
                pdata0,
                &(new_intra_freq_cell_list->newintrafreqcellsi_ecn0_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqCellInfoSI_List_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqCellInfoSI_List_ECN0_LCR_r4
 *       to intrafreqcellinfosi_list_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqCellInfoSI_List_ECN0_LCR_r4
(
 UMTS_IntraFreqCellInfoSI_List_ECN0_LCR_r4 *intraFreqCellInfoSI_List,
 intrafreqcellinfosi_list_ecn0_lcr_r4_t	*intra_freq_cell_info_si_list
 )
{
    intra_freq_cell_info_si_list->presence_bitmask = 0;
    if (intraFreqCellInfoSI_List->m.removedIntraFreqCellListPresent)
    {
        intra_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTRAFREQCELLINFOSI_LIST_ECN0_LCR_R4_REMOVEDINTRAFREQCELLLIST_PRESENCE_FLAG;
        convert_RemovedIntraFreqCellList(
                &intraFreqCellInfoSI_List->removedIntraFreqCellList,
                &intra_freq_cell_info_si_list->removed_intra_freq_cell_list);
    }

    convert_NewIntraFreqCellSI_List_ECN0_LCR_r4(
            &intraFreqCellInfoSI_List->newIntraFreqCellList,
            &intra_freq_cell_info_si_list->new_intra_freq_cell_list);
}


/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqMeasurementSysInfo_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasurementSysInfo_ECN0_LCR_r4
 *       to intrafreqmeasurementsysinfo_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqMeasurementSysInfo_ECN0_LCR_r4
(
 UMTS_IntraFreqMeasurementSysInfo_ECN0_LCR_r4 *intraFreqMeasurementSysInfo,
 intrafreqmeasurementsysinfo_ecn0_lcr_r4_t  *intra_freq_measurement_sys_info
 )
{
    intra_freq_measurement_sys_info->presence_bitmask = 0;

    intra_freq_measurement_sys_info->intra_freq_measurement_id =
        intraFreqMeasurementSysInfo->intraFreqMeasurementID;

    if (intraFreqMeasurementSysInfo->m.intraFreqCellInfoSI_ListPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_ECN0_LCR_R4_INTRAFREQCELLINFOSI_LIST_PRESENCE_FLAG;
        convert_IntraFreqCellInfoSI_List_ECN0_LCR_r4(
                &intraFreqMeasurementSysInfo->intraFreqCellInfoSI_List,
                &intra_freq_measurement_sys_info->intra_freq_cell_info_si_list);
    }
    if (intraFreqMeasurementSysInfo->m.intraFreqMeasQuantityPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_ECN0_LCR_R4_INTRAFREQMEASQUANTITY_PRESENCE_FLAG;
        convert_IntraFreqMeasQuantity(
                &intraFreqMeasurementSysInfo->intraFreqMeasQuantity,
                &intra_freq_measurement_sys_info->intra_freq_meas_quantity);
    }

    if (intraFreqMeasurementSysInfo->m.intraFreqReportingQuantityForRACHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_ECN0_LCR_R4_INTRAFREQREPORTINGQUANTITYFORRACHPRESEN_FLAG;

        convert_IntraFreqReportingQuantityForRACH(
                &intraFreqMeasurementSysInfo->intraFreqReportingQuantityForRACH,
                &intra_freq_measurement_sys_info->intra_freq_reporting_quantity_for_rach);
    }

    if (intraFreqMeasurementSysInfo->m.maxReportedCellsOnRACHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_ECN0_LCR_R4_MAXREPORTEDCELLSONRACH_PRESENCE_FLAG;
        intra_freq_measurement_sys_info->max_reported_cell_sonrach =
            intraFreqMeasurementSysInfo->maxReportedCellsOnRACH;
    }

    if (intraFreqMeasurementSysInfo->m.reportingInfoForCellDCHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_ECN0_LCR_R4_REPORTINGINFOFORCELLDCH_PRESENCE_FLAG;

        convert_ReportingInfoForCellDCH_LCR_r4(
                &intraFreqMeasurementSysInfo->reportingInfoForCellDCH,
                &intra_freq_measurement_sys_info->reporting_info_for_celldch);
    }

}


/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellSI_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_ECN0_LCR_r4
 *       to newinterfreqcellsi_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellSI_ECN0_LCR_r4
(
 UMTS_NewInterFreqCellSI_ECN0_LCR_r4 *NewInterFreqCellSI_ECN0_LCR_r4,
 newinterfreqcellsi_ecn0_lcr_r4_t *newinterfreqcellsi_ecn0_lcr_r4
 )
{
    newinterfreqcellsi_ecn0_lcr_r4->presence_bitmask = 0;

    if (NewInterFreqCellSI_ECN0_LCR_r4->m.interFreqCellIDPresent)
    {
        newinterfreqcellsi_ecn0_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTERFREQCELLSI_ECN0_LCR_R4_INTERFREQCELLID_PRESENCE_FLAG; 
        newinterfreqcellsi_ecn0_lcr_r4->inter_freq_cell_id |=
            NewInterFreqCellSI_ECN0_LCR_r4->interFreqCellID;
    }

    if (NewInterFreqCellSI_ECN0_LCR_r4->m.frequencyInfoPresent)
    {
        newinterfreqcellsi_ecn0_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTERFREQCELLSI_ECN0_LCR_R4_INTERFREQCFREQUENCYINFO_PRESENCE_FLAG;
        convert_FrequencyInfo(&NewInterFreqCellSI_ECN0_LCR_r4->frequencyInfo,
                &newinterfreqcellsi_ecn0_lcr_r4->frequency_info);
    }

    convert_CellInfoSI_ECN0_LCR_r4(
            &NewInterFreqCellSI_ECN0_LCR_r4->cellInfo,
            &newinterfreqcellsi_ecn0_lcr_r4->cell_info);
}


/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellSI_List_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_ECN0_LCR_r4
 *       to newinterfreqcellsi_list_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellSI_List_ECN0_LCR_r4
(
 UMTS_NewInterFreqCellSI_List_ECN0_LCR_r4 *newInterFreqCellList,
 newinterfreqcellsi_list_ecn0_lcr_r4_t	*new_inter_freq_cell_list
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewInterFreqCellSI_ECN0_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    new_inter_freq_cell_list->count = newInterFreqCellList->count;
    pnode = newInterFreqCellList->head;

    for (index=0; index<new_inter_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewInterFreqCellSI_ECN0_LCR_r4*)pnode->data;

        convert_NewInterFreqCellSI_ECN0_LCR_r4(
                pdata0,
                &(new_inter_freq_cell_list->newinterfreqcellsi_ecn0_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqCellInfoSI_List_ECN0_LCR
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqCellInfoSI_List_ECN0_LCR
 *       to interfreqcellinfosi_list_ecn0_lcr_t
 *
 *******************************************************************************/
void convert_InterFreqCellInfoSI_List_ECN0_LCR
(
 UMTS_InterFreqCellInfoSI_List_ECN0_LCR *interFreqCellInfoSI_List,
 interfreqcellinfosi_list_ecn0_lcr_t *inter_freq_cell_info_si_list
 )
{
    inter_freq_cell_info_si_list->presence_bitmask  = 0;
    if (interFreqCellInfoSI_List->m.removedInterFreqCellListPresent)
    {
        inter_freq_cell_info_si_list->presence_bitmask  |=
            UMTS_SIB_INTERFREQCELLINFOSI_LIST_ECN0_LCR_REMOVEDiNTERfREQcELLlISTpRESENT_FLAG;
        convert_RemovedInterFreqCellList(
                &interFreqCellInfoSI_List->removedInterFreqCellList,
                &inter_freq_cell_info_si_list->removed_inter_freq_cell_list);
    }

    if (interFreqCellInfoSI_List->m.newInterFreqCellListPresent)
    {
        inter_freq_cell_info_si_list->presence_bitmask  |=
            UMTS_SIB_INTERFREQCELLINFOSI_LIST_ECN0_LCR_NEWiNTERfREQcELLlISTpRESENT_FLAG;
        convert_NewInterFreqCellSI_List_ECN0_LCR_r4(
                &interFreqCellInfoSI_List->newInterFreqCellList,
                &inter_freq_cell_info_si_list->new_inter_freq_cell_list);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqMeasurementSysInfo_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqMeasurementSysInfo_ECN0_LCR_r4
 *       to interfreqmeasurementsysinfo_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_InterFreqMeasurementSysInfo_ECN0_LCR_r4
(
 UMTS_InterFreqMeasurementSysInfo_ECN0_LCR_r4 *interFreqMeasurementSysInfo,
 interfreqmeasurementsysinfo_ecn0_lcr_r4_t  *inter_freq_measurement_sys_info
 )
{
    inter_freq_measurement_sys_info->presence_bitmask  = 0;

    if (interFreqMeasurementSysInfo->m.interFreqCellInfoSI_ListPresent)
    {
        inter_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTERFREQMEASUREMENTSYSINFO_ECN0_LCR_R4_INTERFREQCELLINFOSI_LIST_PRESENCE_FLAG;
        convert_InterFreqCellInfoSI_List_ECN0_LCR(
                &interFreqMeasurementSysInfo->interFreqCellInfoSI_List,
                &inter_freq_measurement_sys_info->inter_freq_cell_info_si_list);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0
 *       to measurementcontrolsysInfo_lcr_r4_ext_use_of_hcs_hcs_not_used_cellselectqualitymeasure_cpich_ec_n0_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0 *cpich_Ec_N0,
 measurementcontrolsysInfo_lcr_r4_ext_use_of_hcs_hcs_not_used_cellselectqualitymeasure_cpich_ec_n0_t	*cpich_ec_n0
 )
{
    cpich_ec_n0->presence_bitmask  = 0; 

    if (cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent)
    {
        cpich_ec_n0->presence_bitmask  |= 
            UMTS_SIB_MEASUREMENTCONTROLSYSiNFO_LCR_R4_EXT_USE_OF_HCS_HCS_NOT_USED_CELLSELECTQUALITYMEASURE_CPICH_EC_NO_INTRAFREQMEASUREMENTSYSINFO_PRESENCE_FLAG;
        convert_IntraFreqMeasurementSysInfo_ECN0_LCR_r4(
                &cpich_Ec_N0->intraFreqMeasurementSysInfo,
                &cpich_ec_n0->intra_freq_measurement_sys_info);
    }
    if (cpich_Ec_N0->m.interFreqMeasurementSysInfoPresent)
    {
        cpich_ec_n0->presence_bitmask  |= 
            UMTS_SIB_MEASUREMENTCONTROLSYSiNFO_LCR_R4_EXT_USE_OF_HCS_HCS_NOT_USED_CELLSELECTQUALITYMEASURE_CPICH_EC_NO_INTERFREQMEASUREMENTSYSINFO_PRESENCE_FLAG;
        convert_InterFreqMeasurementSysInfo_ECN0_LCR_r4(
                &cpich_Ec_N0->interFreqMeasurementSysInfo,
                &cpich_ec_n0->inter_freq_measurement_sys_info);
    }

}


/******************************************************************************
 *   FUNCTION NAME: convert_PenaltyTime_RSCP
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PenaltyTime_RSCP
 *       to penaltytime_rscp_t
 *
 *******************************************************************************/
void convert_PenaltyTime_RSCP
(
 UMTS_PenaltyTime_RSCP *penaltyTime,
 penaltytime_rscp_t *penalty_time
 )
{
    penalty_time->t = penaltyTime->t;

    switch (penaltyTime->t)
    {
        case RRC_UMTS_PenaltyTime_RSCP_notUsed:
            break;
        case RRC_UMTS_PenaltyTime_RSCP_pt10:
            penalty_time->u.pt10 = penaltyTime->u.pt10;
            break;
        case RRC_UMTS_PenaltyTime_RSCP_pt20:
            penalty_time->u.pt20 = penaltyTime->u.pt20;
            break;
        case RRC_UMTS_PenaltyTime_RSCP_pt30:
            penalty_time->u.pt30 = penaltyTime->u.pt30;
            break;
        case RRC_UMTS_PenaltyTime_RSCP_pt40:
            penalty_time->u.pt40 = penaltyTime->u.pt40;
            break;
        case RRC_UMTS_PenaltyTime_RSCP_pt50:
            penalty_time->u.pt50 = penaltyTime->u.pt50;
            break;
        case RRC_UMTS_PenaltyTime_RSCP_pt60:
            penalty_time->u.pt60 = penaltyTime->u.pt60;
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_HCS_CellReselectInformation_RSCP
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_HCS_CellReselectInformation_RSCP
 *       to hcs_cellreselectinformation_rscp_t
 *
 *******************************************************************************/
void convert_HCS_CellReselectInformation_RSCP
(
 UMTS_HCS_CellReselectInformation_RSCP *hcs_CellReselectInformation,
 hcs_cellreselectinformation_rscp_t *hcs_cellreselectinformation
 )
{
    convert_PenaltyTime_RSCP(
            &hcs_CellReselectInformation->penaltyTime,
            &hcs_cellreselectinformation->penalty_time);

}


/******************************************************************************
 *   FUNCTION NAME: convert_HCS_NeighbouringCellInformation_RSCP
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_HCS_NeighbouringCellInformation_RSCP
 *       to hcs_neighbouringcellinformation_rscp_t
 *
 *******************************************************************************/
void convert_HCS_NeighbouringCellInformation_RSCP
(
 UMTS_HCS_NeighbouringCellInformation_RSCP *hcs_NeighbouringCellInformation_RSCP,
 hcs_neighbouringcellinformation_rscp_t *hcs_neighbouring_cell_information_rscp
 )
{
    hcs_neighbouring_cell_information_rscp->hcs_prio =
        hcs_NeighbouringCellInformation_RSCP->hcs_PRIO;
    hcs_neighbouring_cell_information_rscp->q_hcs =
        hcs_NeighbouringCellInformation_RSCP->q_HCS;

    convert_HCS_CellReselectInformation_RSCP(
            &hcs_NeighbouringCellInformation_RSCP->hcs_CellReselectInformation,
            &hcs_neighbouring_cell_information_rscp->hcs_cellreselectinformation);
}


/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfoSIB_11_12_HCS_RSCP
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP
 *       cellselectreselectinfosib_11_12_hcs_rscp_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfoSIB_11_12_HCS_RSCP
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP *cellSelectionReselectionInfo,
 cellselectreselectinfosib_11_12_hcs_rscp_t *cell_selection_reselection_info
 )
{
    cell_selection_reselection_info->q_OffsetS_N = 
        cellSelectionReselectionInfo->q_OffsetS_N;

    cell_selection_reselection_info->presence_bitmask = 0;

    if (cellSelectionReselectionInfo->m.maxAllowedUL_TX_PowerPresent)
    {
        cell_selection_reselection_info->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_HCS_RSCP_MAXALLOWEDUL_TX_POWER_PRESENCE_FLAG;
        cell_selection_reselection_info->max_allowed_ul_tx_power =
            cellSelectionReselectionInfo->maxAllowedUL_TX_Power;
    }
    if (cellSelectionReselectionInfo->m.hcs_NeighbouringCellInformation_RSCPPresent)
    {
        cell_selection_reselection_info->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFOSIB_11_12_HCS_RSCP_HCS_NEIGHBOURINGCELLINFORMATION_RSCP_PRESENCE_FLAG;
        convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info(
                &cellSelectionReselectionInfo->modeSpecificInfo,
                &cell_selection_reselection_info->mode_specific_info);
    }
    convert_HCS_NeighbouringCellInformation_RSCP(
            &cellSelectionReselectionInfo->hcs_NeighbouringCellInformation_RSCP,
            &cell_selection_reselection_info->hcs_neighbouring_cell_information_rscp);
}


/******************************************************************************
 *   FUNCTION NAME: convert_CellInfoSI_HCS_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_RSCP_LCR_r4
 *       to cellinfosi_hcs_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_CellInfoSI_HCS_RSCP_LCR_r4
(
 UMTS_CellInfoSI_HCS_RSCP_LCR_r4 *cellInfo,
 cellinfosi_hcs_rscp_lcr_r4_t *cell_info
 )
{
    cell_info->presence_bitmask = 0;

    cell_info->readsfn_indicator =
        cellInfo->readSFN_Indicator;
    convert_PrimaryCCPCH_Info_LCR_r4(
            &cellInfo->primaryCCPCH_Info,
            &cell_info->primaryccpch_info);

    cell_info->cellIndividualOffset =
        cellInfo->cellIndividualOffset;

    if (cellInfo->m.referenceTimeDifferenceToCellPresent)
    {
        cell_info->presence_bitmask |=
            UMTS_SIB_CELLINFOSI_HCS_RSCP_LCR_R4_REFERENCETIMEDIFFERENCETOCELL_PRESENCE_FLAG;
        convert_ReferenceTimeDifferenceToCell(
                &cellInfo->referenceTimeDifferenceToCell,
                &cell_info->referencetime_differencetocell);
    }
    if (cellInfo->m.primaryCCPCH_TX_PowerPresent)
    {
        cell_info->presence_bitmask |=
            UMTS_SIB_CELLINFOSI_HCS_RSCP_LCR_R4_PRIMARYCCPCH_TX_POWER_PRESENCE_FLAG;
        cell_info->primaryccpch_tx_power =
            cellInfo->primaryCCPCH_TX_Power;
    }
    if (cellInfo->m.timeslotInfoListPresent)
    {
        cell_info->presence_bitmask |=
            UMTS_SIB_CELLINFOSI_HCS_RSCP_LCR_R4_TIMESLOTINFOLIST_PRESENCE_FLAG;
        convert_TimeslotInfoList_LCR_r4(
                &cellInfo->timeslotInfoList,
                &cell_info->timeslot_info_list);
    }
    if (cellInfo->m.cellSelectionReselectionInfoPresent)
    {
        cell_info->presence_bitmask |=
            UMTS_SIB_CELLINFOSI_HCS_RSCP_LCR_R4_CELLSELECTIONRESELECTIONINFO_PRESENCE_FLAG;
        convert_CellSelectReselectInfoSIB_11_12_HCS_RSCP(
                &cellInfo->cellSelectionReselectionInfo,
                &cell_info->cell_selection_reselection_info);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_NewIntraFreqCellSI_HCS_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_HCS_RSCP_LCR_r4
 *       to newintrafreqcellsi_hcs_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewIntraFreqCellSI_HCS_RSCP_LCR_r4
(
 UMTS_NewIntraFreqCellSI_HCS_RSCP_LCR_r4 *NewIntraFreqCellSI_HCS_RSCP_LCR_r4,
 newintrafreqcellsi_hcs_rscp_lcr_r4_t *newintrafreqcellsi_hcs_rscp_lcr_r4
 )
{
    newintrafreqcellsi_hcs_rscp_lcr_r4->presence_bitmask = 0;
    if (NewIntraFreqCellSI_HCS_RSCP_LCR_r4->m.intraFreqCellIDPresent)
    {
        newintrafreqcellsi_hcs_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTRAFREQCELLSI_HCS_RSCP_LCR_R4_INTRAFREQCELLIDPRESENCE_FLAG;
        newintrafreqcellsi_hcs_rscp_lcr_r4->intra_freq_cell_id =
            NewIntraFreqCellSI_HCS_RSCP_LCR_r4->intraFreqCellID;
    }

    convert_CellInfoSI_HCS_RSCP_LCR_r4(
            &NewIntraFreqCellSI_HCS_RSCP_LCR_r4->cellInfo,
            &newintrafreqcellsi_hcs_rscp_lcr_r4->cell_info);

}


/******************************************************************************
 *   FUNCTION NAME: convert_NewIntraFreqCellSI_List_HCS_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_HCS_RSCP_LCR_r4
 *       newintrafreqcellsi_list_hcs_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewIntraFreqCellSI_List_HCS_RSCP_LCR_r4
(
 UMTS_NewIntraFreqCellSI_List_HCS_RSCP_LCR_r4 *newIntraFreqCellList,
 newintrafreqcellsi_list_hcs_rscp_lcr_r4_t *new_intra_freq_cell_list
 )
{
    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewIntraFreqCellSI_HCS_RSCP_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    new_intra_freq_cell_list->count = newIntraFreqCellList->count;
    pnode = newIntraFreqCellList->head;

    for (index=0; index<new_intra_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewIntraFreqCellSI_HCS_RSCP_LCR_r4*)pnode->data;

        convert_NewIntraFreqCellSI_HCS_RSCP_LCR_r4(
                pdata0,
                &(new_intra_freq_cell_list->newintrafreqcellsi_hcs_rscp_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqCellInfoSI_List_HCS_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqCellInfoSI_List_HCS_RSCP_LCR_r4
 *       to intrafreqcellinfosi_list_hcs_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqCellInfoSI_List_HCS_RSCP_LCR_r4(
        UMTS_IntraFreqCellInfoSI_List_HCS_RSCP_LCR_r4 *intraFreqCellInfoSI_List,
        intrafreqcellinfosi_list_hcs_rscp_lcr_r4_t   *intra_freq_cell_info_si_list)
{
    intra_freq_cell_info_si_list->presence_bitmask = 0;

    if (intraFreqCellInfoSI_List->m.removedIntraFreqCellListPresent)
    {
        intra_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTRAFREQCELLINFOSI_LIST_HCS_RSCP_LCR_R4_REMOVEDiNTRAfREQCELLlIST_PRESENCE_FLAG;

        convert_RemovedIntraFreqCellList(
                &intraFreqCellInfoSI_List->removedIntraFreqCellList,
                &intra_freq_cell_info_si_list->removed_intra_freq_cell_list);
    }

    convert_NewIntraFreqCellSI_List_HCS_RSCP_LCR_r4(
            &intraFreqCellInfoSI_List->newIntraFreqCellList,
            &intra_freq_cell_info_si_list->new_intra_freq_cell_list);
}


/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqMeasurementSysInfo_HCS_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasurementSysInfo_HCS_RSCP_LCR_r4
 *       to intrafreqmeasurementsysinfo_hcs_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqMeasurementSysInfo_HCS_RSCP_LCR_r4
(
 UMTS_IntraFreqMeasurementSysInfo_HCS_RSCP_LCR_r4 *intraFreqMeasurementSysInfo,
 intrafreqmeasurementsysinfo_hcs_rscp_lcr_r4_t *intra_freq_measurement_sys_info
 )
{
    intra_freq_measurement_sys_info->presence_bitmask = 0;
    intra_freq_measurement_sys_info->intra_freq_measurement_id =
        intraFreqMeasurementSysInfo->intraFreqMeasurementID;

    if (intraFreqMeasurementSysInfo->m.intraFreqCellInfoSI_ListPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_RSCP_LCR_R4_INTRAFREQCELLINFOSI_LIST_PRESENCE_FLAG;
        convert_IntraFreqCellInfoSI_List_HCS_RSCP_LCR_r4(
                &intraFreqMeasurementSysInfo->intraFreqCellInfoSI_List,
                &intra_freq_measurement_sys_info->intra_freq_cell_info_si_list);
    }
    if (intraFreqMeasurementSysInfo->m.intraFreqMeasQuantityPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_RSCP_LCR_R4_INTRAFREQMEASQUANTITYPRESEN_FLAG;
        convert_IntraFreqMeasQuantity(
                &intraFreqMeasurementSysInfo->intraFreqMeasQuantity,
                &intra_freq_measurement_sys_info->intra_freq_meas_quantity);
    }
    if (intraFreqMeasurementSysInfo->m.intraFreqReportingQuantityForRACHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_RSCP_LCR_R4_INTRAFREQREPORTINGQUANTITYFORRACHPRESEN_FLAG;
        convert_IntraFreqReportingQuantityForRACH(
                &intraFreqMeasurementSysInfo->intraFreqReportingQuantityForRACH,
                &intra_freq_measurement_sys_info->intra_freq_reporting_quantity_forrach);
    }
    if (intraFreqMeasurementSysInfo->m.maxReportedCellsOnRACHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_RSCP_LCR_R4_MAXREPORTEDCELLSONRACHPRESEN_FLAG;
        intra_freq_measurement_sys_info->max_reported_cells_onrach =
            intraFreqMeasurementSysInfo->maxReportedCellsOnRACH;
    }
    if (intraFreqMeasurementSysInfo->m.reportingInfoForCellDCHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_RSCP_LCR_R4_REPORTINGINFOFORCELLDCHPRESEN_FLAG;
        convert_ReportingInfoForCellDCH_LCR_r4(
                &intraFreqMeasurementSysInfo->reportingInfoForCellDCH,
                &intra_freq_measurement_sys_info->reporting_info_forellDCH);
    }

}


/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellSI_HCS_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_HCS_RSCP_LCR_r4
 *       newinterfreqcellsi_hcs_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellSI_HCS_RSCP_LCR_r4
(
 UMTS_NewInterFreqCellSI_HCS_RSCP_LCR_r4 *NewInterFreqCellSI_HCS_RSCP_LCR_r4,
 newinterfreqcellsi_hcs_rscp_lcr_r4_t *newinterfreqcellsi_hcs_rscp_lcr_r4
 )
{
    newinterfreqcellsi_hcs_rscp_lcr_r4->presence_bitmask = 0;

    if (NewInterFreqCellSI_HCS_RSCP_LCR_r4->m.interFreqCellIDPresent)
    {
        newinterfreqcellsi_hcs_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTERFREQCELLSI_HCS_RSCP_LCR_R4_INTERFREQCELLID_PRESENCE_FLAG;
        newinterfreqcellsi_hcs_rscp_lcr_r4->inter_freq_cell_id =
            NewInterFreqCellSI_HCS_RSCP_LCR_r4->interFreqCellID;
    }
    if (NewInterFreqCellSI_HCS_RSCP_LCR_r4->m.frequencyInfoPresent)
    {
        newinterfreqcellsi_hcs_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTERFREQCELLSI_HCS_RSCP_LCR_R4_FREQUENCYINFO_PRESENCE_FLAG;
        convert_FrequencyInfo(
                &NewInterFreqCellSI_HCS_RSCP_LCR_r4->frequencyInfo,
                &newinterfreqcellsi_hcs_rscp_lcr_r4->frequencyInfo);
    }
    convert_CellInfoSI_HCS_RSCP_LCR_r4(
            &NewInterFreqCellSI_HCS_RSCP_LCR_r4->cellInfo,
            &newinterfreqcellsi_hcs_rscp_lcr_r4->cellInfo);
}


/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellSI_List_HCS_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_HCS_RSCP_LCR_r4
 *       to newinterfreqcellsi_list_hcs_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellSI_List_HCS_RSCP_LCR_r4
(
 UMTS_NewInterFreqCellSI_List_HCS_RSCP_LCR_r4 *newInterFreqCellList,
 newinterfreqcellsi_list_hcs_rscp_lcr_r4_t *new_inter_freq_cell_list
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewInterFreqCellSI_HCS_RSCP_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    new_inter_freq_cell_list->count = newInterFreqCellList->count;
    pnode = newInterFreqCellList->head;

    for (index=0; index < new_inter_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewInterFreqCellSI_HCS_RSCP_LCR_r4*)pnode->data;

        convert_NewInterFreqCellSI_HCS_RSCP_LCR_r4(
                pdata0,
                &(new_inter_freq_cell_list->newinterfreqcellsi_hcs_rscp_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqCellInfoSI_List_HCS_RSCP_LCR
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqCellInfoSI_List_HCS_RSCP_LCR
 *       interfreqcellinfosi_list_hcs_rscp_lcr_t
 *
 *******************************************************************************/
void convert_InterFreqCellInfoSI_List_HCS_RSCP_LCR(
        UMTS_InterFreqCellInfoSI_List_HCS_RSCP_LCR *interFreqCellInfoSI_List,
        interfreqcellinfosi_list_hcs_rscp_lcr_t *inter_freq_cell_info_si_list)
{
    inter_freq_cell_info_si_list->presence_bitmask = 0;
    if (interFreqCellInfoSI_List->m.removedInterFreqCellListPresent)
    {
        inter_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTERFREQCELLINFOSI_LIST_HCS_RSCP_LCR_REMOVEDINTERFREQCELLLIST_PRESENCE_FLAG;
        convert_RemovedInterFreqCellList(
                &interFreqCellInfoSI_List->removedInterFreqCellList,
                &inter_freq_cell_info_si_list->removed_inter_freq_cell_list);
    }

    if (interFreqCellInfoSI_List->m.newInterFreqCellListPresent)
    {
        inter_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTERFREQCELLINFOSI_LIST_HCS_RSCP_LCR_NEWINTERFREQCELLLIST_PRESENCE_FLAG;
        convert_NewInterFreqCellSI_List_HCS_RSCP_LCR_r4(
                &interFreqCellInfoSI_List->newInterFreqCellList,
                &inter_freq_cell_info_si_list->new_inter_freq_cell_list);
    }

}

/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqMeasurementSysInfo_HCS_RSCP_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqMeasurementSysInfo_HCS_RSCP_LCR_r4
 *       to interfreqmeasurementsysinfo_hcs_rscp_lcr_r4_t
 *
 *******************************************************************************/
void convert_InterFreqMeasurementSysInfo_HCS_RSCP_LCR_r4
(
 UMTS_InterFreqMeasurementSysInfo_HCS_RSCP_LCR_r4 *interFreqMeasurementSysInfo,
 interfreqmeasurementsysinfo_hcs_rscp_lcr_r4_t    *inter_freq_measurement_sys_info
 )
{
    inter_freq_measurement_sys_info->presence_bitmask = 0;

    if (interFreqMeasurementSysInfo->m.interFreqCellInfoSI_ListPresent)
    {
        inter_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTERFREQMEASUREMENTSYSINFO_HCS_RSCP_LCR_R4_INTERFREQCELLINFOSI_LIST_PRESENCE_FLAG;
        convert_InterFreqCellInfoSI_List_HCS_RSCP_LCR(
                &interFreqMeasurementSysInfo->interFreqCellInfoSI_List,
                &inter_freq_measurement_sys_info->inter_freq_cell_info_si_list);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP
 *       to measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_used_cellselectqualitymeasure_cpich_rscp_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP(
        UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP *cpich_RSCP,
        measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_used_cellselectqualitymeasure_cpich_rscp_t *cpich_rscp)
{
    cpich_rscp->presence_bitmask = 0;

    if (cpich_RSCP->m.intraFreqMeasurementSysInfoPresent)
    {
        cpich_rscp->presence_bitmask |=
            UMTS_SIB_MEASUREMENTCONTROLSYSINFO_LCR_R4_EXT_USE_OF_HCS_HCS_USED_CELLSELECTQUALITYMEASURE_CPICH_RSCP_INTRAFREQMEASUREMENTSYSINFO_PRESENCE_FLAG;
        convert_IntraFreqMeasurementSysInfo_HCS_RSCP_LCR_r4(
                &cpich_RSCP->intraFreqMeasurementSysInfo,
                &cpich_rscp->intra_freq_measurement_sys_info);
    }
    if (cpich_RSCP->m.interFreqMeasurementSysInfoPresent)
    {
        cpich_rscp->presence_bitmask |=
            UMTS_SIB_MEASUREMENTCONTROLSYSINFO_LCR_R4_EXT_USE_OF_HCS_HCS_USED_CELLSELECTQUALITYMEASURE_CPICH_RSCP_INTERFREQMEASUREMENTSYSiNFO_PRESENCE_FLAG;
        convert_InterFreqMeasurementSysInfo_HCS_RSCP_LCR_r4(
                &cpich_RSCP->interFreqMeasurementSysInfo,
                &cpich_rscp->inter_freq_measurement_sys_info);
    }

}

/******************************************************************************
 *   FUNCTION NAME: convert_NewIntraFreqCellSI_HCS_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_HCS_ECN0_LCR_r4
 *       to newintrafreqcellsi_hcs_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewIntraFreqCellSI_HCS_ECN0_LCR_r4
(
 UMTS_NewIntraFreqCellSI_HCS_ECN0_LCR_r4 *NewIntraFreqCellSI_HCS_ECN0_LCR_r4,
 newintrafreqcellsi_hcs_ecn0_lcr_r4_t *newintrafreqcellsi_hcs_ecn0_lcr_r4
 )
{
    newintrafreqcellsi_hcs_ecn0_lcr_r4->presence_bitmask = 0;

    if (NewIntraFreqCellSI_HCS_ECN0_LCR_r4->m.intraFreqCellIDPresent)
    {
        newintrafreqcellsi_hcs_ecn0_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTRAFREQCELLSI_HCS_ECNO_LCR_R4_INTRAFREQCELLID_PRESENCE_FLAG;

        newintrafreqcellsi_hcs_ecn0_lcr_r4->intrafreqcellid =
            NewIntraFreqCellSI_HCS_ECN0_LCR_r4->intraFreqCellID;
    }

    convert_cell_info_si_hcs_ecno_lcr_r4(
            &NewIntraFreqCellSI_HCS_ECN0_LCR_r4->cellInfo,
            &newintrafreqcellsi_hcs_ecn0_lcr_r4->cellInfo);
}

/******************************************************************************
 *   FUNCTION NAME: convert_NewIntraFreqCellSI_List_HCS_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_HCS_ECN0_LCR_r4
 *       newintrafreqcellsi_list_hcs_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewIntraFreqCellSI_List_HCS_ECN0_LCR_r4
(
 UMTS_NewIntraFreqCellSI_List_HCS_ECN0_LCR_r4 *newIntraFreqCellList,
 newintrafreqcellsi_list_hcs_ecn0_lcr_r4_t *new_intra_freq_cell_list
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewIntraFreqCellSI_HCS_ECN0_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    new_intra_freq_cell_list->count = newIntraFreqCellList->count;
    pnode = newIntraFreqCellList->head;

    for (index=0; index < new_intra_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewIntraFreqCellSI_HCS_ECN0_LCR_r4*)pnode->data;

        convert_NewIntraFreqCellSI_HCS_ECN0_LCR_r4(
                pdata0,
                &(new_intra_freq_cell_list->newintrafreqcellsi_hcs_ecn0_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqCellInfoSI_List_HCS_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqCellInfoSI_List_HCS_ECN0_LCR_r4
 *       to intrafreqcellinfosi_list_hcs_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqCellInfoSI_List_HCS_ECN0_LCR_r4
(
 UMTS_IntraFreqCellInfoSI_List_HCS_ECN0_LCR_r4 *intraFreqCellInfoSI_List,
 intrafreqcellinfosi_list_hcs_ecn0_lcr_r4_t  *intra_freq_cell_info_si_list
 )
{
    intra_freq_cell_info_si_list->presence_bitmask = 0;

    if (intraFreqCellInfoSI_List->m.removedIntraFreqCellListPresent)
    {
        intra_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTRAFREQCELLINFOSI_LIST_HCS_ECN0_LCR_R4_REMOVEDINTRAFREQCELLLIST_PRESENCE_FLAG;

        convert_RemovedIntraFreqCellList(
                &intraFreqCellInfoSI_List->removedIntraFreqCellList,
                &intra_freq_cell_info_si_list->removed_intra_freq_cell_list);
    }

    convert_NewIntraFreqCellSI_List_HCS_ECN0_LCR_r4(
            &intraFreqCellInfoSI_List->newIntraFreqCellList,
            &intra_freq_cell_info_si_list->new_intra_freq_cell_list);
}

/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqMeasurementSysInfo_HCS_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasurementSysInfo_HCS_ECN0_LCR_r4
 *       intrafreqmeasurementsysinfo_hcs_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_IntraFreqMeasurementSysInfo_HCS_ECN0_LCR_r4
(
 UMTS_IntraFreqMeasurementSysInfo_HCS_ECN0_LCR_r4 *intraFreqMeasurementSysInfo,
 intrafreqmeasurementsysinfo_hcs_ecn0_lcr_r4_t *intra_freq_measurement_sys_info
 )
{
    intra_freq_measurement_sys_info->presence_bitmask = 0;
    intra_freq_measurement_sys_info->intra_freq_measurement_id =
        intraFreqMeasurementSysInfo->intraFreqMeasurementID;

    if (intraFreqMeasurementSysInfo->m.intraFreqCellInfoSI_ListPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_ECN0_LCR_R4_INTRAFREQCELLINFOSI_LIST_PRESENCE_FLAG;
        convert_IntraFreqCellInfoSI_List_HCS_ECN0_LCR_r4(
                &intraFreqMeasurementSysInfo->intraFreqCellInfoSI_List,
                &intra_freq_measurement_sys_info->intra_freq_cell_info_si_list);
    }
    if (intraFreqMeasurementSysInfo->m.intraFreqMeasQuantityPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_ECN0_LCR_R4_INTRAFREQMEASQUANTITY_PRESENCE_FLAG;

        convert_IntraFreqMeasQuantity(
                &intraFreqMeasurementSysInfo->intraFreqMeasQuantity,
                &intra_freq_measurement_sys_info->intra_freq_meas_quantity);
    }
    if (intraFreqMeasurementSysInfo->m.intraFreqReportingQuantityForRACHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_ECN0_LCR_R4_INTRAFREQREPORTINGQUANTITYFORRACH_PRESENCE_FLAG;

        convert_IntraFreqReportingQuantityForRACH(
                &intraFreqMeasurementSysInfo->intraFreqReportingQuantityForRACH,
                &intra_freq_measurement_sys_info->intra_freq_reporting_quantity_for_rach);
    }
    if (intraFreqMeasurementSysInfo->m.maxReportedCellsOnRACHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_ECN0_LCR_R4_MAXREPORTEDCELLSONRACH_PRESENCE_FLAG;

        intra_freq_measurement_sys_info->max_reported_cells_on_rach =
            intraFreqMeasurementSysInfo->maxReportedCellsOnRACH;
    }
    if (intraFreqMeasurementSysInfo->m.reportingInfoForCellDCHPresent)
    {
        intra_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTRAFREQMEASUREMENTSYSINFO_HCS_ECN0_LCR_R4_REPORTINGINFOFORCELLDCH_PRESENCE_FLAG;

        convert_ReportingInfoForCellDCH_LCR_r4(
                &intraFreqMeasurementSysInfo->reportingInfoForCellDCH,
                &intra_freq_measurement_sys_info->reporting_info_for_celldch);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellSI_HCS_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_HCS_ECN0_LCR_r4
 *       newinterfreqcellsi_hcs_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellSI_HCS_ECN0_LCR_r4
(
 UMTS_NewInterFreqCellSI_HCS_ECN0_LCR_r4 *NewInterFreqCellSI_HCS_ECN0_LCR_r4,
 newinterfreqcellsi_hcs_ecn0_lcr_r4_t *newinterfreqcellsi_hcs_ecn0_lcr_r4
 )
{
    newinterfreqcellsi_hcs_ecn0_lcr_r4->presence_bitmask = 0;
    if (NewInterFreqCellSI_HCS_ECN0_LCR_r4->m.interFreqCellIDPresent)
    {
        newinterfreqcellsi_hcs_ecn0_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTERFREQCELLSI_HCS_ECN0_LCR_R4_INTERFREQCELLID_PRESENCE_FLAG;
        newinterfreqcellsi_hcs_ecn0_lcr_r4->inter_freq_cell_id =
            NewInterFreqCellSI_HCS_ECN0_LCR_r4->interFreqCellID;
    }
    if (NewInterFreqCellSI_HCS_ECN0_LCR_r4->m.frequencyInfoPresent)
    {
        newinterfreqcellsi_hcs_ecn0_lcr_r4->presence_bitmask |=
            UMTS_SIB_NEWINTERFREQCELLSI_HCS_ECN0_LCR_R4_FREQUENCYINFO_PRESENCE_FLAG;
        convert_FrequencyInfo(
                &NewInterFreqCellSI_HCS_ECN0_LCR_r4->frequencyInfo,
                &newinterfreqcellsi_hcs_ecn0_lcr_r4->frequency_info);
    }

    convert_cell_info_si_hcs_ecno_lcr_r4(
            &NewInterFreqCellSI_HCS_ECN0_LCR_r4->cellInfo,
            &newinterfreqcellsi_hcs_ecn0_lcr_r4->cell_info);
}

/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellSI_List_HCS_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_HCS_ECN0_LCR_r4
 *       to newinterfreqcellsi_list_hcs_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellSI_List_HCS_ECN0_LCR_r4
(
 UMTS_NewInterFreqCellSI_List_HCS_ECN0_LCR_r4 *newInterFreqCellList,
 newinterfreqcellsi_list_hcs_ecn0_lcr_r4_t *new_inter_freq_cell_list
 )
{
    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewInterFreqCellSI_HCS_ECN0_LCR_r4     *pdata0 = NULL;
    U32                                 index;

    new_inter_freq_cell_list->count = newInterFreqCellList->count;
    pnode = newInterFreqCellList->head;

    for (index=0; index<new_inter_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewInterFreqCellSI_HCS_ECN0_LCR_r4*)pnode->data;

        convert_NewInterFreqCellSI_HCS_ECN0_LCR_r4(
                pdata0,
                &(new_inter_freq_cell_list->newinterfreqcellsi_hcs_ecn0_lcr_r4[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqCellInfoSI_List_HCS_ECN0_LCR
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqCellInfoSI_List_HCS_ECN0_LCR
 *       to interfreqcellinfosi_list_hcs_ecn0_lcr_t
 *
 *******************************************************************************/
void convert_InterFreqCellInfoSI_List_HCS_ECN0_LCR
(
 UMTS_InterFreqCellInfoSI_List_HCS_ECN0_LCR *interFreqCellInfoSI_List,
 interfreqcellinfosi_list_hcs_ecn0_lcr_t *inter_freq_cell_info_si_list
 )
{

    if (interFreqCellInfoSI_List->m.removedInterFreqCellListPresent)
    {
        inter_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTERFREQCELLINFOSI_LIST_HCS_ECN0_LCR_REMOVEDINTERFREQCELLLIST_PRESENCE_FLAG;

        convert_RemovedInterFreqCellList(
                &interFreqCellInfoSI_List->removedInterFreqCellList,
                &inter_freq_cell_info_si_list->removed_inter_freq_cell_list);
    }
    if (interFreqCellInfoSI_List->m.newInterFreqCellListPresent)
    {
        inter_freq_cell_info_si_list->presence_bitmask |=
            UMTS_SIB_INTERFREQCELLINFOSI_LIST_HCS_ECN0_LCR_NEWINTERFREQcELLLIST_PRESENCE_FLAG;

        convert_NewInterFreqCellSI_List_HCS_ECN0_LCR_r4(
                &interFreqCellInfoSI_List->newInterFreqCellList,
                &inter_freq_cell_info_si_list->new_inter_freq_cell_list);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqMeasurementSysInfo_HCS_ECN0_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqMeasurementSysInfo_HCS_ECN0_LCR_r4
 *       to interfreqmeasurementsysinfo_hcs_ecn0_lcr_r4_t
 *
 *******************************************************************************/
void convert_InterFreqMeasurementSysInfo_HCS_ECN0_LCR_r4
(
 UMTS_InterFreqMeasurementSysInfo_HCS_ECN0_LCR_r4 *interFreqMeasurementSysInfo,
 interfreqmeasurementsysinfo_hcs_ecn0_lcr_r4_t *inter_freq_measurement_sys_info
 )
{

    if (interFreqMeasurementSysInfo->m.interFreqCellInfoSI_ListPresent)
    {
        inter_freq_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTERFREQMEASUREMENTSYSINFO_HCS_ECN0_LCR_R4_INTERFREQCELLINFOSI_LIST_PRESENCE_FLAG;

        convert_InterFreqCellInfoSI_List_HCS_ECN0_LCR(
                &interFreqMeasurementSysInfo->interFreqCellInfoSI_List,
                &inter_freq_measurement_sys_info->inter_freq_cell_info_si_list);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0
 *       to measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_used_cellselectqualitymeasure_cpich_ec_no_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0 *cpich_Ec_N0,
 measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_used_cellselectqualitymeasure_cpich_ec_no_t *cpich_ec_n0
 )
{
    if (cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent)
    {
        cpich_ec_n0->presence_bitmask |=
            UMTS_SIB_MEASUREMENTCONTROLSYSINFO_LCR_R4_EXT_USE_OF_HCS_HCS_USED_CELLSELECTQUALITYMEASURE_CPICH_EC_NO_INTRAFREQMEASUREMENTSYSINFO_PRESENCE_FLAG;
        convert_IntraFreqMeasurementSysInfo_HCS_ECN0_LCR_r4(
                &cpich_Ec_N0->intraFreqMeasurementSysInfo,
                &cpich_ec_n0->intra_freq_measurement_sys_info);
    }
    if (cpich_Ec_N0->m.interFreqMeasurementSysInfoPresent)
    {
        cpich_ec_n0->presence_bitmask |=
            UMTS_SIB_MEASUREMENTCONTROLSYSINFO_LCR_R4_EXT_USE_OF_HCS_HCS_USED_CELLSELECTQUALITYMEASURE_CPICH_EC_NO_INTERFREQMEASUREMENTSYSINFO_PRESENCE_FLAG;
        convert_InterFreqMeasurementSysInfo_HCS_ECN0_LCR_r4(
                &cpich_Ec_N0->interFreqMeasurementSysInfo,
                &cpich_ec_n0->inter_freq_measurement_sys_info);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure
 *       to measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_used_cellselectqualitymeasure_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure *cellSelectQualityMeasure,
 measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_used_cellselectqualitymeasure_t *cell_select_quality_measure
 )
{
    cell_select_quality_measure->t =  cellSelectQualityMeasure->t;
    switch (cellSelectQualityMeasure->t)
    {
        case RRC_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP:
            convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP(
                    cellSelectQualityMeasure->u.cpich_RSCP,
                    &cell_select_quality_measure->u.cpich_rscp);
            break;
        case RRC_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0:
            convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0(
                    cellSelectQualityMeasure->u.cpich_Ec_N0,
                    &cell_select_quality_measure->u.cpich_ec_n0);
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure
 *       to measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_not_used_cellselectqualitymeasure_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure *cellSelectQualityMeasure,
 measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_not_used_cellselectqualitymeasure_t *cell_select_quality_measure
 )
{
    cell_select_quality_measure->t = cellSelectQualityMeasure->t;
    switch (cell_select_quality_measure->t)
    {
        case RRC_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP:
            convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP(
                    cellSelectQualityMeasure->u.cpich_RSCP,
                    &cell_select_quality_measure->u.cpich_rscp);
            break;
        case RRC_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0:
            convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0(
                    cellSelectQualityMeasure->u.cpich_Ec_N0,
                    &cell_select_quality_measure->u.cpich_ec_n0);
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used
 *       to measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_not_used_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used *asn_hcs_not_used,
 measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_not_used_t	*hcs_not_used
 )
{
    convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure(
            &asn_hcs_not_used->cellSelectQualityMeasure,
            &hcs_not_used->cell_select_quality_measure);
}

/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used
 *       to measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_used_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used *asn_hcs_used,
 measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_hcs_used_t  *umts_hcs_used
 )
{
    convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure(
            &asn_hcs_used->cellSelectQualityMeasure,
            &umts_hcs_used->cell_select_quality_measure);
}

/******************************************************************************
 *   FUNCTION NAME: conver_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS
 *       to measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_t
 *
 *******************************************************************************/
void conver_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS *use_of_HCS,
 measurementcontrolsysinfo_lcr_r4_ext_use_of_hcs_t    *use_of_hcs
 )
{
    use_of_hcs->t = use_of_HCS->t;
    switch(use_of_HCS->t)
    {
        case RRC_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used:

            convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used(
                    use_of_HCS->u.hcs_not_used,
                    &use_of_hcs->u.hcs_not_used);
            break;
        case RRC_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used:

            convert_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used(
                    use_of_HCS->u.hcs_used,
                    &use_of_hcs->u.hcs_used);
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_MeasurementControlSysInfo_LCR_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext
 *       to measurementcontrolsysinfo_lcr_r4_ext_t
 *
 *******************************************************************************/
void convert_MeasurementControlSysInfo_LCR_r4
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext *measurementControlSysInfo_LCR,
 measurementcontrolsysinfo_lcr_r4_ext_t	*measurement_control_sysinfo_lcr
 )
{
    conver_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS (
            &measurementControlSysInfo_LCR->use_of_HCS,
            &measurement_control_sysinfo_lcr->use_of_hcs);
}

/******************************************************************************
 *   FUNCTION NAME: convert_fach_MeasurementOccasionInfo_LCR_Ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FACH_MeasurementOccasionInfo_LCR_r4_ext
 *       to fach_measurementoccasioninfo_lcr_r4_ext_t
 *
 *******************************************************************************/
void convert_fach_MeasurementOccasionInfo_LCR_Ext
(
 UMTS_FACH_MeasurementOccasionInfo_LCR_r4_ext *fach_MeasurementOccasionInfo_LCR_Ext,
 fach_measurementoccasioninfo_lcr_r4_ext_t    *fach_measurement_occasioninfo_lcr_ext
 )
{
    fach_measurement_occasioninfo_lcr_ext->inter_freq_tdd128_meas_ind =
        fach_MeasurementOccasionInfo_LCR_Ext->inter_freq_TDD128_meas_ind;
}

/******************************************************************************
 *   FUNCTION NAME: convert_CellSelectReselectInfo_v590ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *      UMTS_CellSelectReselectInfo_v590ext
 *      cellselectreselectinfo_v590ext_t
 *
 *******************************************************************************/
void convert_CellSelectReselectInfo_v590ext
(
 UMTS_CellSelectReselectInfo_v590ext *CellSelectReselectInfo_v590ext,
 cellselectreselectinfo_v590ext_t  *cellselectreselectinfo_v590ext
 )
{

    if (CellSelectReselectInfo_v590ext->m.deltaQrxlevminPresent)
    {
        cellselectreselectinfo_v590ext->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFO_V590EXT_DELTAQRXLEVMIN_PRESENCE_FLAG;
        cellselectreselectinfo_v590ext->deltaqrxlevmin =
            CellSelectReselectInfo_v590ext->deltaQrxlevmin;
    }
    if (CellSelectReselectInfo_v590ext->m.deltaQhcsPresent)
    {
        cellselectreselectinfo_v590ext->presence_bitmask |=
            UMTS_SIB_CELLSELECTRESELECTINFO_V590EXT_DELTAQHCS_PRESENCE_FLAG;
        cellselectreselectinfo_v590ext->deltaqhcs =
            CellSelectReselectInfo_v590ext->deltaQhcs;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext
 *       to sysinfotype11_v590ext_ies_newintrafrequencycellinfolist_v590ext_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext
(
 UMTS_SysInfoType11_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext *newIntraFrequencyCellInfoList_v590ext,
 sysinfotype11_v590ext_ies_newintrafrequencycellinfolist_v590ext_t    *new_intra_frequency_cell_info_list_v590ext
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_CellSelectReselectInfo_v590ext     *pdata0 = NULL;
    U32                                 index;

    new_intra_frequency_cell_info_list_v590ext->count = newIntraFrequencyCellInfoList_v590ext->count;
    pnode = newIntraFrequencyCellInfoList_v590ext->head;

    for (index=0; index<new_intra_frequency_cell_info_list_v590ext->count; index++)
    {
        pdata0 = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_CellSelectReselectInfo_v590ext(
                pdata0,
                &(new_intra_frequency_cell_info_list_v590ext->cellselectreselectinfo_v590ext[index]));

        pnode = pnode->next;
    }

    return;

}


/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v590ext_IEs_newInterFrequencyCellInfoList_v590ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v590ext_IEs_newInterFrequencyCellInfoList_v590ext
 *       to sysinfotype11_v590ext_ies_newinterfrequencycellinfolist_v590ext_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v590ext_IEs_newInterFrequencyCellInfoList_v590ext
(
 UMTS_SysInfoType11_v590ext_IEs_newInterFrequencyCellInfoList_v590ext *newInterFrequencyCellInfoList_v590ext,
 sysinfotype11_v590ext_ies_newinterfrequencycellinfolist_v590ext_t    *new_inter_frequency_cell_info_list_v590ext
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_CellSelectReselectInfo_v590ext     *pdata0 = NULL;
    U32                                 index;

    new_inter_frequency_cell_info_list_v590ext->count = newInterFrequencyCellInfoList_v590ext->count;
    pnode = newInterFrequencyCellInfoList_v590ext->head;

    for (index=0; index<new_inter_frequency_cell_info_list_v590ext->count; index++)
    {
        pdata0 = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_CellSelectReselectInfo_v590ext(
                pdata0,
                &(new_inter_frequency_cell_info_list_v590ext->cellselectreselectinfo_v590ext[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v590ext_IEs_newInterRATCellInfoList_v590ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v590ext_IEs_newInterRATCellInfoList_v590ext
 *       to sysinfotype11_v590ext_ies_newinterratcellinfolist_v590ext_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v590ext_IEs_newInterRATCellInfoList_v590ext
(
 UMTS_SysInfoType11_v590ext_IEs_newInterRATCellInfoList_v590ext *newInterRATCellInfoList_v590ext,
 sysinfotype11_v590ext_ies_newinterratcellinfolist_v590ext_t    *newinterratcell_info_list_v590ext
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_CellSelectReselectInfo_v590ext     *pdata0 = NULL;
    U32                                 index;

    newinterratcell_info_list_v590ext->count = newInterRATCellInfoList_v590ext->count;
    pnode = newInterRATCellInfoList_v590ext->head;

    for (index=0; index<newinterratcell_info_list_v590ext->count; index++)
    {
        pdata0 = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_CellSelectReselectInfo_v590ext(
                pdata0,
                &(newinterratcell_info_list_v590ext->cellselectreselectinfo_v590ext[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_Intra_FreqEventCriteriaList_v590ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Intra_FreqEventCriteriaList_v590ext
 *       to intra_freqeventcriterialist_v590ext_t
 *
 *******************************************************************************/
void convert_Intra_FreqEventCriteriaList_v590ext
(
 UMTS_Intra_FreqEventCriteriaList_v590ext *intraFreqEventCriteriaList_v590ext,
 intra_freqeventcriterialist_v590ext_t *intra_freq_event_criteria_list_v590ext
 )
{
    intra_freq_event_criteria_list_v590ext->n = intraFreqEventCriteriaList_v590ext->n;
    memcpy(intra_freq_event_criteria_list_v590ext->elem, 
            intraFreqEventCriteriaList_v590ext->elem ,
            (intraFreqEventCriteriaList_v590ext->n * sizeof(deltarscp_t)));
}

/******************************************************************************
 *   FUNCTION NAME: convert_PeriodicReportingInfo_1b
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PeriodicReportingInfo_1b
 *       to periodicreportinginfo_1b_t
 *
 *******************************************************************************/
void convert_PeriodicReportingInfo_1b
(
 UMTS_PeriodicReportingInfo_1b *periodicReportingInfo_1b,
 periodicreportinginfo_1b_t    *periodic_reporting_info_1b
 )
{
    periodic_reporting_info_1b->reporting_amount =
        periodicReportingInfo_1b->reportingAmount;
    periodic_reporting_info_1b->reporting_interval =
        periodicReportingInfo_1b->reportingInterval;
}


/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqReportingCriteria_1b_r5
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingCriteria_1b_r5
 *       to intrafreqreportingcriteria_1b_r5_t
 *
 *******************************************************************************/
void convert_IntraFreqReportingCriteria_1b_r5
(
 UMTS_IntraFreqReportingCriteria_1b_r5 *intraFreqReportingCriteria_1b_r5,
 intrafreqreportingcriteria_1b_r5_t *intra_freq_reporting_criteria_1b_r5
 )
{
    convert_PeriodicReportingInfo_1b(
            &intraFreqReportingCriteria_1b_r5->periodicReportingInfo_1b,
            &intra_freq_reporting_criteria_1b_r5->periodic_reporting_info_1b);
}


/******************************************************************************
 *   FUNCTION NAME: convert_IntraFreqEvent_1d_r5
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqEvent_1d_r5
 *       to intrafreqevent_1d_r5_t
 *
 *******************************************************************************/
void convert_IntraFreqEvent_1d_r5
(
 UMTS_IntraFreqEvent_1d_r5 *intraFreqEvent_1d_r5,
 intrafreqevent_1d_r5_t *intra_freq_event_1d_r5
 )
{

    if (intraFreqEvent_1d_r5->m.triggeringConditionPresent)
    {
        intra_freq_event_1d_r5->presence_bitmask |= 
            UMTS_SIB_INTRAFREQEVENT_1D_R5_TRIGGERINGCONDITION_PRESENCE_FLAG;
        intra_freq_event_1d_r5->triggering_condition =
            intraFreqEvent_1d_r5->triggeringCondition;
    }
    if (intraFreqEvent_1d_r5->m.useCIOPresent)
    {
        intra_freq_event_1d_r5->presence_bitmask |= 
            UMTS_SIB_INTRAFREQEVENT_1D_R5_USECIO_PRESENCE_FLAG;
        intra_freq_event_1d_r5->use_cio = intraFreqEvent_1d_r5->useCIO;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v590ext_IEs
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v590ext_IEs
 *       to sysinfotype11_v590ext_ies_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v590ext_IEs
(
 UMTS_SysInfoType11_v590ext_IEs *sysInfoType11_v590ext,
 sysinfotype11_v590ext_ies_t    *sys_info_type11_v590ext
 )
{

    if (sysInfoType11_v590ext->m.newIntraFrequencyCellInfoList_v590extPresent)
    {
        sys_info_type11_v590ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V590EXT_IES_NEWINTRAFREQUENCYCELLINFOLIST_V590EXT_PRESENCE_FLAG;
        convert_SysInfoType11_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext(
                &sysInfoType11_v590ext->newIntraFrequencyCellInfoList_v590ext,
                &sys_info_type11_v590ext->new_intra_frequency_cell_info_list_v590ext);
    }
    if (sysInfoType11_v590ext->m.newInterFrequencyCellInfoList_v590extPresent)
    {
        sys_info_type11_v590ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V590EXT_IES_NEWINTERFREQUENCYCELLINFOLIST_V590EXT_PRESENCE_FLAG;
        convert_SysInfoType11_v590ext_IEs_newInterFrequencyCellInfoList_v590ext(
                &sysInfoType11_v590ext->newInterFrequencyCellInfoList_v590ext,
                &sys_info_type11_v590ext->new_inter_frequency_cell_info_list_v590ext);
    }
    if (sysInfoType11_v590ext->m.newInterRATCellInfoList_v590extPresent)
    {
        sys_info_type11_v590ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V590EXT_IES_NEWINTERRATCELLINFOLIST_V590EXT_PRESENCE_FLAG;
        convert_SysInfoType11_v590ext_IEs_newInterRATCellInfoList_v590ext(
                &sysInfoType11_v590ext->newInterRATCellInfoList_v590ext,
                &sys_info_type11_v590ext->newinterratcell_info_list_v590ext);
    }
    if (sysInfoType11_v590ext->m.intraFreqEventCriteriaList_v590extPresent)
    {
        sys_info_type11_v590ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V590EXT_IES_INTRAFREQEVENTCRITERIALIST_V590EXT_PRESENCE_FLAG;

        convert_Intra_FreqEventCriteriaList_v590ext(
                &sysInfoType11_v590ext->intraFreqEventCriteriaList_v590ext,
                &sys_info_type11_v590ext->intra_freq_event_criteria_list_v590ext);
    }
    if (sysInfoType11_v590ext->m.intraFreqReportingCriteria_1b_r5Present)
    {
        sys_info_type11_v590ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V590EXT_IES_INTRAFREQREPORTINGcRITERIA_1B_R5_PRESENCE_FLAG;

        convert_IntraFreqReportingCriteria_1b_r5(
                &sysInfoType11_v590ext->intraFreqReportingCriteria_1b_r5,
                &sys_info_type11_v590ext->intra_freq_reporting_criteria_1b_r5);
    }
    if (sysInfoType11_v590ext->m.intraFreqEvent_1d_r5Present)
    {
        sys_info_type11_v590ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V590EXT_IES_INTRAFREQEVENT_1D_R5_PRESENCE_FLAG;

        convert_IntraFreqEvent_1d_r5(
                &sysInfoType11_v590ext->intraFreqEvent_1d_r5,
                &sys_info_type11_v590ext->intra_freq_event_1d_r5);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqRACHReportingInfo_modeSpecificInfo_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqRACHReportingInfo_modeSpecificInfo_fdd
 *       to interfreqrachreportinginfo_modespecificinfo_fdd_t
 *
 *******************************************************************************/
void convert_InterFreqRACHReportingInfo_modeSpecificInfo_fdd
(
 UMTS_InterFreqRACHReportingInfo_modeSpecificInfo_fdd *asn_fdd,
 interfreqrachreportinginfo_modespecificinfo_fdd_t *umts_fdd
 )
{
    umts_fdd->inter_freq_rep_quantityrach_fdd = asn_fdd->interFreqRepQuantityRACH_FDD;
}


/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqRepQuantityRACH_TDDList
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqRepQuantityRACH_TDDList
 *       to interfreqrepquantityrach_tddlist_t
 *
 *******************************************************************************/
void convert_InterFreqRepQuantityRACH_TDDList
(
 UMTS_InterFreqRepQuantityRACH_TDDList *interFreqRepQuantityRACH_TDDList,
 interfreqrepquantityrach_tddlist_t   *inter_freq_repquantityrach_tdd_list
 )
{
    inter_freq_repquantityrach_tdd_list->n = interFreqRepQuantityRACH_TDDList->n;
    memcpy(inter_freq_repquantityrach_tdd_list->elem,
            interFreqRepQuantityRACH_TDDList->elem,
            interFreqRepQuantityRACH_TDDList->n * sizeof(U32));
}

/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqRACHReportingInfo_modeSpecificInfo_tdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqRACHReportingInfo_modeSpecificInfo_tdd
 *       to interfreqrachreportinginfo_modespecificinfo_tdd_t
 *
 *******************************************************************************/
void convert_InterFreqRACHReportingInfo_modeSpecificInfo_tdd
(
 UMTS_InterFreqRACHReportingInfo_modeSpecificInfo_tdd *asn_tdd,
 interfreqrachreportinginfo_modespecificinfo_tdd_t *umts_tdd
 )
{
    convert_InterFreqRepQuantityRACH_TDDList(
            &asn_tdd->interFreqRepQuantityRACH_TDDList,
            &umts_tdd->inter_freq_repquantityrach_tdd_list);

}

/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqRACHReportingInfo_modeSpecificInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqRACHReportingInfo_modeSpecificInfo
 *       to interfreqrachreportinginfo_modespecificinfo_t
 *
 *******************************************************************************/
void convert_InterFreqRACHReportingInfo_modeSpecificInfo
(
 UMTS_InterFreqRACHReportingInfo_modeSpecificInfo *modeSpecificInfo,
 interfreqrachreportinginfo_modespecificinfo_t    *mode_specific_info
 )
{
    mode_specific_info->t = modeSpecificInfo->t;

    switch(modeSpecificInfo->t)
    {

        case RRC_UMTS_InterFreqRACHReportingInfo_modeSpecificInfo_fdd:
            convert_InterFreqRACHReportingInfo_modeSpecificInfo_fdd(
                    modeSpecificInfo->u.fdd,
                    &mode_specific_info->u.fdd);
            break;
        case RRC_UMTS_InterFreqRACHReportingInfo_modeSpecificInfo_tdd:
            convert_InterFreqRACHReportingInfo_modeSpecificInfo_tdd(
                    modeSpecificInfo->u.tdd,
                    &mode_specific_info->u.tdd);
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_InterFreqRACHReportingInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqRACHReportingInfo
 *       to interfreqrachreportinginfo_t
 *
 *******************************************************************************/
void convert_InterFreqRACHReportingInfo
(
 UMTS_InterFreqRACHReportingInfo *interFreqRACHReportingInfo,
 interfreqrachreportinginfo_t *inter_freq_rachreporting_info
 )
{
    inter_freq_rachreporting_info->inter_freqrachreporting_threshold =
        interFreqRACHReportingInfo->interFreqRACHReportingThreshold;

    inter_freq_rachreporting_info->max_reported_cells_on_rach_inter_freq =
        interFreqRACHReportingInfo->maxReportedCellsOnRACHinterFreq;

    convert_InterFreqRACHReportingInfo_modeSpecificInfo(
            &interFreqRACHReportingInfo->modeSpecificInfo,
            &inter_freq_rachreporting_info->mode_specific_info);
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v6b0ext_IEs
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v6b0ext_IEs
 *       to sysinfotype11_v6b0ext_ies_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v6b0ext_IEs
(
 UMTS_SysInfoType11_v6b0ext_IEs *sysInfoType11_v6b0ext,
 sysinfotype11_v6b0ext_ies_t *sys_info_type11_v6b0ext
 )
{
    if (sysInfoType11_v6b0ext->m.interFreqRACHReportingInfoPresent)
    {
        sys_info_type11_v6b0ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V6B0EXT_IES_INTERFREQRACHREPORTINGINFO_PRESENCE_FLAG;
        convert_InterFreqRACHReportingInfo(
                &sysInfoType11_v6b0ext->interFreqRACHReportingInfo,
                &sys_info_type11_v6b0ext->inter_freq_rachreporting_info);
    }
}


/******************************************************************************
 *   FUNCTION NAME: convert_MBSFNFrequency
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MBSFNFrequency
 *       to mbsfnfrequency_t
 *
 *******************************************************************************/
void convert_MBSFNFrequency
(
 UMTS_MBSFNFrequency *MBSFNFrequency,
 mbsfnfrequency_t *mbsfnfrequency
 )
{
    if (MBSFNFrequency->m.cellParametersIDPresent)
    {
        mbsfnfrequency->presence_bitmask |=
            UMTS_SIB_MBSFNFREQUENCY_CELLPARAMETERSID_PRESENCE_FLAG;
        mbsfnfrequency->cellparametersid = 
            MBSFNFrequency->cellParametersID;
    }

    convert_FrequencyInfo(
            &MBSFNFrequency->frequencyInfo,
            &mbsfnfrequency->frequencyinfo);
}

/******************************************************************************
 *   FUNCTION NAME: convert_MBSFNFrequencyList
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MBSFNFrequencyList
 *       to mbsfnfrequencylist_t
 *
 *******************************************************************************/
void convert_MBSFNFrequencyList
(
 UMTS_MBSFNFrequencyList *mbsfnFrequencyList,
 mbsfnfrequencylist_t  *mbsfn_frequency_list
 )
{
    OSRTDListNode                       *pnode  = NULL;
    UMTS_MBSFNFrequency     *pdata0 = NULL;
    U32                                 index;

    mbsfn_frequency_list->count = mbsfnFrequencyList->count;
    pnode = mbsfnFrequencyList->head;

    for (index=0; index<mbsfn_frequency_list->count; index++)
    {
        pdata0 = (UMTS_MBSFNFrequency*)pnode->data;

        convert_MBSFNFrequency(
                pdata0,
                &(mbsfn_frequency_list->mbsfnfrequency[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v770ext_IEs
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v770ext_IEs
 *       to sysinfotype11_v770ext_ies_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v770ext_IEs
(
 UMTS_SysInfoType11_v770ext_IEs *sysInfoType11_v770ext,
 sysinfotype11_v770ext_ies_t *sys_info_type11_v770ext
 )
{
    if (sysInfoType11_v770ext->m.mbsfnFrequencyListPresent)
    {
        sys_info_type11_v770ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V770EXT_IES_MBSFNFREQUENCYLIST_PRESENCE_FLAG;
        convert_MBSFNFrequencyList(
                &sysInfoType11_v770ext->mbsfnFrequencyList,
                &sys_info_type11_v770ext->mbsfn_frequency_list);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCell_v7b0ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCell_v7b0ext
 *       to newinterfreqcell_v7b0ext_t
 *
 *******************************************************************************/
void convert_NewInterFreqCell_v7b0ext
(
 UMTS_NewInterFreqCell_v7b0ext *NewInterFreqCell_v7b0ext,
 newinterfreqcell_v7b0ext_t   *newinterfreqcell_v7b0ext
 )
{
    newinterfreqcell_v7b0ext->intrasecondaryfreqindicator =
        NewInterFreqCell_v7b0ext->intraSecondaryFreqIndicator;
}

/******************************************************************************
 *   FUNCTION NAME: convert_NewInterFreqCellList_v7b0ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellList_v7b0ext
 *       to newinterfreqcelllist_v7b0ext_t
 *
 *******************************************************************************/
void convert_NewInterFreqCellList_v7b0ext
(
 UMTS_NewInterFreqCellList_v7b0ext *newInterFreqCellList,
 newinterfreqcelllist_v7b0ext_t   *new_inter_freq_cell_list
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_NewInterFreqCell_v7b0ext     *pdata0 = NULL;
    U32                                 index;

    new_inter_freq_cell_list->count = newInterFreqCellList->count;
    pnode = newInterFreqCellList->head;

    for (index=0; index < new_inter_freq_cell_list->count; index++)
    {
        pdata0 = (UMTS_NewInterFreqCell_v7b0ext*)pnode->data;

        convert_NewInterFreqCell_v7b0ext(
                pdata0,
                &(new_inter_freq_cell_list->newinterfreqcell_v7b0ext[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v7b0ext_IEs
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v7b0ext_IEs
 *       to sysinfotype11_v7b0ext_ies_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v7b0ext_IEs
(
 UMTS_SysInfoType11_v7b0ext_IEs *sysInfoType11_v7b0ext,
 sysinfotype11_v7b0ext_ies_t *sys_info_type11_v7b0ext
 )
{
    if (sysInfoType11_v7b0ext->m.newInterFreqCellListPresent)
    {
        sys_info_type11_v7b0ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V7B0EXT_IES_NEWINTERFREQCELLLIST_PRESENCE_FLAG;
        convert_NewInterFreqCellList_v7b0ext(
                &sysInfoType11_v7b0ext->newInterFreqCellList,
                &sys_info_type11_v7b0ext->new_inter_freq_cell_list);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_MBSFNFrequency_v860ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MBSFNFrequency_v860ext
 *       mbsfnfrequency_v860ext_t
 *
 *******************************************************************************/
void convert_MBSFNFrequency_v860ext
(
 UMTS_MBSFNFrequency_v860ext *MBSFNFrequency_v860ext,
 mbsfnfrequency_v860ext_t *mbsfnfrequency_v860ext
 )
{
    if (MBSFNFrequency_v860ext->m.imb_IndicationPresent)
    {
        mbsfnfrequency_v860ext->imb_indication =
            MBSFNFrequency_v860ext->imb_Indication;

        mbsfnfrequency_v860ext->presence_bitmask |=
            UMTS_SIB_MBSFNFREQUENCY_V860EXT_IMB_INDICATION_PRESENCE_FLAG;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_MBSFNFrequencyList_v860ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MBSFNFrequencyList_v860ext
 *       to mbsfnfrequencylist_v860ext_t
 *
 *******************************************************************************/
void convert_MBSFNFrequencyList_v860ext
(
 UMTS_MBSFNFrequencyList_v860ext *mbsfnFrequencyList,
 mbsfnfrequencylist_v860ext_t  *mbsfn_frequency_list
 )
{

    OSRTDListNode                       *pnode  = NULL;
    UMTS_MBSFNFrequency_v860ext     *pdata0 = NULL;
    U32                                 index;

    mbsfn_frequency_list->count = mbsfnFrequencyList->count;
    pnode = mbsfnFrequencyList->head;

    for (index=0; index<mbsfn_frequency_list->count; index++)
    {
        pdata0 = (UMTS_MBSFNFrequency_v860ext*)pnode->data;

        convert_MBSFNFrequency_v860ext(
                pdata0,
                &(mbsfn_frequency_list->mbsfnfrequency_v860ext[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v860ext_IEs
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v860ext_IEs
 *       to sysinfotype11_v860ext_ies_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v860ext_IEs
(
 UMTS_SysInfoType11_v860ext_IEs *sysInfoType11_v860ext,
 sysinfotype11_v860ext_ies_t  *sys_info_type11_v860ext
 )
{

    if (sysInfoType11_v860ext->m.mbsfnFrequencyListPresent)
    {
        sys_info_type11_v860ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V860EXT_IES_MBSFNFREQUENCYLIST_PRESENCE_FLAG;
        convert_MBSFNFrequencyList_v860ext(
                &sysInfoType11_v860ext->mbsfnFrequencyList,
                &sys_info_type11_v860ext->mbsfn_frequency_list);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions
 *       to  sysinfotype11_v4b0nces_v590nce_v690nces_v6b0nces_v770nces_v7b0nces_v860nces_nces_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions
(
 UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions *nonCriticalExtensions,
 sysinfotype11_v4b0nces_v590nce_v690nces_v6b0nces_v770nces_v7b0nces_v860nces_nces_t   *non_critical_extensions
 )
{
    non_critical_extensions->__dummy__ = nonCriticalExtensions->__dummy__;
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions
 *       to sysinfotype11_v4b0nces_v590nce_v690nces_v6b0nces_v770nces_v7b0nces_v860nces_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions
(
 UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions *v860NonCriticalExtensions,
 sysinfotype11_v4b0nces_v590nce_v690nces_v6b0nces_v770nces_v7b0nces_v860nces_t *v860_non_critical_extensions
 )
{
    convert_SysInfoType11_v860ext_IEs(
            &v860NonCriticalExtensions->sysInfoType11_v860ext,
            &v860_non_critical_extensions->sys_info_type11_v860ext);

    if (v860NonCriticalExtensions->m.nonCriticalExtensionsPresent)
    {
        v860_non_critical_extensions->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V4B0NCES_V590NCE_V690NCES_V6B0NCES_V770NCES_V7B0NCES_V860NCES_NONCRITICALEXTENSIONS_PRESENCE_FLAG;

        convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions(
                &v860NonCriticalExtensions->nonCriticalExtensions,
                &v860_non_critical_extensions->non_critical_extensions);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions
 *       to sysinfotype11_v4b0nces_v590nce_v690nces_v6b0nces_v770nces_v7b0nces_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions
(
 UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions *v7b0NonCriticalExtensions,
 sysinfotype11_v4b0nces_v590nce_v690nces_v6b0nces_v770nces_v7b0nces_t *v7b0_non_critical_extensions
 )
{

    convert_SysInfoType11_v7b0ext_IEs(
            &v7b0NonCriticalExtensions->sysInfoType11_v7b0ext,
            &v7b0_non_critical_extensions->sys_info_type11_v7b0ext);

    if (v7b0NonCriticalExtensions->m.v860NonCriticalExtensionsPresent)
    {

        v7b0_non_critical_extensions->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V4B0NCES_V590NCE_V690NCES_V6B0NCES_V770NCES_V7B0NCES_V860NONCRITICALEXTENSIONS_PRESENCE_FLAG;

        convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions_v860NonCriticalExtensions(
                &v7b0NonCriticalExtensions->v860NonCriticalExtensions,
                &v7b0_non_critical_extensions->v860_non_critical_extensions);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions
 *       to sysinfotype11_v4b0nces_v590nce_v690nces_v6b0nces_v770nces_t
 *
 *******************************************************************************/
void convert_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions
(
 UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions *v770NonCriticalExtensions,
 sysinfotype11_v4b0nces_v590nce_v690nces_v6b0nces_v770nces_t  *v770noncritical_extensions
 )
{
    convert_SysInfoType11_v770ext_IEs(
            &v770NonCriticalExtensions->sysInfoType11_v770ext,
            &v770noncritical_extensions->sys_info_type11_v770ext);

    if (v770NonCriticalExtensions->m.v7b0NonCriticalExtensionsPresent)
    {
        v770noncritical_extensions->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V4B0NCES_V590NCE_V690NCES_V6B0NCES_V770NCES_V7B0NONCRITICALEXTENSIONS_PRESENCE_FLAG;

        convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions_v7b0NonCriticalExtensions(
                &v770NonCriticalExtensions->v7b0NonCriticalExtensions,
                &v770noncritical_extensions->v7b0_non_critical_extensions);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions
 *       sysinfotype11_v4b0nces_v590nces_v690nces_v6b0nces_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions
(
 UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions *v6b0NonCriticalExtensions,
 sysinfotype11_v4b0nces_v590nces_v690nces_v6b0nces_t  *v6b0_non_critical_extensions
 )
{
    convert_SysInfoType11_v6b0ext_IEs(
            &v6b0NonCriticalExtensions->sysInfoType11_v6b0ext,
            &v6b0_non_critical_extensions->sys_info_type11_v6b0ext);

    if (v6b0NonCriticalExtensions->m.v770NonCriticalExtensionsPresent)
    {
        v6b0_non_critical_extensions->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V4B0NCES_V590NCES_V690NCES_V6B0NCES_V770NONCRITICALEXTENSIONS_PRESENCE_FLAG;
        convert_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v770NonCriticalExtensions(
                &v6b0NonCriticalExtensions->v770NonCriticalExtensions,
                &v6b0_non_critical_extensions->v770noncritical_extensions);
    }

}

/******************************************************************************
 *   FUNCTION NAME: convert_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_fdd
 *       to dummy_interfreqrachreportinginfo_modespecificinfo_fdd_t
 *
 *******************************************************************************/
void convert_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_fdd
(
 UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_fdd *asn_fdd,
 dummy_interfreqrachreportinginfo_modespecificinfo_fdd_t *umts_fdd
 )
{
    umts_fdd->inter_freq_rep_quantity_rach_fdd =
        asn_fdd->interFreqRepQuantityRACH_FDD;
}

void convert_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_tdd(
        UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_tdd *asn_tdd,
        dummy_interfreqrachreportingInfo_modespecificinfo_tdd_t *umts_tdd)
{
    convert_InterFreqRepQuantityRACH_TDDList(
            &asn_tdd->interFreqRepQuantityRACH_TDDList,
            &umts_tdd->inter_freq_rep_quantity_rach_tdd_list);
}


/******************************************************************************
 *   FUNCTION NAME: convert_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo
 *       to dummy_interfreqrachreportinginfo_modespecificinfo_t
 *
 *******************************************************************************/
void convert_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo
(
 UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo *modeSpecificInfo,
 dummy_interfreqrachreportinginfo_modespecificinfo_t  *mode_specific_info
 )
{
    mode_specific_info->t = modeSpecificInfo->t;

    switch(modeSpecificInfo->t)
    {
        case RRC_UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_fdd:

            convert_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_fdd(
                    modeSpecificInfo->u.fdd, &mode_specific_info->u.fdd);
            break;
        case RRC_UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_tdd:

            convert_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_tdd(
                    modeSpecificInfo->u.tdd, &mode_specific_info->u.tdd);
            break;
        case RRC_UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_interFreqRACHReportingThreshold:

            mode_specific_info->u.inter_freqrachreporting_threshold =
                modeSpecificInfo->u.interFreqRACHReportingThreshold;
            break;
        case RRC_UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_maxReportedCellsOnRACHinterFreq:

            mode_specific_info->u.max_reported_cells_onrachinter_freq =
                modeSpecificInfo->u.maxReportedCellsOnRACHinterFreq;
            break;
        default:
            break;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_Dummy_InterFreqRACHReportingInfo
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Dummy_InterFreqRACHReportingInfo
 *       to dummy_interfreqrachreportinginfo_t
 *
 *******************************************************************************/
void convert_Dummy_InterFreqRACHReportingInfo
(
 UMTS_Dummy_InterFreqRACHReportingInfo *asn_dummy,
 dummy_interfreqrachreportinginfo_t   *umts_dummy
 )
{
    convert_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo(
            &asn_dummy->modeSpecificInfo,
            &umts_dummy->mode_specific_info);
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v690ext_IEs
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v690ext_IEs
 *       to sysinfotype11_v690ext_ies_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v690ext_IEs
(
 UMTS_SysInfoType11_v690ext_IEs *sysInfoType11_v690ext,
 sysinfotype11_v690ext_ies_t *sys_info_type11_v690ext
 )
{
    if (sysInfoType11_v690ext->m.dummyPresent)
    {
        sys_info_type11_v690ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V690EXT_IES_DUMMY_PRESENCE_FLAG;
        convert_Dummy_InterFreqRACHReportingInfo(
                &sysInfoType11_v690ext->dummy,
                &sys_info_type11_v690ext->dummy);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions
 *       to sysinfotype11_v4b0noncriticalextensions_v590noncriticalextension_v690noncriticalextensions_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions
(
 UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions *v690NonCriticalExtensions,
 sysinfotype11_v4b0noncriticalextensions_v590noncriticalextension_v690noncriticalextensions_t *v690_non_critical_extensions
 )
{

    convert_SysInfoType11_v690ext_IEs(
            &v690NonCriticalExtensions->sysInfoType11_v690ext,
            &v690_non_critical_extensions->sys_info_type11_v690ext);

    if (v690NonCriticalExtensions->m.v6b0NonCriticalExtensionsPresent)
    {
        v690_non_critical_extensions->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V4B0NONCRITICALEXTENSIONS_V590NONCRITICALEXTENSION_V690NONCRITICALEXTENSIONS_V6B0NONCRITICALEXTENSIONS_PRESENCE_FLAG;

        convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions(
                &v690NonCriticalExtensions->v6b0NonCriticalExtensions,
                &v690_non_critical_extensions->v6b0_non_critical_extensions);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension
 *       to sysinfotype11_v4b0_nc_extensions_v590_nc_extension_t
 *
 *******************************************************************************/
void convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension
(
 UMTS_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension *v590NonCriticalExtension,
 sysinfotype11_v4b0_nc_extensions_v590_nc_extension_t *v590_nc_extension
 )
{

    convert_SysInfoType11_v590ext_IEs(
            &v590NonCriticalExtension->sysInfoType11_v590ext,
            &v590_nc_extension->sys_info_type11_v590ext);
    if (v590NonCriticalExtension->m.v690NonCriticalExtensionsPresent)
    {
        v590_nc_extension->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V4B0_NC_EXTENSIONS_V590_NC_EXTENSION_V690NONCRITICALEXTENSIONS_PRESENCE_FLAG;
        convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions(
                &v590NonCriticalExtension->v690NonCriticalExtensions,
                &v590_nc_extension->v690_non_critical_extensions);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysInfoType11_v4b0ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0ext_IEs
 *       to sysinfotype11_v4b0ext_ies_t
 *
 *******************************************************************************/
void convert_sysInfoType11_v4b0ext
(
 UMTS_SysInfoType11_v4b0ext_IEs *sysInfoType11_v4b0ext,
 sysinfotype11_v4b0ext_ies_t    *sys_info_type11_v4b0ext
 )
{
    if (sysInfoType11_v4b0ext->m.fach_MeasurementOccasionInfo_LCR_ExtPresent)
    {
        sys_info_type11_v4b0ext->presence_bitmask |= 
            UMTS_SIB_SYSINFOTYPE11_V4B0EXT_IES_FACH_MEASUREMENTOCCASIONINFO_LCR_EXT_PRESENCE_FLAG;
        convert_fach_MeasurementOccasionInfo_LCR_Ext(
                &sysInfoType11_v4b0ext->fach_MeasurementOccasionInfo_LCR_Ext,
                &sys_info_type11_v4b0ext->fach_measurement_occasioninfo_lcr_ext);
    }

    convert_MeasurementControlSysInfo_LCR_r4(
            &sysInfoType11_v4b0ext->measurementControlSysInfo_LCR,
            &sys_info_type11_v4b0ext->measurement_control_sysinfo_lcr);
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype11_v4b0_nc_extensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11_v4b0NonCriticalExtensions
 *       to sysinfotype11_v4b0_nc_extensions_t
 *
 *******************************************************************************/
void convert_sysinfotype11_v4b0_nc_extensions
(
 UMTS_SysInfoType11_v4b0NonCriticalExtensions *v4b0NonCriticalExtensions,
 sysinfotype11_v4b0_nc_extensions_t  *sysinfotype11_v4b0_nc_extensions
 )
{
    if(v4b0NonCriticalExtensions->m.sysInfoType11_v4b0extPresent)
    {
        sysinfotype11_v4b0_nc_extensions->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V4B0_NC_EXTENSIONS_SYSINFOTYPE11_V4B0EXT_PRESENCE_FLAG;

        convert_sysInfoType11_v4b0ext(
                &v4b0NonCriticalExtensions->sysInfoType11_v4b0ext,
                &sysinfotype11_v4b0_nc_extensions->sys_info_type11_v4b0ext);
    }

    if(v4b0NonCriticalExtensions->m.v590NonCriticalExtensionPresent)
    {
        sysinfotype11_v4b0_nc_extensions->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE11_V4B0_NC_EXTENSIONS_V590NONCRITICALEXTENSION_PRESENCE_FLAG;

        convert_SysInfoType11_v4b0NonCriticalExtensions_v590NonCriticalExtension(
                &v4b0NonCriticalExtensions->v590NonCriticalExtension,
                &sysinfotype11_v4b0_nc_extensions->v590_nc_extension);
    }
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib11
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType11 to
 *       umts_sib_type_11_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       umts_sib11 - Pointer to decoded SIB11
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib11
(
 umts_sib_type_11_info_t    *umts_sib11
 )
{
    UMTS_SysInfoType11   sys_info_type_11;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_11_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_11, 0, sizeof(UMTS_SysInfoType11));

    if ( 0 != (asn1PD_UMTS_SysInfoType11(&ctxt, &sys_info_type_11)))
    {
        printf("umts_convert_sib11:asn decoding failed\n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType11("Decoded SysInfoType11\n", &sys_info_type_11);
    memset( umts_sib11, 0, sizeof(umts_sib_type_11_info_t));

    umts_sib11->sib12indicator = sys_info_type_11.sib12indicator;

    if (sys_info_type_11.m.fach_MeasurementOccasionInfoPresent)
    {
        umts_sib11->presence_bitmask |= 
            UMTS_SIB_TYPE_11_FACH_MEAS_OCCASION_INFO_PRESENCE_FLAG;

        convert_fach_measurement_occasion_info(
                &sys_info_type_11.fach_MeasurementOccasionInfo,
                &umts_sib11->fach_measurement_occasion_info);
    }

    convert_measurement_control_sys_info(
            &sys_info_type_11.measurementControlSysInfo ,
            &umts_sib11->measurement_control_sys_info );

    if (sys_info_type_11.m.v4b0NonCriticalExtensionsPresent)
    {
        umts_sib11->presence_bitmask |=
            UMTS_SIB_TYPE_11_V4B0_NC_EXTNS_PRESENCE_FLAG;
        convert_sysinfotype11_v4b0_nc_extensions(
                &sys_info_type_11.v4b0NonCriticalExtensions,
                &umts_sib11->sysinfotype11_v4b0_nc_extensions);
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: convert_fach_measurement_occasion_info_lcr_r4_ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FACH_MeasurementOccasionInfo_LCR_r4_ext to
 *       fach_measurement_occasion_info_lcr_r4_ext_t 
 *
 *******************************************************************************/
void convert_fach_measurement_occasion_info_lcr_r4_ext
(
 UMTS_FACH_MeasurementOccasionInfo_LCR_r4_ext   *pvalue,
 fach_measurement_occasion_info_lcr_r4_ext_t    *p_ext 
 )
{
    p_ext->inter_freq_tdd128_meas_ind =
        pvalue->inter_freq_TDD128_meas_ind;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_cell_info_si_list_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqCellInfoSI_List_RSCP_LCR_r4 to
 *       intra_freq_cell_info_si_list_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_cell_info_si_list_rscp_lcr_r4
(
 UMTS_IntraFreqCellInfoSI_List_RSCP_LCR_r4  *pvalue,
 intra_freq_cell_info_si_list_rscp_lcr_r4_t *p_lcr_r4 
 )
{
    if (pvalue->m.removedIntraFreqCellListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_CELL_INFO_SI_LIST_RSCP_LCR_R4_REMOVED_INTRA_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_intra_freq_cell_list(
                &pvalue->removedIntraFreqCellList,
                &p_lcr_r4->removed_intra_freq_cell_list);
    }

    convert_new_intra_freq_cell_si_list_rscp_lcr_r4(
            &pvalue->newIntraFreqCellList,
            &p_lcr_r4->new_intra_freq_cell_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_forbidden_affect_cell_list_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ForbiddenAffectCellList_LCR_r4 to
 *       forbidden_affect_cell_list_lcr_r4_t 
 *
 *******************************************************************************/
void convert_forbidden_affect_cell_list_lcr_r4
(
 UMTS_ForbiddenAffectCellList_LCR_r4    *pvalue,
 forbidden_affect_cell_list_lcr_r4_t    *p_lcr_r4 
 )
{
    UMTS_ForbiddenAffectCell_LCR_r4 *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ForbiddenAffectCell_LCR_r4*)pnode->data;

        convert_primary_ccpch_info_lcr_r4(
                &pdata->tdd,
                &p_lcr_r4->forbidden_affect_cell_lcr_r4[index].tdd);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_event_1a_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Event1a_LCR_r4 to
 *       event_1a_lcr_r4_t 
 *
 *******************************************************************************/
void convert_event_1a_lcr_r4
(
 UMTS_Event1a_LCR_r4    *pvalue,
 event_1a_lcr_r4_t      *p_event_1a_lcr_r4 
 )
{
    p_event_1a_lcr_r4->triggering_condition =
        pvalue->triggeringCondition;

    p_event_1a_lcr_r4->reporting_range =
        pvalue->reportingRange;

    if (pvalue->m.forbiddenAffectCellListPresent)
    {
        p_event_1a_lcr_r4->presence_bitmask |=
            UMTS_SIB_EVENT_1A_LCR_R4_FORBIDDEN_AFFECT_CELL_LIST_PRESENCE_FLAG;

        convert_forbidden_affect_cell_list_lcr_r4(
                &pvalue->forbiddenAffectCellList,
                &p_event_1a_lcr_r4->forbidden_affect_cell_list);
    }

    p_event_1a_lcr_r4->w = pvalue->w;

    p_event_1a_lcr_r4->report_deactivation_threshold =
        pvalue->reportDeactivationThreshold;

    p_event_1a_lcr_r4->reporting_amount =
        pvalue->reportingAmount;

    p_event_1a_lcr_r4->reporting_interval =
        pvalue->reportingInterval;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_event_1b_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Event1b_LCR_r4 to
 *       event_1b_lcr_r4_t 
 *
 *******************************************************************************/
void convert_event_1b_lcr_r4
(
 UMTS_Event1b_LCR_r4    *pvalue,
 event_1b_lcr_r4_t      *p_lcr_r4 
 )
{
    p_lcr_r4->triggering_condition =
        pvalue->triggeringCondition;

    p_lcr_r4->reporting_range =
        pvalue->reportingRange;

    if (pvalue->m.forbiddenAffectCellListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_EVENT_1B_LCR_R4_FORBIDDEN_AFFECT_CELL_LIST_PRESENCE_FLAG;

        convert_forbidden_affect_cell_list_lcr_r4(
                &pvalue->forbiddenAffectCellList,
                &p_lcr_r4->forbidden_affect_cell_list);
    }

    p_lcr_r4->w = pvalue->w;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_event_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqEvent_LCR_r4 to
 *       intra_freq_event_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_event_lcr_r4
(
 UMTS_IntraFreqEvent_LCR_r4     *pvalue,
 intra_freq_event_lcr_r4_t      *p_lcr_r4 
 )
{
    p_lcr_r4->t = pvalue->t;

    if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1a)
    {
        convert_event_1a_lcr_r4(
                pvalue->u.e1a,
                &p_lcr_r4->u.e1a);
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1b)
    {
        convert_event_1b_lcr_r4(
                pvalue->u.e1b,
                &p_lcr_r4->u.e1b); 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1c)
    {
        convert_event_1c(
                pvalue->u.e1c,
                &p_lcr_r4->u.e1c); 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1d)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1e)
    {
        convert_event_1e(
                pvalue->u.e1e,
                &p_lcr_r4->u.e1e); 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1f)
    {
        convert_event_1f(
                pvalue->u.e1f,
                &p_lcr_r4->u.e1f); 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1g)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1h)
    {
        p_lcr_r4->u.e1h = pvalue->u.e1h; 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_LCR_r4_e1i)
    {
        p_lcr_r4->u.e1i = pvalue->u.e1i; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_event_criteria_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqEventCriteria_LCR_r4 to
 *       intra_freq_event_criteria_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_event_criteria_lcr_r4
(
 UMTS_IntraFreqEventCriteria_LCR_r4     *pvalue,
 intra_freq_event_criteria_lcr_r4_t     *p_lcr_r4 
 )
{
    convert_intra_freq_event_lcr_r4(
            &pvalue->event,
            &p_lcr_r4->event);

    p_lcr_r4->hysteresis = pvalue->hysteresis;
    p_lcr_r4->timeToTrigger = pvalue->timeToTrigger;

    if (pvalue->m.reportingCellStatusPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_EVENT_CRITERIA_LCR_R4_REPORTING_CELL_STATUS_PRESENCE_FLAG;

        convert_reporting_cell_status(
                &pvalue->reportingCellStatus,
                &p_lcr_r4->reporting_cell_status);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_event_criteria_list_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqEventCriteriaList_LCR_r4 to
 *       intra_freq_event_criteria_list_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_event_criteria_list_lcr_r4
(
 UMTS_IntraFreqEventCriteriaList_LCR_r4     *pvalue,
 intra_freq_event_criteria_list_lcr_r4_t    *p_lcr_r4
 )
{
    UMTS_IntraFreqEventCriteria_LCR_r4  *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_IntraFreqEventCriteria_LCR_r4*)pnode->data;

        convert_intra_freq_event_criteria_lcr_r4(
                pdata,
                &p_lcr_r4->intra_freq_event_criteria_lcr_r4[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_criteria_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingCriteria_LCR_r4 to
 *       intra_freq_reporting_criteria_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_reporting_criteria_lcr_r4
(
 UMTS_IntraFreqReportingCriteria_LCR_r4 *pvalue,
 intra_freq_reporting_criteria_lcr_r4_t *p_lcr_r4 
 )
{
    if (pvalue->m.eventCriteriaListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_REPORTING_CRITERIA_LCR_R4_EVENT_CRITERIA_LIST_PRESENCE_FLAG;

        convert_intra_freq_event_criteria_list_lcr_r4(
                &pvalue->eventCriteriaList,
                &p_lcr_r4->event_criteria_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_dch_report_criteria_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellDCH_ReportCriteria_LCR_r4 to
 *       cell_dch_report_criteria_lcr_r4_t 
 *
 *******************************************************************************/
void convert_cell_dch_report_criteria_lcr_r4
(
 UMTS_CellDCH_ReportCriteria_LCR_r4     *pvalue,
 cell_dch_report_criteria_lcr_r4_t      *p_lcr_r4
 )
{
    p_lcr_r4->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellDCH_ReportCriteria_LCR_r4_intraFreqReportingCriteria)
    {
        convert_intra_freq_reporting_criteria_lcr_r4(
                pvalue->u.intraFreqReportingCriteria,
                &p_lcr_r4->u.intra_freq_reporting_criteria); 
    }
    else if (pvalue->t == T_UMTS_CellDCH_ReportCriteria_LCR_r4_periodicalReportingCriteria)
    {
        convert_periodical_reporting_criteria(
                pvalue->u.periodicalReportingCriteria,
                &p_lcr_r4->u.periodical_reporting_criteria); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_reporting_info_for_cell_dch_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ReportingInfoForCellDCH_LCR_r4 to
 *       reporting_info_for_cell_dch_lcr_r4_t 
 *
 *******************************************************************************/
void convert_reporting_info_for_cell_dch_lcr_r4
(
 UMTS_ReportingInfoForCellDCH_LCR_r4    *pvalue,
 reporting_info_for_cell_dch_lcr_r4_t   *p_lcr_r4 
 )
{
    convert_intra_freq_reporting_quantity(
            &pvalue->intraFreqReportingQuantity,
            &p_lcr_r4->intra_freq_reporting_quantity);

    convert_measurement_reporting_mode(
            &pvalue->measurementReportingMode,
            &p_lcr_r4->measurement_reporting_mode);

    convert_cell_dch_report_criteria_lcr_r4(
            &pvalue->reportCriteria,
            &p_lcr_r4->report_criteria);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_measurement_sys_info_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasurementSysInfo_RSCP_LCR_r4 to
 *       intra_freq_measurement_sys_info_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_measurement_sys_info_rscp_lcr_r4
(
 UMTS_IntraFreqMeasurementSysInfo_RSCP_LCR_r4   *pvalue,
 intra_freq_measurement_sys_info_rscp_lcr_r4_t  *p_lcr_r4 
 )
{
    p_lcr_r4->intra_freq_measurement_id =
        pvalue->intraFreqMeasurementID;

    if (pvalue->m.intraFreqCellInfoSI_ListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_RSCP_LCR_R4_INTRA_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_intra_freq_cell_info_si_list_rscp_lcr_r4(
                &pvalue->intraFreqCellInfoSI_List,
                &p_lcr_r4->intra_freq_cell_info_si_list);
    }

    if (pvalue->m.intraFreqMeasQuantityPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_RSCP_LCR_R4_INTRA_FREQ_MEAS_QUANTITY_PRESENCE_FLAG;

        convert_intra_freq_meas_quantity(
                &pvalue->intraFreqMeasQuantity,
                &p_lcr_r4->intra_freq_meas_quantity);
    }

    if (pvalue->m.intraFreqReportingQuantityForRACHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_RSCP_LCR_R4_INTRA_FREQ_REPORTING_QUANTITY_FOR_RACH_PRESENCE_FLAG;

        convert_intra_freq_reporting_quantity_for_rach(
                &pvalue->intraFreqReportingQuantityForRACH,
                &p_lcr_r4->intra_freq_reporting_quantity_for_rach);
    }

    if (pvalue->m.maxReportedCellsOnRACHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_RSCP_LCR_R4_MAX_REPORTED_CELL_SON_RACH_PRESENCE_FLAG;

        p_lcr_r4->max_reported_cells_on_rach =
            pvalue->maxReportedCellsOnRACH;
    }

    if (pvalue->m.reportingInfoForCellDCHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_RSCP_LCR_R4_REPORTING_INFO_FOR_CELL_DCH_PRESENCE_FLAG;

        convert_reporting_info_for_cell_dch_lcr_r4(
                &pvalue->reportingInfoForCellDCH,
                &p_lcr_r4->reporting_info_for_cell_dch);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_cell_info_si_list_rscp_lcr 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqCellInfoSI_List_RSCP_LCR to
 *       inter_freq_cell_info_si_list_rscp_lcr_t 
 *
 *******************************************************************************/
void convert_inter_freq_cell_info_si_list_rscp_lcr
(
 UMTS_InterFreqCellInfoSI_List_RSCP_LCR     *pvalue,
 inter_freq_cell_info_si_list_rscp_lcr_t    *p_lcr 
 )
{
    if (pvalue->m.removedInterFreqCellListPresent)
    {
        p_lcr->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_RSCP_LCR_REMOVED_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_inter_freq_cell_list(
                &pvalue->removedInterFreqCellList,
                &p_lcr->removed_inter_freq_cell_list); 
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_lcr->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_RSCP_LCR_NEW_INTER_FREQ_CELL_SI_LIST_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_rscp_lcr_r4(
                &pvalue->newInterFreqCellList,
                &p_lcr->new_inter_freq_cell_si_list_rscp_lcr_r4);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_measurement_sys_info_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqMeasurementSysInfo_RSCP_LCR_r4 to
 *       inter_freq_measurement_sys_info_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_inter_freq_measurement_sys_info_rscp_lcr_r4
(
 UMTS_InterFreqMeasurementSysInfo_RSCP_LCR_r4   *pvalue,
 inter_freq_measurement_sys_info_rscp_lcr_r4_t  *p_lcr_r4 
 )
{
    if (pvalue->m.interFreqCellInfoSI_ListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEASUREMENT_SYS_INFO_RSCP_LCR_R4_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_inter_freq_cell_info_si_list_rscp_lcr(
                &pvalue->interFreqCellInfoSI_List,
                &p_lcr_r4->inter_freq_cell_info_si_list_rscp_lcr);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP  *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp_t   *p_cpich_rscp 
 )
{
    if (pvalue->m.intraFreqMeasurementSysInfoPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_intra_freq_measurement_sys_info_rscp_lcr_r4(
                &pvalue->intraFreqMeasurementSysInfo,
                &p_cpich_rscp->intra_freq_measurement_sysInfo); 
    }

    if (pvalue->m.interFreqMeasurementSysInfoPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEASUREMENT_SYS_INFO_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_inter_freq_measurement_sys_info_rscp_lcr_r4(
                &pvalue->interFreqMeasurementSysInfo,
                &p_cpich_rscp->inter_freq_measurement_sysInfo); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_cell_info_si_list_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqCellInfoSI_List_ECN0_LCR_r4 to
 *       intra_freq_cell_info_si_list_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_cell_info_si_list_ecno_lcr_r4
(
 UMTS_IntraFreqCellInfoSI_List_ECN0_LCR_r4  *pvalue,
 intra_freq_cell_info_si_list_ecno_lcr_r4_t *p_lcr_r4
 )
{
    if (pvalue->m.removedIntraFreqCellListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_CELL_INFO_SI_LIST_ECNO_LCR_R4_REMOVED_INTRA_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_intra_freq_cell_list(
                &pvalue->removedIntraFreqCellList,
                &p_lcr_r4->removed_intra_freq_cell_list);
    }

    convert_new_intra_freq_cell_si_list_ecno_lcr_r4(
            &pvalue->newIntraFreqCellList,
            &p_lcr_r4->new_intra_freq_cell_si_list_ecno_lcr_r4);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_measurement_sys_info_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasurementSysInfo_ECN0_LCR_r4 to
 *       intra_freq_measurement_sys_info_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_measurement_sys_info_ecno_lcr_r4
(
 UMTS_IntraFreqMeasurementSysInfo_ECN0_LCR_r4   *pvalue,
 intra_freq_measurement_sys_info_ecno_lcr_r4_t  *p_lcr_r4 
 )
{
    p_lcr_r4->intra_freq_measurement_id = 
        pvalue->intraFreqMeasurementID;

    if (pvalue->m.intraFreqCellInfoSI_ListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_ECNO_LCR_R4_INTRA_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_intra_freq_cell_info_si_list_ecno_lcr_r4(
                &pvalue->intraFreqCellInfoSI_List,
                &p_lcr_r4->intra_freq_cell_info_si_list); 
    }

    if (pvalue->m.intraFreqMeasQuantityPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_ECNO_LCR_R4_INTRA_FREQ_MEAS_QUANTITY_PRESENCE_FLAG;

        convert_intra_freq_meas_quantity(
                &pvalue->intraFreqMeasQuantity,
                &p_lcr_r4->intra_freq_meas_quantity); 
    }

    if (pvalue->m.intraFreqReportingQuantityForRACHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_ECNO_LCR_R4_INTRA_FREQ_REPORTING_QUANTITY_FOR_RACH_PRESENCE_FLAG;

        convert_intra_freq_reporting_quantity_for_rach(
                &pvalue->intraFreqReportingQuantityForRACH,
                &p_lcr_r4->intra_freq_reporting_quantity_for_rach);
    }

    if (pvalue->m.maxReportedCellsOnRACHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_ECNO_LCR_R4_MAX_REPORTED_CELLS_ON_RACH_PRESENCE_FLAG;

        p_lcr_r4->max_reported_cells_on_rach =
            pvalue->maxReportedCellsOnRACH;
    }

    if (pvalue->m.reportingInfoForCellDCHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_ECNO_LCR_R4_REPORTING_INFO_FOR_CELL_DCH_PRESENCE_FLAG;

        convert_reporting_info_for_cell_dch_lcr_r4(
                &pvalue->reportingInfoForCellDCH,
                &p_lcr_r4->reporting_info_for_cell_dch);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_cell_info_si_list_ecno_lcr 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqCellInfoSI_List_ECN0_LCR to
 *       inter_freq_cell_info_si_list_ecno_lcr_t 
 *
 *******************************************************************************/
void convert_inter_freq_cell_info_si_list_ecno_lcr
(
 UMTS_InterFreqCellInfoSI_List_ECN0_LCR     *pvalue,
 inter_freq_cell_info_si_list_ecno_lcr_t    *p_lcr 
 )
{
    if (pvalue->m.removedInterFreqCellListPresent)
    {
        p_lcr->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_ECNO_LCR_REMOVED_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_inter_freq_cell_list(
                &pvalue->removedInterFreqCellList,
                &p_lcr->removed_inter_freq_cell_list); 
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_lcr->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_ECNO_LCR_NEW_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_ecno_lcr_r4(
                &pvalue->newInterFreqCellList,
                &p_lcr->new_inter_freq_cell_list); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_measurement_sys_info_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqMeasurementSysInfo_ECN0_LCR_r4 to
 *       inter_freq_measurement_sys_info_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_inter_freq_measurement_sys_info_ecno_lcr_r4
(
 UMTS_InterFreqMeasurementSysInfo_ECN0_LCR_r4   *pvalue,
 inter_freq_measurement_sys_info_ecno_lcr_r4_t  *p_lcr_r4 
 )
{
    if (pvalue->m.interFreqCellInfoSI_ListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_ECNO_LCR_PRESENCE_FLAG;

        convert_inter_freq_cell_info_si_list_ecno_lcr(
                &pvalue->interFreqCellInfoSI_List,
                &p_lcr_r4->inter_freq_cell_info_si_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0 to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0     *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no_t  *p_ecno 
 )
{
    if (pvalue->m.intraFreqMeasurementSysInfoPresent)
    {
        p_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_ECNO_LCR_R4_PRESENCE_FLAG;

        convert_intra_freq_measurement_sys_info_ecno_lcr_r4(
                &pvalue->intraFreqMeasurementSysInfo,
                &p_ecno->intra_freq_measurement_sys_info); 
    }

    if (pvalue->m.interFreqMeasurementSysInfoPresent)
    {
        p_ecno->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEASUREMENT_SYS_INFO_ECNO_LCR_R4_PRESENCE_FLAG;

        convert_inter_freq_measurement_sys_info_ecno_lcr_r4(
                &pvalue->interFreqMeasurementSysInfo,
                &p_ecno->inter_freq_measurement_sys_info); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure     *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_t  *p_cell_select_quality_measure 
 )
{
    p_cell_select_quality_measure->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP)
    {
        convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp(
                pvalue->u.cpich_RSCP,
                &p_cell_select_quality_measure->u.cpich_rscp);
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no(
                pvalue->u.cpich_Ec_N0,
                &p_cell_select_quality_measure->u.cpich_ec_no);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used  *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_t  *p_hcs_not_used
 )
{
    convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_hcs_not_used->cell_select_quality_measure);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_cell_info_si_list_hcs_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqCellInfoSI_List_HCS_RSCP_LCR_r4 to
 *       intra_freq_cell_info_si_list_hcs_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_cell_info_si_list_hcs_rscp_lcr_r4
(
 UMTS_IntraFreqCellInfoSI_List_HCS_RSCP_LCR_r4  *pvalue,
 intra_freq_cell_info_si_list_hcs_rscp_lcr_r4_t *p_lcr_r4 
 )
{
    if (pvalue->m.removedIntraFreqCellListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_CELL_INFO_SI_LIST_HCS_RSCP_LCR_R4_REMOVED_INTRA_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_intra_freq_cell_list(
                &pvalue->removedIntraFreqCellList,
                &p_lcr_r4->removed_intra_freq_cell_list);
    }

    convert_new_intra_freq_cell_si_list_hcs_rscp_lcr_r4(
            &pvalue->newIntraFreqCellList,
            &p_lcr_r4->new_intra_freq_cell_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_measurement_sys_info_hcs_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasurementSysInfo_HCS_RSCP_LCR_r4 to
 *       intra_freq_measurement_sys_info_hcs_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_measurement_sys_info_hcs_rscp_lcr_r4
(
 UMTS_IntraFreqMeasurementSysInfo_HCS_RSCP_LCR_r4   *pvalue,
 intra_freq_measurement_sys_info_hcs_rscp_lcr_r4_t  *p_lcr_r4 
 )
{
    p_lcr_r4->intra_freq_measurement_id =
        pvalue->intraFreqMeasurementID;

    if (pvalue->m.intraFreqCellInfoSI_ListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_RSCP_LCR_R4_INTRA_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_intra_freq_cell_info_si_list_hcs_rscp_lcr_r4(
                &pvalue->intraFreqCellInfoSI_List,
                &p_lcr_r4->intra_freq_cell_info_si_list); 
    }

    if (pvalue->m.intraFreqMeasQuantityPresent)
    {
        p_lcr_r4->presence_bitmask |=
            INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_RSCP_LCR_R4_INTRA_FREQ_MEAS_QUANTITY_PRESENCE_FLAG;

        convert_intra_freq_meas_quantity(
                &pvalue->intraFreqMeasQuantity,
                &p_lcr_r4->intra_freq_meas_quantity); 
    }

    if (pvalue->m.intraFreqReportingQuantityForRACHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_RSCP_LCR_R4_INTRA_FREQ_REPORTING_QUANTITY_FOR_RACH_PRESENCE_FLAG;

        convert_intra_freq_reporting_quantity_for_rach(
                &pvalue->intraFreqReportingQuantityForRACH,
                &p_lcr_r4->intra_freq_reporting_quantity_for_rach); 
    }

    if (pvalue->m.maxReportedCellsOnRACHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_RSCP_LCR_R4_MAX_REPORTED_CELLS_ON_RACH_PRESENCE_FLAG;

        p_lcr_r4->max_reported_cells_on_rach =
            pvalue->maxReportedCellsOnRACH;
    }

    if (pvalue->m.reportingInfoForCellDCHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_RSCP_LCR_R4_REPORTING_INFO_FOR_CELL_DCH_PRESENCE_FLAG;

        convert_reporting_info_for_cell_dch_lcr_r4(
                &pvalue->reportingInfoForCellDCH,
                &p_lcr_r4->reporting_info_for_cell_DCH); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_cell_info_si_list_hcs_rscp_lcr 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqCellInfoSI_List_HCS_RSCP_LCR to
 *       inter_freq_cell_info_si_list_hcs_rscp_lcr_t 
 *
 *******************************************************************************/
void convert_inter_freq_cell_info_si_list_hcs_rscp_lcr
(
 UMTS_InterFreqCellInfoSI_List_HCS_RSCP_LCR     *pvalue,
 inter_freq_cell_info_si_list_hcs_rscp_lcr_t    *p_lcr 
 )
{
    if (pvalue->m.removedInterFreqCellListPresent)
    {
        p_lcr->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_RSCP_LCR_REMOVED_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_inter_freq_cell_list(
                &pvalue->removedInterFreqCellList,
                &p_lcr->removed_inter_freq_cell_list);
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_lcr->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_RSCP_LCR_NEW_INTER_FREQ_CELL_SI_LIST_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_hcs_rscp_lcr_r4(
                &pvalue->newInterFreqCellList,
                &p_lcr->new_inter_freq_cell_si_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_measurement_sys_info_hcs_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqMeasurementSysInfo_HCS_RSCP_LCR_r4 to
 *       inter_freq_measurement_sys_info_hcs_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_inter_freq_measurement_sys_info_hcs_rscp_lcr_r4
(
 UMTS_InterFreqMeasurementSysInfo_HCS_RSCP_LCR_r4   *pvalue,
 inter_freq_measurement_sys_info_hcs_rscp_lcr_r4_t  *p_lcr_r4 
 )
{
    if (pvalue->m.interFreqCellInfoSI_ListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            INTER_FREQ_MEASUREMENT_SYS_INFO_HCS_RSCP_LCR_R4_INTER_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_inter_freq_cell_info_si_list_hcs_rscp_lcr(
                &pvalue->interFreqCellInfoSI_List,
                &p_lcr_r4->inter_freq_cell_info_si_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP      *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp_t   *p_rscp 
 )
{
    if (pvalue->m.intraFreqMeasurementSysInfoPresent)
    {
        p_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_intra_freq_measurement_sys_info_hcs_rscp_lcr_r4(
                &pvalue->intraFreqMeasurementSysInfo,
                &p_rscp->intra_freq_measurement_sys_info); 
    }

    if (pvalue->m.interFreqMeasurementSysInfoPresent)
    {
        p_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEASUREMENT_SYS_INFO_HCS_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_inter_freq_measurement_sys_info_hcs_rscp_lcr_r4(
                &pvalue->interFreqMeasurementSysInfo,
                &p_rscp->inter_freq_measurement_sys_info); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_cell_info_si_list_hcs_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqCellInfoSI_List_HCS_ECN0_LCR_r4 to
 *       intra_freq_cell_info_si_list_hcs_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_cell_info_si_list_hcs_ecno_lcr_r4
(
 UMTS_IntraFreqCellInfoSI_List_HCS_ECN0_LCR_r4  *pvalue,
 intra_freq_cell_info_si_list_hcs_ecno_lcr_r4_t *p_lcr_r4 
 )
{
    if (pvalue->m.removedIntraFreqCellListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_CELL_INFO_SI_LIST_HCS_ECNO_LCR_R4_REMOVED_INTRA_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_intra_freq_cell_list(
                &pvalue->removedIntraFreqCellList,
                &p_lcr_r4->removed_intra_freq_cell_list);
    }

    convert_new_intra_freq_cell_si_list_hcs_ecno_lcr_r4(
            &pvalue->newIntraFreqCellList,
            &p_lcr_r4->new_intra_freq_cell_si_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_measurement_sys_info_hcs_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasurementSysInfo_HCS_ECN0_LCR_r4 to
 *       intra_freq_measurement_sys_info_hcs_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_intra_freq_measurement_sys_info_hcs_ecno_lcr_r4
(
 UMTS_IntraFreqMeasurementSysInfo_HCS_ECN0_LCR_r4   *pvalue,
 intra_freq_measurement_sys_info_hcs_ecno_lcr_r4_t  *p_lcr_r4
 )
{
    p_lcr_r4->intra_freq_measurement_id =
        pvalue->intraFreqMeasurementID;

    if (pvalue->m.intraFreqCellInfoSI_ListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_ECNO_LCR_R4_INTRA_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_intra_freq_cell_info_si_list_hcs_ecno_lcr_r4(
                &pvalue->intraFreqCellInfoSI_List,
                &p_lcr_r4->intra_freq_cell_info_si_list);
    }

    if (pvalue->m.intraFreqMeasQuantityPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_ECNO_LCR_R4_INTRA_FREQ_MEAS_QUANTITY_PRESENCE_FLAG;

        convert_intra_freq_meas_quantity(
                &pvalue->intraFreqMeasQuantity,
                &p_lcr_r4->intra_freq_meas_quantity);
    }

    if (pvalue->m.intraFreqReportingQuantityForRACHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_ECNO_LCR_R4_INTRA_FREQ_REPORTING_QUANTITY_FOR_RACH_PRESENCE_FLAG;

        convert_intra_freq_reporting_quantity_for_rach(
                &pvalue->intraFreqReportingQuantityForRACH,
                &p_lcr_r4->intra_freq_reporting_quantity_for_rach);
    }

    if (pvalue->m.maxReportedCellsOnRACHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_ECNO_LCR_R4_MAX_REPORTED_CELLS_ON_RACH_PRESENCE_FLAG;

        p_lcr_r4->max_reported_cells_on_rach =
            pvalue->maxReportedCellsOnRACH;
    }

    if (pvalue->m.reportingInfoForCellDCHPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_ECNO_LCR_R4_REPORTING_INFO_FOR_CELL_DCH_PRESENCE_FLAG;

        convert_reporting_info_for_cell_dch_lcr_r4(
                &pvalue->reportingInfoForCellDCH,
                &p_lcr_r4->reporting_info_for_cell_dch);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_cell_info_si_list_hcs_ecno_lcr 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqCellInfoSI_List_HCS_ECN0_LCR to
 *       inter_freq_cell_info_si_list_hcs_ecno_lcr_t 
 *
 *******************************************************************************/
void convert_inter_freq_cell_info_si_list_hcs_ecno_lcr
(
 UMTS_InterFreqCellInfoSI_List_HCS_ECN0_LCR     *pvalue,
 inter_freq_cell_info_si_list_hcs_ecno_lcr_t    *p_lcr 
 )
{
    if (pvalue->m.removedInterFreqCellListPresent)
    {
        p_lcr->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_ECNO_LCR_REMOVED_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_inter_freq_cell_list(
                &pvalue->removedInterFreqCellList,
                &p_lcr->removed_inter_freq_cell_list); 
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_lcr->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_ECNO_LCR_NEW_INTER_FREQ_CELL_SI_LIST_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_hcs_ecno_lcr_r4(
                &pvalue->newInterFreqCellList,
                &p_lcr->new_inter_freq_cell_si_list); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_measurement_sys_info_hcs_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqMeasurementSysInfo_HCS_ECN0_LCR_r4 to
 *       inter_freq_measurement_sys_info_hcs_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_inter_freq_measurement_sys_info_hcs_ecno_lcr_r4
(
 UMTS_InterFreqMeasurementSysInfo_HCS_ECN0_LCR_r4   *pvalue,
 inter_freq_measurement_sys_info_hcs_ecno_lcr_r4_t  *p_lcr_r4 
 )
{
    if (pvalue->m.interFreqCellInfoSI_ListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_ECNO_LCR_PRESENCE_FLAG;

        convert_inter_freq_cell_info_si_list_hcs_ecno_lcr(
                &pvalue->interFreqCellInfoSI_List,
                &p_lcr_r4->inter_freq_cell_info_si_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0 to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0     *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno_t   *p_ecno 
 )
{
    if (pvalue->m.intraFreqMeasurementSysInfoPresent)
    {
        p_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEASUREMENT_SYS_INFO_HCS_ECNO_LCR_R4_PRESENCE_FLAG;

        convert_intra_freq_measurement_sys_info_hcs_ecno_lcr_r4(
                &pvalue->intraFreqMeasurementSysInfo,
                &p_ecno->intra_freq_measurement_sys_info); 
    }

    if (pvalue->m.interFreqMeasurementSysInfoPresent)
    {
        p_ecno->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEASUREMENT_SYS_INFO_HCS_ECNO_LCR_R4_PRESENCE_FLAG;

        convert_inter_freq_measurement_sys_info_hcs_ecno_lcr_r4(
                &pvalue->interFreqMeasurementSysInfo,
                &p_ecno->inter_freq_measurement_sys_info); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure     *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_t  *p_cell_select_quality_measure 
 )
{
    p_cell_select_quality_measure->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP)
    {
        convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp(
                pvalue->u.cpich_RSCP,
                &p_cell_select_quality_measure->u.cpich_rscp);
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno(
                pvalue->u.cpich_Ec_N0,
                &p_cell_select_quality_measure->u.cpich_ec_no); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used  *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_t  *p_hcs_used 
 )
{
    convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_hcs_used->cell_select_quality_measure);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS to
 *       measurement_control_sys_info_lcr_r4_ext_use_of_hcs_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS   *pvalue,
 measurement_control_sys_info_lcr_r4_ext_use_of_hcs_t   *p_use_of_hcs 
 )
{
    p_use_of_hcs->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_not_used)
    {
        convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_not_used(
                pvalue->u.hcs_not_used,
                &p_use_of_hcs->u.hcs_not_used);
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfo_LCR_r4_ext_use_of_HCS_hcs_used)
    {
        convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs_hcs_used(
                pvalue->u.hcs_used,
                &p_use_of_hcs->u.hcs_used); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_lcr_r4_ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_LCR_r4_ext to
 *       measurement_control_sys_info_lcr_r4_ext_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_lcr_r4_ext
(
 UMTS_MeasurementControlSysInfo_LCR_r4_ext  *pvalue,
 measurement_control_sys_info_lcr_r4_ext_t  *p_ext 
 )
{
    convert_measurement_control_sys_info_lcr_r4_ext_use_of_hcs(
            &pvalue->use_of_HCS,
            &p_ext->use_of_hcs);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v4b0ext_ies 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v4b0ext_IEs to
 *       sysinfotype12_v4b0ext_ies_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v4b0ext_ies
(
 UMTS_SysInfoType12_v4b0ext_IEs *pvalue,
 sysinfotype12_v4b0ext_ies_t    *p_ies 
 )
{
    if (pvalue->m.fach_MeasurementOccasionInfo_LCR_ExtPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_V4B0EXT_FACH_MEASUREMENT_OCCASION_INFO_LCR_R4_EXT_PRESENCE_FLAG;

        convert_fach_measurement_occasion_info_lcr_r4_ext(
                &pvalue->fach_MeasurementOccasionInfo_LCR_Ext,
                &p_ies->fach_measurement_occasion_info_lcr_r4_ext);
    }

    convert_measurement_control_sys_info_lcr_r4_ext(
            &pvalue->measurementControlSysInfo_LCR,
            &p_ies->measurement_control_sys_info_lcr_r4_ext);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_v590ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfo_v590ext to
 *       cell_select_reselect_info_v590ext_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_v590ext
(
 UMTS_CellSelectReselectInfo_v590ext    *pvalue,
 cell_select_reselect_info_v590ext_t    *p_ext 
 )
{
    if (pvalue->m.deltaQrxlevminPresent)
    {
        p_ext->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_V590EXT_DELTA_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_ext->delta_q_rx_lev_min =
            pvalue->deltaQrxlevmin;
    }

    if (pvalue->m.deltaQhcsPresent)
    {
        p_ext->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_V590EXT_DELTA_Q_HCS_PRESENCE_FLAG;

        p_ext->delta_q_hcs =
            pvalue->deltaQhcs;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v590ext_ies_new_intra_frequency_cell_info_list_v590ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext to
 *       sysinfotype12_v590ext_ies_new_intra_frequency_cell_info_list_v590ext_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v590ext_ies_new_intra_frequency_cell_info_list_v590ext
(
 UMTS_SysInfoType12_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext   *pvalue,
 sysinfotype12_v590ext_ies_new_intra_frequency_cell_info_list_v590ext_t *p_ext 
 )
{
    UMTS_CellSelectReselectInfo_v590ext *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_ext->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_cell_select_reselect_info_v590ext(
                pdata,
                &p_ext->cell_select_reselect_info_v590ext[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v590ext_ies_new_inter_frequency_cell_info_list_v590ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v590ext_IEs_newInterFrequencyCellInfoList_v590ext to
 *       sysinfotype12_v590ext_ies_new_inter_frequency_cell_info_list_v590ext_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v590ext_ies_new_inter_frequency_cell_info_list_v590ext
(
 UMTS_SysInfoType12_v590ext_IEs_newInterFrequencyCellInfoList_v590ext   *pvalue,
 sysinfotype12_v590ext_ies_new_inter_frequency_cell_info_list_v590ext_t *p_ext 
 )
{
    UMTS_CellSelectReselectInfo_v590ext *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_ext->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_cell_select_reselect_info_v590ext(
                pdata,
                &p_ext->cell_select_reselect_info_v590ext[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v590ext_ies_new_inter_rat_cell_info_list_v590ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v590ext_IEs_newInterRATCellInfoList_v590ext to
 *       sysinfotype12_v590ext_ies_new_inter_rat_cell_info_list_v590ext_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v590ext_ies_new_inter_rat_cell_info_list_v590ext
(
 UMTS_SysInfoType12_v590ext_IEs_newInterRATCellInfoList_v590ext     *pvalue,
 sysinfotype12_v590ext_ies_new_inter_rat_cell_info_list_v590ext_t   *p_ext
 )
{
    UMTS_CellSelectReselectInfo_v590ext *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_ext->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_cell_select_reselect_info_v590ext(
                pdata,
                &p_ext->cell_select_reselect_info_v590ext[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_event_criteria_list_v590ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Intra_FreqEventCriteriaList_v590ext to
 *       intra_freq_event_criteria_list_v590ext_t 
 *
 *******************************************************************************/
void convert_intra_freq_event_criteria_list_v590ext
(
 UMTS_Intra_FreqEventCriteriaList_v590ext   *pvalue,
 intra_freq_event_criteria_list_v590ext_t   *p_ext
 )
{
    p_ext->n = pvalue->n;

    memcpy(&p_ext->elem, &pvalue->elem,
            (sizeof(S8)* p_ext->n));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_criteria_1b_r5 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqReportingCriteria_1b_r5 to
 *       intra_freq_reporting_criteria_1b_r5_t 
 *
 *******************************************************************************/
void convert_intra_freq_reporting_criteria_1b_r5
(
 UMTS_IntraFreqReportingCriteria_1b_r5  *pvalue,
 intra_freq_reporting_criteria_1b_r5_t  *p_r5
 )
{
    p_r5->periodic_reporting_info_1b.reporting_amount =
        pvalue->periodicReportingInfo_1b.reportingAmount;

    p_r5->periodic_reporting_info_1b.reporting_interval =
        pvalue->periodicReportingInfo_1b.reportingInterval;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_event_1d_r5 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqEvent_1d_r5 to
 *       intra_freq_event_1d_r5_t 
 *
 *******************************************************************************/
void convert_intra_freq_event_1d_r5
(
 UMTS_IntraFreqEvent_1d_r5  *pvalue,
 intra_freq_event_1d_r5_t   *p_r5
 )
{
    if (pvalue->m.triggeringConditionPresent)
    {
        p_r5->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_EVENT_1D_R5_TRIGGERING_CONDITION_PRESENCE_FLAG;

        p_r5->triggering_condition = pvalue->triggeringCondition;
    }

    if (pvalue->m.useCIOPresent)
    {
        p_r5->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_EVENT_1D_R5_USE_CIO_PRESENCE_FLAG;

        p_r5->use_cio = pvalue->useCIO;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v590ext_ies 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v590ext_IEs to
 *       sysinfotype12_v590ext_ies_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v590ext_ies
(
 UMTS_SysInfoType12_v590ext_IEs     *pvalue,
 sysinfotype12_v590ext_ies_t        *p_ies
 )
{
    if (pvalue->m.newIntraFrequencyCellInfoList_v590extPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_NEW_INTRA_FREQUENCY_CELL_INFO_LIST_V590EXT_PRESENCE_FLAG;

        convert_sysinfotype12_v590ext_ies_new_intra_frequency_cell_info_list_v590ext(
                &pvalue->newIntraFrequencyCellInfoList_v590ext,
                &p_ies->new_intra_frequency_cell_info_list_v590ext); 
    }

    if (pvalue->m.newInterFrequencyCellInfoList_v590extPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_NEW_INTER_FREQUENCY_CELL_INFO_LIST_V590EXT_PRESENCE_FLAG;

        convert_sysinfotype12_v590ext_ies_new_inter_frequency_cell_info_list_v590ext(
                &pvalue->newInterFrequencyCellInfoList_v590ext,
                &p_ies->new_inter_frequency_cell_info_list_v590ext); 
    }

    if (pvalue->m.newInterRATCellInfoList_v590extPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_NEW_INTER_RAT_CELL_INFO_LIST_V590EXT_PRESENCE_FLAG;

        convert_sysinfotype12_v590ext_ies_new_inter_rat_cell_info_list_v590ext(
                &pvalue->newInterRATCellInfoList_v590ext,
                &p_ies->new_inter_rat_cell_info_list_v590ext); 
    }

    if (pvalue->m.intraFreqEventCriteriaList_v590extPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_INTRA_FREQ_EVENT_CRITERIA_LIST_V590EXT_PRESENCE_FLAG;

        convert_intra_freq_event_criteria_list_v590ext(
                &pvalue->intraFreqEventCriteriaList_v590ext,
                &p_ies->intra_freq_event_criteria_list_v590ext); 
    }

    if (pvalue->m.intraFreqReportingCriteria_1b_r5Present)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_INTRA_FREQ_REPORTING_CRITERIA_1B_R5_PRESENCE_FLAG;

        convert_intra_freq_reporting_criteria_1b_r5(
                &pvalue->intraFreqReportingCriteria_1b_r5,
                &p_ies->intra_freq_reporting_criteria_1b_r5); 
    }

    if (pvalue->m.intraFreqEvent_1d_r5Present)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_INTRA_FREQ_EVENT_1D_R5_PRESENCE_FLAG;

        convert_intra_freq_event_1d_r5(
                &pvalue->intraFreqEvent_1d_r5,
                &p_ies->intra_freq_event_1d_r5);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dummy_inter_freq_rach_reporting_info_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo to
 *       dummy_inter_freq_rach_reporting_info_mode_specific_info_t 
 *
 *******************************************************************************/
void convert_dummy_inter_freq_rach_reporting_info_mode_specific_info
(
 UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo     *pvalue,
 dummy_inter_freq_rach_reporting_info_mode_specific_info_t  *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_fdd)
    {
        p_info->u.fdd.inter_freq_rep_quantity_rach_fdd =
            pvalue->u.fdd->interFreqRepQuantityRACH_FDD;
    }
    else if (pvalue->t == T_UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_tdd)
    {
        p_info->u.tdd.inter_freq_rep_quantity_rach_tdd_list.n =
            pvalue->u.tdd->interFreqRepQuantityRACH_TDDList.n;

        memcpy(&p_info->u.tdd.inter_freq_rep_quantity_rach_tdd_list.elem,
                &pvalue->u.tdd->interFreqRepQuantityRACH_TDDList.elem,
                (sizeof(U32)*p_info->u.tdd.inter_freq_rep_quantity_rach_tdd_list.n));
    }
    else if (pvalue->t == T_UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_interFreqRACHReportingThreshold)
    {
        memcpy(&p_info->u.inter_freq_rach_reporting_threshold,
                &pvalue->u.interFreqRACHReportingThreshold,
                sizeof(S8));
    }
    else if (pvalue->t == T_UMTS_Dummy_InterFreqRACHReportingInfo_modeSpecificInfo_maxReportedCellsOnRACHinterFreq)
    {
        p_info->u.max_reported_cells_on_rach_inter_freq =
            pvalue->u.maxReportedCellsOnRACHinterFreq; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dummy_inter_freq_rach_reporting_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Dummy_InterFreqRACHReportingInfo to
 *       dummy_inter_freq_rach_reporting_info_t 
 *
 *******************************************************************************/
void convert_dummy_inter_freq_rach_reporting_info
(
 UMTS_Dummy_InterFreqRACHReportingInfo  *pvalue,
 dummy_inter_freq_rach_reporting_info_t *p_info
 )
{
    convert_dummy_inter_freq_rach_reporting_info_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_info->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v690ext_ies 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v690ext_IEs to
 *       sysinfotype12_v690ext_ies_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v690ext_ies
(
 UMTS_SysInfoType12_v690ext_IEs     *pvalue,
 sysinfotype12_v690ext_ies_t        *p_ies 
 )
{
    if (pvalue->m.dummyPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_DUMMY_INTER_FREQ_RACH_REPORTING_INFO_PRESENCE_FLAG;

        convert_dummy_inter_freq_rach_reporting_info(
                &pvalue->dummy,
                &p_ies->dummy);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_rach_reporting_info_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqRACHReportingInfo_modeSpecificInfo to
 *       inter_freq_rach_reporting_info_mode_specific_info_t 
 *
 *******************************************************************************/
void convert_inter_freq_rach_reporting_info_mode_specific_info
(
 UMTS_InterFreqRACHReportingInfo_modeSpecificInfo       *pvalue,
 inter_freq_rach_reporting_info_mode_specific_info_t    *p_info
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_InterFreqRACHReportingInfo_modeSpecificInfo_fdd)
    {
        p_info->u.fdd.inter_freq_rep_quantity_rach_fdd =
            pvalue->u.fdd->interFreqRepQuantityRACH_FDD;
    }
    else if (pvalue->t == T_UMTS_InterFreqRACHReportingInfo_modeSpecificInfo_tdd)
    {
        p_info->u.tdd.inter_freq_rep_quantity_rach_tdd_list.n =
            pvalue->u.tdd->interFreqRepQuantityRACH_TDDList.n;

        memcpy(&p_info->u.tdd.inter_freq_rep_quantity_rach_tdd_list.elem,
                &pvalue->u.tdd->interFreqRepQuantityRACH_TDDList.elem,
                (sizeof(U32)*p_info->u.tdd.inter_freq_rep_quantity_rach_tdd_list.n));
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_rach_reporting_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterFreqRACHReportingInfo to
 *       inter_freq_rach_reporting_info_t 
 *
 *******************************************************************************/
void convert_inter_freq_rach_reporting_info
(
 UMTS_InterFreqRACHReportingInfo    *pvalue,
 inter_freq_rach_reporting_info_t   *p_info
 )
{
    convert_inter_freq_rach_reporting_info_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_info->mode_specific_info);

    memcpy(&p_info->inter_freq_rach_reporting_threshold,
            &pvalue->interFreqRACHReportingThreshold,
            sizeof(S8));

    p_info->max_reported_cells_on_rach_inter_freq =
        pvalue->maxReportedCellsOnRACHinterFreq;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v6b0ext_ies 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v6b0ext_IEs to
 *       sysinfotype12_v6b0ext_ies_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v6b0ext_ies
(
 UMTS_SysInfoType12_v6b0ext_IEs     *pvalue,
 sysinfotype12_v6b0ext_ies_t        *p_ies 
 )
{
    if (pvalue->m.interFreqRACHReportingInfoPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_INTER_FREQ_RACH_REPORTING_INFO_PRESENCE_FLAG;

        convert_inter_freq_rach_reporting_info(
                &pvalue->interFreqRACHReportingInfo,
                &p_ies->inter_freq_rach_reporting_info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_list_v7b0ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellList_v7b0ext to
 *       new_inter_freq_cell_list_v7b0ext_t 
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_list_v7b0ext
(
 UMTS_NewInterFreqCellList_v7b0ext  *pvalue,
 new_inter_freq_cell_list_v7b0ext_t *p_ext
 )
{
    UMTS_NewInterFreqCell_v7b0ext   *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_ext->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCell_v7b0ext*)pnode->data;

        p_ext->new_inter_freq_cell_v7b0ext[index].intra_secondary_freq_indicator =
            pdata->intraSecondaryFreqIndicator;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v7b0ext_ies 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v7b0ext_IEs to
 *       sysinfotype12_v7b0ext_ies_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v7b0ext_ies
(
 UMTS_SysInfoType12_v7b0ext_IEs *pvalue,
 sysinfotype12_v7b0ext_ies_t    *p_ies
 )
{
    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE12_NEW_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_freq_cell_list_v7b0ext(
                &pvalue->newInterFreqCellList,
                &p_ies->new_inter_freq_cell_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces_nces 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v7b0NonCriticalExtensions_nonCriticalExtensions to
 *       sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces_nces_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces_nces
(
 UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v7b0NonCriticalExtensions_nonCriticalExtensions  *pvalue,
 sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces_nces_t   *p_nce
 )
{
    p_nce->__dummy__ = pvalue->__dummy__;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v7b0NonCriticalExtensions to
 *       sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces
(
 UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions_v7b0NonCriticalExtensions    *pvalue,
 sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces_t    *p_nce
 )
{
    convert_sysinfotype12_v7b0ext_ies(
            &pvalue->sysInfoType12_v7b0ext,
            &p_nce->sys_info_type12_v7b0ext);

    if (pvalue->m.nonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE12_V4B0_V590_V690_V6B0_7B0_NCE_NCE_PRESENCE_FLAG;

        convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces_nces(
                &pvalue->nonCriticalExtensions,
                &p_nce->nonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions to
 *       sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces
(
 UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions_v6b0NonCriticalExtensions  *pvalue,
 sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_t     *p_nce 
 )
{
    convert_sysinfotype12_v6b0ext_ies(
            &pvalue->sysInfoType12_v6b0ext,
            &p_nce->sys_info_type12_v6b0ext);

    if (pvalue->m.v7b0NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE12_V4B0_V590_V690_V6B0_7B0_NCE_PRESENCE_FLAG;

        convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces_v7b0nces(
                &pvalue->v7b0NonCriticalExtensions,
                &p_nce->v7b0NonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v4b0nces_v590nce_v690nces 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions to
 *       sysinfotype12_v4b0nces_v590nce_v690nces_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v4b0nces_v590nce_v690nces
(
 UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension_v690NonCriticalExtensions    *pvalue,
 sysinfotype12_v4b0nces_v590nce_v690nces_t  *p_nce
 )
{
    convert_sysinfotype12_v690ext_ies(
            &pvalue->sysInfoType12_v690ext,
            &p_nce->sys_info_type12_v690ext);

    if (pvalue->m.v6b0NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE12_V4B0_V590_V690_V6B0_NCE_PRESENCE_FLAG;

        convert_sysinfotype12_v4b0nces_v590nce_v690nces_v6b0nces(
                &pvalue->v6b0NonCriticalExtensions,
                &p_nce->v6b0_non_critical_extensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v4b0nces_v590nce 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension to
 *       sysinfotype12_v4b0nces_v590nce_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v4b0nces_v590nce
(
 UMTS_SysInfoType12_v4b0NonCriticalExtensions_v590NonCriticalExtension  *pvalue,
 sysinfotype12_v4b0nces_v590nce_t                                       *p_nce 
 )
{
    convert_sysinfotype12_v590ext_ies(
            &pvalue->sysInfoType12_v590ext,
            &p_nce->sys_info_type12_v590ext);

    if (pvalue->m.v690NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE12_V4B0_V590_V690_NCE_PRESENCE_FLAG;

        convert_sysinfotype12_v4b0nces_v590nce_v690nces(
                &pvalue->v690NonCriticalExtensions,
                &p_nce->v690_non_critical_extensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype12_v4b0_nc_extensions 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType12_v4b0NonCriticalExtensions to
 *       sysinfotype12_v4b0_nc_extensions_t 
 *
 *******************************************************************************/
void convert_sysinfotype12_v4b0_nc_extensions
(
 UMTS_SysInfoType12_v4b0NonCriticalExtensions   *pvalue,
 sysinfotype12_v4b0_nc_extensions_t             *p_nce 
 )
{
    if (pvalue->m.sysInfoType12_v4b0extPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE12_V4B0EXT_IES_PRESENCE_FLAG;

        convert_sysinfotype12_v4b0ext_ies(
                &pvalue->sysInfoType12_v4b0ext,
                &p_nce->sys_info_type12_v4b0ext);
    }

    if (pvalue->m.v590NonCriticalExtensionPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE12_V4B0_V590_NCE_PRESENCE_FLAG;

        convert_sysinfotype12_v4b0nces_v590nce(
                &pvalue->v590NonCriticalExtension,
                &p_nce->v590non_critical_extension);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib12
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType12 to
 *       umts_sib_type_12_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       umts_sib12 - Pointer to decoded SIB12
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib12
(
 umts_sib_type_12_info_t    *umts_sib12
 )
{
    UMTS_SysInfoType12   sys_info_type_12;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_12_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_12, 0, sizeof(UMTS_SysInfoType12));

    if ( 0 != (asn1PD_UMTS_SysInfoType12(&ctxt, &sys_info_type_12)))
    {
        printf("umts_convert_sib12:asn decoding failed\n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType12("Decoded SysInfoType12\n", &sys_info_type_12);
    memset( umts_sib12, 0, sizeof(umts_sib_type_12_info_t));

    if (sys_info_type_12.m.fach_MeasurementOccasionInfoPresent)
    {
        umts_sib12->presence_bitmask |= 
            UMTS_SIB_TYPE12_FACH_MEAS_OCCASION_INFO_PRESENCE_FLAG;

        convert_fach_measurement_occasion_info(
                &sys_info_type_12.fach_MeasurementOccasionInfo,
                &umts_sib12->fach_measurement_occasion_info);
    }

    convert_measurement_control_sys_info(
            &sys_info_type_12.measurementControlSysInfo ,
            &umts_sib12->measurement_control_sys_info );

    if (sys_info_type_12.m.v4b0NonCriticalExtensionsPresent)
    {
        umts_sib12->presence_bitmask |=
            UMTS_SIB_TYPE12_V4B0_NCE_PRESENCE_FLAG;

        convert_sysinfotype12_v4b0_nc_extensions(
                &sys_info_type_12.v4b0NonCriticalExtensions,
                &umts_sib12->sysinfotype12_v4b0_nc_extensions);
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_ReferenceTimeDifferenceToCell to
 *       reference_time_difference_to_cell_t 
 *
 *******************************************************************************/
void convert_reference_time_difference_to_cell
(
 UMTS_ReferenceTimeDifferenceToCell     *pvalue,
 reference_time_difference_to_cell_t    *p_reference_time_difference_to_cell 
 )
{
    p_reference_time_difference_to_cell->t = pvalue->t;

    if (pvalue->t == T_UMTS_ReferenceTimeDifferenceToCell_accuracy40)
    {
        p_reference_time_difference_to_cell->u.accuracy40 =
            pvalue->u.accuracy40; 
    }
    else if (pvalue->t == T_UMTS_ReferenceTimeDifferenceToCell_accuracy256)
    {
        p_reference_time_difference_to_cell->u.accuracy256 =
            pvalue->u.accuracy256; 
    }
    else if (pvalue->t == T_UMTS_ReferenceTimeDifferenceToCell_accuracy2560)
    {
        p_reference_time_difference_to_cell->u.accuracy2560 =
            pvalue->u.accuracy2560; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_primary_cpich_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PrimaryCPICH_Info to
 *       primary_cpich_info_t 
 *
 *******************************************************************************/
void convert_primary_cpich_info
(
 UMTS_PrimaryCPICH_Info     *pvalue,
 primary_cpich_info_t       *p_primary_cpich_info 
 )
{
    p_primary_cpich_info->primary_scrambling_code =
        pvalue->primaryScramblingCode;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_rscp_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_RSCP_modeSpecificInfo_fdd to
 *       cell_info_si_rscp_mode_specific_info_fdd_t 
 *
 *******************************************************************************/
void convert_cell_info_si_rscp_mode_specific_info_fdd
(
 UMTS_CellInfoSI_RSCP_modeSpecificInfo_fdd  *pvalue,
 cell_info_si_rscp_mode_specific_info_fdd_t *p_mode_specific_info_fdd 
 )
{
    if (pvalue->m.primaryCPICH_InfoPresent)
    {
        p_mode_specific_info_fdd->presence_bitmask |=
            UMTS_SIB_PRIMARY_CPICH_INFO_PRESENCE_FLAG;

        convert_primary_cpich_info(
                &pvalue->primaryCPICH_Info,
                &p_mode_specific_info_fdd->primary_cpich_info);
    }

    if (pvalue->m.primaryCPICH_TX_PowerPresent)
    {
        p_mode_specific_info_fdd->presence_bitmask |=
            UMTS_SIB_PRIMARY_CPICH_TX_POWER_PRESENCE_FLAG;

        p_mode_specific_info_fdd->primary_cpich_tx_power =
            pvalue->primaryCPICH_TX_Power;
    }

    p_mode_specific_info_fdd->read_sfn_indicator =
        pvalue->readSFN_Indicator;

    p_mode_specific_info_fdd->tx_diversity_indicator =
        pvalue->tx_DiversityIndicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_primary_ccpch_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PrimaryCCPCH_Info_fdd to
 *      primary_ccpch_info_fdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_primary_ccpch_info_fdd
(
 UMTS_PrimaryCCPCH_Info_fdd     *pvalue,
 primary_ccpch_info_fdd_t        *p_primary_ccpch_info_fdd 
 )
{
    p_primary_ccpch_info_fdd->tx_diversity_indicator = 
        pvalue->tx_DiversityIndicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_primary_ccpch_info_tdd_synch_case
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PrimaryCCPCH_Info_tdd_syncCase to
 *      primary_ccpch_info_tdd_synch_case_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_primary_ccpch_info_tdd_synch_case
(
 UMTS_PrimaryCCPCH_Info_tdd_syncCase    *pvalue,
 primary_ccpch_info_tdd_synch_case_t    *p_primary_ccpch_info_tdd_synch_case 
 )
{
    p_primary_ccpch_info_tdd_synch_case->t = pvalue->t;

    if (pvalue->t == T_UMTS_PrimaryCCPCH_Info_tdd_syncCase_syncCase1)
    {
        p_primary_ccpch_info_tdd_synch_case->u.syncCase1.time_slot_Number =
            pvalue->u.syncCase1->timeslot;  
    }
    else if (pvalue->t == T_UMTS_PrimaryCCPCH_Info_tdd_syncCase_syncCase2)
    {
        p_primary_ccpch_info_tdd_synch_case->u.syncCase2.timeslot_Sync2 =
            pvalue->u.syncCase2->timeslotSync2;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_primary_ccpch_info_tdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PrimaryCCPCH_Info_tdd to
 *      primary_ccpch_info_tdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_primary_ccpch_info_tdd
(
 UMTS_PrimaryCCPCH_Info_tdd     *pvalue,
 primary_ccpch_info_tdd_t       *p_primary_ccpch_info_tdd 
 )
{
    if (pvalue->m.syncCasePresent)
    {
        p_primary_ccpch_info_tdd->presence_bitmask |= 
            UMTS_SIB_TYPE_5_INFO_PRIMARY_CCPCH_INFO_TDD_SYNCH_CASE_PRESENCE_FLAG;

        convert_primary_ccpch_info_tdd_synch_case(
                &pvalue->syncCase,
                &p_primary_ccpch_info_tdd->synch_case); 
    }

    if (pvalue->m.cellParametersIDPresent)
    {
        p_primary_ccpch_info_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRIMARY_CCPCH_INFO_TDD_CELL_PARAMS_PRESENCE_FLAG;

        p_primary_ccpch_info_tdd->cell_parametersID = pvalue->cellParametersID; 
    }

    p_primary_ccpch_info_tdd->sctd_indicator = pvalue->sctd_Indicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_primary_ccpch_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PrimaryCCPCH_Info to
 *       primary_ccpch_info_t 
 *
 *******************************************************************************/
void convert_primary_ccpch_info
(
 UMTS_PrimaryCCPCH_Info     *pvalue,
 primary_ccpch_info_t       *p_primary_ccpch_info 
 )
{
    p_primary_ccpch_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_PrimaryCCPCH_Info_fdd)
    {
        convert_primary_ccpch_info_fdd(
                pvalue->u.fdd,
                &p_primary_ccpch_info->u.fdd);
    }
    else if (pvalue->t == T_UMTS_PrimaryCCPCH_Info_tdd)
    {
        convert_primary_ccpch_info_tdd(
                pvalue->u.tdd,
                &p_primary_ccpch_info->u.tdd); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_timeslot_info_list 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TimeslotInfoList to
 *       timeslot_info_list_t 
 *
 *******************************************************************************/
void convert_timeslot_info_list
(
 UMTS_TimeslotInfoList  *pvalue,
 timeslot_info_list_t   *p_timeslot_info_list
 )
{
    UMTS_TimeslotInfo   *pdata = NULL;
    OSRTDListNode       *pnode = NULL;
    U32                 index;

    pnode = pvalue->head;
    p_timeslot_info_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TimeslotInfo*)pnode->data;

        p_timeslot_info_list->timeslot_info[index].timeslot_number =
            pdata->timeslotNumber;

        p_timeslot_info_list->timeslot_info[index].burst_type =
            pdata->burstType;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_rscp_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_RSCP_modeSpecificInfo_tdd to
 *       cell_info_si_rscp_mode_specific_info_tdd_t 
 *
 *******************************************************************************/
void convert_cell_info_si_rscp_mode_specific_info_tdd
(
 UMTS_CellInfoSI_RSCP_modeSpecificInfo_tdd  *pvalue,
 cell_info_si_rscp_mode_specific_info_tdd_t *p_mode_specific_info_tdd 
 )
{
    convert_primary_ccpch_info(
            &pvalue->primaryCCPCH_Info,
            &p_mode_specific_info_tdd->primary_ccpch_info);

    if (pvalue->m.primaryCCPCH_TX_PowerPresent)
    {
        p_mode_specific_info_tdd->presence_bitmask |=
            UMTS_SIB_PRIMARY_CCPCH_TX_POWER_PRESENCE_FLAG;

        p_mode_specific_info_tdd->primary_ccpch_tx_power =
            pvalue->primaryCCPCH_TX_Power;
    }

    if (pvalue->m.timeslotInfoListPresent)
    {
        p_mode_specific_info_tdd->presence_bitmask |=
            UMTS_SIB_TIME_SLOT_INFO_LIST_PRESENCE_FLAG;

        convert_timeslot_info_list(
                &pvalue->timeslotInfoList,
                &p_mode_specific_info_tdd->timeslot_info_list);
    }

    p_mode_specific_info_tdd->read_sfn_indicator =
        pvalue->readSFN_Indicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_rscp_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_RSCP_modeSpecificInfo to
 *       cell_info_si_rscp_mode_specific_info_t 
 *
 *******************************************************************************/
void convert_cell_info_si_rscp_mode_specific_info
(
 UMTS_CellInfoSI_RSCP_modeSpecificInfo  *pvalue,
 cell_info_si_rscp_mode_specific_info_t *p_cell_info_si_rscp_mode_specific_info 
 )
{
    p_cell_info_si_rscp_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellInfoSI_RSCP_modeSpecificInfo_fdd)
    {
        convert_cell_info_si_rscp_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_cell_info_si_rscp_mode_specific_info->u.fdd);
    }
    else if (pvalue->t == T_UMTS_CellInfoSI_RSCP_modeSpecificInfo_tdd)
    {
        convert_cell_info_si_rscp_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_cell_info_si_rscp_mode_specific_info->u.tdd); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd to
 *       cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_fdd_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_fdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd     *pvalue,
 cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_fdd_t  *p_mode_specific_info_fdd 
 )
{
    if (pvalue->m.q_QualMinPresent)
    {
        p_mode_specific_info_fdd->presence_bitmask |=
            UMTS_SIB_MODE_SPECIFIC_INFO_FDD_Q_QUALMIN_PRESENCE_FLAG;

        p_mode_specific_info_fdd->q_qual_min = pvalue->q_QualMin;
    }

    if (pvalue->m.q_RxlevMinPresent)
    {
        p_mode_specific_info_fdd->presence_bitmask |=
            UMTS_SIB_MODE_SPECIFIC_INFO_FDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_mode_specific_info_fdd->q_rx_lev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd to
 *       cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_tdd_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_tdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd     *pvalue,
 cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_tdd_t  *p_mode_specific_info_tdd 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_mode_specific_info_tdd->presence_bitmask |=
            UMTS_SIB_MODE_SPECIFIC_INFO_TDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_mode_specific_info_tdd->q_rx_lev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_gsm 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm to
 *       cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_gsm_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_gsm
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm     *pvalue,
 cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_gsm_t  *p_mode_specific_info_gsm 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_mode_specific_info_gsm->presence_bitmask |=
            UMTS_SIB_MODE_SPECIFIC_INFO_GSM_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_mode_specific_info_gsm->q_rx_lev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo to
 *       cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo     *pvalue,
 cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_t  *p_mode_specific_info
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd)
    {
        convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_tdd)
    {
        convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd); 
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_gsm)
    {
        convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info_gsm(
                pvalue->u.gsm,
                &p_mode_specific_info->u.gsm); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_RSCP to
 *       cell_select_reselect_info_sib_11_12_rscp_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_rscp
(
 UMTS_CellSelectReselectInfoSIB_11_12_RSCP  *pvalue,
 cell_select_reselect_info_sib_11_12_rscp_t *p_cell_select_reselect_info_sib_11_12_rscp
 )
{
    p_cell_select_reselect_info_sib_11_12_rscp->q_offset_s_n =
        pvalue->q_OffsetS_N;

    if (pvalue->m.maxAllowedUL_TX_PowerPresent)
    {
        p_cell_select_reselect_info_sib_11_12_rscp->presence_bitmask |=
            UMTS_SIB_MAX_ALLOWED_UL_TX_POWER_PRESENCE_FLAG;

        p_cell_select_reselect_info_sib_11_12_rscp->max_allowed_ul_tx_power =
            pvalue->maxAllowedUL_TX_Power;
    }

    convert_cell_select_reselect_info_sib_11_12_rscp_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_cell_select_reselect_info_sib_11_12_rscp->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_RSCP to
 *       cell_info_si_rscp_t 
 *
 *******************************************************************************/
void convert_cell_info_si_rscp
(
 UMTS_CellInfoSI_RSCP   *pvalue,
 cell_info_si_rscp_t    *p_cell_info_si_rscp 
 )
{
    p_cell_info_si_rscp->cell_individual_offset = pvalue->cellIndividualOffset;

    if (pvalue->m.referenceTimeDifferenceToCellPresent)
    {
        p_cell_info_si_rscp->presence_bitmask |=
            UMTS_SIB_REFERENCE_TIME_DIFF_TO_CELL_PRESENCE_FLAG;

        convert_reference_time_difference_to_cell(
                &pvalue->referenceTimeDifferenceToCell,
                &p_cell_info_si_rscp->reference_time_difference_to_cell);
    }

    convert_cell_info_si_rscp_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_cell_info_si_rscp->mode_specific_info);

    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_cell_info_si_rscp->presence_bitmask |=
            UMTS_SIB_CELL_SELECTION_RESELECTION_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12_rscp(
                &pvalue->cellSelectionReselectionInfo,
                &p_cell_info_si_rscp->cell_select_reselect_info_sib_11_12_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_RSCP to
 *       new_intra_freq_cell_si_list_rscp_t 
 *
 *******************************************************************************/
void convert_new_intra_freq_cell_si_list_rscp
(
 UMTS_NewIntraFreqCellSI_List_RSCP  *pvalue,
 new_intra_freq_cell_si_list_rscp_t *p_new_intra_freq_cell_si_list_rscp 
 )
{
    UMTS_NewIntraFreqCellSI_RSCP    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_new_intra_freq_cell_si_list_rscp->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewIntraFreqCellSI_RSCP*)pnode->data;

        if (pdata->m.intraFreqCellIDPresent)
        {
            p_new_intra_freq_cell_si_list_rscp->new_intra_freq_cell_si_rscp[index].presence_bitmask |=
                UMTS_SIB_NEW_INTRA_FREQ_CELL_SI_RSCP_INTRA_FREQ_CELL_ID_PRESENCE_FLAG;

            p_new_intra_freq_cell_si_list_rscp->new_intra_freq_cell_si_rscp[index].intra_freq_cell_id =
                pdata->intraFreqCellID;
        }

        convert_cell_info_si_rscp(
                &pdata->cellInfo,
                &p_new_intra_freq_cell_si_list_rscp->new_intra_freq_cell_si_rscp[index].cell_info_si_rscp);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_frequency_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FrequencyInfoFDD to
 *       frequency_info_fdd_t 
 *
 *******************************************************************************/
void convert_frequency_info_fdd
(
 UMTS_FrequencyInfoFDD  *pvalue,
 frequency_info_fdd_t   *p_frequency_info_fdd 
 )
{
    if (pvalue->m.uarfcn_ULPresent)
    {
        p_frequency_info_fdd->presence_bitmask |=
            UMTS_SIB_FREQ_INFO_FDD_UARFCN_UL_PRESENCE_FLAG;

        p_frequency_info_fdd->uarfcn_ul = pvalue->uarfcn_UL;
    }

    p_frequency_info_fdd->uarfcn_dl = pvalue->uarfcn_DL;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_frequency_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FrequencyInfoTDD to
 *       frequency_info_tdd_t 
 *
 *******************************************************************************/
void convert_frequency_info_tdd
(
 UMTS_FrequencyInfoTDD  *pvalue,
 frequency_info_tdd_t   *p_frequency_info_tdd 
 )
{
    p_frequency_info_tdd->uarfcn_nt = pvalue->uarfcn_Nt;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_frequency_info_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FrequencyInfo_modeSpecificInfo to
 *       frequency_info_mode_specific_info_t 
 *
 *******************************************************************************/
void convert_frequency_info_mode_specific_info
(
 UMTS_FrequencyInfo_modeSpecificInfo    *pvalue,
 frequency_info_mode_specific_info_t    *p_frequency_info_mode_specific_info 
 )
{
    p_frequency_info_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_FrequencyInfo_modeSpecificInfo_fdd)
    {
        convert_frequency_info_fdd(
                pvalue->u.fdd,
                &p_frequency_info_mode_specific_info->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_FrequencyInfo_modeSpecificInfo_tdd)
    {
        convert_frequency_info_tdd(
                pvalue->u.tdd,
                &p_frequency_info_mode_specific_info->u.tdd); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_frequency_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_FrequencyInfo to
 *       frequency_info_t 
 *
 *******************************************************************************/
void convert_frequency_info
(
 UMTS_FrequencyInfo     *pvalue,
 frequency_info_t       *p_frequency_info 
 )
{
    convert_frequency_info_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_frequency_info->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_si_list_rscp 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_NewInterFreqCellSI_List_RSCP 
 *        to new_inter_freq_cell_si_list_rscp_t
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_si_list_rscp
(
 UMTS_NewInterFreqCellSI_List_RSCP  *pvalue,
 new_inter_freq_cell_si_list_rscp_t *p_new_inter_freq_cell_si_list_rscp 
 )
{
    UMTS_NewInterFreqCellSI_RSCP    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_new_inter_freq_cell_si_list_rscp->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCellSI_RSCP*)pnode->data;

        if (pdata->m.interFreqCellIDPresent)
        {
            p_new_inter_freq_cell_si_list_rscp->new_inter_freq_cell_si_rscp[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_RSCP_INTER_FREQ_CELL_ID_PRESENCE_FLAG;

            p_new_inter_freq_cell_si_list_rscp->new_inter_freq_cell_si_rscp[index].inter_freq_cell_id =
                pdata->interFreqCellID;
        }

        if (pdata->m.frequencyInfoPresent)
        {
            p_new_inter_freq_cell_si_list_rscp->new_inter_freq_cell_si_rscp[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_RSCP_INTER_FREQ_INFO_PRESENCE_FLAG;

            convert_frequency_info(
                    &pdata->frequencyInfo,
                    &p_new_inter_freq_cell_si_list_rscp->new_inter_freq_cell_si_rscp[index].frequency_info);
        }

        convert_cell_info_si_rscp(
                &pdata->cellInfo,
                &p_new_inter_freq_cell_si_list_rscp->new_inter_freq_cell_si_rscp[index].cell_info);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP to
 *       measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP        *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp_t    *p_cpich_rscp 
 )
{
    if (pvalue->m.newIntraFreqCellListPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_NOT_USED_CELL_SELECT_QUALITY_MEAS_CPICH_RSCP_NEW_INTRA_FREQ_CELL_SI_LIST_RSCP_PRESENCE_FLAG;

        convert_new_intra_freq_cell_si_list_rscp(
                &pvalue->newIntraFreqCellList,
                &p_cpich_rscp->new_intra_freq_cell_si_list_rscp);
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_NOT_USED_CELL_SELECT_QUALITY_MEAS_CPICH_RSCP_NEW_INTER_FREQ_CELL_SI_LIST_RSCP_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_rscp(
                &pvalue->newInterFreqCellList,
                &p_cpich_rscp->new_inter_freq_cell_si_list_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_ecno_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_ECN0_modeSpecificInfo_fdd to
 *       cell_info_si_ecno_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_cell_info_si_ecno_mode_specific_info_fdd
(
 UMTS_CellInfoSI_ECN0_modeSpecificInfo_fdd  *pvalue,
 cell_info_si_ecno_mode_specific_info_fdd_t *p_mode_specific_info_fdd 
 )
{
    if (pvalue->m.primaryCPICH_InfoPresent)
    {
        p_mode_specific_info_fdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_MODE_SPECIFIC_INFO_FDD_PRIMARY_CPICH_INFO_PRESENCE_FLAG;

        convert_primary_cpich_info(
                &pvalue->primaryCPICH_Info,
                &p_mode_specific_info_fdd->primary_cpich_info);
    }

    if (pvalue->m.primaryCPICH_TX_PowerPresent)
    {
        p_mode_specific_info_fdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_MODE_SPECIFIC_INFO_FDD_PRIMARY_CPICH_TX_PWR_PRESENCE_FLAG;

        p_mode_specific_info_fdd->primary_cpich_tx_power = pvalue->primaryCPICH_TX_Power;
    }

    p_mode_specific_info_fdd->read_sfn_indicator = pvalue->readSFN_Indicator;
    p_mode_specific_info_fdd->tx_diversity_indicator = pvalue->tx_DiversityIndicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_ecno_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_ECN0_modeSpecificInfo_tdd to
 *       cell_info_si_ecno_mode_specific_info_tdd_t
 *
 *******************************************************************************/
void convert_cell_info_si_ecno_mode_specific_info_tdd
(
 UMTS_CellInfoSI_ECN0_modeSpecificInfo_tdd  *pvalue,
 cell_info_si_ecno_mode_specific_info_tdd_t *p_mode_specific_info_tdd 
 )
{
    convert_primary_ccpch_info(
            &pvalue->primaryCCPCH_Info,
            &p_mode_specific_info_tdd->primary_ccpch_info);

    if (pvalue->m.primaryCCPCH_TX_PowerPresent)
    {
        p_mode_specific_info_tdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_MODE_SPECIFIC_INFO_TDD_PRIMARY_CCPCH_TX_PWR_PRESENCE_FLAG;

        p_mode_specific_info_tdd->primary_ccpch_tx_power =
            pvalue->primaryCCPCH_TX_Power;
    }

    if (pvalue->m.timeslotInfoListPresent)
    {
        p_mode_specific_info_tdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_MODE_SPECIFIC_INFO_TDD_TIME_SLOT_INFO_LIST_PRESENCE_FLAG;

        convert_timeslot_info_list(
                &pvalue->timeslotInfoList,
                &p_mode_specific_info_tdd->timeslot_info_list);
    }

    p_mode_specific_info_tdd->read_sfn_indicator = pvalue->readSFN_Indicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_ecno_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_ECN0_modeSpecificInfo to
 *       cell_info_si_ecno_mode_specific_info_t
 *
 *******************************************************************************/
void convert_cell_info_si_ecno_mode_specific_info
(
 UMTS_CellInfoSI_ECN0_modeSpecificInfo      *pvalue,
 cell_info_si_ecno_mode_specific_info_t     *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellInfoSI_ECN0_modeSpecificInfo_fdd)
    {
        convert_cell_info_si_ecno_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_CellInfoSI_ECN0_modeSpecificInfo_tdd)
    {
        convert_cell_info_si_ecno_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd to
 *       cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_fdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd     *pvalue,
 cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_fdd_t  *p_fdd 
 )
{
    if (pvalue->m.q_QualMinPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_ECNO_MODE_SPECIFIC_INFO_FDD_Q_QUAL_MIN_PRESENCE_FLAG;

        p_fdd->q_qual_min = pvalue->q_QualMin; 
    }

    if (pvalue->m.q_RxlevMinPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_ECNO_MODE_SPECIFIC_INFO_FDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_fdd->q_rx_lev_min = pvalue->q_RxlevMin; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd to
 *       cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_tdd_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_tdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd     *pvalue,
 cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_tdd_t  *p_tdd 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_ECNO_MODE_SPECIFIC_INFO_TDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_tdd->q_rx_lev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_gsm 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm to
 *       cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_gsm_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_gsm
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm     *pvalue,
 cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_gsm_t  *p_gsm 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_gsm->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_ECNO_MODE_SPECIFIC_INFO_GSM_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_gsm->q_rx_lev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo to
 *       cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo     *pvalue,
 cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_t  *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_fdd)
    {
        convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_tdd)
    {
        convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_ECN0_modeSpecificInfo_gsm)
    {
        convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info_gsm(
                pvalue->u.gsm,
                &p_mode_specific_info->u.gsm);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_ECN0 to
 *       cell_select_reselect_info_sib_11_12_ecno_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_ecno
(
 UMTS_CellSelectReselectInfoSIB_11_12_ECN0  *pvalue,
 cell_select_reselect_info_sib_11_12_ecno_t *p_cell_select_reselect_info_sib_11_12_ecno 
 )
{
    p_cell_select_reselect_info_sib_11_12_ecno->q_offset_1s_n =
        pvalue->q_Offset1S_N;

    p_cell_select_reselect_info_sib_11_12_ecno->q_offset_2s_n =
        pvalue->q_Offset2S_N;

    if (pvalue->m.maxAllowedUL_TX_PowerPresent)
    {
        p_cell_select_reselect_info_sib_11_12_ecno->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_ECNO_MAX_ALLOWED_UL_TX_PWR_PRESENCE_FLAG;

        p_cell_select_reselect_info_sib_11_12_ecno->max_allowed_ul_tx_power =
            pvalue->maxAllowedUL_TX_Power;
    }

    convert_cell_select_reselect_info_sib_11_12_ecno_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_cell_select_reselect_info_sib_11_12_ecno->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_ECN0 to
 *       cell_info_si_ecno_t
 *
 *******************************************************************************/
void convert_cell_info_si_ecno
(
 UMTS_CellInfoSI_ECN0   *pvalue,
 cell_info_si_ecno_t    *p_cell_info_si_ecno 
 )
{
    p_cell_info_si_ecno->cell_individual_offset = pvalue->cellIndividualOffset;

    if (pvalue->m.referenceTimeDifferenceToCellPresent)
    {
        p_cell_info_si_ecno->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_REF_TIME_DIFF_TO_CELL_PRESENCE_FLAG;

        convert_reference_time_difference_to_cell(
                &pvalue->referenceTimeDifferenceToCell,
                &p_cell_info_si_ecno->reference_time_difference_to_cell);
    }

    convert_cell_info_si_ecno_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_cell_info_si_ecno->mode_specific_info);

    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_cell_info_si_ecno->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_CELL_SELECT_RESELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12_ecno(
                &pvalue->cellSelectionReselectionInfo,
                &p_cell_info_si_ecno->cell_select_reselect_info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_ECN0 to
 *       new_intra_freq_cell_si_list_ecno_t 
 *
 *******************************************************************************/
void convert_new_intra_freq_cell_si_list_ecno
(
 UMTS_NewIntraFreqCellSI_List_ECN0  *pvalue,
 new_intra_freq_cell_si_list_ecno_t *p_new_intra_freq_cell_si_list_ecno 
 )
{
    UMTS_NewIntraFreqCellSI_ECN0    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_new_intra_freq_cell_si_list_ecno->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewIntraFreqCellSI_ECN0*)pnode->data;

        if (pdata->m.intraFreqCellIDPresent)
        {
            p_new_intra_freq_cell_si_list_ecno->new_intra_freq_cell_si_ecno[index].presence_bitmask |=
                UMTS_SIB_NEW_INTRA_FREQ_CELL_SI_ECNO_INTRA_FREQ_CELL_ID_PRESENCE_FLAG;

            p_new_intra_freq_cell_si_list_ecno->new_intra_freq_cell_si_ecno[index].intra_freq_cell_id =
                pdata->intraFreqCellID;
        }

        convert_cell_info_si_ecno(
                &pdata->cellInfo,
                &p_new_intra_freq_cell_si_list_ecno->new_intra_freq_cell_si_ecno[index].cell_info_si_ecno);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_si_list_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_ECN0 to
 *       new_inter_freq_cell_si_list_ecno_t 
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_si_list_ecno
(
 UMTS_NewInterFreqCellSI_List_ECN0  *pvalue,
 new_inter_freq_cell_si_list_ecno_t *p_new_inter_freq_cell_si_list_ecno 
 )
{
    UMTS_NewInterFreqCellSI_ECN0    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_new_inter_freq_cell_si_list_ecno->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCellSI_ECN0*)pnode->data;

        if (pdata->m.interFreqCellIDPresent)
        {
            p_new_inter_freq_cell_si_list_ecno->new_inter_freq_cell_si_ecno[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_ECNO_INTER_FREQ_CELL_ID_PRESENCE_FLAG;

            p_new_inter_freq_cell_si_list_ecno->new_inter_freq_cell_si_ecno[index].inter_freq_cell_id =
                pdata->interFreqCellID;
        }

        convert_frequency_info(
                &pdata->frequencyInfo,
                &p_new_inter_freq_cell_si_list_ecno->new_inter_freq_cell_si_ecno[index].frequency_info);

        convert_cell_info_si_ecno(
                &pdata->cellInfo,
                &p_new_inter_freq_cell_si_list_ecno->new_inter_freq_cell_si_ecno[index].cell_info_si_ecno);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0 to
 *       measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0       *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no_t   *p_cpich_ec_no 
 )
{
    if (pvalue->m.newIntraFreqCellListPresent)
    {
        p_cpich_ec_no->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_NOT_USED_CELL_SELECT_QUALITY_MEAS_CPICH_ECNO_NEW_INTRA_FREQ_CELL_SI_LIST_ECNO_PRESENCE_FLAG;

        convert_new_intra_freq_cell_si_list_ecno(
                &pvalue->newIntraFreqCellList,
                &p_cpich_ec_no->new_intra_freq_cell_si_list_ecno); 
    }
    else if (pvalue->m.newInterFreqCellListPresent)
    {
        p_cpich_ec_no->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_NOT_USED_CELL_SELECT_QUALITY_MEAS_CPICH_ECNO_NEW_INTER_FREQ_CELL_SI_LIST_ECNO_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_ecno(
                &pvalue->newInterFreqCellList,
                &p_cpich_ec_no->new_inter_freq_cell_si_list_ecno); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used_cellSelectQualityMeasure to
 *       measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used_cellSelectQualityMeasure       *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_t   *p_cell_select_quality_measure
 )
{
    p_cell_select_quality_measure->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP)
    {
        convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp(
                pvalue->u.cpich_RSCP,
                &p_cell_select_quality_measure->u.cpich_rscp);
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no(
                pvalue->u.cpich_Ec_N0,
                &p_cell_select_quality_measure->u.cpich_ec_no); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_penalty_time_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PenaltyTime_RSCP to
 *       penalty_time_rscp_t 
 *
 *******************************************************************************/
void convert_penalty_time_rscp
(
 UMTS_PenaltyTime_RSCP  *pvalue,
 penalty_time_rscp_t    *p_penalty_time_rscp 
 )
{
    p_penalty_time_rscp->t = pvalue->t;

    if (pvalue->t == T_UMTS_PenaltyTime_RSCP_notUsed)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_RSCP_pt10)
    {
        p_penalty_time_rscp->u.pt10 = pvalue->u.pt10; 
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_RSCP_pt20)
    {
        p_penalty_time_rscp->u.pt20 = pvalue->u.pt20;
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_RSCP_pt30)
    {
        p_penalty_time_rscp->u.pt30 = pvalue->u.pt30;
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_RSCP_pt40)
    {
        p_penalty_time_rscp->u.pt40 = pvalue->u.pt40;
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_RSCP_pt50)
    {
        p_penalty_time_rscp->u.pt50 = pvalue->u.pt50;
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_RSCP_pt60)
    {
        p_penalty_time_rscp->u.pt60 = pvalue->u.pt60;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hcs_cell_reselect_info_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_HCS_CellReselectInformation_RSCP to
 *       hcs_cell_reselect_info_rscp_t 
 *
 *******************************************************************************/
void convert_hcs_cell_reselect_info_rscp
(
 UMTS_HCS_CellReselectInformation_RSCP  *pvalue,
 hcs_cell_reselect_info_rscp_t          *p_hcs_cell_reselect_info_rscp 
 )
{
    convert_penalty_time_rscp(
            &pvalue->penaltyTime,
            &p_hcs_cell_reselect_info_rscp->penalty_time_rscp);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hcs_neighboring_cell_info_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_HCS_NeighbouringCellInformation_RSCP to
 *       hcs_neighboring_cell_info_rscp_t 
 *
 *******************************************************************************/
void convert_hcs_neighboring_cell_info_rscp
(
 UMTS_HCS_NeighbouringCellInformation_RSCP      *pvalue,
 hcs_neighboring_cell_info_rscp_t               *p_hcs_neighboring_cell_info_rscp 
 )
{
    p_hcs_neighboring_cell_info_rscp->hcs_prio = pvalue->hcs_PRIO;
    p_hcs_neighboring_cell_info_rscp->q_hcs = pvalue->q_HCS;

    convert_hcs_cell_reselect_info_rscp(
            &pvalue->hcs_CellReselectInformation,
            &p_hcs_neighboring_cell_info_rscp->hcs_cell_reselect_info_rscp);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_fdd to
 *       cell_select_reselect_info_sib_11_12_mode_specific_info_fdd_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_mode_specific_info_fdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_fdd      *pvalue,
 cell_select_reselect_info_sib_11_12_mode_specific_info_fdd_t   *p_fdd 
 )
{
    if (pvalue->m.q_QualMinPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_MODE_SPECIFIC_INFO_FDD_Q_QUAL_MIN_PRESENCE_FLAG;

        p_fdd->q_qual_min = pvalue->q_QualMin;
    }

    if (pvalue->m.q_RxlevMinPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_MODE_SPECIFIC_INFO_FDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_fdd->q_rx_lev_min = pvalue->q_RxlevMin; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_tdd to
 *       cell_select_reselect_info_sib_11_12_mode_specific_info_tdd_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_mode_specific_info_tdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_tdd      *pvalue,
 cell_select_reselect_info_sib_11_12_mode_specific_info_tdd_t   *p_tdd 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_MODE_SPECIFIC_INFO_TDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_tdd->q_rx_lev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_mode_specific_info_gsm 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_gsm to
 *       cell_select_reselect_info_sib_11_12_mode_specific_info_gsm_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_mode_specific_info_gsm
(
 UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_gsm      *pvalue,
 cell_select_reselect_info_sib_11_12_mode_specific_info_gsm_t   *p_gsm 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_gsm->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_MODE_SPECIFIC_INFO_GSM_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_gsm->q_rx_lev_min = pvalue->q_RxlevMin; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo to
 *       cell_select_reselect_info_sib_11_12_mode_specific_info_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_mode_specific_info
(
 UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo      *pvalue,
 cell_select_reselect_info_sib_11_12_mode_specific_info_t   *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_fdd)
    {
        convert_cell_select_reselect_info_sib_11_12_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_tdd)
    {
        convert_cell_select_reselect_info_sib_11_12_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_modeSpecificInfo_gsm)
    {
        convert_cell_select_reselect_info_sib_11_12_mode_specific_info_gsm(
                pvalue->u.gsm,
                &p_mode_specific_info->u.gsm); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12 to
 *       cell_select_reselect_info_sib_11_12_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12
(
 UMTS_CellSelectReselectInfoSIB_11_12   *pvalue,
 cell_select_reselect_info_sib_11_12_t  *p_cell_select_reselect_info_sib_11_12 
 )
{
    p_cell_select_reselect_info_sib_11_12->q_offset_1s_n =
        pvalue->q_Offset1S_N;

    if (pvalue->m.q_Offset2S_NPresent)
    {
        p_cell_select_reselect_info_sib_11_12->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_11_12_Q_OFFSET_2S_N_PRESENCE_FLAG;

        p_cell_select_reselect_info_sib_11_12->q_offset_2s_n = pvalue->q_Offset2S_N;
    }

    if (pvalue->m.maxAllowedUL_TX_PowerPresent)
    {
        p_cell_select_reselect_info_sib_11_12->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_11_12_MAX_ALLOWED_UL_TX_PWR_PRESENCE_FLAG;

        p_cell_select_reselect_info_sib_11_12->max_allowed_ul_tx_power =
            pvalue->maxAllowedUL_TX_Power;
    }

    if (pvalue->m.hcs_NeighbouringCellInformation_RSCPPresent)
    {
        p_cell_select_reselect_info_sib_11_12->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_11_12_HCS_NEIGHBOURING_CELL_INFO_RSCP_PRESENCE_FLAG;

        convert_hcs_neighboring_cell_info_rscp(
                &pvalue->hcs_NeighbouringCellInformation_RSCP,
                &p_cell_select_reselect_info_sib_11_12->hcs_neighboring_cell_info_rscp);
    }

    convert_cell_select_reselect_info_sib_11_12_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_cell_select_reselect_info_sib_11_12->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_bsic 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_BSIC to
 *       bsic_t 
 *
 *******************************************************************************/
void convert_bsic
(
 UMTS_BSIC  *pvalue,
 bsic_t     *p_bsic 
 )
{
    p_bsic->ncc = pvalue->ncc;
    p_bsic->bcc = pvalue->bcc;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_technology_specific_info_gsm 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCell_technologySpecificInfo_gsm to
 *       new_inter_rat_cell_technology_specific_info_gsm_t 
 *
 *******************************************************************************/
void convert_new_inter_rat_cell_technology_specific_info_gsm
(
 UMTS_NewInterRATCell_technologySpecificInfo_gsm    *pvalue,
 new_inter_rat_cell_technology_specific_info_gsm_t  *p_gsm 
 )
{
    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_gsm->presence_bitmask |=
            UMTS_SIB_NEW_INTER_RAT_CELL_TECH_SPECIFIC_INFO_GSM_CELL_SELECT_RELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12(
                &pvalue->cellSelectionReselectionInfo,
                &p_gsm->cell_select_reselect_info_sib_11_12);
    }

    p_gsm->inter_rat_cell_individual_offset = pvalue->interRATCellIndividualOffset;

    if (pvalue->m.dummyPresent)
    {
        p_gsm->presence_bitmask |= UMTS_SIB_NEW_INTER_RAT_CELL_TECH_SPECIFIC_INFO_GSM_DUMMY_PRESENCE_FLAG;

        convert_bsic(
                &pvalue->bsic,
                &p_gsm->bsic);
    }

    p_gsm->freq_band = pvalue->frequency_band;
    p_gsm->bcch_arfcn = pvalue->bcch_ARFCN;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_technology_specific_info_is_2000 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCell_technologySpecificInfo_is_2000 to
 *       new_inter_rat_cell_technology_specific_info_is_2000_t 
 *
 *******************************************************************************/
void convert_new_inter_rat_cell_technology_specific_info_is_2000
(
 UMTS_NewInterRATCell_technologySpecificInfo_is_2000    *pvalue,
 new_inter_rat_cell_technology_specific_info_is_2000_t  *p_is_2000 
 )
{
    p_is_2000->is_2000_specific_meas_info = pvalue->is_2000SpecificMeasInfo;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_technology_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCell_technologySpecificInfo to
 *       new_inter_rat_cell_technology_specific_info_t 
 *
 *******************************************************************************/
void convert_new_inter_rat_cell_technology_specific_info
(
 UMTS_NewInterRATCell_technologySpecificInfo    *pvalue,
 new_inter_rat_cell_technology_specific_info_t  *p_technology_specific_info 
 )
{
    p_technology_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_NewInterRATCell_technologySpecificInfo_gsm)
    {
        convert_new_inter_rat_cell_technology_specific_info_gsm(
                pvalue->u.gsm,
                &p_technology_specific_info->u.gsm);
    }
    else if (pvalue->t == T_UMTS_NewInterRATCell_technologySpecificInfo_is_2000)
    {
        convert_new_inter_rat_cell_technology_specific_info_is_2000(
                pvalue->u.is_2000,
                &p_technology_specific_info->u.is_2000);
    }
    else if (pvalue->t == T_UMTS_NewInterRATCell_technologySpecificInfo_absent)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_NewInterRATCell_technologySpecificInfo_spare1)
    {
        /* for future use */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_list 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCellList to
 *       new_inter_rat_cell_list_t 
 *
 *******************************************************************************/
void convert_new_inter_rat_cell_list
(
 UMTS_NewInterRATCellList   *pvalue,
 new_inter_rat_cell_list_t  *p_new_inter_rat_cell_list 
 )
{
    UMTS_NewInterRATCell    *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_new_inter_rat_cell_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterRATCell*)pnode->data;

        if (pdata->m.interRATCellIDPresent)
        {
            p_new_inter_rat_cell_list->new_inter_rat_cell[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_RAT_CELL_INTER_RAT_CELL_ID_PRESENCE_FLAG;

            p_new_inter_rat_cell_list->new_inter_rat_cell[index].inter_rat_cell_id =
                pdata->interRATCellID;
        }

        convert_new_inter_rat_cell_technology_specific_info(
                &pdata->technologySpecificInfo,
                &p_new_inter_rat_cell_list->new_inter_rat_cell[index].new_inter_rat_cell_technology_specific_info);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used to
 *       measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used    *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_t   *p_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used 
 )
{
    convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used->cell_select_quality_measure);

    if (pvalue->m.newInterRATCellListPresent)
    {
        p_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_NOT_USED_NEW_INTER_RAT_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_rat_cell_list(
                &pvalue->newInterRATCellList,
                &p_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used->new_inter_rat_cell_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_rscp_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_RSCP_modeSpecificInfo_fdd
 *       to cell_info_si_hcs_rscp_mode_specific_info_fdd_t 
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_rscp_mode_specific_info_fdd
(
 UMTS_CellInfoSI_HCS_RSCP_modeSpecificInfo_fdd  *pvalue,
 cell_info_si_hcs_rscp_mode_specific_info_fdd_t *p_fdd 
 )
{
    if (pvalue->m.primaryCPICH_InfoPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_MODE_SPECIFIC_INFO_FDD_PRIMARY_CPICH_INFO_PRESENCE_FLAG;

        convert_primary_cpich_info(
                &pvalue->primaryCPICH_Info,
                &p_fdd->primary_cpich_info);
    }

    if (pvalue->m.primaryCPICH_TX_PowerPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_MODE_SPECIFIC_INFO_FDD_PRIMARY_CPICH_TX_PWR_PRESENCE_FLAG;

        p_fdd->primary_cpich_tx_power = pvalue->primaryCPICH_TX_Power;
    }

    p_fdd->read_sfn_indicator = pvalue->readSFN_Indicator;
    p_fdd->tx_diversity_indicator = pvalue->tx_DiversityIndicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_rscp_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_RSCP_modeSpecificInfo_tdd
 *       to cell_info_si_hcs_rscp_mode_specific_info_tdd_t 
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_rscp_mode_specific_info_tdd
(
 UMTS_CellInfoSI_HCS_RSCP_modeSpecificInfo_tdd  *pvalue,
 cell_info_si_hcs_rscp_mode_specific_info_tdd_t *p_tdd 
 )
{
    convert_primary_ccpch_info(
            &pvalue->primaryCCPCH_Info,
            &p_tdd->primary_ccpch_info);

    if (pvalue->m.primaryCCPCH_TX_PowerPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_MODE_SPECIFIC_INFO_TDD_PRIMARY_CCPCH_TX_PWR_PRESENCE_FLAG;

        p_tdd->primary_ccpch_tx_power = pvalue->primaryCCPCH_TX_Power;
    }

    if (pvalue->m.timeslotInfoListPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_MODE_SPECIFIC_INFO_TDD_TIMESLOT_INFO_LIST_PRESENCE_FLAG;

        convert_timeslot_info_list(
                &pvalue->timeslotInfoList,
                &p_tdd->timeslot_info_list);
    }

    p_tdd->read_sfn_indicator = pvalue->readSFN_Indicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_rscp_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_RSCP_modeSpecificInfo
 *       to cell_info_si_hcs_rscp_mode_specific_info_t 
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_rscp_mode_specific_info
(
 UMTS_CellInfoSI_HCS_RSCP_modeSpecificInfo  *pvalue,
 cell_info_si_hcs_rscp_mode_specific_info_t *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellInfoSI_HCS_RSCP_modeSpecificInfo_fdd)
    {
        convert_cell_info_si_hcs_rscp_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_CellInfoSI_HCS_RSCP_modeSpecificInfo_tdd)
    {
        convert_cell_info_si_hcs_rscp_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hcs_neighbouring_cell_info_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_HCS_NeighbouringCellInformation_RSCP
 *       to hcs_neighbouring_cell_info_rscp_t 
 *
 *******************************************************************************/
void convert_hcs_neighbouring_cell_info_rscp
(
 UMTS_HCS_NeighbouringCellInformation_RSCP  *pvalue,
 hcs_neighbouring_cell_info_rscp_t          *p_hcs_neighbouring_cell_info_rscp 
 )
{
    p_hcs_neighbouring_cell_info_rscp->hcs_prio =
        pvalue->hcs_PRIO;

    p_hcs_neighbouring_cell_info_rscp->q_hcs =
        pvalue->q_HCS;

    convert_hcs_cell_reselect_info_rscp(
            &pvalue->hcs_CellReselectInformation,
            &p_hcs_neighbouring_cell_info_rscp->hcs_cell_reselect_info_rscp);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_fdd
 *       to cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_fdd_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_fdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_fdd     *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_fdd_t  *p_fdd 
 )
{
    if (pvalue->m.q_QualMinPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_RSCP_MODE_SPECIFIC_INFO_FDD_Q_QUAL_MIN_PRESENCE_FLAG;

        p_fdd->q_qual_min = pvalue->q_QualMin; 
    }

    if (pvalue->m.q_RxlevMinPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_RSCP_MODE_SPECIFIC_INFO_FDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_fdd->q_rxlev_min = pvalue->q_RxlevMin; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_tdd
 *       to cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_tdd_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_tdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_tdd     *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_tdd_t  *p_tdd 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_RSCP_MODE_SPECIFIC_INFO_TDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_tdd->q_rxlev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_gsm 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_gsm
 *       to cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_gsm_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_gsm
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_gsm     *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_gsm_t  *p_gsm 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_gsm->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_RSCP_MODE_SPECIFIC_INFO_GSM_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_gsm->q_rxlev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo
 *       to cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo     *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_t  *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_fdd)
    {
        convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_tdd)
    {
        convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd); 
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_gsm)
    {
        convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info_gsm(
                pvalue->u.gsm,
                &p_mode_specific_info->u.gsm);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP
 *       to cell_select_reselect_info_sib_11_12_hcs_rscp_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_rscp
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_RSCP  *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_rscp_t *p_rscp 
 )
{
    p_rscp->q_offset_s_n = pvalue->q_OffsetS_N;

    if (pvalue->m.maxAllowedUL_TX_PowerPresent)
    {
        p_rscp->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_RSCP_MAX_ALLOWED_UL_TX_PWR_PRESENCE_FLAG;

        p_rscp->max_allowed_ul_tx_power = pvalue->maxAllowedUL_TX_Power;
    }

    if (pvalue->m.hcs_NeighbouringCellInformation_RSCPPresent)
    {
        p_rscp->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_RSCP_HCS_NEIGHBOURING_CELL_INFO_RSCP_PRESENCE_FLAG;

        convert_hcs_neighbouring_cell_info_rscp(
                &pvalue->hcs_NeighbouringCellInformation_RSCP,
                &p_rscp->hcs_neighbouring_cell_info_rscp);
    }

    convert_cell_select_reselect_info_sib_11_12_hcs_rscp_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_rscp->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_RSCP
 *       to cell_info_si_hcs_rscp_t 
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_rscp
(
 UMTS_CellInfoSI_HCS_RSCP   *pvalue,
 cell_info_si_hcs_rscp_t    *p_cell_info_si_hcs_rscp 
 )
{
    p_cell_info_si_hcs_rscp->cell_individual_offset =
        pvalue->cellIndividualOffset;

    if (pvalue->m.referenceTimeDifferenceToCellPresent)
    {
        p_cell_info_si_hcs_rscp->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_REF_TIME_DIFF_TO_CELL_PRESENCE_FLAG;

        convert_reference_time_difference_to_cell(
                &pvalue->referenceTimeDifferenceToCell,
                &p_cell_info_si_hcs_rscp->reference_time_difference_to_cell);
    }

    convert_cell_info_si_hcs_rscp_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_cell_info_si_hcs_rscp->mode_specific_info);

    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_cell_info_si_hcs_rscp->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_CELL_SELECT_RELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12_hcs_rscp(
                &pvalue->cellSelectionReselectionInfo,
                &p_cell_info_si_hcs_rscp->cell_select_reselect_info_sib_11_12_hcs_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_hcs_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_HCS_RSCP
 *       to new_intra_freq_cell_si_list_hcs_rscp_t 
 *
 *******************************************************************************/
void convert_new_intra_freq_cell_si_list_hcs_rscp
(
 UMTS_NewIntraFreqCellSI_List_HCS_RSCP  *pvalue,
 new_intra_freq_cell_si_list_hcs_rscp_t *p_new_intra_freq_cell_si_list_hcs_rscp 
 )
{
    UMTS_NewIntraFreqCellSI_HCS_RSCP    *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_new_intra_freq_cell_si_list_hcs_rscp->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewIntraFreqCellSI_HCS_RSCP*)pnode->data;

        if (pdata->m.intraFreqCellIDPresent)
        {
            p_new_intra_freq_cell_si_list_hcs_rscp->new_intra_freq_cell_si_hcs_rscp[index].presence_bitmask |=
                UMTS_SIB_NEW_INTRA_FREQ_CELL_SI_HCS_RSCP_INTRA_FREQ_CELL_ID_PRESENCE_FLAG;

            p_new_intra_freq_cell_si_list_hcs_rscp->new_intra_freq_cell_si_hcs_rscp[index].intra_freq_cell_id =
                pdata->intraFreqCellID;
        }

        convert_cell_info_si_hcs_rscp(
                &pdata->cellInfo,
                &p_new_intra_freq_cell_si_list_hcs_rscp->new_intra_freq_cell_si_hcs_rscp[index].cell_info_si_hcs_rscp);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_si_list_hcs_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_HCS_RSCP
 *       to new_inter_freq_cell_si_list_hcs_rscp_t 
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_si_list_hcs_rscp
(
 UMTS_NewInterFreqCellSI_List_HCS_RSCP      *pvalue,
 new_inter_freq_cell_si_list_hcs_rscp_t     *p_new_inter_freq_cell_si_list_hcs_rscp 
 )
{
    UMTS_NewInterFreqCellSI_HCS_RSCP    *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_new_inter_freq_cell_si_list_hcs_rscp->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCellSI_HCS_RSCP*)pnode->data;

        if (pdata->m.interFreqCellIDPresent)
        {
            p_new_inter_freq_cell_si_list_hcs_rscp->new_inter_freq_cell_si_hcs_rscp[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_HCS_RSCP_INTER_FREQ_CELL_ID_PRESENCE_FLAG;

            p_new_inter_freq_cell_si_list_hcs_rscp->new_inter_freq_cell_si_hcs_rscp[index].inter_freq_cell_id =
                pdata->interFreqCellID;
        }

        if (pdata->m.frequencyInfoPresent)
        {
            p_new_inter_freq_cell_si_list_hcs_rscp->new_inter_freq_cell_si_hcs_rscp[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_HCS_RSCP_FREQ_INFO_PRESENCE_FLAG;

            convert_frequency_info(
                    &pdata->frequencyInfo,
                    &p_new_inter_freq_cell_si_list_hcs_rscp->new_inter_freq_cell_si_hcs_rscp[index].frequency_info);
        }

        convert_cell_info_si_hcs_rscp(
                &pdata->cellInfo,
                &p_new_inter_freq_cell_si_list_hcs_rscp->new_inter_freq_cell_si_hcs_rscp[index].cell_info_si_hcs_rscp);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP
 *       to
 *       measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP        *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp_t    *p_cpich_rscp 
 )
{
    if (pvalue->m.newIntraFreqCellListPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_USED_CELL_SELECT_QUALITY_MEAS_CPICH_RSCP_NEW_INTRA_FREQ_CELL_SI_LIST_HCS_RSCP_PRESENCE_FLAG;

        convert_new_intra_freq_cell_si_list_hcs_rscp(
                &pvalue->newIntraFreqCellList,
                &p_cpich_rscp->new_intra_freq_cell_si_list_hcs_rscp);
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_USED_CELL_SELECT_QUALITY_MEAS_CPICH_RSCP_NEW_INTER_FREQ_CELL_SI_LIST_HCS_RSCP_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_hcs_rscp(
                &pvalue->newInterFreqCellList,
                &p_cpich_rscp->new_inter_freq_cell_si_list_hcs_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_ecno_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_ECN0_modeSpecificInfo_fdd to
 *       cell_info_si_hcs_ecno_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_ecno_mode_specific_info_fdd
(
 UMTS_CellInfoSI_HCS_ECN0_modeSpecificInfo_fdd  *pvalue,
 cell_info_si_hcs_ecno_mode_specific_info_fdd_t *p_fdd 
 )
{
    if (pvalue->m.primaryCPICH_InfoPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_MODE_SPECIFIC_INFO_FDD_PRIMARY_CPICH_INFO_PRESENCE_FLAG;

        convert_primary_cpich_info(
                &pvalue->primaryCPICH_Info,
                &p_fdd->primary_cpich_info);
    }

    if (pvalue->m.primaryCPICH_TX_PowerPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_MODE_SPECIFIC_INFO_FDD_PRIMARY_CPICH_TX_PWR_PRESENCE_FLAG;

        p_fdd->primary_cpich_tx_power = pvalue->primaryCPICH_TX_Power;
    }

    p_fdd->read_sfn_indicator = pvalue->readSFN_Indicator;
    p_fdd->tx_diversity_indicator = pvalue->tx_DiversityIndicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_ecno_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_ECN0_modeSpecificInfo_tdd to
 *       cell_info_si_hcs_ecno_mode_specific_info_tdd_t
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_ecno_mode_specific_info_tdd
(
 UMTS_CellInfoSI_HCS_ECN0_modeSpecificInfo_tdd  *pvalue,
 cell_info_si_hcs_ecno_mode_specific_info_tdd_t *p_tdd 
 )
{
    convert_primary_ccpch_info(
            &pvalue->primaryCCPCH_Info,
            &p_tdd->primary_ccpch_info);

    if (pvalue->m.primaryCCPCH_TX_PowerPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_MODE_SPECIFIC_INFO_TDD_PRIMARY_CCPCH_TX_PWR_PRESENCE_FLAG;

        p_tdd->primary_ccpch_tx_power = pvalue->primaryCCPCH_TX_Power;
    }

    if (pvalue->m.timeslotInfoListPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_MODE_SPECIFIC_INFO_TDD_TIME_SLOT_INFO_LIST_PRESENCE_FLAG;

        convert_timeslot_info_list(
                &pvalue->timeslotInfoList,
                &p_tdd->timeslot_info_list);
    }

    p_tdd->read_sfn_indicator = pvalue->readSFN_Indicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_ecno_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_ECN0_modeSpecificInfo to
 *       cell_info_si_hcs_ecno_mode_specific_info_t
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_ecno_mode_specific_info
(
 UMTS_CellInfoSI_HCS_ECN0_modeSpecificInfo  *pvalue,
 cell_info_si_hcs_ecno_mode_specific_info_t *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellInfoSI_HCS_ECN0_modeSpecificInfo_fdd)
    {
        convert_cell_info_si_hcs_ecno_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_CellInfoSI_HCS_ECN0_modeSpecificInfo_tdd)
    {
        convert_cell_info_si_hcs_ecno_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_temporary_offset_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TemporaryOffsetList to
 *       temporary_offset_list_t
 *
 *******************************************************************************/
void convert_temporary_offset_list
(
 UMTS_TemporaryOffsetList   *pvalue,
 temporary_offset_list_t    *p_temporary_offset_list 
 )
{
    memcpy(p_temporary_offset_list, pvalue, sizeof(temporary_offset_list_t));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_penalty_time_ecno
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PenaltyTime_ECN0 to
 *       penalty_time_ecno_t
 *
 *******************************************************************************/
void convert_penalty_time_ecno
(
 UMTS_PenaltyTime_ECN0  *pvalue,
 penalty_time_ecno_t    *p_penalty_time_ecno 
 )
{
    p_penalty_time_ecno->t = pvalue->t;

    if (pvalue->t == T_UMTS_PenaltyTime_ECN0_notUsed)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_ECN0_pt10)
    {
        convert_temporary_offset_list(
                pvalue->u.pt10,
                &p_penalty_time_ecno->u.pt10); 
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_ECN0_pt20)
    {
        convert_temporary_offset_list(
                pvalue->u.pt20,
                &p_penalty_time_ecno->u.pt20); 
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_ECN0_pt30)
    {
        convert_temporary_offset_list(
                pvalue->u.pt30,
                &p_penalty_time_ecno->u.pt30);
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_ECN0_pt40)
    {
        convert_temporary_offset_list(
                pvalue->u.pt40,
                &p_penalty_time_ecno->u.pt40);
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_ECN0_pt50)
    {
        convert_temporary_offset_list(
                pvalue->u.pt50,
                &p_penalty_time_ecno->u.pt50);
    }
    else if (pvalue->t == T_UMTS_PenaltyTime_ECN0_pt60)
    {
        convert_temporary_offset_list(
                pvalue->u.pt60,
                &p_penalty_time_ecno->u.pt60);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hcs_cell_reselect_info_ecno
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_HCS_CellReselectInformation_ECN0 to
 *       hcs_cell_reselect_info_ecno_t
 *
 *******************************************************************************/
void convert_hcs_cell_reselect_info_ecno
(
 UMTS_HCS_CellReselectInformation_ECN0  *pvalue,
 hcs_cell_reselect_info_ecno_t          *p_hcs_cell_reselect_info_ecno 
 )
{
    convert_penalty_time_ecno(
            &pvalue->penaltyTime,
            &p_hcs_cell_reselect_info_ecno->penalty_time_ecno);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hcs_neighbouring_cell_info_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_HCS_NeighbouringCellInformation_ECN0 to
 *       hcs_neighbouring_cell_info_ecno_t
 *
 *******************************************************************************/
void convert_hcs_neighbouring_cell_info_ecno
(
 UMTS_HCS_NeighbouringCellInformation_ECN0  *pvalue,
 hcs_neighbouring_cell_info_ecno_t          *p_hcs_neighbouring_cell_info_ecno 
 )
{
    p_hcs_neighbouring_cell_info_ecno->hcs_prio = pvalue->hcs_PRIO;
    p_hcs_neighbouring_cell_info_ecno->q_hcs = pvalue->q_HCS;

    convert_hcs_cell_reselect_info_ecno(
            &pvalue->hcs_CellReselectInformation,
            &p_hcs_neighbouring_cell_info_ecno->hcs_cell_reselect_info_ecno);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_fdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_fdd to
 *       cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_fdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_fdd     *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_fdd_t  *p_fdd 
 )
{
    if (pvalue->m.q_QualMinPresent)
    {
        p_fdd->presence_bitmask |=
            CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_ECNO_MODE_SPECIFIC_INFO_FDD_Q_QUAL_MIN_PRESENCE_FLAG;

        p_fdd->q_qual_min = pvalue->q_QualMin;
    }

    if (pvalue->m.q_RxlevMinPresent)
    {
        p_fdd->presence_bitmask |=
            CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_ECNO_MODE_SPECIFIC_INFO_FDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_fdd->q_rxlev_min = pvalue->q_RxlevMin; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_tdd 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_tdd to
 *       cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_tdd_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_tdd
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_tdd     *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_tdd_t  *p_tdd 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_tdd->presence_bitmask |=
            CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_ECNO_MODE_SPECIFIC_INFO_TDD_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_tdd->q_rxlev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_gsm 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_gsm to
 *       cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_gsm_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_gsm
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_gsm     *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_gsm_t  *p_gsm 
 )
{
    if (pvalue->m.q_RxlevMinPresent)
    {
        p_gsm->presence_bitmask |=
            CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_ECNO_MODE_SPECIFIC_INFO_GSM_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_gsm->q_rxlev_min = pvalue->q_RxlevMin;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo to
 *       cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo     *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_t  *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_fdd)
    {
        convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_tdd)
    {
        convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0_modeSpecificInfo_gsm)
    {
        convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info_gsm(
                pvalue->u.gsm,
                &p_mode_specific_info->u.gsm);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_sib_11_12_hcs_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0 to
 *       cell_select_reselect_info_sib_11_12_hcs_ecno_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_sib_11_12_hcs_ecno
(
 UMTS_CellSelectReselectInfoSIB_11_12_HCS_ECN0  *pvalue,
 cell_select_reselect_info_sib_11_12_hcs_ecno_t *p_ecno 
 )
{
    p_ecno->q_offset_1s_n = pvalue->q_Offset1S_N;
    p_ecno->q_offset_2s_n = pvalue->q_Offset2S_N;

    if (pvalue->m.maxAllowedUL_TX_PowerPresent)
    {
        p_ecno->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_ECNO_MAX_ALLOWED_UL_TX_PWR_PRESENCE_FLAG;

        p_ecno->max_allowed_ul_tx_power = pvalue->maxAllowedUL_TX_Power;
    }

    if (pvalue->m.hcs_NeighbouringCellInformation_ECN0Present)
    {
        p_ecno->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_SIB_11_12_HCS_ECNO_HCS_NEIGHBOURING_CELL_INFO_ECNO_PRESENCE_FLAG;

        convert_hcs_neighbouring_cell_info_ecno(
                &pvalue->hcs_NeighbouringCellInformation_ECN0,
                &p_ecno->hcs_neighbouring_cell_info_ecno);
    }

    convert_cell_select_reselect_info_sib_11_12_hcs_ecno_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_ecno->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_ECN0 to
 *       cell_info_si_hcs_ecno_t
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_ecno
(
 UMTS_CellInfoSI_HCS_ECN0   *pvalue,
 cell_info_si_hcs_ecno_t    *p_cell_info_si_hcs_ecno 
 )
{
    p_cell_info_si_hcs_ecno->cell_individual_offset =
        pvalue->cellIndividualOffset;

    if (pvalue->m.referenceTimeDifferenceToCellPresent)
    {
        p_cell_info_si_hcs_ecno->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_REF_TIME_DIFF_TO_CELL_PRESENCE_FLAG;

        convert_reference_time_difference_to_cell(
                &pvalue->referenceTimeDifferenceToCell,
                &p_cell_info_si_hcs_ecno->reference_time_difference_to_cell);
    }

    convert_cell_info_si_hcs_ecno_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_cell_info_si_hcs_ecno->mode_specific_info);

    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_cell_info_si_hcs_ecno->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_CELL_SELECT_RESELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12_hcs_ecno(
                &pvalue->cellSelectionReselectionInfo,
                &p_cell_info_si_hcs_ecno->cell_select_reselect_info_sib_11_12_hcs_ecno);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_hcs_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_HCS_ECN0 to
 *       new_intra_freq_cell_si_list_hcs_ecno_t
 *
 *******************************************************************************/
void convert_new_intra_freq_cell_si_list_hcs_ecno
(
 UMTS_NewIntraFreqCellSI_List_HCS_ECN0  *pvalue,
 new_intra_freq_cell_si_list_hcs_ecno_t *p_ecno 
 )
{
    UMTS_NewIntraFreqCellSI_HCS_ECN0    *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_ecno->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewIntraFreqCellSI_HCS_ECN0*)pnode->data;

        if (pdata->m.intraFreqCellIDPresent)
        {
            p_ecno->new_intra_freq_cell_si_hcs_ecno[index].presence_bitmask |=
                UMTS_SIB_NEW_INTRA_FREQ_CELL_SI_HCS_ECNO_INTRA_FREQ_CELL_ID_PRESENCE_FLAG;

            p_ecno->new_intra_freq_cell_si_hcs_ecno[index].intra_freq_cell_id =
                pdata->intraFreqCellID;
        }

        convert_cell_info_si_hcs_ecno(
                &pdata->cellInfo,
                &p_ecno->new_intra_freq_cell_si_hcs_ecno[index].cell_info_si_hcs_ecno);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_si_list_hcs_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_HCS_ECN0 to
 *       new_inter_freq_cell_si_list_hcs_ecno_t
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_si_list_hcs_ecno
(
 UMTS_NewInterFreqCellSI_List_HCS_ECN0  *pvalue,
 new_inter_freq_cell_si_list_hcs_ecno_t *p_ecno 
 )
{
    UMTS_NewInterFreqCellSI_HCS_ECN0    *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_ecno->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCellSI_HCS_ECN0*)pnode->data;

        if (pdata->m.interFreqCellIDPresent)
        {
            p_ecno->new_inter_freq_cell_si_hcs_ecno[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_HCS_ECNO_INTER_FREQ_CELL_ID_PRESENCE_FLAG;

            p_ecno->new_inter_freq_cell_si_hcs_ecno[index].inter_freq_cell_id=
                pdata->interFreqCellID;
        }

        if (pdata->m.frequencyInfoPresent)
        {
            p_ecno->new_inter_freq_cell_si_hcs_ecno[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_HCS_ECNO_FREQ_INFO_PRESENCE_FLAG;

            convert_frequency_info(
                    &pdata->frequencyInfo,
                    &p_ecno->new_inter_freq_cell_si_hcs_ecno[index].frequency_info);
        }

        convert_cell_info_si_hcs_ecno(
                &pdata->cellInfo,
                &p_ecno->new_inter_freq_cell_si_hcs_ecno[index].cell_info_si_hcs_ecno);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0 to
 *       measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no_t
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0       *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no_t   *p_ec_no 
 )
{
    if (pvalue->m.newIntraFreqCellListPresent)
    {
        p_ec_no->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_USED_CELL_SELECT_QUALITY_MEAS_CPICH_RSCP_NEW_INTRA_FREQ_CELL_SI_LIST_HCS_ECNO_PRESENCE_FLAG;

        convert_new_intra_freq_cell_si_list_hcs_ecno(
                &pvalue->newIntraFreqCellList,
                &p_ec_no->new_intra_freq_cell_si_list_hcs_ecno);
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_ec_no->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_USED_CELL_SELECT_QUALITY_MEAS_CPICH_RSCP_NEW_INTER_FREQ_CELL_SI_LIST_HCS_ECNO_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_hcs_ecno(
                &pvalue->newInterFreqCellList,
                &p_ec_no->new_inter_freq_cell_si_list_hcs_ecno);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used_cellSelectQualityMeasure to
 *       measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used_cellSelectQualityMeasure       *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_t   *p_cell_select_quality_measure
 )
{
    p_cell_select_quality_measure->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP)
    {
        convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp(
                pvalue->u.cpich_RSCP,
                &p_cell_select_quality_measure->u.cpich_rscp); 
    }
    else if(pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no(
                pvalue->u.cpich_Ec_N0,
                &p_cell_select_quality_measure->u.cpich_ec_no); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used to
 *       measurement_control_sys_info_extension_use_of_hcs_hcs_used_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used    *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_hcs_used_t   *p_hcs_used 
 )
{
    convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_hcs_used->cell_select_quality_measure);

    if (pvalue->m.newInterRATCellListPresent)
    {
        p_hcs_used->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_USE_OF_HCS_HCS_USED_NEW_INTER_RAT_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_rat_cell_list(
                &pvalue->newInterRATCellList,
                &p_hcs_used->new_inter_rat_cell_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_use_of_hcs 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_MeasurementControlSysInfoExtension_use_of_HCS to
 *       measurement_control_sys_info_extension_use_of_hcs_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_use_of_hcs
(
 UMTS_MeasurementControlSysInfoExtension_use_of_HCS     *pvalue,
 measurement_control_sys_info_extension_use_of_hcs_t    *p_measurement_control_sys_info_extension_use_of_hcs 
 )
{
    p_measurement_control_sys_info_extension_use_of_hcs->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_not_used)
    {
        convert_measurement_control_sys_info_extension_use_of_hcs_hcs_not_used(
                pvalue->u.hcs_not_used,
                &p_measurement_control_sys_info_extension_use_of_hcs->u.hcs_not_used);
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used)
    {
        convert_measurement_control_sys_info_extension_use_of_hcs_hcs_used(
                pvalue->u.hcs_used,
                &p_measurement_control_sys_info_extension_use_of_hcs->u.hcs_used); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension 
 *
 *   DESCRIPTION:
 *       This function converts UMTS_MeasurementControlSysInfoExtension to
 *       measurement_control_sys_info_extension_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension
(
 UMTS_MeasurementControlSysInfoExtension    *pvalue,
 measurement_control_sys_info_extension_t   *p_lcr_r4 
 )
{
    convert_measurement_control_sys_info_extension_use_of_hcs(
            &pvalue->use_of_HCS,
            &p_lcr_r4->use_of_hcs);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_primary_ccpch_info_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PrimaryCCPCH_Info_LCR_r4 to
 *       primary_ccpch_info_lcr_r4_t 
 *
 *******************************************************************************/
void convert_primary_ccpch_info_lcr_r4
(
 UMTS_PrimaryCCPCH_Info_LCR_r4  *pvalue,
 primary_ccpch_info_lcr_r4_t    *p_primary_ccpch_info_lcr_r4 
 )
{
    p_primary_ccpch_info_lcr_r4->tstd_indicator =
        pvalue->tstd_Indicator;

    if (pvalue->m.cellParametersIDPresent)
    {
        p_primary_ccpch_info_lcr_r4->presence_bitmask |=
            UMTS_SIB_PRIMARY_CCPCH_INFO_LCR_R4_CELL_PARAMS_ID_PRESENCE_FLAG;

        p_primary_ccpch_info_lcr_r4->cell_parameters_id =
            pvalue->cellParametersID;
    }

    p_primary_ccpch_info_lcr_r4->sctd_indicator =
        pvalue->sctd_Indicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_timeslot_info_list_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_TimeslotInfoList_LCR_r4 to
 *       timeslot_info_list_lcr_r4_t 
 *
 *******************************************************************************/
void convert_timeslot_info_list_lcr_r4
(
 UMTS_TimeslotInfoList_LCR_r4   *pvalue,
 timeslot_info_list_lcr_r4_t    *p_timeslot_info_list_lcr_r4 
 )
{
    UMTS_TimeslotInfo_LCR_r4    *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_timeslot_info_list_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TimeslotInfo_LCR_r4*)pnode->data;

        p_timeslot_info_list_lcr_r4->timeslot_info_lcr_r4[index].timeslot_number =
            pdata->timeslotNumber;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_RSCP_LCR_r4 to
 *       cell_info_si_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_cell_info_si_rscp_lcr_r4
(
 UMTS_CellInfoSI_RSCP_LCR_r4    *pvalue,
 cell_info_si_rscp_lcr_r4_t     *p_cell_info_si_rscp_lcr_r4 
 )
{
    p_cell_info_si_rscp_lcr_r4->cell_individual_offset =
        pvalue->cellIndividualOffset;

    if (pvalue->m.referenceTimeDifferenceToCellPresent)
    {
        p_cell_info_si_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_RSCP_LCR_R4_REF_TIME_DIFF_TO_CELL_PRESENCE_FLAG;

        convert_reference_time_difference_to_cell(
                &pvalue->referenceTimeDifferenceToCell,
                &p_cell_info_si_rscp_lcr_r4->reference_time_difference_to_cell);
    }

    convert_primary_ccpch_info_lcr_r4(
            &pvalue->primaryCCPCH_Info,
            &p_cell_info_si_rscp_lcr_r4->primary_ccpch_info_lcr_r4);

    if (pvalue->m.primaryCCPCH_TX_PowerPresent)
    {
        p_cell_info_si_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_RSCP_LCR_R4_PRIMARY_CCPCH_TX_PWR_PRESENCE_FLAG;

        p_cell_info_si_rscp_lcr_r4->primary_ccpch_tx_power =
            pvalue->primaryCCPCH_TX_Power;
    }

    if (pvalue->m.timeslotInfoListPresent)
    {
        p_cell_info_si_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_RSCP_LCR_R4_TIMESLOT_INFO_LIST_PRESENCE_FLAG;

        convert_timeslot_info_list_lcr_r4(
                &pvalue->timeslotInfoList,
                &p_cell_info_si_rscp_lcr_r4->timeslot_info_list_lcr_r4);
    }

    p_cell_info_si_rscp_lcr_r4->read_sfn_indicator = pvalue->readSFN_Indicator;

    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_cell_info_si_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_RSCP_LCR_R4_CELL_SELECT_RESELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12_rscp(
                &pvalue->cellSelectionReselectionInfo,
                &p_cell_info_si_rscp_lcr_r4->cell_select_reselect_info_sib_11_12_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_RSCP_LCR_r4 to
 *       new_intra_freq_cell_si_list_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_new_intra_freq_cell_si_list_rscp_lcr_r4
(
 UMTS_NewIntraFreqCellSI_List_RSCP_LCR_r4   *pvalue,
 new_intra_freq_cell_si_list_rscp_lcr_r4_t  *p_lcr_r4 
 )
{
    UMTS_NewIntraFreqCellSI_RSCP_LCR_r4 *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewIntraFreqCellSI_RSCP_LCR_r4*)pnode->data;

        if (pdata->m.intraFreqCellIDPresent)
        {
            p_lcr_r4->new_intra_freq_cell_si_rscp_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTRA_FREQ_CELL_SI_RSCP_LCR_R4_INTRA_FREQ_CELL_ID_PRESENCE_FLAG;

            p_lcr_r4->new_intra_freq_cell_si_rscp_lcr_r4[index].intra_freq_cell_id =
                pdata->intraFreqCellID;
        }

        convert_cell_info_si_rscp_lcr_r4(
                &pdata->cellInfo,
                &p_lcr_r4->new_intra_freq_cell_si_rscp_lcr_r4[index].cell_info_si_rscp_lcr_r4);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_si_list_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_RSCP_LCR_r4 to
 *       new_inter_freq_cell_si_list_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_si_list_rscp_lcr_r4
(
 UMTS_NewInterFreqCellSI_List_RSCP_LCR_r4   *pvalue,
 new_inter_freq_cell_si_list_rscp_lcr_r4_t  *p_lcr_r4 
 )
{
    UMTS_NewInterFreqCellSI_RSCP_LCR_r4 *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCellSI_RSCP_LCR_r4*)pnode->data;

        if (pdata->m.interFreqCellIDPresent)
        {
            p_lcr_r4->new_inter_freq_cell_si_rscp_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_RSCP_LCR_R4_INTER_FREQ_CELL_ID_PRESENCE_FLAG;

            p_lcr_r4->new_inter_freq_cell_si_rscp_lcr_r4[index].inter_freq_cell_id =
                pdata->interFreqCellID;
        }

        if (pdata->m.frequencyInfoPresent)
        {
            p_lcr_r4->new_inter_freq_cell_si_rscp_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_RSCP_LCR_R4_FREQUENCY_INFO_PRESENCE_FLAG;

            convert_frequency_info(
                    &pdata->frequencyInfo,
                    &p_lcr_r4->new_inter_freq_cell_si_rscp_lcr_r4[index].frequency_info);
        }

        convert_cell_info_si_rscp_lcr_r4(
                &pdata->cellInfo,
                &p_lcr_r4->new_inter_freq_cell_si_rscp_lcr_r4[index].cell_info_si_rscp_lcr_r4);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP     *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp_t *p_cpich_rscp 
 )
{
    if (pvalue->m.newIntraFreqCellListPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_NEW_INTRA_FREQ_CELL_SI_LIST_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_new_intra_freq_cell_si_list_rscp_lcr_r4(
                &pvalue->newIntraFreqCellList,
                &p_cpich_rscp->new_intra_freq_cell_si_list_rscp_lcr_r4);
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_NEW_INTER_FREQ_CELL_SI_LIST_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_rscp_lcr_r4(
                &pvalue->newInterFreqCellList,
                &p_cpich_rscp->new_inter_freq_cell_si_list_rscp_lcr_r4);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_ECN0_LCR_r4 to
 *       cell_info_si_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_cell_info_si_ecno_lcr_r4
(
 UMTS_CellInfoSI_ECN0_LCR_r4    *pvalue,
 cell_info_si_ecno_lcr_r4_t     *p_cell_info_si_ecno_lcr_r4 
 )
{
    p_cell_info_si_ecno_lcr_r4->cell_individual_offset =
        pvalue->cellIndividualOffset;

    if (pvalue->m.referenceTimeDifferenceToCellPresent)
    {
        p_cell_info_si_ecno_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_LCR_R4_REF_TIME_DIFF_TO_CELL_PRESENCE_FLAG;

        convert_reference_time_difference_to_cell(
                &pvalue->referenceTimeDifferenceToCell,
                &p_cell_info_si_ecno_lcr_r4->reference_time_difference_to_cell);
    }

    convert_primary_ccpch_info_lcr_r4(
            &pvalue->primaryCCPCH_Info,
            &p_cell_info_si_ecno_lcr_r4->primary_ccpch_info_lcr_r4);

    if (pvalue->m.primaryCCPCH_TX_PowerPresent)
    {
        p_cell_info_si_ecno_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_LCR_R4_PRIMARY_CCPCH_TX_PWR_PRESENCE_FLAG;

        p_cell_info_si_ecno_lcr_r4->primary_ccpch_tx_power =
            pvalue->primaryCCPCH_TX_Power;
    }

    if (pvalue->m.timeslotInfoListPresent)
    {
        p_cell_info_si_ecno_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_LCR_R4_TIMESLOT_INFO_LIST_PRESENCE_FLAG;

        convert_timeslot_info_list_lcr_r4(
                &pvalue->timeslotInfoList,
                &p_cell_info_si_ecno_lcr_r4->timeslot_info_list_lcr_r4);
    }

    p_cell_info_si_ecno_lcr_r4->read_sfn_indicator =
        pvalue->readSFN_Indicator;

    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_cell_info_si_ecno_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_ECNO_LCR_R4_CELL_SELECT_RESELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12_ecno(
                &pvalue->cellSelectionReselectionInfo,
                &p_cell_info_si_ecno_lcr_r4->cell_select_reselect_info_sib_11_12_ecno);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_ECN0_LCR_r4 to
 *       new_intra_freq_cell_si_list_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_new_intra_freq_cell_si_list_ecno_lcr_r4
(
 UMTS_NewIntraFreqCellSI_List_ECN0_LCR_r4   *pvalue,
 new_intra_freq_cell_si_list_ecno_lcr_r4_t  *p_lcr_r4 
 )
{
    UMTS_NewIntraFreqCellSI_ECN0_LCR_r4 *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewIntraFreqCellSI_ECN0_LCR_r4*)pnode->data;

        if (pdata->m.intraFreqCellIDPresent)
        {
            p_lcr_r4->new_intra_freq_cell_si_ecno_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTRA_FREQ_CELL_SI_ECNO_LCR_R4_INTRA_FREQ_CELL_ID_PRESENCE_FLAG;

            p_lcr_r4->new_intra_freq_cell_si_ecno_lcr_r4[index].intra_freq_cell_id =
                pdata->intraFreqCellID;
        }

        convert_cell_info_si_ecno_lcr_r4(
                &pdata->cellInfo,
                &p_lcr_r4->new_intra_freq_cell_si_ecno_lcr_r4[index].cell_info_si_ecno_lcr_r4);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_si_list_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_ECN0_LCR_r4 to
 *       new_inter_freq_cell_si_list_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_si_list_ecno_lcr_r4
(
 UMTS_NewInterFreqCellSI_List_ECN0_LCR_r4   *pvalue,
 new_inter_freq_cell_si_list_ecno_lcr_r4_t  *p_lcr_r4 
 )
{
    UMTS_NewInterFreqCellSI_ECN0_LCR_r4 *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCellSI_ECN0_LCR_r4*)pnode->data;

        if (pdata->m.interFreqCellIDPresent)
        {
            p_lcr_r4->new_inter_freq_cell_si_ecno_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_ECNO_LCR_R4_INTER_FREQ_CELL_ID_PRESENCE_FLAG;

            p_lcr_r4->new_inter_freq_cell_si_ecno_lcr_r4[index].inter_freq_cell_id = 
                pdata->interFreqCellID;
        }

        if (pdata->m.frequencyInfoPresent)
        {
            p_lcr_r4->new_inter_freq_cell_si_ecno_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_ECNO_LCR_R4_FREQ_INFO_PRESENCE_FLAG;

            convert_frequency_info(
                    &pdata->frequencyInfo,
                    &p_lcr_r4->new_inter_freq_cell_si_ecno_lcr_r4[index].frequency_info);
        }

        convert_cell_info_si_ecno_lcr_r4(
                &pdata->cellInfo,
                &p_lcr_r4->new_inter_freq_cell_si_ecno_lcr_r4[index].cell_info_si_ecno_lcr_r4);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0 to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0        *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no_t    *p_ec_no 
 )
{
    if (pvalue->m.newIntraFreqCellListPresent)
    {
        p_ec_no->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_LCR_R4_NEW_INTRA_FREQ_CELL_SI_LIST_ECNO_LCR_R4_PRESENCE_FLAG;

        convert_new_intra_freq_cell_si_list_ecno_lcr_r4(
                &pvalue->newIntraFreqCellList,
                &p_ec_no->new_intra_freq_cell_si_list_ecno_lcr_r4);
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_ec_no->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_LCR_R4_NEW_INTER_FREQ_CELL_SI_LIST_ECNO_LCR_R4_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_ecno_lcr_r4(
                &pvalue->newInterFreqCellList,
                &p_ec_no->new_inter_freq_cell_si_list_ecno_lcr_r4); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used_cellSelectQualityMeasure to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used_cellSelectQualityMeasure        *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_t    *p_cell_select_quality_measure 
 )
{
    p_cell_select_quality_measure->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP)
    {
        convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp(
                pvalue->u.cpich_RSCP,
                &p_cell_select_quality_measure->u.cpich_rscp); 
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no(
                pvalue->u.cpich_Ec_N0,
                &p_cell_select_quality_measure->u.cpich_ec_no); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used     *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_t    *p_hcs_not_used 
 )
{
    convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_hcs_not_used->cell_select_quality_measure);

    if (pvalue->m.newInterRATCellListPresent)
    {
        p_hcs_not_used->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_LCR_R4_USE_OF_HCS_HCS_NOT_USED_NEW_INTER_RAT_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_rat_cell_list(
                &pvalue->newInterRATCellList,
                &p_hcs_not_used->new_inter_rat_cell_list); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_RSCP_LCR_r4 to
 *       cell_info_si_hcs_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_rscp_lcr_r4
(
 UMTS_CellInfoSI_HCS_RSCP_LCR_r4    *pvalue,
 cell_info_si_hcs_rscp_lcr_r4_t     *p_cell_info_si_hcs_rscp_lcr_r4 
 )
{
    p_cell_info_si_hcs_rscp_lcr_r4->cell_individual_offset =
        pvalue->cellIndividualOffset;

    if (pvalue->m.referenceTimeDifferenceToCellPresent)
    {
        p_cell_info_si_hcs_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_LCR_R4_REF_TIME_DIFF_TO_CELL_PRESENCE_FLAG;

        convert_reference_time_difference_to_cell(
                &pvalue->referenceTimeDifferenceToCell,
                &p_cell_info_si_hcs_rscp_lcr_r4->reference_time_difference_to_cell);
    }

    convert_primary_ccpch_info_lcr_r4(
            &pvalue->primaryCCPCH_Info,
            &p_cell_info_si_hcs_rscp_lcr_r4->primary_ccpch_info_lcr_r4);

    if (pvalue->m.primaryCCPCH_TX_PowerPresent)
    {
        p_cell_info_si_hcs_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_LCR_R4_PRIMARY_CCPCH_TX_PWR_PRESENCE_FLAG;

        p_cell_info_si_hcs_rscp_lcr_r4->primary_ccpch_tx_power =
            pvalue->primaryCCPCH_TX_Power;
    }

    if (pvalue->m.timeslotInfoListPresent)
    {
        p_cell_info_si_hcs_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_LCR_R4_TIMESLOT_INFO_LIST_PRESENCE_FLAG;

        convert_timeslot_info_list_lcr_r4(
                &pvalue->timeslotInfoList,
                &p_cell_info_si_hcs_rscp_lcr_r4->timeslot_info_list_lcr_r4);
    }

    p_cell_info_si_hcs_rscp_lcr_r4->read_sfn_indicator = pvalue->readSFN_Indicator;

    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_cell_info_si_hcs_rscp_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_RSCP_LCR_R4_CELL_SELECT_RESELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12_hcs_rscp(
                &pvalue->cellSelectionReselectionInfo,
                &p_cell_info_si_hcs_rscp_lcr_r4->cell_select_reselect_info_sib_11_12_hcs_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_hcs_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_HCS_RSCP_LCR_r4 to
 *       new_intra_freq_cell_si_list_hcs_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_new_intra_freq_cell_si_list_hcs_rscp_lcr_r4
(
 UMTS_NewIntraFreqCellSI_List_HCS_RSCP_LCR_r4   *pvalue,
 new_intra_freq_cell_si_list_hcs_rscp_lcr_r4_t  *p_lcr_r4 
 )
{
    UMTS_NewIntraFreqCellSI_HCS_RSCP_LCR_r4 *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewIntraFreqCellSI_HCS_RSCP_LCR_r4*)pnode->data;

        if (pdata->m.intraFreqCellIDPresent)
        {
            p_lcr_r4->new_intra_freq_cell_si_list_hcs_rscp_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_INTRA_FREQ_CELL_SI_HCS_RSCP_LCR_R4_INTRA_FREQ_CELL_ID_PRESENCE_FLAG;

            p_lcr_r4->new_intra_freq_cell_si_list_hcs_rscp_lcr_r4[index].intra_freq_cell_id = 
                pdata->intraFreqCellID;
        }

        convert_cell_info_si_hcs_rscp_lcr_r4(
                &pdata->cellInfo,
                &p_lcr_r4->new_intra_freq_cell_si_list_hcs_rscp_lcr_r4[index].cell_info_si_hcs_rscp_lcr_r4);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_si_list_hcs_rscp_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_HCS_RSCP_LCR_r4 to
 *       new_inter_freq_cell_si_list_hcs_rscp_lcr_r4_t 
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_si_list_hcs_rscp_lcr_r4
(
 UMTS_NewInterFreqCellSI_List_HCS_RSCP_LCR_r4   *pvalue,
 new_inter_freq_cell_si_list_hcs_rscp_lcr_r4_t  *p_lcr_r4 
 )
{
    UMTS_NewInterFreqCellSI_HCS_RSCP_LCR_r4 *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCellSI_HCS_RSCP_LCR_r4*)pnode->data;

        if (pdata->m.interFreqCellIDPresent)
        {
            p_lcr_r4->new_inter_freq_cell_si_hcs_rscp_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_HCS_RSCP_LCR_R4_INTER_FREQ_CELL_ID_PRESENCE_FLAG;

            p_lcr_r4->new_inter_freq_cell_si_hcs_rscp_lcr_r4[index].inter_freq_cell_id =
                pdata->interFreqCellID;
        }

        if (pdata->m.frequencyInfoPresent)
        {
            p_lcr_r4->new_inter_freq_cell_si_hcs_rscp_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_HCS_RSCP_LCR_R4_FREQ_INFO_PRESENCE_FLAG;

            convert_frequency_info(
                    &pdata->frequencyInfo,
                    &p_lcr_r4->new_inter_freq_cell_si_hcs_rscp_lcr_r4[index].frequency_info);
        }

        convert_cell_info_si_hcs_rscp_lcr_r4(
                &pdata->cellInfo,
                &p_lcr_r4->new_inter_freq_cell_si_hcs_rscp_lcr_r4[index].cell_info_si_hcs_rscp_lcr_r4);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP     *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp_t *p_cpich_rscp 
 )
{
    if (pvalue->m.newIntraFreqCellListPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_HCS_USED_CELL_SELECT_QUALITY_MEAS_CPICH_RSCP_NEW_INTRA_FREQ_CELL_SI_LIST_HCS_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_new_intra_freq_cell_si_list_hcs_rscp_lcr_r4(
                &pvalue->newIntraFreqCellList,
                &p_cpich_rscp->new_intra_freq_cell_si_list_hcs_rscp_lcr_r4); 
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_HCS_USED_CELL_SELECT_QUALITY_MEAS_CPICH_RSCP_NEW_INTER_FREQ_CELL_SI_LIST_HCS_RSCP_LCR_R4_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_hcs_rscp_lcr_r4(
                &pvalue->newInterFreqCellList,
                &p_cpich_rscp->new_inter_freq_cell_si_list_hcs_rscp_lcr_r4);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_info_si_hcs_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellInfoSI_HCS_ECN0_LCR_r4 to
 *       cell_info_si_hcs_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_cell_info_si_hcs_ecno_lcr_r4
(
 UMTS_CellInfoSI_HCS_ECN0_LCR_r4    *pvalue,
 cell_info_si_hcs_ecno_lcr_r4_t     *p_lcr_r4 
 )
{
    p_lcr_r4->cell_individual_offset = pvalue->cellIndividualOffset;

    if (pvalue->m.referenceTimeDifferenceToCellPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_LCR_R4_REF_TIME_DIFF_TO_CELL_PRESENCE_FLAG;

        convert_reference_time_difference_to_cell(
                &pvalue->referenceTimeDifferenceToCell,
                &p_lcr_r4->reference_time_difference_to_cell);
    }

    convert_primary_ccpch_info_lcr_r4(
            &pvalue->primaryCCPCH_Info,
            &p_lcr_r4->primary_ccpch_info_lcr_r4);

    if (pvalue->m.primaryCCPCH_TX_PowerPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_LCR_R4_PRIMARY_CCPCH_TX_POWER_PRESENCE_FLAG;

        p_lcr_r4->primary_ccpch_tx_power = pvalue->primaryCCPCH_TX_Power;
    }

    if (pvalue->m.timeslotInfoListPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_LCR_R4_TIMESLOT_INFO_LIST_PRESENCE_FLAG;

        convert_timeslot_info_list_lcr_r4(
                &pvalue->timeslotInfoList,
                &p_lcr_r4->timeslot_info_list_lcr_r4);
    }

    p_lcr_r4->read_sfn_indicator = pvalue->readSFN_Indicator;

    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_CELL_INFO_SI_HCS_ECNO_LCR_R4_CELL_SELECT_RESELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12_hcs_ecno(
                &pvalue->cellSelectionReselectionInfo,
                &p_lcr_r4->cell_select_reselect_info_sib_11_12_hcs_ecno);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_intra_freq_cell_si_list_hcs_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewIntraFreqCellSI_List_HCS_ECN0_LCR_r4 to
 *       new_intra_freq_cell_si_list_hcs_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_new_intra_freq_cell_si_list_hcs_ecno_lcr_r4
(
 UMTS_NewIntraFreqCellSI_List_HCS_ECN0_LCR_r4   *pvalue,
 new_intra_freq_cell_si_list_hcs_ecno_lcr_r4_t  *p_ecno_lcr_r4 
 )
{
    UMTS_NewIntraFreqCellSI_HCS_ECN0_LCR_r4 *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_ecno_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewIntraFreqCellSI_HCS_ECN0_LCR_r4*)pnode->data;

        if (pdata->m.intraFreqCellIDPresent)
        {
            p_ecno_lcr_r4->new_intra_freq_cell_si_hcs_ecno_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTRA_FREQ_CELL_SI_HCS_ECNO_LCR_R4_CELL_INFO_SI_HCS_ECNO_LCR_R4_PRESENCE_FLAG;

            p_ecno_lcr_r4->new_intra_freq_cell_si_hcs_ecno_lcr_r4[index].intra_freq_cell_id =
                pdata->intraFreqCellID;
        }

        convert_cell_info_si_hcs_ecno_lcr_r4(
                &pdata->cellInfo,
                &p_ecno_lcr_r4->new_intra_freq_cell_si_hcs_ecno_lcr_r4[index].cell_info_si_hcs_ecno_lcr_r4);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_new_inter_freq_cell_si_list_hcs_ecno_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterFreqCellSI_List_HCS_ECN0_LCR_r4 to
 *       new_inter_freq_cell_si_list_hcs_ecno_lcr_r4_t 
 *
 *******************************************************************************/
void convert_new_inter_freq_cell_si_list_hcs_ecno_lcr_r4
(
 UMTS_NewInterFreqCellSI_List_HCS_ECN0_LCR_r4   *pvalue,
 new_inter_freq_cell_si_list_hcs_ecno_lcr_r4_t  *p_ecno_lcr_r4 
 )
{
    UMTS_NewInterFreqCellSI_HCS_ECN0_LCR_r4 *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_ecno_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterFreqCellSI_HCS_ECN0_LCR_r4*)pnode->data;

        if (pdata->m.interFreqCellIDPresent)
        {
            p_ecno_lcr_r4->new_inter_freq_cell_si_hcs_ecno_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_HCS_ECNO_LCR_R4_INTER_FREQ_CELL_ID_PRESENCE_FLAG;

            p_ecno_lcr_r4->new_inter_freq_cell_si_hcs_ecno_lcr_r4[index].inter_freq_cell_id =
                pdata->interFreqCellID;
        }

        if (pdata->m.frequencyInfoPresent)
        {
            p_ecno_lcr_r4->new_inter_freq_cell_si_hcs_ecno_lcr_r4[index].presence_bitmask |=
                UMTS_SIB_NEW_INTER_FREQ_CELL_SI_HCS_ECNO_LCR_R4_CELL_INFO_SI_HCS_ECNO_LCR_R4_PRESENCE_FLAG;

            convert_frequency_info(
                    &pdata->frequencyInfo,
                    &p_ecno_lcr_r4->new_inter_freq_cell_si_hcs_ecno_lcr_r4[index].frequency_info);
        }

        convert_cell_info_si_hcs_ecno_lcr_r4(
                &pdata->cellInfo,
                &p_ecno_lcr_r4->new_inter_freq_cell_si_hcs_ecno_lcr_r4[index].cell_info_si_hcs_ecno_lcr_r4);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0 to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0    *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno_t *p_cpich_ecno 
 )
{
    if (pvalue->m.newIntraFreqCellListPresent)
    {
        p_cpich_ecno->presence_bitmask |=
            UMTS_SIB_HCS_USED_CELL_SELECT_QUALITY_MEAS_CPICH_ECNO_NEW_INTRA_FREQ_CELL_SI_LIST_HCS_ECNO_LCR_R4_PRESENCE_FLAG;

        convert_new_intra_freq_cell_si_list_hcs_ecno_lcr_r4(
                &pvalue->newIntraFreqCellList,
                &p_cpich_ecno->new_intra_freq_cell_si_list_hcs_ecno_lcr_r4); 
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_cpich_ecno->presence_bitmask |=
            UMTS_SIB_HCS_USED_CELL_SELECT_QUALITY_MEAS_CPICH_ECNO_NEW_INTER_FREQ_CELL_SI_LIST_HCS_ECNO_LCR_R4_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_hcs_ecno_lcr_r4(
                &pvalue->newInterFreqCellList,
                &p_cpich_ecno->new_inter_freq_cell_si_list_hcs_ecno_lcr_r4); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used_cellSelectQualityMeasure to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used_cellSelectQualityMeasure        *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_t    *p_cell_select_quality_measure 
 )
{
    p_cell_select_quality_measure->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP)
    {
        convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp(
                pvalue->u.cpich_RSCP,
                &p_cell_select_quality_measure->u.cpich_rscp); 
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ecno(
                pvalue->u.cpich_Ec_N0,
                &p_cell_select_quality_measure->u.cpich_ecno); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used     *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_t    *p_hcs_used 
 )
{
    convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_hcs_used->cell_select_quality_measure);

    if (pvalue->m.newInterRATCellListPresent)
    {
        p_hcs_used->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_LCR_R4_USE_OF_HCS_HCS_USED_NEW_INTER_RAT_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_rat_cell_list(
                &pvalue->newInterRATCellList,
                &p_hcs_used->new_inter_rat_cell_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS to
 *       measurement_control_sys_info_extension_lcr_r4_use_of_hcs_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS  *pvalue,
 measurement_control_sys_info_extension_lcr_r4_use_of_hcs_t *p_use_of_hcs 
 )
{
    p_use_of_hcs->t = pvalue->t;

    if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_not_used)
    {
        convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_not_used(
                pvalue->u.hcs_not_used,
                &p_use_of_hcs->u.hcs_not_used);
    }
    else if (pvalue->t == T_UMTS_MeasurementControlSysInfoExtension_LCR_r4_use_of_HCS_hcs_used)
    {
        convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs_hcs_used(
                pvalue->u.hcs_used,
                &p_use_of_hcs->u.hcs_used);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_lcr_r4 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtension_LCR_r4 to
 *       measurement_control_sys_info_extension_lcr_r4_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_lcr_r4
(
 UMTS_MeasurementControlSysInfoExtension_LCR_r4     *pvalue,
 measurement_control_sys_info_extension_lcr_r4_t    *p_lcr_r4 
 )
{
    convert_measurement_control_sys_info_extension_lcr_r4_use_of_hcs(
            &pvalue->use_of_HCS,
            &p_lcr_r4->use_of_hcs);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cell_select_reselect_info_v590_ext 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfo_v590ext to
 *       cell_select_reselect_info_v590_ext_t 
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_v590_ext
(
 UMTS_CellSelectReselectInfo_v590ext    *pvalue,
 cell_select_reselect_info_v590_ext_t   *p_cell_select_reselect_info_v590_ext 
 )
{
    if (pvalue->m.deltaQrxlevminPresent)
    {
        p_cell_select_reselect_info_v590_ext->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_V590_EXT_DELTA_Q_RX_LEV_MIN_PRESENCE_FLAG;

        p_cell_select_reselect_info_v590_ext->delta_q_rx_lev_min =
            pvalue->deltaQrxlevmin;
    }

    if (pvalue->m.deltaQhcsPresent)
    {
        p_cell_select_reselect_info_v590_ext->presence_bitmask |=
            UMTS_SIB_CELL_SELECT_RESELECT_INFO_V590_EXT_DELTA_Q_HCS_PRESENCE_FLAG;

        p_cell_select_reselect_info_v590_ext->delta_q_hcs =
            pvalue->deltaQhcs;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_addon_r5_new_intra_frequency_cell_info_list_addon_r5 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtensionAddon_r5_newIntraFrequencyCellInfoListAddon_r5 to
 *       measurement_control_sys_info_extension_addon_r5_new_intra_frequency_cell_info_list_addon_r5_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_addon_r5_new_intra_frequency_cell_info_list_addon_r5
(
 UMTS_MeasurementControlSysInfoExtensionAddon_r5_newIntraFrequencyCellInfoListAddon_r5          *pvalue,
 measurement_control_sys_info_extension_addon_r5_new_intra_frequency_cell_info_list_addon_r5_t  *p_addon_r5 
 )
{
    UMTS_CellSelectReselectInfo_v590ext *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_addon_r5->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_cell_select_reselect_info_v590_ext(
                pdata,
                &p_addon_r5->cell_select_reselect_info_v590_ext[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_addon_r5_new_inter_frequency_cell_info_list_addon_r5 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtensionAddon_r5_newInterFrequencyCellInfoListAddon_r5 to
 *       measurement_control_sys_info_extension_addon_r5_new_inter_frequency_cell_info_list_addon_r5_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_addon_r5_new_inter_frequency_cell_info_list_addon_r5
(
 UMTS_MeasurementControlSysInfoExtensionAddon_r5_newInterFrequencyCellInfoListAddon_r5          *pvalue,
 measurement_control_sys_info_extension_addon_r5_new_inter_frequency_cell_info_list_addon_r5_t  *p_addon_r5 
 )
{
    UMTS_CellSelectReselectInfo_v590ext *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_addon_r5->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_cell_select_reselect_info_v590_ext(
                pdata,
                &p_addon_r5->cell_select_reselect_info_v590_ext[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_addon_r5_new_inter_rat_cell_info_list_addon_r5 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtensionAddon_r5_newInterRATCellInfoListAddon_r5 to
 *       measurement_control_sys_info_extension_addon_r5_new_inter_rat_cell_info_list_addon_r5_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_addon_r5_new_inter_rat_cell_info_list_addon_r5
(
 UMTS_MeasurementControlSysInfoExtensionAddon_r5_newInterRATCellInfoListAddon_r5            *pvalue,
 measurement_control_sys_info_extension_addon_r5_new_inter_rat_cell_info_list_addon_r5_t    *p_addon_r5 
 )
{
    UMTS_CellSelectReselectInfo_v590ext *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_addon_r5->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_CellSelectReselectInfo_v590ext*)pnode->data;

        convert_cell_select_reselect_info_v590_ext(
                pdata,
                &p_addon_r5->cell_select_reselect_info_v590_ext[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_extension_addon_r5 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfoExtensionAddon_r5 to
 *       measurement_control_sys_info_extension_addon_r5_t 
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_extension_addon_r5
(
 UMTS_MeasurementControlSysInfoExtensionAddon_r5    *pvalue,
 measurement_control_sys_info_extension_addon_r5_t  *p_addon_r5 
 )
{
    if (pvalue->m.newIntraFrequencyCellInfoListAddon_r5Present)
    {
        p_addon_r5->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_ADDON_R5_NEW_INTRA_FREQ_CELL_INFO_LIST_ADDON_R5_PRESENCE_FLAG;

        convert_measurement_control_sys_info_extension_addon_r5_new_intra_frequency_cell_info_list_addon_r5(
                &pvalue->newIntraFrequencyCellInfoListAddon_r5,
                &p_addon_r5->new_intra_frequency_cell_info_list_addon_r5); 
    }

    if (pvalue->m.newInterFrequencyCellInfoListAddon_r5Present)
    {
        p_addon_r5->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_ADDON_R5_NEW_INTER_FREQ_CELL_INFO_LIST_ADDON_R5_PRESENCE_FLAG;

        convert_measurement_control_sys_info_extension_addon_r5_new_inter_frequency_cell_info_list_addon_r5(
                &pvalue->newInterFrequencyCellInfoListAddon_r5,
                &p_addon_r5->new_inter_frequency_cell_info_list_addon_r5); 
    }

    if (pvalue->m.newInterRATCellInfoListAddon_r5Present)
    {
        p_addon_r5->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_EXTN_ADDON_R5_NEW_INTER_RAT_CELL_INFO_LIST_ADDON_R5_PRESENCE_FLAG;

        convert_measurement_control_sys_info_extension_addon_r5_new_inter_rat_cell_info_list_addon_r5(
                &pvalue->newInterRATCellInfoListAddon_r5,
                &p_addon_r5->new_inter_rat_cell_info_list_addon_r5);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype11bis_v7b0ext_ies 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11bis_v7b0ext_IEs to
 *       sysinfotype11bis_v7b0ext_ies_t 
 *
 *******************************************************************************/
void convert_sysinfotype11bis_v7b0ext_ies
(
 UMTS_SysInfoType11bis_v7b0ext_IEs  *pvalue,
 sysinfotype11bis_v7b0ext_ies_t     *p_ies
 )
{
    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE_11BIS_V7B0_EXT_IES_NEW_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_freq_cell_list_v7b0ext(
                &pvalue->newInterFreqCellList,
                &p_ies->new_inter_freq_cell_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_csg_dedicated_frequency_info_list 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CSG_DedicatedFrequencyInfoList to
 *       csg_dedicated_frequency_info_list_t 
 *
 *******************************************************************************/
void convert_csg_dedicated_frequency_info_list
(
 UMTS_CSG_DedicatedFrequencyInfoList    *pvalue,
 csg_dedicated_frequency_info_list_t    *p_list 
 )
{
    UMTS_FrequencyInfo  *pdata = NULL;
    OSRTDListNode       *pnode = NULL;
    U32                 index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_FrequencyInfo*)pnode->data;

        convert_frequency_info_mode_specific_info(
                &pdata->modeSpecificInfo,
                &p_list->frequency_info[index].mode_specific_info);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_csg_psc_split_info
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CSG_PSCSplitInfo to
 *       csg_psc_split_info_t
 *
 *******************************************************************************/
void convert_csg_psc_split_info
(
 UMTS_CSG_PSCSplitInfo  *pvalue,
 csg_psc_split_info_t   *p_csg_psc_split_info 
 )
{
    p_csg_psc_split_info->start_psc =
        pvalue->startPSC;

    p_csg_psc_split_info->number_of_pscs =
        pvalue->numberOfPSCs;

    if (pvalue->m.pscRange2OffsetPresent)
    {
        p_csg_psc_split_info->presence_bitmask |=
            UMTS_SIB_PSC_RANGE_2_OFFSET_PRESENCE_FLAG;

        p_csg_psc_split_info->psc_range_2_offset =
            pvalue->pscRange2Offset;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype11bis_v860ext_ies 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11bis_v860ext_IEs to
 *       sysinfotype11bis_v860ext_ies_t 
 *
 *******************************************************************************/
void convert_sysinfotype11bis_v860ext_ies
(
 UMTS_SysInfoType11bis_v860ext_IEs  *pvalue,
 sysinfotype11bis_v860ext_ies_t     *p_ies 
 )
{
    if (pvalue->m.csg_PSCSplitInfoPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE_11BIS_V7B0_V860_IES_CSG_PSC_SPLIT_INFO_PRESENCE_FLAG;

        convert_csg_psc_split_info(
                &pvalue->csg_PSCSplitInfo,
                &p_ies->csg_pscsplit_info);
    }

    if (pvalue->m.csg_DedicatedFrequencyInfoListPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE_11BIS_V7B0_V860_IES_CSG_CSG_DEDICATED_FREQ_INFO_LIST_PRESENCE_FLAG;

        convert_csg_dedicated_frequency_info_list(
                &pvalue->csg_DedicatedFrequencyInfoList,
                &p_ies->csg_dedicated_frequency_info_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype11bis_v7b0nces_v860nces_nces 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11bis_v7b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions to
 *       sysinfotype11bis_v7b0nces_v860nces_nces_t 
 *
 *******************************************************************************/
void convert_sysinfotype11bis_v7b0nces_v860nces_nces
(
 UMTS_SysInfoType11bis_v7b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions    *pvalue,
 sysinfotype11bis_v7b0nces_v860nces_nces_t      *p_nce
 )
{
    p_nce->__dummy__ = pvalue->__dummy__;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype11bis_v7b0nces_v860nces 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11bis_v7b0NonCriticalExtensions_v860NonCriticalExtensions to
 *       sysinfotype11bis_v7b0nces_v860nces_t 
 *
 *******************************************************************************/
void convert_sysinfotype11bis_v7b0nces_v860nces
(
 UMTS_SysInfoType11bis_v7b0NonCriticalExtensions_v860NonCriticalExtensions  *pvalue,
 sysinfotype11bis_v7b0nces_v860nces_t       *p_nce 
 )
{
    convert_sysinfotype11bis_v860ext_ies(
            &pvalue->sysInfoType11bis_v860ext,
            &p_nce->sys_info_type11bis_v860ext);

    if (pvalue->m.nonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_11BIS_V7B0_V860_NCE_NCE_PRESENCE_FLAG;

        convert_sysinfotype11bis_v7b0nces_v860nces_nces(
                &pvalue->nonCriticalExtensions,
                &p_nce->non_critical_extensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype11bis_v7b0_nc_extensions 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType11bis_v7b0NonCriticalExtensions to
 *       sysinfotype11bis_v7b0_nc_extensions_t 
 *
 *******************************************************************************/
void convert_sysinfotype11bis_v7b0_nc_extensions
(
 UMTS_SysInfoType11bis_v7b0NonCriticalExtensions    *pvalue,
 sysinfotype11bis_v7b0_nc_extensions_t              *p_nce 
 )
{
    convert_sysinfotype11bis_v7b0ext_ies(
            &pvalue->sysInfoType11bis_v7b0ext,
            &p_nce->sys_info_type11bis_v7b0ext);

    if (pvalue->m.v860NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_11BIS_V7B0_V860_NCE_PRESENCE_FLAG;

        convert_sysinfotype11bis_v7b0nces_v860nces(
                &pvalue->v860NonCriticalExtensions,
                &p_nce->v860non_critical_extensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib11bis
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType11bis to
 *       umts_sib_type_11bis_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       pumts_sib11bis  - Pointer to decoded SIB11bis
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib11bis
(
 umts_sib_type_11bis_info_t *pumts_sib11bis    
 )
{
    UMTS_SysInfoType11bis   sys_info_type_11bis;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_11_bis_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_11bis, 0, sizeof(UMTS_SysInfoType11bis));

    if ( 0 != (asn1PD_UMTS_SysInfoType11bis(&ctxt, &sys_info_type_11bis)))
    {
        printf("umts_convert_sib11bis:asn decoding failed\n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType11bis("Decoded SysInfoType11bis\n", &sys_info_type_11bis);
    memset( pumts_sib11bis, 0, sizeof(umts_sib_type_11bis_info_t));

    if (sys_info_type_11bis.m.measurementControlSysInfoPresent)
    {
        pumts_sib11bis->presence_bitmask |=
            UMTS_SIB_TYPE11_BIS_MEAS_CTRL_SYSINFO_PRESENCE_FLAG;

        convert_measurement_control_sys_info_extension(
                &sys_info_type_11bis.measurementControlSysInfo,
                &pumts_sib11bis->measurement_control_sys_info_extension);
    }

    if (sys_info_type_11bis.m.measurementControlSysInfo_LCRPresent)
    {
        pumts_sib11bis->presence_bitmask |=
            UMTS_SIB_TYPE11_BIS_MEAS_CTRL_SYSINFO_LCR_PRESENCE_FLAG;

        convert_measurement_control_sys_info_extension_lcr_r4(
                &sys_info_type_11bis.measurementControlSysInfo_LCR,
                &pumts_sib11bis->measurement_control_sys_info_extension_lcr_r4);
    }

    if (sys_info_type_11bis.m.measurementControlSysInfoExtensionAddon_r5Present)
    {
        pumts_sib11bis->presence_bitmask |=
            UMTS_SIB_TYPE11_BIS_MEAS_CTRL_SYSINFO_EXTN_ADDON_R5_PRESENCE_FLAG;

        convert_measurement_control_sys_info_extension_addon_r5(
                &sys_info_type_11bis.measurementControlSysInfoExtensionAddon_r5,
                &pumts_sib11bis->measurement_control_sys_info_extension_addon_r5);
    }

    if (sys_info_type_11bis.m.v7b0NonCriticalExtensionsPresent)
    {
        pumts_sib11bis->presence_bitmask |=
            UMTS_SIB_TYPE11_BIS_V7B0_NCE_PRESENCE_FLAG;

        convert_sysinfotype11bis_v7b0_nc_extensions(
                &sys_info_type_11bis.v7b0NonCriticalExtensions,
                &pumts_sib11bis->sysinfotype11bis_v7b0_nc_extensions);
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_removed_inter_rat_cell_list_remove_some_inter_rat_cells
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_RemovedInterRATCellList_removeSomeInterRATCells to 
 *       removed_inter_rat_cell_list_remove_some_inter_rat_cells_t
 *
 ******************************************************************************/
void convert_removed_inter_rat_cell_list_remove_some_inter_rat_cells
(
 UMTS_RemovedInterRATCellList_removeSomeInterRATCells       *pvalue,
 removed_inter_rat_cell_list_remove_some_inter_rat_cells_t  *p_inter_rat_cells 
 )
{
    p_inter_rat_cells->n = pvalue->n;

    memcpy(&p_inter_rat_cells->elem, &pvalue->elem, 
            (sizeof(U8)*p_inter_rat_cells->n));

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_removed_inter_rat_cell_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_RemovedInterRATCellList to 
 *       removed_inter_rat_cell_list_t
 *
 ******************************************************************************/
void convert_removed_inter_rat_cell_list
(
 UMTS_RemovedInterRATCellList   *pvalue,
 removed_inter_rat_cell_list_t  *p_removed_inter_rat_cell_list 
 )
{
    p_removed_inter_rat_cell_list->t = pvalue->t;

    if (pvalue->t == T_UMTS_RemovedInterRATCellList_removeAllInterRATCells)
    {
        /* for future use */    
    }
    else if (pvalue->t == T_UMTS_RemovedInterRATCellList_removeSomeInterRATCells)
    {
        convert_removed_inter_rat_cell_list_remove_some_inter_rat_cells(
                pvalue->u.removeSomeInterRATCells,
                &p_removed_inter_rat_cell_list->u.remove_some_inter_rat_cells); 
    }
    else if (pvalue->t == T_UMTS_RemovedInterRATCellList_removeNoInterRATCells)
    {
        /* for future use */    
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_list_b_technology_specific_info_gsm
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCell_B_technologySpecificInfo_gsm to 
 *       new_inter_rat_cell_list_b_technology_specific_info_gsm_t
 *
 ******************************************************************************/
void convert_new_inter_rat_cell_list_b_technology_specific_info_gsm
(
 UMTS_NewInterRATCell_B_technologySpecificInfo_gsm          *pvalue,
 new_inter_rat_cell_list_b_technology_specific_info_gsm_t   *p_gsm 
 )
{
    if (pvalue->m.cellSelectionReselectionInfoPresent)
    {
        p_gsm->presence_bitmask |=
            UMTS_SIB_NEW_INTER_RAT_CELL_LIST_B_TECH_SPECIFIC_INFO_GSM_CELL_SELECT_RESELECT_INFO_PRESENCE_FLAG;

        convert_cell_select_reselect_info_sib_11_12(
                &pvalue->cellSelectionReselectionInfo,
                &p_gsm->cell_select_reselect_info_sib_11_12);
    }

    p_gsm->inter_rat_cell_individual_offset = pvalue->interRATCellIndividualOffset;

    convert_bsic(
            &pvalue->bsic,
            &p_gsm->bsic);

    p_gsm->freq_band = pvalue->frequency_band;
    p_gsm->bcch_arfcn = pvalue->bcch_ARFCN;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_list_b_technology_specific_info_is_2000
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCell_B_technologySpecificInfo_is_2000 to 
 *       new_inter_rat_cell_list_b_technology_specific_info_is_2000_t
 *
 ******************************************************************************/
void convert_new_inter_rat_cell_list_b_technology_specific_info_is_2000
(
 UMTS_NewInterRATCell_B_technologySpecificInfo_is_2000          *pvalue,
 new_inter_rat_cell_list_b_technology_specific_info_is_2000_t   *p_2000 
 )
{
    p_2000->is_2000_specific_meas_info = pvalue->is_2000SpecificMeasInfo;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_list_b_technology_specific_info
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCell_B_technologySpecificInfo to 
 *       new_inter_rat_cell_list_b_technology_specific_info_t
 *
 ******************************************************************************/
void convert_new_inter_rat_cell_list_b_technology_specific_info
(
 UMTS_NewInterRATCell_B_technologySpecificInfo          *pvalue,
 new_inter_rat_cell_list_b_technology_specific_info_t   *p_technology_specific_info 
 )
{
    p_technology_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_NewInterRATCell_B_technologySpecificInfo_gsm)
    {
        convert_new_inter_rat_cell_list_b_technology_specific_info_gsm(
                pvalue->u.gsm,
                &p_technology_specific_info->u.gsm);
    }
    else if (pvalue->t == T_UMTS_NewInterRATCell_B_technologySpecificInfo_is_2000)
    {
        convert_new_inter_rat_cell_list_b_technology_specific_info_is_2000(
                pvalue->u.is_2000,
                &p_technology_specific_info->u.is_2000); 
    }
    else if (pvalue->t == T_UMTS_NewInterRATCell_B_technologySpecificInfo_absent)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_NewInterRATCell_B_technologySpecificInfo_spare1)
    {
        /* for future use */ 
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_b
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCell_B to 
 *       new_inter_rat_cell_b_t
 *
 ******************************************************************************/
void convert_new_inter_rat_cell_b
(
 UMTS_NewInterRATCell_B     *pvalue,
 new_inter_rat_cell_b_t     *p_new_inter_rat_cell_b 
 )
{
    if (pvalue->m.interRATCellIDPresent)
    {
        p_new_inter_rat_cell_b->presence_bitmask |=
            UMTS_SIB_NEW_INTER_RAT_CELL_LIST_B_INTER_RAT_CELL_ID_PRESENCE_FLAG;

        p_new_inter_rat_cell_b->inter_rat_cell_id =
            pvalue->interRATCellID;
    }

    convert_new_inter_rat_cell_list_b_technology_specific_info(
            &pvalue->technologySpecificInfo,
            &p_new_inter_rat_cell_b->technology_specific_info);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_new_inter_rat_cell_list_b
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_NewInterRATCellList_B to 
 *       new_inter_rat_cell_list_b_t
 *
 ******************************************************************************/
void convert_new_inter_rat_cell_list_b
(
 UMTS_NewInterRATCellList_B     *pvalue,
 new_inter_rat_cell_list_b_t    *p_new_inter_rat_cell_list_b 
 )
{
    UMTS_NewInterRATCell_B  *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_new_inter_rat_cell_list_b->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NewInterRATCell_B*)pnode->data;

        convert_new_inter_rat_cell_b(
                pdata,
                &p_new_inter_rat_cell_list_b->new_inter_rat_cell_b[index]);

        pnode = pnode->next;
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_inter_rat_cell_info_list_b
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterRATCellInfoList_B to 
 *       inter_rat_cell_info_list_b_t
 *
 ******************************************************************************/
void convert_inter_rat_cell_info_list_b
(
 UMTS_InterRATCellInfoList_B    *pvalue,
 inter_rat_cell_info_list_b_t   *p_inter_rat_cell_info_list_b 
 )
{
    convert_removed_inter_rat_cell_list(
            &pvalue->removedInterRATCellList,
            &p_inter_rat_cell_info_list_b->removed_inter_rat_cell_list);

    convert_new_inter_rat_cell_list_b(
            &pvalue->newInterRATCellList,
            &p_inter_rat_cell_info_list_b->new_inter_rat_cell_list_b);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_inter_rat_measurement_sysinfo_b
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_InterRATMeasurementSysInfo_B to 
 *       inter_rat_measurement_sysinfo_b_t
 *
 ******************************************************************************/
void convert_inter_rat_measurement_sysinfo_b
( 
 UMTS_InterRATMeasurementSysInfo_B   *pvalue,
 inter_rat_measurement_sysinfo_b_t   *p_inter_rat_measurement_sysinfo_b
 )
{
    if(pvalue->m.interRATCellInfoListPresent)
    {
        p_inter_rat_measurement_sysinfo_b->presence_bitmask |=
            UMTS_SIB_INTER_RAT_CELL_INFO_LIST_B_CELL_LIST_PRESENCE_FLAG;

        convert_inter_rat_cell_info_list_b(
                &pvalue->interRATCellInfoList,
                &p_inter_rat_measurement_sysinfo_b->inter_rat_cell_info_list_b);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_removed_intra_freq_cell_list_remove_some_intra_freq_cells
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_RemovedIntraFreqCellList_removeSomeIntraFreqCells to 
 *       removed_intra_freq_cell_list_remove_some_intra_freq_cells_t
 *
 ******************************************************************************/
void convert_removed_intra_freq_cell_list_remove_some_intra_freq_cells
(
 UMTS_RemovedIntraFreqCellList_removeSomeIntraFreqCells         *pvalue,
 removed_intra_freq_cell_list_remove_some_intra_freq_cells_t    *p_remove_some_intra_freq_cells
 )
{
    memcpy(p_remove_some_intra_freq_cells,
            pvalue, sizeof(removed_intra_freq_cell_list_remove_some_intra_freq_cells_t));

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_removed_intra_freq_cell_list
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_RemovedIntraFreqCellList to 
 *       removed_intra_freq_cell_list_t
 *
 ******************************************************************************/
void convert_removed_intra_freq_cell_list
(
 UMTS_RemovedIntraFreqCellList  *pvalue,
 removed_intra_freq_cell_list_t *p_removed_intra_freq_cell_list
 )
{
    p_removed_intra_freq_cell_list->t = pvalue->t;

    if (pvalue->t == T_UMTS_RemovedIntraFreqCellList_removeAllIntraFreqCells)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_RemovedIntraFreqCellList_removeSomeIntraFreqCells)
    {
        convert_removed_intra_freq_cell_list_remove_some_intra_freq_cells(
                pvalue->u.removeSomeIntraFreqCells,
                &p_removed_intra_freq_cell_list->u.remove_some_intra_freq_cells);
    }
    else if(pvalue->t == T_UMTS_RemovedIntraFreqCellList_removeNoIntraFreqCells )
    {
        /* for future use */ 
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_cell_info_si_list_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqCellInfoSI_List_RSCP to 
 *       intra_freq_cell_info_si_list_rscp_t
 *
 ******************************************************************************/
void convert_intra_freq_cell_info_si_list_rscp
(
 UMTS_IntraFreqCellInfoSI_List_RSCP  *pvalue,
 intra_freq_cell_info_si_list_rscp_t *p_intra_freq_cell_info_si_list_rscp
 )
{
    if (pvalue->m.removedIntraFreqCellListPresent)
    {
        p_intra_freq_cell_info_si_list_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_CELL_SI_LIST_RSCP_REMOVED_CELL_LIST_PRESENCE_FLAG;

        convert_removed_intra_freq_cell_list(
                &pvalue->removedIntraFreqCellList,
                &p_intra_freq_cell_info_si_list_rscp->removed_intra_freq_cell_list);
    }

    convert_new_intra_freq_cell_si_list_rscp(
            &pvalue->newIntraFreqCellList,
            &p_intra_freq_cell_info_si_list_rscp->new_intra_freq_cell_si_list_rscp);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_meas_quantity_tdd_list
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasQuantity_TDDList to 
 *       intra_freq_meas_quantity_tdd_list_t
 *
 ******************************************************************************/
void convert_intra_freq_meas_quantity_tdd_list
(
 UMTS_IntraFreqMeasQuantity_TDDList     *pvalue,
 intra_freq_meas_quantity_tdd_list_t    *p_intra_freq_meas_quantity_tdd_list
 )
{
    memcpy(p_intra_freq_meas_quantity_tdd_list,
            pvalue, sizeof(intra_freq_meas_quantity_tdd_list_t));

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_meas_quantity_mode_specific_info_tdd
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasQuantity_modeSpecificInfo_tdd to 
 *       intra_freq_meas_quantity_mode_specific_info_tdd_t
 *
 ******************************************************************************/
void convert_intra_freq_meas_quantity_mode_specific_info_tdd
(
 UMTS_IntraFreqMeasQuantity_modeSpecificInfo_tdd    *pvalue,
 intra_freq_meas_quantity_mode_specific_info_tdd_t  *p_tdd
 )
{
    convert_intra_freq_meas_quantity_tdd_list(
            &pvalue->intraFreqMeasQuantity_TDDList,
            &p_tdd->intra_freq_meas_quantity_tdd_list);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_meas_quantity_mode_specific_info_fdd
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasQuantity_modeSpecificInfo_fdd to 
 *       intra_freq_meas_quantity_mode_specific_info_fdd_t
 *
 ******************************************************************************/
void convert_intra_freq_meas_quantity_mode_specific_info_fdd
(
 UMTS_IntraFreqMeasQuantity_modeSpecificInfo_fdd    *pvalue,
 intra_freq_meas_quantity_mode_specific_info_fdd_t  *p_fdd 
 )
{
    p_fdd->intra_freq_meas_quantity_fdd =
        pvalue->intraFreqMeasQuantity_FDD;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_meas_quantity_mode_specific_info
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasQuantity_modeSpecificInfo to 
 *       intra_freq_meas_quantity_mode_specific_info_t
 *
 ******************************************************************************/
void convert_intra_freq_meas_quantity_mode_specific_info
(
 UMTS_IntraFreqMeasQuantity_modeSpecificInfo    *pvalue,
 intra_freq_meas_quantity_mode_specific_info_t  *p_mode_specific_info
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_IntraFreqMeasQuantity_modeSpecificInfo_fdd)
    {
        convert_intra_freq_meas_quantity_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd);
    }
    else if(pvalue->t == T_UMTS_IntraFreqMeasQuantity_modeSpecificInfo_tdd)
    {
        convert_intra_freq_meas_quantity_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_meas_quantity
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasQuantity to 
 *       intra_freq_meas_quantity_t
 *
 ******************************************************************************/
void convert_intra_freq_meas_quantity
(
 UMTS_IntraFreqMeasQuantity *pvalue,
 intra_freq_meas_quantity_t *p_intra_freq_meas_quantity
 )
{
    p_intra_freq_meas_quantity->filter_coefficient = pvalue->filterCoefficient;

    convert_intra_freq_meas_quantity_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_intra_freq_meas_quantity->mode_specific_info);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_quantity_for_rach_mode_specific_info_fdd
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd to 
 *       intra_freq_reporting_quantity_for_rach_mode_specific_info_fdd_t
 *
 ******************************************************************************/
void convert_intra_freq_reporting_quantity_for_rach_mode_specific_info_fdd
(
 UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd        *pvalue,
 intra_freq_reporting_quantity_for_rach_mode_specific_info_fdd_t    *p_fdd
 )
{
    p_fdd->intra_freq_reporting_quantity_for_rach_fdd =
        pvalue->intraFreqRepQuantityRACH_FDD;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_quantity_for_rach_tdd_list
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqRepQuantityRACH_TDDList to 
 *       intra_freq_reporting_quantity_for_rach_tdd_list_t
 *
 ******************************************************************************/
void convert_intra_freq_reporting_quantity_for_rach_tdd_list
(
 UMTS_IntraFreqRepQuantityRACH_TDDList               *pvalue,
 intra_freq_reporting_quantity_for_rach_tdd_list_t   *p_intra_freq_reporting_quantity_for_rach_tdd_list
 )
{
    memcpy(p_intra_freq_reporting_quantity_for_rach_tdd_list,
            pvalue, sizeof(intra_freq_reporting_quantity_for_rach_tdd_list_t));

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_quantity_for_rach_mode_specific_info_tdd
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd to 
 *       intra_freq_reporting_quantity_for_rach_mode_specific_info_tdd_t
 *
 ******************************************************************************/
void convert_intra_freq_reporting_quantity_for_rach_mode_specific_info_tdd
(
 UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd        *pvalue,
 intra_freq_reporting_quantity_for_rach_mode_specific_info_tdd_t    *p_tdd
 )
{
    convert_intra_freq_reporting_quantity_for_rach_tdd_list(
            &pvalue->intraFreqRepQuantityRACH_TDDList,
            &p_tdd->intra_freq_reporting_quantity_for_rach_tdd_list);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_quantity_for_rach_mode_specific_info
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo to 
 *       intra_freq_reporting_quantity_for_rach_mode_specific_info_t
 *
 ******************************************************************************/
void convert_intra_freq_reporting_quantity_for_rach_mode_specific_info
(
 UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo        *pvalue,
 intra_freq_reporting_quantity_for_rach_mode_specific_info_t    *p_mode_specific_info
 )
{
    p_mode_specific_info->t = pvalue->t;

    if(pvalue->t == T_UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)
    {
        convert_intra_freq_reporting_quantity_for_rach_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd);
    }
    else if(pvalue->t == T_UMTS_IntraFreqReportingQuantityForRACH_modeSpecificInfo_tdd)
    {
        convert_intra_freq_reporting_quantity_for_rach_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_quantity_for_rach
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqReportingQuantityForRACH to 
 *       intra_freq_reporting_quantity_for_rach_t
 *
 ******************************************************************************/
void convert_intra_freq_reporting_quantity_for_rach
(
 UMTS_IntraFreqReportingQuantityForRACH     *pvalue,
 intra_freq_reporting_quantity_for_rach_t   *p_intra_freq_reporting_quantity_for_rach
 )
{
    p_intra_freq_reporting_quantity_for_rach->sfn_sfn_otd_type = 
        pvalue->sfn_SFN_OTD_Type;

    convert_intra_freq_reporting_quantity_for_rach_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_intra_freq_reporting_quantity_for_rach->mode_specific_info);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_cell_reporting_quantities_mode_specific_info_tdd
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_CellReportingQuantities_modeSpecificInfo_tdd to 
 *       cell_reporting_quantities_mode_specific_info_tdd_t
 *
 ******************************************************************************/
void convert_cell_reporting_quantities_mode_specific_info_tdd
(
 UMTS_CellReportingQuantities_modeSpecificInfo_tdd      *pvalue,
 cell_reporting_quantities_mode_specific_info_tdd_t     *p_tdd
 )
{
    p_tdd->timeslot_iscp_reporting_indicator = 
        pvalue->timeslotISCP_reportingIndicator;

    p_tdd->proposed_tgsn_reporting_required = 
        pvalue->proposedTGSN_ReportingRequired;

    p_tdd->primary_ccpch_rscp_reporting_indicator =
        pvalue->primaryCCPCH_RSCP_reportingIndicator;

    p_tdd->pathloss_reporting_indicator = pvalue->pathloss_reportingIndicator;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_cell_reporting_quantities_mode_specific_info_fdd
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_CellReportingQuantities_modeSpecificInfo_fdd to 
 *       cell_reporting_quantities_mode_specific_info_fdd_t
 *
 ******************************************************************************/
void convert_cell_reporting_quantities_mode_specific_info_fdd
(
 UMTS_CellReportingQuantities_modeSpecificInfo_fdd  *pvalue,
 cell_reporting_quantities_mode_specific_info_fdd_t *p_fdd
 )
{
    p_fdd->cpich_ec_no_reporting_indicator = 
        pvalue->cpich_Ec_N0_reportingIndicator;

    p_fdd->cpich_rscp_reporting_indicator = 
        pvalue->cpich_RSCP_reportingIndicator;

    p_fdd->pathloss_reporting_indicator = 
        pvalue->pathloss_reportingIndicator;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_cell_reporting_quantities_mode_specific_info
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_CellReportingQuantities_modeSpecificInfo to 
 *       cell_reporting_quantities_mode_specific_info_t
 *
 ******************************************************************************/
void convert_cell_reporting_quantities_mode_specific_info
(
 UMTS_CellReportingQuantities_modeSpecificInfo       *pvalue,
 cell_reporting_quantities_mode_specific_info_t      *p_cell_reporting_quantities_mode_specific_info
 )
{
    p_cell_reporting_quantities_mode_specific_info->t = pvalue->t;

    if(pvalue->t == T_UMTS_CellReportingQuantities_modeSpecificInfo_fdd)
    {
        convert_cell_reporting_quantities_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_cell_reporting_quantities_mode_specific_info->u.fdd);
    }
    else if(pvalue->t == T_UMTS_CellReportingQuantities_modeSpecificInfo_tdd)
    {

        convert_cell_reporting_quantities_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_cell_reporting_quantities_mode_specific_info->u.tdd);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_cell_reporting_quantities
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_CellReportingQuantities to 
 *       cell_reporting_quantities_t
 *
 ******************************************************************************/
void convert_cell_reporting_quantities
(
 UMTS_CellReportingQuantities    *pvalue,
 cell_reporting_quantities_t     *p_reporting_quantities
 )
{
    p_reporting_quantities->dummy = pvalue->dummy;
    p_reporting_quantities->cell_identity_reporting_indicator = pvalue->cellIdentity_reportingIndicator;
    p_reporting_quantities->cell_sync_info_reporting_indicator = pvalue->cellSynchronisationInfoReportingIndicator;

    convert_cell_reporting_quantities_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_reporting_quantities->cell_reporting_quantities_mode_specific_info);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_quantity
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqReportingQuantity to 
 *       intra_freq_reporting_quantity_t
 *
 ******************************************************************************/
void convert_intra_freq_reporting_quantity
(
 UMTS_IntraFreqReportingQuantity *pvalue,
 intra_freq_reporting_quantity_t *p_intra_freq_reporting_quantity
 )
{
    convert_cell_reporting_quantities(
            &pvalue->activeSetReportingQuantities,
            &p_intra_freq_reporting_quantity->active_set_reporting_quantities);

    convert_cell_reporting_quantities(
            &pvalue->monitoredSetReportingQuantities,
            &p_intra_freq_reporting_quantity->monitored_set_reporting_quantities);

    if(pvalue->m.detectedSetReportingQuantitiesPresent)
    {
        p_intra_freq_reporting_quantity->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_REPORTING_QTY_DETECTED_SET_REPORTING_QUANTITIES_PRESENCE_FLAG;

        convert_cell_reporting_quantities(
                &pvalue->detectedSetReportingQuantities,
                &p_intra_freq_reporting_quantity->detected_set_reporting_quantities);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_forbidden_affect_cell
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_ForbiddenAffectCell to 
 *       forbidden_affect_cell_t
 *
 ******************************************************************************/
void convert_forbidden_affect_cell
(
 UMTS_ForbiddenAffectCell   *pvalue,
 forbidden_affect_cell_t    *p_forbidden_affect_cell 
 )
{
    p_forbidden_affect_cell->t = pvalue->t;

    if (pvalue->t == T_UMTS_ForbiddenAffectCell_fdd)
    {
        convert_primary_cpich_info(
                pvalue->u.fdd,
                &p_forbidden_affect_cell->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_ForbiddenAffectCell_tdd)
    {
        convert_primary_ccpch_info(
                pvalue->u.tdd,
                &p_forbidden_affect_cell->u.tdd); 
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_forbidden_affect_cell_list
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_ForbiddenAffectCellList to 
 *       forbidden_affect_cell_list_t
 *
 ******************************************************************************/
void convert_forbidden_affect_cell_list
(
 UMTS_ForbiddenAffectCellList   *pvalue,
 forbidden_affect_cell_list_t   *p_forbidden_affect_cell_list 
 )
{
    UMTS_ForbiddenAffectCell    *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_forbidden_affect_cell_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ForbiddenAffectCell*)pnode->data;

        convert_forbidden_affect_cell(
                pdata,
                &p_forbidden_affect_cell_list->forbidden_affect_cell[index]);

        pnode = pnode->next;
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_event_1a
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_Event1a to 
 *       event_1a_t
 *
 ******************************************************************************/
void convert_event_1a
(
 UMTS_Event1a   *pvalue,
 event_1a_t     *p_event_1a 
 )
{
    p_event_1a->triggering_condition = pvalue->triggeringCondition;
    p_event_1a->reporting_range = pvalue->reportingRange;

    if (pvalue->m.forbiddenAffectCellListPresent)
    {
        p_event_1a->presence_bitmask |=
            UMTS_SIB_EVENT_1A_FORBIDDEN_AFFECT_CELL_LIST_PRESENCE_FLAG;

        convert_forbidden_affect_cell_list(
                &pvalue->forbiddenAffectCellList,
                &p_event_1a->forbidden_affect_cell_list);
    }

    p_event_1a->w = pvalue->w;
    p_event_1a->report_deactivation_threshold = pvalue->reportDeactivationThreshold;
    p_event_1a->reporting_amount = pvalue->reportingAmount;
    p_event_1a->reporting_interval = pvalue->reportingInterval;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_event_1b
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_Event1b to 
 *       event_1b_t
 *
 ******************************************************************************/
void convert_event_1b
(
 UMTS_Event1b   *pvalue,
 event_1b_t     *p_event_1b 
 )
{
    p_event_1b->triggering_condition = pvalue->triggeringCondition;
    p_event_1b->reporting_range = pvalue->reportingRange;

    if (pvalue->m.forbiddenAffectCellListPresent)
    {
        p_event_1b->presence_bitmask |=
            UMTS_SIB_EVENT_1B_FORBIDDEN_AFFECT_CELL_LIST_PRESENCE_FLAG;

        convert_forbidden_affect_cell_list(
                &pvalue->forbiddenAffectCellList,
                &p_event_1b->forbidden_affect_cell_list);
    }

    p_event_1b->w = pvalue->w;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_event_1c
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_Event1c to 
 *       event_1c_t
 *
 ******************************************************************************/
void convert_event_1c
(
 UMTS_Event1c   *pvalue,
 event_1c_t     *p_event_1c 
 )
{
    p_event_1c->replacement_activation_threshold = pvalue->replacementActivationThreshold;
    p_event_1c->reporting_amount = pvalue->reportingAmount;
    p_event_1c->reporting_interval = pvalue->reportingInterval;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_event_1e
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_Event1e to 
 *       event_1e_t
 *
 ******************************************************************************/
void convert_event_1e
(
 UMTS_Event1e   *pvalue,
 event_1e_t     *p_event_1e 
 )
{
    p_event_1e->triggering_condition = 
        pvalue->triggeringCondition;

    p_event_1e->threshold_used_freq =
        pvalue->thresholdUsedFrequency;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_event_1f
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_Event1f to 
 *       event_1f_t
 *
 ******************************************************************************/
void convert_event_1f
(
 UMTS_Event1f   *pvalue,
 event_1f_t     *p_event_1f 
 )
{
    p_event_1f->triggering_condition =
        pvalue->triggeringCondition;

    p_event_1f->threshold_used_freq =
        pvalue->thresholdUsedFrequency;

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_event
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqEvent to 
 *       intra_freq_event_t
 *
 ******************************************************************************/
void convert_intra_freq_event
(
 UMTS_IntraFreqEvent    *pvalue,
 intra_freq_event_t     *p_intra_freq_event 
 )
{
    p_intra_freq_event->t = pvalue->t;

    if (pvalue->t == T_UMTS_IntraFreqEvent_e1a)
    {
        convert_event_1a(
                pvalue->u.e1a,
                &p_intra_freq_event->u.e1a);
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_e1b)
    {
        convert_event_1b(
                pvalue->u.e1b,
                &p_intra_freq_event->u.e1b); 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_e1c)
    {
        convert_event_1c(
                pvalue->u.e1c,
                &p_intra_freq_event->u.e1c); 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_e1d)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_e1e)
    {
        convert_event_1e(
                pvalue->u.e1e,
                &p_intra_freq_event->u.e1e); 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_e1f)
    {
        convert_event_1f(
                pvalue->u.e1f,
                &p_intra_freq_event->u.e1f); 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_e1g)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_e1h)
    {
        p_intra_freq_event->u.e1h = pvalue->u.e1h;
    }
    else if (pvalue->t == T_UMTS_IntraFreqEvent_e1i)
    {
        p_intra_freq_event->u.e1i = pvalue->u.e1i;
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_reporting_cell_status
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_ReportingCellStatus to 
 *       reporting_cell_status_t
 *
 ******************************************************************************/
void convert_reporting_cell_status
(
 UMTS_ReportingCellStatus   *pvalue,
 reporting_cell_status_t    *p_reporting_cell_status 
 )
{
    memcpy(p_reporting_cell_status, pvalue, sizeof(reporting_cell_status_t));

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_event_criteria
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqEventCriteria to 
 *       intra_freq_event_criteria_t
 *
 ******************************************************************************/
void convert_intra_freq_event_criteria
(
 UMTS_IntraFreqEventCriteria    *pvalue,
 intra_freq_event_criteria_t    *p_intra_freq_event_criteria 
 )
{
    convert_intra_freq_event(
            &pvalue->event,
            &p_intra_freq_event_criteria->event);

    p_intra_freq_event_criteria->hysteresis =
        pvalue->hysteresis;

    p_intra_freq_event_criteria->time_to_trigger =
        pvalue->timeToTrigger;

    if (pvalue->m.reportingCellStatusPresent)
    {
        p_intra_freq_event_criteria->presence_bitmask |=
            UMTS_SIB_REPORTING_CELL_STATUS_PRESENCE_FLAG;

        convert_reporting_cell_status(
                &pvalue->reportingCellStatus,
                &p_intra_freq_event_criteria->reporting_cell_status);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_event_criteria_list
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqEventCriteriaList to 
 *       intra_freq_event_criteria_list_t
 *
 ******************************************************************************/
void convert_intra_freq_event_criteria_list
(
 UMTS_IntraFreqEventCriteriaList    *pvalue,
 intra_freq_event_criteria_list_t   *p_intra_freq_event_criteria_list 
 )
{
    UMTS_IntraFreqEventCriteria *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_intra_freq_event_criteria_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_IntraFreqEventCriteria*)pnode->data;

        convert_intra_freq_event_criteria(
                pdata,
                &p_intra_freq_event_criteria_list->intra_freq_event_criteria[index]);

        pnode = pnode->next;
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_reporting_criteria
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqReportingCriteria to 
 *       intra_freq_reporting_criteria_t
 *
 ******************************************************************************/
void convert_intra_freq_reporting_criteria
(
 UMTS_IntraFreqReportingCriteria     *pvalue,
 intra_freq_reporting_criteria_t     *p_intra_freq_reporting_criteria
 )
{
    if(pvalue->m.eventCriteriaListPresent)
    {
        p_intra_freq_reporting_criteria->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_EVENT_CRITERIA_LIST_PRESENCE_FLAG ;

        convert_intra_freq_event_criteria_list(
                &pvalue->eventCriteriaList,
                &p_intra_freq_reporting_criteria->intra_freq_event_criteria_list);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_cell_dch_report_criteria
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_CellDCH_ReportCriteria to 
 *       cell_dch_report_criteria_t
 *
 ******************************************************************************/
void convert_cell_dch_report_criteria
(
 UMTS_CellDCH_ReportCriteria     *pvalue,
 cell_dch_report_criteria_t      *p_report_criteria
 )
{
    p_report_criteria->t = pvalue->t;

    if(pvalue->t == T_UMTS_CellDCH_ReportCriteria_intraFreqReportingCriteria)
    {
        convert_intra_freq_reporting_criteria(
                pvalue->u.intraFreqReportingCriteria,
                &p_report_criteria->u.intra_freq_reporting_criteria);
    }
    else if(pvalue->t == T_UMTS_CellDCH_ReportCriteria_periodicalReportingCriteria)
    {
        convert_periodical_reporting_criteria(
                pvalue->u.periodicalReportingCriteria,
                &p_report_criteria->u.periodical_reporting_criteria);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_reporting_info_for_cell_dch
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_ReportingInfoForCellDCH to 
 *       reporting_info_for_cell_dch_t
 *
 ******************************************************************************/
void convert_reporting_info_for_cell_dch
(
 UMTS_ReportingInfoForCellDCH   *pvalue,
 reporting_info_for_cell_dch_t  *p_reporting_info_for_cell_dch
 )
{
    convert_intra_freq_reporting_quantity(
            &pvalue->intraFreqReportingQuantity,
            &p_reporting_info_for_cell_dch->intra_freq_reporting_quantity);

    convert_measurement_reporting_mode(
            &pvalue->measurementReportingMode,
            &p_reporting_info_for_cell_dch->measurement_reporting_mode);

    convert_cell_dch_report_criteria(
            &pvalue->reportCriteria,
            &p_reporting_info_for_cell_dch->report_criteria);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_measurement_sysinfo_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasurementSysInfo_RSCP to 
 *       intra_freq_measurement_sysinfo_rscp_t
 *
 ******************************************************************************/
void convert_intra_freq_measurement_sysinfo_rscp
(
 UMTS_IntraFreqMeasurementSysInfo_RSCP  *pvalue,
 intra_freq_measurement_sysinfo_rscp_t  *p_intra_freq_measurement_sysinfo_rscp
 )
{
    p_intra_freq_measurement_sysinfo_rscp->intra_freq_meas_id =
        pvalue->intraFreqMeasurementID;

    if(pvalue->m.intraFreqCellInfoSI_ListPresent)
    {
        p_intra_freq_measurement_sysinfo_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_RSCP_SI_LIST_PRESENCE_FLAG;

        convert_intra_freq_cell_info_si_list_rscp(
                &pvalue->intraFreqCellInfoSI_List,
                &p_intra_freq_measurement_sysinfo_rscp->intra_freq_cell_info_si_list_rscp);
    }

    if(pvalue->m.intraFreqMeasQuantityPresent)
    {
        p_intra_freq_measurement_sysinfo_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_RSCP_MEAS_QTY_PRESENCE_FLAG;

        convert_intra_freq_meas_quantity(
                &pvalue->intraFreqMeasQuantity,
                &p_intra_freq_measurement_sysinfo_rscp->intra_freq_meas_quantity);
    }

    if(pvalue->m.intraFreqReportingQuantityForRACHPresent)
    {
        p_intra_freq_measurement_sysinfo_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_RSCP_REPORTING_QTY_FOR_RACH_PRESENCE_FLAG;

        convert_intra_freq_reporting_quantity_for_rach(
                &pvalue->intraFreqReportingQuantityForRACH,
                &p_intra_freq_measurement_sysinfo_rscp->intra_freq_reporting_quantity_for_rach);
    }

    if(pvalue->m.maxReportedCellsOnRACHPresent)
    {
        p_intra_freq_measurement_sysinfo_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_RSCP_MAX_REPORTED_CELLS_ON_RACH_PRESENCE_FLAG;

        p_intra_freq_measurement_sysinfo_rscp->max_reported_cells_on_rach = 
            pvalue->maxReportedCellsOnRACH;
    }

    if(pvalue->m.reportingInfoForCellDCHPresent)
    {
        p_intra_freq_measurement_sysinfo_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_RSCP_REPORTING_INFO_FOR_CELL_DCH_PRESENCE_FLAG;

        convert_reporting_info_for_cell_dch(
                &pvalue->reportingInfoForCellDCH,
                &p_intra_freq_measurement_sysinfo_rscp->reporting_info_for_cell_dch);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_removed_inter_freq_cell_list_remove_some_inter_freq_cells
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_RemovedInterFreqCellList_removeSomeInterFreqCells to 
 *       removed_inter_freq_cell_list_remove_some_inter_freq_cells_t
 *
 ******************************************************************************/
void convert_removed_inter_freq_cell_list_remove_some_inter_freq_cells
(
 UMTS_RemovedInterFreqCellList_removeSomeInterFreqCells         *pvalue,
 removed_inter_freq_cell_list_remove_some_inter_freq_cells_t    *p_inter_freq_cells
 )
{
    p_inter_freq_cells->n = pvalue->n;

    memcpy(&p_inter_freq_cells->elem, &pvalue->elem,
            (sizeof(U8) * p_inter_freq_cells->n));

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_removed_inter_freq_cell_list
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_RemovedInterFreqCellList to 
 *       removed_inter_freq_cell_list_t
 *
 ******************************************************************************/
void convert_removed_inter_freq_cell_list
(
 UMTS_RemovedInterFreqCellList       *pvalue,
 removed_inter_freq_cell_list_t      *p_removed_inter_freq_cell_list
 )
{
    p_removed_inter_freq_cell_list->t = pvalue->t;

    if(pvalue->t == T_UMTS_RemovedInterFreqCellList_removeAllInterFreqCells)
    {
        /* for future use only */
    }
    else if (pvalue->t == T_UMTS_RemovedInterFreqCellList_removeSomeInterFreqCells)
    {
        convert_removed_inter_freq_cell_list_remove_some_inter_freq_cells(
                pvalue->u.removeSomeInterFreqCells,
                &p_removed_inter_freq_cell_list->u.remove_some_inter_freq_cells);
    }
    else if(pvalue->t == T_UMTS_RemovedInterFreqCellList_removeNoInterFreqCells)
    {
        /* for future use only */
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_cell_info_si_list_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterFreqCellInfoSI_List_RSCP to 
 *       inter_freq_cell_info_si_list_rscp_t
 *
 ******************************************************************************/
void convert_inter_freq_cell_info_si_list_rscp
(
 UMTS_InterFreqCellInfoSI_List_RSCP      *pvalue,
 inter_freq_cell_info_si_list_rscp_t     *p_inter_freq_cell_info_si_list_rscp
 )
{
    if(pvalue->m.removedInterFreqCellListPresent)
    {
        p_inter_freq_cell_info_si_list_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_RSCP_REMOVED_LIST_PRESENCE_FLAG;

        convert_removed_inter_freq_cell_list(
                &pvalue->removedInterFreqCellList,
                &p_inter_freq_cell_info_si_list_rscp->removed_inter_freq_cell_list);
    }

    if(pvalue->m.newInterFreqCellListPresent)
    {
        p_inter_freq_cell_info_si_list_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_RSCP_NEW_LIST_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_rscp(
                &pvalue->newInterFreqCellList,
                &p_inter_freq_cell_info_si_list_rscp->new_inter_freq_cell_si_list_rscp);

    }
    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_measurement_sysinfo_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterFreqMeasurementSysInfo_RSCP to 
 *       inter_freq_measurement_sysinfo_rscp_t
 *
 ******************************************************************************/
void convert_inter_freq_measurement_sysinfo_rscp
(
 UMTS_InterFreqMeasurementSysInfo_RSCP   *pvalue,
 inter_freq_measurement_sysinfo_rscp_t   *p_inter_freq_measurement_sysinfo_rscp
 )
{

    if(pvalue->m.interFreqCellInfoSI_ListPresent)
    {
        p_inter_freq_measurement_sysinfo_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEAS_SYSINFO_RSCP_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_inter_freq_cell_info_si_list_rscp(
                &pvalue->interFreqCellInfoSI_List,
                &p_inter_freq_measurement_sysinfo_rscp->inter_freq_cell_info_si_list_rscp);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP to 
 *       measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp_t
 *
 ******************************************************************************/
void convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp
(
 UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP     *pvalue,
 measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp_t  *p_cpich_rscp
 )
{
    if (pvalue->m.intraFreqMeasurementSysInfoPresent)
    {
        p_cpich_rscp->presence_bitmask|=
            UMTS_SIB_TYPE_11_MEAS_CTRL_SYSINFO_USE_OF_HCS_NOT_USED_CELL_SELECT_QLTY_MEAS_CPICH_RSCP_INTRA_FREQ_PRESENCE_FLAG;

        convert_intra_freq_measurement_sysinfo_rscp(
                &pvalue->intraFreqMeasurementSysInfo,
                &p_cpich_rscp->intra_freq_measurement_sysinfo_rscp);
    }

    if (pvalue->m.interFreqMeasurementSysInfoPresent)
    { 
        p_cpich_rscp->presence_bitmask|=
            UMTS_SIB_TYPE_11_MEAS_CTRL_SYSINFO_USE_OF_HCS_NOT_USED_CELL_SELECT_QLTY_MEAS_CPICH_RSCP_INTER_FREQ_PRESENCE_FLAG;

        convert_inter_freq_measurement_sysinfo_rscp(
                &pvalue->interFreqMeasurementSysInfo,
                &p_cpich_rscp->inter_freq_measurement_sysinfo_rscp);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_cell_info_si_list_ecno
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqCellInfoSI_List_ECN0 to 
 *       intra_freq_cell_info_si_list_ecno_t
 *
 ******************************************************************************/
void convert_intra_freq_cell_info_si_list_ecno
(
 UMTS_IntraFreqCellInfoSI_List_ECN0      *pvalue,
 intra_freq_cell_info_si_list_ecno_t     *p_intra_freq_cell_info_si_list_ecno
 )
{
    if(pvalue->m.removedIntraFreqCellListPresent)
    {
        p_intra_freq_cell_info_si_list_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_CELL_INFO_SI_LIST_ECNO_REMOVED_INTRA_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_intra_freq_cell_list(
                &pvalue->removedIntraFreqCellList,
                &p_intra_freq_cell_info_si_list_ecno->removed_intra_freq_cell_list);
    }

    convert_new_intra_freq_cell_si_list_ecno(
            &pvalue->newIntraFreqCellList,
            &p_intra_freq_cell_info_si_list_ecno->new_intra_freq_cell_si_list_ecno);

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_measurement_sysinfo_ecno
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasurementSysInfo_ECN0 to 
 *       intra_freq_measurement_sysinfo_ecno_t
 *
 ******************************************************************************/
void convert_intra_freq_measurement_sysinfo_ecno
(
 UMTS_IntraFreqMeasurementSysInfo_ECN0   *pvalue,
 intra_freq_measurement_sysinfo_ecno_t   *p_intra_freq_measurement_sysinfo_ecno
 )
{
    p_intra_freq_measurement_sysinfo_ecno->intra_freq_meas_id  = pvalue->intraFreqMeasurementID;

    if(pvalue->m.intraFreqCellInfoSI_ListPresent)
    {
        p_intra_freq_measurement_sysinfo_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_ECNO_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_intra_freq_cell_info_si_list_ecno(
                &pvalue->intraFreqCellInfoSI_List,
                &p_intra_freq_measurement_sysinfo_ecno->intra_freq_cell_info_si_list_ecno);
    }

    if(pvalue->m.intraFreqMeasQuantityPresent)
    {
        p_intra_freq_measurement_sysinfo_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_ECNO_MEAS_QTY_PRESENCE_FLAG;

        convert_intra_freq_meas_quantity(
                &pvalue->intraFreqMeasQuantity,
                &p_intra_freq_measurement_sysinfo_ecno->intra_freq_meas_quantity);
    }

    if(pvalue->m.intraFreqReportingQuantityForRACHPresent)
    {
        p_intra_freq_measurement_sysinfo_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_ECNO_REPORTING_QTY_FOR_RACH_PRESENCE_FLAG;

        convert_intra_freq_reporting_quantity_for_rach(
                &pvalue->intraFreqReportingQuantityForRACH,
                &p_intra_freq_measurement_sysinfo_ecno->intra_freq_reporting_quantity_for_rach);
    }

    if(pvalue->m.maxReportedCellsOnRACHPresent)
    {
        p_intra_freq_measurement_sysinfo_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_ECNO_MAX_REPORTED_CELLS_ON_RACH_PRESENCE_FLAG;

        p_intra_freq_measurement_sysinfo_ecno->max_reported_cells_on_rach = pvalue->maxReportedCellsOnRACH;
    }

    if(pvalue->m.reportingInfoForCellDCHPresent)
    {
        p_intra_freq_measurement_sysinfo_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_ECNO_REPORTING_INFO_FOR_CELL_DCH_PRESENCE_FLAG;

        convert_reporting_info_for_cell_dch(
                &pvalue->reportingInfoForCellDCH,
                &p_intra_freq_measurement_sysinfo_ecno->reporting_info_for_cell_dch);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_cell_info_si_list_ecno
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterFreqCellInfoSI_List_ECN0 to 
 *       inter_freq_cell_info_si_list_ecno_t
 *
 ******************************************************************************/
void convert_inter_freq_cell_info_si_list_ecno
(
 UMTS_InterFreqCellInfoSI_List_ECN0      *pvalue,
 inter_freq_cell_info_si_list_ecno_t     *p_inter_freq_cell_info_si_list_ecno 
 )
{
    if(pvalue->m.removedInterFreqCellListPresent)
    {
        p_inter_freq_cell_info_si_list_ecno->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_ECNO_REMOVED_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_inter_freq_cell_list(
                &pvalue->removedInterFreqCellList,
                &p_inter_freq_cell_info_si_list_ecno->removed_inter_freq_cell_list);
    }

    if(pvalue->m.newInterFreqCellListPresent)
    {
        p_inter_freq_cell_info_si_list_ecno->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_ECNO_NEW_INTER_FREQ_CELL_SI_LIST_ECNO_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_ecno(
                &pvalue->newInterFreqCellList,
                &p_inter_freq_cell_info_si_list_ecno->new_inter_freq_cell_si_list_ecno);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_measurement_sysinfo_ecno
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterFreqMeasurementSysInfo_ECN0 to 
 *       inter_freq_measurement_sysinfo_ecno_t
 *
 ******************************************************************************/
void convert_inter_freq_measurement_sysinfo_ecno
(
 UMTS_InterFreqMeasurementSysInfo_ECN0   *pvalue,
 inter_freq_measurement_sysinfo_ecno_t   *p_inter_freq_measurement_sysinfo_ecno
 )
{
    if(pvalue->m.interFreqCellInfoSI_ListPresent)
    {
        p_inter_freq_measurement_sysinfo_ecno->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_ECNO_PRESENCE_FLAG;

        convert_inter_freq_cell_info_si_list_ecno(
                &pvalue->interFreqCellInfoSI_List,
                &p_inter_freq_measurement_sysinfo_ecno->inter_freq_cell_info_si_list_ecno);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0 to 
 *       measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no_t
 *
 ******************************************************************************/
void convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no
(
 UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0     *pvalue,
 measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no_t  *p_cpich_Ec_N0 
 )
{
    if(pvalue->m.intraFreqMeasurementSysInfoPresent)
    {
        p_cpich_Ec_N0->presence_bitmask |=
            UMTS_SIB_TYPE_11_MEAS_CTRL_SYSINFO_USE_OF_HCS_NOT_USED_CELL_SELECT_QLTY_MEAS_CPICH_EC_NO_INTRA_FREQ_PRESENCE_FLAG;

        convert_intra_freq_measurement_sysinfo_ecno(
                &pvalue->intraFreqMeasurementSysInfo,
                &p_cpich_Ec_N0->intra_freq_measurement_sysinfo_ecno);
    }
    else if(pvalue->m.interFreqMeasurementSysInfoPresent)
    {
        p_cpich_Ec_N0->presence_bitmask |=
            UMTS_SIB_TYPE_11_MEAS_CTRL_SYSINFO_USE_OF_HCS_NOT_USED_CELL_SELECT_QLTY_MEAS_CPICH_EC_NO_INTER_FREQ_PRESENCE_FLAG;

        convert_inter_freq_measurement_sysinfo_ecno(
                &pvalue->interFreqMeasurementSysInfo,
                &p_cpich_Ec_N0->inter_freq_measurement_sysinfo_ecno);
    }

    return;
}

/*******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used_cellSelectQualityMeasure to 
 *       measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_t
 *
 ******************************************************************************/
void  convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure
(
 UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used_cellSelectQualityMeasure    *pvalue,
 measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_t *p_cell_select_quality_measure
 )
{
    p_cell_select_quality_measure->t = pvalue->t;

    if(pvalue->t == T_UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_RSCP)
    {
        convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_rscp(
                pvalue->u.cpich_RSCP,
                &p_cell_select_quality_measure->u.cpich_rscp);
    }
    else if(pvalue->t == T_UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure_cpich_ec_no(
                pvalue->u.cpich_Ec_N0,
                &p_cell_select_quality_measure->u.cpich_ec_no);
    }

    return;
}


/*******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_use_of_hcs_hcs_not_used
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used to 
 *       measurement_control_sys_info_use_of_hcs_hcs_not_used_t
 *
 ******************************************************************************/
void convert_measurement_control_sys_info_use_of_hcs_hcs_not_used
(
 UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_not_used *pvalue,
 measurement_control_sys_info_use_of_hcs_hcs_not_used_t *p_hcs_not_used
 )
{
    convert_measurement_control_sys_info_use_of_hcs_hcs_not_used_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_hcs_not_used->cell_select_quality_measure);

    if(pvalue->m.interRATMeasurementSysInfoPresent)
    {
        p_hcs_not_used->presence_bitmask |=
            UMTS_SIB_TYPE_11_MEAS_CTRL_SYSINFO_USE_OF_HCS_NOT_USED_INTER_RAT_MEAS_SYSINFO_PRESENCE_FLAG;

        convert_inter_rat_measurement_sysinfo_b(
                &pvalue->interRATMeasurementSysInfo,
                &p_hcs_not_used->inter_rat_measurement_sysinfo_b);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_cell_info_si_list_hcs_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqCellInfoSI_List_HCS_RSCP to 
 *       intra_freq_cell_info_si_list_hcs_rscp_t
 *
 *******************************************************************************/
void convert_intra_freq_cell_info_si_list_hcs_rscp
(
 UMTS_IntraFreqCellInfoSI_List_HCS_RSCP          *pvalue,
 intra_freq_cell_info_si_list_hcs_rscp_t         *p_intra_freq_cell_info_si_list_hcs_rscp
 )
{
    if(pvalue->m.removedIntraFreqCellListPresent)
    {
        p_intra_freq_cell_info_si_list_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_CELL_INFO_SI_LIST_HCS_RSCP_REMOVED_INTRA_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_intra_freq_cell_list(
                &pvalue->removedIntraFreqCellList,
                &p_intra_freq_cell_info_si_list_hcs_rscp->removed_intra_freq_cell_list);
    }

    convert_new_intra_freq_cell_si_list_hcs_rscp(
            &pvalue->newIntraFreqCellList,
            &p_intra_freq_cell_info_si_list_hcs_rscp->new_intra_freq_cell_si_list_hcs_rscp);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_measurement_sys_info_hcs_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasurementSysInfo_HCS_RSCP to 
 *       intra_freq_measurement_sys_info_hcs_rscp_t
 *
 *******************************************************************************/
void convert_intra_freq_measurement_sys_info_hcs_rscp
(
 UMTS_IntraFreqMeasurementSysInfo_HCS_RSCP           *pvalue,
 intra_freq_measurement_sys_info_hcs_rscp_t          *p_intra_freq_measurement_sys_info_hcs_rscp
 )
{
    p_intra_freq_measurement_sys_info_hcs_rscp->intra_freq_meas_id = 
        pvalue->intraFreqMeasurementID;

    if(pvalue->m.intraFreqCellInfoSI_ListPresent)
    {
        p_intra_freq_measurement_sys_info_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_RSCP_INTRA_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_intra_freq_cell_info_si_list_hcs_rscp(
                &pvalue->intraFreqCellInfoSI_List,
                &p_intra_freq_measurement_sys_info_hcs_rscp->intra_freq_cell_info_si_list_hcs_rscp);
    }

    if(pvalue->m.intraFreqMeasQuantityPresent)
    {
        p_intra_freq_measurement_sys_info_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_RSCP_INTRA_FREQ_MEAS_QTY_PRESENCE_FLAG;

        convert_intra_freq_meas_quantity(
                &pvalue->intraFreqMeasQuantity,
                &p_intra_freq_measurement_sys_info_hcs_rscp->intra_freq_meas_quantity);
    }

    if(pvalue->m.intraFreqReportingQuantityForRACHPresent)
    {
        p_intra_freq_measurement_sys_info_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_RSCP_INTRA_FREQ_REPORTING_QTY_FOR_RACH_PRESENCE_FLAG;

        convert_intra_freq_reporting_quantity_for_rach(
                &pvalue->intraFreqReportingQuantityForRACH,
                &p_intra_freq_measurement_sys_info_hcs_rscp->intra_freq_reporting_quantity_for_rach);
    }

    if(pvalue->m.maxReportedCellsOnRACHPresent)
    {
        p_intra_freq_measurement_sys_info_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_RSCP_MAX_REPORTED_CELLS_ON_RACH_PRESENCE_FLAG;

        p_intra_freq_measurement_sys_info_hcs_rscp->max_reported_cells_on_rach = 
            pvalue->maxReportedCellsOnRACH;
    }

    if(pvalue->m.reportingInfoForCellDCHPresent)
    {
        p_intra_freq_measurement_sys_info_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_RSCP_REPORTING_INFO_FOR_CELL_DCH_PRESENCE_FLAG;

        convert_reporting_info_for_cell_dch(
                &pvalue->reportingInfoForCellDCH,
                &p_intra_freq_measurement_sys_info_hcs_rscp->reporting_info_for_cell_dch);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_cell_info_si_list_hcs_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterFreqCellInfoSI_List_HCS_RSCP to 
 *       inter_freq_cell_info_si_list_hcs_rscp_t
 *
 *******************************************************************************/
void convert_inter_freq_cell_info_si_list_hcs_rscp
(
 UMTS_InterFreqCellInfoSI_List_HCS_RSCP      *pvalue,
 inter_freq_cell_info_si_list_hcs_rscp_t     *p_inter_freq_cell_info_si_list_hcs_rscp
 )
{
    if(pvalue->m.removedInterFreqCellListPresent)
    {
        p_inter_freq_cell_info_si_list_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_RSCP_REMOVED_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_inter_freq_cell_list(
                &pvalue->removedInterFreqCellList,
                &p_inter_freq_cell_info_si_list_hcs_rscp->removed_inter_freq_cell_list);
    }

    if(pvalue->m.newInterFreqCellListPresent)
    {
        p_inter_freq_cell_info_si_list_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_RSCP_NEW_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_hcs_rscp(
                &pvalue->newInterFreqCellList,
                &p_inter_freq_cell_info_si_list_hcs_rscp->new_inter_freq_cell_si_list_hcs_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_measurement_sys_info_hcs_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterFreqMeasurementSysInfo_HCS_RSCP to 
 *       inter_freq_measurement_sys_info_hcs_rscp_t
 *
 *******************************************************************************/
void convert_inter_freq_measurement_sys_info_hcs_rscp
(
 UMTS_InterFreqMeasurementSysInfo_HCS_RSCP   *pvalue,
 inter_freq_measurement_sys_info_hcs_rscp_t  *p_inter_freq_measurement_sys_info_hcs_rscp
 )
{
    if(pvalue->m.interFreqCellInfoSI_ListPresent)
    {
        p_inter_freq_measurement_sys_info_hcs_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEAS_SYSINFO_HCS_RSCP_INTER_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_inter_freq_cell_info_si_list_hcs_rscp(
                &pvalue->interFreqCellInfoSI_List,
                &p_inter_freq_measurement_sys_info_hcs_rscp->inter_freq_cell_info_si_list_hcs_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP to 
 *       measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp_t
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp
(
 UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP      *pvalue,
 measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp_t   *p_cpich_rscp
 )
{
    if(pvalue->m.intraFreqMeasurementSysInfoPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_RSCP_PRESENCE_FLAG;

        convert_intra_freq_measurement_sys_info_hcs_rscp(
                &pvalue->intraFreqMeasurementSysInfo,
                &p_cpich_rscp->intra_freq_measurement_sys_info_hcs_rscp);
    }

    if(pvalue->m.interFreqMeasurementSysInfoPresent)
    {
        p_cpich_rscp->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEAS_SYSINFO_HCS_RSCP_PRESENCE_FLAG;

        convert_inter_freq_measurement_sys_info_hcs_rscp(
                &pvalue->interFreqMeasurementSysInfo,
                &p_cpich_rscp->inter_freq_measurement_sys_info_hcs_rscp);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_cell_info_si_list_hcs_ecno
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqCellInfoSI_List_HCS_ECN0 to 
 *       intra_freq_cell_info_si_list_hcs_ecno_t
 *
 *******************************************************************************/
void convert_intra_freq_cell_info_si_list_hcs_ecno
(
 UMTS_IntraFreqCellInfoSI_List_HCS_ECN0     *pvalue,
 intra_freq_cell_info_si_list_hcs_ecno_t    *p_hcs_ecno 
 )
{
    if (pvalue->m.removedIntraFreqCellListPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_CELL_INFO_SI_LIST_HCS_ECNO_REMOVED_INTRA_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_intra_freq_cell_list(
                &pvalue->removedIntraFreqCellList,
                &p_hcs_ecno->removed_intra_freq_cell_list);
    }

    convert_new_intra_freq_cell_si_list_hcs_ecno(
            &pvalue->newIntraFreqCellList,
            &p_hcs_ecno->new_intra_freq_cell_si_list_hcs_ecno);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_intra_freq_measurement_sys_info_hcs_ecno
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_IntraFreqMeasurementSysInfo_HCS_ECN0 to 
 *       intra_freq_measurement_sys_info_hcs_ecno_t
 *
 *******************************************************************************/
void convert_intra_freq_measurement_sys_info_hcs_ecno
(
 UMTS_IntraFreqMeasurementSysInfo_HCS_ECN0      *pvalue,
 intra_freq_measurement_sys_info_hcs_ecno_t     *p_hcs_ecno 
 )
{
    p_hcs_ecno->intra_freq_meas_id =
        pvalue->intraFreqMeasurementID;

    if (pvalue->m.intraFreqCellInfoSI_ListPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_ECNO_INTRA_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_intra_freq_cell_info_si_list_hcs_ecno(
                &pvalue->intraFreqCellInfoSI_List,
                &p_hcs_ecno->intra_freq_cell_info_si_list_hcs_ecno);
    }

    if (pvalue->m.intraFreqMeasQuantityPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_ECNO_INTRA_FREQ_MEAS_QTY_PRESENCE_FLAG;

        convert_intra_freq_meas_quantity(
                &pvalue->intraFreqMeasQuantity,
                &p_hcs_ecno->intra_freq_meas_quantity);
    }

    if (pvalue->m.intraFreqReportingQuantityForRACHPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_ECNO_INTRA_FREQ_REPORTING_QTY_FOR_RACH_PRESENCE_FLAG;

        convert_intra_freq_reporting_quantity_for_rach(
                &pvalue->intraFreqReportingQuantityForRACH,
                &p_hcs_ecno->intra_freq_reporting_quantity_for_rach);
    }

    if (pvalue->m.maxReportedCellsOnRACHPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_ECNO_MAX_REPORTED_CELLS_ON_RACH_PRESENCE_FLAG;

        p_hcs_ecno->max_reported_cells_on_rach =
            pvalue->maxReportedCellsOnRACH;
    }

    if (pvalue->m.reportingInfoForCellDCHPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_ECNO_REPORTING_INFO_FOR_CELL_DCH_PRESENCE_FLAG;

        convert_reporting_info_for_cell_dch(
                &pvalue->reportingInfoForCellDCH,
                &p_hcs_ecno->reporting_info_for_cell_dch);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_cell_info_si_list_hcs_ecno
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterFreqCellInfoSI_List_HCS_ECN0 to 
 *       inter_freq_cell_info_si_list_hcs_ecno_t
 *
 *******************************************************************************/
void convert_inter_freq_cell_info_si_list_hcs_ecno
(
 UMTS_InterFreqCellInfoSI_List_HCS_ECN0     *pvalue,
 inter_freq_cell_info_si_list_hcs_ecno_t    *p_hcs_ecno 
 )
{
    if (pvalue->m.removedInterFreqCellListPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_ECNO_REMOVED_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_removed_inter_freq_cell_list(
                &pvalue->removedInterFreqCellList,
                &p_hcs_ecno->removed_inter_freq_cell_list);
    }

    if (pvalue->m.newInterFreqCellListPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_CELL_INFO_SI_LIST_HCS_ECNO_NEW_INTER_FREQ_CELL_LIST_PRESENCE_FLAG;

        convert_new_inter_freq_cell_si_list_hcs_ecno(
                &pvalue->newInterFreqCellList,
                &p_hcs_ecno->new_inter_freq_cell_si_list_hcs_ecno);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_freq_measurement_sys_info_hcs_ecno
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterFreqMeasurementSysInfo_HCS_ECN0 to 
 *       inter_freq_measurement_sys_info_hcs_ecno_t
 *
 *******************************************************************************/
void convert_inter_freq_measurement_sys_info_hcs_ecno
(
 UMTS_InterFreqMeasurementSysInfo_HCS_ECN0  *pvalue,
 inter_freq_measurement_sys_info_hcs_ecno_t *p_hcs_ecno 
 )
{
    if (pvalue->m.interFreqCellInfoSI_ListPresent)
    {
        p_hcs_ecno->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEAS_SYSINFO_HCS_ECNO_INTER_FREQ_CELL_INFO_SI_LIST_PRESENCE_FLAG;

        convert_inter_freq_cell_info_si_list_hcs_ecno(
                &pvalue->interFreqCellInfoSI_List,
                &p_hcs_ecno->inter_freq_cell_info_si_list_hcs_ecno);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0 to 
 *       measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no_t
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no
(
 UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0     *pvalue,
 measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no_t  *p_cpich_ec_no
 )
{
    if (pvalue->m.intraFreqMeasurementSysInfoPresent)
    {
        p_cpich_ec_no->presence_bitmask |=
            UMTS_SIB_INTRA_FREQ_MEAS_SYSINFO_HCS_ECNO_PRESENCE_FLAG;

        convert_intra_freq_measurement_sys_info_hcs_ecno(
                &pvalue->intraFreqMeasurementSysInfo,
                &p_cpich_ec_no->intra_freq_measurement_sys_info_hcs_ecno);
    }

    if (pvalue->m.interFreqMeasurementSysInfoPresent)
    {
        p_cpich_ec_no->presence_bitmask |=
            UMTS_SIB_INTER_FREQ_MEAS_SYSINFO_HCS_ECNO_PRESENCE_FLAG;

        convert_inter_freq_measurement_sys_info_hcs_ecno(
                &pvalue->interFreqMeasurementSysInfo,
                &p_cpich_ec_no->inter_freq_measurement_sys_info_hcs_ecno);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used_cellSelectQualityMeasure to 
 *       measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_t
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure
(
 UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used_cellSelectQualityMeasure    *pvalue,
 measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_t *p_hcs_used
 )
{
    p_hcs_used->t = pvalue->t;

    if(pvalue->t == T_UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_RSCP)
    {   
        convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_rscp(
                pvalue->u.cpich_RSCP,
                &p_hcs_used->u.cpich_rscp);
    }
    else if(pvalue->t == T_UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure_cpich_ec_no(
                pvalue->u.cpich_Ec_N0,
                &p_hcs_used->u.cpich_ec_no);    
    }           

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_cells_for_inter_rat_meas_list
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_CellsForInterRATMeasList to 
 *       cells_for_inter_rat_meas_list_t
 *
 *******************************************************************************/
void convert_cells_for_inter_rat_meas_list
(
 UMTS_CellsForInterRATMeasList      *pvalue,
 cells_for_inter_rat_meas_list_t    *p_cells_for_inter_rat_meas_list 
 )
{
    p_cells_for_inter_rat_meas_list->n = pvalue->n;

    memcpy(p_cells_for_inter_rat_meas_list, pvalue,
            (sizeof(U8)*p_cells_for_inter_rat_meas_list->n));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_rat_cell_info_list
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterRATCellInfoList to 
 *       inter_rat_cell_info_list_t
 *
 *******************************************************************************/
void convert_inter_rat_cell_info_list
(
 UMTS_InterRATCellInfoList  *pvalue,
 inter_rat_cell_info_list_t *p_inter_rat_cell_info_list 
 )
{
    convert_removed_inter_rat_cell_list(
            &pvalue->removedInterRATCellList,
            &p_inter_rat_cell_info_list->removed_inter_rat_cell_list);

    convert_new_inter_rat_cell_list(
            &pvalue->newInterRATCellList,
            &p_inter_rat_cell_info_list->new_inter_rat_cell_list);

    if (pvalue->m.cellsForInterRATMeasListPresent)
    {
        p_inter_rat_cell_info_list->presence_bitmask |=
            UMTS_SIB_INTER_RAT_CELL_INFO_LIST_CELLS_FOR_INTER_RAT_MEAS_LIST_PRESENCE_FLAG;

        convert_cells_for_inter_rat_meas_list(
                &pvalue->cellsForInterRATMeasList,
                &p_inter_rat_cell_info_list->cells_for_inter_rat_meas_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_inter_rat_measurement_sys_info
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_InterRATMeasurementSysInfo to 
 *       inter_rat_measurement_sys_info_t
 *
 *******************************************************************************/
void convert_inter_rat_measurement_sys_info
(
 UMTS_InterRATMeasurementSysInfo    *pvalue,
 inter_rat_measurement_sys_info_t   *p_inter_rat_measurement_sys_info 
 )
{
    if (pvalue->m.interRATCellInfoListPresent)
    {
        p_inter_rat_measurement_sys_info->presence_bitmask |=
            UMTS_SIB_INTER_RAT_MEAS_SYSINFO_INTER_RAT_CELL_INFO_LIST_PRESENCE_FLAG;

        convert_inter_rat_cell_info_list(
                &pvalue->interRATCellInfoList,
                &p_inter_rat_measurement_sys_info->inter_rat_cell_info_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_control_sys_info_use_of_hcs_hcs_used
 *
 *   DESCRIPTION:
 *       This function converts  
 *       UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used to 
 *       measurement_control_sys_info_use_of_hcs_hcs_used_t
 *
 *******************************************************************************/
void convert_measurement_control_sys_info_use_of_hcs_hcs_used
(
 UMTS_MeasurementControlSysInfo_use_of_HCS_hcs_used      *pvalue,
 measurement_control_sys_info_use_of_hcs_hcs_used_t      *p_hcs_used
 )
{
    convert_measurement_control_sys_info_use_of_hcs_hcs_used_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_hcs_used->cell_select_quality_measure);

    if(pvalue->m.interRATMeasurementSysInfoPresent)
    {
        p_hcs_used->presence_bitmask |=
            UMTS_SIB_MEAS_CTRL_SYSINFO_USE_OF_HCS_HCS_USED_INTER_RAT_MEAS_SYSINFO_PRESENCE_FLAG;

        convert_inter_rat_measurement_sys_info(
                &pvalue->interRATMeasurementSysInfo,
                &p_hcs_used->inter_rat_measurement_sys_info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: decode_system_info_msg
 *
 *   DESCRIPTION: This function decodes the system information message.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code decode_system_info_msg
(
 umts_sib_message_t     *decoded_buf
 )
{
    return_code ret_val = FAILURE;

    if (UMTS_MIB_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_mib( &(decoded_buf->umts_mib_info));
        free(g_umts_ctxt.bch_info[UMTS_MIB_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_MIB_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_mib failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_MIB_INFO_COMPLETE;
            return FAILURE;
        }  
        decoded_buf->presence_bitmask |= UMTS_MIB_INFO_DECODE_COMPLETE;  
    }

    if (UMTS_SIB_TYPE_1_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib1(&(decoded_buf->umts_sib_type_1_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_1_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_1_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib1 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_1_INFO_COMPLETE;
            return FAILURE;
        }   
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_1_INFO_DECODE_COMPLETE;
    }    

    if (UMTS_SIB_TYPE_2_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib2(&(decoded_buf->umts_sib_type_2_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_2_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_2_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib2 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_2_INFO_COMPLETE;

            return FAILURE;
        }    
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_2_INFO_DECODE_COMPLETE;
    }

    if (UMTS_SIB_TYPE_3_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib3(&(decoded_buf->umts_sib_type_3_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_3_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_3_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib3 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_3_INFO_COMPLETE;

            return FAILURE;
        }    
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_3_INFO_DECODE_COMPLETE;
    }

    if (UMTS_SIB_TYPE_5_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib5(&(decoded_buf->umts_sib_type_5_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_5_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_5_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib5 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_5_INFO_COMPLETE;

            return FAILURE;
        }    
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_5_INFO_DECODE_COMPLETE;
    }    

    if (UMTS_SIB_TYPE_7_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib7(&(decoded_buf->umts_sib_type_7_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_7_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_7_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib7 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_7_INFO_COMPLETE;

            return FAILURE;
        }    
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_7_INFO_DECODE_COMPLETE;
    }    

    if (UMTS_SIB_TYPE_11_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib11(&(decoded_buf->umts_sib_type_11_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_11_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_11_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib11 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_11_INFO_COMPLETE;

            return FAILURE;
        }    
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_11_INFO_DECODE_COMPLETE;
    }   

    if (UMTS_SIB_TYPE_11_BIS_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib11bis(&(decoded_buf->umts_sib_type_11bis_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_11_bis_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_11_bis_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib11bis failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_11_BIS_INFO_COMPLETE;

            return FAILURE;
        }    
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_11_BIS_INFO_DECODE_COMPLETE;
    }   

    if (UMTS_SIB_TYPE_12_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib12(&(decoded_buf->umts_sib_type_12_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_12_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_12_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib12 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_12_INFO_COMPLETE;

            return FAILURE;
        }    
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_12_INFO_DECODE_COMPLETE;
    }

    if (UMTS_SIB_TYPE_18_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = umts_convert_sib18(&(decoded_buf->umts_sib_type_18_info));
        free(g_umts_ctxt.bch_info[UMTS_SIB_TYPE_18_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SIB_TYPE_18_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_sib18 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SIB_TYPE_18_INFO_COMPLETE;

            return FAILURE;
        }    
        decoded_buf->presence_bitmask |= UMTS_SIB_TYPE_18_INFO_DECODE_COMPLETE;
    }

    if (UMTS_SB_BLOCK_1_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = convert_scheduling_block1(&(decoded_buf->umts_scheduling_block_1_info));
        free(g_umts_ctxt.bch_info[UMTS_SB_BLOCK_1_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SB_BLOCK_1_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_scheduling_block1 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SB_BLOCK_1_INFO_COMPLETE;

            return FAILURE;
        }
        decoded_buf->presence_bitmask |= UMTS_SB_BLOCK_1_INFO_DECODE_COMPLETE;
    }

    if (UMTS_SB_BLOCK_2_INFO_COMPLETE & g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        ret_val = convert_scheduling_block2(&(decoded_buf->umts_scheduling_block_2_info));
        free(g_umts_ctxt.bch_info[UMTS_SB_BLOCK_2_INFO].p_start_bch_data); 
        memset(&g_umts_ctxt.bch_info[UMTS_SB_BLOCK_2_INFO], 0, sizeof(umts_bch_info_t));
        if (FAILURE == ret_val)
        {
            printf("decode_system_info_msg:umts_convert_scheduling_block2 failed\n");
            g_umts_ctxt.complete_si_msg_filled_bitmask ^= UMTS_SB_BLOCK_2_INFO_COMPLETE;

            return FAILURE;
        }   
        decoded_buf->presence_bitmask |= UMTS_SB_BLOCK_2_INFO_DECODE_COMPLETE;
    }
    ret_val = SUCCESS;
    g_umts_ctxt.complete_si_msg_filled_bitmask = 0x00;    

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: umts_sib_decoder_set_gb_ctxt_bitmask
 *
 *   DESCRIPTION:This function sets the bitmask for the global context.
 *
 *   RETURNS: NONE
 *
 *******************************************************************************/
void umts_sib_decoder_set_gb_ctxt_bitmask
(
 umts_sib_type_et umts_sib_type
 )
{
    switch (umts_sib_type)
    {
        case UMTS_MIB_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_MIB_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_1_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_1_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_2_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_2_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_3_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_3_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_5_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_5_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_7_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_7_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_11_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_11_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_11_bis_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_11_BIS_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_12_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_12_INFO_COMPLETE;        
            break;

        case UMTS_SIB_TYPE_18_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SIB_TYPE_18_INFO_COMPLETE;        
            break;

        case UMTS_SB_BLOCK_1_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SB_BLOCK_1_INFO_COMPLETE;        
            break;

        case UMTS_SB_BLOCK_2_INFO:
            g_umts_ctxt.complete_si_msg_filled_bitmask |= UMTS_SB_BLOCK_2_INFO_COMPLETE;        
            break;

        default:
            printf("umts_sib_decoder_set_gb_ctxt_bitmask:no such option available\n");
            break;
    }

    return;
}                        

/******************************************************************************
 *   FUNCTION NAME: get_sib_type
 *
 *   DESCRIPTION:
 *       This function returns SIB type 
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
umts_sib_type_et get_sib_type
(
 UMTS_SIB_Type          sib_type
 )
{
    umts_sib_type_et umts_sib_type  = INVALID_SIB_TYPE;

    switch(sib_type)
    {
        case masterInformationBlock:
            umts_sib_type = UMTS_MIB_INFO;
            break;

        case systemInformationBlockType1:
            umts_sib_type = UMTS_SIB_TYPE_1_INFO; 
            break;

        case systemInformationBlockType2:
            umts_sib_type = UMTS_SIB_TYPE_2_INFO;
            break;

        case systemInformationBlockType3:
            umts_sib_type = UMTS_SIB_TYPE_3_INFO;
            break;

        case systemInformationBlockType5:
            umts_sib_type = UMTS_SIB_TYPE_5_INFO;
            break;

        case systemInformationBlockType7:
            umts_sib_type = UMTS_SIB_TYPE_7_INFO;
            break;

        case systemInformationBlockType11:
            umts_sib_type = UMTS_SIB_TYPE_11_INFO;
            break;

        case extensionType:
            umts_sib_type = UMTS_SIB_TYPE_11_bis_INFO;
            break;

        case systemInformationBlockType12:
            umts_sib_type = UMTS_SIB_TYPE_12_INFO;
            break;

        case systemInformationBlockType18:
            umts_sib_type = UMTS_SIB_TYPE_18_INFO;
            break;

        case schedulingBlock1:
            umts_sib_type = UMTS_SB_BLOCK_1_INFO;
            break;

        case schedulingBlock2:
            umts_sib_type = UMTS_SB_BLOCK_2_INFO;
            break;

        default:
            printf("get_sib_type:No such option available \n");
            break;
    }

    return umts_sib_type;
}


/******************************************************************************
 *   FUNCTION NAME: check_decode_first_segment
 *
 *   DESCRIPTION: This code decodes the first segment.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_first_segment
(
 UMTS_FirstSegment      *p_first_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read = 0,loop_count = 0;

    umts_sib_type = get_sib_type(p_first_segment->sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type)
    {    
        g_umts_ctxt.bch_info[umts_sib_type].segment_count = p_first_segment->seg_Count;
        g_umts_ctxt.bch_info[umts_sib_type].segment_remaining = (p_first_segment->seg_Count - 1);
        g_umts_ctxt.bch_info[umts_sib_type].p_bch_data = 
            (void *)malloc(g_umts_ctxt.bch_info[umts_sib_type].segment_count * FIRST_SEGMENT_DATA_BYTES);

        memset(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data, 0, 
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count * FIRST_SEGMENT_DATA_BYTES));           

        /* Assigning the starting address of the segment allocated*/
        g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data;

        if (0 == ((p_first_segment->sib_Data_fixed).numbits) % OCTET_SIZE)
        {
            bytes_to_read = (((p_first_segment->sib_Data_fixed).numbits) / OCTET_SIZE);
        }
        else
        {
            bytes_to_read = (((p_first_segment->sib_Data_fixed).numbits)/OCTET_SIZE) + 1;
        }    
        /* Copying the byte date from BCH Segment data to global context*/
        for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
        {
            *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) = (p_first_segment->sib_Data_fixed).data[loop_count];
        }    
        g_umts_ctxt.bch_info[umts_sib_type].p_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count;
        ret_val = SUCCESS;
    }
    else
    {
        printf("check_decode_first_segment:Invalid sib type\n");
        ret_val = FAILURE;
    }    

    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: check_decode_subsequent_segment
 *
 *   DESCRIPTION: This function decodes the subsequent segments.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_subsequent_segment
(
 UMTS_SubsequentSegment      *p_subsequent_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0;

    umts_sib_type = get_sib_type(p_subsequent_segment->sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {    
        if (p_subsequent_segment->segmentIndex == 
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count - 
                 g_umts_ctxt.bch_info[umts_sib_type].segment_remaining))
        {
            g_umts_ctxt.bch_info[umts_sib_type].segment_remaining--;

            if (0 == ((p_subsequent_segment->sib_Data_fixed).numbits) % OCTET_SIZE)
            {
                bytes_to_read = (((p_subsequent_segment->sib_Data_fixed).numbits) / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = (((p_subsequent_segment->sib_Data_fixed).numbits)/OCTET_SIZE) + 1;
            }     
            for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) = 
                    (p_subsequent_segment->sib_Data_fixed).data[loop_count];
            }    
            g_umts_ctxt.bch_info[umts_sib_type].p_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count;
            ret_val = SUCCESS;
        }
        else
        {
            free (g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data);
            memset(&g_umts_ctxt.bch_info[umts_sib_type], 0, sizeof(umts_bch_info_t));
        }    
    }    
    else
    {
        printf("check_decode_subsequent_segment:Invalid sib type\n");

        ret_val = FAILURE;
    }    
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: check_decode_last_segment_short
 *
 *   DESCRIPTION:This function decodes the last segment short.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_last_segment_short
(
 UMTS_LastSegmentShort  *p_last_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0;

    umts_sib_type = get_sib_type(p_last_segment->sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {
        if (p_last_segment->segmentIndex ==
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count -
                 g_umts_ctxt.bch_info[umts_sib_type].segment_remaining))
        {
            g_umts_ctxt.bch_info[umts_sib_type].segment_remaining--;

            if (0 == ((p_last_segment->sib_Data_variable).numbits) % OCTET_SIZE)
            {
                bytes_to_read = ((p_last_segment->sib_Data_variable).numbits / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = (((p_last_segment->sib_Data_variable).numbits)/OCTET_SIZE) + 1;
            }
            for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) =
                    (p_last_segment->sib_Data_variable).data[loop_count];
            }
            if (0 == g_umts_ctxt.bch_info[umts_sib_type].segment_remaining)
            {
                umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
                ret_val = SUCCESS;
            }
        }
        else
        {
            free (g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data);
            memset(&g_umts_ctxt.bch_info[umts_sib_type], 0, sizeof(umts_bch_info_t));
        }
    }
    else
    {
        printf("check_decode_last_segment_short:Invalid sib type\n");

        ret_val = FAILURE;
    }
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: check_decode_last_and_first
 *
 *   DESCRIPTION :This function decodes the last and first segment.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_last_and_first
(
 UMTS_SystemInformation_BCH_payload_lastAndFirst  *p_last_and_first_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0;

    umts_sib_type = get_sib_type((p_last_and_first_segment->lastSegmentShort).sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {    
        if ((p_last_and_first_segment->lastSegmentShort).segmentIndex == 
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count - 
                 g_umts_ctxt.bch_info[umts_sib_type].segment_remaining))
        {
            g_umts_ctxt.bch_info[umts_sib_type].segment_remaining--;

            if (0 == (((p_last_and_first_segment->lastSegmentShort).sib_Data_variable).numbits) % OCTET_SIZE)
            {
                bytes_to_read = (((p_last_and_first_segment->lastSegmentShort).sib_Data_variable).numbits / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = ((((p_last_and_first_segment->lastSegmentShort).sib_Data_variable).numbits)/OCTET_SIZE) + 1;
            }     
            for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) = 
                    ((p_last_and_first_segment->lastSegmentShort).sib_Data_variable).data[loop_count];
            }   
            if (0 == g_umts_ctxt.bch_info[umts_sib_type].segment_remaining)
            {
                umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
            }    
        }
        else
        {
            free (g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data);
            memset(&g_umts_ctxt.bch_info[umts_sib_type], 0, sizeof(umts_bch_info_t));
            return FAILURE;
        }    
    }    
    else
    {
        printf("check_decode_last_and_first:Invalid sib type\n");

        return FAILURE;
    }    

    ret_val = FAILURE;
    umts_sib_type = INVALID_SIB_TYPE;
    bytes_to_read = 0;
    loop_count = 0;

    umts_sib_type = get_sib_type((p_last_and_first_segment->firstSegment).sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {
        g_umts_ctxt.bch_info[umts_sib_type].segment_count = (p_last_and_first_segment->firstSegment).seg_Count;
        g_umts_ctxt.bch_info[umts_sib_type].segment_remaining = ((p_last_and_first_segment->firstSegment).seg_Count - 1);
        g_umts_ctxt.bch_info[umts_sib_type].p_bch_data =
            (void *)malloc(g_umts_ctxt.bch_info[umts_sib_type].segment_count * FIRST_SEGMENT_DATA_BYTES);

        if (!g_umts_ctxt.bch_info[umts_sib_type].p_bch_data)
        {
            printf("check_decode_last_and_first: Memory Allocation Failure\n");
            return FAILURE;    
        }    
        memset(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data, 0,
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count * FIRST_SEGMENT_DATA_BYTES));    

        g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data;

        if (0 == ((p_last_and_first_segment->firstSegment).sib_Data_variable.numbits) % OCTET_SIZE)
        {
            bytes_to_read = (((p_last_and_first_segment->firstSegment).sib_Data_variable.numbits) / OCTET_SIZE);
        }
        else
        {
            bytes_to_read = (((p_last_and_first_segment->firstSegment).sib_Data_variable.numbits)/OCTET_SIZE) + 1;
        }
        for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
        {
            *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) = 
                (p_last_and_first_segment->firstSegment).sib_Data_variable.data[loop_count];
        }
        g_umts_ctxt.bch_info[umts_sib_type].p_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count;
        ret_val = SUCCESS;    
    }    
    else
    {
        printf("check_decode_last_and_first:Invalid sib type\n");

        return FAILURE;
    }    

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: convert_completesib_info_list
 *
 *   DESCRIPTION:This function converts UMTS_CompleteSIB_List to
 *                   umts_completesib_info_list_t.
 *
 *
 *   RETURNS: NONE
 *
 *******************************************************************************/
void convert_completesib_info_list
(
 UMTS_CompleteSIB_List        *p_complete_list,
 umts_completesib_info_list_t *p_completesib_info_list
 )
{
    UMTS_CompleteSIBshort       *pdata;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    memset (p_completesib_info_list, 0, sizeof(umts_completesib_info_list_t));

    pnode = p_complete_list->head;
    p_completesib_info_list->count = p_complete_list->count;

    for ( index = 0; index < p_completesib_info_list->count; index++ )
    {
        pdata = (UMTS_CompleteSIBshort *)pnode->data;

        p_completesib_info_list->umts_completesib_info[index].sib_type = pdata->sib_Type;
        memcpy(&(p_completesib_info_list->umts_completesib_info[index].umts_sib_data_variable), 
                &(pdata->sib_Data_variable),
                sizeof(umts_sib_data_variable_t));

        pnode = pnode->next;
    }

    return;
}    


/******************************************************************************
 *   FUNCTION NAME: check_decode_last_and_complete
 *
 *   DESCRIPTION:This function decodes the last and complete segment.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_last_and_complete
(
 UMTS_SystemInformation_BCH_payload_lastAndComplete  *p_last_and_complete_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_completesib_info_list_t *p_completesib_info_list = ((void *)0); 
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0,
       loop_count_1 =                   0;

    umts_sib_type = get_sib_type((p_last_and_complete_segment->lastSegmentShort).sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {    
        if ((p_last_and_complete_segment->lastSegmentShort).segmentIndex == 
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count - 
                 g_umts_ctxt.bch_info[umts_sib_type].segment_remaining))
        {
            g_umts_ctxt.bch_info[umts_sib_type].segment_remaining--;

            if (0 == ((p_last_and_complete_segment->lastSegmentShort.sib_Data_variable).numbits) % OCTET_SIZE)
            {
                bytes_to_read = ((p_last_and_complete_segment->lastSegmentShort.sib_Data_variable).numbits / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = (((p_last_and_complete_segment->lastSegmentShort.sib_Data_variable).numbits)/OCTET_SIZE) + 1;
            }     
            for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) = 
                    (p_last_and_complete_segment->lastSegmentShort.sib_Data_variable).data[loop_count];
            }   
            if (0 == g_umts_ctxt.bch_info[umts_sib_type].segment_remaining)
            {
                umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
            }    
        }
        else
        {
            free (g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data);
            memset(&g_umts_ctxt.bch_info[umts_sib_type], 0, sizeof(umts_bch_info_t));
            return FAILURE;
        }    
    }    
    else
    {
        printf("check_decode_last_and_complete:Invalid sib type\n");
        return FAILURE;
    }    

    p_completesib_info_list = (umts_completesib_info_list_t *)malloc(sizeof (umts_completesib_info_list_t));
    ret_val = FAILURE;
    umts_sib_type = INVALID_SIB_TYPE;
    bytes_to_read = 0;
    loop_count = 0;

    if (!p_completesib_info_list)
        return FAILURE;

    convert_completesib_info_list(&(p_last_and_complete_segment->completeSIB_List), p_completesib_info_list);

    for (loop_count = 0; p_completesib_info_list->count > loop_count; loop_count++)
    {    
        umts_sib_type = get_sib_type(p_completesib_info_list->umts_completesib_info[loop_count].sib_type);
        if (INVALID_SIB_TYPE != umts_sib_type )
        {
            g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data = (void *)malloc(FIRST_SEGMENT_DATA_BYTES);

            if (!g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data)
            {
                printf("check_decode_last_and_complete: Memory Allocation Failure\n");
                free(p_completesib_info_list); 
                return FAILURE;   
            }     
            memset(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data, 0, FIRST_SEGMENT_DATA_BYTES);    

            if (0 == ((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits) % OCTET_SIZE)
            {
                bytes_to_read = (((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits) / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = (((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits)/OCTET_SIZE) + 1;
            }
            for (loop_count_1 = 0; bytes_to_read > loop_count_1; loop_count_1++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data + loop_count_1) = 
                    ((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.data[loop_count_1]);
            }
            umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
            ret_val = SUCCESS;
        }    
        else
        {
            printf("check_decode_last_and_complete:Invalid sib type\n");
            free(p_completesib_info_list); 
            return FAILURE;
        }    
    }    
    free(p_completesib_info_list); 
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: check_decode_last_and_complete_and_first
 *
 *   DESCRIPTION:This function decodes last,complete and first segment.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_last_and_complete_and_first
(
 UMTS_SystemInformation_BCH_payload_lastAndCompleteAndFirst  *p_last_complete_first_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_completesib_info_list_t *p_completesib_info_list = ((void *)0);
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0,
       loop_count_1 =                   0;

    umts_sib_type = get_sib_type((p_last_complete_first_segment->lastSegmentShort).sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {    
        if ((p_last_complete_first_segment->lastSegmentShort).segmentIndex == 
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count - 
                 g_umts_ctxt.bch_info[umts_sib_type].segment_remaining))
        {
            g_umts_ctxt.bch_info[umts_sib_type].segment_remaining--;

            if (0 == (((p_last_complete_first_segment->lastSegmentShort).sib_Data_variable).numbits) % OCTET_SIZE)
            {
                bytes_to_read = (((p_last_complete_first_segment->lastSegmentShort).sib_Data_variable).numbits / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = ((((p_last_complete_first_segment->lastSegmentShort).sib_Data_variable).numbits)/OCTET_SIZE) + 1;
            }     
            for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) = 
                    (p_last_complete_first_segment->lastSegmentShort).sib_Data_variable.data[loop_count];
            }   
            if (0 == g_umts_ctxt.bch_info[umts_sib_type].segment_remaining)
            {
                umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
            }    
        }
        else
        {
            free (g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data);
            memset(&g_umts_ctxt.bch_info[umts_sib_type], 0, sizeof(umts_bch_info_t));
            return FAILURE;
        }    
    }    
    else
    {
        printf("check_decode_last_and_complete_and_first:Invalid sib type\n");

        return FAILURE;
    }    

    p_completesib_info_list = (umts_completesib_info_list_t *)malloc(sizeof (umts_completesib_info_list_t));
    ret_val = FAILURE;
    umts_sib_type = INVALID_SIB_TYPE;
    bytes_to_read = 0;
    loop_count = 0;

    if (!p_completesib_info_list)
        return FAILURE;

    convert_completesib_info_list(&(p_last_complete_first_segment->completeSIB_List), p_completesib_info_list);

    for (loop_count = 0; p_completesib_info_list->count > loop_count; loop_count++)
    {    
        umts_sib_type = get_sib_type(p_completesib_info_list->umts_completesib_info[loop_count].sib_type);
        if (INVALID_SIB_TYPE != umts_sib_type )
        {
            g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data = (void *)malloc(FIRST_SEGMENT_DATA_BYTES);

            if (!g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data)
            {
                printf("check_decode_last_and_complete_and_first: Memory Allocation Failure\n");
                free(p_completesib_info_list); 
                return FAILURE;   
            }     
            memset(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data, 0, FIRST_SEGMENT_DATA_BYTES);    

            if (0 == ((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits) % OCTET_SIZE)
            {
                bytes_to_read = (((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits) / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = (((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits)/OCTET_SIZE) + 1;
            }
            for (loop_count_1 = 0; bytes_to_read > loop_count_1; loop_count_1++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data + loop_count_1) = 
                    ((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.data[loop_count_1]);
            }
            umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
        }    
        else
        {
            printf("check_decode_last_and_complete_and_first:Invalid sib type\n");
            free(p_completesib_info_list); 
            return FAILURE;
        }   
    }   

    free(p_completesib_info_list); 
    ret_val = FAILURE;
    umts_sib_type = INVALID_SIB_TYPE;
    bytes_to_read = 0;
    loop_count = 0;

    umts_sib_type = get_sib_type((p_last_complete_first_segment->firstSegment).sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {
        g_umts_ctxt.bch_info[umts_sib_type].segment_count = (p_last_complete_first_segment->firstSegment).seg_Count;
        g_umts_ctxt.bch_info[umts_sib_type].segment_remaining = ((p_last_complete_first_segment->firstSegment).seg_Count - 1);
        g_umts_ctxt.bch_info[umts_sib_type].p_bch_data =
            (void *)malloc(g_umts_ctxt.bch_info[umts_sib_type].segment_count * FIRST_SEGMENT_DATA_BYTES);

        if (!g_umts_ctxt.bch_info[umts_sib_type].p_bch_data)
        {
            printf("check_decode_last_and_complete_and_first: Memory Allocation Failure\n");
            return FAILURE;   
        }     
        memset(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data, 0,
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count * FIRST_SEGMENT_DATA_BYTES));    

        g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data;

        if (0 == ((p_last_complete_first_segment->firstSegment).sib_Data_variable.numbits) % OCTET_SIZE)
        {
            bytes_to_read = (((p_last_complete_first_segment->firstSegment).sib_Data_variable.numbits) / OCTET_SIZE);
        }
        else
        {
            bytes_to_read = (((p_last_complete_first_segment->firstSegment).sib_Data_variable.numbits)/OCTET_SIZE) + 1;
        }
        for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
        {
            *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) = 
                (p_last_complete_first_segment->firstSegment).sib_Data_variable.data[loop_count];
        }
        g_umts_ctxt.bch_info[umts_sib_type].p_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count;
        ret_val = SUCCESS;
    }    
    else
    {
        printf("check_decode_last_and_complete_and_first:Invalid sib type\n");
        return FAILURE;
    }    
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: check_decode_completeSIB_list
 *
 *   DESCRIPTION:This function decodes Complete Sib list.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_completeSIB_list
(
 UMTS_CompleteSIB_List  *p_complete_segment_list
 )
{
    return_code ret_val =               FAILURE;
    umts_completesib_info_list_t *p_completesib_info_list = ((void *)0);
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0,
       loop_count_1 =                   0;

    p_completesib_info_list = (umts_completesib_info_list_t *)malloc(sizeof (umts_completesib_info_list_t));

    if (!p_completesib_info_list)
        return FAILURE;

    convert_completesib_info_list(p_complete_segment_list, p_completesib_info_list);

    for (loop_count = 0; p_completesib_info_list->count > loop_count; loop_count++)
    {    
        umts_sib_type = get_sib_type(p_completesib_info_list->umts_completesib_info[loop_count].sib_type);
        if (INVALID_SIB_TYPE != umts_sib_type )
        {
            g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data = (void *)malloc(FIRST_SEGMENT_DATA_BYTES);

            if (!g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data)
            {
                printf("check_decode_completeSIB_list: Memory Allocation Failure\n");
                free(p_completesib_info_list); 
                return FAILURE;   
            }     
            memset(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data, 0, FIRST_SEGMENT_DATA_BYTES);    

            if (0 == ((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits) % OCTET_SIZE)
            {
                bytes_to_read = (((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits) / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = (((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits)/OCTET_SIZE) + 1;
            }
            for (loop_count_1 = 0; bytes_to_read > loop_count_1; loop_count_1++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data + loop_count_1) = 
                    ((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.data[loop_count_1]);
            }
            umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
            ret_val = SUCCESS;
        }    
        else
        {
            printf("check_decode_completeSIB_list:Invalid sib type\n");
            ret_val = FAILURE;
        }   
    }  
    free(p_completesib_info_list); 
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: check_decode_complete_and_first
 *
 *   DESCRIPTION:This function decodes complete and first segment. 
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_complete_and_first
(
 UMTS_SystemInformation_BCH_payload_completeAndFirst  *p_complete_and_first_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_completesib_info_list_t *p_completesib_info_list = ((void *)0);
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0,
       loop_count_1 =                     0;

    p_completesib_info_list = (umts_completesib_info_list_t *)malloc(sizeof (umts_completesib_info_list_t));

    if (!p_completesib_info_list)
        return FAILURE;

    convert_completesib_info_list(&(p_complete_and_first_segment->completeSIB_List), p_completesib_info_list);

    for (loop_count = 0; p_completesib_info_list->count > loop_count; loop_count++)
    {    
        umts_sib_type = get_sib_type(p_completesib_info_list->umts_completesib_info[loop_count].sib_type);
        if (INVALID_SIB_TYPE != umts_sib_type )
        {
            g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data = (void *)malloc(FIRST_SEGMENT_DATA_BYTES);

            if (!g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data)
            {
                printf("check_decode_complete_and_first: Memory Allocation Failure\n");
                free(p_completesib_info_list); 
                return FAILURE;   
            }     
            memset(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data, 0, FIRST_SEGMENT_DATA_BYTES);    

            if (0 == ((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits) % OCTET_SIZE)
            {
                bytes_to_read = (((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits) / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = (((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.numbits)/OCTET_SIZE) + 1;
            }
            for (loop_count_1 = 0; bytes_to_read > loop_count_1; loop_count_1++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data + loop_count_1) = 
                    ((p_completesib_info_list->umts_completesib_info[loop_count]).umts_sib_data_variable.data[loop_count_1]);
            }
            umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
        }    
        else
        {
            printf("check_decode_complete_and_first:Invalid sib type\n");
            free(p_completesib_info_list); 
            return FAILURE;
        }   
    }   

    free(p_completesib_info_list); 
    ret_val = FAILURE;
    umts_sib_type = INVALID_SIB_TYPE;
    bytes_to_read = 0;
    loop_count = 0;

    umts_sib_type = get_sib_type((p_complete_and_first_segment->firstSegment).sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {
        g_umts_ctxt.bch_info[umts_sib_type].segment_count = (p_complete_and_first_segment->firstSegment).seg_Count;
        g_umts_ctxt.bch_info[umts_sib_type].segment_remaining = ((p_complete_and_first_segment->firstSegment).seg_Count - 1);
        g_umts_ctxt.bch_info[umts_sib_type].p_bch_data =
            (void *)malloc(g_umts_ctxt.bch_info[umts_sib_type].segment_count * FIRST_SEGMENT_DATA_BYTES);

        if (!g_umts_ctxt.bch_info[umts_sib_type].p_bch_data)
        {
            printf("check_decode_complete_and_first: Memory Allocation Failure\n");
            return FAILURE;   
        }     
        memset(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data, 0,
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count * FIRST_SEGMENT_DATA_BYTES));    

        g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data;

        if (0 == ((p_complete_and_first_segment->firstSegment).sib_Data_variable.numbits) % OCTET_SIZE)
        {
            bytes_to_read = (((p_complete_and_first_segment->firstSegment).sib_Data_variable.numbits) / OCTET_SIZE);
        }
        else
        {
            bytes_to_read = (((p_complete_and_first_segment->firstSegment).sib_Data_variable.numbits)/OCTET_SIZE) + 1;
        }
        for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
        {
            *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) = 
                (p_complete_and_first_segment->firstSegment).sib_Data_variable.data[loop_count];
        }
        g_umts_ctxt.bch_info[umts_sib_type].p_bch_data = g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count;
        ret_val = SUCCESS;
    }    
    else
    {
        printf("check_decode_complete_and_first:Invalid sib type\n");

        return FAILURE;
    }    
    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: check_decode_complete_SIB
 *
 *   DESCRIPTION: This function decodes the complete SIB.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_complete_SIB
(
 UMTS_CompleteSIB *p_complete_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0;

    umts_sib_type = get_sib_type(p_complete_segment->sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {
        g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data =(void *)malloc(COMPLETE_SIB_SEGMENT_DATA_BYTES);

        if (!g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data)
        {
            printf("check_decode_complete_SIB: Memory Allocation Failure\n");
            return FAILURE;   
        }     
        memset(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data, 0, FIRST_SEGMENT_DATA_BYTES);    

        if (0 == ((p_complete_segment->sib_Data_fixed).numbits) % OCTET_SIZE)
        {
            bytes_to_read = (((p_complete_segment->sib_Data_fixed).numbits) / OCTET_SIZE);
        }
        else
        {
            bytes_to_read = (((p_complete_segment->sib_Data_fixed).numbits)/OCTET_SIZE) + 1;
        }
        for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
        {
            *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data + loop_count) = 
                (p_complete_segment->sib_Data_fixed).data[loop_count];
        }
        umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
        ret_val = SUCCESS;
    }    
    else
    {
        printf("check_decode_complete_SIB:invalid sib type\n");
        return FAILURE;
    }    
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: check_decode_last_segment
 *
 *   DESCRIPTION :this function decodes the last segment.
 *
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code check_decode_last_segment
(
 UMTS_LastSegment  *p_last_segment
 )
{
    return_code ret_val =               FAILURE;
    umts_sib_type_et umts_sib_type =    INVALID_SIB_TYPE;
    U8 bytes_to_read =                  0,
       loop_count =                     0;

    umts_sib_type = get_sib_type(p_last_segment->sib_Type);
    if (INVALID_SIB_TYPE != umts_sib_type )
    {
        if (p_last_segment->segmentIndex ==
                (g_umts_ctxt.bch_info[umts_sib_type].segment_count -
                 g_umts_ctxt.bch_info[umts_sib_type].segment_remaining))
        {
            g_umts_ctxt.bch_info[umts_sib_type].segment_remaining--;

            if (0 == ((p_last_segment->sib_Data_fixed).numbits) % OCTET_SIZE)
            {
                bytes_to_read = ((p_last_segment->sib_Data_fixed).numbits / OCTET_SIZE);
            }
            else
            {
                bytes_to_read = (((p_last_segment->sib_Data_fixed).numbits)/OCTET_SIZE) + 1;
            }
            for (loop_count = 0; bytes_to_read > loop_count; loop_count++)
            {
                *(U8 *)(g_umts_ctxt.bch_info[umts_sib_type].p_bch_data + loop_count) =
                    (p_last_segment->sib_Data_fixed).data[loop_count];
            }
            if (0 == g_umts_ctxt.bch_info[umts_sib_type].segment_remaining)
            {
                umts_sib_decoder_set_gb_ctxt_bitmask(umts_sib_type);
                ret_val = SUCCESS;
            }
        }
        else
        {
            free (g_umts_ctxt.bch_info[umts_sib_type].p_start_bch_data);
            memset(&g_umts_ctxt.bch_info[umts_sib_type], 0, sizeof(umts_bch_info_t));
        }
    }
    else
    {
        printf("check_decode_last_segment:Invalid sib type\n");
        ret_val = FAILURE;
    }
    return ret_val;
}



/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib1
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType1 to
 *       umts_sib_type_1_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       umts_sib1              - Pointer to decoded SIB1
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib1
(
 umts_sib_type_1_info_t     *umts_sib1
 )
{
    UMTS_SysInfoType1 sys_info_type_1;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_1_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_1, 0, sizeof(UMTS_SysInfoType1));

    if ( 0 != (asn1PD_UMTS_SysInfoType1(&ctxt, &sys_info_type_1)))
    {
        printf("umts_convert_sib1:asn decoding failed\n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType1("Decoded SysInfoType1\n", &sys_info_type_1);
    memset( umts_sib1, 0, sizeof(umts_sib_type_1_info_t));

    convert_nas_system_gsm_map_info(
            &sys_info_type_1.cn_CommonGSM_MAP_NAS_SysInfo,
            &umts_sib1->nas_system_gsm_map_info);

    convert_cn_domain_sysinfo_list(
            &(sys_info_type_1.cn_DomainSysInfoList),
            &(umts_sib1->cn_domainsys_info_list));

    if (sys_info_type_1.m.ue_ConnTimersAndConstantsPresent == 1)
    {
        umts_sib1->presence_bitmask |= UMTS_SIB_TYPE_1_CONN_TIMERS_AND_CONST_PRESENCE_FLAG;

        umts_sib1->ue_conn_timers_consts.t_301 = sys_info_type_1.ue_ConnTimersAndConstants.t_301;
        umts_sib1->ue_conn_timers_consts.n_301 = sys_info_type_1.ue_ConnTimersAndConstants.n_301;
        umts_sib1->ue_conn_timers_consts.t_302 = sys_info_type_1.ue_ConnTimersAndConstants.t_302;
        umts_sib1->ue_conn_timers_consts.n_302 = sys_info_type_1.ue_ConnTimersAndConstants.n_302;
        umts_sib1->ue_conn_timers_consts.t_304 = sys_info_type_1.ue_ConnTimersAndConstants.t_304;
        umts_sib1->ue_conn_timers_consts.n_304 = sys_info_type_1.ue_ConnTimersAndConstants.n_304;
        umts_sib1->ue_conn_timers_consts.t_305 = sys_info_type_1.ue_ConnTimersAndConstants.t_305;
        umts_sib1->ue_conn_timers_consts.t_307 = sys_info_type_1.ue_ConnTimersAndConstants.t_307;
        umts_sib1->ue_conn_timers_consts.t_308 = sys_info_type_1.ue_ConnTimersAndConstants.t_308;
        umts_sib1->ue_conn_timers_consts.t_309 = sys_info_type_1.ue_ConnTimersAndConstants.t_309;
        umts_sib1->ue_conn_timers_consts.t_310 = sys_info_type_1.ue_ConnTimersAndConstants.t_310;
        umts_sib1->ue_conn_timers_consts.n_310 = sys_info_type_1.ue_ConnTimersAndConstants.n_310;
        umts_sib1->ue_conn_timers_consts.t_311 = sys_info_type_1.ue_ConnTimersAndConstants.t_311;
        umts_sib1->ue_conn_timers_consts.t_312 = sys_info_type_1.ue_ConnTimersAndConstants.t_312;
        umts_sib1->ue_conn_timers_consts.n_312 = sys_info_type_1.ue_ConnTimersAndConstants.n_312;
        umts_sib1->ue_conn_timers_consts.t_313 = sys_info_type_1.ue_ConnTimersAndConstants.t_313;
        umts_sib1->ue_conn_timers_consts.n_313 = sys_info_type_1.ue_ConnTimersAndConstants.n_313;
        umts_sib1->ue_conn_timers_consts.t_314 = sys_info_type_1.ue_ConnTimersAndConstants.t_314;
        umts_sib1->ue_conn_timers_consts.t_315 = sys_info_type_1.ue_ConnTimersAndConstants.t_315;
        umts_sib1->ue_conn_timers_consts.n_315 = sys_info_type_1.ue_ConnTimersAndConstants.n_315;
        umts_sib1->ue_conn_timers_consts.t_316 = sys_info_type_1.ue_ConnTimersAndConstants.t_316;
        umts_sib1->ue_conn_timers_consts.t_317 = sys_info_type_1.ue_ConnTimersAndConstants.t_317;
    }

    if (sys_info_type_1.m.ue_IdleTimersAndConstantsPresent== 1)
    {
        umts_sib1->presence_bitmask |= UMTS_SIB_TYPE_1_IDLE_TIMERS_AND_CONST_PRESENCE_FLAG;

        umts_sib1->ue_idle_timers_consts.t_300 = sys_info_type_1.ue_IdleTimersAndConstants.t_300;
        umts_sib1->ue_idle_timers_consts.n_300 = sys_info_type_1.ue_IdleTimersAndConstants.n_300;
        umts_sib1->ue_idle_timers_consts.t_312 = sys_info_type_1.ue_IdleTimersAndConstants.t_312;
        umts_sib1->ue_idle_timers_consts.n_312 = sys_info_type_1.ue_IdleTimersAndConstants.n_312;
    }

    if (sys_info_type_1.m.v3a0NonCriticalExtensionsPresent == 1)
    {
        umts_sib1->presence_bitmask |= UMTS_SIB_TYPE_1_SYSINFOTYPE1_V3A0_NCE_PRESENCE_FLAG;

        fill_sysinfotype1_v3a0_nce(&(sys_info_type_1.v3a0NonCriticalExtensions),
                &(umts_sib1->sysinfotype1_v3a0_nce));
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype2_non_critical_extensions
 *
 *   DESCRIPTION:
 *   This function converts 
 *   UMTS_SysInfoType2_nonCriticalExtensions to
 *   sysinfotype2_non_critical_extensions_t
 *
 *******************************************************************************/
void convert_sysinfotype2_non_critical_extensions
(
 UMTS_SysInfoType2_nonCriticalExtensions    *pvalue,
 sysinfotype2_non_critical_extensions_t     *p_nce 
 )
{
    p_nce->__dummy__ = pvalue->__dummy__;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib2
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType2 to
 *       umts_sib_type_2_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       umts_sib_type_2_info   - Pointer to decoded SIB2
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib2
(
 umts_sib_type_2_info_t     *umts_sib_type_2_info
 )
{
    UMTS_SysInfoType2   sys_info_type_2;
    OSCTXT  ctxt;
    U32                 cnt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_2_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_2, 0, sizeof(UMTS_SysInfoType2));

    if ( 0 != (asn1PD_UMTS_SysInfoType2( &ctxt, &sys_info_type_2)))
    {
        printf("umts_convert_sib2:asn decoding failed\n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType2("Decoded SysInfoType2\n", &sys_info_type_2);
    memset( umts_sib_type_2_info, 0, sizeof(umts_sib_type_2_info_t));

    umts_sib_type_2_info->ura_identity_list.count = 
        sys_info_type_2.ura_IdentityList.n;

    memcpy(umts_sib_type_2_info->ura_identity_list.identity_node,
            sys_info_type_2.ura_IdentityList.elem,
            (sizeof(identity_node_t) * 8));

    for (cnt = 0; cnt < sys_info_type_2.ura_IdentityList.n; cnt++ )
    {
        umts_sib_type_2_info->ura_identity_list.identity_node[cnt].numbits =
            sys_info_type_2.ura_IdentityList.elem[cnt].numbits;

        memcpy(umts_sib_type_2_info->ura_identity_list.identity_node[cnt].ura_identity,
                sys_info_type_2.ura_IdentityList.elem[cnt].data,
                (sizeof(U8) * umts_sib_type_2_info->ura_identity_list.identity_node[cnt].numbits));
    }

    if (sys_info_type_2.m.nonCriticalExtensionsPresent)
    {
        umts_sib_type_2_info->presence_bitmask |=
            UMTS_SIB_UMTS_SIB_TYPE_2_INFO_NON_CRITICAL_EXTENSIONS_PRESENCE_FLAG;

        convert_sysinfotype2_non_critical_extensions(
                &sys_info_type_2.nonCriticalExtensions,
                &umts_sib_type_2_info->non_critical_extensions);
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dynamic_persistencelevel_list
 *
 *   DESCRIPTION:
 *      This function converts UMTS_DynamicPersistenceLevelList to
 *      dynamic_persistencelevel_list_t  and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_dynamic_persistencelevel_list
(
 UMTS_DynamicPersistenceLevelList   *p_asn_list,
 dynamic_persistencelevel_list_t    *p_dynamic_persistencelevel_list
 )
{
    p_dynamic_persistencelevel_list->count = p_asn_list->n;

    memcpy(p_dynamic_persistencelevel_list->dynamic_persistencelevel,
            p_asn_list->elem, (p_asn_list->n * sizeof(U8)));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype7_modespecificinfo_fdd
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType7_modeSpecificInfo_fdd  to
 *      sysinfotype7_modespecificinfo_fdd_t
 *
 *******************************************************************************/
void convert_sysinfotype7_modespecificinfo_fdd
(
 UMTS_SysInfoType7_modeSpecificInfo_fdd     *pvalue,
 sysinfotype7_modespecificinfo_fdd_t        *p_fdd 
 )
{
    memcpy(&p_fdd->ul_Interference,
            &pvalue->ul_Interference,
            sizeof(S8));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype7_modespecificinfo
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SysInfoType7_modeSpecificInfo  to
 *      sysinfotype7_modespecificinfo_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sysinfotype7_modespecificinfo
(
 UMTS_SysInfoType7_modeSpecificInfo *pvalue,
 sysinfotype7_modespecificinfo_t    *p_sysinfotype7_modespecificinfo 
 )
{
    p_sysinfotype7_modespecificinfo-> t = pvalue->t;

    if (pvalue->t == T_UMTS_SysInfoType7_modeSpecificInfo_fdd)
    {
        convert_sysinfotype7_modespecificinfo_fdd(
                pvalue->u.fdd,
                &p_sysinfotype7_modespecificinfo->u.fdd);
    }
    else if (pvalue->t == T_UMTS_SysInfoType7_modeSpecificInfo_tdd)
    {
        /* not used */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib7
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType7 to
 *       umts_sib_type_7_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       umts_sib7 - Pointer to decoded SIB7
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib7
(
 umts_sib_type_7_info_t *umts_sib7
 )
{
    UMTS_SysInfoType7   sys_info_type_7;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_7_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_7, 0, sizeof(UMTS_SysInfoType7));

    if ( 0 != (asn1PD_UMTS_SysInfoType7( &ctxt, &sys_info_type_7)))
    {
        printf("umts_convert_sib7:asn decoding failed");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType7("Decoded SysInfoType7\n", &sys_info_type_7);
    memset(umts_sib7, 0 , sizeof(umts_sib_type_7_info_t));

    convert_sysinfotype7_modespecificinfo(
            &sys_info_type_7.modeSpecificInfo,
            &umts_sib7->sysinfotype7_modespecificinfo);

    convert_dynamic_persistencelevel_list(
            &(sys_info_type_7.prach_Information_SIB5_List),
            &(umts_sib7->prach_information_sib5_list));

    if (sys_info_type_7.m.prach_Information_SIB6_ListPresent == 1)
    {
        umts_sib7->presence_bitmask |= UMTS_SIB_TYPE_7_PRAC_INFO_SIB6_LIST_PRESENCE_FLAG;

        convert_dynamic_persistencelevel_list(
                &(sys_info_type_7.prach_Information_SIB6_List),
                &(umts_sib7->prach_information_sib6_list));
    }

    if (sys_info_type_7.m.expirationTimeFactorPresent == 1)
    {
        umts_sib7->presence_bitmask |= UMTS_SIB_TYPE_7_EXPIRATION_TIME_FACTOR_PRESENCE_FLAG;
        umts_sib7->expirationtime_factor = sys_info_type_7.expirationTimeFactor;
    }

    if (sys_info_type_7.m.nonCriticalExtensionsPresent == 1)
    {
        umts_sib7->presence_bitmask |= UMTS_SIB_TYPE_7_NC_EXTN_PRESENCE_FLAG; 
        umts_sib7->sysinfotype7_nce.__dummy__ = sys_info_type_7.nonCriticalExtensions.__dummy__;
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype18_v860ext
 *
 *   DESCRIPTION:
 *      This function converts  UMTS_SysInfoType18_v860ext to
 *      sysinfotype18_v860ext_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sysinfotype18_v860ext
(
 UMTS_SysInfoType18_v860ext *pvalue,
 sysinfotype18_v860ext_t    *p_sysinfotype18_v860ext 
 )
{
    if (pvalue->m.idleModePLMNIdentitiesPresent)
    {
        p_sysinfotype18_v860ext->presence_bitmask |=
            UMTS_SIB_TYPE_18_V860_NCE_IDLE_MODE_PLMN_IDENTITIES_PRESENCE_FLAG;

        convert_plmn_identities_of_neighbour_cells_v860ext(
                &pvalue->idleModePLMNIdentities,
                &p_sysinfotype18_v860ext->idle_mode_plmn_identities);
    }

    if (pvalue->m.connectedModePLMNIdentitiesPresent)
    {
        p_sysinfotype18_v860ext->presence_bitmask |=
            UMTS_SIB_TYPE_18_V860_NCE_CONN_MODE_PLMN_IDENTITIES_PRESENCE_FLAG;

        convert_plmn_identities_of_neighbour_cells_v860ext(
                &pvalue->connectedModePLMNIdentities,
                &p_sysinfotype18_v860ext->connected_mode_plmn_identities);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype18_v6b0_nce_v860_nce_nce
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType18_v6b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions
 *      to sysinfotype18_v6b0_nce_v860_nce_nce_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sysinfotype18_v6b0_nce_v860_nce_nce
(
 UMTS_SysInfoType18_v6b0NonCriticalExtensions_v860NonCriticalExtensions_nonCriticalExtensions   *pvalue,
 sysinfotype18_v6b0_nce_v860_nce_nce_t  *p_sysinfotype18_v6b0_nce_v860_nce_nce 
 )
{
    p_sysinfotype18_v6b0_nce_v860_nce_nce->dummy = pvalue->__dummy__;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype18_v6b0_nce_v860_nce
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType18_v6b0NonCriticalExtensions_v860NonCriticalExtensions to
 *      sysinfotype18_v6b0_nce_v860_nce_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sysinfotype18_v6b0_nce_v860_nce
(
 UMTS_SysInfoType18_v6b0NonCriticalExtensions_v860NonCriticalExtensions *pvalue,
 sysinfotype18_v6b0_nce_v860_nce_t      *p_sysinfotype18_v6b0_nce_v860_nce
 )
{
    convert_sysinfotype18_v860ext(
            &pvalue->sysInfoType18_v860ext,
            &p_sysinfotype18_v6b0_nce_v860_nce->sysInfoType18_v860ext);

    if (pvalue->m.nonCriticalExtensionsPresent)
    {
        p_sysinfotype18_v6b0_nce_v860_nce->presence_bitmask |=
            UMTS_SIB_TYPE_18_V6B0_NCE_V860_NCE_PRESENCE_FLAG;

        convert_sysinfotype18_v6b0_nce_v860_nce_nce(
                &pvalue->nonCriticalExtensions,
                &p_sysinfotype18_v6b0_nce_v860_nce->nonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype18_v6b0ext
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SysInfoType18_v6b0ext to
 *      sysinfotype18_v6b0ext_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sysinfotype18_v6b0ext
(
 UMTS_SysInfoType18_v6b0ext     *pvalue,
 sysinfotype18_v6b0ext_t        *p_sysinfotype18_v6b0ext 
 )
{
    if (pvalue->m.idleModePLMNIdentitiesSIB11bisPresent)
    {
        p_sysinfotype18_v6b0ext->presence_bitmask |=
            UMTS_SIB_TYPE_18_V6B0_NCE_IDLE_MODE_PLMN_IDS_PRESENCE_FLAG;

        convert_plmn_identities_of_neighbour_cells(
                &pvalue->idleModePLMNIdentitiesSIB11bis,
                &p_sysinfotype18_v6b0ext->idle_mode_plmn_identities);
    }

    if (pvalue->m.connectedModePLMNIdentitiesSIB11bisPresent)
    {
        p_sysinfotype18_v6b0ext->presence_bitmask |=
            UMTS_SIB_TYPE_18_V6B0_NCE_CONN_MODE_PLMN_IDS_PRESENCE_FLAG;

        convert_plmn_identities_of_neighbour_cells(
                &pvalue->connectedModePLMNIdentitiesSIB11bis,
                &p_sysinfotype18_v6b0ext->connected_mode_plmn_identities);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: fill_sysinfotype18_v3a0_nce
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SysInfoType18_v6b0NonCriticalExtensions to
 *      sysinfotype18_v6b0_nce_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
return_code fill_sysinfotype18_v3a0_nce
(
 UMTS_SysInfoType18_v6b0NonCriticalExtensions    *p_v6b0NonCriticalExtensions,
 sysinfotype18_v6b0_nce_t                        *p_sysinfotype18_v6b0_nce
 )
{
    if (p_v6b0NonCriticalExtensions == NULL)
    {
        printf("fill_sysinfotype18_v3a0_nce: null value received for p_v6b0NonCriticalExtensions\n");
        return FAILURE;
    }

    memset(p_sysinfotype18_v6b0_nce, 0, sizeof(sysinfotype18_v6b0_nce_t));

    convert_sysinfotype18_v6b0ext(
            &p_v6b0NonCriticalExtensions->sysInfoType18_v6b0ext,
            &p_sysinfotype18_v6b0_nce->sysinfotype18_v6b0ext); 

    if (p_v6b0NonCriticalExtensions->m.v860NonCriticalExtensionsPresent)
    {
        p_sysinfotype18_v6b0_nce->presence_bitmask |=
            UMTS_SIB_TYPE_18_V6B0_V860_NCE_PRESENCE_FLAG;

        convert_sysinfotype18_v6b0_nce_v860_nce(
                &p_v6b0NonCriticalExtensions->v860NonCriticalExtensions,
                &p_sysinfotype18_v6b0_nce->v860_non_critical_extensions);
    }

    return SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: convert_plmn_identities_of_neighbour_cells_v860ext
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMNIdentitiesOfNeighbourCells_v860ext  to
 *       plmn_identities_of_neighbour_cells_v860ext_t 
 *
 *******************************************************************************/
void convert_plmn_identities_of_neighbour_cells_v860ext
(
 UMTS_PLMNIdentitiesOfNeighbourCells_v860ext    *pvalue,
 plmn_identities_of_neighbour_cells_v860ext_t   *p_plmn_identities_of_neighbour_cells_v860ext
 )
{
    if (pvalue->m.multipleplmnsOfIntraFreqCellsListPresent == 1)
    {
        p_plmn_identities_of_neighbour_cells_v860ext->presence_bitmask |=
            UMTS_SIB_TYPE_18_V860_NCE_PLMN_IDENTITIES_MUL_PLMNS_OF_INTRA_FREQ_CELL_PRESENCE_FLAG;

        convert_multiple_plmns_of_intra_freq_cells_list(
                &(pvalue->multipleplmnsOfIntraFreqCellsList),
                &(p_plmn_identities_of_neighbour_cells_v860ext->
                    multiple_plmns_of_intra_freq_cells_list));
    }

    if (pvalue->m.multipleplmnsOfInterFreqCellsListPresent== 1)
    {
        p_plmn_identities_of_neighbour_cells_v860ext->presence_bitmask |=
            UMTS_SIB_TYPE_18_V860_NCE_PLMN_IDENTITIES_MUL_PLMNS_OF_INTER_FREQ_CELL_PRESENCE_FLAG;

        convert_multiple_plmns_of_inter_freq_cells_list(
                &(pvalue->multipleplmnsOfInterFreqCellsList),
                &(p_plmn_identities_of_neighbour_cells_v860ext->
                    multiple_plmns_of_inter_freq_cells_list));
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_multiple_plmns_of_intra_freq_cells_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_MultiplePLMNsOfIntraFreqCellsList to
 *       multiple_plmns_of_intra_freq_cells_list_t
 *
 *******************************************************************************/
void convert_multiple_plmns_of_intra_freq_cells_list
(
 UMTS_MultiplePLMNsOfIntraFreqCellsList     *asn_multiplePLMNSIntraFreqList,
 multiple_plmns_of_intra_freq_cells_list_t  *multiple_plmns_list
 )
{
    OSRTDListNode                                   *pnode = NULL;
    UMTS_MultiplePLMNsOfIntraFreqCellsList_element  *pdata = NULL;
    U32                                             index;

    multiple_plmns_list->count = asn_multiplePLMNSIntraFreqList->count;
    pnode = asn_multiplePLMNSIntraFreqList->head;

    for(index=0; index< multiple_plmns_list->count; index++)
    {
        pdata = (UMTS_MultiplePLMNsOfIntraFreqCellsList_element*)pnode->data;

        if ( pdata->m.multiplePLMN_listPresent == 1)
        {
            multiple_plmns_list->multiple_plms_of_intra_freq_cells_list_element[index].presence_bitmask |=
                UMTS_SIB_TYPE_18_V860_NCE_PLMN_IDENTITIES_MUL_PLMNS_OF_INTRA_FREQ_CELL_MUL_PLMN_PRESENCE_FLAG;

            convert_multiple_plmns_of_intra_freq_cells_list_element_multiple_plmn_list(
                    &(pdata->multiplePLMN_list),
                    &(multiple_plmns_list->multiple_plms_of_intra_freq_cells_list_element[index].
                        multiple_plmn_list));
        }

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_multiple_plmns_of_inter_freq_cells_list
 *
 *   DESCRIPTION:
 *       This function converts UMTS_MultiplePLMNsOfInterFreqCellsList to
 *       multiple_plmns_of_inter_freq_cells_list_t
 *
 *******************************************************************************/
void convert_multiple_plmns_of_inter_freq_cells_list
(
 UMTS_MultiplePLMNsOfInterFreqCellsList     *p_asn_multiplePLMNSInterFreqList,
 multiple_plmns_of_inter_freq_cells_list_t  *p_multiple_plmns_list
 )
{
    OSRTDListNode                                   *pnode = NULL;
    UMTS_MultiplePLMNsOfInterFreqCellsList_element  *pdata = NULL;
    U32                                             index;

    p_multiple_plmns_list->count = p_asn_multiplePLMNSInterFreqList->count;
    pnode = p_asn_multiplePLMNSInterFreqList->head;

    for(index=0; index< p_multiple_plmns_list->count; index++)
    {
        pdata = (UMTS_MultiplePLMNsOfInterFreqCellsList_element*)pnode->data;

        if (pdata->m.multiplePLMN_listPresent == 1)
        {
            p_multiple_plmns_list->multiple_plms_of_inter_freq_cells_list_element[index].presence_bitmask |=
                UMTS_SIB_TYPE_18_V860_NCE_PLMN_IDENTITIES_MUL_PLMNS_OF_INTER_FREQ_CELL_MUL_PLMN_PRESENCE_FLAG;

            convert_multiple_plmns_of_inter_freq_cells_list_element_multiple_plmn_list(
                    &(pdata->multiplePLMN_list),
                    &(p_multiple_plmns_list->multiple_plms_of_inter_freq_cells_list_element[index].
                        multiple_plmn_list));
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_multiple_plmns_of_intra_freq_cells_list_element_multiple_plmn_list 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MultiplePLMNsOfIntraFreqCellsList_element_multiplePLMN_list to
 *       multiple_plmns_of_intra_freq_cells_list_element_multiple_plmn_list_t
 *
 *******************************************************************************/
void convert_multiple_plmns_of_intra_freq_cells_list_element_multiple_plmn_list
(
 UMTS_MultiplePLMNsOfIntraFreqCellsList_element_multiplePLMN_list       *p_asn_multiplePLMNSIntraFreqList,
 multiple_plmns_of_intra_freq_cells_list_element_multiple_plmn_list_t   *p_multiple_plmns_list
 )
{
    OSRTDListNode                           *pnode = NULL;
    UMTS_PLMN_IdentityWithOptionalMCC_r6    *pdata = NULL;
    U32                                     index;

    p_multiple_plmns_list->count = p_asn_multiplePLMNSIntraFreqList->count;
    pnode = p_asn_multiplePLMNSIntraFreqList->head;

    for(index=0; index< p_multiple_plmns_list->count; index++)
    {
        pdata = (UMTS_PLMN_IdentityWithOptionalMCC_r6*)pnode->data;

        convert_plmn_identity_with_optional_mcc_r6(
                pdata,
                &(p_multiple_plmns_list->plmn_identity_with_optional_mcc_r6[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:convert_multiple_plmns_of_inter_freq_cells_list_element_multiple_plmn_list 
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_MultiplePLMNsOfInterFreqCellsList_element_multiplePLMN_list to
 *       multiple_plmns_of_inter_freq_cells_list_element_multiple_plmn_list_t
 *
 *******************************************************************************/
void convert_multiple_plmns_of_inter_freq_cells_list_element_multiple_plmn_list
(
 UMTS_MultiplePLMNsOfInterFreqCellsList_element_multiplePLMN_list       *p_asn_multiplePLMNSInterFreqList,
 multiple_plmns_of_inter_freq_cells_list_element_multiple_plmn_list_t   *p_multiple_plmns_list
 )
{
    OSRTDListNode                           *pnode = NULL;
    UMTS_PLMN_IdentityWithOptionalMCC_r6    *pdata = NULL;
    U32                                     index;

    p_multiple_plmns_list->count = p_asn_multiplePLMNSInterFreqList->count;
    pnode = p_asn_multiplePLMNSInterFreqList->head;

    for(index=0; index < p_multiple_plmns_list->count; index++)
    {
        pdata = (UMTS_PLMN_IdentityWithOptionalMCC_r6*)pnode->data;

        convert_plmn_identity_with_optional_mcc_r6(
                pdata,
                &(p_multiple_plmns_list->plmn_identity_with_optional_mcc_r6[index]));

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_plmn_identities_of_neighbour_cells
 *
 *   DESCRIPTION:
 *       This function converts UMTS_PLMNIdentitiesOfNeighbourCells to
 *       plmn_identities_of_neighbour_cells_t
 *
 *******************************************************************************/
void convert_plmn_identities_of_neighbour_cells
(
 UMTS_PLMNIdentitiesOfNeighbourCells    *pvalue,
 plmn_identities_of_neighbour_cells_t   *p_plmn_identities_of_neighbour_cells 
 )
{
    if (pvalue->m.plmnsOfIntraFreqCellsListPresent)
    {
        p_plmn_identities_of_neighbour_cells->presence_bitmask |=
            UMTS_SIB_TYPE_18_PLMN_IDENTITIES_INTRA_FREQ_CELLS_LIST_PRESENCE_FLAG;

        convert_plmn_intra_freq_list(
                &pvalue->plmnsOfIntraFreqCellsList,
                &p_plmn_identities_of_neighbour_cells->plmns_of_intra_freq_cells_list); 
    }

    if (pvalue->m.plmnsOfInterFreqCellsListPresent)
    {
        p_plmn_identities_of_neighbour_cells->presence_bitmask |=
            UMTS_SIB_TYPE_18_PLMN_IDENTITIES_INTER_FREQ_CELLS_LIST_PRESENCE_FLAG;

        convert_plmn_inter_freq_list(
                &pvalue->plmnsOfInterFreqCellsList,
                &p_plmn_identities_of_neighbour_cells->plmns_of_inter_freq_cells_list);  
    }

    if (pvalue->m.plmnsOfInterRATCellsListPresent)
    {
        p_plmn_identities_of_neighbour_cells->presence_bitmask |=
            UMTS_SIB_TYPE_18_PLMN_IDENTITIES_INTER_RAT_CELLS_LIST_PRESENCE_FLAG;

        convert_plmn_inter_rat_list(
                &pvalue->plmnsOfInterRATCellsList,
                &p_plmn_identities_of_neighbour_cells->plmns_of_inter_rat_cells_list); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib18
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType18 to
 *       umts_sib_type_18_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       umts_sib18 - Pointer to decoded SIB18
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib18
(
 umts_sib_type_18_info_t *umts_sib18
 )
{
    UMTS_SysInfoType18   sys_info_type_18;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_18_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_18, 0, sizeof(UMTS_SysInfoType18));


    if ( 0 !=  (asn1PD_UMTS_SysInfoType18( &ctxt, &sys_info_type_18)))
    {
        printf("umts_convert_sib18: asn decoding failed\n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType18("Decoded SysInfoType18\n", &sys_info_type_18);
    memset( umts_sib18, 0 , sizeof(umts_sib_type_18_info_t));

    if (sys_info_type_18.m.idleModePLMNIdentitiesPresent == 1)
    {
        umts_sib18->presence_bitmask |= UMTS_SIB_TYPE_18_IDLE_MODE_PLMN_IDENTITIES_PRESENCE_FLAG;

        convert_plmn_identities_of_neighbour_cells(
                &sys_info_type_18.idleModePLMNIdentities,
                &umts_sib18->idle_mode_plmn_identities);
    }

    if (sys_info_type_18.m.connectedModePLMNIdentitiesPresent == 1)
    {
        umts_sib18->presence_bitmask |= 
            UMTS_SIB_TYPE_18_CONNECTED_MODE_PLMN_IDENTITIES_PRESENCE_FLAG;            

        convert_plmn_identities_of_neighbour_cells(
                &sys_info_type_18.connectedModePLMNIdentities,
                &umts_sib18->connected_mode_plmn_identities);
    }

    if (sys_info_type_18.m.v6b0NonCriticalExtensionsPresent == 1)
    {
        umts_sib18->presence_bitmask |= UMTS_SIB_TYPE_18_NC_EXTN_PRESENCE_FLAG;

        fill_sysinfotype18_v3a0_nce(
                &(sys_info_type_18.v6b0NonCriticalExtensions),
                &(umts_sib18->v6b0_non_ritical_extensions));
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}


/******************************************************************************
 *   FUNCTION NAME: umts_check_and_decode_sibs
 *
 *   DESCRIPTION:
 *       This function decode UMTS_BCCH_BCH_Message to
 *       umts_sib_message_t
 *       and check if input data are valid.
 *
 *   INPUT:
 *       pctxt              - Pointer to asn context
 *       asn_decoded_sibs   - Pointer to asn decoded sibs
 *       decoded_buf        - Pointer to decoded message
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data is invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_check_and_decode_sibs
(
 OSCTXT                  *pctxt,
 UMTS_BCCH_BCH_Message   *asn_decoded_sibs,
 umts_sib_message_t      *decoded_buf
 )
{

    return_code ret_val = FAILURE;

    switch(asn_decoded_sibs->message.payload.t)
    {
        case T_UMTS_SystemInformation_BCH_payload_noSegment:
            printf("No system info provided\n");
            break;

        case T_UMTS_SystemInformation_BCH_payload_firstSegment:
            ret_val = check_decode_first_segment((asn_decoded_sibs->message).payload.u.firstSegment);
            break;

        case T_UMTS_SystemInformation_BCH_payload_subsequentSegment:
            ret_val = check_decode_subsequent_segment((asn_decoded_sibs->message).payload.u.subsequentSegment);
            break;

        case T_UMTS_SystemInformation_BCH_payload_lastSegmentShort:
            ret_val = check_decode_last_segment_short((asn_decoded_sibs->message).payload.u.lastSegmentShort);
            if (SUCCESS == ret_val)
            {
                ret_val = decode_system_info_msg(decoded_buf);
            }    
            break;

        case T_UMTS_SystemInformation_BCH_payload_lastAndFirst:
            ret_val = check_decode_last_and_first((asn_decoded_sibs->message).payload.u.lastAndFirst);
            if (SUCCESS == ret_val)
            {
                ret_val = decode_system_info_msg(decoded_buf);
            }    
            break;

        case T_UMTS_SystemInformation_BCH_payload_lastAndComplete:
            ret_val = check_decode_last_and_complete((asn_decoded_sibs->message).payload.u.lastAndComplete);
            if (SUCCESS == ret_val)
            {
                ret_val = decode_system_info_msg(decoded_buf);
            }    
            break;

        case T_UMTS_SystemInformation_BCH_payload_lastAndCompleteAndFirst:
            ret_val = check_decode_last_and_complete_and_first((asn_decoded_sibs->message).payload.u.lastAndCompleteAndFirst);
            if (SUCCESS == ret_val)
            {
                ret_val = decode_system_info_msg(decoded_buf);
            }    
            break;

        case T_UMTS_SystemInformation_BCH_payload_completeSIB_List:
            ret_val = check_decode_completeSIB_list((asn_decoded_sibs->message).payload.u.completeSIB_List);
            if (SUCCESS == ret_val)
            {
                ret_val = decode_system_info_msg(decoded_buf);
            }    
            break;

        case T_UMTS_SystemInformation_BCH_payload_completeAndFirst:
            ret_val = check_decode_complete_and_first((asn_decoded_sibs->message).payload.u.completeAndFirst);
            if (SUCCESS == ret_val)
            {
                ret_val = decode_system_info_msg(decoded_buf);
            }    
            break;

        case T_UMTS_SystemInformation_BCH_payload_completeSIB:
            ret_val = check_decode_complete_SIB((asn_decoded_sibs->message).payload.u.completeSIB);
            if (SUCCESS == ret_val)
            {
                ret_val = decode_system_info_msg(decoded_buf);
            }    
            break;

        case T_UMTS_SystemInformation_BCH_payload_lastSegment:
            ret_val = check_decode_last_segment((asn_decoded_sibs->message).payload.u.lastSegment);
            if (SUCCESS == ret_val)
            {
                ret_val = decode_system_info_msg(decoded_buf);
            }    
            break;

        case T_UMTS_SystemInformation_BCH_payload_spare5:
        case T_UMTS_SystemInformation_BCH_payload_spare4:
        case T_UMTS_SystemInformation_BCH_payload_spare3:
        case T_UMTS_SystemInformation_BCH_payload_spare2:
        case T_UMTS_SystemInformation_BCH_payload_spare1:
            break;

        default:
            printf("umts_check_and_decode_sibs:Invalid Option recived as asn_decoded_sibs->message.payload.t");
            ret_val = FAILURE;
            break;
    }
    while (0x00 != g_umts_ctxt.complete_si_msg_filled_bitmask)
    {
        decode_system_info_msg(decoded_buf);
    }    

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: umts_sib_decoder
 *
 *   DESCRIPTION:
 *       This is interface function for UMTS sib decoding
 *       It converts encoded UMTS sib data into user umts_sib_message_t
 *       structure.
 *
 *   INPUT:
 *       encoded_sib_msg - Pointer to encoded sib message
 *       decoded_sib_msg - Pointer to decoded sib message to be filled
 *       encoded_sib_len - encoded sib length
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data is invalid
 *
 *******************************************************************************/
U8 umts_sib_decoder
(
 U8                 *encoded_sib_msg,
 umts_sib_message_t *decoded_sibs_msg,
 U16                encoded_sib_len
 )
{
    UMTS_BCCH_BCH_Message   asn_decoded_sibs;
    OSCTXT                  ctxt;
    S32                     stat              = 0;
    U8                      ret_val           = 0;

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        return FAILURE;
    }

    pu_setBuffer (&ctxt, encoded_sib_msg, encoded_sib_len, FALSE);

    stat =  asn1PD_UMTS_BCCH_BCH_Message(&ctxt, &asn_decoded_sibs);

    if (stat != RT_OK)
    {
        printf("Can't decode BCH: %d", stat);
        return  FAILURE;
    }

    asn1Print_UMTS_BCCH_BCH_Message("UMTS_BCCH_BCH_Message", &asn_decoded_sibs);

    ret_val = (U8) umts_check_and_decode_sibs(&ctxt, &asn_decoded_sibs, decoded_sibs_msg);


    rtFreeContext(&ctxt);

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: convert_rat_fdd_info_list
 *
 *   DESCRIPTION:
 *       This function converts RAT_FDD_InfoList to
 *      rat_fdd_info_list_t
 *       and checks whether input data are valid.
 *
 *******************************************************************************/
void convert_rat_fdd_info_list
(
 UMTS_RAT_FDD_InfoList  *pvalue,
 rat_fdd_info_list_t    *p_rat_fdd_info_list
 )
{
    UMTS_RAT_FDD_Info   *pdata;
    OSRTDListNode       *pnode = NULL;
    U32                 index;

    pnode = pvalue->head;
    p_rat_fdd_info_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_RAT_FDD_Info*)pnode->data;

        p_rat_fdd_info_list->rat_fdd_info[index].rat_identifier = pdata->rat_Identifier;
        p_rat_fdd_info_list->rat_fdd_info[index].s_search_rat = pdata->s_SearchRAT;

        if (pdata->m.s_HCS_RATPresent)
        {
            p_rat_fdd_info_list->rat_fdd_info[index].presence_bitmask |=
                UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_FDD_RAT_FDD_INFO_S_HCS_RAT_PRESENCE_FLAG;

            p_rat_fdd_info_list->rat_fdd_info[index].s_hcs_rat = pdata->s_HCS_RAT;
        }

        p_rat_fdd_info_list->rat_fdd_info[index].s_limit_search_rat = pdata->s_Limit_SearchRAT;

        pnode = pnode->next;
    }
}                       

/******************************************************************************                                               
 *   FUNCTION NAME: convert_rat_tdd_info_list
 *
 *   DESCRIPTION:
 *       This function converts RAT_TDD_InfoList to
 *      rat_tdd_info_list_t
 *       and checks whether input data are valid.
 *
 *******************************************************************************/
void convert_rat_tdd_info_list
(
 UMTS_RAT_TDD_InfoList  *pvalue,
 rat_tdd_info_list_t    *p_rat_tdd_info_list
 )
{
    UMTS_RAT_TDD_Info   *pdata = NULL;
    OSRTDListNode       *pnode = NULL;
    U32                 index;

    pnode = pvalue->head;
    p_rat_tdd_info_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_RAT_TDD_Info*)pnode->data;

        p_rat_tdd_info_list->rat_tdd_info[index].rat_identifier = pdata->rat_Identifier;
        p_rat_tdd_info_list->rat_tdd_info[index].s_search_rat = pdata->s_SearchRAT;

        if (pdata->m.s_HCS_RATPresent)
        {
            p_rat_tdd_info_list->rat_tdd_info[index].presence_bitmask |= 
                UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_TDD_RAT_TDD_INFO_S_HCS_RAT_PRESENCE_FLAG;

            p_rat_tdd_info_list->rat_tdd_info[index].s_hcs_rat = pdata->s_HCS_RAT;
        }

        p_rat_tdd_info_list->rat_tdd_info[index].s_limit_search_rat = pdata->s_Limit_SearchRAT;

        pnode = pnode->next;
    }
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_call_select_reselect_infoSIB3_4_cell_select_quality_measure_cpich_Ec_N0
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_3_4_cellSelectQualityMeasure_cpich_Ec_N0 to
 *       call_select_reselect_infoSIB3_4_cell_select_quality_measure_cpich_Ec_N0_t
 *
 *******************************************************************************/
void convert_call_select_reselect_infoSIB3_4_cell_select_quality_measure_cpich_Ec_N0
(
 UMTS_CellSelectReselectInfoSIB_3_4_cellSelectQualityMeasure_cpich_Ec_N0    *pvalue,
 call_select_reselect_infoSIB3_4_cell_select_quality_measure_cpich_Ec_N0_t  *p_cpich_ec_no 
 )
{
    if (pvalue->m.q_HYST_2_SPresent)
    {
        p_cpich_ec_no->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_QUALITY_MEASURE_CPICH_EC_NO_Q_HYST_2_S_PRESENCE_FLAG;

        p_cpich_ec_no->q_hyst_2_s = pvalue->q_HYST_2_S;
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_call_select_reselect_infoSIB3_4_cell_select_quality_measure
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_3_4_cellSelectQualityMeasure to
 *       call_select_reselect_infoSIB3_4_cell_select_quality_measure_t
 *
 *******************************************************************************/
void convert_call_select_reselect_infoSIB3_4_cell_select_quality_measure
(
 UMTS_CellSelectReselectInfoSIB_3_4_cellSelectQualityMeasure    *pvalue,
 call_select_reselect_infoSIB3_4_cell_select_quality_measure_t  *p_select_quality_measure 
 )
{
    p_select_quality_measure->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_3_4_cellSelectQualityMeasure_cpich_Ec_N0)
    {
        convert_call_select_reselect_infoSIB3_4_cell_select_quality_measure_cpich_Ec_N0(
                pvalue->u.cpich_Ec_N0,
                &p_select_quality_measure->u.cpich_Ec_N0);
    }
    else if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_3_4_cellSelectQualityMeasure_cpich_RSCP)
    {
        /* for future use */         
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_call_select_reselect_infoSIB3_4_mode_specific_info_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd to
 *       call_select_reselect_infoSIB3_4_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_call_select_reselect_infoSIB3_4_mode_specific_info_fdd
(
 UMTS_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd    *pvalue,
 call_select_reselect_infoSIB3_4_mode_specific_info_fdd_t   *p_fdd 
 )
{
    if (pvalue->m.s_IntrasearchPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_FDD_INTRA_SEARCH_PRESENCE_FLAG;

        p_fdd->s_intra_search = pvalue->s_Intrasearch;
    }

    if (pvalue->m.s_IntersearchPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_FDD_INTER_SERACH_PRESENCE_FLAG;

        p_fdd->s_inter_search = pvalue->s_Intersearch;
    }

    if (pvalue->m.s_SearchHCSPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_FDD_SEARCH_HCS_PRESENCE_FLAG;

        p_fdd->s_search_hcs = pvalue->s_SearchHCS;
    }

    if (pvalue->m.rat_ListPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_FDD_RAT_LIST_PRESENCE_FLAG;

        convert_rat_fdd_info_list(
                &pvalue->rat_List,
                &p_fdd->rat_fdd_info_list);
    }

    p_fdd->q_qual_min = pvalue->q_QualMin;
    p_fdd->q_rxlev_min = pvalue->q_RxlevMin;

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_call_select_reselect_infoSIB3_4_mode_specific_info_tdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_tdd to
 *       call_select_reselect_infoSIB3_4_mode_specific_info_tdd_t
 *
 *******************************************************************************/
void convert_call_select_reselect_infoSIB3_4_mode_specific_info_tdd
(
 UMTS_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_tdd    *pvalue,
 call_select_reselect_infoSIB3_4_mode_specific_info_tdd_t   *p_tdd 
 )
{
    if (pvalue->m.s_IntrasearchPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_TDD_INTRA_SEARCH_PRESENCE_FLAG;

        p_tdd->s_intra_search = pvalue->s_Intrasearch;
    }

    if (pvalue->m.s_IntersearchPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_TDD_INTER_SEARCH_PRESENCE_FLAG;

        p_tdd->s_inter_search = pvalue->s_Intersearch; 
    }

    if (pvalue->m.s_SearchHCSPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_TDD_SEARCH_HCS_PRESENCE_FLAG;

        p_tdd->s_search_hcs = pvalue->s_SearchHCS;
    }

    if (pvalue->m.rat_ListPresent)
    {
        p_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MODE_SPECIFIC_INFO_P_TDD_RAT_LIST_PRESENCE_FLAG;

        convert_rat_tdd_info_list(
                &pvalue->rat_List,
                &p_tdd->rat_tdd_info_list);
    }

    p_tdd->q_rxlev_min = pvalue->q_RxlevMin;

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_call_select_reselect_infoSIB3_4_mode_specific_info
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_3_4_modeSpecificInfo to
 *       call_select_reselect_infoSIB3_4_mode_specific_info_t
 *
 *******************************************************************************/
void convert_call_select_reselect_infoSIB3_4_mode_specific_info
(
 UMTS_CellSelectReselectInfoSIB_3_4_modeSpecificInfo    *pvalue,
 call_select_reselect_infoSIB3_4_mode_specific_info_t   *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd)
    {
        convert_call_select_reselect_infoSIB3_4_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd);
    }
    else if(pvalue->t == T_UMTS_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_tdd)
    {
        convert_call_select_reselect_infoSIB3_4_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_T_cr_max
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_T_CRMax to
 *       T_cr_max_t
 *
 *******************************************************************************/
void convert_T_cr_max
(
 UMTS_T_CRMax   *pvalue,
 T_cr_max_t     *p_T_cr_max 
 )
{
    p_T_cr_max-> t = pvalue->t;

    if (pvalue->t == T_UMTS_T_CRMax_notUsed)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_T_CRMax_t30)
    {
        memcpy(&p_T_cr_max->u.t30, pvalue->u.t30,
                sizeof (n_cr_t_cr_max_hyst_t));
    }
    else if (pvalue->t == T_UMTS_T_CRMax_t60)
    {
        memcpy(&p_T_cr_max->u.t60, pvalue->u.t60,
                sizeof (n_cr_t_cr_max_hyst_t));
    }
    else if (pvalue->t == T_UMTS_T_CRMax_t120)
    {
        memcpy(&p_T_cr_max->u.t120, pvalue->u.t120,
                sizeof (n_cr_t_cr_max_hyst_t));
    }
    else if (pvalue->t == T_UMTS_T_CRMax_t180)
    {
        memcpy(&p_T_cr_max->u.t180, pvalue->u.t180,
                sizeof (n_cr_t_cr_max_hyst_t));
    }
    else if (pvalue->t == T_UMTS_T_CRMax_t240)
    {
        memcpy(&p_T_cr_max->u.t240, pvalue->u.t240,
                sizeof (n_cr_t_cr_max_hyst_t));
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_hsc_serving_cell_information
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_HCS_ServingCellInformation to
 *       hsc_serving_cell_information_t
 *
 *******************************************************************************/
void convert_hsc_serving_cell_information
(
 UMTS_HCS_ServingCellInformation    *pvalue,
 hsc_serving_cell_information_t     *p_hsc_serving_cell_information 
 )
{
    p_hsc_serving_cell_information->hsc_prio =
        pvalue->hcs_PRIO;

    p_hsc_serving_cell_information->q_hcs =
        pvalue->q_HCS;

    if (pvalue->m.t_CR_MaxPresent)
    {
        p_hsc_serving_cell_information->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_HSC_SERVING_CELL_INFO_T_CR_MAX_PRESENCE_FLAG;

        convert_T_cr_max(
                &pvalue->t_CR_Max,
                &p_hsc_serving_cell_information->t_cr_max);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_cell_select_reselect_infoSIB_3_4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoSIB_3_4 to
 *       cell_select_reselect_infoSIB_3_4_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_infoSIB_3_4
(
 UMTS_CellSelectReselectInfoSIB_3_4     *pvalue,
 cell_select_reselect_infoSIB_3_4_t     *p_cell_select_reselect_infoSIB_3_4 
 )
{
    if (pvalue->m.mappingInfoPresent)
    {
        p_cell_select_reselect_infoSIB_3_4->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_MAPPING_INFO_PRESENCE_FLAG;

        convert_mapping_info(
                &pvalue->mappingInfo,
                &p_cell_select_reselect_infoSIB_3_4->mapping_Info);
    }

    convert_call_select_reselect_infoSIB3_4_cell_select_quality_measure(
            &pvalue->cellSelectQualityMeasure,
            &p_cell_select_reselect_infoSIB_3_4->cell_select_quality_measure);

    convert_call_select_reselect_infoSIB3_4_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_cell_select_reselect_infoSIB_3_4->mode_specific_info);

    p_cell_select_reselect_infoSIB_3_4->Hyst_1_S =
        pvalue->q_Hyst_l_S;

    p_cell_select_reselect_infoSIB_3_4->Reselection_S =
        pvalue->t_Reselection_S;

    if (pvalue->m.hcs_ServingCellInformationPresent)
    {
        p_cell_select_reselect_infoSIB_3_4->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_HSC_SERVING_CELL_INFO_PRESENCE_FLAG;

        convert_hsc_serving_cell_information(
                &pvalue->hcs_ServingCellInformation,
                &p_cell_select_reselect_infoSIB_3_4->hsc_serving_cell_Info);
    }

    p_cell_select_reselect_infoSIB_3_4->max_AllowedUL_TX_Power =
        pvalue->maxAllowedUL_TX_Power;

    return;
}

/******************************************************************************
 * FUNCTION NAME: convert_callBarred_barred
 *
 * DESCRIPTION:
 * This function converts
 * UMTS_CellBarred_barred to
 * callBarred_barred_t
 *
 *******************************************************************************/
void convert_callBarred_barred
(
 UMTS_CellBarred_barred *pvalue,
 callBarred_barred_t *p_callBarred_barred
 )
{
    p_callBarred_barred->allowed_indicator =
        pvalue->intraFreqCellReselectionInd;

    p_callBarred_barred->t_barred =
        pvalue->t_Barred;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_call_barred
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellBarred to
 *       call_barred_t
 *
 *******************************************************************************/
void convert_call_barred
(
 UMTS_CellBarred    *pvalue,
 call_barred_t      *p_call_barred 
 )
{
    p_call_barred->t = pvalue->t;

    if (pvalue->t == T_UMTS_CellBarred_barred)
    {
        convert_callBarred_barred(
                pvalue->u.barred,
                &p_call_barred->u.barred);
    }
    else if (pvalue->t == T_UMTS_CellBarred_notBarred)
    {
        /* for future use */
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_access_class_barred_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_AccessClassBarredList to
 *       access_class_barred_list_t
 *
 *******************************************************************************/
void convert_access_class_barred_list
(
 UMTS_AccessClassBarredList     *pvalue,
 access_class_barred_list_t     *p_access_class_barred_list 
 )
{   
    p_access_class_barred_list->n = pvalue->n;

    memcpy(&p_access_class_barred_list->elem,
            &pvalue->elem, 
            (sizeof(U32) * p_access_class_barred_list->n));

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_cell_access_restriction
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellAccessRestriction to
 *       cell_access_restriction_t
 *
 *******************************************************************************/
void convert_cell_access_restriction
(
 UMTS_CellAccessRestriction     *pvalue,
 cell_access_restriction_t      *p_cell_access_restriction 
 )
{
    convert_call_barred(
            &pvalue->cellBarred,
            &p_cell_access_restriction->cell_barred);

    p_cell_access_restriction->cell_reserved_for_operator_use =
        pvalue->cellReservedForOperatorUse;

    p_cell_access_restriction->cell_reservation_extenstion =
        pvalue->cellReservationExtension;

    if (pvalue->m.accessClassBarredListPresent)
    {
        p_cell_access_restriction->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_ACCESS_RESTRICTION_ACCESS_CLASS_BARRED_LIST_PRESENCE_FLAG;

        convert_access_class_barred_list(
                &pvalue->accessClassBarredList,
                &p_cell_access_restriction->accessClass_barred_list);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_mapping_lcr_r4
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_Mapping_LCR_r4 to
 *       mapping_lcr_r4_t
 *
 *******************************************************************************/
void convert_mapping_lcr_r4
(
 UMTS_Mapping_LCR_r4    *pvalue,
 mapping_lcr_r4_t       *p_mapping_lcr_r4 
 )
{
    convert_mapping_function_parameter_list(
            &pvalue->mappingFunctionParameterList,
            &p_mapping_lcr_r4->mapping_function_parameter_list);

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0ext_ies_t
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0ext_IEs to
 *       sysinfotype3_v4b0ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0ext_ies_t
(
 UMTS_SysInfoType3_v4b0ext_IEs  *pvalue,
 sysinfotype3_v4b0ext_ies_t     *p_sysinfotype3_v4b0ext_ies 
 )
{
    if (pvalue->m.mapping_LCRPresent)
    {
        p_sysinfotype3_v4b0ext_ies->presence_bitmask |=
            SYSINFOTYPE3_V4B0EXT_IES_MAPPING_LCR_PRESENCE_FLAG;

        convert_mapping_lcr_r4(
                &pvalue->mapping_LCR,
                &p_sysinfotype3_v4b0ext_ies->mapping_LCR);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v590ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v590ext to
 *       sysinfotype3_v590ext_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v590ext
(
 UMTS_SysInfoType3_v590ext  *pvalue,
 sysinfotype3_v590ext_t     *p_sysinfotype3_v590ext 
 )
{
    if (pvalue->m.cellSelectReselectInfo_v590extPresent)
    {
        p_sysinfotype3_v590ext->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_V590_EXT_PRESENCE_FLAG;

        convert_cell_select_reselect_info_v590_ext(
                &pvalue->cellSelectReselectInfo_v590ext,
                &p_sysinfotype3_v590ext->cell_select_reselect_info_v590_ext);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_cell_select_reselect_info_t_reselection_scaling_v5c0ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellSelectReselectInfoTreselectionScaling_v5c0ext to
 *       cell_select_reselect_info_t_reselection_scaling_v5c0ext_t
 *
 *******************************************************************************/
void convert_cell_select_reselect_info_t_reselection_scaling_v5c0ext
(
 UMTS_CellSelectReselectInfoTreselectionScaling_v5c0ext     *pvalue,
 cell_select_reselect_info_t_reselection_scaling_v5c0ext_t  *p_reselection_scaling_v5c0ext 
 )
{
    if (pvalue->m.non_HCS_t_CR_MaxPresent)
    {
        p_reselection_scaling_v5c0ext->presence_bitmask |=
            UMTS_SIB_T_CR_MAX_PRESENCE_FLAG;

        convert_T_cr_max(
                &pvalue->non_HCS_t_CR_Max,
                &p_reselection_scaling_v5c0ext->non_hcs_t_cr_max);
    }

    if (pvalue->m.speedDependentScalingFactorPresent)
    {
        p_reselection_scaling_v5c0ext->presence_bitmask |=
            UMTS_SIB_SPEED_DEPENDENT_SCALING_FACTOR_PRESENCE_FLAG;

        p_reselection_scaling_v5c0ext->speed_dependent_scaling_factor =
            pvalue->speedDependentScalingFactor;
    }

    if (pvalue->m.interFrequencyTreselectionScalingFactorPresent)
    {
        p_reselection_scaling_v5c0ext->presence_bitmask |=
            UMTS_SIB_INTER_FREQUENCY_T_RESELECTION_SCALING_FACTOR_PRESENCE_FLAG;

        p_reselection_scaling_v5c0ext->inter_frequency_t_reselection_scaling_factor =
            pvalue->interFrequencyTreselectionScalingFactor;
    }

    if (pvalue->m.interRATTreselectionScalingFactorPresent)
    {
        p_reselection_scaling_v5c0ext->presence_bitmask |=
            UMTS_SIB_INTER_RAT_T_RESELECTION_SCALING_FACTOR_PRESENCE_FLAG;

        p_reselection_scaling_v5c0ext->inter_rat_t_reselection_scaling_factor =
            pvalue->interRATTreselectionScalingFactor;
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v5c0ext_ies
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v5c0ext_IEs to
 *       sysinfotype3_v5c0ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v5c0ext_ies
(
 UMTS_SysInfoType3_v5c0ext_IEs  *pvalue,
 sysinfotype3_v5c0ext_ies_t     *p_sysinfotype3_v5c0ext_ies 
 )
{
    if (pvalue->m.cellSelectReselectInfoTreselectionScaling_v5c0extPresent)
    {
        p_sysinfotype3_v5c0ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_SELECT_RESELECT_INFO_T_RESELECTION_SCALING_V5C0EXT_PRESENCE_FLAG;

        convert_cell_select_reselect_info_t_reselection_scaling_v5c0ext(
                &pvalue->cellSelectReselectInfoTreselectionScaling_v5c0ext,
                &p_sysinfotype3_v5c0ext_ies->cell_select_reselect_info_t_reselection_scaling_v5c0ext);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_domain_specific_access_restriction_v670ext_restriction
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DomainSpecificAccessRestriction_v670ext_restriction to
 *       domain_specific_access_restriction_v670ext_restriction_t
 *
 *******************************************************************************/
void convert_domain_specific_access_restriction_v670ext_restriction
(
 UMTS_DomainSpecificAccessRestriction_v670ext_restriction   *pvalue,
 domain_specific_access_restriction_v670ext_restriction_t   *p_restriction 
 )
{
    if (pvalue->m.domainSpecficAccessClassBarredListPresent)
    {
        p_restriction->presence_bitmask |=
            UMTS_SIB_DOMAIN_SPECIFIC_ACCESS_RESTRICTION_V670EXT_RESTRICTION_PRESENCE_FLAG;

        convert_access_class_barred_list(
                &pvalue->domainSpecficAccessClassBarredList,
                &p_restriction->domain_specfic_access_class_barred_list);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_domain_specific_access_restriction_v670ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DomainSpecificAccessRestriction_v670ext to
 *       domain_specific_access_restriction_v670ext_t
 *
 *******************************************************************************/
void convert_domain_specific_access_restriction_v670ext
(
 UMTS_DomainSpecificAccessRestriction_v670ext   *pvalue,
 domain_specific_access_restriction_v670ext_t   *p_access_restriction 
 )
{
    p_access_restriction->t = pvalue->t;

    if (pvalue->t == T_UMTS_DomainSpecificAccessRestriction_v670ext_noRestriction)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_DomainSpecificAccessRestriction_v670ext_restriction)
    {
        convert_domain_specific_access_restriction_v670ext_restriction(
                pvalue->u.restriction,
                &p_access_restriction->u.restriction);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_domain_specific_access_restriction_param_v670ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DomainSpecificAccessRestrictionParam_v670ext to
 *       domain_specific_access_restriction_param_v670ext_t
 *
 *******************************************************************************/
void convert_domain_specific_access_restriction_param_v670ext
(
 UMTS_DomainSpecificAccessRestrictionParam_v670ext  *pvalue,
 domain_specific_access_restriction_param_v670ext_t *p_param 
 )
{
    convert_domain_specific_access_restriction_v670ext(
            &pvalue->cSDomainSpecificAccessRestriction,
            &p_param->cs_domain_specific_access_restriction);

    convert_domain_specific_access_restriction_v670ext(
            &pvalue->pSDomainSpecificAccessRestriction,
            &p_param->ps_domain_specific_access_restriction);

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_domain_specific_access_restriction_list_v670ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DomainSpecificAccessRestrictionList_v670ext to
 *       domain_specific_access_restriction_list_v670ext_t
 *
 *******************************************************************************/
void convert_domain_specific_access_restriction_list_v670ext
(
 UMTS_DomainSpecificAccessRestrictionList_v670ext   *pvalue,
 domain_specific_access_restriction_list_v670ext_t  *p_list 
 )
{
    if (pvalue->m.domainSpecificAccessRestrictionParametersForOperator1Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_DOMAIN_SPECIFIC_ACCESS_RESTRICTION_PARAMETERS_FOR_OPERATOR1_PRESENCE_FLAG;

        convert_domain_specific_access_restriction_param_v670ext(
                &pvalue->domainSpecificAccessRestrictionParametersForOperator1,
                &p_list->domain_specific_access_restriction_parameters_for_operator1);
    }

    if (pvalue->m.domainSpecificAccessRestrictionParametersForOperator2Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_DOMAIN_SPECIFIC_ACCESS_RESTRICTION_PARAMETERS_FOR_OPERATOR2_PRESENCE_FLAG;

        convert_domain_specific_access_restriction_param_v670ext(
                &pvalue->domainSpecificAccessRestrictionParametersForOperator2,
                &p_list->domain_specific_access_restriction_parameters_for_operator2);
    }    

    if (pvalue->m.domainSpecificAccessRestrictionParametersForOperator3Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_DOMAIN_SPECIFIC_ACCESS_RESTRICTION_PARAMETERS_FOR_OPERATOR3_PRESENCE_FLAG;

        convert_domain_specific_access_restriction_param_v670ext(
                &pvalue->domainSpecificAccessRestrictionParametersForOperator3,
                &p_list->domain_specific_access_restriction_parameters_for_operator3);
    }    

    if (pvalue->m.domainSpecificAccessRestrictionParametersForOperator4Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_DOMAIN_SPECIFIC_ACCESS_RESTRICTION_PARAMETERS_FOR_OPERATOR4_PRESENCE_FLAG;

        convert_domain_specific_access_restriction_param_v670ext(
                &pvalue->domainSpecificAccessRestrictionParametersForOperator4,
                &p_list->domain_specific_access_restriction_parameters_for_operator4);
    }    

    if (pvalue->m.domainSpecificAccessRestrictionParametersForOperator5Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_DOMAIN_SPECIFIC_ACCESS_RESTRICTION_PARAMETERS_FOR_OPERATOR5_PRESENCE_FLAG;

        convert_domain_specific_access_restriction_param_v670ext(
                &pvalue->domainSpecificAccessRestrictionParametersForOperator5,
                &p_list->domain_specific_access_restriction_parameters_for_operator5);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_domain_specific_access_restriction_for_shared_network_v670ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DomainSpecificAccessRestrictionForSharedNetwork_v670ext to
 *       domain_specific_access_restriction_for_shared_network_v670ext_t
 *
 *******************************************************************************/
void convert_domain_specific_access_restriction_for_shared_network_v670ext
(
 UMTS_DomainSpecificAccessRestrictionForSharedNetwork_v670ext       *pvalue,
 domain_specific_access_restriction_for_shared_network_v670ext_t    *p_shared_network_v670ext 
 )
{
    p_shared_network_v670ext->t = pvalue->t;

    if (pvalue->t == T_UMTS_DomainSpecificAccessRestrictionForSharedNetwork_v670ext_domainSpecificAccessRestictionList)
    {
        convert_domain_specific_access_restriction_list_v670ext(
                pvalue->u.domainSpecificAccessRestictionList,
                &p_shared_network_v670ext->u.domain_specific_access_restiction_list);
    }
    else if (pvalue->t == T_UMTS_DomainSpecificAccessRestrictionForSharedNetwork_v670ext_domainSpecificAccessRestictionParametersForAll)
    {
        convert_domain_specific_access_restriction_param_v670ext(
                pvalue->u.domainSpecificAccessRestictionParametersForAll,
                &p_shared_network_v670ext->u.domain_specific_access_restiction_parameters_forall);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v670ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v670ext to
 *       sysinfotype3_v670ext_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v670ext
(
 UMTS_SysInfoType3_v670ext  *pvalue,
 sysinfotype3_v670ext_t     *p_sysinfotype3_v670ext 
 )
{
    if (pvalue->m.domainSpecificAccessRestrictionParametersForPLMNOfMIBPresent)
    {
        p_sysinfotype3_v670ext->presence_bitmask |=
            UMTS_SIB_DOMAIN_SPECIFIC_ACCESS_RESTRICTION_PARAM_V670EXT_PRESENCE_FLAG;

        convert_domain_specific_access_restriction_param_v670ext(
                &pvalue->domainSpecificAccessRestrictionParametersForPLMNOfMIB,
                &p_sysinfotype3_v670ext->domain_specific_access_restriction_parameters_for_plmn_of_mib);
    }

    if (pvalue->m.domainSpecificAccessRestictionForSharedNetworkPresent)
    {
        p_sysinfotype3_v670ext->presence_bitmask |=
            UMTS_SIB_DOMAIN_SPECIFIC_ACCESS_RESTRICTION_FOR_SHARED_NETWORK_V670EXT_PRESENCE_FLAG;

        convert_domain_specific_access_restriction_for_shared_network_v670ext(
                &pvalue->domainSpecificAccessRestictionForSharedNetwork,
                &p_sysinfotype3_v670ext->domain_specific_access_restiction_for_shared_network); 
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_deferred_measurement_control_reading_support_mode_specific_info_fdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DeferredMeasurementControlReadingSupport_modeSpecificInfo_fdd to
 *       deferred_measurement_control_reading_support_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_deferred_measurement_control_reading_support_mode_specific_info_fdd
(
 UMTS_DeferredMeasurementControlReadingSupport_modeSpecificInfo_fdd     *pvalue,
 deferred_measurement_control_reading_support_mode_specific_info_fdd_t  *p_fdd 
 )
{
    p_fdd->intra_freq_meas_quantity_fdd =
        pvalue->intraFreqMeasQuantity_FDD;

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_intra_freq_meas_quantity_tdd_sib3_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_IntraFreqMeasQuantity_TDD_sib3List to
 *       intra_freq_meas_quantity_tdd_sib3_list_t
 *
 *******************************************************************************/
void convert_intra_freq_meas_quantity_tdd_sib3_list
(
 UMTS_IntraFreqMeasQuantity_TDD_sib3List    *pvalue,
 intra_freq_meas_quantity_tdd_sib3_list_t   *p_sib3_list 
 )
{
    p_sib3_list->n = pvalue->n;

    memcpy(&p_sib3_list->elem, &pvalue->elem,
            (sizeof(U32)*p_sib3_list->n));

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_deferred_measurement_control_reading_support_mode_specific_info_tdd
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DeferredMeasurementControlReadingSupport_modeSpecificInfo_tdd to
 *       deferred_measurement_control_reading_support_mode_specific_info_tdd_t
 *
 *******************************************************************************/
void convert_deferred_measurement_control_reading_support_mode_specific_info_tdd
(
 UMTS_DeferredMeasurementControlReadingSupport_modeSpecificInfo_tdd     *pvalue,
 deferred_measurement_control_reading_support_mode_specific_info_tdd_t  *p_tdd 
 )
{
    convert_intra_freq_meas_quantity_tdd_sib3_list(
            &pvalue->intraFreqMeasQuantity_TDDList,
            &p_tdd->intra_freq_meas_quantity_tdd_sib3_list);

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_deferred_measurement_control_reading_support_mode_specific_info
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DeferredMeasurementControlReadingSupport_modeSpecificInfo to
 *       deferred_measurement_control_reading_support_mode_specific_info_t
 *
 *******************************************************************************/
void convert_deferred_measurement_control_reading_support_mode_specific_info
(
 UMTS_DeferredMeasurementControlReadingSupport_modeSpecificInfo     *pvalue,
 deferred_measurement_control_reading_support_mode_specific_info_t  *p_mode_specific_info 
 )
{
    p_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_DeferredMeasurementControlReadingSupport_modeSpecificInfo_fdd)
    {
        convert_deferred_measurement_control_reading_support_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_mode_specific_info->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_DeferredMeasurementControlReadingSupport_modeSpecificInfo_tdd)
    {
        convert_deferred_measurement_control_reading_support_mode_specific_info_tdd(
                pvalue->u.tdd,
                &p_mode_specific_info->u.tdd); 
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_deferred_measurement_control_reading_support
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_DeferredMeasurementControlReadingSupport to
 *       deferred_measurement_control_reading_support_t
 *
 *******************************************************************************/
void convert_deferred_measurement_control_reading_support
(
 UMTS_DeferredMeasurementControlReadingSupport  *pvalue,
 deferred_measurement_control_reading_support_t *p_support 
 )
{
    if (pvalue->m.modeSpecificInfoPresent)
    {
        p_support->presence_bitmask |=
            UMTS_SIB_DEFERRED_MEASUREMENT_CONTROL_READING_SUPPORT_MODE_SPECIFIC_INFO_PRESENCE_FLAG;

        convert_deferred_measurement_control_reading_support_mode_specific_info(
                &pvalue->modeSpecificInfo,
                &p_support->mode_specific_info);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v770ext_ies
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v770ext_IEs to
 *       sysinfotype3_v770ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v770ext_ies
(
 UMTS_SysInfoType3_v770ext_IEs  *pvalue,
 sysinfotype3_v770ext_ies_t     *p_sysinfotype3_v770ext_ies 
 )
{
    if (pvalue->m.deferredMeasurementControlReadingSupportPresent)
    {
        p_sysinfotype3_v770ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_DEFERRED_MEASUREMENT_CONTROL_READING_SUPPORT_PRESENCE_FLAG;

        convert_deferred_measurement_control_reading_support(
                &pvalue->deferredMeasurementControlReadingSupport,
                &p_sysinfotype3_v770ext_ies->deferred_measurement_control_reading_support);
    }

    if (pvalue->m.q_QualMin_OffsetPresent)
    {
        p_sysinfotype3_v770ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_Q_QUALMIN_OFFSET_PRESENCE_FLAG;

        p_sysinfotype3_v770ext_ies->q_QualMin_offset =
            pvalue->q_QualMin_Offset;
    }

    if (pvalue->m.q_RxlevMin_OffsetPresent)
    {
        p_sysinfotype3_v770ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_Q_RXLEVMIN_OFFSET_PRESENCE_FLAG;

        p_sysinfotype3_v770ext_ies->q_RxlevMin_offset =
            pvalue->q_RxlevMin_Offset;
    }

    if (pvalue->m.mbsfnOnlyServicePresent)
    {
        p_sysinfotype3_v770ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_MBSFN_ONLYSERVICE_PRESENCE_FLAG;

        p_sysinfotype3_v770ext_ies->mbsfn_OnlyService =
            pvalue->mbsfnOnlyService; 
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_location_registration_access_class_barred_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_LocationRegistrationAccessClassBarredList to
 *       location_registration_access_class_barred_list_t
 *
 *******************************************************************************/
void convert_location_registration_access_class_barred_list
(
 UMTS_LocationRegistrationAccessClassBarredList     *pvalue,
 location_registration_access_class_barred_list_t   *p_list 
 )
{
    p_list->n = pvalue->n;

    memcpy(&p_list->elem, &pvalue->elem,
            (sizeof(U32)*p_list->n));

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_location_registration_parameters
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_LocationRegistrationParameters to
 *       location_registration_parameters_t
 *
 *******************************************************************************/
void convert_location_registration_parameters
(
 UMTS_LocationRegistrationParameters    *pvalue,
 location_registration_parameters_t     *p_paramters 
 )
{
    p_paramters->t = pvalue->t;

    if (pvalue->t == T_UMTS_LocationRegistrationParameters_noRestriction)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_LocationRegistrationParameters_restriction)
    {
        convert_location_registration_access_class_barred_list(
                pvalue->u.restriction,
                &p_paramters->u.restriction);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_paging_permission_with_access_control_parameters
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PagingPermissionWithAccessControlParameters to
 *       paging_permission_with_access_control_parameters_t
 *
 *******************************************************************************/
void convert_paging_permission_with_access_control_parameters
(
 UMTS_PagingPermissionWithAccessControlParameters   *pvalue,
 paging_permission_with_access_control_parameters_t *p_parameters 
 )
{
    p_parameters->paging_response_restriction_indicator =
        pvalue->pagingResponseRestrictionIndicator;

    p_parameters->location_registration_restriction_indicator =
        pvalue->locationRegistrationRestrictionIndicator;

    convert_location_registration_parameters(
            &pvalue->locationRegistration,
            &p_parameters->location_registration);

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_paging_permission_with_access_control_list
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PagingPermissionWithAccessControlList to
 *       paging_permission_with_access_control_list_t
 *
 *******************************************************************************/
void convert_paging_permission_with_access_control_list
(
 UMTS_PagingPermissionWithAccessControlList     *pvalue,
 paging_permission_with_access_control_list_t   *p_list 
 )
{
    if (pvalue->m.pagingPermissionWithAccessControlParametersForOperator1Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_PAGING_PERMISSION_WITH_ACCESS_CONTROL_PARAMETERS_FOR_OPERATOR1_PRESENCE_FLAG;

        convert_paging_permission_with_access_control_parameters(
                &pvalue->pagingPermissionWithAccessControlParametersForOperator1,
                &p_list->paging_permission_with_access_control_parameters_for_operator1);
    }

    if (pvalue->m.pagingPermissionWithAccessControlParametersForOperator2Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_PAGING_PERMISSION_WITH_ACCESS_CONTROL_PARAMETERS_FOR_OPERATOR2_PRESENCE_FLAG;

        convert_paging_permission_with_access_control_parameters(
                &pvalue->pagingPermissionWithAccessControlParametersForOperator2,
                &p_list->paging_permission_with_access_control_parameters_for_operator2);
    }

    if (pvalue->m.pagingPermissionWithAccessControlParametersForOperator3Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_PAGING_PERMISSION_WITH_ACCESS_CONTROL_PARAMETERS_FOR_OPERATOR3_PRESENCE_FLAG;

        convert_paging_permission_with_access_control_parameters(
                &pvalue->pagingPermissionWithAccessControlParametersForOperator3,
                &p_list->paging_permission_with_access_control_parameters_for_operator3);
    }

    if (pvalue->m.pagingPermissionWithAccessControlParametersForOperator4Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_PAGING_PERMISSION_WITH_ACCESS_CONTROL_PARAMETERS_FOR_OPERATOR4_PRESENCE_FLAG;

        convert_paging_permission_with_access_control_parameters(
                &pvalue->pagingPermissionWithAccessControlParametersForOperator4,
                &p_list->paging_permission_with_access_control_parameters_for_operator4);
    }

    if (pvalue->m.pagingPermissionWithAccessControlParametersForOperator5Present)
    {
        p_list->presence_bitmask |=
            UMTS_SIB_PAGING_PERMISSION_WITH_ACCESS_CONTROL_PARAMETERS_FOR_OPERATOR5_PRESENCE_FLAG;

        convert_paging_permission_with_access_control_parameters(
                &pvalue->pagingPermissionWithAccessControlParametersForOperator5,
                &p_list->paging_permission_with_access_control_parameters_for_operator5);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_paging_permission_with_access_control_for_shared_network
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_PagingPermissionWithAccessControlForSharedNetwork to
 *       paging_permission_with_access_control_for_shared_network_t
 *
 *******************************************************************************/
void convert_paging_permission_with_access_control_for_shared_network
(
 UMTS_PagingPermissionWithAccessControlForSharedNetwork     *pvalue,
 paging_permission_with_access_control_for_shared_network_t *p_shared_network 
 )
{
    p_shared_network->t = pvalue->t;

    if (pvalue->t == T_UMTS_PagingPermissionWithAccessControlForSharedNetwork_pagingPermissionWithAccessControlList)
    {
        convert_paging_permission_with_access_control_list(
                pvalue->u.pagingPermissionWithAccessControlList,
                &p_shared_network->u.paging_permission_with_access_control_list); 
    }
    else if (pvalue->t == T_UMTS_PagingPermissionWithAccessControlForSharedNetwork_pagingPermissionWithAccessControlForAll)
    {
        convert_paging_permission_with_access_control_parameters(
                pvalue->u.pagingPermissionWithAccessControlForAll,
                &p_shared_network->u.paging_permission_with_access_control_for_all); 
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v830ext_ies
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v830ext_IEs to
 *       sysinfotype3_v830ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v830ext_ies
(
 UMTS_SysInfoType3_v830ext_IEs  *pvalue,
 sysinfotype3_v830ext_ies_t     *p_sysinfotype3_v830ext_ies 
 )
{
    if (pvalue->m.pagingPermissionWithAccessControlParametersForPLMNOfMIBPresent)
    {
        p_sysinfotype3_v830ext_ies->presence_bitmask |=
            UMTS_SIB_PAGING_PERMISSION_WITH_ACCESS_CONTROL_PARAMETERS_FOR_PLMN_OF_MIB_PRESENCE_FLAG;

        convert_paging_permission_with_access_control_parameters(
                &pvalue->pagingPermissionWithAccessControlParametersForPLMNOfMIB,
                &p_sysinfotype3_v830ext_ies->paging_permission_with_access_control_parameters_for_plmn_of_mib);
    }

    if (pvalue->m.pagingPermissionWithAccessControlParametersForSharedNetworkPresent)
    {
        p_sysinfotype3_v830ext_ies->presence_bitmask |=
            UMTS_SIB_PAGING_PERMISSION_WITH_ACCESS_CONTROL_FOR_SHARED_NETWORK_PRESENCE_FLAG;

        convert_paging_permission_with_access_control_for_shared_network(
                &pvalue->pagingPermissionWithAccessControlParametersForSharedNetwork,
                &p_sysinfotype3_v830ext_ies->paging_permission_with_access_control_for_shared_network);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_csg_identity
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CSG_Identity to
 *       csg_identity_t
 *
 *******************************************************************************/
void convert_csg_identity
(
 UMTS_CSG_Identity  *pvalue,
 csg_identity_t     *p_csg_identity 
 )
{
    p_csg_identity->n = pvalue->numbits;

    memcpy(&p_csg_identity->data, &pvalue->data,
            (sizeof(U8)*p_csg_identity->n));

    return;
}



/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v860ext_ies
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v860ext_IEs to
 *       sysinfotype3_v860ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v860ext_ies
(
 UMTS_SysInfoType3_v860ext_IEs  *pvalue,
 sysinfotype3_v860ext_ies_t     *p_sysinfotype3_v860ext_ies 
 )
{
    if (pvalue->m.csgIdentityPresent)
    {
        p_sysinfotype3_v860ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_CSG_IDENTITY_PRESENCE_FLAG;

        convert_csg_identity(
                &pvalue->csgIdentity,
                &p_sysinfotype3_v860ext_ies->csg_identity);
    }

    if (pvalue->m.csg_PSCSplitInfoPresent)
    {
        p_sysinfotype3_v860ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_CSG_PSC_SPLIT_INFO_PRESENCE_FLAG;

        convert_csg_psc_split_info(
                &pvalue->csg_PSCSplitInfo,
                &p_sysinfotype3_v860ext_ies->csg_psc_split_info);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_cell_access_restriction_v870ext
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_CellAccessRestriction_v870ext to
 *       cell_access_restriction_v870ext_t
 *
 *******************************************************************************/
void convert_cell_access_restriction_v870ext
(
 UMTS_CellAccessRestriction_v870ext     *pvalue,
 cell_access_restriction_v870ext_t      *p_restriction 
 )
{
    if (pvalue->m.cellReservedForCSGPresent)
    {
        p_restriction->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_RESERVED_FOR_CSG_PRESENCE_FLAG;

        p_restriction->cell_reserved_for_csg =
            pvalue->cellReservedForCSG;
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v870ext_ies
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v870ext_IEs to
 *       sysinfotype3_v870ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v870ext_ies
(
 UMTS_SysInfoType3_v870ext_IEs  *pvalue,
 sysinfotype3_v870ext_ies_t     *p_sysinfotype3_v870ext_ies 
 )
{
    if (pvalue->m.cellAccessRestrictionPresent)
    {
        p_sysinfotype3_v870ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_CELL_ACCESS_RESTRICTION_PRESENCE_FLAG;

        convert_cell_access_restriction_v870ext(
                &pvalue->cellAccessRestriction,
                &p_sysinfotype3_v870ext_ies->cell_access_restriction);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v920ext_ies
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v920ext_IEs to
 *       sysinfotype3_v920ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v920ext_ies
(
 UMTS_SysInfoType3_v920ext_IEs  *pvalue,
 sysinfotype3_v920ext_ies_t     *p_sysinfotype3_v920ext_ies
 )
{
    if (pvalue->m.imsEmergencySupportIndicatorPresent)
    {
        p_sysinfotype3_v920ext_ies->presence_bitmask |=
            UMTS_SIB_TYPE_3_IMS_EMERGENCY_SUPPORT_INDICATOR_PRESENCE_FLAG;

        p_sysinfotype3_v920ext_ies->ims_emergency_support_indicator =
            pvalue->imsEmergencySupportIndicator;
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce_nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension_v860NonCriticalExtension_v870NonCriticalExtension_v900NonCriticalExtension_nonCriticalExtensions to
 *       sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce_nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce_nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension_v860NonCriticalExtension_v870NonCriticalExtension_v900NonCriticalExtension_nonCriticalExtensions  *pvalue,
 sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce_nce_t    *p_nce 
 )
{
    p_nce->__dummy__ = pvalue->__dummy__;
    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension_v860NonCriticalExtension_v870NonCriticalExtension_v900NonCriticalExtension to
 *       sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension_v860NonCriticalExtension_v870NonCriticalExtension_v900NonCriticalExtension    *pvalue,
 sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce_t    *p_nce 
 )
{
    convert_sysinfotype3_v920ext_ies(
            &pvalue->sysInfoType3_v920ext,
            &p_nce->sys_info_type3_v920ext);

    if (pvalue->m.nonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_V590_V5C0_V670_V770_V830_V860_V870_V900_NCE_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce_nce(
                &pvalue->nonCriticalExtensions,
                &p_nce->v900nce_nce);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension_v860NonCriticalExtension_v870NonCriticalExtension to
 *       sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension_v860NonCriticalExtension_v870NonCriticalExtension *pvalue,
 sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_t    *p_nce 
 )
{
    convert_sysinfotype3_v870ext_ies(
            &pvalue->sysInfoType3_v870ext,
            &p_nce->sys_info_type3_v870ext);

    if (pvalue->m.v900NonCriticalExtensionPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_V590_V5C0_V670_V770_V830_V860_V870_V900_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce_v900nce(
                &pvalue->v900NonCriticalExtension,
                &p_nce->v900_non_critical_extension);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension_v860NonCriticalExtension to
 *       sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension_v860NonCriticalExtension  *pvalue,
 sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_t    *p_nce 
 )
{
    convert_sysinfotype3_v860ext_ies(
            &pvalue->sysInfoType3_v860ext,
            &p_nce->sysInfoType3_v860ext);

    if (pvalue->m.v870NonCriticalExtensionPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_V590_V5C0_V670_V770_V830_V860_V870_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce_v870nce(
                &pvalue->v870NonCriticalExtension,
                &p_nce->v870_non_critical_extension);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension to
 *       sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension_v830NonCriticalExtension   *pvalue,
 sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_t *p_nce 
 )
{
    convert_sysinfotype3_v830ext_ies(
            &pvalue->sysInfoType3_v830ext,
            &p_nce->sys_info_type3_v830ext);

    if (pvalue->m.v860NonCriticalExtensionPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_V590_V5C0_V670_V770_V830_V860_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce_v860nce(
                &pvalue->v860NonCriticalExtension,
                &p_nce->v860non_critical_extension);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension to
 *       sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension_v770NonCriticalExtension    *pvalue,
 sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_t    *p_nce 
 )
{
    convert_sysinfotype3_v770ext_ies(
            &pvalue->sysInfoType3_v770ext,
            &p_nce->sys_info_type3_v770ext);

    if (pvalue->m.v830NonCriticalExtensionPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_V590_V5C0_V670_V770_V830_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce_v830nce(
                &pvalue->v830NonCriticalExtension,
                &p_nce->v830_non_critical_extension);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension to
 *       sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension_v670NonCriticalExtension *pvalue,
 sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_t    *p_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce 
 )
{
    convert_sysinfotype3_v670ext(
            &pvalue->sysInfoType3_v670ext,
            &p_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce->sys_info_type3_v670ext);

    if (pvalue->m.v770NonCriticalExtensionPresent)
    {
        p_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_V590_V5C0_V670_V770_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce_v770nce(
                &pvalue->v770NonCriticalExtension,
                &p_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce->v770non_critical_extension);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce_v5c0nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension to
 *       sysinfotype3_v4b0nces_v590nce_v5c0nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce_v5c0nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension_v5c0NoncriticalExtension  *pvalue,
 sysinfotype3_v4b0nces_v590nce_v5c0nce_t        *p_sysinfotype3_v4b0nces_v590nce_v5c0nce 
 )
{
    convert_sysinfotype3_v5c0ext_ies(
            &pvalue->sysInfoType3_v5c0ext,
            &p_sysinfotype3_v4b0nces_v590nce_v5c0nce->sys_info_type3_v5c0ext);

    if (pvalue->m.v670NonCriticalExtensionPresent)
    {
        p_sysinfotype3_v4b0nces_v590nce_v5c0nce->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_NC_EXT_V590_V5C0_V670_V770_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce_v5c0nce_v670nce(
                &pvalue->v670NonCriticalExtension,
                &p_sysinfotype3_v4b0nces_v590nce_v5c0nce->v670non_critical_extension);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0nces_v590nce
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension to
 *       sysinfotype3_v4b0nces_v590nce_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0nces_v590nce
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions_v590NonCriticalExtension   *pvalue,
 sysinfotype3_v4b0nces_v590nce_t        *p_sysinfotype3_v4b0nces_v590nce 
 )
{
    convert_sysinfotype3_v590ext(
            &pvalue->sysInfoType3_v590ext,
            &p_sysinfotype3_v4b0nces_v590nce->sys_info_type3_v590ext);

    if (pvalue->m.v5c0NoncriticalExtensionPresent)
    {
        p_sysinfotype3_v4b0nces_v590nce->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_V590_V5C0_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce_v5c0nce(
                &pvalue->v5c0NoncriticalExtension,
                &p_sysinfotype3_v4b0nces_v590nce->v5c0noncritical_extension);
    }

    return;
}

/******************************************************************************                                               
 *   FUNCTION NAME: convert_sysinfotype3_v4b0_nc_extensions
 *
 *   DESCRIPTION:
 *       This function converts 
 *       UMTS_SysInfoType3_v4b0NonCriticalExtensions to
 *       sysinfotype3_v4b0_nc_extensions_t
 *
 *******************************************************************************/
void convert_sysinfotype3_v4b0_nc_extensions
(
 UMTS_SysInfoType3_v4b0NonCriticalExtensions    *pvalue,
 sysinfotype3_v4b0_nc_extensions_t              *p_sysinfotype3_v4b0_nc_extensions 
 )
{
    convert_sysinfotype3_v4b0ext_ies_t(
            &pvalue->sysInfoType3_v4b0ext,
            &p_sysinfotype3_v4b0_nc_extensions->sysinfotype3_v4b0ext_ies);

    if (pvalue->m.v590NonCriticalExtensionPresent)
    {
        p_sysinfotype3_v4b0_nc_extensions->presence_bitmask |=
            UMTS_SIB_TYPE_3_V4B0_V590_NCE_PRESENCE_FLAG;

        convert_sysinfotype3_v4b0nces_v590nce(
                &pvalue->v590NonCriticalExtension,
                &p_sysinfotype3_v4b0_nc_extensions->v590NonCriticalExtension); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib3
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType3 to
 *       umts_sib_type_3_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       umts_sib_type_3_info   - Pointer to decoded SIB3
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib3
(
 umts_sib_type_3_info_t  *umts_sib_type_3_info
 )
{
    UMTS_SysInfoType3   sys_info_type_3;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_3_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_3, 0, sizeof(UMTS_SysInfoType3));

    if( 0 != (asn1PD_UMTS_SysInfoType3( &ctxt, &sys_info_type_3)))
    {
        printf("umts_convert_sib3:asn decoding failed\n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType3("Decoded SysInfoType3\n", &sys_info_type_3);
    memset(umts_sib_type_3_info, 0, sizeof(umts_sib_type_3_info_t)); 

    umts_sib_type_3_info->sib_4_indicator = sys_info_type_3.sib4indicator;

    umts_sib_type_3_info->cell_identity.numbits =
        sys_info_type_3.cellIdentity.numbits;

    memcpy (umts_sib_type_3_info->cell_identity.data, 
            sys_info_type_3.cellIdentity.data, 
            sys_info_type_3.cellIdentity.numbits);

    convert_cell_select_reselect_infoSIB_3_4(
            &sys_info_type_3.cellSelectReselectInfo,
            &umts_sib_type_3_info->cell_select_reselect_info);

    convert_cell_access_restriction(
            &sys_info_type_3.cellAccessRestriction,
            &umts_sib_type_3_info->cell_access_restriction);

    convert_sysinfotype3_v4b0_nc_extensions(
            &sys_info_type_3.v4b0NonCriticalExtensions,
            &umts_sib_type_3_info->v4b0_nc_extensions);

    rtFreeContext(&ctxt);
    return SUCCESS;
}

/************SIB 5 *****************************************/

/******************************************************************************
 *   FUNCTION NAME: convert_sf256_and_code_num
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SF256_AndCodeNumber to
 *      sf256_and_code_num_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sf256_and_code_num
(
 UMTS_SF256_AndCodeNumber   *pvalue,
 sf256_and_code_number_t    *p_sf256_and_code_num 
 )
{
    p_sf256_and_code_num->t = pvalue->t;

    if (pvalue->t == T_UMTS_SF256_AndCodeNumber_sf4)
    {
        p_sf256_and_code_num->u.sf4 = pvalue->u.sf4; 
    }
    else if (pvalue->t == T_UMTS_SF256_AndCodeNumber_sf8)
    {
        p_sf256_and_code_num->u.sf8 = pvalue->u.sf8; 
    }
    else if (pvalue->t == T_UMTS_SF256_AndCodeNumber_sf16)
    {
        p_sf256_and_code_num->u.sf16 = pvalue->u.sf16; 
    }
    else if (pvalue->t == T_UMTS_SF256_AndCodeNumber_sf32)
    {
        p_sf256_and_code_num->u.sf32 = pvalue->u.sf32; 
    }
    else if (pvalue->t == T_UMTS_SF256_AndCodeNumber_sf64)
    {
        p_sf256_and_code_num->u.sf64 = pvalue->u.sf64; 
    }
    else if (pvalue->t == T_UMTS_SF256_AndCodeNumber_sf128)
    {
        p_sf256_and_code_num->u.sf128 = pvalue->u.sf128; 
    }
    else if (pvalue->t == T_UMTS_SF256_AndCodeNumber_sf256)
    {
        p_sf256_and_code_num->u.sf256 = pvalue->u.sf256; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_cpich_info
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SecondaryCPICH_Info to
 *      secondary_cpich_info_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_secondary_cpich_info
(
 UMTS_SecondaryCPICH_Info   *pvalue,
 secondary_cpich_info_t     *p_secondary_cpich_info 
 )
{
    if (pvalue->m.secondaryDL_ScramblingCodePresent)
    {
        p_secondary_cpich_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_SECONDARY_CCPCH_INFO_MODESPECIFIC_INFO_FDD_SECOND_CPICH_INFO_SCRAMBLING_CODE_PRESENCE_FLAG;

        p_secondary_cpich_info->secondaryDL_ScramblingCode = pvalue->secondaryDL_ScramblingCode;
    }

    p_secondary_cpich_info->channelisation_Code = pvalue->channelisationCode;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_modespecific_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SecondaryCCPCH_Info_modeSpecificInfo_fdd to
 *      secondary_ccpch_info_modespecific_info_fdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_modespecific_info_fdd
(
 UMTS_SecondaryCCPCH_Info_modeSpecificInfo_fdd  *pvalue,
 secondary_ccpch_info_modespecific_info_fdd_t   *p_secondary_ccpch_info_modespecific_info_fdd 
 )
{
    p_secondary_ccpch_info_modespecific_info_fdd->dummy1_PCPICH_usageForForChannelEst =
        pvalue->dummy1;

    if (pvalue->m.dummy2Present)
    {
        p_secondary_ccpch_info_modespecific_info_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_SECONDARY_CCPCH_INFO_MODESPECIFIC_INFO_FDD_DUMMY2_PRESENCE_FLAG;

        convert_secondary_cpich_info(
                &pvalue->dummy2,
                &p_secondary_ccpch_info_modespecific_info_fdd->dummy2);
    }

    if (pvalue->m.secondaryScramblingCodePresent)
    {
        p_secondary_ccpch_info_modespecific_info_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_SECONDARY_CCPCH_INFO_MODESPECIFIC_INFO_FDD_SEC_SCRAMBLING_CODE_PRESENCE_FLAG;

        p_secondary_ccpch_info_modespecific_info_fdd->secondary_ScramblingCode =
            pvalue->secondaryScramblingCode;
    }

    p_secondary_ccpch_info_modespecific_info_fdd->sttd_indicator =
        pvalue->sttd_Indicator;

    convert_sf256_and_code_num(
            &pvalue->sf_AndCodeNumber,
            &p_secondary_ccpch_info_modespecific_info_fdd->sf_andCodeNumber);

    p_secondary_ccpch_info_modespecific_info_fdd->pilot_SymbolExistence =
        pvalue->pilotSymbolExistence;

    p_secondary_ccpch_info_modespecific_info_fdd->tfci_Existence =
        pvalue->tfci_Existence;

    p_secondary_ccpch_info_modespecific_info_fdd->positionFixedOrFlexible =
        pvalue->positionFixedOrFlexible;

    p_secondary_ccpch_info_modespecific_info_fdd->timingOffset =
        pvalue->timingOffset;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_repetition_period_length_and_offset
 *
 *   DESCRIPTION:
 *      This function converts UMTS_RepetitionPeriodLengthAndOffset to
 *      repetition_period_length_and_offset_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_repetition_period_length_and_offset
(
 UMTS_RepetitionPeriodLengthAndOffset   *pvalue,
 repetition_period_length_and_offset_t  *p_repetition_period_length_and_offset 
 )
{
    p_repetition_period_length_and_offset->t = pvalue->t;

    if (pvalue->t == T_UMTS_RepetitionPeriodLengthAndOffset_repetitionPeriod1)
    {
        /* not used */ 
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodLengthAndOffset_repetitionPeriod2)
    {
        p_repetition_period_length_and_offset->u.repetitionPeriod2.offset =
            pvalue->u.repetitionPeriod2->offset;
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodLengthAndOffset_repetitionPeriod4)
    {
        p_repetition_period_length_and_offset->u.repetitionPeriod4.length =
            pvalue->u.repetitionPeriod4->length;

        p_repetition_period_length_and_offset->u.repetitionPeriod4.offset =
            pvalue->u.repetitionPeriod4->offset;
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodLengthAndOffset_repetitionPeriod8)
    {
        p_repetition_period_length_and_offset->u.repetitionPeriod8.length =
            pvalue->u.repetitionPeriod8->length;

        p_repetition_period_length_and_offset->u.repetitionPeriod8.offset =
            pvalue->u.repetitionPeriod8->offset;
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodLengthAndOffset_repetitionPeriod16)
    {
        p_repetition_period_length_and_offset->u.repetitionPeriod16.length =
            pvalue->u.repetitionPeriod16->length;

        p_repetition_period_length_and_offset->u.repetitionPeriod16.offset =
            pvalue->u.repetitionPeriod16->offset;
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodLengthAndOffset_repetitionPeriod32)
    {
        p_repetition_period_length_and_offset->u.repetitionPeriod32.length =
            pvalue->u.repetitionPeriod32->length;

        p_repetition_period_length_and_offset->u.repetitionPeriod32.offset =
            pvalue->u.repetitionPeriod32->offset;
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodLengthAndOffset_repetitionPeriod64)
    {
        p_repetition_period_length_and_offset->u.repetitionPeriod64.length =
            pvalue->u.repetitionPeriod64->length;

        p_repetition_period_length_and_offset->u.repetitionPeriod64.offset =
            pvalue->u.repetitionPeriod64->offset;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_timeslot_info_sccpch
 *
 *   DESCRIPTION:
 *      This function converts UMTS_CommonTimeslotInfoSCCPCH to
 *      common_timeslot_info_sccpch_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_timeslot_info_sccpch
(
 UMTS_CommonTimeslotInfoSCCPCH  *pvalue,
 common_timeslot_info_sccpch_t  *p_common_timeslot_info_sccpch 
 )
{
    p_common_timeslot_info_sccpch->second_InterleavingMode = pvalue->secondInterleavingMode;

    if (pvalue->m.tfci_CodingPresent)
    {
        p_common_timeslot_info_sccpch->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_SCCPCH_MODESPECIFIC_TDD_COMMON_TIMESLOT_TFCI_CODING_PRESENCE_FLAG;

        p_common_timeslot_info_sccpch->tfci_Coding = pvalue->tfci_Coding;
    }

    p_common_timeslot_info_sccpch->puncturing_Limit = pvalue->puncturingLimit;

    if (pvalue->m.repetitionPeriodLengthAndOffsetPresent)
    {
        p_common_timeslot_info_sccpch->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_SCCPCH_MODESPECIFIC_TDD_COMMON_TIMESLOT_REPETITION_PRD_LEN_OFFSET_PRESENCE_FLAG;

        convert_repetition_period_length_and_offset(
                &pvalue->repetitionPeriodLengthAndOffset,
                &p_common_timeslot_info_sccpch->repetitionPeriodLengthAndOffset);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_channelisation_code_list
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SCCPCH_ChannelisationCodeList to
 *      sccpch_channelisation_code_list_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sccpch_channelisation_code_list
(
 UMTS_SCCPCH_ChannelisationCodeList     *pvalue,
 sccpch_channelisation_code_list_t      *p_sccpch_channelisation_code_list 
 )
{
    U32 index;

    p_sccpch_channelisation_code_list->n = pvalue->n;

    for (index = 0; index < pvalue->n; index ++)
    {
        p_sccpch_channelisation_code_list->elem[index] = pvalue->elem[index]; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_burst_type_type3_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode to
 *      midamble_shift_and_burst_type_burst_type_type3_midamble_allocation_mode_t 
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_burst_type_type3_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode      *pvalue,
 midamble_shift_and_burst_type_burst_type_type3_midamble_allocation_mode_t  *p_midamble_allocation_mode
 )
{
    p_midamble_allocation_mode->t = pvalue->t;

    if (pvalue->t == 
            T_UMTS_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode_defaultMidamble)
    {
        /* unused */
    }
    else if (pvalue->t ==
            T_UMTS_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode_ueSpecificMidamble)
    {
        p_midamble_allocation_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_burst_type_type3
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_burstType_type3 to
 *      midamble_shift_and_burst_type_burst_type_type3_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_burst_type_type3
(
 UMTS_MidambleShiftAndBurstType_burstType_type3     *pvalue,
 midamble_shift_and_burst_type_burst_type_type3_t   *p_info 
 )
{
    p_info->midamble_configuration_burst_type1_and_3 =
        pvalue->midambleConfigurationBurstType1and3;

    convert_midamble_shift_and_burst_type_burst_type_type3_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_info->midamble_allocation_mode);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_burst_type_type2_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode to
 *      midamble_shift_and_burst_type_burst_type_type2_midamble_allocation_mode_t 
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_burst_type_type2_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode          *pvalue,
 midamble_shift_and_burst_type_burst_type_type2_midamble_allocation_mode_t    *p_midamble_allocation_mode
 )
{
    p_midamble_allocation_mode->t = pvalue->t;

    if (pvalue->t == 
            T_UMTS_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode_defaultMidamble)
    {
        /* unused */
    }
    else if (pvalue->t ==
            T_UMTS_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode_commonMidamble)
    {
        /* unused */
    }
    else if (pvalue->t ==
            T_UMTS_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode_ueSpecificMidamble)
    {
        p_midamble_allocation_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_burst_type_type2
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_burstType_type2 to
 *      midamble_shift_and_burst_type_burst_type_type2_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_burst_type_type2
(
 UMTS_MidambleShiftAndBurstType_burstType_type2     *pvalue,
 midamble_shift_and_burst_type_burst_type_type2_t   *p_info
 )
{
    p_info->midamble_configuration_burst_type2 =
        pvalue->midambleConfigurationBurstType2;

    convert_midamble_shift_and_burst_type_burst_type_type2_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_info->midamble_allocation_mode);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_burst_type_type1_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode to
 *      midamble_shift_and_burst_type_burst_type_type1_midamble_allocation_mode_t 
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_burst_type_type1_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode      *pvalue,
 midamble_shift_and_burst_type_burst_type_type1_midamble_allocation_mode_t  *p_midamble_allocation_mode
 )
{
    p_midamble_allocation_mode->t = pvalue->t;

    if (pvalue->t == 
            T_UMTS_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode_defaultMidamble)
    {
        /* unused*/ 
    }
    else if (pvalue->t ==
            T_UMTS_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode_commonMidamble)
    {
        /* unused */
    }
    else if (pvalue->t ==
            T_UMTS_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode_ueSpecificMidamble)
    {
        p_midamble_allocation_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_burst_type_type1
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_burstType_type1 to
 *      midamble_shift_and_burst_type_burst_type_type1_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_burst_type_type1
(
 UMTS_MidambleShiftAndBurstType_burstType_type1     *pvalue,
 midamble_shift_and_burst_type_burst_type_type1_t   *p_info 
 )
{
    p_info->midamble_configuration_burst_type1_and_3 =
        pvalue->midambleConfigurationBurstType1and3;

    convert_midamble_shift_and_burst_type_burst_type_type1_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_info->midamble_allocation_mode);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType to
 *      midamble_shift_and_burst_type_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type
(
 UMTS_MidambleShiftAndBurstType  *pvalue,
 midamble_shift_and_burst_type_t *p_midamble_shift_n_burst_type
 )
{
    p_midamble_shift_n_burst_type->burst_type.t = pvalue->burstType.t;

    if (pvalue->burstType.t == T_UMTS_MidambleShiftAndBurstType_burstType_type1)
    {
        convert_midamble_shift_and_burst_type_burst_type_type1(
                pvalue->burstType.u.type1,
                &p_midamble_shift_n_burst_type->burst_type.u.type1);
    }
    else if (pvalue->burstType.t == T_UMTS_MidambleShiftAndBurstType_burstType_type2)
    {
        convert_midamble_shift_and_burst_type_burst_type_type2(
                pvalue->burstType.u.type2,
                &p_midamble_shift_n_burst_type->burst_type.u.type2);
    }
    else if (pvalue->burstType.t == T_UMTS_MidambleShiftAndBurstType_burstType_type3)
    {
        convert_midamble_shift_and_burst_type_burst_type_type3(
                pvalue->burstType.u.type3,
                &p_midamble_shift_n_burst_type->burst_type.u.type3);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_individual_timeslot_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_IndividualTimeslotInfo to
 *      individual_timeslot_info_t
 *
 *******************************************************************************/
void convert_individual_timeslot_info
(
 UMTS_IndividualTimeslotInfo *pvalue,
 individual_timeslot_info_t  *p_individual_timeslot_info
 )
{
    p_individual_timeslot_info->timeslot_num = pvalue->timeslotNumber;
    p_individual_timeslot_info->tfci_existence = pvalue->tfci_Existence;

    convert_midamble_shift_and_burst_type(
            &pvalue->midambleShiftAndBurstType,
            &p_individual_timeslot_info->midamble_shift_and_burst_type);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_modespecific_info_tdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SecondaryCCPCH_Info_modeSpecificInfo_tdd to
 *      secondary_ccpch_info_modespecific_info_tdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_modespecific_info_tdd
(
 UMTS_SecondaryCCPCH_Info_modeSpecificInfo_tdd  *pvalue,
 secondary_ccpch_info_modespecific_info_tdd_t   *p_secondary_ccpch_info_modespecific_info_tdd 
 )
{
    convert_common_timeslot_info_sccpch(
            &pvalue->commonTimeslotInfo,
            &p_secondary_ccpch_info_modespecific_info_tdd->commonTimeSlot_Info);

    convert_individual_timeslot_info(
            &pvalue->individualTimeslotInfo,
            &p_secondary_ccpch_info_modespecific_info_tdd->individualTimeSlot_Info);

    convert_sccpch_channelisation_code_list(
            &pvalue->channelisationCode,
            &p_secondary_ccpch_info_modespecific_info_tdd->channelisation_Code);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SecondaryCCPCH_Info to
 *      secondary_ccpch_info_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_secondary_ccpch_info
( 
 UMTS_SecondaryCCPCH_Info   *pvalue,
 secondary_ccpch_info_t     *p_secondary_ccpch_info
 )
{
    p_secondary_ccpch_info->modeSpecific_Info.t = pvalue->modeSpecificInfo.t;

    if (pvalue->modeSpecificInfo.t == T_UMTS_SecondaryCCPCH_Info_modeSpecificInfo_fdd )
    {
        convert_secondary_ccpch_info_modespecific_info_fdd(
                pvalue->modeSpecificInfo.u.fdd,
                &p_secondary_ccpch_info->modeSpecific_Info.u.fdd);
    }
    else if (pvalue->modeSpecificInfo.t == T_UMTS_SecondaryCCPCH_Info_modeSpecificInfo_tdd)
    {
        convert_secondary_ccpch_info_modespecific_info_tdd(
                pvalue->modeSpecificInfo.u.tdd,
                &p_secondary_ccpch_info->modeSpecific_Info.u.tdd); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_fach_pch_information_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_FACH_PCH_InformationList to
 *      fach_pch_information_list_t
 *
 *******************************************************************************/
void convert_fach_pch_information_list
(
 UMTS_FACH_PCH_InformationList  *pvalue,
 fach_pch_information_list_t    *p_fach_pch_information_list 
 )
{
    UMTS_FACH_PCH_Information   *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_fach_pch_information_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_FACH_PCH_Information*)pnode->data;

        convert_transport_format_set(
                &pdata->transportFormatSet,
                &p_fach_pch_information_list->fach_pch_info[index].transport_format_set);

        p_fach_pch_information_list->fach_pch_info[index].transport_channel_identity = 
            pdata->transportChannelIdentity; 

        p_fach_pch_information_list->fach_pch_info[index].ctch_indicator =
            pdata->ctch_Indicator;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pich_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PICH_Info_fdd to
 *      pich_info_fdd and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_pich_info_fdd
(
 UMTS_PICH_Info_fdd     *pvalue,
 pich_info_fdd          *p_pich_info_fdd 
 )
{
    p_pich_info_fdd->channelisation_Code256 = pvalue->channelisationCode256;
    p_pich_info_fdd->pi_CountPerFrame = pvalue->pi_CountPerFrame;
    p_pich_info_fdd->sttd_Indicator = pvalue->sttd_Indicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_rep_per_length_offset_pich
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_RepPerLengthOffset_PICH to
 *      rep_per_length_offset_pich_t
 *
 *******************************************************************************/
void convert_rep_per_length_offset_pich
(
 UMTS_RepPerLengthOffset_PICH   *pvalue,
 rep_per_length_offset_pich_t   *p_rep_perlength_offset_pich 
 )
{
    p_rep_perlength_offset_pich->t = pvalue->t;

    if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp4_2)
    {
        p_rep_perlength_offset_pich->u.rpp4_2 = pvalue->u.rpp4_2; 
    }
    else if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp8_2)
    {
        p_rep_perlength_offset_pich->u.rpp8_2 = pvalue->u.rpp8_2; 
    }
    else if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp8_4)
    {
        p_rep_perlength_offset_pich->u.rpp8_4 = pvalue->u.rpp8_4;
    }
    else if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp16_2)
    {
        p_rep_perlength_offset_pich->u.rpp16_2 = pvalue->u.rpp16_2; 
    }
    else if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp16_4)
    {
        p_rep_perlength_offset_pich->u.rpp16_4 = pvalue->u.rpp16_4; 
    }
    else if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp32_2)
    {
        p_rep_perlength_offset_pich->u.rpp32_2 = pvalue->u.rpp32_2; 
    }
    else if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp32_4)
    {
        p_rep_perlength_offset_pich->u.rpp32_4 = pvalue->u.rpp32_4; 
    }
    else if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp64_2)
    {
        p_rep_perlength_offset_pich->u.rpp64_2 = pvalue->u.rpp64_2; 
    }
    else if (pvalue->t == T_UMTS_RepPerLengthOffset_PICH_rpp64_4)
    {
        p_rep_perlength_offset_pich->u.rpp64_4 = pvalue->u.rpp64_4;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pich_info_tdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PICH_Info_tdd to
 *      pich_info_tdd and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_pich_info_tdd
(
 UMTS_PICH_Info_tdd     *pvalue,
 pich_info_tdd          *p_pich_info_tdd 
 )
{
    if (pvalue->m.channelisationCodePresent) 
    {
        p_pich_info_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_SCCPCH_SYSINFO_PICH_TDD_INFO_CHANNELISATION_CODE_PRESENCE_FLAG;

        p_pich_info_tdd->channelisation_code = pvalue->channelisationCode;
    }

    if (pvalue->m.timeslotPresent)
    {
        p_pich_info_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_SCCPCH_SYSINFO_PICH_TDD_INFO_TIMESLOT_NUMBER_PRESENCE_FLAG;

        p_pich_info_tdd->timeslot_number = pvalue->timeslot;
    }

    convert_midamble_shift_and_burst_type(
            &pvalue->midambleShiftAndBurstType,
            &p_pich_info_tdd->midamble_shift_and_burst_type);

    if (pvalue->m.repetitionPeriodLengthOffsetPresent)
    {
        p_pich_info_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_SCCPCH_SYSINFO_PICH_TDD_INFO_REPETITION_PRD_LEN_OFF_PRESENCE_FLAG;

        convert_rep_per_length_offset_pich(
                &pvalue->repetitionPeriodLengthOffset,
                &p_pich_info_tdd->rep_per_length_offset_pich);
    }

    p_pich_info_tdd->paging_indicator_length = pvalue->pagingIndicatorLength;
    p_pich_info_tdd->n_gap = pvalue->n_GAP;
    p_pich_info_tdd->n_pch = pvalue->n_PCH;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pich_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PICH_Info to
 *      pich_info_t 
 *
 *******************************************************************************/
void convert_pich_info
(
 UMTS_PICH_Info     *pvalue,
 pich_info_t        *p_pich_info 
 )
{
    p_pich_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_PICH_Info_fdd)
    {
        convert_pich_info_fdd(
                pvalue->u.fdd,
                &p_pich_info->u.fdd);  
    }
    else if (pvalue->t == T_UMTS_PICH_Info_tdd)
    {
        convert_pich_info_tdd(
                pvalue->u.tdd,
                &p_pich_info->u.tdd); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_signalled_gain_factors_mode_specific_info
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SignalledGainFactors_modeSpecificInfo to
 *      signalled_gain_factors_mode_specific_info_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_signalled_gain_factors_mode_specific_info
(
 UMTS_SignalledGainFactors_modeSpecificInfo     *pvalue,
 signalled_gain_factors_mode_specific_info_t    *p_signalled_gain_factors_mode_specific_info 
 )
{
    p_signalled_gain_factors_mode_specific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_SignalledGainFactors_modeSpecificInfo_fdd)
    {
        p_signalled_gain_factors_mode_specific_info->u.fdd.gain_factor_beta_c =
            pvalue->u.fdd->gainFactorBetaC;   
    }
    else if (pvalue->t == T_UMTS_SignalledGainFactors_modeSpecificInfo_tdd)
    {
        /* not used */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_signalled_gain_factors
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SignalledGainFactors to
 *      signalled_gain_factors_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_signalled_gain_factors
(
 UMTS_SignalledGainFactors      *pvalue,
 signalled_gain_factors_t       *p_signalled_gain_factors 
 )
{
    convert_signalled_gain_factors_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_signalled_gain_factors->mode_specific_info);

    p_signalled_gain_factors->gain_factor_beta_d = pvalue->gainFactorBetaD;

    if (pvalue->m.referenceTFC_IDPresent)
    {
        p_signalled_gain_factors->presence_bitmask |=
            UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC2BIT_ELEMENT_SIGNALLED_GAIN_FACTORS_REF_TFC_ID_PRESENCE_FLAG;

        p_signalled_gain_factors->reference_tfc_id = pvalue->referenceTFC_ID;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_gain_factor_information
 *
 *   DESCRIPTION:
 *      This function converts UMTS_GainFactorInformation to
 *      gain_factor_information_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_gain_factor_information
(
 UMTS_GainFactorInformation     *pvalue,
 gain_factor_information_t      *p_gain_factor_information 
 )
{
    p_gain_factor_information->t = pvalue->t;

    if (pvalue->t == T_UMTS_GainFactorInformation_signalledGainFactors)
    {
        convert_signalled_gain_factors(
                pvalue->u.signalledGainFactors,
                &p_gain_factor_information->u.signalled_gain_factors);
    }
    else if (pvalue->t == T_UMTS_GainFactorInformation_computedGainFactors)
    {
        p_gain_factor_information->u.computed_gain_factors = pvalue->u.computedGainFactors; 
    } 

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_power_offset_information
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PowerOffsetInformation to
 *      power_offset_information_t
 *
 *******************************************************************************/
void convert_power_offset_information
(
 UMTS_PowerOffsetInformation    *pvalue,
 power_offset_information_t     *p_power_offset_information 
 )
{
    convert_gain_factor_information(
            &pvalue->gainFactorInformation,
            &p_power_offset_information->gainFactor_Information);

    if (pvalue->m.powerOffsetPp_mPresent)
    {
        p_power_offset_information->presence_bitmask |=
            UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC2BIT_ELEMENT_POWER_OFF_INFO_PP_M_PRESENCE_FLAG;

        p_power_offset_information->powerOffset_Pp_m = pvalue->powerOffsetPp_m;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_reconf_add_ctfcSize_ctfc2Bit
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_TFCS_ReconfAdd_ctfcSize_ctfc2Bit to
 *      tfcs_reconf_add_ctfcSize_ctfc2Bit_t 
 *
 *******************************************************************************/
void convert_tfcs_reconf_add_ctfcSize_ctfc2Bit
(
 UMTS_TFCS_ReconfAdd_ctfcSize_ctfc2Bit  *pvalue, 
 tfcs_reconf_add_ctfcSize_ctfc2Bit_t    *p_tfcs_reconf_add_ctfcSize_ctfc2Bit
 ) 
{

    UMTS_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element   *pdata = NULL;;
    OSRTDListNode                                   *pnode = NULL;
    U32                                             index;

    pnode = pvalue->head;
    p_tfcs_reconf_add_ctfcSize_ctfc2Bit->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element*)pnode->data;
        p_tfcs_reconf_add_ctfcSize_ctfc2Bit->ctfc2Bit_elem[index].ctfc2 = pdata->ctfc2;

        if (pdata->m.powerOffsetInformationPresent)
        {
            p_tfcs_reconf_add_ctfcSize_ctfc2Bit->ctfc2Bit_elem[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC2BIT_ELEMENT_POWER_OFF_INFO_PRESENCE_FLAG;

            convert_power_offset_information(
                    &pdata->powerOffsetInformation,
                    &p_tfcs_reconf_add_ctfcSize_ctfc2Bit->ctfc2Bit_elem[index].power_offser_information);
        } 

        pnode = pnode->next;
    } 

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_reconf_add_ctfcSize_ctfc4Bit
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_ReconfAdd_ctfcSize_ctfc4Bit to
 *      tfcs_reconf_add_ctfcSize_ctfc4Bit_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_reconf_add_ctfcSize_ctfc4Bit
(
 UMTS_TFCS_ReconfAdd_ctfcSize_ctfc4Bit  *pvalue,
 tfcs_reconf_add_ctfcSize_ctfc4Bit_t    *p_tfcs_reconf_add_ctfcSize_ctfc4Bit 
 )
{
    UMTS_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element   *pdata = NULL;;
    OSRTDListNode                                   *pnode = NULL;
    U32                                             index;

    pnode = pvalue->head;
    p_tfcs_reconf_add_ctfcSize_ctfc4Bit->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element*)pnode->data;
        p_tfcs_reconf_add_ctfcSize_ctfc4Bit->ctfc4Bit_elem[index].ctfc4 = pdata->ctfc4;

        if (pdata->m.powerOffsetInformationPresent)
        {
            p_tfcs_reconf_add_ctfcSize_ctfc4Bit->ctfc4Bit_elem[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC4BIT_ELEMENT_POWER_OFF_INFO_PRESENCE_FLAG;

            convert_power_offset_information(
                    &pdata->powerOffsetInformation,
                    &p_tfcs_reconf_add_ctfcSize_ctfc4Bit->ctfc4Bit_elem[index].power_offser_information);
        } 

        pnode = pnode->next;
    }
    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_reconf_add_ctfcSize_ctfc6Bit
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_ReconfAdd_ctfcSize_ctfc6Bit to
 *      tfcs_reconf_add_ctfcSize_ctfc6Bit_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_reconf_add_ctfcSize_ctfc6Bit
(
 UMTS_TFCS_ReconfAdd_ctfcSize_ctfc6Bit  *pvalue,
 tfcs_reconf_add_ctfcSize_ctfc6Bit_t    *p_tfcs_reconf_add_ctfcSize_ctfc6Bit 
 )
{
    UMTS_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element   *pdata = NULL;;
    OSRTDListNode                                   *pnode = NULL;
    U32                                             index;

    pnode = pvalue->head;
    p_tfcs_reconf_add_ctfcSize_ctfc6Bit->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element*)pnode->data;
        p_tfcs_reconf_add_ctfcSize_ctfc6Bit->ctfc6Bit_elem[index].ctfc6 = pdata->ctfc6;

        if (pdata->m.powerOffsetInformationPresent)
        {
            p_tfcs_reconf_add_ctfcSize_ctfc6Bit->ctfc6Bit_elem[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC6BIT_ELEMENT_POWER_OFF_INFO_PRESENCE_FLAG;

            convert_power_offset_information(
                    &pdata->powerOffsetInformation,
                    &p_tfcs_reconf_add_ctfcSize_ctfc6Bit->ctfc6Bit_elem[index].power_offser_information);
        } 

        pnode = pnode->next;
    }
    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_reconf_add_ctfcSize_ctfc8Bit
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_ReconfAdd_ctfcSize_ctfc8Bit to
 *      tfcs_reconf_add_ctfcSize_ctfc8Bit_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_reconf_add_ctfcSize_ctfc8Bit
(
 UMTS_TFCS_ReconfAdd_ctfcSize_ctfc8Bit  *pvalue,
 tfcs_reconf_add_ctfcSize_ctfc8Bit_t    *p_tfcs_reconf_add_ctfcSize_ctfc8Bit 
 )
{
    UMTS_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element   *pdata = NULL;;
    OSRTDListNode                                   *pnode = NULL;
    U32                                             index;

    pnode = pvalue->head;
    p_tfcs_reconf_add_ctfcSize_ctfc8Bit->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element*)pnode->data;
        p_tfcs_reconf_add_ctfcSize_ctfc8Bit->ctfc8Bit_elem[index].ctfc8 = pdata->ctfc8;

        if (pdata->m.powerOffsetInformationPresent)
        {
            p_tfcs_reconf_add_ctfcSize_ctfc8Bit->ctfc8Bit_elem[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC8BIT_ELEMENT_POWER_OFF_INFO_PRESENCE_FLAG;

            convert_power_offset_information(
                    &pdata->powerOffsetInformation,
                    &p_tfcs_reconf_add_ctfcSize_ctfc8Bit->ctfc8Bit_elem[index].power_offser_information);
        } 

        pnode = pnode->next;
    }
    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_reconf_add_ctfcSize_ctfc12Bit
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_ReconfAdd_ctfcSize_ctfc12Bit to
 *      tfcs_reconf_add_ctfcSize_ctfc12Bit_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_reconf_add_ctfcSize_ctfc12Bit
(
 UMTS_TFCS_ReconfAdd_ctfcSize_ctfc12Bit  *pvalue,
 tfcs_reconf_add_ctfcSize_ctfc12Bit_t    *p_tfcs_reconf_add_ctfcSize_ctfc12Bit 
 )
{
    UMTS_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element   *pdata = NULL;;
    OSRTDListNode                                   *pnode = NULL;
    U32                                             index;

    pnode = pvalue->head;
    p_tfcs_reconf_add_ctfcSize_ctfc12Bit->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element*)pnode->data;
        p_tfcs_reconf_add_ctfcSize_ctfc12Bit->ctfc12Bit_elem[index].ctfc12 = pdata->ctfc12;

        if (pdata->m.powerOffsetInformationPresent)
        {
            p_tfcs_reconf_add_ctfcSize_ctfc12Bit->ctfc12Bit_elem[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC12BIT_ELEMENT_POWER_OFF_INFO_PRESENCE_FLAG;

            convert_power_offset_information(
                    &pdata->powerOffsetInformation,
                    &p_tfcs_reconf_add_ctfcSize_ctfc12Bit->ctfc12Bit_elem[index].power_offser_information);
        } 

        pnode = pnode->next;
    }
    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_reconf_add_ctfcSize_ctfc16Bit
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_ReconfAdd_ctfcSize_ctfc16Bit to
 *      tfcs_reconf_add_ctfcSize_ctfc16Bit_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_reconf_add_ctfcSize_ctfc16Bit
(
 UMTS_TFCS_ReconfAdd_ctfcSize_ctfc16Bit  *pvalue,
 tfcs_reconf_add_ctfcSize_ctfc16Bit_t    *p_tfcs_reconf_add_ctfcSize_ctfc16Bit 
 )
{
    UMTS_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element   *pdata = NULL;;
    OSRTDListNode                                   *pnode = NULL;
    U32                                             index;

    pnode = pvalue->head;
    p_tfcs_reconf_add_ctfcSize_ctfc16Bit->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element*)pnode->data;
        p_tfcs_reconf_add_ctfcSize_ctfc16Bit->ctfc16Bit_elem[index].ctfc16 = pdata->ctfc16;

        if (pdata->m.powerOffsetInformationPresent)
        {
            p_tfcs_reconf_add_ctfcSize_ctfc16Bit->ctfc16Bit_elem[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC16BIT_ELEMENT_POWER_OFF_INFO_PRESENCE_FLAG;

            convert_power_offset_information(
                    &pdata->powerOffsetInformation,
                    &p_tfcs_reconf_add_ctfcSize_ctfc16Bit->ctfc16Bit_elem[index].power_offser_information);
        } 

        pnode = pnode->next;
    }
    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_reconf_add_ctfcSize_ctfc24Bit
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_ReconfAdd_ctfcSize_ctfc24Bit to
 *      tfcs_reconf_add_ctfcSize_ctfc24Bit_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_reconf_add_ctfcSize_ctfc24Bit
(
 UMTS_TFCS_ReconfAdd_ctfcSize_ctfc24Bit  *pvalue,
 tfcs_reconf_add_ctfcSize_ctfc24Bit_t    *p_tfcs_reconf_add_ctfcSize_ctfc24Bit 
 )
{
    UMTS_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element   *pdata = NULL;;
    OSRTDListNode                                   *pnode = NULL;
    U32                                             index;

    pnode = pvalue->head;
    p_tfcs_reconf_add_ctfcSize_ctfc24Bit->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element*)pnode->data;
        p_tfcs_reconf_add_ctfcSize_ctfc24Bit->ctfc24Bit_elem[index].ctfc24 = pdata->ctfc24;

        if (pdata->m.powerOffsetInformationPresent)
        {
            p_tfcs_reconf_add_ctfcSize_ctfc24Bit->ctfc24Bit_elem[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_TFCS_RECONF_ADD_CTFCSIZE_CTFC24BIT_ELEMENT_POWER_OFF_INFO_PRESENCE_FLAG;

            convert_power_offset_information(
                    &pdata->powerOffsetInformation,
                    &p_tfcs_reconf_add_ctfcSize_ctfc24Bit->ctfc24Bit_elem[index].power_offser_information);
        } 

        pnode = pnode->next;
    }
    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_reconf_add
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_ReconfAdd to
 *      tfcs_reconf_add_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_reconf_add
(
 UMTS_TFCS_ReconfAdd    *pvalue,
 tfcs_reconf_add_t      *p_tfcs_reconf_add 
 )
{
    p_tfcs_reconf_add->ctfc_Size.t = pvalue->ctfcSize.t;

    if (pvalue->ctfcSize.t == T_UMTS_TFCS_ReconfAdd_ctfcSize_ctfc2Bit)
    {
        convert_tfcs_reconf_add_ctfcSize_ctfc2Bit(
                pvalue->ctfcSize.u.ctfc2Bit,
                &p_tfcs_reconf_add->ctfc_Size.u.ctfc2Bit); 
    } 
    else if (pvalue->ctfcSize.t == T_UMTS_TFCS_ReconfAdd_ctfcSize_ctfc4Bit) 
    {
        convert_tfcs_reconf_add_ctfcSize_ctfc4Bit(
                pvalue->ctfcSize.u.ctfc4Bit,
                &p_tfcs_reconf_add->ctfc_Size.u.ctfc4Bit);
    }
    else if (pvalue->ctfcSize.t == T_UMTS_TFCS_ReconfAdd_ctfcSize_ctfc6Bit) 
    {
        convert_tfcs_reconf_add_ctfcSize_ctfc6Bit(
                pvalue->ctfcSize.u.ctfc6Bit,
                &p_tfcs_reconf_add->ctfc_Size.u.ctfc6Bit);
    }
    else if (pvalue->ctfcSize.t == T_UMTS_TFCS_ReconfAdd_ctfcSize_ctfc8Bit)
    {
        convert_tfcs_reconf_add_ctfcSize_ctfc8Bit(
                pvalue->ctfcSize.u.ctfc8Bit,
                &p_tfcs_reconf_add->ctfc_Size.u.ctfc8Bit);
    }
    else if (pvalue->ctfcSize.t == T_UMTS_TFCS_ReconfAdd_ctfcSize_ctfc12Bit)
    {
        convert_tfcs_reconf_add_ctfcSize_ctfc12Bit(
                pvalue->ctfcSize.u.ctfc12Bit,
                &p_tfcs_reconf_add->ctfc_Size.u.ctfc12Bit);
    }
    else if (pvalue->ctfcSize.t == T_UMTS_TFCS_ReconfAdd_ctfcSize_ctfc16Bit)
    {
        convert_tfcs_reconf_add_ctfcSize_ctfc16Bit(
                pvalue->ctfcSize.u.ctfc16Bit,
                &p_tfcs_reconf_add->ctfc_Size.u.ctfc16Bit);
    }
    else if (pvalue->ctfcSize.t == T_UMTS_TFCS_ReconfAdd_ctfcSize_ctfc24Bit)
    {
        convert_tfcs_reconf_add_ctfcSize_ctfc24Bit(
                pvalue->ctfcSize.u.ctfc24Bit,
                &p_tfcs_reconf_add->ctfc_Size.u.ctfc248Bit);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_removal_list
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_RemovalList to
 *      tfcs_removal_list_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_removal_list
(
 UMTS_TFCS_RemovalList  *pvalue,
 tfcs_removal_list_t    *p_tfcs_removal_list 
 )
{
    UMTS_TFCS_Removal   *pdata = NULL;;
    OSRTDListNode       *pnode = NULL;
    U32                 index;

    pnode = pvalue->head;
    p_tfcs_removal_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCS_Removal*)pnode->data;
        p_tfcs_removal_list->tfcs_removal[index].tfci = pdata->tfci;
        pnode = pnode->next;
    } 

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_explicit_tfcs_configuration_replacement
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_ExplicitTFCS_Configuration_replacement to
 *      explicit_tfcs_configuration_replacement_t
 *
 *******************************************************************************/
void convert_explicit_tfcs_configuration_replacement
(
 UMTS_ExplicitTFCS_Configuration_replacement        *pvalue,
 explicit_tfcs_configuration_replacement_t          *p_explicit_tfcs_configuration_replacement 
 )
{
    convert_tfcs_removal_list(
            &pvalue->tfcsRemoval,
            &p_explicit_tfcs_configuration_replacement->tfcs_Removal);

    convert_tfcs_reconf_add(
            &pvalue->tfcsAdd,
            &p_explicit_tfcs_configuration_replacement->tfcs_Add);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_explicit_tfcs_configuration
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_ExplicitTFCS_Configuration to
 *      explicit_tfcs_configuration_t
 *
 *******************************************************************************/
void convert_explicit_tfcs_configuration
(
 UMTS_ExplicitTFCS_Configuration    *pvalue,
 explicit_tfcs_configuration_t      *p_explicit_tfcs_configuration 
 )
{
    p_explicit_tfcs_configuration->t = pvalue->t;

    if (pvalue->t == T_UMTS_ExplicitTFCS_Configuration_complete)
    {
        convert_tfcs_reconf_add(
                pvalue->u.complete,
                &p_explicit_tfcs_configuration->u.complete);
    }
    else if (pvalue->t == T_UMTS_ExplicitTFCS_Configuration_addition)
    {
        convert_tfcs_reconf_add(
                pvalue->u.addition,
                &p_explicit_tfcs_configuration->u.addition);
    }
    else if (pvalue->t == T_UMTS_ExplicitTFCS_Configuration_removal)
    {
        convert_tfcs_removal_list(
                pvalue->u.removal,
                &p_explicit_tfcs_configuration->u.removal);
    }
    else if (pvalue->t == T_UMTS_ExplicitTFCS_Configuration_replacement)
    {
        convert_explicit_tfcs_configuration_replacement(
                pvalue->u.replacement,
                &p_explicit_tfcs_configuration->u.replacement);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs_info_for_dsch
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCS_InfoForDSCH to
 *      tfcs_info_for_dsch_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfcs_info_for_dsch
(
 UMTS_TFCS_InfoForDSCH  *pvalue,
 tfcs_info_for_dsch_t   *p_tfcs_info_for_dsch 
 )
{
    p_tfcs_info_for_dsch->t = pvalue->t;

    if (pvalue->t == T_UMTS_TFCS_InfoForDSCH_ctfc2bit)
    {
        p_tfcs_info_for_dsch->u.ctfc2bit = pvalue->u.ctfc2bit; 
    }
    else if (pvalue->t == T_UMTS_TFCS_InfoForDSCH_ctfc4bit)
    {
        p_tfcs_info_for_dsch->u.ctfc4bit = pvalue->u.ctfc4bit; 
    }
    else if (pvalue->t == T_UMTS_TFCS_InfoForDSCH_ctfc6bit)
    {
        p_tfcs_info_for_dsch->u.ctfc6bit = pvalue->u.ctfc6bit; 
    }
    else if (pvalue->t == T_UMTS_TFCS_InfoForDSCH_ctfc8bit)
    {
        p_tfcs_info_for_dsch->u.ctfc8bit = pvalue->u.ctfc8bit; 
    }
    else if (pvalue->t == T_UMTS_TFCS_InfoForDSCH_ctfc12bit)
    {
        p_tfcs_info_for_dsch->u.ctfc12bit = pvalue->u.ctfc12bit; 
    }
    else if (pvalue->t == T_UMTS_TFCS_InfoForDSCH_ctfc16bit)
    {
        p_tfcs_info_for_dsch->u.ctfc16bit = pvalue->u.ctfc16bit; 
    }
    else if (pvalue->t == T_UMTS_TFCS_InfoForDSCH_ctfc24bit)
    {
        p_tfcs_info_for_dsch->u.ctfc24bit = pvalue->u.ctfc24bit; 
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_tfci_rangelist
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCI_RangeList to
 *      tfci_rangelist_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfci_rangelist
(
 UMTS_TFCI_RangeList    *pvalue,
 tfci_rangelist_t       *p_tfci_rangelist 
 )
{
    UMTS_TFCI_Range     *pdata = NULL;
    OSRTDListNode       *pnode = NULL;
    U32                 index;

    pnode = pvalue->head;
    p_tfci_rangelist->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TFCI_Range*)pnode->data;

        p_tfci_rangelist->tfci_range[index].max_TFCIField2_Value = pdata->maxTFCIField2Value;

        convert_tfcs_info_for_dsch(
                &pdata->tfcs_InfoForDSCH,
                &p_tfci_rangelist->tfci_range[index].tfcs_InfoFor_DSCH);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfci_field2_information
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TFCI_Field2_Information to
 *      tfci_field2_information_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tfci_field2_information
(
 UMTS_TFCI_Field2_Information   *pvalue,
 tfci_field2_information_t      *p_tfci_field2_information 
 )
{
    p_tfci_field2_information->t = pvalue->t;

    if (pvalue->t == T_UMTS_TFCI_Field2_Information_tfci_Range)
    {
        convert_tfci_rangelist(
                pvalue->u.tfci_Range,
                &p_tfci_field2_information->u.tfci_Range);
    }
    else if (pvalue->t == T_UMTS_TFCI_Field2_Information_explicit_config)
    {
        convert_explicit_tfcs_configuration(
                pvalue->u.explicit_config,
                &p_tfci_field2_information->u.explicit_config);
    }

    return;
}
/******************************************************************************
 *   FUNCTION NAME: convert_split_tfci_signalling
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SplitTFCI_Signalling to
 *      split_tfci_signalling_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_split_tfci_signalling
(
 UMTS_SplitTFCI_Signalling  *pvalue,
 split_tfci_signalling_t    *p_split_tfci_signalling 
 )
{
    if (pvalue->m.splitTypePresent)
    {
        p_split_tfci_signalling->presence_bitmask |=
            UMTS_SIB_TYPE_5_USCH_TFCS_SPLIT_TFCI_SIGNALLING_SPLIT_TYPE_PRESENCE_FLAG;

        p_split_tfci_signalling->split_type = pvalue->splitType;
    }

    if (pvalue->m.tfci_Field2_LengthPresent)
    {
        p_split_tfci_signalling->presence_bitmask |=
            UMTS_SIB_TYPE_5_USCH_TFCS_SPLIT_TFCI_SIGNALLING_FIELD2_LENGTH_PRESENCE_FLAG;

        p_split_tfci_signalling->tfci_Field2_Length = pvalue->tfci_Field2_Length; 
    }

    if (pvalue->m.tfci_Field1_InformationPresent)
    {
        p_split_tfci_signalling->presence_bitmask |=
            UMTS_SIB_TYPE_5_USCH_TFCS_SPLIT_TFCI_SIGNALLING_FIELD1_INFO_PRESENCE_FLAG;

        convert_explicit_tfcs_configuration(
                &pvalue->tfci_Field1_Information,
                &p_split_tfci_signalling->tfci_Field1_Information);
    }

    if (pvalue->m.tfci_Field2_InformationPresent)
    {
        p_split_tfci_signalling->presence_bitmask |=
            UMTS_SIB_TYPE_5_USCH_TFCS_SPLIT_TFCI_SIGNALLING_FIELD2_INFO_PRESENCE_FLAG;

        convert_tfci_field2_information(
                &pvalue->tfci_Field2_Information,
                &p_split_tfci_signalling->tfci_Field2_Information);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tfcs
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_TFCS to
 *      tfcs_t
 *
 *******************************************************************************/
void convert_tfcs
(
 UMTS_TFCS  *pvalue,
 tfcs_t     *p_tfcs 
 )
{
    p_tfcs->t = pvalue->t;

    if (pvalue->t == T_UMTS_TFCS_normalTFCI_Signalling)
    {
        convert_explicit_tfcs_configuration(
                pvalue->u.normalTFCI_Signalling,
                &p_tfcs->u.normal_TFCI_Signalling);  
    }
    else if (pvalue->t == T_UMTS_TFCS_dummy)
    {
        convert_split_tfci_signalling(
                pvalue->u.dummy,
                &p_tfcs->u.dummy); 
    } 

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformationList to
 *      sccpch_system_information_list_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_list
(
 UMTS_SCCPCH_SystemInformationList  *pvalue,
 sccpch_system_information_list_t   *p_sccpch_system_information_list
 )
{
    UMTS_SCCPCH_SystemInformation   *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_sccpch_system_information_list->count = pvalue->count;

    for (index = 0; index < pvalue->count; index++)
    {
        pdata = (UMTS_SCCPCH_SystemInformation*)pnode->data;

        convert_secondary_ccpch_info (
                &pdata->secondaryCCPCH_Info, 
                &p_sccpch_system_information_list->sccpcf_system_info[index].secondary_CCPCH_Info);

        if (pdata->m.tfcsPresent)
        {
            p_sccpch_system_information_list->sccpcf_system_info[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_INFO_SCCPCH_SYSINFO_TFCS_PRESENCE_FLAG;

            convert_tfcs(
                    &pdata->tfcs,
                    &p_sccpch_system_information_list->sccpcf_system_info[index].tfcs);  
        }

        if (pdata->m.fach_PCH_InformationListPresent)
        {
            p_sccpch_system_information_list->sccpcf_system_info[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_INFO_SCCPCH_SYSINFO_FACH_PCH_INFO_LIST_PRESENCE_FLAG;

            convert_fach_pch_information_list(
                    &pdata->fach_PCH_InformationList,
                    &p_sccpch_system_information_list->sccpcf_system_info[index].fach_PCH_Information_List);
        }

        if (pdata->m.pich_InfoPresent)
        {
            p_sccpch_system_information_list->sccpcf_system_info[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_INFO_SCCPCH_SYSINFO_FACH_PCH_INFO_LIST_PRESENCE_FLAG;

            convert_pich_info(
                    &pdata->pich_Info,
                    &p_sccpch_system_information_list->sccpcf_system_info[index].pich_info);  
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_number_of_tb_size_n_tti_list
 *
 *   DESCRIPTION:
 *      This function converts UMTS_NumberOfTbSizeAndTTIList to
 *      number_of_tb_size_n_tti_list_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_number_of_tb_size_n_tti_list
(
 UMTS_NumberOfTbSizeAndTTIList      *pvalue,
 number_of_tb_size_n_tti_list_t     *numOf_tb_sizeAnd_tti_list
 )
{
    UMTS_NumberOfTbSizeAndTTIList_element   *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    numOf_tb_sizeAnd_tti_list->count = pvalue->count;

    for (index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NumberOfTbSizeAndTTIList_element*)pnode->data;

        numOf_tb_sizeAnd_tti_list->num_of_tb_sizeAndTTL_listElemet[index].numTransport_blocks.t = 
            pdata->numberOfTransportBlocks.t;

        if (pdata->numberOfTransportBlocks.t == T_UMTS_NumberOfTransportBlocks_small_)
            numOf_tb_sizeAnd_tti_list->num_of_tb_sizeAndTTL_listElemet[index].numTransport_blocks.u.small_ = 
                pdata->numberOfTransportBlocks.u.small_;

        else if (pdata->numberOfTransportBlocks.t == T_UMTS_NumberOfTransportBlocks_large_)
            numOf_tb_sizeAnd_tti_list->num_of_tb_sizeAndTTL_listElemet[index].numTransport_blocks.u.large_ = 
                pdata->numberOfTransportBlocks.u.large_;

        numOf_tb_sizeAnd_tti_list->num_of_tb_sizeAndTTL_listElemet[index].transmissionTime_inverval = 
            pdata->transmissionTimeInterval;

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_octet_mode_rlc_size_info_type1_size_type3
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_OctetModeRLC_SizeInfoType1_sizeType3 to
 *      octetmode_rlc_sizeinfo_type1_sizetype3_t
 *
 *******************************************************************************/
void convert_octet_mode_rlc_size_info_type1_size_type3
(
 UMTS_OctetModeRLC_SizeInfoType1_sizeType3   *pvalue,
 octetmode_rlc_sizeinfo_type1_sizetype3_t    *p_octetmode_rlc_sizeinfo_type1_sizetype3
 )
{
    p_octetmode_rlc_sizeinfo_type1_sizetype3->part1 = pvalue->part1;

    if (pvalue->m.part2Present)
    {
        p_octetmode_rlc_sizeinfo_type1_sizetype3->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_OCTETMODE_RLC_SIZEINFO_TYPE1_SIZETYPE3_PART2_PRESENCE_FLAG;

        p_octetmode_rlc_sizeinfo_type1_sizetype3->part2 = pvalue->part2;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_octet_mode_rlc_size_info_type1_size_type2
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_OctetModeRLC_SizeInfoType1_sizeType2 to
 *      octetmode_rlc_sizeinfo_type1_sizetype2_t 
 *
 *******************************************************************************/
void convert_octet_mode_rlc_size_info_type1_size_type2
(
 UMTS_OctetModeRLC_SizeInfoType1_sizeType2   *pvalue,
 octetmode_rlc_sizeinfo_type1_sizetype2_t    *p_octetmode_rlc_sizeinfo_type1_sizetype2
 )
{
    p_octetmode_rlc_sizeinfo_type1_sizetype2->part1 = pvalue->part1;

    if (pvalue->m.part2Present)
    {
        p_octetmode_rlc_sizeinfo_type1_sizetype2->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_OCTETMODE_RLC_SIZEINFO_TYPE1_SIZETYPE2_PART2_PRESENCE_FLAG;

        p_octetmode_rlc_sizeinfo_type1_sizetype2->part2 = pvalue->part2;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_octet_mode_rlc_size_info_type_1
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_OctetModeRLC_SizeInfoType1 to
 *      octetmode_rlc_sizeinfo_type1_t 
 *
 *******************************************************************************/
void convert_octet_mode_rlc_size_info_type_1
(
 UMTS_OctetModeRLC_SizeInfoType1   *pvalue,
 octetmode_rlc_sizeinfo_type1_t    *p_octetmode_rlc_sizeinfo_type1
 )
{
    p_octetmode_rlc_sizeinfo_type1->t = pvalue->t;

    if (pvalue->t == T_UMTS_OctetModeRLC_SizeInfoType1_sizeType1)
    {
        p_octetmode_rlc_sizeinfo_type1->u.size_type1 = pvalue->u.sizeType1;
    }
    else if (pvalue->t == T_UMTS_OctetModeRLC_SizeInfoType1_sizeType2)
    {
        convert_octet_mode_rlc_size_info_type1_size_type2(
                pvalue->u.sizeType2,
                &p_octetmode_rlc_sizeinfo_type1->u.sizeType2);
    }
    else if (pvalue->t == T_UMTS_OctetModeRLC_SizeInfoType1_sizeType3)
    {
        convert_octet_mode_rlc_size_info_type1_size_type3(
                pvalue->u.sizeType3,
                &p_octetmode_rlc_sizeinfo_type1->u.sizeType3);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_rlc_size_info_size_type4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_BitModeRLC_SizeInfo_sizeType4 to
 *      bitmode_rlc_sizeinfo_sizetype4_t
 *
 *******************************************************************************/
void convert_rlc_size_info_size_type4
(
 UMTS_BitModeRLC_SizeInfo_sizeType4     *pvalue,
 bitmode_rlc_sizeinfo_sizetype4_t       *p_bitmode_rlc_sizeinfo_sizetype4 
 )
{
    p_bitmode_rlc_sizeinfo_sizetype4->part1 = pvalue->part1;

    if (pvalue->m.part2Present)
    {
        p_bitmode_rlc_sizeinfo_sizetype4->presence_bitmask |= 
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_BITMODE_RLC_SIZEINFO_SIZETYPE4_PART2_PRESENCE_FLAG;

        p_bitmode_rlc_sizeinfo_sizetype4->part2 = pvalue->part2;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_rlc_size_info_size_type3
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_BitModeRLC_SizeInfo_sizeType3 to
 *      bitmode_rlc_sizeinfo_sizetype3_t 
 *
 *******************************************************************************/
void convert_rlc_size_info_size_type3
(
 UMTS_BitModeRLC_SizeInfo_sizeType3     *pvalue,
 bitmode_rlc_sizeinfo_sizetype3_t       *p_bitmode_rlc_sizeinfo_sizetype3
 )
{
    p_bitmode_rlc_sizeinfo_sizetype3->part1 = pvalue->part1;

    if (pvalue->m.part2Present)
    {
        p_bitmode_rlc_sizeinfo_sizetype3->presence_bitmask |= 
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_BITMODE_RLC_SIZEINFO_SIZETYPE3_PART2_PRESENCE_FLAG;

        p_bitmode_rlc_sizeinfo_sizetype3->part2 = pvalue->part2;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_rlc_size_info_size_type2
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_BitModeRLC_SizeInfo_sizeType2 to
 *      bitmode_rlc_sizeinfo_sizetype2_t 
 *
 *******************************************************************************/
void convert_rlc_size_info_size_type2
(
 UMTS_BitModeRLC_SizeInfo_sizeType2     *pvalue,
 bitmode_rlc_sizeinfo_sizetype2_t       *p_bitmode_rlc_sizeinfo_sizetype2 
 )
{
    p_bitmode_rlc_sizeinfo_sizetype2->part1 = pvalue->part1;

    if (pvalue->m.part2Present)
    {
        p_bitmode_rlc_sizeinfo_sizetype2->presence_bitmask |= 
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_BITMODE_RLC_SIZEINFO_SIZETYPE2_PART2_PRESENCE_FLAG;

        p_bitmode_rlc_sizeinfo_sizetype2->part2 = pvalue->part2;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_bit_mode_rlc_size_info
 *
 *   DESCRIPTION:
 *      This function converts UMTS_BitModeRLC_SizeInfo to
 *      bitmode_rlc_sizeinfo_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_bit_mode_rlc_size_info
(
 UMTS_BitModeRLC_SizeInfo   *pvalue,
 bitmode_rlc_sizeinfo_t     *p_bitmode_rlc_sizeinfo
 )
{
    p_bitmode_rlc_sizeinfo->t = pvalue->t;

    if (pvalue->t == T_UMTS_BitModeRLC_SizeInfo_sizeType1)
    {
        p_bitmode_rlc_sizeinfo->u.size_Type1 = pvalue->u.sizeType1;
    }
    else if (pvalue->t == T_UMTS_BitModeRLC_SizeInfo_sizeType2)
    {
        convert_rlc_size_info_size_type2(
                pvalue->u.sizeType2,
                &p_bitmode_rlc_sizeinfo->u.size_Type2);
    }
    else if (pvalue->t == T_UMTS_BitModeRLC_SizeInfo_sizeType3)
    {
        convert_rlc_size_info_size_type3(
                pvalue->u.sizeType3,
                &p_bitmode_rlc_sizeinfo->u.size_Type3);
    }
    else if (pvalue->t == T_UMTS_BitModeRLC_SizeInfo_sizeType4)
    {
        convert_rlc_size_info_size_type4(
                pvalue->u.sizeType4,
                &p_bitmode_rlc_sizeinfo->u.size_Type4);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_commmon_dynamic_tf_ino_common_tdd_choice
 *
 *   DESCRIPTION:
 *      This function converts UMTS_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice to
 *      common_dynamic_tf_info_dynamic_tti_common_tdd_choice_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_commmon_dynamic_tf_ino_common_tdd_choice
(
 UMTS_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice   *pvalue,
 common_dynamic_tf_info_dynamic_tti_common_tdd_choice_t  *common_tdd_choice
 )
{
    common_tdd_choice->t = pvalue->t;

    if (pvalue->t == T_UMTS_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice_bitModeRLC_SizeInfo)
    {
        convert_bit_mode_rlc_size_info(
                pvalue->u.bitModeRLC_SizeInfo,
                &common_tdd_choice->u.bitmode_RLC_sizeInfo); 
    }
    else if (pvalue->t == T_UMTS_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice_octetModeRLC_SizeInfoType1)
    {
        convert_octet_mode_rlc_size_info_type_1(
                pvalue->u.octetModeRLC_SizeInfoType1,
                &common_tdd_choice->u.octetmode_RLC_sizeInfoType1); 
    } 
}

/******************************************************************************
 *   FUNCTION NAME: convert_logical_channel_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_LogicalChannelList to
 *      logical_channel_list_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_logical_channel_list
(
 UMTS_LogicalChannelList    *pvalue,
 logical_channel_list_t     *p_logical_channel_list 
 )
{
    p_logical_channel_list->t = pvalue->t;

    if (pvalue->t == T_UMTS_LogicalChannelList_allSizes)
    {
        /* not used */
    }
    else if (pvalue->t == T_UMTS_LogicalChannelList_configured)
    {
        /* not used */
    }
    else if (pvalue->t == T_UMTS_LogicalChannelList_explicitList)
    {
        convert_logical_channel_list_explicitList(
                pvalue->u.explicitList,
                &p_logical_channel_list->u.explicit_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_dynamic_tf_info_list_dynamic_tti
 *
 *   DESCRIPTION:
 *      This function converts UMTS_CommonDynamicTF_InfoList_DynamicTTI to
 *      common_dynamic_tf_info_list_dynamic_tti_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_dynamic_tf_info_list_dynamic_tti
(
 UMTS_CommonDynamicTF_InfoList_DynamicTTI   *pvalue,
 common_dynamic_tf_info_list_dynamic_tti_t  *p_common_dynamic_tf_info_list_dynamic_tti
 )
{
    UMTS_CommonDynamicTF_Info_DynamicTTI    *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_common_dynamic_tf_info_list_dynamic_tti->count = pvalue->count;

    for (index = 0; index <pvalue-> count; pvalue++)
    {
        pdata = (UMTS_CommonDynamicTF_Info_DynamicTTI*)pnode->data;

        convert_commmon_dynamic_tf_ino_common_tdd_choice(
                &pdata->commonTDD_Choice,
                &p_common_dynamic_tf_info_list_dynamic_tti->common_dynamic_tf_info_dynamicTTI[index].
                commonTDD_choice);

        /* NumberOfTbSizeAndTTIList */
        convert_number_of_tb_size_n_tti_list(
                &pdata->numberOfTbSizeAndTTIList,
                &p_common_dynamic_tf_info_list_dynamic_tti->common_dynamic_tf_info_dynamicTTI[index].
                num_of_Tb_size_and_TTIList);

        /* LogicalChannelList */
        convert_logical_channel_list(
                &pdata->logicalChannelList,        
                &p_common_dynamic_tf_info_list_dynamic_tti->common_dynamic_tf_info_dynamicTTI[index].
                logical_channel_list);

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_logical_channel_list_explicitList
 *
 *   DESCRIPTION:
 *      This function converts UMTS_LogicalChannelList_explicitList to
 *      logical_channel_list_explicitList_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_logical_channel_list_explicitList
(
 UMTS_LogicalChannelList_explicitList   *pvalue,
 logical_channel_list_explicitList_t    *logical_channel_list_explicit_List
 )
{
    UMTS_LogicalChannelByRB     *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    logical_channel_list_explicit_List->count = pvalue->count;

    for (index = 0; index <pvalue->count; index++)
    {
        pdata = (UMTS_LogicalChannelByRB*)pnode->data;

        logical_channel_list_explicit_List->logicalChannel_by_RB[index].rb_identity = pdata->rb_Identity;

        if (pdata->m.logChOfRbPresent)
        {
            logical_channel_list_explicit_List->logicalChannel_by_RB[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_LOGICAL_CHANNEL_BY_RB_PRESENCE_FLAG;

            logical_channel_list_explicit_List->logicalChannel_by_RB[index].logCh_of_Rb = pdata->logChOfRb;
        }

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_dedicated_dynamic_tf_info_dynamic_tti_rlc_size
 *
 *   DESCRIPTION:
 *      This function converts UMTS_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size to
 *      dedicated_dynamic_tf_info_dynamic_tti_rlc_size_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_dedicated_dynamic_tf_info_dynamic_tti_rlc_size
(
 UMTS_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size   *pvalue,
 dedicated_dynamic_tf_info_dynamic_tti_rlc_size_t   *p_dedicated_dynamic_tf_info_dynamic_tti_rlc_size 
 )
{
    p_dedicated_dynamic_tf_info_dynamic_tti_rlc_size->t = pvalue->t;

    if (pvalue->t == T_UMTS_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size_bitMode)
    {
        convert_bit_mode_rlc_size_info(
                pvalue->u.bitMode,
                &p_dedicated_dynamic_tf_info_dynamic_tti_rlc_size->u.bit_mode); 
    }
    else if (pvalue->t == T_UMTS_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size_octetModeType1)
    {
        convert_octet_mode_rlc_size_info_type_1(
                pvalue->u.octetModeType1,
                &p_dedicated_dynamic_tf_info_dynamic_tti_rlc_size->u.octet_modeType1);    
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dedicated_dynamic_tf_info_list_dynamic_tti
 *
 *   DESCRIPTION:
 *      This function converts UMTS_DedicatedDynamicTF_InfoList_DynamicTTI to
 *      dedicated_dynamic_tf_info_list_dynamic_tti_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_dedicated_dynamic_tf_info_list_dynamic_tti
( 
 UMTS_DedicatedDynamicTF_InfoList_DynamicTTI    *pvalue,
 dedicated_dynamic_tf_info_list_dynamic_tti_t   *p_dedicated_dynamic_tti_list
 )
{
    UMTS_DedicatedDynamicTF_Info_DynamicTTI *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_dedicated_dynamic_tti_list->count = pvalue->count;

    for (index = 0; index < pvalue->count; index ++)
    {
        pdata = (UMTS_DedicatedDynamicTF_Info_DynamicTTI*)pnode->data;

        convert_dedicated_dynamic_tf_info_dynamic_tti_rlc_size(
                &pdata->rlc_Size,
                &p_dedicated_dynamic_tti_list->dedicatedDynamicTF_info_DynamicTTI[index].rlc_size);

        convert_number_of_tb_size_n_tti_list(
                &pdata->numberOfTbSizeAndTTIList,
                &p_dedicated_dynamic_tti_list->dedicatedDynamicTF_info_DynamicTTI[index].
                num_of_Tb_size_and_TTIList);

        convert_logical_channel_list(
                &pdata->logicalChannelList,
                &p_dedicated_dynamic_tti_list->dedicatedDynamicTF_info_DynamicTTI[index].
                logical_channel_list);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dedicated_dynamic_tf_info_num_of_tb_size_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DedicatedDynamicTF_Info_numberOfTbSizeList to
 *      dedicated_dynamic_tf_info_num_of_tb_size_list_t
 *
 *******************************************************************************/
void convert_dedicated_dynamic_tf_info_num_of_tb_size_list
(
 UMTS_DedicatedDynamicTF_Info_numberOfTbSizeList    *pvalue,
 dedicated_dynamic_tf_info_num_of_tb_size_list_t    *dedicated_dynamic_tf_info_num_of_tb_size_list
 )
{
    UMTS_NumberOfTransportBlocks    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    dedicated_dynamic_tf_info_num_of_tb_size_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_NumberOfTransportBlocks*)pnode->data;
        dedicated_dynamic_tf_info_num_of_tb_size_list->numTransport_blocks[index].t = pdata->t;

        if (pdata->t == T_UMTS_NumberOfTransportBlocks_small_ )
            dedicated_dynamic_tf_info_num_of_tb_size_list->numTransport_blocks[index].u.small_ = pdata->u.small_;

        else if (pdata->t == T_UMTS_NumberOfTransportBlocks_large_ )
            dedicated_dynamic_tf_info_num_of_tb_size_list->numTransport_blocks[index].u.large_ = pdata->u.large_;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dedicated_dynamic_tf_info_rlc_size
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DedicatedDynamicTF_Info_rlc_Size to
 *      dedicated_dynamic_tf_info_rlc_size_t
 *
 *******************************************************************************/
void convert_dedicated_dynamic_tf_info_rlc_size
(
 UMTS_DedicatedDynamicTF_Info_rlc_Size  *pvalue,
 dedicated_dynamic_tf_info_rlc_size_t   *p_dedicated_dynamic_tf_info_rlc_size
 )
{
    p_dedicated_dynamic_tf_info_rlc_size->t = pvalue->t;

    if (pvalue->t == T_UMTS_DedicatedDynamicTF_Info_rlc_Size_bitMode)
    {
        convert_bit_mode_rlc_size_info(
                pvalue->u.bitMode,
                &p_dedicated_dynamic_tf_info_rlc_size->u.bit_mode);
    }
    else if (pvalue->t == T_UMTS_DedicatedDynamicTF_Info_rlc_Size_octetModeType1)
    {
        convert_octet_mode_rlc_size_info_type_1(
                pvalue->u.octetModeType1,
                &p_dedicated_dynamic_tf_info_rlc_size->u.octet_modeType1);
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: convert_dedicated_dynamic_tf_info_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DedicatedDynamicTF_InfoList to
 *      dedicated_dynamic_tf_info_list_t
 *
 *******************************************************************************/
void convert_dedicated_dynamic_tf_info_list
(
 UMTS_DedicatedDynamicTF_InfoList   *pvalue,
 dedicated_dynamic_tf_info_list_t   *p_dedicated_dynamic_tf_info_list
 )
{
    UMTS_DedicatedDynamicTF_Info    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_dedicated_dynamic_tf_info_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_DedicatedDynamicTF_Info*)pnode->data;

        convert_dedicated_dynamic_tf_info_rlc_size(
                &pdata->rlc_Size,
                &p_dedicated_dynamic_tf_info_list->dedicated_dynamic_tf_info[index].rlc_size);

        convert_dedicated_dynamic_tf_info_num_of_tb_size_list (
                &pdata->numberOfTbSizeList, 
                &p_dedicated_dynamic_tf_info_list->dedicated_dynamic_tf_info[index].num_of_Tb_size_list);

        convert_logical_channel_list(
                &pdata->logicalChannelList,
                &p_dedicated_dynamic_tf_info_list->dedicated_dynamic_tf_info[index].logical_channel_list);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dedicated_trans_ch_tfs_tti
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DedicatedTransChTFS_tti to
 *      dedicated_trans_ch_tfs_tti_t
 *
 *******************************************************************************/
void convert_dedicated_trans_ch_tfs_tti 
(
 UMTS_DedicatedTransChTFS_tti   *pvalue,
 dedicated_trans_ch_tfs_tti_t   *dedicated_trans_ch_tfs_tti
 )
{
    dedicated_trans_ch_tfs_tti->t = pvalue->t;

    if (pvalue->t == T_UMTS_DedicatedTransChTFS_tti_tti10 ) 
    {
        convert_dedicated_dynamic_tf_info_list (
                pvalue->u.tti10, 
                &dedicated_trans_ch_tfs_tti->u.tti10); 
    }
    else if (pvalue->t == T_UMTS_DedicatedTransChTFS_tti_tti20)
    {
        convert_dedicated_dynamic_tf_info_list (
                pvalue->u.tti20, 
                &dedicated_trans_ch_tfs_tti->u.tti20); 
    }
    else if (pvalue->t == T_UMTS_DedicatedTransChTFS_tti_tti40 )
    {
        convert_dedicated_dynamic_tf_info_list (
                pvalue->u.tti40, 
                &dedicated_trans_ch_tfs_tti->u.tti40); 
    }
    else if (pvalue->t == T_UMTS_DedicatedTransChTFS_tti_tti80)
    {
        convert_dedicated_dynamic_tf_info_list (
                pvalue->u.tti80,
                &dedicated_trans_ch_tfs_tti->u.tti80); 
    }
    else if (pvalue->t == T_UMTS_DedicatedTransChTFS_tti_dynamic )
    {
        convert_dedicated_dynamic_tf_info_list_dynamic_tti (
                pvalue->u.dynamic, 
                &dedicated_trans_ch_tfs_tti->u.dynamic);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_dynamic_tf_info_num_of_tb_size_list
 *
 *   DESCRIPTION:
 *      This function UMTS_CommonDynamicTF_Info_numberOfTbSizeList to
 *      common_dynamic_tf_info_num_of_tb_size_list_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_dynamic_tf_info_num_of_tb_size_list
(
 UMTS_CommonDynamicTF_Info_numberOfTbSizeList   *pvalue,
 common_dynamic_tf_info_num_of_tb_size_list_t   *num_of_tb_size_list
 )
{
    UMTS_NumberOfTransportBlocks    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    num_of_tb_size_list->count = pvalue->count;

    for(index = 0; index < pvalue->count; index++)
    {
        pdata = (UMTS_NumberOfTransportBlocks*)pnode->data;
        num_of_tb_size_list->numTransportBlocks[index].t = pdata->t;

        if (pdata->t == T_UMTS_NumberOfTransportBlocks_small_)
            num_of_tb_size_list->numTransportBlocks[index].u.small_ = pdata->u.small_;

        else if (pdata->t == T_UMTS_NumberOfTransportBlocks_large_)
            num_of_tb_size_list->numTransportBlocks[index].u.large_ = pdata->u.large_;

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_octet_mode_rlc_size_info_type2
 *
 *   DESCRIPTION:
 *      This function UMTS_OctetModeRLC_SizeInfoType2 to
 *      octet_mode_rlc_size_info_type2_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_octet_mode_rlc_size_info_type2
(
 UMTS_OctetModeRLC_SizeInfoType2    *pvalue,
 octet_mode_rlc_size_info_type2_t   *p_octet_mode_rlc_size_info_type2 
 )
{
    p_octet_mode_rlc_size_info_type2->t = pvalue->t;

    if (pvalue->t == T_UMTS_OctetModeRLC_SizeInfoType2_sizeType1)
    {
        p_octet_mode_rlc_size_info_type2->u.size_Type1 = pvalue->u.sizeType1; 
    }
    else if (pvalue->t == T_UMTS_OctetModeRLC_SizeInfoType2_sizeType2)
    {
        p_octet_mode_rlc_size_info_type2->u.size_Type2 = pvalue->u.sizeType2; 
    }
    else if (pvalue->t == T_UMTS_OctetModeRLC_SizeInfoType2_sizeType3)
    {
        p_octet_mode_rlc_size_info_type2->u.size_Type3 = pvalue->u.sizeType3; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_dynamic_tf_info_rlc_size_fdd
 *
 *   DESCRIPTION:
 *      This function UMTS_CommonDynamicTF_Info_rlc_Size_fdd to
 *      common_dynamic_tf_info_rlc_size_fdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_dynamic_tf_info_rlc_size_fdd
(
 UMTS_CommonDynamicTF_Info_rlc_Size_fdd     *pvalue,
 common_dynamic_tf_info_rlc_size_fdd_t      *p_common_dynamic_tf_info_rlc_size_fdd 
 )
{
    convert_octet_mode_rlc_size_info_type2(
            &pvalue->octetModeRLC_SizeInfoType2,
            &p_common_dynamic_tf_info_rlc_size_fdd->octet_mode_RLC_sizeInfoType2);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice
 *
 *   DESCRIPTION:
 *      This function UMTS_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice to
 *      common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice
(
 UMTS_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice    *pvalue,
 common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice_t    *p_common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice 
 )
{
    p_common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice->t = pvalue->t;

    if (pvalue->t == T_UMTS_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice_bitModeRLC_SizeInfo)
    {
        convert_bit_mode_rlc_size_info(
                pvalue->u.bitModeRLC_SizeInfo,
                &p_common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice->u.
                bit_modeRLC_sizeinfo); 
    }
    else if (pvalue->t == T_UMTS_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice_octetModeRLC_SizeInfoType1)
    {
        convert_octet_mode_rlc_size_info_type_1(
                pvalue->u.octetModeRLC_SizeInfoType1,
                &p_common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice->u.
                octet_mode_RLC_sizeinfoType1); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_dynamic_tf_info_rlc_size_tdd
 *
 *   DESCRIPTION:
 *      This function UMTS_CommonDynamicTF_Info_rlc_Size_tdd to
 *      common_dynamic_tf_info_rlc_size_tdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_dynamic_tf_info_rlc_size_tdd
(
 UMTS_CommonDynamicTF_Info_rlc_Size_tdd     *pvalue,
 common_dynamic_tf_info_rlc_size_tdd_t      *p_common_dynamic_tf_info_rlc_size_tdd 
 )
{
    convert_common_dynamic_tf_info_rlc_size_tdd_common_tdd_choice(
            &pvalue->commonTDD_Choice,
            &p_common_dynamic_tf_info_rlc_size_tdd->commonTDD_choice);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_dynamic_tf_info_rlc_size
 *
 *   DESCRIPTION:
 *      This function UMTS_CommonDynamicTF_Info_rlc_Size to
 *      common_dynamic_tf_info_rlc_size_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_dynamic_tf_info_rlc_size
(
 UMTS_CommonDynamicTF_Info_rlc_Size *pvalue,
 common_dynamic_tf_info_rlc_size_t  *p_common_dynamic_tf_info_rlc_size 
 )
{
    p_common_dynamic_tf_info_rlc_size->t = pvalue->t;

    if (pvalue->t == T_UMTS_CommonDynamicTF_Info_rlc_Size_fdd)
    {
        convert_common_dynamic_tf_info_rlc_size_fdd(
                pvalue->u.fdd,
                &p_common_dynamic_tf_info_rlc_size->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_CommonDynamicTF_Info_rlc_Size_tdd)
    {
        convert_common_dynamic_tf_info_rlc_size_tdd(
                pvalue->u.tdd,
                &p_common_dynamic_tf_info_rlc_size->u.tdd); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_dynamic_tf_info_list
 *
 *   DESCRIPTION:
 *      This function UMTS_CommonDynamicTF_InfoList to
 *      common_dynamic_tf_info_list_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_dynamic_tf_info_list
(
 UMTS_CommonDynamicTF_InfoList  *pvalue,
 common_dynamic_tf_info_list_t  *p_common_dynamic_tf_info_list
 )
{
    UMTS_CommonDynamicTF_Info   *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_common_dynamic_tf_info_list->count = pvalue->count;

    for (index = 0; index < pvalue->count; index++)
    {
        pdata = (UMTS_CommonDynamicTF_Info*)pnode->data;

        convert_common_dynamic_tf_info_rlc_size(
                &pdata->rlc_Size,
                &p_common_dynamic_tf_info_list->common_dynamicTF_info[index].rlc_size);

        /* CommonDynamicTF_Info_numberOfTbSizeList */
        convert_common_dynamic_tf_info_num_of_tb_size_list(
                &pdata->numberOfTbSizeList,
                &p_common_dynamic_tf_info_list->common_dynamicTF_info[index].num_of_TBsize_list);

        /* LogicalChannelList */
        convert_logical_channel_list(
                &pdata->logicalChannelList,
                &p_common_dynamic_tf_info_list->common_dynamicTF_info[index].logical_channel_list);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_trans_ch_tfs_tti
 *
 *   DESCRIPTION:
 *      This function UMTS_CommonTransChTFS_tti to
 *      common_trans_ch_tfs_tti_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_trans_ch_tfs_tti
(
 UMTS_CommonTransChTFS_tti  *pvalue,
 common_trans_ch_tfs_tti_t  *p_common_trans_ch_tfs_tti
 )
{
    p_common_trans_ch_tfs_tti->t = pvalue->t;

    if (pvalue->t == T_UMTS_CommonTransChTFS_tti_tti10)
    {
        convert_common_dynamic_tf_info_list(pvalue->u.tti10, &p_common_trans_ch_tfs_tti->u.tti10);
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_tti_tti20)
    {
        convert_common_dynamic_tf_info_list(pvalue->u.tti20, &p_common_trans_ch_tfs_tti->u.tti20);
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_tti_tti40)
    {
        convert_common_dynamic_tf_info_list(pvalue->u.tti40, &p_common_trans_ch_tfs_tti->u.tti40);
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_tti_tti80)
    {
        convert_common_dynamic_tf_info_list(pvalue->u.tti80, &p_common_trans_ch_tfs_tti->u.tti80);
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_tti_dynamic)
    {
        convert_common_dynamic_tf_info_list_dynamic_tti(pvalue->u.dynamic, 
                &p_common_trans_ch_tfs_tti->u.dynamic);
    }

    return;
}

/******************************************************************************

 *   FUNCTION NAME: convert_channel_coding_type
 *
 *   DESCRIPTION:
 *      This function UMTS_ChannelCodingType to
 *      channel_coding_type_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_channel_coding_type
(
 UMTS_ChannelCodingType     *pvalue,
 channel_coding_type_t      *p_channel_coding_type 
 )
{
    p_channel_coding_type->t = pvalue->t;

    if (pvalue->t == T_UMTS_ChannelCodingType_noCoding)
    {
        /* not used */
    }
    else if (pvalue->t == T_UMTS_ChannelCodingType_convolutional)
    {
        p_channel_coding_type->u.codingRate_convolutional = pvalue->u.convolutional; 
    }
    else if (pvalue->t == T_UMTS_ChannelCodingType_turbo)
    {
        /* not used */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_semistatic_tf_information
 *
 *   DESCRIPTION:
 *      This function UMTS_SemistaticTF_Information to
 *      semistatic_tf_information_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_semistatic_tf_information
(
 UMTS_SemistaticTF_Information      *pvalue,
 semistatic_tf_information_t        *p_semistatic_tf_information 
 )
{
    convert_channel_coding_type(
            &pvalue->channelCodingType,
            &p_semistatic_tf_information->channel_codingType);

    p_semistatic_tf_information->rateMatchingAttribute = pvalue->rateMatchingAttribute;
    p_semistatic_tf_information->CRC_size = pvalue->crc_Size;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_trans_ch_tfs
 *
 *   DESCRIPTION:
 *      This function UMTS_CommonTransChTFS to
 *      common_trans_ch_tfs_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_common_trans_ch_tfs
(
 UMTS_CommonTransChTFS      *pvalue,
 common_trans_ch_tfs_t      *p_common_trans_ch_tfs 
 )
{
    convert_common_trans_ch_tfs_tti (
            &pvalue->tti, 
            &p_common_trans_ch_tfs->tti);

    convert_semistatic_tf_information(
            &pvalue->semistaticTF_Information,
            &p_common_trans_ch_tfs->semistatic_TF_Information);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dedicated_trans_ch_tfs
 *
 *   DESCRIPTION:
 *      This function 
 *      UMTS_DedicatedTransChTFS to
 *      dedicated_trans_ch_tfs_t
 *
 *******************************************************************************/
void convert_dedicated_trans_ch_tfs
(
 UMTS_DedicatedTransChTFS   *pvalue,
 dedicated_trans_ch_tfs_t   *p_dedicated_trans_ch_tfs 
 )
{
    convert_dedicated_trans_ch_tfs_tti(
            &pvalue->tti,
            &p_dedicated_trans_ch_tfs->tti);

    convert_semistatic_tf_information(
            &pvalue->semistaticTF_Information,
            &p_dedicated_trans_ch_tfs->semistaticTF_information);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_transport_format_set
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_TransportFormatSet to
 *      transport_format_set_t
 *
 *******************************************************************************/
void convert_transport_format_set
(
 UMTS_TransportFormatSet    *pvalue,
 transport_format_set_t     *p_transport_format_set
 )
{
    p_transport_format_set->t = pvalue->t;

    if (pvalue->t == T_UMTS_TransportFormatSet_dedicatedTransChTFS)
    {
        convert_dedicated_trans_ch_tfs(
                pvalue->u.dedicatedTransChTFS,
                &p_transport_format_set->u.dedicated_trans_ChTFS);
    }
    else if (pvalue->t == T_UMTS_TransportFormatSet_commonTransChTFS)
    {
        convert_common_trans_ch_tfs(
                pvalue->u.commonTransChTFS,
                &p_transport_format_set->u.common_transChTFS);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_available_signatures
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AvailableSignatures to
 *      available_signatures_t
 *
 *******************************************************************************/
void convert_available_signatures
(
 UMTS_AvailableSignatures   *pvalue,
 available_signatures_t     *p_available_signatures 
 )
{
    U32 index;

    p_available_signatures->numbits = pvalue->numbits;

    for (index = 0; index < pvalue->numbits; index ++)
    {
        p_available_signatures->data[index] = pvalue->data[index];
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_available_subchannel_numbers
 *
 *   DESCRIPTION:
 *      This function converts UMTS_AvailableSubChannelNumbers to
 *      available_subchannel_numbers_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_available_subchannel_numbers
(
 UMTS_AvailableSubChannelNumbers    *pvalue,
 available_subchannel_numbers_t     *p_available_subchannel_numbers 
 )
{
    U32 index;

    p_available_subchannel_numbers->numbits = pvalue->numbits;

    for (index = 0; index < pvalue->numbits; index ++)
    {
        p_available_subchannel_numbers->data[index] = pvalue->data[index]; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_rach_info_modespecific_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_RACH_Info_modeSpecificInfo_fdd to
 *      prach_rach_info_modespecific_info_fdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_rach_info_modespecific_info_fdd
(
 UMTS_PRACH_RACH_Info_modeSpecificInfo_fdd  *pvalue,
 prach_rach_info_modespecific_info_fdd_t    *p_prach_rach_info_modespecific_info_fdd 
 )
{
    convert_available_signatures(
            &pvalue->availableSignatures,
            &p_prach_rach_info_modespecific_info_fdd->available_Signatures);

    p_prach_rach_info_modespecific_info_fdd->available_SF = pvalue->availableSF;

    p_prach_rach_info_modespecific_info_fdd->preambleScramblingCodeWordNumber =
        pvalue->preambleScramblingCodeWordNumber;

    p_prach_rach_info_modespecific_info_fdd->puncturing_Limit =
        pvalue->puncturingLimit;

    convert_available_subchannel_numbers(
            &pvalue->availableSubChannelNumbers,
            &p_prach_rach_info_modespecific_info_fdd->available_subchannel_numbers);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tdd_prach_ccode_list_sf8
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TDD_PRACH_CCodeList_sf8 to
 *      tdd_prach_ccode_list_sf8_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tdd_prach_ccode_list_sf8
(
 UMTS_TDD_PRACH_CCodeList_sf8   *pvalue,
 tdd_prach_ccode_list_sf8_t     *p_tdd_prach_ccode_list_sf8 
 )
{
    U32 index;

    p_tdd_prach_ccode_list_sf8->n = pvalue->n;

    for (index = 0; index < pvalue->n; index ++)
    {
        p_tdd_prach_ccode_list_sf8->elem[index] = pvalue->elem[index]; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tdd_prach_ccode_list_sf16
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TDD_PRACH_CCodeList_sf16 to
 *      tdd_prach_ccode_list_sf16_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tdd_prach_ccode_list_sf16
(
 UMTS_TDD_PRACH_CCodeList_sf16  *pvalue,
 tdd_prach_ccode_list_sf16_t    *p_tdd_prach_ccode_list_sf16 
 )
{
    U32 index;

    p_tdd_prach_ccode_list_sf16->n = pvalue->n;

    for (index = 0; index < pvalue->n; index ++)
    {
        p_tdd_prach_ccode_list_sf16->elem[index] = pvalue->elem[index];
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tdd_prach_ccode_list
 *
 *   DESCRIPTION:
 *      This function converts UMTS_TDD_PRACH_CCodeList to
 *      tdd_prach_ccode_list_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_tdd_prach_ccode_list
(
 UMTS_TDD_PRACH_CCodeList   *pvalue,
 tdd_prach_ccode_list_t     *p_tdd_prach_ccode_list 
 )
{
    p_tdd_prach_ccode_list->t = pvalue->t;

    if (pvalue->t == T_UMTS_TDD_PRACH_CCodeList_sf8)
    {
        convert_tdd_prach_ccode_list_sf8(
                pvalue->u.sf8,
                &p_tdd_prach_ccode_list->u.sf8); 
    }
    else if (pvalue->t == T_UMTS_TDD_PRACH_CCodeList_sf16)
    {
        convert_tdd_prach_ccode_list_sf16(
                pvalue->u.sf16,
                &p_tdd_prach_ccode_list->u.sf16); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_rach_info_modespecific_info_tdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_RACH_Info_modeSpecificInfo_tdd to
 *      prach_rach_info_modespecific_info_tdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_rach_info_modespecific_info_tdd
(
 UMTS_PRACH_RACH_Info_modeSpecificInfo_tdd  *pvalue,
 prach_rach_info_modespecific_info_tdd_t    *p_prach_rach_info_modespecific_info_tdd 
 )
{
    p_prach_rach_info_modespecific_info_tdd->timeslot_number =
        pvalue->timeslot;

    convert_tdd_prach_ccode_list(
            &pvalue->channelisationCodeList,
            &p_prach_rach_info_modespecific_info_tdd->channelisation_CodeList);

    p_prach_rach_info_modespecific_info_tdd->prach_Midamble =
        pvalue->prach_Midamble;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_rach_info_modespecific_info
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_RACH_Info_modeSpecificInfo to
 *      prach_rach_info_modespecific_info_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_rach_info_modespecific_info
(
 UMTS_PRACH_RACH_Info_modeSpecificInfo      *pvalue,
 prach_rach_info_modespecific_info_t        *p_prach_rach_info_modespecific_info 
 )
{
    p_prach_rach_info_modespecific_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_PRACH_RACH_Info_modeSpecificInfo_fdd)
    {
        convert_prach_rach_info_modespecific_info_fdd(
                pvalue->u.fdd,
                &p_prach_rach_info_modespecific_info->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_PRACH_RACH_Info_modeSpecificInfo_tdd)
    {
        convert_prach_rach_info_modespecific_info_tdd(
                pvalue->u.tdd,
                &p_prach_rach_info_modespecific_info->u.tdd); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_rach_info
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_RACH_Info to
 *      prach_rach_info_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_rach_info
(
 UMTS_PRACH_RACH_Info   *pvalue,
 prach_rach_info_t      *p_prach_rach_info
 )
{
    convert_prach_rach_info_modespecific_info(
            &pvalue->modeSpecificInfo,
            &p_prach_rach_info->modeSpecific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_fdd_assigned_sub_channel_number
 *
 *   DESCRIPTION:
 *      This function convert 
 *      UMTS_AccessServiceClass_FDD_assignedSubChannelNumber
 *      to access_service_class_fdd_assigned_sub_channel_number_t
 *
 *******************************************************************************/
void convert_access_service_class_fdd_assigned_sub_channel_number
(
 UMTS_AccessServiceClass_FDD_assignedSubChannelNumber   *pvalue,
 access_service_class_fdd_assigned_sub_channel_number_t *p_number 
 )
{
    U32 index;
    p_number->numbits = pvalue->numbits;

    for (index = 0; index < pvalue->numbits; index ++)
    {
        p_number->data[index] = pvalue->data[index];
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_fdd
 *
 *   DESCRIPTION:
 *      This function convert 
 *      UMTS_AccessServiceClass_FDD to
 *      access_service_class_fdd_t
 *
 *******************************************************************************/
void convert_access_service_class_fdd
(
 UMTS_AccessServiceClass_FDD    *pvalue,
 access_service_class_fdd_t     *p_access_service_class_fdd 
 )
{
    p_access_service_class_fdd->available_signature_start_index =
        pvalue->availableSignatureStartIndex;

    p_access_service_class_fdd->available_signature_end_index =
        pvalue->availableSignatureEndIndex;

    convert_access_service_class_fdd_assigned_sub_channel_number(
            &pvalue->assignedSubChannelNumber,
            &p_access_service_class_fdd->assigned_sub_channel_number);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_partitioning_fdd
 *
 *   DESCRIPTION:
 *      This function convert UMTS_PRACH_Partitioning_fdd to
 *      prach_partitioning_fdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_partitioning_fdd
(
 UMTS_PRACH_Partitioning_fdd    *pvalue,
 prach_partitioning_fdd_t       *prach_partition_fdd
 )
{
    UMTS_ASCSetting_FDD     *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    prach_partition_fdd->count = pvalue->count;

    for (index = 0; index < pvalue->count; index++)
    {
        pdata = (UMTS_ASCSetting_FDD*)pnode->data;

        if (pdata->m.accessServiceClass_FDDPresent)
        {
            prach_partition_fdd->ascs_settingFDD[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_PARTITIONING_ASCS_SETTING_FDD_PRESENCE_FLAG;

            convert_access_service_class_fdd(
                    &pdata->accessServiceClass_FDD,
                    &prach_partition_fdd->ascs_settingFDD[index].access_service_class_FDD); 
        }

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_subchannel_size_size2
 *
 *   DESCRIPTION:
 *      This function converts UMTS_AccessServiceClass_TDD_subchannelSize_size2
 *      to access_service_class_tdd_subchannel_size_size2_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_access_service_class_tdd_subchannel_size_size2
(
 UMTS_AccessServiceClass_TDD_subchannelSize_size2   *pvalue,
 access_service_class_tdd_subchannel_size_size2_t   *p_access_service_class_tdd_subchannel_size_size2 
 )
{
    if (pvalue->m.subchannelsPresent)
    {
        p_access_service_class_tdd_subchannel_size_size2->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_PARTITIONING_ACCESS_SERVICE_CLASS_TDD_SUB_CHANN_PRESENCE_FLAG;

        p_access_service_class_tdd_subchannel_size_size2->sub_channels =
            pvalue->subchannels; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_subchannel_size_size4
 *
 *   DESCRIPTION:
 *      This function converts UMTS_AccessServiceClass_TDD_subchannelSize_size4
 *      to access_service_class_tdd_subchannel_size_size4_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_access_service_class_tdd_subchannel_size_size4
(
 UMTS_AccessServiceClass_TDD_subchannelSize_size4   *pvalue,
 access_service_class_tdd_subchannel_size_size4_t   *p_access_service_class_tdd_subchannel_size_size4 
 )
{
    U32 index;

    if (pvalue->m.subchannelsPresent)
    {
        p_access_service_class_tdd_subchannel_size_size4->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_PARTITIONING_ACCESS_SERVICE_CLASS_TDD_SUB_CHANN_SIZE4_PRESENCE_FLAG;

        p_access_service_class_tdd_subchannel_size_size4->sub_channels.numbits =
            pvalue->subchannels.numbits;

        for (index = 0; index < pvalue->subchannels.numbits; index ++)
        {
            p_access_service_class_tdd_subchannel_size_size4->sub_channels.data[index] =
                pvalue->subchannels.data[index]; 
        }
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_subchannel_size_size8
 *
 *   DESCRIPTION:
 *      This function converts UMTS_AccessServiceClass_TDD_subchannelSize_size8
 *      to access_service_class_tdd_subchannel_size_size8_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_access_service_class_tdd_subchannel_size_size8
(
 UMTS_AccessServiceClass_TDD_subchannelSize_size8   *pvalue,
 access_service_class_tdd_subchannel_size_size8_t   *p_access_service_class_tdd_subchannel_size_size8 
 )
{
    U32 index;

    if (pvalue->m.subchannelsPresent)
    {
        p_access_service_class_tdd_subchannel_size_size8->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_PARTITIONING_ACCESS_SERVICE_CLASS_TDD_SUB_CHANN_SIZE8_PRESENCE_FLAG;

        p_access_service_class_tdd_subchannel_size_size8->sub_channels.numbits =
            pvalue->subchannels.numbits;

        for (index = 0; index < pvalue->subchannels.numbits; index ++)
        {
            p_access_service_class_tdd_subchannel_size_size8->sub_channels.data[index] =
                pvalue->subchannels.data[index]; 
        }
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_subchannel_size
 *
 *   DESCRIPTION:
 *      This function converts UMTS_AccessServiceClass_TDD_subchannelSize to
 *      access_service_class_tdd_subchannel_size_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_access_service_class_tdd_subchannel_size
(
 UMTS_AccessServiceClass_TDD_subchannelSize *pvalue,
 access_service_class_tdd_subchannel_size_t *p_access_service_class_tdd_subchannel_size 
 )
{
    p_access_service_class_tdd_subchannel_size->t = pvalue->t;

    if (pvalue->t == T_UMTS_AccessServiceClass_TDD_subchannelSize_size1)
    {
        /* not used   */ 
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_subchannelSize_size2)
    {
        convert_access_service_class_tdd_subchannel_size_size2(
                pvalue->u.size2,
                &p_access_service_class_tdd_subchannel_size->u.size2);  
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_subchannelSize_size4)
    {
        convert_access_service_class_tdd_subchannel_size_size4(
                pvalue->u.size4,
                &p_access_service_class_tdd_subchannel_size->u.size4);
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_subchannelSize_size8)
    {
        convert_access_service_class_tdd_subchannel_size_size8(
                pvalue->u.size8,
                &p_access_service_class_tdd_subchannel_size->u.size8);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_AccessServiceClass_TDD to
 *      access_service_class_tdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_access_service_class_tdd
(
 UMTS_AccessServiceClass_TDD    *pvalue,
 access_service_class_tdd_t     *p_access_service_class_tdd 
 )
{
    U32 index;

    if (pvalue->m.channelisationCodeIndicesPresent)
    {
        p_access_service_class_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_PARTITIONING_ACCESS_SERVICE_CLASS_TDD_CHANNEL_CODE_INDICES_PRESENCE_FLAG;

        p_access_service_class_tdd->channelisation_CodeIndices.numbits =
            pvalue->channelisationCodeIndices.numbits;

        for (index = 0; index < pvalue->channelisationCodeIndices.numbits; index ++)
        {
            p_access_service_class_tdd->channelisation_CodeIndices.data[index] =
                pvalue->channelisationCodeIndices.data[index];    
        }
    }

    convert_access_service_class_tdd_subchannel_size(
            &pvalue->subchannelSize,
            &p_access_service_class_tdd->subchannel_Size);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_partitioning_tdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_Partitioning_tdd to
 *      prach_partitioning_tdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_partitioning_tdd
(
 UMTS_PRACH_Partitioning_tdd    *pvalue,
 prach_partitioning_tdd_t       *p_prach_partitioning_tdd 
 )
{
    UMTS_ASCSetting_TDD     *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_prach_partitioning_tdd->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ASCSetting_TDD*)pnode->data;

        if (pdata->m.accessServiceClass_TDDPresent)
        {
            p_prach_partitioning_tdd->ascs_settingTDD[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_PARTITIONING_ASCS_SETTING_TDD_PRESENCE_FLAG;

            convert_access_service_class_tdd(
                    &pdata->accessServiceClass_TDD,
                    &p_prach_partitioning_tdd->ascs_settingTDD[index].access_service_class_TDD);  
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_partitioning
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_Partitioning to
 *      prach_partitioning_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_partitioning
(
 UMTS_PRACH_Partitioning    *pvalue,
 prach_partitioning_t       *p_prach_partition
 )
{
    p_prach_partition->t = pvalue->t;

    if (pvalue->t == T_UMTS_PRACH_Partitioning_fdd)
    {
        convert_prach_partitioning_fdd(
                pvalue->u.fdd, 
                &p_prach_partition->u.fdd);
    }

    else if (pvalue->t == T_UMTS_PRACH_Partitioning_tdd)
    {
        convert_prach_partitioning_tdd(
                pvalue->u.tdd,
                &p_prach_partition->u.tdd);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_poweroffset
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_PowerOffset
 *      to prach_poweroffset_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_prach_poweroffset
(
 UMTS_PRACH_PowerOffset     *pvalue,
 prach_poweroffset_t        *p_prach_poweroffset 
 )
{
    p_prach_poweroffset->powerRampStep = pvalue->powerRampStep;
    p_prach_poweroffset->preambleRetransMax = pvalue->preambleRetransMax;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_rach_transmission_parameters
 *
 *   DESCRIPTION:
 *      This function converts UMTS_RACH_TransmissionParameters
 *      to rach_transmission_parameters_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_rach_transmission_parameters
(
 UMTS_RACH_TransmissionParameters   *pvalue,
 rach_transmission_parameters_t     *p_rach_transmission_parameters 
 )
{
    p_rach_transmission_parameters->mmax = pvalue->mmax;
    p_rach_transmission_parameters->nb01_Min = pvalue->nb01Min;
    p_rach_transmission_parameters->nb01_Max = pvalue->nb01Max; 

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_aich_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AICH_Info
 *      to aich_info_t
 *
 *******************************************************************************/
void convert_aich_info
(
 UMTS_AICH_Info     *pvalue,
 aich_info_t        *p_aich_info 
 )
{
    p_aich_info->channelisation_Code256 = pvalue->channelisationCode256;
    p_aich_info->sttd_indicator = pvalue->sttd_Indicator;
    p_aich_info->aich_Transmission_Timing = pvalue->aich_TransmissionTiming;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information_modespecific_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_SystemInformation_modeSpecificInfo_fdd
 *      to prach_system_information_modespecific_info_fdd_t and checks whether 
 *      input data are valid.
 *
 *******************************************************************************/
void convert_prach_system_information_modespecific_info_fdd
(
 UMTS_PRACH_SystemInformation_modeSpecificInfo_fdd  *pvalue,
 prach_system_information_modespecific_info_fdd_t   *p_prach_system_information_modespecific_info_fdd
 )
{
    if (pvalue->m.primaryCPICH_TX_PowerPresent)
    {
        p_prach_system_information_modespecific_info_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_SYSINFO_MODE_SPECIFIC_INFO_FDD_PRIM_CPICH_TX_PWR_PRESENCE_FLAG;

        p_prach_system_information_modespecific_info_fdd->primaryCPICH_TX_Power =
            pvalue->primaryCPICH_TX_Power;
    }

    if (pvalue->m.constantValuePresent)
    {
        p_prach_system_information_modespecific_info_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_SYSINFO_MODE_SPECIFIC_INFO_FDD_CONST_VAL_PRESENCE_FLAG;

        p_prach_system_information_modespecific_info_fdd->constant_value =
            pvalue->constantValue;
    }

    if (pvalue->m.prach_PowerOffsetPresent)
    {
        p_prach_system_information_modespecific_info_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_SYSINFO_MODE_SPECIFIC_INFO_FDD_PRACH_PWROFFSET_PRESENCE_FLAG;

        convert_prach_poweroffset(
                &pvalue->prach_PowerOffset,
                &p_prach_system_information_modespecific_info_fdd->prach_powerOffset);
    }

    if (pvalue->m.rach_TransmissionParametersPresent)
    {
        p_prach_system_information_modespecific_info_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_SYSINFO_MODE_SPECIFIC_INFO_FDD_RACH_TRANS_PARAM_PRESENCE_FLAG;

        convert_rach_transmission_parameters(
                &pvalue->rach_TransmissionParameters,
                &p_prach_system_information_modespecific_info_fdd->rach_transmissionParameters);
    }

    if (pvalue->m.aich_InfoPresent)
    {
        p_prach_system_information_modespecific_info_fdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_SYSINFO_MODE_SPECIFIC_INFO_FDD_AICH_INFO_PRESENCE_FLAG;

        convert_aich_info(
                &pvalue->aich_Info,
                &p_prach_system_information_modespecific_info_fdd->aich_info); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information_modespecific_info
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_SystemInformation_modeSpecificInfo to
 *      prach_system_information_modespecific_info_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_system_information_modespecific_info
(
 UMTS_PRACH_SystemInformation_modeSpecificInfo  *pvalue,
 prach_system_information_modespecific_info_t   *prach_modeSpecificInfo
 )
{
    prach_modeSpecificInfo->t = pvalue->t;

    if (pvalue->t == T_UMTS_PRACH_SystemInformation_modeSpecificInfo_fdd)
    {
        convert_prach_system_information_modespecific_info_fdd(
                pvalue->u.fdd,
                &prach_modeSpecificInfo->u.fdd); 
    }
    else if (pvalue->t == T_UMTS_PRACH_SystemInformation_modeSpecificInfo_tdd)
    {
        /* not used */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_persistence_scaling_factorlist
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PersistenceScalingFactorList to
 *      persistence_scaling_factorlist_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_persistence_scaling_factorlist
(
 UMTS_PersistenceScalingFactorList  *pvalue,
 persistence_scaling_factorlist_t   *p_persistence_scaling_factorlist 
 )
{
    U32 index;

    p_persistence_scaling_factorlist->n = pvalue->n;

    for (index = 0; index < pvalue->n; index++)
    {
        p_persistence_scaling_factorlist->elem[index] = pvalue->elem[index];
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ac_to_asc_mapping_table
 *
 *   DESCRIPTION:
 *      This function converts UMTS_AC_To_ASC_MappingTable to
 *      ac_to_asc_mapping_table_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_ac_to_asc_mapping_table
(
 UMTS_AC_To_ASC_MappingTable    *pvalue,
 ac_to_asc_mapping_table_t      *p_ac_to_asc_mapping_table 
 )
{
    U32 index;

    p_ac_to_asc_mapping_table->n = pvalue->n;

    for (index = 0; index < pvalue->n; index++)
    {
        p_ac_to_asc_mapping_table->elem[index] = pvalue->elem[index];
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_SystemInformation to
 *      prach_system_information_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_system_information
(
 UMTS_PRACH_SystemInformation   *pvalue,
 prach_system_information_t     *p_prach_system_information
 )
{
    convert_prach_rach_info ( 
            &pvalue->prach_RACH_Info, 
            &p_prach_system_information->prach_RACH_info );

    p_prach_system_information->transportChannel_Identity = pvalue->transportChannelIdentity;

    if (pvalue->m.rach_TransportFormatSetPresent)
    {
        p_prach_system_information->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_RACH_TRANSPORT_FORMAT_SET_PRESENCE_FLAG;

        convert_transport_format_set(
                &pvalue->rach_TransportFormatSet,
                &p_prach_system_information->rach_TransportFormatSet); 
    }

    if (pvalue->m.rach_TFCSPresent)
    {
        p_prach_system_information->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_RACH_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->rach_TFCS,
                &p_prach_system_information->rach_TFCS);
    }

    if (pvalue->m.prach_PartitioningPresent)
    {
        p_prach_system_information->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PRACH_PARTITIONING_PRESENCE_FLAG;

        convert_prach_partitioning(
                &pvalue->prach_Partitioning,
                &p_prach_system_information->prach_Partitioning); 
    }

    if (pvalue->m.persistenceScalingFactorListPresent)
    {
        p_prach_system_information->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_PERSISTENCE_SCALING_FACTOR_LIST_PRESENCE_FLAG;

        convert_persistence_scaling_factorlist(
                &pvalue->persistenceScalingFactorList,
                &p_prach_system_information->persistence_scaling_factor_list);
    }

    if (pvalue->m.ac_To_ASC_MappingTablePresent)
    {
        p_prach_system_information->presence_bitmask |=
            UMTS_SIB_TYPE_5_INFO_PRACH_SYS_INFO_AC_TO_ASC_MAPPING_TABLE_PRESENCE_FLAG;

        convert_ac_to_asc_mapping_table(
                &pvalue->ac_To_ASC_MappingTable,
                &p_prach_system_information->ac_to_ASC_MappingTable);
    }

    convert_prach_system_information_modespecific_info(
            &pvalue->modeSpecificInfo,
            &p_prach_system_information->modeSpecific_Info);
}  

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information_list
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PRACH_SystemInformationList to
 *      prach_system_information_list_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_prach_system_information_list
(
 UMTS_PRACH_SystemInformationList   *pvalue,
 prach_system_information_list_t    *p_prach_system_information_list
 )
{
    UMTS_PRACH_SystemInformation    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;  

    pnode = pvalue->head;
    p_prach_system_information_list->count = pvalue->count;

    for (index = 0; index < pvalue->count; index++)
    {
        pdata = (UMTS_PRACH_SystemInformation*)pnode->data;

        convert_prach_system_information (
                pdata, &p_prach_system_information_list->prach_sys_info[index]);

        pnode = pnode->next;
    }    
}

/******************************************************************************
 *   FUNCTION NAME: convert_repetition_period_n_length
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_RepetitionPeriodAndLength to
 *      repetition_period_n_length_t
 *
 *******************************************************************************/
void convert_repetition_period_n_length
(
 UMTS_RepetitionPeriodAndLength  *pvalue,
 repetition_period_n_length_t    *p_repetition_period_n_length
 )
{
    p_repetition_period_n_length->t = pvalue->t;

    if (pvalue->t == T_UMTS_RepetitionPeriodAndLength_repetitionPeriod1)
    {
        /* unused */  
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodAndLength_repetitionPeriod2)
    {
        p_repetition_period_n_length->u.repetition_period_2 = pvalue->u.repetitionPeriod2; 
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodAndLength_repetitionPeriod4)
    {
        p_repetition_period_n_length->u.repetition_period_4 = pvalue->u.repetitionPeriod4; 
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodAndLength_repetitionPeriod8)
    {
        p_repetition_period_n_length->u.repetition_period_8 = pvalue->u.repetitionPeriod8; 
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodAndLength_repetitionPeriod16)
    {
        p_repetition_period_n_length->u.repetition_period_16 = pvalue->u.repetitionPeriod16; 
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodAndLength_repetitionPeriod32)
    {
        p_repetition_period_n_length->u.repetition_period_32 = pvalue->u.repetitionPeriod32; 
    }
    else if (pvalue->t == T_UMTS_RepetitionPeriodAndLength_repetitionPeriod64)
    {
        p_repetition_period_n_length->u.repetition_period_64 =  pvalue->u.repetitionPeriod64; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonTimeslotInfo to
 *      common_timeslot_info_t
 *
 *******************************************************************************/
void convert_common_timeslot_info
(
 UMTS_CommonTimeslotInfo *pvalue,
 common_timeslot_info_t  *p_common_timeslot_info
 )
{
    p_common_timeslot_info->second_interLeaving_mode = 
        pvalue->secondInterleavingMode; 

    if (pvalue->m.tfci_CodingPresent)
    {
        p_common_timeslot_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_COMMON_TIMESLOT_INFO_TFCI_CODING_PRESENCE_FLAG;

        p_common_timeslot_info->tfci_coding = pvalue->tfci_Coding; 
    }

    p_common_timeslot_info->puncturing_limit = pvalue->puncturingLimit;

    if (pvalue->m.repetitionPeriodAndLengthPresent)
    {
        p_common_timeslot_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_COMMON_TIMESLOT_INFO_REPETITION_PERIOD_AND_LEN_PRESENCE_FLAG;

        convert_repetition_period_n_length(
                &pvalue->repetitionPeriodAndLength,
                &p_common_timeslot_info->repetition_PerionAndlength); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ul_ts_channelisation_code_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UL_TS_ChannelisationCodeList to
 *      ul_ts_channelisation_code_list_t 
 *
 *******************************************************************************/
void convert_ul_ts_channelisation_code_list
(
 UMTS_UL_TS_ChannelisationCodeList  *pvalue,
 ul_ts_channelisation_code_list_t   *p_ul_ts_channelisation_codelist 
 )
{
    U32                                 index;

    p_ul_ts_channelisation_codelist->n = pvalue->n;

    for (index = 0; index < pvalue->n; index ++)
    {
        p_ul_ts_channelisation_codelist->elem[index] = pvalue->elem[index];
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_additional_timeslots_parameters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkAdditionalTimeslots_parameters to
 *      uplink_additional_timeslots_parameters_t
 *
 *******************************************************************************/
void convert_uplink_additional_timeslots_parameters
(
 UMTS_UplinkAdditionalTimeslots_parameters  *pvalue,
 uplink_additional_timeslots_parameters_t   *p_param 
 )
{
    p_param->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkAdditionalTimeslots_parameters_sameAsLast)
    {
        p_param->u.same_as_last.timeslot_number =
            pvalue->u.sameAsLast->timeslotNumber; 
    }
    else if (pvalue->t == T_UMTS_UplinkAdditionalTimeslots_parameters_newParameters)
    {
        convert_individual_timeslot_info(
                &pvalue->u.newParameters->individualTimeslotInfo,
                &p_param->u.new_parameters.individual_timeslot_info);

        convert_ul_ts_channelisation_code_list(
                &pvalue->u.newParameters->ul_TS_ChannelisationCodeList,
                &p_param->u.new_parameters.ul_ts_channelisation_code_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList to
 *      uplink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list
(
 UMTS_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList   *pvalue,
 uplink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list_t *p_list
 )
{
    UMTS_UplinkAdditionalTimeslots  *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_UplinkAdditionalTimeslots*)pnode->data;

        convert_uplink_additional_timeslots_parameters(
                &pdata->parameters,
                &p_list->uplink_additional_timeslots[index].parameters);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_more_timeslots_additional_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots to
 *      uplink_timeslots_codes_more_timeslots_additional_timeslots_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_more_timeslots_additional_timeslots
(
 UMTS_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots    *pvalue,
 uplink_timeslots_codes_more_timeslots_additional_timeslots_t   *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_consecutive)
    {
        p_info->u.consecutive.num_additional_timeslots =
            pvalue->u.consecutive->numAdditionalTimeslots;
    }
    else if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList)
    {
        convert_uplink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list(
                pvalue->u.timeslotList,
                &p_info->u.timeslot_list); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_more_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_moreTimeslots to
 *      uplink_timeslots_codes_more_timeslots_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_more_timeslots
(
 UMTS_UplinkTimeslotsCodes_moreTimeslots    *pvalue,
 uplink_timeslots_codes_more_timeslots_t    *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_moreTimeslots_noMore)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots)
    {
        convert_uplink_timeslots_codes_more_timeslots_additional_timeslots(
                pvalue->u.additionalTimeslots,
                &p_info->u.additional_timeslots); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes to
 *      uplink_timeslots_codes_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes
(
 UMTS_UplinkTimeslotsCodes   *pvalue,
 uplink_timeslots_codes_t    *p_uplink_timeslots_codes
 )
{
    p_uplink_timeslots_codes->dynamic_fusage = pvalue->dynamicSFusage;

    convert_individual_timeslot_info(
            &pvalue->firstIndividualTimeslotInfo,
            &p_uplink_timeslots_codes->first_individual_timeslot_info);

    convert_ul_ts_channelisation_code_list(
            &pvalue->ul_TS_ChannelisationCodeList,
            &p_uplink_timeslots_codes->ul_ts_channelisation_code_list);

    convert_uplink_timeslots_codes_more_timeslots(
            &pvalue->moreTimeslots,
            &p_uplink_timeslots_codes->more_timeslots);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_Info to
 *      pusch_info_t 
 *
 *******************************************************************************/
void convert_pusch_info
(
 UMTS_PUSCH_Info *pvalue,
 pusch_info_t    *p_pusch_info
 )
{
    p_pusch_info->tfcs_id = pvalue->tfcs_ID;

    if (pvalue->m.commonTimeslotInfoPresent)
    {
        p_pusch_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_COMMON_TIMESLOT_INFO_PRESENCE_FLAG;

        convert_common_timeslot_info(
                &pvalue->commonTimeslotInfo,
                &p_pusch_info->common_timeslot_info); 
    }

    if (pvalue->m.pusch_TimeslotsCodesPresent)
    {
        p_pusch_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_TIMESLOTS_CODES_PRESENCE_FLAG;

        convert_uplink_timeslots_codes(
                &pvalue->pusch_TimeslotsCodes,
                &p_pusch_info->pusch_timeslots_codes);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sysinfo
 *
 *   DESCRIPTION:
 *      This function converts PUSCH_SysInfo to
 *      pusch_SysInfoList_SFN_element_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_pusch_sysinfo 
(
 UMTS_PUSCH_SysInfo     *pvalue,
 pusch_sysinfo_t        *p_pusch_sysinfo
 )
{
    p_pusch_sysinfo->pusch_identity = pvalue->pusch_Identity;

    convert_pusch_info (
            &pvalue->pusch_Info,
            &p_pusch_sysinfo->pusch_info);

    if (pvalue->m.usch_TFSPresent)
    {
        p_pusch_sysinfo->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_USCH_TFS_PRESENCE_FLAG;

        convert_transport_format_set (
                &pvalue->usch_TFS,
                &p_pusch_sysinfo->uschTFS);
    }

    if (pvalue->m.usch_TFCSPresent)
    {
        p_pusch_sysinfo->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_USCH_TFCS_PRESENCE_FLAG;

        convert_tfcs (
                &pvalue->usch_TFCS,
                &p_pusch_sysinfo->usch_tfcs);
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_sfn_time_info 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SFN_TimeInfo to
 *      sfn_time_info_t
 *
 *******************************************************************************/
void convert_sfn_time_info
(
 UMTS_SFN_TimeInfo  *pvalue,
 sfn_time_info_t    *p_info 
 )
{
    p_info->activation_time_sfn =
        pvalue->activationTimeSFN;

    p_info->phys_ch_duration =
        pvalue->physChDuration;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sysinfo_list_sfn 
 *
 *   DESCRIPTION:
 *      This function converts PUSCH_SysInfoList_SFN to
 *      pusch_sysinfo_list_sfn_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_pusch_sysinfo_list_sfn
(
 UMTS_PUSCH_SysInfoList_SFN     *pvalue,
 pusch_sysinfo_list_sfn_t       *p_pusch_sysinfo_list_sfn
 )
{
    UMTS_PUSCH_SysInfoList_SFN_element  *pdata = NULL;;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;    

    pnode = pvalue->head;
    p_pusch_sysinfo_list_sfn->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PUSCH_SysInfoList_SFN_element*)pnode->data;

        convert_pusch_sysinfo(
                &pdata->pusch_SysInfo,
                &p_pusch_sysinfo_list_sfn->pusch_SysInfo_list_SFN_elememt[index].pusch_sysinfo);

        if (pdata->m.sfn_TimeInfoPresent)
        {
            p_pusch_sysinfo_list_sfn->pusch_SysInfo_list_SFN_elememt[index].presence_bitmask |=
                UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_SFN_TIMEINFO_PRESENCE_FLAG;

            convert_sfn_time_info(
                    &pdata->sfn_TimeInfo,
                    &p_pusch_sysinfo_list_sfn->pusch_SysInfo_list_SFN_elememt[index].sfn_timeinfo);
        }

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_dl_ts_channelisation_codes_short_codes_representation_consecutive
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DL_TS_ChannelisationCodesShort_codesRepresentation_consecutive 
 *      to dl_ts_channelisation_codes_short_codes_representation_consecutive_t
 *
 *******************************************************************************/
void convert_dl_ts_channelisation_codes_short_codes_representation_consecutive
(
 UMTS_DL_TS_ChannelisationCodesShort_codesRepresentation_consecutive    *pvalue,
 dl_ts_channelisation_codes_short_codes_representation_consecutive_t    *p_info 
 )
{
    p_info->first_channelisation_code =
        pvalue->firstChannelisationCode;

    p_info->last_channelisation_code =
        pvalue->lastChannelisationCode;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dl_ts_channelisation_codes_short_codes_representation_bitmap
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DL_TS_ChannelisationCodesShort_codesRepresentation_bitmap
 *      to dl_ts_channelisation_codes_short_codes_representation_bitmap_t
 *
 *******************************************************************************/
void convert_dl_ts_channelisation_codes_short_codes_representation_bitmap
(
 UMTS_DL_TS_ChannelisationCodesShort_codesRepresentation_bitmap *pvalue,
 dl_ts_channelisation_codes_short_codes_representation_bitmap_t *p_info 
 )
{
    U32     index;

    p_info->numbits = pvalue->numbits;

    for (index = 0; index < pvalue->numbits; index++)
    {
        p_info->data[index] = pvalue->data[index];
    } 

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dl_ts_channelisation_codes_short
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DL_TS_ChannelisationCodesShort to
 *      dl_ts_channelisation_codes_short_t
 *
 *******************************************************************************/
void convert_dl_ts_channelisation_codes_short
(
 UMTS_DL_TS_ChannelisationCodesShort    *pvalue,
 dl_ts_channelisation_codes_short_t     *p_dl_ts_channelisation_codes_short 
 )
{
    p_dl_ts_channelisation_codes_short->codes_representation.t =
        pvalue->codesRepresentation.t;

    if (pvalue->codesRepresentation.t == 
            T_UMTS_DL_TS_ChannelisationCodesShort_codesRepresentation_consecutive)
    {
        convert_dl_ts_channelisation_codes_short_codes_representation_consecutive(
                pvalue->codesRepresentation.u.consecutive,
                &p_dl_ts_channelisation_codes_short->codes_representation.u.consecutive); 
    }
    else if (pvalue->codesRepresentation.t ==
            T_UMTS_DL_TS_ChannelisationCodesShort_codesRepresentation_bitmap)
    {
        convert_dl_ts_channelisation_codes_short_codes_representation_bitmap(
                pvalue->codesRepresentation.u.bitmap,
                &p_dl_ts_channelisation_codes_short->codes_representation.u.bitmap);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_additional_timeslots_parameters_new_parameters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkAdditionalTimeslots_parameters_newParameters
 *      to downlink_additional_timeslots_parameters_new_parameters_t
 *
 *******************************************************************************/
void convert_downlink_additional_timeslots_parameters_new_parameters
(
 UMTS_DownlinkAdditionalTimeslots_parameters_newParameters  *pvalue,
 downlink_additional_timeslots_parameters_new_parameters_t  *p_params 
 )
{
    convert_individual_timeslot_info(
            &pvalue->individualTimeslotInfo,
            &p_params->individual_timeslot_info);

    convert_dl_ts_channelisation_codes_short(
            &pvalue->dl_TS_ChannelisationCodesShort,
            &p_params->dl_ts_channelisation_codes_short);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_additional_timeslots_parameters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkAdditionalTimeslots_parameters
 *      to downlink_additional_timeslots_parameters_t
 *
 *******************************************************************************/
void convert_downlink_additional_timeslots_parameters
(
 UMTS_DownlinkAdditionalTimeslots_parameters    *pvalue,
 downlink_additional_timeslots_parameters_t     *p_downlink_additional_timeslots_parameters 
 )
{
    p_downlink_additional_timeslots_parameters->t = pvalue->t;

    if (pvalue->t == T_UMTS_DownlinkAdditionalTimeslots_parameters_sameAsLast)
    {
        p_downlink_additional_timeslots_parameters->u.same_as_last.timeslot_number =
            pvalue->u.sameAsLast->timeslotNumber;
    }
    else if (pvalue->t == T_UMTS_DownlinkAdditionalTimeslots_parameters_newParameters)
    {
        convert_downlink_additional_timeslots_parameters_new_parameters(
                pvalue->u.newParameters,
                &p_downlink_additional_timeslots_parameters->u.new_parameters); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList
 *      to downlink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list
(
 UMTS_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList     *pvalue,
 downlink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list_t   *p_list 
 )
{
    UMTS_DownlinkAdditionalTimeslots    *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_DownlinkAdditionalTimeslots*)pnode->data;

        convert_downlink_additional_timeslots_parameters(
                &pdata->parameters,
                &p_list->downlink_additional_timeslots[index].parameters);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_more_timeslots_additional_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_moreTimeslots to
 *      downlink_timeslots_codes_more_timeslots_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_more_timeslots_additional_timeslots
(
 UMTS_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots  *pvalue,
 downlink_timeslots_codes_more_timeslots_additional_timeslots_t *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_consecutive)
    {
        p_info->u.consecutive = pvalue->u.consecutive; 
    }
    else if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList)
    {
        convert_downlink_timeslots_codes_more_timeslots_additional_timeslots_timeslot_list(
                pvalue->u.timeslotList,
                &p_info->u.timeslotList); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_more_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_moreTimeslots to
 *      downlink_timeslots_codes_more_timeslots_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_more_timeslots
(
 UMTS_DownlinkTimeslotsCodes_moreTimeslots  *pvalue,
 downlink_timeslots_codes_more_timeslots_t  *p_downlink_timeslots_codes_more_timeslots 
 )
{
    p_downlink_timeslots_codes_more_timeslots->t = pvalue->t;

    if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_moreTimeslots_noMore)
    {
        /*  not used */   
    }
    else if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots)   
    {
        convert_downlink_timeslots_codes_more_timeslots_additional_timeslots(
                pvalue->u.additionalTimeslots,
                &p_downlink_timeslots_codes_more_timeslots->u.additional_timeslots);  
    } 

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes to
 *      downlink_timeslots_codes_t 
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes
(
 UMTS_DownlinkTimeslotsCodes    *pvalue,
 downlink_timeslots_codes_t     *p_downlink_timeslots_codes 
 )
{
    convert_individual_timeslot_info(
            &pvalue->firstIndividualTimeslotInfo,
            &p_downlink_timeslots_codes->first_individual_timeslot_info);

    convert_dl_ts_channelisation_codes_short(
            &pvalue->dl_TS_ChannelisationCodesShort,
            &p_downlink_timeslots_codes->dl_ts_channelisation_codes_short);

    convert_downlink_timeslots_codes_more_timeslots(
            &pvalue->moreTimeslots,
            &p_downlink_timeslots_codes->more_timeslots);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_Info to
 *      pdsch_info_t 
 *
 *******************************************************************************/
void convert_pdsch_info
(
 UMTS_PDSCH_Info    *pvalue,
 pdsch_info_t       *p_pdsch_info 
 )
{
    p_pdsch_info->tfcs_id = pvalue->tfcs_ID;

    if (pvalue->m.commonTimeslotInfoPresent)
    {
        p_pdsch_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_PDSCH_SYSINFOLIST_COMMON_TIMESLOT_INFO_PRESENCE_FLAG;

        convert_common_timeslot_info(
                &pvalue->commonTimeslotInfo,
                &p_pdsch_info->common_timeslot_info);    
    }

    if (pvalue->m.pdsch_TimeslotsCodesPresent)
    {
        p_pdsch_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_PDSCH_SYSINFOLIST_PDSCH_TIMESLOTS_CODES_PRESENCE_FLAG;

        convert_downlink_timeslots_codes(
                &pvalue->pdsch_TimeslotsCodes,
                &p_pdsch_info->pdsch_timeslots_codes);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_SysInfo
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PDSCH_SysInfo to
 *      pdsch_SysInfo_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_pdsch_SysInfo
(
 UMTS_PDSCH_SysInfo     *pvalue,
 pdsch_SysInfo_t        *p_pdsch_SysInfo 
 )
{
    p_pdsch_SysInfo->pdsch_identity = pvalue->pdsch_Identity;

    convert_pdsch_info(
            &pvalue->pdsch_Info,
            &p_pdsch_SysInfo->pdsch_info);

    if (pvalue->m.dsch_TFSPresent)
    {
        p_pdsch_SysInfo->presence_bitmask |=
            UMTS_SIB_TYPE_5_PDSCH_SYSINFOLIST_SFN_DSCH_TFS_PRESENCE_FLAG;

        convert_transport_format_set(
                &pvalue->dsch_TFS,
                &p_pdsch_SysInfo->dsch_TFS);
    }

    if (pvalue->m.dsch_TFCSPresent)
    {
        p_pdsch_SysInfo->presence_bitmask |=
            UMTS_SIB_TYPE_5_PDSCH_SYSINFOLIST_SFN_DSCH_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->dsch_TFCS,
                &p_pdsch_SysInfo->dsch_TFCS);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sysinfo_list_sfn
 *
 *   DESCRIPTION:
 *      This function converts UMTS_PDSCH_SysInfoList_SFN to
 *      pdsch_sysinfo_list_sfn_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_pdsch_sysinfo_list_sfn
(
 UMTS_PDSCH_SysInfoList_SFN     *pvalue,
 pdsch_sysinfo_list_sfn_t       *p_pdsch_sysinfo_list_sfn 
 )
{
    UMTS_PDSCH_SysInfoList_SFN_element  *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_pdsch_sysinfo_list_sfn->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PDSCH_SysInfoList_SFN_element*)pnode->data;

        convert_pdsch_SysInfo(
                &pdata->pdsch_SysInfo,
                &p_pdsch_sysinfo_list_sfn->pdsch_SysInfo_list_SFN_elememt[index].pdsch_SysInfo);

        if (pdata->m.sfn_TimeInfoPresent)
        {
            p_pdsch_sysinfo_list_sfn->pdsch_SysInfo_list_SFN_elememt[index].presence_bitmask |= 
                UMTS_SIB_TYPE_5_PDSCH_SYSINFOLIST_SFN_TIMEINFO_PRESENCE_FLAG;

            convert_sfn_time_info(
                    &pdata->sfn_TimeInfo,
                    &p_pdsch_sysinfo_list_sfn->pdsch_SysInfo_list_SFN_elememt[index].sfn_timeInfo); 
        }

        pnode = pnode->next;
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_openLoop_powerControl_tdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_OpenLoopPowerControl_TDD to
 *      openLoop_powerControl_tdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_openLoop_powerControl_tdd
(
 UMTS_OpenLoopPowerControl_TDD  *pvalue,
 openLoop_powerControl_tdd_t    *p_openLoop_powerControl_tdd 
 )
{
    p_openLoop_powerControl_tdd->primary_ccpx_tx_power = pvalue->primaryCCPCH_TX_Power;

    if (pvalue->m.alphaPresent)
    {
        p_openLoop_powerControl_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_OPENLOOP_PWRCTRL_TDD_ALPHA_PRESENCE_FLAG;

        p_openLoop_powerControl_tdd->alpha = pvalue->alpha; 
    }

    p_openLoop_powerControl_tdd->prach_constant_value_tdd = pvalue->prach_ConstantValue;
    p_openLoop_powerControl_tdd->dpch_constant_value_tdd = pvalue->dpch_ConstantValue;

    if (pvalue->m.pusch_ConstantValuePresent)
    {
        p_openLoop_powerControl_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_OPENLOOP_PWRCTRL_TDD_PUSCH_CONST_VAL_PRESENCE_FLAG;

        p_openLoop_powerControl_tdd->pusch_constant_value_tdd = pvalue->pusch_ConstantValue;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfo_type5_modespecific_info_tdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SysInfoType5_modeSpecificInfo_tdd to
 *      sysinfo_type5_modespecific_info_tdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sysinfo_type5_modespecific_info_tdd
(
 UMTS_SysInfoType5_modeSpecificInfo_tdd     *pvalue,
 sysinfo_type5_modespecific_info_tdd_t      *p_sysinfo_type5_modespecific_info_tdd
 )
{
    if (pvalue->m.pusch_SysInfoList_SFNPresent)
    {
        p_sysinfo_type5_modespecific_info_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PUSCH_SYSINFO_LIST_PRESENCE_FLAG;

        convert_pusch_sysinfo_list_sfn(
                &pvalue->pusch_SysInfoList_SFN,
                &p_sysinfo_type5_modespecific_info_tdd->pusch_SysInfo_list_SFN);
    }

    if (pvalue->m.pdsch_SysInfoList_SFNPresent)
    {
        p_sysinfo_type5_modespecific_info_tdd->presence_bitmask |=
            UMTS_SIB_TYPE_5_CELL_SELECT_MODE_SPECIFIC_INFO_TDD_PDSCH_SYSINFO_LIST_PRESENCE_FLAG;

        convert_pdsch_sysinfo_list_sfn(
                &pvalue->pdsch_SysInfoList_SFN,
                &p_sysinfo_type5_modespecific_info_tdd->pdsch_SysInfo_list_SFN);
    }

    convert_openLoop_powerControl_tdd(
            &pvalue->openLoopPowerControl_TDD,
            &p_sysinfo_type5_modespecific_info_tdd->openLoop_PowerControl_TDD);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfo_type5_modespecific_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SysInfoType5_modeSpecificInfo_fdd to
 *      sysinfo_type5_modespecific_info_fdd_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sysinfo_type5_modespecific_info_fdd
(
 UMTS_SysInfoType5_modeSpecificInfo_fdd     *pvalue,
 sysinfo_type5_modespecific_info_fdd_t      *p_sysinfo_type5_modespecific_info_fdd
 )
{
    p_sysinfo_type5_modespecific_info_fdd->aich_poweroffset = pvalue->aich_PowerOffset;
    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sib_type_5_mode_specific_info
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SysInfoType5_modeSpecificInfo to
 *      sysinfo_type5_modespecific_info_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sib_type_5_mode_specific_info
(
 UMTS_SysInfoType5_modeSpecificInfo     *pvalue,
 sysinfo_type5_modespecific_info_t      *p_sysinfo_type5_modespecific_info
 )
{
    p_sysinfo_type5_modespecific_info->t = pvalue->t; 

    if (pvalue->t == T_UMTS_SysInfoType5_modeSpecificInfo_fdd)
    {
        convert_sysinfo_type5_modespecific_info_fdd(
                pvalue->u.fdd,
                &p_sysinfo_type5_modespecific_info->u.fdd);
    }
    else if (pvalue->t == T_UMTS_SysInfoType5_modeSpecificInfo_tdd)
    {
        convert_sysinfo_type5_modespecific_info_tdd(
                pvalue->u.tdd,
                &p_sysinfo_type5_modespecific_info->u.tdd); 
    }
}

/******************************************************************************
 *   FUNCTION NAME: convert_cbs_drx_level1_information
 *
 *   DESCRIPTION:
 *      This function converts UMTS_CBS_DRX_Level1Information to
 *      cbs_drx_level1_information_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_cbs_drx_level1_information
(
 UMTS_CBS_DRX_Level1Information *pvalue,
 cbs_drx_level1_information_t   *p_cbs_drx_level1_information 
 )
{
    p_cbs_drx_level1_information->ctch_allocation_period = pvalue->ctch_AllocationPeriod;
    p_cbs_drx_level1_information->cbs_frame_offset = pvalue->cbs_FrameOffset;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pnbsch_allocation_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PNBSCH_Allocation_r4 to
 *      pnbsch_allocation_r4_t
 *
 *******************************************************************************/
void convert_pnbsch_allocation_r4
(
 UMTS_PNBSCH_Allocation_r4      *pvalue,
 pnbsch_allocation_r4_t         *p_pnbsch_allocation_r4
 )
{
    p_pnbsch_allocation_r4->number_of_repetitions_per_sfn_period = 
        pvalue->numberOfRepetitionsPerSFNPeriod;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_open_loop_power_control_ipdl_tdd_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_OpenLoopPowerControl_IPDL_TDD_r4 to
 *      open_loop_power_control_ipdl_tdd_r4_t
 *
 *******************************************************************************/
void convert_open_loop_power_control_ipdl_tdd_r4
(
 UMTS_OpenLoopPowerControl_IPDL_TDD_r4      *pvalue,
 open_loop_power_control_ipdl_tdd_r4_t      *p_tdd
 )
{
    p_tdd->ipdl_alpha = pvalue->ipdl_alpha;
    p_tdd->max_power_increase = pvalue->maxPowerIncrease;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sync_ul_codes_bitmap
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_Sync_UL_Codes_Bitmap to
 *      sync_ul_codes_bitmap_t
 *
 *******************************************************************************/
void convert_sync_ul_codes_bitmap
(
 UMTS_Sync_UL_Codes_Bitmap  *pvalue,
 sync_ul_codes_bitmap_t     *p_bitmap 
 )
{
    p_bitmap->numbits = pvalue->numbits;

    memcpy(&p_bitmap->data,
            &pvalue->data,
            (sizeof(U8)*p_bitmap->numbits));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sync_ul_info_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SYNC_UL_Info_r4 to
 *      sync_ul_info_r4_t
 *
 *******************************************************************************/
void convert_sync_ul_info_r4
(
 UMTS_SYNC_UL_Info_r4   *pvalue,
 sync_ul_info_r4_t      *p_r4 
 )
{
    convert_sync_ul_codes_bitmap(
            &pvalue->sync_UL_Codes_Bitmap,
            &p_r4->sync_ul_codes_bitmap);

    p_r4->prx_up_pch_des = pvalue->prxUpPCHdes;
    p_r4->power_ramp_step = pvalue->powerRampStep;
    p_r4->max_sync_ul_transmissions = pvalue->max_SYNC_UL_Transmissions;
    p_r4->mmax = pvalue->mmax;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_chan_codes_lcr_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_ChanCodes_LCR_r4 to
 *      prach_chan_codes_lcr_r4_t
 *
 *******************************************************************************/
void convert_prach_chan_codes_lcr_r4
(
 UMTS_PRACH_ChanCodes_LCR_r4    *pvalue,
 prach_chan_codes_lcr_r4_t      *p_lcr_r4
 )
{
    p_lcr_r4->n = pvalue->n;

    memcpy(&p_lcr_r4->elem,
            &pvalue->elem,
            (sizeof(U32)*p_lcr_r4->n));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode_ue_specific_midamble
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode_ueSpecificMidamble to
 *      midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode_ue_specific_midamble_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode_ue_specific_midamble
(
 UMTS_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode_ueSpecificMidamble        *pvalue,
 midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode_ue_specific_midamble_t   *p_info 
 )
{
    p_info->midamble_shift = pvalue->midambleShift;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode to
 *      midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode       *pvalue,
 midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode_t    *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode_commonMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode_ueSpecificMidamble)
    {
        convert_midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode_ue_specific_midamble(
                pvalue->u.ueSpecificMidamble,
                &p_mode->u.ue_specific_midamble);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_lcr_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_LCR_r4 to
 *      midamble_shift_and_burst_type_lcr_r4_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_lcr_r4
(
 UMTS_MidambleShiftAndBurstType_LCR_r4  *pvalue,
 midamble_shift_and_burst_type_lcr_r4_t *p_lcr_r4 
 )
{
    convert_midamble_shift_and_burst_type_lcr_r4_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_lcr_r4->midamble_allocation_mode);

    p_lcr_r4->midamble_configuration =
        pvalue->midambleConfiguration;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_fpach_info_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_FPACH_Info_r4 to
 *      fpach_info_r4_t
 *
 *******************************************************************************/
void convert_fpach_info_r4
(
 UMTS_FPACH_Info_r4     *pvalue,
 fpach_info_r4_t        *p_r4 
 )
{
    p_r4->timeslot = pvalue->timeslot;
    p_r4->channelisation_code = pvalue->channelisationCode;

    convert_midamble_shift_and_burst_type_lcr_r4(
            &pvalue->midambleShiftAndBurstType,
            &p_r4->midamble_shift_and_burst_type_lcr_r4);

    p_r4->wi = pvalue->wi;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_definition_lcr_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_Definition_LCR_r4 to
 *      prach_definition_lcr_r4_t
 *
 *******************************************************************************/
void convert_prach_definition_lcr_r4
(
 UMTS_PRACH_Definition_LCR_r4   *pvalue,
 prach_definition_lcr_r4_t      *p_lcr_r4 
 )
{
    p_lcr_r4->timeslot = pvalue->timeslot;

    convert_prach_chan_codes_lcr_r4(
            &pvalue->prach_ChanCodes_LCR,
            &p_lcr_r4->prach_chan_codes_lcr_r4);

    convert_midamble_shift_and_burst_type_lcr_r4(
            &pvalue->midambleShiftAndBurstType,
            &p_lcr_r4->midamble_shift_and_burst_type_lcr_r4);

    convert_fpach_info_r4(
            &pvalue->fpach_Info,
            &p_lcr_r4->fpach_info_r4);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_rach_info_lcr_r4_prach_definition_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_RACH_Info_LCR_r4_prach_DefinitionList to
 *      prach_rach_info_lcr_r4_prach_definition_list_t
 *
 *******************************************************************************/
void convert_prach_rach_info_lcr_r4_prach_definition_list
(
 UMTS_PRACH_RACH_Info_LCR_r4_prach_DefinitionList   *pvalue,
 prach_rach_info_lcr_r4_prach_definition_list_t     *p_list
 )
{
    UMTS_PRACH_Definition_LCR_r4    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PRACH_Definition_LCR_r4*)pnode->data;

        convert_prach_definition_lcr_r4(
                pdata,
                &p_list->prach_definition_lcr_r4[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_rach_info_lcr_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_RACH_Info_LCR_r4 to
 *      prach_rach_info_lcr_r4_t
 *
 *******************************************************************************/
void convert_prach_rach_info_lcr_r4
(
 UMTS_PRACH_RACH_Info_LCR_r4    *pvalue,
 prach_rach_info_lcr_r4_t       *p_lcr_r4 
 )
{
    convert_sync_ul_info_r4(
            &pvalue->sync_UL_Info,
            &p_lcr_r4->sync_ul_info_r4);

    convert_prach_rach_info_lcr_r4_prach_definition_list(
            &pvalue->prach_DefinitionList,
            &p_lcr_r4->prach_definition_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_trans_ch_tfs_lcr_tti 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonTransChTFS_LCR_tti to
 *      common_trans_ch_tfs_lcr_tti_t
 *
 *******************************************************************************/
void convert_common_trans_ch_tfs_lcr_tti
(
 UMTS_CommonTransChTFS_LCR_tti  *pvalue,
 common_trans_ch_tfs_lcr_tti_t  *p_tti 
 )
{
    p_tti->t = pvalue->t;

    if (pvalue->t == T_UMTS_CommonTransChTFS_LCR_tti_tti5)
    {
        convert_common_dynamic_tf_info_list(
                pvalue->u.tti5,
                &p_tti->u.tti5); 
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_LCR_tti_tti10)
    {
        convert_common_dynamic_tf_info_list(
                pvalue->u.tti10,
                &p_tti->u.tti10); 
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_LCR_tti_tti20)
    {
        convert_common_dynamic_tf_info_list(
                pvalue->u.tti20,
                &p_tti->u.tti20); 
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_LCR_tti_tti40)
    {
        convert_common_dynamic_tf_info_list(
                pvalue->u.tti40,
                &p_tti->u.tti40); 
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_LCR_tti_tti80)
    {
        convert_common_dynamic_tf_info_list(
                pvalue->u.tti80,
                &p_tti->u.tti80); 
    }
    else if (pvalue->t == T_UMTS_CommonTransChTFS_LCR_tti_dynamic)
    {
        convert_common_dynamic_tf_info_list_dynamic_tti(
                pvalue->u.dynamic,
                &p_tti->u.dynamic);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_trans_ch_tfs_lcr 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonTransChTFS_LCR to
 *      common_trans_ch_tfs_lcr_t
 *
 *******************************************************************************/
void convert_common_trans_ch_tfs_lcr
(
 UMTS_CommonTransChTFS_LCR  *pvalue,
 common_trans_ch_tfs_lcr_t  *p_lcr
 )
{
    convert_common_trans_ch_tfs_lcr_tti(
            &pvalue->tti,
            &p_lcr->tti);

    convert_semistatic_tf_information(
            &pvalue->semistaticTF_Information,
            &p_lcr->semistatic_tf_information);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_transport_format_set_lcr 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_TransportFormatSet_LCR to
 *      transport_format_set_lcr_t
 *
 *******************************************************************************/
void convert_transport_format_set_lcr
(
 UMTS_TransportFormatSet_LCR    *pvalue,
 transport_format_set_lcr_t     *p_lcr 
 )
{
    p_lcr->t = pvalue->t;

    if (pvalue->t == T_UMTS_TransportFormatSet_LCR_dedicatedTransChTFS)
    {
        convert_dedicated_trans_ch_tfs(
                pvalue->u.dedicatedTransChTFS,
                &p_lcr->u.dedicated_trans_ch_tfs);
    }
    else if (pvalue->t == T_UMTS_TransportFormatSet_LCR_commonTransChTFS_LCR)
    {
        convert_common_trans_ch_tfs_lcr(
                pvalue->u.commonTransChTFS_LCR,
                &p_lcr->u.ccommon_trans_ch_tfs_lcr); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_lcr_r4_available_sync_ul_codes_indics 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_LCR_r4_availableSYNC_UlCodesIndics to
 *      access_service_class_tdd_lcr_r4_available_sync_ul_codes_indics_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_lcr_r4_available_sync_ul_codes_indics
(
 UMTS_AccessServiceClass_TDD_LCR_r4_availableSYNC_UlCodesIndics     *pvalue,
 access_service_class_tdd_lcr_r4_available_sync_ul_codes_indics_t   *p_indics 
 )
{
    p_indics->numbits = pvalue->numbits;

    memcpy(&p_indics->data,
            &pvalue->data,
            (sizeof(U8)*p_indics->numbits));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_lcr_r4_subchannel_size_size2 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2 to
 *      access_service_class_tdd_lcr_r4_subchannel_size_size2_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_lcr_r4_subchannel_size_size2
(
 UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2    *pvalue,
 access_service_class_tdd_lcr_r4_subchannel_size_size2_t    *p_size2
 )
{
    if (pvalue->m.subchannelsPresent)
    {
        p_size2->presence_bitmask |=
            UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_LCR_R4_SUBCHANNEL_SIZE_SIZE2_SUBCHANNELS_PRESENCE_FLAG;

        p_size2->subchannels = pvalue->subchannels;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_lcr_r4_subchannel_size_size4_subchannels 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4_subchannels to
 *      access_service_class_tdd_lcr_r4_subchannel_size_size4_subchannels_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_lcr_r4_subchannel_size_size4_subchannels
(
 UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4_subchannels    *pvalue,
 access_service_class_tdd_lcr_r4_subchannel_size_size4_subchannels_t    *p_subchannel 
 )
{
    p_subchannel->numbits = pvalue->numbits;

    memcpy(&p_subchannel->data,
            &pvalue->data,
            sizeof(U8)*p_subchannel->numbits);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_lcr_r4_subchannel_size_size4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4 to
 *      access_service_class_tdd_lcr_r4_subchannel_size_size4_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_lcr_r4_subchannel_size_size4
(
 UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4    *pvalue,
 access_service_class_tdd_lcr_r4_subchannel_size_size4_t    *p_size4
 )
{
    if (pvalue->m.subchannelsPresent)
    {
        p_size4->presence_bitmask |=
            UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_LCR_R4_SUBCHANNEL_SIZE_SIZE4_SUBCHANNELS_PRESENCE_FLAG;

        convert_access_service_class_tdd_lcr_r4_subchannel_size_size4_subchannels(
                &pvalue->subchannels,
                &p_size4->subchannels);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_lcr_r4_subchannel_size_size8_subchannels 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8_subchannels to
 *      access_service_class_tdd_lcr_r4_subchannel_size_size8_subchannels_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_lcr_r4_subchannel_size_size8_subchannels
(
 UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8_subchannels    *pvalue,
 access_service_class_tdd_lcr_r4_subchannel_size_size8_subchannels_t    *p_subchannel
 )
{
    p_subchannel->numbits = pvalue->numbits;

    memcpy(&p_subchannel->data,
            &pvalue->data,
            sizeof(U8)*p_subchannel->numbits);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_lcr_r4_subchannel_size_size8 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8 to
 *      access_service_class_tdd_lcr_r4_subchannel_size_size8_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_lcr_r4_subchannel_size_size8
(
 UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8    *pvalue,
 access_service_class_tdd_lcr_r4_subchannel_size_size8_t    *p_size8 
 )
{
    if (pvalue->m.subchannelsPresent)
    {
        p_size8->presence_bitmask |=
            UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_LCR_R4_SUBCHANNEL_SIZE_SIZE8_SUBCHANNELS_PRESENCE_FLAG;

        convert_access_service_class_tdd_lcr_r4_subchannel_size_size8_subchannels(
                &pvalue->subchannels,
                &p_size8->subchannels);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_lcr_r4_sub_channel_size 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize to
 *      access_service_class_tdd_lcr_r4_sub_channel_size_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_lcr_r4_sub_channel_size
(
 UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize  *pvalue,
 access_service_class_tdd_lcr_r4_sub_channel_size_t *p_size 
 )
{
    p_size->t = pvalue->t;

    if (pvalue->t == T_UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size1)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2)
    {
        convert_access_service_class_tdd_lcr_r4_subchannel_size_size2(
                pvalue->u.size2,
                &p_size->u.size2); 
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4)
    {
        convert_access_service_class_tdd_lcr_r4_subchannel_size_size4(
                pvalue->u.size4,
                &p_size->u.size4); 
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8)
    {
        convert_access_service_class_tdd_lcr_r4_subchannel_size_size8(
                pvalue->u.size8,
                &p_size->u.size8); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_LCR_r4 to
 *      access_service_class_tdd_lcr_r4_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_lcr_r4
(
 UMTS_AccessServiceClass_TDD_LCR_r4     *pvalue,
 access_service_class_tdd_lcr_r4_t      *p_lcr_r4 
 )
{
    if (pvalue->m.availableSYNC_UlCodesIndicsPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_LCR_R4_AVAILABLE_SYNC_UL_CODES_INDICS_PRESENCE_FLAG;

        convert_access_service_class_tdd_lcr_r4_available_sync_ul_codes_indics(
                &pvalue->availableSYNC_UlCodesIndics,
                &p_lcr_r4->available_sync_ul_codes_indics);
    }

    convert_access_service_class_tdd_lcr_r4_sub_channel_size(
            &pvalue->subchannelSize,
            &p_lcr_r4->sub_channel_size);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_asc_setting_tdd_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_ASCSetting_TDD_LCR_r4 to
 *      asc_setting_tdd_lcr_r4_t
 *
 *******************************************************************************/
void convert_asc_setting_tdd_lcr_r4
(
 UMTS_ASCSetting_TDD_LCR_r4     *pvalue,
 asc_setting_tdd_lcr_r4_t       *p_lcr_r4
 )
{
    if (pvalue->m.accessServiceClass_TDD_LCRPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_ASC_SETTING_TDD_LCR_R4_ACCESS_SERVICE_CLASS_TDD_LCR_R4_PRESENCE_FLAG;

        convert_access_service_class_tdd_lcr_r4(
                &pvalue->accessServiceClass_TDD_LCR,
                &p_lcr_r4->access_service_class_tdd_lcr_r4);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_partitioning_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_Partitioning_LCR_r4 to
 *      prach_partitioning_lcr_r4_t
 *
 *******************************************************************************/
void convert_prach_partitioning_lcr_r4
(
 UMTS_PRACH_Partitioning_LCR_r4     *pvalue,
 prach_partitioning_lcr_r4_t        *p_lcr_r4 
 )
{
    UMTS_ASCSetting_TDD_LCR_r4  *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ASCSetting_TDD_LCR_r4*)pnode->data;

        convert_asc_setting_tdd_lcr_r4(
                pdata,
                &p_lcr_r4->asc_setting_tdd_lcr_r4[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_SystemInformation_LCR_r4 to
 *      prach_system_information_lcr_r4_t
 *
 *******************************************************************************/
void convert_prach_system_information_lcr_r4
(
 UMTS_PRACH_SystemInformation_LCR_r4    *pvalue,
 prach_system_information_lcr_r4_t      *p_lcr_r4 
 )
{
    convert_prach_rach_info_lcr_r4(
            &pvalue->prach_RACH_Info_LCR,
            &p_lcr_r4->prach_rach_info_lcr_r4);

    if (pvalue->m.rach_TransportFormatSet_LCRPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_PRACH_SYSTEM_INFORMATION_LCR_R4_TRANSPORT_FORMAT_SET_PRESENCE_FLAG;

        convert_transport_format_set_lcr(
                &pvalue->rach_TransportFormatSet_LCR,
                &p_lcr_r4->transport_format_set_lcr);
    }

    if (pvalue->m.prach_Partitioning_LCRPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_PRACH_SYSTEM_INFORMATION_LCR_R4_PRACH_PARTITIONING_LCR_R4_PRESENCE_FLAG;

        convert_prach_partitioning_lcr_r4(
                &pvalue->prach_Partitioning_LCR,
                &p_lcr_r4->prach_partitioning_lcr_r4);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information_list_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_SystemInformationList_LCR_r4 to
 *      prach_system_information_list_lcr_r4_t
 *
 *******************************************************************************/
void convert_prach_system_information_list_lcr_r4
(
 UMTS_PRACH_SystemInformationList_LCR_r4    *pvalue,
 prach_system_information_list_lcr_r4_t     *p_lcr_r4
 )
{
    UMTS_PRACH_SystemInformation_LCR_r4 *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PRACH_SystemInformation_LCR_r4*)pnode->data;

        convert_prach_system_information_lcr_r4(
                pdata,
                &p_lcr_r4->prach_system_information_lcr_r4[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_consecutive 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_consecutive to
 *      uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_consecutive_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_consecutive
(
 UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_consecutive     *pvalue,
 uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_consecutive_t    *p_info 
 )
{
    p_info->num_additional_timeslots = pvalue->numAdditionalTimeslots;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_additional_timeslots_lcr_r4_parameters_same_as_last 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast to
 *      uplink_additional_timeslots_lcr_r4_parameters_same_as_last_t
 *
 *******************************************************************************/
void convert_uplink_additional_timeslots_lcr_r4_parameters_same_as_last
(
 UMTS_UplinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast    *pvalue,
 uplink_additional_timeslots_lcr_r4_parameters_same_as_last_t   *p_info 
 )
{
    p_info->timeslot_number = pvalue->timeslotNumber;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_additional_timeslots_lcr_r4_parameters_new_parameters 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters to
 *      uplink_additional_timeslots_lcr_r4_parameters_new_parameters_t
 *
 *******************************************************************************/
void convert_uplink_additional_timeslots_lcr_r4_parameters_new_parameters
(
 UMTS_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters     *pvalue,
 uplink_additional_timeslots_lcr_r4_parameters_new_parameters_t     *p_info 
 )
{
    convert_individual_timeslot_info_lcr_r4(
            &pvalue->individualTimeslotInfo,
            &p_info->individual_timeslot_info);

    convert_ul_ts_channelisation_code_list(
            &pvalue->ul_TS_ChannelisationCodeList,
            &p_info->ul_ts_channelisation_code_list); 

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_additional_timeslots_lcr_r4_parameters 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkAdditionalTimeslots_LCR_r4_parameters to
 *      uplink_additional_timeslots_lcr_r4_parameters_t
 *
 *******************************************************************************/
void convert_uplink_additional_timeslots_lcr_r4_parameters
(
 UMTS_UplinkAdditionalTimeslots_LCR_r4_parameters   *pvalue,
 uplink_additional_timeslots_lcr_r4_parameters_t    *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast)
    {
        convert_uplink_additional_timeslots_lcr_r4_parameters_same_as_last(
                pvalue->u.sameAsLast,
                &p_info->u.same_as_last); 
    }
    else if (pvalue->t == T_UMTS_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters)
    {
        convert_uplink_additional_timeslots_lcr_r4_parameters_new_parameters(
                pvalue->u.newParameters,
                &p_info->u.new_parameters); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList to
 *      uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list
(
 UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList    *pvalue,
 uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list_t  *p_info 
 )
{
    UMTS_UplinkAdditionalTimeslots_LCR_r4   *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_UplinkAdditionalTimeslots_LCR_r4*)pnode->data;

        convert_uplink_additional_timeslots_lcr_r4_parameters(
                &pdata->parameters,
                &p_info->uplink_additional_timeslots_lcr_r4[index].parameters);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots to
 *      uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots
(
 UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots     *pvalue,
 uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_t    *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_consecutive)
    {
        convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_consecutive(
                pvalue->u.consecutive,
                &p_info->u.consecutive);
    }
    else if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList)
    {
        convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list(
                pvalue->u.timeslotList,
                &p_info->u.timeslotlist);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_lcr_r4_more_timeslots 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots to
 *      uplink_timeslots_codes_lcr_r4_more_timeslots_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_lcr_r4_more_timeslots
(
 UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots     *pvalue,
 uplink_timeslots_codes_lcr_r4_more_timeslots_t     *p_info
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_noMore)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots)
    {
        convert_uplink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots(
                pvalue->u.additionalTimeslots,
                &p_info->u.additional_timeslots);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_LCR_r4 to
 *      uplink_timeslots_codes_lcr_r4_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_lcr_r4
(
 UMTS_UplinkTimeslotsCodes_LCR_r4   *pvalue,
 uplink_timeslots_codes_lcr_r4_t    *p_lcr_r4 
 )
{
    p_lcr_r4->dynamicsfusage = pvalue->dynamicSFusage;

    convert_individual_timeslot_info_lcr_r4(
            &pvalue->firstIndividualTimeslotInfo,
            &p_lcr_r4->firstindividualtimeslotinfo);

    convert_ul_ts_channelisation_code_list(
            &pvalue->ul_TS_ChannelisationCodeList,
            &p_lcr_r4->ul_ts_channelisationcodelist);

    convert_uplink_timeslots_codes_lcr_r4_more_timeslots(
            &pvalue->moreTimeslots,
            &p_lcr_r4->moretimeslots);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_info_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_Info_LCR_r4 to
 *      pusch_info_lcr_r4_t
 *
 *******************************************************************************/
void convert_pusch_info_lcr_r4
(
 UMTS_PUSCH_Info_LCR_r4     *pvalue,
 pusch_info_lcr_r4_t        *p_lcr_r4 
 )
{
    p_lcr_r4->tfcs_id = pvalue->tfcs_ID;

    if (pvalue->m.commonTimeslotInfoPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_PUSCH_INFO_LCR_R4_COMMONTIMESLOTINFO_PRESENCE_FLAG;

        convert_common_timeslot_info(
                &pvalue->commonTimeslotInfo,
                &p_lcr_r4->common_timeslot_info);
    }

    if (pvalue->m.pusch_TimeslotsCodesPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_PUSCH_INFO_LCR_R4_PUSCH_TIMESLOTSCODES_PRESENCE_FLAG;

        convert_uplink_timeslots_codes_lcr_r4(
                &pvalue->pusch_TimeslotsCodes,
                &p_lcr_r4->pusch_timeslotscodes);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfo_LCR_r4 to
 *      pusch_sys_info_lcr_r4_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_lcr_r4
(
 UMTS_PUSCH_SysInfo_LCR_r4  *pvalue,
 pusch_sys_info_lcr_r4_t    *p_lcr_r4
 )
{
    p_lcr_r4->pusch_identity = pvalue->pusch_Identity;

    convert_pusch_info_lcr_r4(
            &pvalue->pusch_Info,
            &p_lcr_r4->pusch_info);

    if (pvalue->m.usch_TFSPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_PUSCH_SYS_INFO_LCR_R4_USCH_TFS_PRESENCE_FLAG;

        convert_transport_format_set(
                &pvalue->usch_TFS,
                &p_lcr_r4->usch_tfs);
    }

    if (pvalue->m.usch_TFCSPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_CH_SYS_INFO_LCR_R4_USCH_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->usch_TFCS,
                &p_lcr_r4->usch_tfcs); 
    }

    return;
}



/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_list_sfn_lcr_r4_element 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfoList_SFN_LCR_r4_element to
 *      pusch_sys_info_list_sfn_lcr_r4_element_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_list_sfn_lcr_r4_element
(
 UMTS_PUSCH_SysInfoList_SFN_LCR_r4_element  *pvalue,
 pusch_sys_info_list_sfn_lcr_r4_element_t   *p_info
 )
{
    convert_pusch_sys_info_lcr_r4(
            &pvalue->pusch_SysInfo,
            &p_info->pusch_sys_info_lcr_r4);

    if (pvalue->m.sfn_TimeInfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PUSCH_SYS_INFO_LIST_SFN_LCR_R4_ELEMENT_SFN_TIMEINFO_PRESENCE_FLAG;

        convert_sfn_time_info(
                &pvalue->sfn_TimeInfo,
                &p_info->sfn_timeinfo); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_list_sfn_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfoList_SFN_LCR_r4 to
 *      pusch_sys_info_list_sfn_lcr_r4_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_list_sfn_lcr_r4
(
 UMTS_PUSCH_SysInfoList_SFN_LCR_r4  *pvalue,
 pusch_sys_info_list_sfn_lcr_r4_t   *p_lcr_r4 
 )
{
    UMTS_PUSCH_SysInfoList_SFN_LCR_r4_element   *pdata = NULL;
    OSRTDListNode                               *pnode = NULL;
    U32                                         index;

    pnode = pvalue->head;
    p_lcr_r4->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PUSCH_SysInfoList_SFN_LCR_r4_element*)pnode->data;

        convert_pusch_sys_info_list_sfn_lcr_r4_element(
                pdata,
                &p_lcr_r4->pusch_sys_info_list_sfn_lcr_r4_element[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_info_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_Info_LCR_r4 to
 *      pdsch_info_lcr_r4_t
 *
 *******************************************************************************/
void convert_pdsch_info_lcr_r4
(
 UMTS_PDSCH_Info_LCR_r4     *pvalue,
 pdsch_info_lcr_r4_t        *p_info 
 )
{
    p_info->tfcs_id = pvalue->tfcs_ID;

    if (pvalue->m.commonTimeslotInfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PDSCH_INFO_LCR_R4_COMMON_TIMESLOT_INFO_PRESENCE_FLAG;

        convert_common_timeslot_info(
                &pvalue->commonTimeslotInfo,
                &p_info->common_timeslot_info);
    }

    if (pvalue->m.pdsch_TimeslotsCodesPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PDSCH_INFO_LCR_R4_PDSCH_TIMESLOTS_CODES_PRESENCE_FLAG;

        convert_downlink_timeslots_codes_lcr_r4(
                &pvalue->pdsch_TimeslotsCodes,
                &p_info->pdsch_timeslots_codes);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sysinfo_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_SysInfo_LCR_r4 to
 *      pdsch_sysinfo_lcr_r4_t
 *
 *******************************************************************************/
void convert_pdsch_sysinfo_lcr_r4
(
 UMTS_PDSCH_SysInfo_LCR_r4      *pvalue,
 pdsch_sysinfo_lcr_r4_t         *p_info 
 )
{
    p_info->pdsch_identity = pvalue->pdsch_Identity;

    convert_pdsch_info_lcr_r4(
            &pvalue->pdsch_Info,
            &p_info->pdsch_info);

    if (pvalue->m.dsch_TFSPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PDSCH_SYSINFO_LCR_R4_DSCH_TFS_PRESENCE_FLAG;

        convert_transport_format_set(
                &pvalue->dsch_TFS,
                &p_info->dsch_tfs);
    }

    if (pvalue->m.dsch_TFCSPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PDSCH_SYSINFO_LCR_R4_DSCH_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->dsch_TFCS,
                &p_info->dsch_tfcs);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sysInfolist_sfn_lcr_r4_element 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_SysInfoList_SFN_LCR_r4_element to
 *      pdsch_sysInfolist_sfn_lcr_r4_element_t
 *
 *******************************************************************************/
void convert_pdsch_sysInfolist_sfn_lcr_r4_element
(
 UMTS_PDSCH_SysInfoList_SFN_LCR_r4_element  *pvalue,
 pdsch_sysInfolist_sfn_lcr_r4_element_t     *p_info 
 )
{
    convert_pdsch_sysinfo_lcr_r4(
            &pvalue->pdsch_SysInfo,
            &p_info->pdsch_sysinfo);

    if (pvalue->m.sfn_TimeInfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PDSCH_SYSINFOLIST_SFN_LCR_R4_ELEMENT_SFN_TIMEINFO_PRESENCE_FLAG;

        convert_sfn_time_info(
                &pvalue->sfn_TimeInfo,
                &p_info->sfn_timeinfo);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sys_info_list_sfn_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_SysInfoList_SFN_LCR_r4 to
 *      pdsch_sys_info_list_sfn_lcr_r4_t
 *
 *******************************************************************************/
void convert_pdsch_sys_info_list_sfn_lcr_r4
(
 UMTS_PDSCH_SysInfoList_SFN_LCR_r4  *pvalue,
 pdsch_sys_info_list_sfn_lcr_r4_t   *p_info 
 )
{
    UMTS_PDSCH_SysInfoList_SFN_LCR_r4_element   *pdata = NULL;
    OSRTDListNode                               *pnode = NULL;
    U32                                         index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PDSCH_SysInfoList_SFN_LCR_r4_element*)pnode->data;

        convert_pdsch_sysInfolist_sfn_lcr_r4_element(
                pdata,
                &p_info->pdsch_sysInfolist_sfn_lcr_r4_element[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_primary_ccpch_info_lcr_r4_ext 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PrimaryCCPCH_Info_LCR_r4_ext to
 *      primary_ccpch_info_lcr_r4_ext_t
 *
 *******************************************************************************/
void convert_primary_ccpch_info_lcr_r4_ext
(
 UMTS_PrimaryCCPCH_Info_LCR_r4_ext  *pvalue,
 primary_ccpch_info_lcr_r4_ext_t    *p_ext 
 )
{
    p_ext->tstd_indicator = pvalue->tstd_Indicator;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_individual_timeslot_info_lcr_r4_ext 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_IndividualTimeslotInfo_LCR_r4_ext to
 *      individual_timeslot_info_lcr_r4_ext_t
 *
 *******************************************************************************/
void convert_individual_timeslot_info_lcr_r4_ext
(
 UMTS_IndividualTimeslotInfo_LCR_r4_ext     *pvalue,
 individual_timeslot_info_lcr_r4_ext_t      *p_ext 
 )
{
    convert_midamble_shift_and_burst_type_lcr_r4(
            &pvalue->midambleShiftAndBurstType,
            &p_ext->midamble_shift_and_burst_type);

    p_ext->modulation = pvalue->modulation;
    p_ext->ss_tpc_symbols = pvalue->ss_TPC_Symbols;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_lcr_r4_ext 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCH_Info_LCR_r4_ext to
 *      secondary_ccpch_info_lcr_r4_ext_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_lcr_r4_ext
(
 UMTS_SecondaryCCPCH_Info_LCR_r4_ext    *pvalue,
 secondary_ccpch_info_lcr_r4_ext_t      *p_ext 
 )
{
    convert_individual_timeslot_info_lcr_r4_ext(
            &pvalue->individualTimeslotLCR_Ext,
            &p_ext->individual_timeslot_info_lcr_r4_ext);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pich_channelisation_code_list_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PichChannelisationCodeList_LCR_r4 to
 *      pich_channelisation_code_list_lcr_r4_t
 *
 *******************************************************************************/
void convert_pich_channelisation_code_list_lcr_r4
(
 UMTS_PichChannelisationCodeList_LCR_r4     *pvalue,
 pich_channelisation_code_list_lcr_r4_t     *p_info 
 )
{
    p_info->n = pvalue->n;

    memcpy(&p_info->elem,
            &pvalue->elem, sizeof(U32)*p_info->n);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pich_info_lcr_r4 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PICH_Info_LCR_r4 to
 *      pich_info_lcr_r4_t
 *
 *******************************************************************************/
void convert_pich_info_lcr_r4
(
 UMTS_PICH_Info_LCR_r4  *pvalue,
 pich_info_lcr_r4_t     *p_lcr_r4 
 )
{
    if (pvalue->m.timeslotPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_PICH_INFO_LCR_R4_TIMESLOT_PRESENCE_FLAG;

        p_lcr_r4->timeslot = pvalue->timeslot;
    }

    convert_pich_channelisation_code_list_lcr_r4(
            &pvalue->pichChannelisationCodeList_LCR_r4,
            &p_lcr_r4->pich_channelisation_code_list);

    convert_midamble_shift_and_burst_type_lcr_r4(
            &pvalue->midambleShiftAndBurstType,
            &p_lcr_r4->midamble_shift_and_burst_type);

    if (pvalue->m.repetitionPeriodLengthOffsetPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_PICH_INFO_LCR_R4_REPETITION_PERIOD_LENGTH_OFFSET_PRESENCE_FLAG;

        convert_rep_per_length_offset_pich(
                &pvalue->repetitionPeriodLengthOffset,
                &p_lcr_r4->rep_per_length_offset_pich);
    }

    p_lcr_r4->paging_indicator_length = pvalue->pagingIndicatorLength;
    p_lcr_r4->n_gap = pvalue->n_GAP;
    p_lcr_r4->n_pch = pvalue->n_PCH;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_lcr_r4_ext 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformation_LCR_r4_ext to
 *      sccpch_system_information_lcr_r4_ext_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_lcr_r4_ext
(
 UMTS_SCCPCH_SystemInformation_LCR_r4_ext   *pvalue,
 sccpch_system_information_lcr_r4_ext_t     *p_ext 
 )
{
    convert_secondary_ccpch_info_lcr_r4_ext(
            &pvalue->secondaryCCPCH_LCR_Extensions,
            &p_ext->secondary_ccpch_info_lcr_r4_ext);

    if (pvalue->m.pich_InfoPresent)
    {
        p_ext->presence_bitmask |=
            UMTS_SIB_SCCPCH_SYSTEM_INFORMATION_LCR_R4_EXT_PICH_INFO_PRESENCE_FLAG;

        convert_pich_info_lcr_r4(
                &pvalue->pich_Info,
                &p_ext->pich_Info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_list_lcr_r4_ext 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformationList_LCR_r4_ext to
 *      sccpch_system_information_list_lcr_r4_ext_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_list_lcr_r4_ext
(
 UMTS_SCCPCH_SystemInformationList_LCR_r4_ext   *pvalue,
 sccpch_system_information_list_lcr_r4_ext_t    *p_ext 
 )
{
    UMTS_SCCPCH_SystemInformation_LCR_r4_ext    *pdata = NULL;
    OSRTDListNode                               *pnode = NULL;
    U32                                         index;

    pnode = pvalue->head;
    p_ext->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_SCCPCH_SystemInformation_LCR_r4_ext*)pnode->data;

        convert_sccpch_system_information_lcr_r4_ext(
                pdata,
                &p_ext->sccpch_system_information_lcr_r4_ext[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0ext_ies_tdd_128_specific_info 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0ext_IEs_tdd128SpecificInfo to
 *      sysinfotype5_v4b0ext_ies_tdd_128_specific_info_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0ext_ies_tdd_128_specific_info
(
 UMTS_SysInfoType5_v4b0ext_IEs_tdd128SpecificInfo        *pvalue,
 sysinfotype5_v4b0ext_ies_tdd_128_specific_info_t        *p_info
 )
{
    if (pvalue->m.pusch_SysInfoList_SFNPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0EXT_IES_TDD_128_SPECIFIC_INFO_PUSCH_SYS_INFO_LIST_SFN_LCR_R4_PRESENCE_FLAG;

        convert_pusch_sys_info_list_sfn_lcr_r4(
                &pvalue->pusch_SysInfoList_SFN,
                &p_info->pusch_sys_info_list_sfn_lcr_r4);
    }

    if(pvalue->m.pdsch_SysInfoList_SFNPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0EXT_IES_TDD_128_SPECIFIC_INFO_PDSCH_SYS_INFO_LIST_SFN_LCR_R4_PRESENCE_FLAG;

        convert_pdsch_sys_info_list_sfn_lcr_r4(
                &pvalue->pdsch_SysInfoList_SFN,
                &p_info->pdsch_sys_info_list_sfn_lcr_r4);  
    }

    if(pvalue->m.pCCPCH_LCR_ExtensionsPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0EXT_IES_TDD_128_SPECIFIC_INFO_PRIMARY_CCPCH_INFO_LCR_R4_EXT_PRESENCE_FLAG;

        convert_primary_ccpch_info_lcr_r4_ext(
                &pvalue->pCCPCH_LCR_Extensions,
                &p_info->primary_ccpch_info_lcr_r4_ext);
    }

    convert_sccpch_system_information_list_lcr_r4_ext(
            &pvalue->sCCPCH_LCR_ExtensionsList,
            &p_info->sccpch_system_information_list_lcr_r4_ext);

    return;
}

/******************************************************************************
 *   FUNCTION NAME:convert_sysinfotype5_v4b0ext_ies 
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SysInfoType5_v4b0ext_IEs to
 *      sysinfotype5_v4b0ext_ies_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0ext_ies
(
 UMTS_SysInfoType5_v4b0ext_IEs          *pvalue,
 sysinfotype5_v4b0ext_ies_t             *p_sysInfoType5_v4b0ext    
 )
{
    if(pvalue->m.pNBSCH_Allocation_r4Present)
    {
        p_sysInfoType5_v4b0ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_PNBSCH_ALLOCATION_R4_PRESENCE_FLAG;

        convert_pnbsch_allocation_r4(
                &pvalue->pNBSCH_Allocation_r4,
                &p_sysInfoType5_v4b0ext->pnbsch_allocation_r4);
    }

    if(pvalue->m.openLoopPowerControl_IPDL_TDDPresent)
    {
        p_sysInfoType5_v4b0ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_OPEN_LOOP_POWER_CONTROL_IPDL_TDD_R4_PRESENCE_FLAG;

        convert_open_loop_power_control_ipdl_tdd_r4(
                &pvalue->openLoopPowerControl_IPDL_TDD,
                &p_sysInfoType5_v4b0ext->open_loop_power_control_ipdl_tdd_r4);
    }

    if(pvalue->m.prach_SystemInformationList_LCR_r4Present)
    {
        p_sysInfoType5_v4b0ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_PRACH_SYSTEM_INFORMATION_LIST_LCR_R4_PRESENCE_FLAG;

        convert_prach_system_information_list_lcr_r4(
                &pvalue->prach_SystemInformationList_LCR_r4,
                &p_sysInfoType5_v4b0ext->prach_system_information_list_lcr_r4);
    }

    if(pvalue->m.tdd128SpecificInfoPresent)
    {
        p_sysInfoType5_v4b0ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_TDD_128_SPECIFIC_INFO_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0ext_ies_tdd_128_specific_info(
                &pvalue->tdd128SpecificInfo,
                &p_sysInfoType5_v4b0ext->tdd_128_specific_info);
    }

    if(pvalue->m.frequencyBandIndicatorPresent)
    {
        p_sysInfoType5_v4b0ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_FREQUENCY_BAND_INDICATOR_PRESENCE_FLAG;

        p_sysInfoType5_v4b0ext->frequency_band_indicator =
            pvalue->frequencyBandIndicator;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v650ext_ies
 *
 *   DESCRIPTION:
 *      This function converts
 *      UMTS_SysInfoType5_v650ext_IEs to
 *      sysinfotype5_v650ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v650ext_ies
(
 UMTS_SysInfoType5_v650ext_IEs   *pvalue,
 sysinfotype5_v650ext_ies_t      *p_sysInfoType5_v650ext
 )
{
    p_sysInfoType5_v650ext->frequency_band_indicator2 =
        pvalue->frequencyBandIndicator2;

    return;
}

/******************************************************************************
 *   FUNCTION NAME:convert_sysinfotype5_v680ext_ies 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v680ext_IEs to
 *      sysinfotype5_v680ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v680ext_ies
(
 UMTS_SysInfoType5_v680ext_IEs      *pvalue,
 sysinfotype5_v680ext_ies_t         *p_sysinfotype5_v680ext
 )
{
    if(pvalue->m.hsdpa_CellIndicatorPresent)
    {
        p_sysinfotype5_v680ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_V680EXT_IES_HSDPA_CELLINDICATOR_PRESENCE_FLAG;

        p_sysinfotype5_v680ext->hsdpa_cell_indicator =
            pvalue->hsdpa_CellIndicator;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_um_rlc_out_o_seq_delivery_info_r6
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UM_RLC_OutOSeqDelivery_Info_r6 to
 *      um_rlc_out_o_seq_delivery_info_r6_t 
 *
 *******************************************************************************/
void convert_um_rlc_out_o_seq_delivery_info_r6
(
 UMTS_UM_RLC_OutOSeqDelivery_Info_r6    *pvalue,
 um_rlc_out_o_seq_delivery_info_r6_t    *p_dl_UM_RLC_OutOSeqDelivery_Info
 )
{
    if(pvalue->m.timer_OSDPresent)
    {
        p_dl_UM_RLC_OutOSeqDelivery_Info->presence_bitmask |=
            UMTS_SIB_UM_RLC_OUT_O_SEQ_DELIVERY_INFO_R6_TIMER_OSD_PRESENCE_FLAG;

        p_dl_UM_RLC_OutOSeqDelivery_Info->timer_osd = pvalue->timer_OSD;
    }

    p_dl_UM_RLC_OutOSeqDelivery_Info->window_size_osd = pvalue->windowSize_OSD;

    return;
}

/******************************************************************************
 *   FUNCTION NAME:convert_rlc_info_mcch_r6
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_RLC_Info_MCCH_r6 to
 *      rlc_info_mcch_r6_t
 *
 *******************************************************************************/
void convert_rlc_info_mcch_r6
(
 UMTS_RLC_Info_MCCH_r6      *pvalue,
 rlc_info_mcch_r6_t         *p_rlc_Info
 )
{
    p_rlc_Info->dl_um_rlc_li_size = pvalue->dl_UM_RLC_LI_size;

    if(pvalue->m.dl_UM_RLC_OutOSeqDelivery_InfoPresent)
    {
        p_rlc_Info->presence_bitmask |=
            UMTS_SIB_RLC_INFO_MCCH_R6_UM_RLC_OUT_O_SEQ_DELIVERY_INFO_R6_PRESENCE_FLAG;

        convert_um_rlc_out_o_seq_delivery_info_r6(
                &pvalue->dl_UM_RLC_OutOSeqDelivery_Info,
                &p_rlc_Info->um_rlc_out_o_seq_delivery_info_r6);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mbms_mcch_configuration_info_r6
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MBMS_MCCH_ConfigurationInfo_r6 to
 *      mbms_mcch_configuration_info_r6_t
 *
 *******************************************************************************/
void convert_mbms_mcch_configuration_info_r6
(
 UMTS_MBMS_MCCH_ConfigurationInfo_r6    *pvalue,
 mbms_mcch_configuration_info_r6_t      *p_info
 )
{
    p_info->access_info_period_coefficient =
        pvalue->accessInfoPeriodCoefficient;

    p_info->repetition_period_coefficient  =
        pvalue->repetitionPeriodCoefficient;

    p_info->modification_period_coefficient =
        pvalue->modificationPeriodCoefficient;

    convert_rlc_info_mcch_r6(
            &pvalue->rlc_Info,
            &p_info->rlc_info);

    if(pvalue->m.tctf_PresencePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_MBMS_MCCH_CONFIGURATION_INFO_R6_TCTF_PRESENCE_FLAG;

        p_info->tctf_presence = pvalue->tctf_Presence;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sf256_and_code_number
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SF256_AndCodeNumber to
 *      sf256_and_code_number_t
 *
 *******************************************************************************/
void convert_sf256_and_code_number
(
 UMTS_SF256_AndCodeNumber        *pvalue,
 sf256_and_code_number_t         *p_number
 )
{
    p_number->t = pvalue->t;

    if(pvalue->t == T_UMTS_SF256_AndCodeNumber_sf4)
    {
        p_number->u.sf4 = pvalue->u.sf4;
    }
    else if(pvalue->t == T_UMTS_SF256_AndCodeNumber_sf8)
    {
        p_number->u.sf8 = pvalue->u.sf8;
    }
    else if(pvalue->t == T_UMTS_SF256_AndCodeNumber_sf16)
    {
        p_number->u.sf16 = pvalue->u.sf16;
    }
    else if(pvalue->t == T_UMTS_SF256_AndCodeNumber_sf32)
    {
        p_number->u.sf32 = pvalue->u.sf32;
    }
    else if(pvalue->t == T_UMTS_SF256_AndCodeNumber_sf64)
    {
        p_number->u.sf64 = pvalue->u.sf64;
    }
    else if(pvalue->t == T_UMTS_SF256_AndCodeNumber_sf128)
    {
        p_number->u.sf128 = pvalue->u.sf128;
    }
    else if(pvalue->t == T_UMTS_SF256_AndCodeNumber_sf256)
    {
        p_number->u.sf256 = pvalue->u.sf256;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r6_mode_specific_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_fdd to
 *      secondary_ccpch_info_mbms_r6_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r6_mode_specific_info_fdd
(
 UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_fdd   *pvalue,
 secondary_ccpch_info_mbms_r6_mode_specific_info_fdd_t  *p_fdd
 )
{
    if(pvalue->m.secondaryScramblingCodePresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_SECONDARY_CCPCH_INFO_MBMS_R6_MODE_SPECIFIC_INFO_FDD_SECONDARY_SCRAMBLING_CODE_PRESENCE_FLAG;

        p_fdd->secondary_scrambling_code =
            pvalue->secondaryScramblingCode;
    }

    p_fdd->sttd_indicator = pvalue->sttd_Indicator;

    convert_sf256_and_code_number(
            &pvalue->sf_AndCodeNumber,
            &p_fdd->sf256_and_code_number);

    p_fdd->timing_offset = pvalue->timingOffset;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_timeslot_info_mbms
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonTimeslotInfoMBMS to
 *      common_timeslot_info_mbms_t
 *
 *******************************************************************************/
void convert_common_timeslot_info_mbms
(
 UMTS_CommonTimeslotInfoMBMS         *pvalue,
 common_timeslot_info_mbms_t         *p_commonTimeslotInfoMBMS
 )
{
    p_commonTimeslotInfoMBMS->second_interleaving_mode =
        pvalue->secondInterleavingMode;

    if(pvalue->m.tfci_CodingPresent)
    {
        p_commonTimeslotInfoMBMS->presence_bitmask |=
            UMTS_SIB_COMMON_TIMESLOT_INFO_MBMS_TFCI_CODING_PRESENCE_FLAG;

        p_commonTimeslotInfoMBMS->tfci_coding = pvalue->tfci_Coding;
    }

    p_commonTimeslotInfoMBMS->puncturing_limit =
        pvalue->puncturingLimit;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r6_mode_specific_info_tdd384
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_tdd384 to
 *      secondary_ccpch_info_mbms_r6_mode_specific_info_tdd384_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r6_mode_specific_info_tdd384
(
 UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_tdd384    *pvalue,
 secondary_ccpch_info_mbms_r6_mode_specific_info_tdd384_t   *p_tdd384
 )
{
    convert_common_timeslot_info_mbms(
            &pvalue->commonTimeslotInfoMBMS,
            &p_tdd384->common_timeslot_info_mbms);

    convert_downlink_timeslots_codes(
            &pvalue->downlinkTimeslotsCodes,
            &p_tdd384->downlink_timeslots_codes);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_individual_timeslot_info_lcr_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_IndividualTimeslotInfo_LCR_r4 to
 *      individual_timeslot_info_lcr_r4_t 
 *
 *******************************************************************************/
void convert_individual_timeslot_info_lcr_r4
(
 UMTS_IndividualTimeslotInfo_LCR_r4      *pvalue,
 individual_timeslot_info_lcr_r4_t       *p_lcr_r4
 )
{
    p_lcr_r4->time_slot_number = pvalue->timeslotNumber;
    p_lcr_r4->tfci_existence  = pvalue->tfci_Existence;

    convert_midamble_shift_and_burst_type_lcr_r4(
            &pvalue->midambleShiftAndBurstType,
            &p_lcr_r4->midamble_shift_and_burst_type_lcr_r4);

    p_lcr_r4->modulation = pvalue->modulation;

    if(pvalue->m.additionalSS_TPC_SymbolsPresent)
    {
        p_lcr_r4->presence_bitmask |=
            UMTS_SIB_INDIVIDUAL_TIMESLOT_INFO_LCR_R4_ADDITIONAL_SS_TPC_SYMBOLS_PRESENCE_BITMASK;

        p_lcr_r4->ss_tpc_symbols = pvalue->ss_TPC_Symbols;
    }

    p_lcr_r4->additional_ss_tpc_symbols = 
        pvalue->additionalSS_TPC_Symbols;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_additional_timeslots_lcr_r4_parameters_same_as_last
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast to
 *      downlink_additional_timeslots_lcr_r4_parameters_same_as_last_t
 *
 *******************************************************************************/
void convert_downlink_additional_timeslots_lcr_r4_parameters_same_as_last
(
 UMTS_DownlinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast       *pvalue,
 downlink_additional_timeslots_lcr_r4_parameters_same_as_last_t      *p_sameAsLast
 )
{
    p_sameAsLast->timeslot_number = pvalue->timeslotNumber;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_additional_timeslots_lcr_r4_parameters_new_paramaters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkAdditionalTimeslots_LCR_r4_parameters_newParameters to
 *      downlink_additional_timeslots_lcr_r4_parameters_new_paramaters_t
 *
 *******************************************************************************/
void convert_downlink_additional_timeslots_lcr_r4_parameters_new_paramaters 
(
 UMTS_DownlinkAdditionalTimeslots_LCR_r4_parameters_newParameters      *pvalue,
 downlink_additional_timeslots_lcr_r4_parameters_new_paramaters_t      *p_newParameters
 )
{
    convert_individual_timeslot_info_lcr_r4(
            &pvalue->individualTimeslotInfo,
            &p_newParameters->individual_timeslot_info);

    convert_dl_ts_channelisation_codes_short(
            &pvalue->dl_TS_ChannelisationCodesShort,
            &p_newParameters->dl_ts_channelisation_codes_short);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_additional_timeslots_lcr_r4_parameters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkAdditionalTimeslots_LCR_r4_parameters to
 *      downlink_additional_timeslots_lcr_r4_parameters_t
 *
 *******************************************************************************/
void convert_downlink_additional_timeslots_lcr_r4_parameters
(
 UMTS_DownlinkAdditionalTimeslots_LCR_r4_parameters      *pvalue,
 downlink_additional_timeslots_lcr_r4_parameters_t       *p_parameters
 )
{
    p_parameters->t = pvalue->t;

    if(pvalue->t == T_UMTS_DownlinkAdditionalTimeslots_LCR_r4_parameters_sameAsLast)
    {
        convert_downlink_additional_timeslots_lcr_r4_parameters_same_as_last(
                pvalue->u.sameAsLast,
                &p_parameters->u.same_as_last);
    }
    else if (pvalue->t == T_UMTS_DownlinkAdditionalTimeslots_LCR_r4_parameters_newParameters)
    {
        convert_downlink_additional_timeslots_lcr_r4_parameters_new_paramaters(
                pvalue->u.newParameters,
                &p_parameters->u.new_paramaters);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList to
 *      downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list
(
 UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList      *pvalue,
 downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list_t    *p_timeslotList
 )
{
    UMTS_DownlinkAdditionalTimeslots_LCR_r4 *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_timeslotList->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_DownlinkAdditionalTimeslots_LCR_r4*)pnode->data;

        convert_downlink_additional_timeslots_lcr_r4_parameters(
                &pdata->parameters,
                &p_timeslotList->downlink_additional_timeslots_lcr_r4[index].parameters);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots to
 *      downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots
(
 UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots   *pvalue,
 downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_t  *p_additionalTimeslots
 )
{
    p_additionalTimeslots->t = pvalue->t;

    if(pvalue->t == T_UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_consecutive)
    {
        p_additionalTimeslots->u.consecutive = pvalue->u.consecutive;
    }
    else if(p_additionalTimeslots->t == T_UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList)
    {
        convert_downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots_timeslot_list(
                pvalue->u.timeslotList,
                &p_additionalTimeslots->u.timeslot_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_lcr_r4_more_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots to
 *      downlink_timeslots_codes_lcr_r4_more_timeslots_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_lcr_r4_more_timeslots
(
 UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots    *pvalue,
 downlink_timeslots_codes_lcr_r4_more_timeslots_t    *p_moreTimeslots
 )
{
    p_moreTimeslots->t = pvalue->t;

    if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_noMore)
    {
        /* for future use */
    }
    else if(pvalue->t == T_UMTS_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots)
    {
        convert_downlink_timeslots_codes_lcr_r4_more_timeslots_additional_timeslots(
                pvalue->u.additionalTimeslots,
                &p_moreTimeslots->u.additional_timeslots);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_lcr_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_LCR_r4 to
 *      downlink_timeslots_codes_lcr_r4_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_lcr_r4
(
 UMTS_DownlinkTimeslotsCodes_LCR_r4     *pvalue,
 downlink_timeslots_codes_lcr_r4_t      *p_info
 )
{
    convert_individual_timeslot_info_lcr_r4(
            &pvalue->firstIndividualTimeslotInfo,
            &p_info->first_individual_timeslot_info_lcr_r4);

    convert_dl_ts_channelisation_codes_short(
            &pvalue->dl_TS_ChannelisationCodesShort,
            &p_info->dl_ts_channelisation_codes_short);

    convert_downlink_timeslots_codes_lcr_r4_more_timeslots(
            &pvalue->moreTimeslots,
            &p_info->more_timeslots);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r6_mode_specific_info_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_tdd128 to
 *      secondary_ccpch_info_mbms_r6_mode_specific_info_tdd128_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r6_mode_specific_info_tdd128
(
 UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_tdd128     *pvalue,
 secondary_ccpch_info_mbms_r6_mode_specific_info_tdd128_t    *p_tdd128
 )
{
    convert_common_timeslot_info_mbms(
            &pvalue->commonTimeslotInfoMBMS,
            &p_tdd128->common_timeslot_info_mbms);

    convert_downlink_timeslots_codes_lcr_r4(
            &pvalue->downlinkTimeslotsCodes,
            &p_tdd128->downlink_timeslots_codes);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r6_mode_specific_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo to
 *      secondary_ccpch_info_mbms_r6_mode_specific_info_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r6_mode_specific_info
(
 UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo   *pvalue,
 secondary_ccpch_info_mbms_r6_mode_specific_info_t  *p_modeSpecificInfo
 )
{
    p_modeSpecificInfo->t = pvalue->t;

    if(pvalue->t == T_UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_fdd)
    {
        convert_secondary_ccpch_info_mbms_r6_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_modeSpecificInfo->u.fdd);
    }
    else if(pvalue->t == T_UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_tdd384)
    {
        convert_secondary_ccpch_info_mbms_r6_mode_specific_info_tdd384(
                pvalue->u.tdd384,
                &p_modeSpecificInfo->u.tdd384);
    }
    else if(pvalue->t == T_UMTS_SecondaryCCPCHInfo_MBMS_r6_modeSpecificInfo_tdd128)
    {
        convert_secondary_ccpch_info_mbms_r6_mode_specific_info_tdd128(
                pvalue->u.tdd128,
                &p_modeSpecificInfo->u.tdd128);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r6
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r6 to
 *      secondary_ccpch_info_mbms_r6_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r6
(
 UMTS_SecondaryCCPCHInfo_MBMS_r6        *pvalue,
 secondary_ccpch_info_mbms_r6_t         *p_secondaryccpchInfo_mbms
 )
{
    convert_secondary_ccpch_info_mbms_r6_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_secondaryccpchInfo_mbms->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAMEi: convert_sccpch_system_information_mbms_r6_fach_carrying_mcch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformation_MBMS_r6_fachCarryingMCCH to
 *      sccpch_systeminformation_mbms_r6_fachCarryingmcch_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_mbms_r6_fach_carrying_mcch
(
 UMTS_SCCPCH_SystemInformation_MBMS_r6_fachCarryingMCCH      *pvalue,
 sccpch_system_information_mbms_r6_fach_carrying_mcch_t      *p_fachCarryingMCCH
 )
{
    convert_transport_format_set(
            &pvalue->mcch_transportFormatSet,
            &p_fachCarryingMCCH->mcch_transport_format_set);

    convert_mbms_mcch_configuration_info_r6(
            &pvalue->mcch_ConfigurationInfo,
            &p_fachCarryingMCCH->mcch_configuration_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mbms_msch_scheduling_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MBMS_MSCHSchedulingInfo to
 *      mbms_msch_scheduling_info_t
 *
 *******************************************************************************/
void convert_mbms_msch_scheduling_info
(
 UMTS_MBMS_MSCHSchedulingInfo   *pvalue,
 mbms_msch_scheduling_info_t    *p_info 
 )
{
    memcpy(p_info, pvalue, sizeof(mbms_msch_scheduling_info_t));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_rlc_info_msch_r6
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_RLC_Info_MSCH_r6 to
 *      rlc_info_msch_r6_t
 *
 *******************************************************************************/
void convert_rlc_info_msch_r6
(
 UMTS_RLC_Info_MSCH_r6      *pvalue,
 rlc_info_msch_r6_t         *p_info 
 )
{
    p_info->dl_um_rlc_li_size = pvalue->dl_UM_RLC_LI_size;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mbms_msch_configuration_info_r6
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MBMS_MSCH_ConfigurationInfo_r6 to
 *      mbms_msch_configuration_info_r6_t
 *
 *******************************************************************************/
void convert_mbms_msch_configuration_info_r6
(
 UMTS_MBMS_MSCH_ConfigurationInfo_r6    *pvalue,
 mbms_msch_configuration_info_r6_t      *p_info 
 )
{
    if (pvalue->m.mschShedulingInfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_MBMS_MSCH_CONFIGURATION_INFO_R6_MBMS_MSCH_SCHEDULING_INFO_PRESENCE_FLAG;

        convert_mbms_msch_scheduling_info(
                &pvalue->mschShedulingInfo,
                &p_info->mbms_msch_scheduling_info);
    }

    if (pvalue->m.rlc_InfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_MBMS_MSCH_CONFIGURATION_INFO_R6_RLC_INFO_PRESENCE_FLAG;

        convert_rlc_info_msch_r6(
                &pvalue->rlc_Info,
                &p_info->rlc_info);
    }

    if (pvalue->m.tctf_PresencePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_MBMS_MSCH_CONFIGURATION_INFO_R6_TCTF_PRESENCE_PRESENCE_FLAG;

        p_info->tctf_presence = pvalue->tctf_Presence;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_mbms_r6_fach_carrying_msch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformation_MBMS_r6_fachCarryingMSCH to
 *      sccpch_system_information_mbms_r6_fach_carrying_msch_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_mbms_r6_fach_carrying_msch
(
 UMTS_SCCPCH_SystemInformation_MBMS_r6_fachCarryingMSCH      *pvalue,
 sccpch_system_information_mbms_r6_fach_carrying_msch_t      *p_fachCarryingMSCH
 )
{
    convert_transport_format_set(
            &pvalue->msch_transportFormatSet,
            &p_fachCarryingMSCH->msch_transport_format_set);

    convert_mbms_msch_configuration_info_r6(
            &pvalue->dummy,
            &p_fachCarryingMSCH->dummy);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_mbms_r6
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformation_MBMS_r6 to
 *      sccpch_system_information_mbms_r6_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_mbms_r6
(
 UMTS_SCCPCH_SystemInformation_MBMS_r6      *pvalue,
 sccpch_system_information_mbms_r6_t        *p_mcchOnSCCPCHusedOnlyForMBMS
 )
{
    convert_secondary_ccpch_info_mbms_r6(
            &pvalue->secondaryCCPCHInfo_MBMS,
            &p_mcchOnSCCPCHusedOnlyForMBMS->secondary_ccpch_info_mbms_r6);

    convert_tfcs(
            &pvalue->transportFormatCombinationSet,
            &p_mcchOnSCCPCHusedOnlyForMBMS->transport_format_combination_set);

    convert_sccpch_system_information_mbms_r6_fach_carrying_mcch(
            &pvalue->fachCarryingMCCH,
            &p_mcchOnSCCPCHusedOnlyForMBMS->fach_carrying_mcch);

    if(pvalue->m.fachCarryingMTCH_ListPresent)
    {
        p_mcchOnSCCPCHusedOnlyForMBMS->presence_bitmask |=
            UMTS_SIB_SCCPCH_SYSTEM_INFORMATION_MBMS_R6_FACH_CARRYING_MTCH_LIST_PRESENCE_FLAG;

        convert_mbms_fach_carrying_mtch_list(
                &pvalue->fachCarryingMTCH_List,
                &p_mcchOnSCCPCHusedOnlyForMBMS->fach_carrying_mtch_list);
    }

    if(pvalue->m.fachCarryingMSCHPresent)
    {
        p_mcchOnSCCPCHusedOnlyForMBMS->presence_bitmask |=
            UMTS_SIB_SCCPCH_SYSTEM_INFORMATION_MBMS_R6_FACH_CARRYING_MSCH_PRESENCE_FLAG;

        convert_sccpch_system_information_mbms_r6_fach_carrying_msch(
                &pvalue->fachCarryingMSCH,
                &p_mcchOnSCCPCHusedOnlyForMBMS->fach_carrying_msch);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v690ext_ies_sccpch_system_information_mbms
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v690ext_IEs_sccpch_SystemInformation_MBMS to
 *      sysinfotype5_v690ext_ies_sccpch_system_information_mbms_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v690ext_ies_sccpch_system_information_mbms
(
 UMTS_SysInfoType5_v690ext_IEs_sccpch_SystemInformation_MBMS    *pvalue,
 sysinfotype5_v690ext_ies_sccpch_system_information_mbms_t      *p_mbms
 )
{
    p_mbms->t = pvalue->t;

    if(pvalue->t == T_UMTS_SysInfoType5_v690ext_IEs_sccpch_SystemInformation_MBMS_mcchOnSCCPCHusedForNonMBMS)
    {
        convert_mbms_mcch_configuration_info_r6(
                pvalue->u.mcchOnSCCPCHusedForNonMBMS,
                &p_mbms->u.mcch_on_sccpch_used_for_non_mbms);
    }
    else if(pvalue->t == T_UMTS_SysInfoType5_v690ext_IEs_sccpch_SystemInformation_MBMS_mcchOnSCCPCHusedOnlyForMBMS)
    {
        convert_sccpch_system_information_mbms_r6(
                pvalue->u.mcchOnSCCPCHusedOnlyForMBMS,
                &p_mbms->u.mcch_on_sccpch_used_only_for_mbms);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_mbms_fach_carrying_mtch_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MBMS_FACHCarryingMTCH_List to
 *      mbms_fach_carrying_mtch_list_t
 *
 *******************************************************************************/
void convert_mbms_fach_carrying_mtch_list 
(
 UMTS_MBMS_FACHCarryingMTCH_List     *pvalue,
 mbms_fach_carrying_mtch_list_t      *p_fachCarryingMTCH_List
 )
{
    UMTS_TransportFormatSet *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_fachCarryingMTCH_List->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TransportFormatSet*)pnode->data;

        convert_transport_format_set(
                pdata,
                &p_fachCarryingMTCH_List->transport_format_set[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dynamic_tf_information_ccch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DynamicTFInformationCCCH to
 *      dynamic_tf_information_ccch_t
 *
 *******************************************************************************/
void convert_dynamic_tf_information_ccch
(
 UMTS_DynamicTFInformationCCCH       *pvalue,
 dynamic_tf_information_ccch_t       *p_info
 )
{
    convert_octet_mode_rlc_size_info_type2(
            &pvalue->octetModeRLC_SizeInfoType2,
            &p_info->octet_mode_rlc_size_info_type2);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_additional_prach_tf_and_tfcs_ccch_ies
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AdditionalPRACH_TF_and_TFCS_CCCH_IEs to
 *      additional_prach_tf_and_tfcs_ccch_ies_t
 *
 *******************************************************************************/
void convert_additional_prach_tf_and_tfcs_ccch_ies
(
 UMTS_AdditionalPRACH_TF_and_TFCS_CCCH_IEs   *pvalue,
 additional_prach_tf_and_tfcs_ccch_ies_t     *p_ies
 )
{
    convert_power_offset_information(
            &pvalue->powerOffsetInformation,
            &p_ies->power_offset_information);

    convert_dynamic_tf_information_ccch(
            &pvalue->dynamicTFInformationCCCH,
            &p_ies->dynamic_tf_information_ccch);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_additional_prach_tf_and_tfcs_ccch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AdditionalPRACH_TF_and_TFCS_CCCH to
 *      additional_prach_tf_and_tfcs_ccch_t
 *
 *******************************************************************************/
void convert_additional_prach_tf_and_tfcs_ccch
(
 UMTS_AdditionalPRACH_TF_and_TFCS_CCCH  *pvalue,
 additional_prach_tf_and_tfcs_ccch_t    *p_additionalprach_tf_and_tfcs_ccch
 )
{
    if(pvalue->m.additionalPRACH_TF_and_TFCS_CCCH_IEsPresent)
    {
        p_additionalprach_tf_and_tfcs_ccch->presence_bitmask |=
            UMTS_SIB_ADDITIONAL_PRACH_TF_AND_TFCS_CCCH_IES_PRESENCE_FLAG;

        convert_additional_prach_tf_and_tfcs_ccch_ies(
                &pvalue->additionalPRACH_TF_and_TFCS_CCCH_IEs,
                &p_additionalprach_tf_and_tfcs_ccch->additional_prach_tf_and_tfcs_ccch_ies);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_additional_prach_tf_and_tfcs_ccch_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AdditionalPRACH_TF_and_TFCS_CCCH_List to
 *      additional_prach_tf_and_tfcs_ccch_list_t
 *
 *******************************************************************************/
void convert_additional_prach_tf_and_tfcs_ccch_list
(
 UMTS_AdditionalPRACH_TF_and_TFCS_CCCH_List  *pvalue,
 additional_prach_tf_and_tfcs_ccch_list_t    *p_list
 )
{
    UMTS_AdditionalPRACH_TF_and_TFCS_CCCH   *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_AdditionalPRACH_TF_and_TFCS_CCCH*)pnode->data;

        convert_additional_prach_tf_and_tfcs_ccch(
                pdata,
                &p_list->additional_prach_tf_and_tfcs_ccch[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v690ext_ies
 *
 *   DESCRIPTION
 *      This function converts 
 *      UMTS_SysInfoType5_v690ext_IEs
 *       to
 *      sysinfotype5_v690ext_ies_t and checks whether input
 *      data are valid.
 *******************************************************************************/
void convert_sysinfotype5_v690ext_ies
(
 UMTS_SysInfoType5_v690ext_IEs          *pvalue,
 sysinfotype5_v690ext_ies_t             *p_sysInfoType5_v690ext
 )
{
    if(pvalue->m.edch_CellIndicatorPresent)
    {
        p_sysInfoType5_v690ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_V690EXT_IES_EDCH_CELLINDICATOR_PRESENCE_FLAG;

        p_sysInfoType5_v690ext->edch_cellindicator =
            pvalue->edch_CellIndicator;
    }

    if(pvalue->m.sccpch_SystemInformation_MBMSPresent)
    {
        p_sysInfoType5_v690ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_V690EXT_IES_SYSTEM_INFORMATION_MBMS_PRESENCE_FLAG;

        convert_sysinfotype5_v690ext_ies_sccpch_system_information_mbms(
                &pvalue->sccpch_SystemInformation_MBMS,
                &p_sysInfoType5_v690ext->system_information_mbms);
    }

    if(pvalue->m.additionalPRACH_TF_and_TFCS_CCCH_ListPresent)
    {
        p_sysInfoType5_v690ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_V690EXT_IES_ADDITIONAL_PRACH_TF_AND_TFCS_CCCH_LIST_PRESENCE_FLAG;

        convert_additional_prach_tf_and_tfcs_ccch_list(
                &pvalue->additionalPRACH_TF_and_TFCS_CCCH_List,
                &p_sysInfoType5_v690ext->additional_prach_tf_and_tfcs_ccch_list);
    }

    if(pvalue->m.cBS_DRX_Level1Information_extensionPresent)
    {
        p_sysInfoType5_v690ext->presence_bitmask |=
            UMTS_SIB_TYPE_5_V690EXT_IES_CBS_DRX_LEVEL1_INFORMATION_EXTENSION_R6_PRESENCE_FLAG;

        p_sysInfoType5_v690ext->cbs_drx_level1_information_extension_r6 =
            pvalue->cBS_DRX_Level1Information_extension;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_rb_mapping_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonRBMappingInfo to
 *      common_rb_mapping_info_t
 *
 *******************************************************************************/
void convert_common_rb_mapping_info
(
 UMTS_CommonRBMappingInfo       *pvalue,
 common_rb_mapping_info_t       *p_info
 )
{
    p_info->logical_channel_identity = pvalue->logicalChannelIdentity;
    p_info->mac_ehs_queue_id = pvalue->mac_ehs_QueueId;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_mac_ehs_reordering_queue
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_Common_MAC_ehs_ReorderingQueue to
 *      common_mac_ehs_reordering_queue_t
 *
 *******************************************************************************/
void convert_common_mac_ehs_reordering_queue
(
 UMTS_Common_MAC_ehs_ReorderingQueue     *pvalue,
 common_mac_ehs_reordering_queue_t       *p_info
 )
{
    p_info->mac_ehs_queueid = pvalue->mac_ehs_QueueId;
    p_info->t1_release_timer = pvalue->t1_ReleaseTimer;

    if(pvalue->m.reorderingResetTimerPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_COMMON_MAC_EHS_REORDERING_QUEUE_REORDERING_RESET_TIMER_PRESENCE_FLAG;

        p_info->reordering_reset_timer = pvalue->reorderingResetTimer;
    }

    p_info->mac_ehs_window_size = pvalue->mac_ehsWindowSize;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_mac_ehs_reordering_queue_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_Common_MAC_ehs_ReorderingQueueList to
 *      common_mac_ehs_reordering_queue_list_t
 *
 *******************************************************************************/
void convert_common_mac_ehs_reordering_queue_list
(
 UMTS_Common_MAC_ehs_ReorderingQueueList    *pvalue,
 common_mac_ehs_reordering_queue_list_t     *p_list
 )
{
    UMTS_Common_MAC_ehs_ReorderingQueue *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_Common_MAC_ehs_ReorderingQueue*)pnode->data;

        convert_common_mac_ehs_reordering_queue(
                pdata,
                &p_list->common_mac_ehs_reordering_queue[index]); 

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_scch_system_info_hs_scch_channelisation_code_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_SCCH_SystemInfo_hS_SCCHChannelisationCodeInfo to
 *      hs_scch_system_info_hs_scch_channelisation_code_info_t
 *
 *******************************************************************************/
void convert_hs_scch_system_info_hs_scch_channelisation_code_info
(
 UMTS_HS_SCCH_SystemInfo_hS_SCCHChannelisationCodeInfo       *pvalue,
 hs_scch_system_info_hs_scch_channelisation_code_info_t      *p_info
 )
{
    p_info->n = pvalue->n;

    memcpy(&p_info->elem, 
            &pvalue->elem, 
            (sizeof(U8) * p_info->n));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_scch_system_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_SCCH_SystemInfo to
 *      hs_scch_system_info_t
 *
 *******************************************************************************/
void convert_hs_scch_system_info
(
 UMTS_HS_SCCH_SystemInfo     *pvalue,
 hs_scch_system_info_t       *p_info
 )
{
    if(pvalue->m.dl_ScramblingCodePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_HS_SCCH_SYSTEM_INFO_DL_SCRAMBLING_CODE_PRESENCE_FLAG;

        p_info->dl_scrambling_code = pvalue->dl_ScramblingCode;
    }

    convert_hs_scch_system_info_hs_scch_channelisation_code_info(
            &pvalue->hS_SCCHChannelisationCodeInfo,
            &p_info->hs_scch_channelisation_code_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_harq_info_memory_partitioning_explicit
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HARQ_Info_memoryPartitioning to
 *      harq_info_memory_partitioning_explicit_t
 *
 *******************************************************************************/
void convert_harq_info_memory_partitioning_explicit
(
 UMTS_HARQ_Info_memoryPartitioning_explicit_    *pvalue,
 harq_info_memory_partitioning_explicit_t       *p_explicit
 )
{
    p_explicit->n = pvalue->n;

    memcpy(&p_explicit->elem,
            &pvalue->elem, 
            (sizeof(U32) * p_explicit->n));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_harq_info_memory_partitioning
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HARQ_Info_memoryPartitioning to
 *      harq_info_memory_partitioning_t
 *
 *******************************************************************************/
void convert_harq_info_memory_partitioning
(
 UMTS_HARQ_Info_memoryPartitioning  *pvalue,
 harq_info_memory_partitioning_t    *p_memoryPartitioning
 )
{
    p_memoryPartitioning->t = pvalue->t;

    if(pvalue->t == T_UMTS_HARQ_Info_memoryPartitioning_implicit)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_HARQ_Info_memoryPartitioning_explicit_)
    {
        convert_harq_info_memory_partitioning_explicit(
                pvalue->u.explicit_,
                &p_memoryPartitioning->u.explicit_);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:convert_harq_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HARQ_Info to
 *      harq_info_t
 *
 *******************************************************************************/
void convert_harq_info
(
 UMTS_HARQ_Info      *pvalue,
 harq_info_t         *p_info
 )
{
    p_info->number_of_processes = pvalue->numberOfProcesses;

    convert_harq_info_memory_partitioning(
            &pvalue->memoryPartitioning,
            &p_info->memory_partitioning);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_h_rnti
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_H_RNTI to
 *      h_rnti_t
 *
 *******************************************************************************/
void convert_h_rnti
(
 UMTS_H_RNTI        *pvalue,
 h_rnti_t           *p_info
 )
{
    p_info->numbits = pvalue->numbits;

    memcpy(&p_info->data,
            &pvalue->data,
            sizeof(U8)*p_info->numbits);    

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_common_system_information_common_h_rnti_information
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_CommonSystemInformation_common_H_RNTI_information to
 *      hs_dsch_common_system_information_common_h_rnti_information_t
 *
 *******************************************************************************/
void convert_hs_dsch_common_system_information_common_h_rnti_information
(
 UMTS_HS_DSCH_CommonSystemInformation_common_H_RNTI_information *pvalue,
 hs_dsch_common_system_information_common_h_rnti_information_t  *p_info
 )
{
    U8          index;
    p_info->n = pvalue->n;

    for (index = 0; index < pvalue->n; index++)
    {
        convert_h_rnti(
                &pvalue->elem[index],
                &p_info->elem[index]);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_common_system_information
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_CommonSystemInformation to
 *      hs_dsch_common_system_information_t
 *
 *******************************************************************************/
void convert_hs_dsch_common_system_information
(
 UMTS_HS_DSCH_CommonSystemInformation   *pvalue,
 hs_dsch_common_system_information_t    *p_info
 )
{
    convert_common_rb_mapping_info(
            &pvalue->ccch_MappingInfo,
            &p_info->ccch_mapping_info);

    if(pvalue->m.srb1_MappingInfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_HS_DSCH_COMMON_SYSTEM_INFORMATION_SRB1_MAPPING_INFO_PRESENCE_FLAG;

        convert_common_rb_mapping_info(
                &pvalue->srb1_MappingInfo,
                &p_info->srb1_mapping_info);
    }

    convert_common_mac_ehs_reordering_queue_list(
            &pvalue->common_MAC_ehs_ReorderingQueueList,
            &p_info->common_mac_ehs_reordering_queue_list);

    convert_hs_scch_system_info(
            &pvalue->hs_scch_SystemInfo,
            &p_info->hs_scch_system_info);

    convert_harq_info(
            &pvalue->harq_SystemInfo,
            &p_info->harq_system_info);

    convert_hs_dsch_common_system_information_common_h_rnti_information(
            &pvalue->common_H_RNTI_information,
            &p_info->common_h_rnti_information);

    convert_h_rnti(
            &pvalue->bcchSpecific_H_RNTI,
            &p_info->bcch_specific_h_rnti);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pich_for_hsdpa_supported_paging
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PICH_ForHSDPASupportedPaging to
 *      pich_for_hsdpa_supported_paging_t
 *
 *******************************************************************************/
void convert_pich_for_hsdpa_supported_paging
(
 UMTS_PICH_ForHSDPASupportedPaging   *pvalue,
 pich_for_hsdpa_supported_paging_t   *p_paging
 )
{
    convert_pich_info(
            &pvalue->hsdpa_AssociatedPichInfo,
            &p_paging->hsdpa_associated_pich_info);

    p_paging->hs_pdsch_channelisation_code =
        pvalue->hs_pdschChannelisationCode;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_paging_system_information_pich_for_hsdpa_supported_paging_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_PagingSystemInformation_pich_ForHSDPASupportedPagingList to
 *      hs_dsch_paging_system_information_pich_for_hsdpa_supported_paging_list_t
 *
 *******************************************************************************/
void convert_hs_dsch_paging_system_information_pich_for_hsdpa_supported_paging_list
(
 UMTS_HS_DSCH_PagingSystemInformation_pich_ForHSDPASupportedPagingList      *pvalue,
 hs_dsch_paging_system_information_pich_for_hsdpa_supported_paging_list_t   *p_list
 )
{
    UMTS_PICH_ForHSDPASupportedPaging   *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PICH_ForHSDPASupportedPaging*)pnode->data;

        convert_pich_for_hsdpa_supported_paging(
                pdata,
                &p_list->pich_for_hsdpa_supported_paging[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_paging_system_information_transport_block_size_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_PagingSystemInformation_transportBlockSizeList to
 *      hs_dsch_paging_system_information_transport_block_size_list_t
 *
 *******************************************************************************/
void convert_hs_dsch_paging_system_information_transport_block_size_list
(
 UMTS_HS_DSCH_PagingSystemInformation_transportBlockSizeList    *pvalue,
 hs_dsch_paging_system_information_transport_block_size_list_t  *p_list
 )
{
    p_list->n = pvalue ->n;

    memcpy(&p_list->elem, 
            &pvalue->elem, 
            (sizeof(U8)*p_list->n) );

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_paging_system_information
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_PagingSystemInformation to
 *      hs_dsch_paging_system_information_t
 *
 *******************************************************************************/
void convert_hs_dsch_paging_system_information
(
 UMTS_HS_DSCH_PagingSystemInformation   *pvalue,
 hs_dsch_paging_system_information_t    *p_info
 )
{
    if(pvalue->m.dlScramblingCodePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_HS_DSCH_PAGING_SYSTEM_INFORMATION_DL_SCRAMBLING_CODE_PRESENCE_FLAG;

        p_info->dl_scrambling_code = pvalue->dlScramblingCode;
    }

    convert_hs_dsch_paging_system_information_pich_for_hsdpa_supported_paging_list(
            &pvalue->pich_ForHSDPASupportedPagingList,
            &p_info->pich_for_hsdpa_supported_paging_list);

    p_info->number_of_pcch_transmissions = pvalue->numberOfPcchTransmissions;

    convert_hs_dsch_paging_system_information_transport_block_size_list(
            &pvalue->transportBlockSizeList,
            &p_info->transport_block_size_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v770ext_ies_mode_specific_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_fdd to
 *      sysinfotype5_v770ext_ies_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v770ext_ies_mode_specific_info_fdd
(
 UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_fdd     *pvalue,
 sysinfotype5_v770ext_ies_mode_specific_info_fdd_t      *p_fdd
 )
{
    convert_hs_dsch_common_system_information(
            &pvalue->hs_dsch_CommonSystemInformation,
            &p_fdd->hs_dsch_common_system_information);

    if(pvalue->m.hs_dsch_PagingSystemInformationPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_MODE_SPECIFIC_INFO_FDD_HS_DSCH_PAGING_SYSTEM_INFORMATION_PRESENCE_FLAG;

        convert_hs_dsch_paging_system_information(
                &pvalue->hs_dsch_PagingSystemInformation,
                &p_fdd->hs_dsch_paging_system_information);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode_ue_specific_midamble
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_ueSpecificMidamble to
 *      midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode_ue_specific_midamble_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode_ue_specific_midamble
(
 UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_ueSpecificMidamble          *pvalue,
 midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode_ue_specific_midamble_t    *p_midamble 
 )
{
    p_midamble->midamble_shift = pvalue->midambleShift;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode to
 *      midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode     *pvalue,
 midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode_t *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_commonMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode_ueSpecificMidamble)
    {
        convert_midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode_ue_specific_midamble(
                pvalue->u.ueSpecificMidamble,
                &p_mode->u.ue_specific_midamble);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr_burst_type_type1
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1 to
 *      midamble_shift_and_burst_type_vhcr_burst_type_type1_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr_burst_type_type1
(
 UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1    *pvalue,
 midamble_shift_and_burst_type_vhcr_burst_type_type1_t  *p_type1 
 )
{
    p_type1->midamble_configuration_burst_type1_and_3 =
        pvalue->midambleConfigurationBurstType1and3;

    convert_midamble_shift_and_burst_type_vhcr_burst_type_type1_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_type1->midamble_allocation_mode);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr_burst_type_type2_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode to
 *      midamble_shift_and_burst_type_vhcr_burst_type_type2_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr_burst_type_type2_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode     *pvalue,
 midamble_shift_and_burst_type_vhcr_burst_type_type2_midamble_allocation_mode_t *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode_commonMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr_burst_type_type2
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR_burstType_type2 to
 *      midamble_shift_and_burst_type_vhcr_burst_type_type2_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr_burst_type_type2
(
 UMTS_MidambleShiftAndBurstType_VHCR_burstType_type2    *pvalue,
 midamble_shift_and_burst_type_vhcr_burst_type_type2_t  *p_type2 
 )
{
    p_type2->midamble_configuration_burst_type2 =
        pvalue->midambleConfigurationBurstType2;

    convert_midamble_shift_and_burst_type_vhcr_burst_type_type2_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_type2->midamble_allocation_mode);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr_burst_type_type3_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode to
 *      midamble_shift_and_burst_type_vhcr_burst_type_type3_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr_burst_type_type3_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode     *pvalue,
 midamble_shift_and_burst_type_vhcr_burst_type_type3_midamble_allocation_mode_t *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr_burst_type_type3
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR_burstType_type3 to
 *      midamble_shift_and_burst_type_vhcr_burst_type_type3_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr_burst_type_type3
(
 UMTS_MidambleShiftAndBurstType_VHCR_burstType_type3    *pvalue,
 midamble_shift_and_burst_type_vhcr_burst_type_type3_t  *p_type3 
 )
{
    p_type3->midamble_configuration_burst_type1_and_3 =
        pvalue->midambleConfigurationBurstType1and3;

    convert_midamble_shift_and_burst_type_vhcr_burst_type_type3_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_type3->midamble_allocation_mode);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr_burst_type
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR_burstType to
 *      midamble_shift_and_burst_type_vhcr_burst_type_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr_burst_type
(
 UMTS_MidambleShiftAndBurstType_VHCR_burstType      *pvalue,
 midamble_shift_and_burst_type_vhcr_burst_type_t    *p_type 
 )
{
    p_type->t = pvalue->t;

    if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type1)
    {
        convert_midamble_shift_and_burst_type_vhcr_burst_type_type1(
                pvalue->u.type1,
                &p_type->u.type1); 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type2)
    {
        convert_midamble_shift_and_burst_type_vhcr_burst_type_type2(
                pvalue->u.type2,
                &p_type->u.type2); 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_type3)
    {
        convert_midamble_shift_and_burst_type_vhcr_burst_type_type3(
                pvalue->u.type3,
                &p_type->u.type3); 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_VHCR_burstType_mbsfnBurstType4)
    {
        /* for future use */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_VHCR to
 *      midamble_shift_and_burst_type_vhcr_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_vhcr
(
 UMTS_MidambleShiftAndBurstType_VHCR    *pvalue,
 midamble_shift_and_burst_type_vhcr_t   *p_vhcr 
 )
{
    convert_midamble_shift_and_burst_type_vhcr_burst_type(
            &pvalue->burstType,
            &p_vhcr->burst_type);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_individual_timeslot_info_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_IndividualTimeslotInfo_VHCR to
 *      individual_timeslot_info_vhcr_t
 *
 *******************************************************************************/
void convert_individual_timeslot_info_vhcr
(
 UMTS_IndividualTimeslotInfo_VHCR   *pvalue,
 individual_timeslot_info_vhcr_t    *p_vhcr 
 )
{
    p_vhcr->timeslot_number = pvalue->timeslotNumber;
    p_vhcr->tfci_existence = pvalue->tfci_Existence;

    convert_midamble_shift_and_burst_type_vhcr(
            &pvalue->midambleShiftAndBurstType_VHCR,
            &p_vhcr->midamble_shift_and_burst_type_vhcr);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ul_ts_channelisation_code_list_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UL_TS_ChannelisationCodeList_VHCR to
 *      ul_ts_channelisation_code_list_vhcr_t
 *
 *******************************************************************************/
void convert_ul_ts_channelisation_code_list_vhcr
(
 UMTS_UL_TS_ChannelisationCodeList_VHCR     *pvalue,
 ul_ts_channelisation_code_list_vhcr_t      *p_vhcr 
 )
{
    p_vhcr->n = pvalue->n;

    memcpy(&p_vhcr->elem,
            &pvalue->elem,
            sizeof(U32)*p_vhcr->n);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_additional_timeslots_vhcr_parameters_new_parameters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkAdditionalTimeslots_VHCR_parameters_newParameters to
 *      uplink_additional_timeslots_vhcr_parameters_new_parameters_t
 *
 *******************************************************************************/
void convert_uplink_additional_timeslots_vhcr_parameters_new_parameters
(
 UMTS_UplinkAdditionalTimeslots_VHCR_parameters_newParameters   *pvalue,
 uplink_additional_timeslots_vhcr_parameters_new_parameters_t   *p_params 
 )
{
    convert_individual_timeslot_info_vhcr(
            &pvalue->individualTimeslotInfo,
            &p_params->individualTimeslotInfo);

    convert_ul_ts_channelisation_code_list(
            &pvalue->ul_TS_ChannelisationCodeList,
            &p_params->ul_TS_ChannelisationCodeList);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_additional_timeslots_vhcr_parameters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkAdditionalTimeslots_VHCR_parameters to
 *      uplink_additional_timeslots_vhcr_parameters_t
 *
 *******************************************************************************/
void convert_uplink_additional_timeslots_vhcr_parameters
(
 UMTS_UplinkAdditionalTimeslots_VHCR_parameters     *pvalue,
 uplink_additional_timeslots_vhcr_parameters_t      *p_params 
 )
{
    p_params->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkAdditionalTimeslots_VHCR_parameters_sameAsLast)
    {
        p_params->u.same_as_last.timeslot_number =
            pvalue->u.sameAsLast->timeslotNumber;
    }
    else if (pvalue->t == T_UMTS_UplinkAdditionalTimeslots_VHCR_parameters_newParameters)
    {
        convert_uplink_additional_timeslots_vhcr_parameters_new_parameters(
                pvalue->u.newParameters,
                &p_params->u.new_parameters); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList to
 *      uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list
(
 UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList      *pvalue,
 uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list_t    *p_list
 )
{
    UMTS_UplinkAdditionalTimeslots_VHCR *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_UplinkAdditionalTimeslots_VHCR*)pnode->data;

        convert_uplink_additional_timeslots_vhcr_parameters(
                &pdata->parameters,
                &p_list->uplink_additional_timeslots_vhcr[index].parameters);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots to
 *      uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots
(
 UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots   *pvalue,
 uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_t  *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_consecutive)
    {
        p_info->u.consecutive.num_additional_timeslots =
            pvalue->u.consecutive->numAdditionalTimeslots; 
    }
    else if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList)
    {
        convert_uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list(
                pvalue->u.timeslotList,
                &p_info->u.timeslot_list); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_vhcr_more_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots to
 *      uplink_timeslots_codes_vhcr_more_timeslots_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_vhcr_more_timeslots
(
 UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots   *pvalue,
 uplink_timeslots_codes_vhcr_more_timeslots_t   *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots_noMore)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots)
    {
        convert_uplink_timeslots_codes_vhcr_more_timeslots_additional_timeslots(
                pvalue->u.additionalTimeslots,
                &p_info->u.additional_timeslots);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_uplink_timeslots_codes_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UplinkTimeslotsCodes_VHCR to
 *      uplink_timeslots_codes_vhcr_t
 *
 *******************************************************************************/
void convert_uplink_timeslots_codes_vhcr
(
 UMTS_UplinkTimeslotsCodes_VHCR     *pvalue,
 uplink_timeslots_codes_vhcr_t      *p_vhcr 
 )
{
    p_vhcr->dynamic_s_fusage = pvalue->dynamicSFusage;

    convert_individual_timeslot_info_vhcr(
            &pvalue->firstIndividualTimeslotInfo,
            &p_vhcr->first_individual_timeslot_info_vhcr);

    convert_ul_ts_channelisation_code_list_vhcr(
            &pvalue->ul_TS_ChannelisationCodeList,
            &p_vhcr->ul_ts_channelisation_code_list);

    convert_uplink_timeslots_codes_vhcr_more_timeslots(
            &pvalue->moreTimeslots,
            &p_vhcr->more_timeslots);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_info_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_Info_VHCR to
 *      pusch_info_vhcr_t
 *
 *******************************************************************************/
void convert_pusch_info_vhcr
(
 UMTS_PUSCH_Info_VHCR   *pvalue,
 pusch_info_vhcr_t      *p_vhcr
 )
{
    p_vhcr->tfcs_id = pvalue->tfcs_ID;

    if (pvalue->m.commonTimeslotInfoPresent)
    {
        p_vhcr->presence_bitmask |=
            UMTS_SIB_PUSCH_INFO_VHCR_COMMON_TIMESLOT_INFO_PRESENCE_FLAG;

        convert_common_timeslot_info(
                &pvalue->commonTimeslotInfo,
                &p_vhcr->common_timeslot_info_t);
    }

    if (pvalue->m.pusch_TimeslotsCodes_VHCRPresent)
    {
        p_vhcr->presence_bitmask |=
            UMTS_SIB_PUSCH_INFO_VHCR_UPLINK_TIMESLOTS_CODES_VHCR_PRESENCE_FLAG;

        convert_uplink_timeslots_codes_vhcr(
                &pvalue->pusch_TimeslotsCodes_VHCR,
                &p_vhcr->uplink_timeslots_codes_vhcr);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfo_VHCR to
 *      pusch_sys_info_vhcr_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_vhcr
(
 UMTS_PUSCH_SysInfo_VHCR    *pvalue,
 pusch_sys_info_vhcr_t      *p_vhcr 
 )
{
    p_vhcr->pusch_identity = pvalue->pusch_Identity;

    convert_pusch_info_vhcr(
            &pvalue->pusch_Info_VHCR,
            &p_vhcr->pusch_info_vhcr);

    if (pvalue->m.usch_TransportChannelsInfoPresent)
    {
        p_vhcr->presence_bitmask |=
            UMTS_SIB_PUSCH_SYS_INFO_VHCR_USCH_TRANSPORT_CHANNELS_INFO_PRESENCE_FLAG;

        convert_usch_transport_channels_info(
                &pvalue->usch_TransportChannelsInfo,
                &p_vhcr->usch_transport_channels_info);
    }

    if (pvalue->m.usch_TFCSPresent)
    {
        p_vhcr->presence_bitmask |=
            UMTS_SIB_PUSCH_SYS_INFO_VHCR_USCH_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->usch_TFCS,
                &p_vhcr->usch_tfcs);    
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_list_sfn_vhcr_element
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfoList_SFN_VHCR_element to
 *      pusch_sys_info_list_sfn_vhcr_element_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_list_sfn_vhcr_element
(
 UMTS_PUSCH_SysInfoList_SFN_VHCR_element    *pvalue,
 pusch_sys_info_list_sfn_vhcr_element_t     *p_element
 )
{
    convert_pusch_sys_info_vhcr(
            &pvalue->pusch_SysInfo_VHCR,
            &p_element->pusch_sys_info_vhcr);

    if (pvalue->m.sfn_TimeInfoPresent)
    {
        p_element->presence_bitmask |=
            UMTS_SIB_PUSCH_SYS_INFO_LIST_SFN_VHCR_ELEMENT_SFN_TIME_INFO_PRESENCE_FLAG;

        convert_sfn_time_info(
                &pvalue->sfn_TimeInfo,
                &p_element->sfn_time_info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_list_sfn_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfoList_SFN_VHCR to
 *      pusch_sys_info_list_sfn_vhcr_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_list_sfn_vhcr
(
 UMTS_PUSCH_SysInfoList_SFN_VHCR    *pvalue,
 pusch_sys_info_list_sfn_vhcr_t     *p_info 
 )
{
    UMTS_PUSCH_SysInfoList_SFN_VHCR_element *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PUSCH_SysInfoList_SFN_VHCR_element*)pnode->data;

        convert_pusch_sys_info_list_sfn_vhcr_element(
                pdata,
                &p_info->pusch_sys_info_list_sfn_vhcr_element[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dl_ts_channelisation_codes_short_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DL_TS_ChannelisationCodesShort_VHCR to
 *      dl_ts_channelisation_codes_short_vhcr_t
 *
 *******************************************************************************/
void convert_dl_ts_channelisation_codes_short_vhcr
(
 UMTS_DL_TS_ChannelisationCodesShort_VHCR   *pvalue,
 dl_ts_channelisation_codes_short_vhcr_t    *p_vhcr 
 )
{
    p_vhcr->codes_representation.t = pvalue->codesRepresentation.t;

    if (pvalue->codesRepresentation.t == T_UMTS_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_consecutive)
    {
        p_vhcr->codes_representation.u.consecutive.first_channelisation_code =
            pvalue->codesRepresentation.u.consecutive->firstChannelisationCode;

        p_vhcr->codes_representation.u.consecutive.last_channelisation_code =
            pvalue->codesRepresentation.u.consecutive->lastChannelisationCode; 
    }
    else if (pvalue->codesRepresentation.t == T_UMTS_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_bitmap)
    {
        p_vhcr->codes_representation.u.bitmap.numbits =
            pvalue->codesRepresentation.u.bitmap->numbits;

        memcpy(&p_vhcr->codes_representation.u.bitmap.data,
                &pvalue->codesRepresentation.u.bitmap->data,
                sizeof(U8)*p_vhcr->codes_representation.u.bitmap.numbits); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_additional_timeslots_vhcr_parameters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkAdditionalTimeslots_VHCR_parameters to
 *      downlink_additional_timeslots_vhcr_parameters_t
 *
 *******************************************************************************/
void convert_downlink_additional_timeslots_vhcr_parameters
(
 UMTS_DownlinkAdditionalTimeslots_VHCR_parameters   *pvalue,
 downlink_additional_timeslots_vhcr_parameters_t    *p_params 
 )
{
    p_params->t = pvalue->t;

    if (pvalue->t == T_UMTS_DownlinkAdditionalTimeslots_VHCR_parameters_sameAsLast)
    {
        p_params->u.same_as_last.timeslot_number =
            pvalue->u.sameAsLast->timeslotNumber; 
    }
    else if (pvalue->t == T_UMTS_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters)
    {
        convert_individual_timeslot_info_vhcr(
                &pvalue->u.newParameters->individualTimeslotInfo,
                &p_params->u.new_parameters.first_individual_timeslot_info); 

        convert_dl_ts_channelisation_codes_short_vhcr(
                &pvalue->u.newParameters->dl_TS_ChannelisationCodesShort,
                &p_params->u.new_parameters.dl_ts_channelisation_codes_short);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList to
 *      downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list
(
 UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList    *pvalue,
 downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list_t  *p_list 
 )
{
    UMTS_DownlinkAdditionalTimeslots_VHCR   *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_DownlinkAdditionalTimeslots_VHCR*)pnode->data;

        convert_downlink_additional_timeslots_vhcr_parameters(
                &pdata->parameters,
                &p_list->downlink_additional_timeslots_vhcr[index].parameters);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots to
 *      downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots
(
 UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots     *pvalue,
 downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_t    *p_info
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_consecutive)
    {
        p_info->u.consecutive = pvalue->u.consecutive; 
    }
    else if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList)
    {
        convert_downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots_timeslot_list(
                pvalue->u.timeslotList,
                &p_info->u.timeslot_list); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_vhcr_more_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots to
 *      downlink_timeslots_codes_vhcr_more_timeslots_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_vhcr_more_timeslots
(
 UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots *pvalue,
 downlink_timeslots_codes_vhcr_more_timeslots_t *p_info
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots_noMore)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots)
    {
        convert_downlink_timeslots_codes_vhcr_more_timeslots_additional_timeslots(
                pvalue->u.additionalTimeslots,
                &p_info->u.additional_timeslots); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_VHCR to
 *      downlink_timeslots_codes_vhcr_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_vhcr
(
 UMTS_DownlinkTimeslotsCodes_VHCR   *pvalue,
 downlink_timeslots_codes_vhcr_t    *p_vhcr 
 )
{
    convert_individual_timeslot_info_vhcr(
            &pvalue->firstIndividualTimeslotInfo,
            &p_vhcr->first_individual_timeslot_info);

    convert_dl_ts_channelisation_codes_short_vhcr(
            &pvalue->dl_TS_ChannelisationCodesShort,
            &p_vhcr->dl_ts_channelisation_codes_short);

    convert_downlink_timeslots_codes_vhcr_more_timeslots(
            &pvalue->moreTimeslots,
            &p_vhcr->more_timeslots);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_info_r7_tdd_option
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_Info_r7_tddOption to
 *      pdsch_info_r7_tdd_option_t
 *
 *******************************************************************************/
void convert_pdsch_info_r7_tdd_option
(
 UMTS_PDSCH_Info_r7_tddOption   *pvalue,
 pdsch_info_r7_tdd_option_t     *p_option 
 )
{
    p_option->t = pvalue->t;

    if (pvalue->t == T_UMTS_PDSCH_Info_r7_tddOption_tdd384)
    {
        if (pvalue->u.tdd384->m.pdsch_TimeslotsCodesPresent)
        {
            p_option->u.tdd384.presence_bitmask |=
                UMTS_SIB_PDSCH_INFO_R7_TDD_OPTION_TDD384_PDSCH_TIMESLOTS_CODES_PRESENCE_FLAG;

            convert_downlink_timeslots_codes(
                    &pvalue->u.tdd384->pdsch_TimeslotsCodes,
                    &p_option->u.tdd384.pdsch_timeslots_codes);
        }
    }
    else if (pvalue->t == T_UMTS_PDSCH_Info_r7_tddOption_tdd768)
    {
        if (pvalue->u.tdd768->m.pdsch_TimeslotsCodesPresent)
        {
            p_option->u.tdd768.presence_bitmask |=
                UMTS_SIB_PDSCH_INFO_R7_TDD_OPTION_TDD768_PDSCH_TIMESLOTS_CODES_PRESENCE_FLAG;

            convert_downlink_timeslots_codes_vhcr(
                    &pvalue->u.tdd768->pdsch_TimeslotsCodes,
                    &p_option->u.tdd768.pdsch_timeslots_codes);
        }
    }
    else if (pvalue->t == T_UMTS_PDSCH_Info_r7_tddOption_tdd128)
    {
        if (pvalue->u.tdd128->m.pdsch_TimeslotsCodesPresent) 
        {
            p_option->u.tdd128.presence_bitmask |=
                UMTS_SIB_PDSCH_INFO_R7_TDD_OPTION_TDD128_PDSCH_TIMESLOTS_CODES_PRESENCE_FLAG;

            convert_downlink_timeslots_codes_lcr_r4(
                    &pvalue->u.tdd128->pdsch_TimeslotsCodes,
                    &p_option->u.tdd128.pdsch_timeslots_codes);
        }
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_info_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_Info_r7 to
 *      pdsch_info_r7_t
 *
 *******************************************************************************/
void convert_pdsch_info_r7
(
 UMTS_PDSCH_Info_r7     *pvalue,
 pdsch_info_r7_t        *p_r7
 )
{
    p_r7->tfcs_id = pvalue->tfcs_ID;

    if (pvalue->m.commonTimeslotInfoPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_PDSCH_INFO_R7_COMMON_TIMESLOT_INFO_PRESENCE_FLAG;

        convert_common_timeslot_info(
                &pvalue->commonTimeslotInfo,
                &p_r7->common_timeslot_info);
    }

    convert_pdsch_info_r7_tdd_option(
            &pvalue->tddOption,
            &p_r7->tdd_option);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sys_info_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_SysInfo_VHCR_r7 to
 *      pdsch_sys_info_vhcr_r7_t
 *
 *******************************************************************************/
void convert_pdsch_sys_info_vhcr_r7
(
 UMTS_PDSCH_SysInfo_VHCR_r7 *pvalue,
 pdsch_sys_info_vhcr_r7_t   *p_r7 
 )
{
    p_r7->pdsch_identity =
        pvalue->pdsch_Identity;

    convert_pdsch_info_r7(
            &pvalue->pdsch_Info,
            &p_r7->pdsch_info);

    if (pvalue->m.dsch_TransportChannelsInfoPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_PDSCH_SYS_INFO_VHCR_R7_PDSCH_SYS_INFO_VHCR_R7_T_PRESENCE_FLAG;

        convert_dsch_transport_channels_info(
                &pvalue->dsch_TransportChannelsInfo,
                &p_r7->dsch_transport_channels_info);
    }

    if (pvalue->m.dsch_TFCSPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SID_PDSCH_SYS_INFO_VHCR_R7_DSCH_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->dsch_TFCS,
                &p_r7->dsch_tfcs);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sys_info_list_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_SysInfoList_VHCR_r7 to
 *      pdsch_sys_info_list_vhcr_r7_t
 *
 *******************************************************************************/
void convert_pdsch_sys_info_list_vhcr_r7
(
 UMTS_PDSCH_SysInfoList_VHCR_r7     *pvalue,
 pdsch_sys_info_list_vhcr_r7_t      *p_r7 
 )
{
    UMTS_PDSCH_SysInfo_VHCR_r7  *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_r7->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PDSCH_SysInfo_VHCR_r7*)pnode->data;

        convert_pdsch_sys_info_vhcr_r7(
                pdata,
                &p_r7->pdsch_sys_info_vhcr_r7[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tdd768_prach_c_code_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_TDD768_PRACH_CCodeList to
 *      tdd768_prach_c_code_list_t
 *
 *******************************************************************************/
void convert_tdd768_prach_c_code_list
(
 UMTS_TDD768_PRACH_CCodeList    *pvalue,
 tdd768_prach_c_code_list_t     *p_list
 )
{
    p_list->t = pvalue->t;

    if (pvalue->t == T_UMTS_TDD768_PRACH_CCodeList_sf32)
    {
        p_list->u.sf32.n = pvalue->u.sf32->n;

        memcpy(&p_list->u.sf32.elem,
                &pvalue->u.sf32->elem,
                sizeof(U32)*p_list->u.sf32.n); 
    }
    else if (pvalue->t == T_UMTS_TDD768_PRACH_CCodeList_sf16)
    {
        p_list->u.sf16.n = pvalue->u.sf16->n;

        memcpy(&p_list->u.sf16.elem,
                &pvalue->u.sf16->elem,
                sizeof(U32)*p_list->u.sf16.n);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_rach_info_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_RACH_Info_VHCR_r7 to
 *      prach_rach_info_vhcr_r7_t
 *
 *******************************************************************************/
void convert_prach_rach_info_vhcr_r7
(
 UMTS_PRACH_RACH_Info_VHCR_r7   *pvalue,
 prach_rach_info_vhcr_r7_t      *p_r7 
 )
{
    p_r7->timeslot = pvalue->timeslot;

    convert_tdd768_prach_c_code_list(
            &pvalue->channelisationCodeList,
            &p_r7->channelisation_code_list);

    p_r7->prach_midamble = pvalue->prach_Midamble;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_partitioning_r7_fdd
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_Partitioning_r7_fdd to
 *      prach_partitioning_r7_fdd_t
 *
 *******************************************************************************/
void convert_prach_partitioning_r7_fdd
(
 UMTS_PRACH_Partitioning_r7_fdd     *pvalue,
 prach_partitioning_r7_fdd_t        *p_fdd 
 )
{
    UMTS_ASCSetting_FDD *pdata = NULL;
    OSRTDListNode       *pnode = NULL;
    U32                 index;

    pnode = pvalue->head;
    p_fdd->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ASCSetting_FDD*)pnode->data;

        if (pdata->m.accessServiceClass_FDDPresent)
        {
            p_fdd->asc_setting_fdd[index].presence_bitmask |=
                UMTS_SIB_ASC_SETTING_FDD_ACCESS_SERVICE_CLASS_FDD_PRESENCE_FLAG;

            convert_access_service_class_fdd(
                    &pdata->accessServiceClass_FDD,
                    &p_fdd->asc_setting_fdd[index].access_service_class_fdd);
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_r7_channelisation_code_indices
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_r7_channelisationCodeIndices to
 *      access_service_class_tdd_r7_channelisation_code_indices_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_r7_channelisation_code_indices
(
 UMTS_AccessServiceClass_TDD_r7_channelisationCodeIndices   *pvalue,
 access_service_class_tdd_r7_channelisation_code_indices_t  *p_info
 )
{
    p_info->numbits = pvalue->numbits;

    memcpy(&p_info->data,
            &pvalue->data,
            sizeof(U8)*p_info->numbits);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_r7_subchannel_size
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_r7_subchannelSize to
 *      access_service_class_tdd_r7_subchannel_size_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_r7_subchannel_size
(
 UMTS_AccessServiceClass_TDD_r7_subchannelSize  *pvalue,
 access_service_class_tdd_r7_subchannel_size_t  *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_AccessServiceClass_TDD_r7_subchannelSize_size1)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_r7_subchannelSize_size2)
    {
        if (pvalue->u.size2->m.subchannelsPresent) 
        {
            p_info->u.size2.presence_bitmask |=
                UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_R7_SUBCHANNEL_SIZE_SIZE2_SUBCHANNELS_PRESENCE_FLAG;

            p_info->u.size2.subchannels =
                pvalue->u.size2->subchannels;
        }
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_r7_subchannelSize_size4)
    {
        if (pvalue->u.size4->m.subchannelsPresent)
        {
            p_info->u.size4.presence_bitmask |=
                UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_R7_SUBCHANNEL_SIZE_SIZE4_SUBCHANNELS_PRESENCE_FLAG;

            p_info->u.size4.subchannels.numbits =
                pvalue->u.size4->subchannels.numbits;

            memcpy(&p_info->u.size4.subchannels.data,
                    &pvalue->u.size4->subchannels.data,
                    sizeof(U8)*p_info->u.size4.subchannels.numbits);
        }
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_r7_subchannelSize_size8)
    {
        if (pvalue->u.size8->m.subchannelsPresent)
        {
            p_info->u.size8.presence_bitmask |=
                UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_R7_SUBCHANNEL_SIZE_SIZE8_SUBCHANNELS_PRESENCE_FLAG;

            p_info->u.size8.subchannels.numbits =
                pvalue->u.size8->subchannels.numbits;

            memcpy(&p_info->u.size8.subchannels.data,
                    &pvalue->u.size8->subchannels.data,
                    sizeof(U8)*p_info->u.size8.subchannels.numbits);
        }
    }
    else if (pvalue->t == T_UMTS_AccessServiceClass_TDD_r7_subchannelSize_size16)
    {
        if (pvalue->u.size16->m.subchannelsPresent)
        {
            p_info->u.size16.presence_bitmask |=
                UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_R7_SUBCHANNEL_SIZE_SIZE16_SUBCHANNELS_PRESENCE_FLAG;

            p_info->u.size16.subchannels.numbits =
                pvalue->u.size16->subchannels.numbits;

            memcpy(&p_info->u.size16.subchannels.data,
                    &pvalue->u.size16->subchannels.data,
                    sizeof(U8)*p_info->u.size16.subchannels.numbits);
        }
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_access_service_class_tdd_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AccessServiceClass_TDD_r7 to
 *      access_service_class_tdd_r7_t
 *
 *******************************************************************************/
void convert_access_service_class_tdd_r7
(
 UMTS_AccessServiceClass_TDD_r7     *pvalue,
 access_service_class_tdd_r7_t      *p_r7
 )
{
    if (pvalue->m.channelisationCodeIndicesPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_ACCESS_SERVICE_CLASS_TDD_R7_CHANNELISATION_CODE_INDICES_PRESENCE_FLAG;

        convert_access_service_class_tdd_r7_channelisation_code_indices(
                &pvalue->channelisationCodeIndices,
                &p_r7->channelisation_code_indices);
    }

    convert_access_service_class_tdd_r7_subchannel_size(
            &pvalue->subchannelSize,
            &p_r7->subchannel_size);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_partitioning_r7_tdd
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_Partitioning_r7_tdd to
 *      prach_partitioning_r7_tdd_t
 *
 *******************************************************************************/
void convert_prach_partitioning_r7_tdd
(
 UMTS_PRACH_Partitioning_r7_tdd     *pvalue,
 prach_partitioning_r7_tdd_t        *p_tdd 
 )
{
    UMTS_ASCSetting_TDD_r7  *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_tdd->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ASCSetting_TDD_r7*)pnode->data;

        if (pdata->m.accessServiceClass_TDDPresent)
        {
            p_tdd->asc_setting_tdd_r7[index].presence_bitmask |=
                UMTS_SIB_ASC_SETTING_TDD_R7_ACCESS_SERVICE_CLASS_TDD_R7_PRESENCE_FLAG;

            convert_access_service_class_tdd_r7(
                    &pdata->accessServiceClass_TDD,
                    &p_tdd->asc_setting_tdd_r7[index].access_service_class_tdd_r7);
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_partitioning_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_Partitioning_r7 to
 *      prach_partitioning_r7_t
 *
 *******************************************************************************/
void convert_prach_partitioning_r7
(
 UMTS_PRACH_Partitioning_r7     *pvalue,
 prach_partitioning_r7_t        *p_r7 
 )
{
    p_r7->t = pvalue->t;

    if (pvalue->t == T_UMTS_PRACH_Partitioning_r7_fdd)
    {
        convert_prach_partitioning_r7_fdd(
                pvalue->u.fdd,
                &p_r7->u.fdd);
    }
    else if (pvalue->t == T_UMTS_PRACH_Partitioning_r7_tdd)
    {
        convert_prach_partitioning_r7_tdd(
                pvalue->u.tdd,
                &p_r7->u.tdd);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_SystemInformation_VHCR_r7 to
 *      prach_system_information_vhcr_r7_t
 *
 *******************************************************************************/
void convert_prach_system_information_vhcr_r7
(
 UMTS_PRACH_SystemInformation_VHCR_r7   *pvalue,
 prach_system_information_vhcr_r7_t     *p_r7
 )
{
    convert_prach_rach_info_vhcr_r7(
            &pvalue->prach_RACH_Info,
            &p_r7->prach_rach_info);

    if (pvalue->m.prach_PartitioningPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_PRACH_SYSTEM_INFORMATION_VHCR_R7_PRACH_PARTITIONING_PRESENCE_FLAG;

        convert_prach_partitioning_r7(
                &pvalue->prach_Partitioning,
                &p_r7->prach_partitioning);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information_list_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_SystemInformationList_VHCR_r7 to
 *      prach_system_information_list_vhcr_r7_t
 *
 *******************************************************************************/
void convert_prach_system_information_list_vhcr_r7
(
 UMTS_PRACH_SystemInformationList_VHCR_r7   *pvalue,
 prach_system_information_list_vhcr_r7_t    *p_r7 
 )
{
    UMTS_PRACH_SystemInformation_VHCR_r7    *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_r7->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PRACH_SystemInformation_VHCR_r7*)pnode->data;

        convert_prach_system_information_vhcr_r7(
                pdata,
                &p_r7->prach_system_information_vhcr_r7[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v770ext_ies_mode_specific_info_tdd768
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_tdd768 to
 *      sysinfotype5_v770ext_ies_mode_specific_info_tdd768_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v770ext_ies_mode_specific_info_tdd768
(
 UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_tdd768   *pvalue,
 sysinfotype5_v770ext_ies_mode_specific_info_tdd768_t    *p_tdd768
 )
{
    if(pvalue->m.pusch_SysInfoList_SFNPresent)
    {
        p_tdd768->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_MODESPECIFICINFO_TDD768_PUSCH_SYSINFOLIST_SFN_PRESENCE_FLAG;

        convert_pusch_sys_info_list_sfn_vhcr(
                &pvalue->pusch_SysInfoList_SFN,
                &p_tdd768->pusch_sys_info_list_sfn);
    }

    if(pvalue->m.pdsch_SysInfoList_SFNPresent)
    {
        p_tdd768->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_MODESPECIFICINFO_TDD768_PDSCH_SYSINFOLIST_SFN_PRESENCE_FLAG;

        convert_pdsch_sys_info_list_vhcr_r7(
                &pvalue->pdsch_SysInfoList_SFN,
                &p_tdd768->pdsch_sys_info_list_sfn);
    }

    if(pvalue->m.prach_SystemInformationListPresent)
    {
        p_tdd768->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_MODESPECIFICINFO_TDD768_PRACH_SYSTEMINFORMATIONLIST_PRESENCE_FLAG;

        convert_prach_system_information_list_vhcr_r7(
                &pvalue->prach_SystemInformationList,
                &p_tdd768->prach_system_information_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_system_information_list_lcr_v770ext
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_SystemInformationList_LCR_v770ext to
 *      prach_system_information_list_lcr_v770ext_t
 *
 *******************************************************************************/
void convert_prach_system_information_list_lcr_v770ext
(
 UMTS_PRACH_SystemInformationList_LCR_v770ext   *pvalue,
 prach_system_information_list_lcr_v770ext_t    *p_ext 
 )
{
    UMTS_PRACH_SystemInformation_LCR_v770ext    *pdata = NULL;
    OSRTDListNode                               *pnode = NULL;
    U32                                         index;

    pnode = pvalue->head;
    p_ext->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PRACH_SystemInformation_LCR_v770ext*)pnode->data;

        convert_sync_ul_codes_bitmap(
                &pdata->prach_RACH_Info_LCR.e_RUCCH_Sync_UL_Codes_Bitmap,
                &p_ext->prach_system_information_lcr_v770ext[index].prach_rach_info_lcr.e_rucch_sync_ul_codes_bitmap);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v770ext_ies_mode_specific_info_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_tdd128 to
 *      sysinfotype5_v770ext_ies_mode_specific_info_tdd128_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v770ext_ies_mode_specific_info_tdd128
(
 UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_tdd128  *pvalue,
 sysinfotype5_v770ext_ies_mode_specific_info_tdd128_t   *p_tdd128 
 )
{
    if (pvalue->m.prach_SystemInformationListPresent)
    {
        p_tdd128->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_MODE_SPECIFIC_INFO_TDD128_PRACH_SYSTEM_INFORMATION_LIST_PRESENCE_FLAG;

        convert_prach_system_information_list_lcr_v770ext(
                &pvalue->prach_SystemInformationList,
                &p_tdd128->prach_system_information_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v770ext_ies_mode_specific_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo to
 *      sysinfotype5_v770ext_ies_mode_specific_info_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v770ext_ies_mode_specific_info
(
 UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo     *pvalue,
 sysinfotype5_v770ext_ies_mode_specific_info_t      *p_modeSpecificInfo
 )
{
    p_modeSpecificInfo->t = pvalue->t;

    if(pvalue->t == T_UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_fdd)
    {
        convert_sysinfotype5_v770ext_ies_mode_specific_info_fdd(
                pvalue->u.fdd,
                &p_modeSpecificInfo->u.fdd);
    }
    else if(pvalue->t == T_UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_tdd768)
    {
        convert_sysinfotype5_v770ext_ies_mode_specific_info_tdd768(
                pvalue->u.tdd768,
                &p_modeSpecificInfo->u.tdd768);
    }
    else if(pvalue->t == T_UMTS_SysInfoType5_v770ext_IEs_modeSpecificInfo_tdd128)
    {
        convert_sysinfotype5_v770ext_ies_mode_specific_info_tdd128(
                pvalue->u.tdd128,
                &p_modeSpecificInfo->u.tdd128);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_r7_burst_type_type1_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode to
 *      midamble_shift_and_burst_type_r7_burst_type_type1_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_r7_burst_type_type1_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode       *pvalue,
 midamble_shift_and_burst_type_r7_burst_type_type1_midamble_allocation_mode_t   *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode_commonMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_r7_burst_type_type2_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode to
 *      midamble_shift_and_burst_type_r7_burst_type_type2_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_r7_burst_type_type2_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode       *pvalue,
 midamble_shift_and_burst_type_r7_burst_type_type2_midamble_allocation_mode_t   *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode_commonMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_r7_burst_type_type3_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode to
 *      midamble_shift_and_burst_type_r7_burst_type_type3_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_r7_burst_type_type3_midamble_allocation_mode
(
 UMTS_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode       *pvalue,
 midamble_shift_and_burst_type_r7_burst_type_type3_midamble_allocation_mode_t   *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_midamble_shift_and_burst_type_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_MidambleShiftAndBurstType_r7 to
 *      midamble_shift_and_burst_type_r7_t
 *
 *******************************************************************************/
void convert_midamble_shift_and_burst_type_r7
(
 UMTS_MidambleShiftAndBurstType_r7  *pvalue,
 midamble_shift_and_burst_type_r7_t *p_r7 
 )
{
    p_r7->burst_type.t = pvalue->burstType.t;

    if (pvalue->burstType.t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type1)
    {
        p_r7->burst_type.u.type1.midamble_configuration_burst_type1_and_3 =
            pvalue->burstType.u.type1->midambleConfigurationBurstType1and3;

        convert_midamble_shift_and_burst_type_r7_burst_type_type1_midamble_allocation_mode(
                &pvalue->burstType.u.type1->midambleAllocationMode,
                &p_r7->burst_type.u.type1.midamble_allocation_mode);
    }
    else if (pvalue->burstType.t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type2)
    {
        p_r7->burst_type.u.type2.midamble_configuration_burst_type2 =
            pvalue->burstType.u.type2->midambleConfigurationBurstType2;

        convert_midamble_shift_and_burst_type_r7_burst_type_type2_midamble_allocation_mode(
                &pvalue->burstType.u.type2->midambleAllocationMode,
                &p_r7->burst_type.u.type2.midamble_allocation_mode);
    }
    else if (pvalue->burstType.t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_type3)
    {
        p_r7->burst_type.u.type3.midamble_configuration_burst_type1_and_3 =
            pvalue->burstType.u.type3->midambleConfigurationBurstType1and3;

        convert_midamble_shift_and_burst_type_r7_burst_type_type3_midamble_allocation_mode(
                &pvalue->burstType.u.type3->midambleAllocationMode,
                &p_r7->burst_type.u.type3.midamble_allocation_mode);
    }
    else if (pvalue->burstType.t == T_UMTS_MidambleShiftAndBurstType_r7_burstType_mbsfnBurstType4)
    {
        /* for future use */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_individual_timeslot_info_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_IndividualTimeslotInfo_r7 to
 *      individual_timeslot_info_r7_t
 *
 *******************************************************************************/
void convert_individual_timeslot_info_r7
(
 UMTS_IndividualTimeslotInfo_r7     *pvalue,
 individual_timeslot_info_r7_t      *p_r7 
 )
{
    p_r7->timeslot_number = pvalue->timeslotNumber;
    p_r7->tfci_existence = pvalue->tfci_Existence;

    convert_midamble_shift_and_burst_type_r7(
            &pvalue->midambleShiftAndBurstType,
            &p_r7->midamble_shift_and_burst_type_r7);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_channelisation_code_list_vhcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_ChannelisationCodeList_VHCR to
 *      sccpch_channelisation_code_list_vhcr_t
 *
 *******************************************************************************/
void convert_sccpch_channelisation_code_list_vhcr
(
 UMTS_SCCPCH_ChannelisationCodeList_VHCR    *pvalue,
 sccpch_channelisation_code_list_vhcr_t     *p_vhcr 
 )
{
    p_vhcr->n = pvalue->n;

    memcpy(&p_vhcr->elem,
            &pvalue->elem, sizeof(U32)*p_vhcr->n);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_hcr_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCH_Info_HCR_VHCR_r7 to
 *      secondary_ccpch_info_hcr_vhcr_r7_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_hcr_vhcr_r7
(
 UMTS_SecondaryCCPCH_Info_HCR_VHCR_r7   *pvalue,
 secondary_ccpch_info_hcr_vhcr_r7_t     *p_r7 
 )
{
    p_r7->mode_specific_info.t = 
        pvalue->modeSpecificInfo.t;

    if (pvalue->modeSpecificInfo.t == T_UMTS_SecondaryCCPCH_Info_HCR_VHCR_r7_modeSpecificInfo_tdd384)
    {
        convert_individual_timeslot_info_r7(
                &pvalue->modeSpecificInfo.u.tdd384->individualTimeslotInfo,
                &p_r7->mode_specific_info.u.tdd384.individual_timeslot_info);

        convert_sccpch_channelisation_code_list(
                &pvalue->modeSpecificInfo.u.tdd384->channelisationCode,
                &p_r7->mode_specific_info.u.tdd384.sccpch_channelisation_code_list);
    }
    else if (pvalue->modeSpecificInfo.t == T_UMTS_SecondaryCCPCH_Info_HCR_VHCR_r7_modeSpecificInfo_tdd768)
    {
        convert_individual_timeslot_info_vhcr(
                &pvalue->modeSpecificInfo.u.tdd768->individualTimeslotInfo,
                &p_r7->mode_specific_info.u.tdd768.individual_timeslot_info);

        convert_sccpch_channelisation_code_list_vhcr(
                &pvalue->modeSpecificInfo.u.tdd768->channelisationCode,
                &p_r7->mode_specific_info.u.tdd768.channelisation_code);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pich_info_hcr_vhcr_r7_channelisation_code
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PICH_Info_HCR_VHCR_r7_channelisationCode to
 *      pich_info_hcr_vhcr_r7_channelisation_code_t
 *
 *******************************************************************************/
void convert_pich_info_hcr_vhcr_r7_channelisation_code
(
 UMTS_PICH_Info_HCR_VHCR_r7_channelisationCode  *pvalue,
 pich_info_hcr_vhcr_r7_channelisation_code_t    *p_code 
 )
{
    p_code->t = pvalue->t;

    if (pvalue->t == T_UMTS_PICH_Info_HCR_VHCR_r7_channelisationCode_tdd384)
    {
        p_code->u.tdd384 = pvalue->u.tdd384;    
    }
    else if (pvalue->t == T_UMTS_PICH_Info_HCR_VHCR_r7_channelisationCode_tdd768)
    {
        p_code->u.tdd768 = pvalue->u.tdd768;    
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pich_info_hcr_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PICH_Info_HCR_VHCR_r7 to
 *      pich_info_hcr_vhcr_r7_t
 *
 *******************************************************************************/
void convert_pich_info_hcr_vhcr_r7
(
 UMTS_PICH_Info_HCR_VHCR_r7     *pvalue,
 pich_info_hcr_vhcr_r7_t        *p_info 
 )
{
    if (pvalue->m.channelisationCodePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PICH_INFO_HCR_VHCR_R7_CHANNELISATION_CODE_PRESENCE_FLAG;

        convert_pich_info_hcr_vhcr_r7_channelisation_code(
                &pvalue->channelisationCode,
                &p_info->channelisation_code);
    }

    if (pvalue->m.timeslotPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PICH_INFO_HCR_VHCR_R7_TIMESLOT_PRESENCE_FLAG;

        p_info->timeslot = pvalue->timeslot;
    }

    convert_midamble_shift_and_burst_type(
            &pvalue->midambleShiftAndBurstType,
            &p_info->midamble_shift_and_burst_type);

    if (pvalue->m.repetitionPeriodLengthOffsetPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PICH_INFO_HCR_VHCR_R7_REP_PER_LENGTH_OFFSET_PICH_PRESENCE_FLAG;

        convert_rep_per_length_offset_pich(
                &pvalue->repetitionPeriodLengthOffset,
                &p_info->rep_per_length_offset_pich);
    }

    p_info->paging_indicator_length = pvalue->pagingIndicatorLength;
    p_info->n_gap = pvalue->n_GAP;
    p_info->n_pch = pvalue->n_PCH;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_hcr_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformation_HCR_VHCR_r7 to
 *      sccpch_system_information_hcr_vhcr_r7_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_hcr_vhcr_r7
(
 UMTS_SCCPCH_SystemInformation_HCR_VHCR_r7  *pvalue,
 sccpch_system_information_hcr_vhcr_r7_t    *p_r7 
 )
{
    convert_secondary_ccpch_info_hcr_vhcr_r7(
            &pvalue->secondaryCCPCH_Info,
            &p_r7->secondary_ccpch_info);

    if (pvalue->m.tfcsPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_SCCPCH_SYSTEM_INFORMATION_HCR_VHCR_R7_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->tfcs,
                &p_r7->tfcs); 
    }

    if (pvalue->m.fach_PCH_InformationListPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_SCCPCH_SYSTEM_INFORMATION_HCR_VHCR_R7_FACH_PCH_INFORMATION_LIST_PRESENCE_FLAG;

        convert_fach_pch_information_list(
                &pvalue->fach_PCH_InformationList,
                &p_r7->fach_pch_information_list); 
    }

    if (pvalue->m.pich_InfoPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_SCCPCH_SYSTEM_INFORMATION_HCR_VHCR_R7_PICH_INFO_PRESENCE_FLAG;

        convert_pich_info_hcr_vhcr_r7(
                &pvalue->pich_Info,
                &p_r7->pich_info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_list_hcr_vhcr_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformationList_HCR_VHCR_r7 to
 *      sccpch_system_information_list_hcr_vhcr_r7_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_list_hcr_vhcr_r7
(
 UMTS_SCCPCH_SystemInformationList_HCR_VHCR_r7  *pvalue,
 sccpch_system_information_list_hcr_vhcr_r7_t   *p_r7 
 )
{
    UMTS_SCCPCH_SystemInformation_HCR_VHCR_r7   *pdata = NULL;
    OSRTDListNode                               *pnode = NULL;
    U32                                         index;

    pnode = pvalue->head;
    p_r7->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_SCCPCH_SystemInformation_HCR_VHCR_r7*)pnode->data;

        convert_sccpch_system_information_hcr_vhcr_r7(
                pdata,
                &p_r7->sccpch_system_information_hcr_vhcr_r7[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r7_mode_specific_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_fdd to
 *      secondary_ccpch_info_mbms_r7_mode_specific_info_fdd_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r7_mode_specific_info_fdd
(
 UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_fdd   *pvalue,
 secondary_ccpch_info_mbms_r7_mode_specific_info_fdd_t  *p_fdd 
 )
{
    if(pvalue->m.secondaryScramblingCodePresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_SECONDARY_CCPCH_INFO_MBMS_R7_MODE_SPECIFIC_INFO_FDD_SECONDARY_SCRAMBLING_CODE_PRESENCE_FLAG;

        p_fdd->secondary_scrambling_code =
            pvalue->secondaryScramblingCode;
    }

    p_fdd->sttd_indicator = pvalue->sttd_Indicator;

    convert_sf256_and_code_number(
            &pvalue->sf_AndCodeNumber,
            &p_fdd->sf_and_code_number);

    p_fdd->timing_offset = pvalue->timingOffset;

    if (pvalue->m.modulationPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_SECONDARY_CCPCH_INFO_MBMS_R7_MODE_SPECIFIC_INFO_FDD_MODULATION_PRESENCE_FLAG;

        p_fdd->modulation.t = pvalue->modulation.t;

        if (pvalue->modulation.t == T_UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_fdd_modulation_modQPSK) 
        {
            /* for future use */        
        }
        else if (pvalue->modulation.t == T_UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_fdd_modulation_mod16QAM)
        {
            p_fdd->modulation.u.mod_16_qam =
                pvalue->modulation.u.mod16QAM; 
        }
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_additional_timeslots_r7_parameters
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkAdditionalTimeslots_r7_parameters to
 *      downlink_additional_timeslots_r7_parameters_t
 *
 *******************************************************************************/
void convert_downlink_additional_timeslots_r7_parameters
(
 UMTS_DownlinkAdditionalTimeslots_r7_parameters     *pvalue,
 downlink_additional_timeslots_r7_parameters_t      *p_params
 )
{
    p_params->t = pvalue->t;

    if (pvalue->t == T_UMTS_DownlinkAdditionalTimeslots_r7_parameters_sameAsLast)
    {
        p_params->u.same_as_last.timeslot_number = 
            pvalue->u.sameAsLast->timeslotNumber; 
    }
    else if (pvalue->t == T_UMTS_DownlinkAdditionalTimeslots_r7_parameters_newParameters)
    {
        convert_individual_timeslot_info_r7(
                &pvalue->u.newParameters->individualTimeslotInfo,
                &p_params->u.new_parameters.individual_timeslot_info);

        convert_dl_ts_channelisation_codes_short(
                &pvalue->u.newParameters->dl_TS_ChannelisationCodesShort,
                &p_params->u.new_parameters.dl_ts_channelisation_codes_short);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_r7_more_timeslots_additional_timeslots_timeslot_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList to
 *      downlink_timeslots_codes_r7_more_timeslots_additional_timeslots_timeslot_list_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_r7_more_timeslots_additional_timeslots_timeslot_list
(
 UMTS_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList      *pvalue,
 downlink_timeslots_codes_r7_more_timeslots_additional_timeslots_timeslot_list_t    *p_list 
 )
{
    UMTS_DownlinkAdditionalTimeslots_r7 *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_DownlinkAdditionalTimeslots_r7*)pnode->data;

        convert_downlink_additional_timeslots_r7_parameters(
                &pdata->parameters,
                &p_list->downlink_additional_timeslots_r7[index].parameters);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_r7_more_timeslots
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_r7_moreTimeslots to
 *      downlink_timeslots_codes_r7_more_timeslots_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_r7_more_timeslots
(
 UMTS_DownlinkTimeslotsCodes_r7_moreTimeslots   *pvalue,
 downlink_timeslots_codes_r7_more_timeslots_t   *p_info 
 )
{
    if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_r7_moreTimeslots_noMore)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots)
    {
        p_info->u.additional_timeslots.t = pvalue->u.additionalTimeslots->t;

        if (pvalue->u.additionalTimeslots->t == T_UMTS_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_consecutive) 
        {
            p_info->u.additional_timeslots.u.consecutive =
                pvalue->u.additionalTimeslots->u.consecutive; 
        }
        else if (pvalue->u.additionalTimeslots->t == T_UMTS_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList)
        {
            convert_downlink_timeslots_codes_r7_more_timeslots_additional_timeslots_timeslot_list(
                    pvalue->u.additionalTimeslots->u.timeslotList,
                    &p_info->u.additional_timeslots.u.timeslot_list); 
        }
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_downlink_timeslots_codes_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DownlinkTimeslotsCodes_r7 to
 *      downlink_timeslots_codes_r7_t
 *
 *******************************************************************************/
void convert_downlink_timeslots_codes_r7
(
 UMTS_DownlinkTimeslotsCodes_r7     *pvalue,
 downlink_timeslots_codes_r7_t      *p_r7
 )
{
    convert_individual_timeslot_info_r7(
            &pvalue->firstIndividualTimeslotInfo,
            &p_r7->first_individual_timeslot_info);

    convert_dl_ts_channelisation_codes_short(
            &pvalue->dl_TS_ChannelisationCodesShort,
            &p_r7->dl_ts_channelisation_codes_short);

    convert_downlink_timeslots_codes_r7_more_timeslots(
            &pvalue->moreTimeslots,
            &p_r7->more_timeslots);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd384
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd384 to
 *      secondary_ccpch_info_mbms_r7_mode_specific_info_tdd384_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd384
(
 UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd384    *pvalue,
 secondary_ccpch_info_mbms_r7_mode_specific_info_tdd384_t   *p_info 
 )
{
    convert_common_timeslot_info_mbms(
            &pvalue->commonTimeslotInfoMBMS,
            &p_info->first_individual_timeslot_info);

    convert_downlink_timeslots_codes_r7(
            &pvalue->downlinkTimeslotsCodes,
            &p_info->downlink_timeslots_codes);

    p_info->modulation = pvalue->modulation;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd768
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd768 to
 *      secondary_ccpch_info_mbms_r7_mode_specific_info_tdd768_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd768
(
 UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd768    *pvalue,
 secondary_ccpch_info_mbms_r7_mode_specific_info_tdd768_t   *p_info 
 )
{
    convert_common_timeslot_info_mbms(
            &pvalue->commonTimeslotInfoMBMS,
            &p_info->common_timeslot_info_mbms);

    convert_downlink_timeslots_codes_vhcr(
            &pvalue->downlinkTimeslotsCodes,
            &p_info->downlink_timeslots_codes);

    p_info->modulation = pvalue->modulation;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd128 to
 *      secondary_ccpch_info_mbms_r7_mode_specific_info_tdd128_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd128
(
 UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd128    *pvalue,
 secondary_ccpch_info_mbms_r7_mode_specific_info_tdd128_t   *p_info 
 )
{
    convert_common_timeslot_info_mbms(
            &pvalue->commonTimeslotInfoMBMS,
            &p_info->common_timeslot_info_mbms);

    convert_downlink_timeslots_codes_lcr_r4(
            &pvalue->downlinkTimeslotsCodes,
            &p_info->downlink_timeslots_codes);

    p_info->mbsfn_special_time_slot = 
        pvalue->mbsfnSpecialTimeSlot;

    p_info->modulation = pvalue->modulation;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_secondary_ccpch_info_mbms_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SecondaryCCPCHInfo_MBMS_r7 to
 *      secondary_ccpch_info_mbms_r7_t
 *
 *******************************************************************************/
void convert_secondary_ccpch_info_mbms_r7
(
 UMTS_SecondaryCCPCHInfo_MBMS_r7    *pvalue,
 secondary_ccpch_info_mbms_r7_t     *p_r7 
 )
{
    p_r7->mode_specific_info.t = pvalue->modeSpecificInfo.t;

    if (pvalue->modeSpecificInfo.t == T_UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_fdd)
    {
        convert_secondary_ccpch_info_mbms_r7_mode_specific_info_fdd(
                pvalue->modeSpecificInfo.u.fdd,
                &p_r7->mode_specific_info.u.fdd);    
    }
    else if (pvalue->modeSpecificInfo.t == T_UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd384)
    {
        convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd384(
                pvalue->modeSpecificInfo.u.tdd384,
                &p_r7->mode_specific_info.u.tdd384); 
    }
    else if (pvalue->modeSpecificInfo.t == T_UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd768)
    {
        convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd768(
                pvalue->modeSpecificInfo.u.tdd768,
                &p_r7->mode_specific_info.u.tdd768); 
    }
    else if (pvalue->modeSpecificInfo.t == T_UMTS_SecondaryCCPCHInfo_MBMS_r7_modeSpecificInfo_tdd128)
    {
        convert_secondary_ccpch_info_mbms_r7_mode_specific_info_tdd128(
                pvalue->modeSpecificInfo.u.tdd128,
                &p_r7->mode_specific_info.u.tdd128); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_mbms_r7_fach_carrying_mcch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformation_MBMS_r7_fachCarryingMCCH to
 *      sccpch_system_information_mbms_r7_fach_carrying_mcch_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_mbms_r7_fach_carrying_mcch
(
 UMTS_SCCPCH_SystemInformation_MBMS_r7_fachCarryingMCCH     *pvalue,
 sccpch_system_information_mbms_r7_fach_carrying_mcch_t     *p_mcch 
 )
{
    convert_transport_format_set(
            &pvalue->mcch_transportFormatSet,
            &p_mcch->mcch_transport_format_set);

    convert_mbms_mcch_configuration_info_r6(
            &pvalue->mcch_ConfigurationInfo,
            &p_mcch->mcch_configuration_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_mbms_r7_fach_carrying_msch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformation_MBMS_r7_fachCarryingMSCH to
 *      sccpch_system_information_mbms_r7_fach_carrying_msch_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_mbms_r7_fach_carrying_msch
(
 UMTS_SCCPCH_SystemInformation_MBMS_r7_fachCarryingMSCH     *pvalue,
 sccpch_system_information_mbms_r7_fach_carrying_msch_t     *p_msch 
 )
{
    convert_transport_format_set(
            &pvalue->msch_transportFormatSet,
            &p_msch->transport_format_set);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sccpch_system_information_mbms_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SCCPCH_SystemInformation_MBMS_r7 to
 *      sccpch_system_information_mbms_r7_t
 *
 *******************************************************************************/
void convert_sccpch_system_information_mbms_r7
(
 UMTS_SCCPCH_SystemInformation_MBMS_r7  *pvalue,
 sccpch_system_information_mbms_r7_t    *p_r7 
 )
{
    convert_secondary_ccpch_info_mbms_r7(
            &pvalue->secondaryCCPCHInfo_MBMS,
            &p_r7->secondary_ccpch_info_mbms);

    convert_tfcs(
            &pvalue->transportFormatCombinationSet,
            &p_r7->transport_format_combination_set);

    convert_sccpch_system_information_mbms_r7_fach_carrying_mcch(
            &pvalue->fachCarryingMCCH,
            &p_r7->fach_carrying_mcch);

    if (pvalue->m.fachCarryingMTCH_ListPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_SCCPCH_SYSTEM_INFORMATION_MBMS_R7_MBMS_FACH_CARRYING_MTCH_LIST_PRESENCE_FLAG;

        convert_mbms_fach_carrying_mtch_list(
                &pvalue->fachCarryingMTCH_List,
                &p_r7->mbms_fach_carrying_mtch_list);
    }

    if (pvalue->m.fachCarryingMSCHPresent)
    {
        p_r7->presence_bitmask |=
            UMTS_SIB_SCCPCH_SYSTEM_INFORMATION_MBMS_R7_FACH_CARRYING_MSCH_PRESENCE_FLAG;

        convert_sccpch_system_information_mbms_r7_fach_carrying_msch(
                &pvalue->fachCarryingMSCH,
                &p_r7->fach_carrying_msch);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v770ext_ies_sccpch_system_information_mbms
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v770ext_IEs_sccpch_SystemInformation_MBMS to
 *      sysinfotype5_v770ext_ies_sccpch_system_information_mbms_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v770ext_ies_sccpch_system_information_mbms
(
 UMTS_SysInfoType5_v770ext_IEs_sccpch_SystemInformation_MBMS    *pvalue,
 sysinfotype5_v770ext_ies_sccpch_system_information_mbms_t      *p_mbms 
 )
{
    p_mbms->t = pvalue->t;

    if (pvalue->t == T_UMTS_SysInfoType5_v770ext_IEs_sccpch_SystemInformation_MBMS_mcchOnSCCPCHusedOnlyForMBMS)
    {
        convert_sccpch_system_information_mbms_r7(
                pvalue->u.mcchOnSCCPCHusedOnlyForMBMS,
                &p_mbms->u.mcch_on_sccpch_used_only_for_mbms);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_tdd_mbsfn_information
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_TDD_MBSFNInformation to
 *      tdd_mbsfn_information_t
 *
 *******************************************************************************/
void convert_tdd_mbsfn_information
(
 UMTS_TDD_MBSFNInformation  *pvalue,
 tdd_mbsfn_information_t    *p_info 
 )
{
    UMTS_TDD_MBSFNTSlotInfo *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_TDD_MBSFNTSlotInfo*)pnode->data;

        p_info->tdd_mbsfnt_slot_info[index].time_slot_number =
            pdata->timeSlotNumber;

        p_info->tdd_mbsfnt_slot_info[index].cell_parameters_id =
            pdata->cellParametersID;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:convert_sysinfotype5_v770ext_ies
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v770ext_IEs to
 *      sysinfotype5_v770ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v770ext_ies
(
 UMTS_SysInfoType5_v770ext_IEs      *pvalue,
 sysinfotype5_v770ext_ies_t         *p_sysInfoType5_v770ext
 )
{
    if(pvalue->m.modeSpecificInfoPresent)
    {
        p_sysInfoType5_v770ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_MODE_SPECIFIC_INFO_PRESENCE_FLAG;

        convert_sysinfotype5_v770ext_ies_mode_specific_info(
                &pvalue->modeSpecificInfo,
                &p_sysInfoType5_v770ext->mode_specific_info);
    }

    if(pvalue->m.sccpch_SystemInformationListPresent)
    {
        p_sysInfoType5_v770ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_SCCPCH_SYSTEM_INFORMATION_LIST_PRESENCE_FLAG;

        convert_sccpch_system_information_list_hcr_vhcr_r7(
                &pvalue->sccpch_SystemInformationList,
                &p_sysInfoType5_v770ext->sccpch_system_information_list);
    }

    if(pvalue->m.sccpch_SystemInformation_MBMSPresent)
    {
        p_sysInfoType5_v770ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_SCCPCH_SYSTEM_INFORMATION_MBMS_PRESENCE_FLAG;

        convert_sysinfotype5_v770ext_ies_sccpch_system_information_mbms(
                &pvalue->sccpch_SystemInformation_MBMS,
                &p_sysInfoType5_v770ext->sccpch_system_information_mbms);
    }

    if(pvalue->m.tDD_MBSFNInformationPresent)
    {
        p_sysInfoType5_v770ext->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V770EXT_IES_TDD_MBSFN_INFORMATION_PRESENCE_FLAG;

        convert_tdd_mbsfn_information(
                &pvalue->tDD_MBSFNInformation,
                &p_sysInfoType5_v770ext->tdd_mbsfn_information);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v860ext_ies_dummy
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v860ext_IEs_dummy to
 *      sysinfotype5_v860ext_ies_dummy_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v860ext_ies_dummy
(
 UMTS_SysInfoType5_v860ext_IEs_dummy    *pvalue,
 sysinfotype5_v860ext_ies_dummy_t       *p_dummy
 )
{
    p_dummy->__dummy__ = pvalue->__dummy__;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_drx_cell_fach_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_DrxCellfach_info to
 *      hs_dsch_drx_cell_fach_info_t
 *
 *******************************************************************************/
void convert_hs_dsch_drx_cell_fach_info
(
 UMTS_HS_DSCH_DrxCellfach_info  *pvalue,
 hs_dsch_drx_cell_fach_info_t   *p_info 
 )
{
    p_info->t_321 = pvalue->t_321;
    p_info->hs_dsch_drx_cycle_fach = pvalue->hs_dsch_DrxCycleFach;
    p_info->hs_dsch_drx_burst_fach = pvalue->hs_dsch_DrxBurstFach;
    p_info->drx_interruption_hs_dsch = pvalue->drxInterruption_hs_dsch;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_scch_tdd128_r6_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_SCCH_TDD128_r6_midambleAllocationMode to
 *      hs_scch_tdd128_r6_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_hs_scch_tdd128_r6_midamble_allocation_mode
(
 UMTS_HS_SCCH_TDD128_r6_midambleAllocationMode  *pvalue,
 hs_scch_tdd128_r6_midamble_allocation_mode_t   *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_HS_SCCH_TDD128_r6_midambleAllocationMode_defaultMidamble)    
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_HS_SCCH_TDD128_r6_midambleAllocationMode_commonMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_HS_SCCH_TDD128_r6_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble = pvalue->u.ueSpecificMidamble; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_sich_configuration_tdd128_r6_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode to
 *      hs_sich_configuration_tdd128_r6_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_hs_sich_configuration_tdd128_r6_midamble_allocation_mode
(
 UMTS_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode    *pvalue,
 hs_sich_configuration_tdd128_r6_midamble_allocation_mode_t     *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */ 
    }
    else if (pvalue->t == T_UMTS_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble.midamble_shift =
            pvalue->u.ueSpecificMidamble->midambleShift; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_sich_configuration_tdd128_r6
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_SICH_Configuration_TDD128_r6 to
 *      hs_sich_configuration_tdd128_r6_t
 *
 *******************************************************************************/
void convert_hs_sich_configuration_tdd128_r6
(
 UMTS_HS_SICH_Configuration_TDD128_r6   *pvalue,
 hs_sich_configuration_tdd128_r6_t      *p_r6 
 )
{
    p_r6->timeslot_number = pvalue->timeslotNumber;
    p_r6->channelisation_code = pvalue->channelisationCode;

    convert_hs_sich_configuration_tdd128_r6_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_r6->midamble_allocation_mode);

    p_r6->midamble_configuration = pvalue->midambleConfiguration;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_scch_system_info_tdd128_hs_scch_set_configuration
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_SCCH_SystemInfo_TDD128_hs_SCCH_SetConfiguration to
 *      hs_scch_system_info_tdd128_hs_scch_set_configuration_t
 *
 *******************************************************************************/
void convert_hs_scch_system_info_tdd128_hs_scch_set_configuration
(
 UMTS_HS_SCCH_SystemInfo_TDD128_hs_SCCH_SetConfiguration    *pvalue,
 hs_scch_system_info_tdd128_hs_scch_set_configuration_t     *p_conf 
 )
{
    UMTS_HS_SCCH_TDD128_r6  *pdata = NULL;
    OSRTDListNode           *pnode = NULL;
    U32                     index;

    pnode = pvalue->head;
    p_conf->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_HS_SCCH_TDD128_r6*)pnode->data;

        p_conf->hs_scch_tdd128_r6[index].timeslot_number =
            pdata->timeslotNumber;

        p_conf->hs_scch_tdd128_r6[index].first_channelisation_code =
            pdata->firstChannelisationCode;

        p_conf->hs_scch_tdd128_r6[index].second_channelisation_code =
            pdata->secondChannelisationCode;

        convert_hs_scch_tdd128_r6_midamble_allocation_mode(
                &pdata->midambleAllocationMode,
                &p_conf->hs_scch_tdd128_r6[index].midamble_allocation_mode);

        p_conf->hs_scch_tdd128_r6[index].midamble_configuration =
            pdata->midambleConfiguration;

        convert_hs_sich_configuration_tdd128_r6(
                &pdata->hs_sich_configuration,
                &p_conf->hs_scch_tdd128_r6[index].hs_sich_configuration);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_scch_system_info_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_SCCH_SystemInfo_TDD128 to
 *      hs_scch_system_info_tdd128_t
 *
 *******************************************************************************/
void convert_hs_scch_system_info_tdd128
(
 UMTS_HS_SCCH_SystemInfo_TDD128     *pvalue,
 hs_scch_system_info_tdd128_t       *p_info
 )
{
    convert_hs_scch_system_info_tdd128_hs_scch_set_configuration(
            &pvalue->hs_SCCH_SetConfiguration,
            &p_info->hs_scch_set_configuration);

    memcpy(&p_info->power_level_hssich,
            &pvalue->power_level_HSSICH,
            sizeof(S8));

    memcpy(&p_info->nack_ack_power_offset,
            &pvalue->nack_ack_power_offset,
            sizeof(S8));

    p_info->tpc_step_size = pvalue->tpc_step_size;
    p_info->bler_target = pvalue->bler_target;

    if (pvalue->m.power_control_gapPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_HS_SCCH_SYSTEMINFO_TDD128_POWER_CONTROL_GAP_PRESENCE_FLAG;

        p_info->power_control_gap = pvalue->power_control_gap;
    }

    if (pvalue->m.pathloss_compensation_switchPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_HS_SCCH_SYSTEMINFO_TDD128_PATHLOSS_COMPENSATION_SWITCH_PRESENCE_FLAG;

        p_info->pathloss_compensation_switch = pvalue->pathloss_compensation_switch;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_pdsch_midamble_configuration_tdd128_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_PDSCH_Midamble_Configuration_TDD128_midambleAllocationMode to
 *      hs_pdsch_midamble_configuration_tdd128_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_hs_pdsch_midamble_configuration_tdd128_midamble_allocation_mode
(
 UMTS_HS_PDSCH_Midamble_Configuration_TDD128_midambleAllocationMode *pvalue,
 hs_pdsch_midamble_configuration_tdd128_midamble_allocation_mode_t  *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_HS_PDSCH_Midamble_Configuration_TDD128_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_HS_PDSCH_Midamble_Configuration_TDD128_midambleAllocationMode_commonMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_HS_PDSCH_Midamble_Configuration_TDD128_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble = pvalue->u.ueSpecificMidamble;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_pdsch_midamble_configuration_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_PDSCH_Midamble_Configuration_TDD128 to
 *      hs_pdsch_midamble_configuration_tdd128_t
 *
 *******************************************************************************/
void convert_hs_pdsch_midamble_configuration_tdd128
(
 UMTS_HS_PDSCH_Midamble_Configuration_TDD128    *pvalue,
 hs_pdsch_midamble_configuration_tdd128_t       *p_tdd128 
 )
{
    convert_hs_pdsch_midamble_configuration_tdd128_midamble_allocation_mode(
            &pvalue->midambleAllocationMode,
            &p_tdd128->midamble_allocation_mode);

    p_tdd128->midamble_configuration =
        pvalue->midambleConfiguration;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_common_system_information_tdd128_common_h_rnti_information
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_CommonSystemInformation_TDD128_common_H_RNTI_information to
 *      hs_dsch_common_system_information_tdd128_common_h_rnti_information_t
 *
 *******************************************************************************/
void convert_hs_dsch_common_system_information_tdd128_common_h_rnti_information
(
 UMTS_HS_DSCH_CommonSystemInformation_TDD128_common_H_RNTI_information  *pvalue,
 hs_dsch_common_system_information_tdd128_common_h_rnti_information_t   *p_info 
 )
{
    U32         idx;
    p_info->n = pvalue->n;

    for (idx=0; idx < p_info->n; idx ++)
    {
        convert_h_rnti(
                &pvalue->elem[idx],
                &p_info->elem[idx]);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_common_system_information_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_CommonSystemInformation_TDD128 to
 *      hs_dsch_common_system_information_tdd128_t
 *
 *******************************************************************************/
void convert_hs_dsch_common_system_information_tdd128
(
 UMTS_HS_DSCH_CommonSystemInformation_TDD128    *pvalue,
 hs_dsch_common_system_information_tdd128_t     *p_tdd128 
 )
{
    convert_common_rb_mapping_info(
            &pvalue->ccch_MappingInfo,
            &p_tdd128->ccch_mapping_info);

    if (pvalue->m.srb1_MappingInfoPresent)
    {
        p_tdd128->presence_bitmask |=
            UMTS_SIB_HS_DSCH_COMMON_SYSTEM_INFORMATION_TDD128_SRB1_MAPPING_INFO_PRESENCE_FLAG;

        convert_common_rb_mapping_info(
                &pvalue->srb1_MappingInfo,
                &p_tdd128->srb1_mapping_info);
    }

    convert_common_mac_ehs_reordering_queue_list(
            &pvalue->common_MAC_ehs_ReorderingQueueList,
            &p_tdd128->common_mac_ehs_reordering_queue_list);

    convert_hs_scch_system_info_tdd128(
            &pvalue->hs_scch_SystemInfo_tdd128,
            &p_tdd128->hs_scch_systeminfo_tdd128);

    convert_harq_info(
            &pvalue->harq_SystemInfo,
            &p_tdd128->harq_system_info);

    convert_hs_pdsch_midamble_configuration_tdd128(
            &pvalue->hs_pdsch_MidambleConfiguration,
            &p_tdd128->hs_pdsch_midamble_configuration);

    convert_hs_dsch_common_system_information_tdd128_common_h_rnti_information(
            &pvalue->common_H_RNTI_information,
            &p_tdd128->common_h_rnti_information);

    convert_h_rnti(
            &pvalue->bcchSpecific_H_RNTI,
            &p_tdd128->bcch_specific_h_rnti);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_paging_system_information_tdd128_pich_for_hs_dsch_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_PagingSystemInformation_TDD128_pich_ForHsdschList to
 *      hs_dsch_paging_system_information_tdd128_pich_for_hs_dsch_list_t
 *
 *******************************************************************************/
void convert_hs_dsch_paging_system_information_tdd128_pich_for_hs_dsch_list
(
 UMTS_HS_DSCH_PagingSystemInformation_TDD128_pich_ForHsdschList     *pvalue,
 hs_dsch_paging_system_information_tdd128_pich_for_hs_dsch_list_t   *p_list 
 )
{
    UMTS_PICH_ForHSDPASupportedPaging_TDD128    *pdata = NULL;
    OSRTDListNode                               *pnode = NULL;
    U32                                         index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PICH_ForHSDPASupportedPaging_TDD128*)pnode->data;

        p_list->pich_for_hsdpa_supported_paging_tdd128[index].t =
            pdata->t;

        if (pdata->t == T_UMTS_PICH_ForHSDPASupportedPaging_TDD128_implicit)
        {
            if (pdata->u.implicit->m.occurrenceSequenceNumberOfPICHPresent)        
            {
                p_list->pich_for_hsdpa_supported_paging_tdd128[index].u.implicit.presence_bitmask |=
                    UMTS_SIB_PICH_FOR_HSDPA_SUPPORTED_PAGING_TDD128_IMPLICIT_OCCURRENCE_SEQUENCE_NUMBER_OF_PICH_PRESENCE_FLAG;

                p_list->pich_for_hsdpa_supported_paging_tdd128[index].u.implicit.occurrence_sequence_number_of_pich =
                    pdata->u.implicit->occurrenceSequenceNumberOfPICH;
            }
        }
        else if (pdata->t == T_UMTS_PICH_ForHSDPASupportedPaging_TDD128_explicit_)
        {
            convert_pich_info_lcr_r4(
                    pdata->u.explicit_,
                    &p_list->pich_for_hsdpa_supported_paging_tdd128[index].u.explicit_); 
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_umts1_bit_str32
 *
 *   DESCRIPTION:
 *      This function converts 
 *      ASN1BitStr32 to
 *      umts1_bit_str32_t
 *
 *******************************************************************************/
void convert_umts1_bit_str32
(
 ASN1BitStr32       *pvalue,
 umts1_bit_str32_t  *p_info 
 )
{
    p_info->numbits = pvalue->numbits;

    memcpy(&p_info->data,
            &pvalue->data,
            sizeof(U8)*p_info->numbits);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_code_resource_information_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CodeResourceInformation_TDD128 to
 *      code_resource_information_tdd128_t
 *
 *******************************************************************************/
void convert_code_resource_information_tdd128
(
 UMTS_CodeResourceInformation_TDD128    *pvalue,
 code_resource_information_tdd128_t     *p_info 
 )
{
    p_info->start_code = pvalue->start_code;
    p_info->stop_code = pvalue->stop_code;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pcch_information_list_paging_associated_hs_pdsch_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PCCH_InformationList_paging_associatedHspdschInfo to
 *      pcch_information_list_paging_associated_hs_pdsch_info_t
 *
 *******************************************************************************/
void convert_pcch_information_list_paging_associated_hs_pdsch_info
(
 UMTS_PCCH_InformationList_paging_associatedHspdschInfo     *pvalue,
 pcch_information_list_paging_associated_hs_pdsch_info_t    *p_info 
 )
{
    UMTS_PCCH_InformationList_paging_associatedHspdschInfo_element  *pdata = NULL;
    OSRTDListNode                                                   *pnode = NULL;
    U32                                                             index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PCCH_InformationList_paging_associatedHspdschInfo_element*)pnode->data;

        convert_hs_pdsch_midamble_configuration_tdd128(
                &pdata->hs_pdsch_MidambleConfiguration,
                &p_info->hs_pdsch_info_element[index].hs_pdsch_midamble_configuration_tdd128);

        convert_umts1_bit_str32(
                &pdata->timeslotResourceRelatedInfo,
                &p_info->hs_pdsch_info_element[index].timeslot_resource_related_info);

        convert_code_resource_information_tdd128(
                &pdata->codeResourceInformation,
                &p_info->hs_pdsch_info_element[index].code_resource_information);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pcch_information_list_transport_block_size_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PCCH_InformationList_transportBlockSizeList to
 *      pcch_information_list_transport_block_size_list_t
 *
 *******************************************************************************/
void convert_pcch_information_list_transport_block_size_list
(
 UMTS_PCCH_InformationList_transportBlockSizeList   *pvalue,
 pcch_information_list_transport_block_size_list_t  *p_list 
 )
{
    p_list->n = pvalue->n;

    memcpy(&p_list->elem,
            &pvalue->elem,
            sizeof(U8)*p_list->n);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pcch_information_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PCCH_InformationList to
 *      pcch_information_list_t
 *
 *******************************************************************************/
void convert_pcch_information_list
(
 UMTS_PCCH_InformationList  *pvalue,
 pcch_information_list_t    *p_list 
 )
{
    convert_pcch_information_list_paging_associated_hs_pdsch_info(
            &pvalue->paging_associatedHspdschInfo,
            &p_list->paging_associated_hs_pdsch_info);

    p_list->paging_sub_channel_size =
        pvalue->paging_sub_Channel_size;

    convert_pcch_information_list_transport_block_size_list(
            &pvalue->transportBlockSizeList,
            &p_list->transport_block_size_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_paging_system_information_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_PagingSystemInformation_TDD128 to
 *      hs_dsch_paging_system_information_tdd128_t
 *
 *******************************************************************************/
void convert_hs_dsch_paging_system_information_tdd128
(
 UMTS_HS_DSCH_PagingSystemInformation_TDD128    *pvalue,
 hs_dsch_paging_system_information_tdd128_t     *p_tdd128 
 )
{
    convert_hs_dsch_paging_system_information_tdd128_pich_for_hs_dsch_list(
            &pvalue->pich_ForHsdschList,
            &p_tdd128->pich_for_hs_dsch_list);

    p_tdd128->dtch_dcch_reception_window_size =
        pvalue->dtch_DCCH_reception_window_size;

    if (pvalue->m.pcch_InformationListPresent)
    {
        p_tdd128->presence_bitmask |=
            UMTS_SIB_HS_DSCH_PAGING_SYSTEM_INFORMATION_TDD128_PCCH_INFORMATION_LIST_PRESENCE_FLAG;

        convert_pcch_information_list(
                &pvalue->pcch_InformationList,
                &p_tdd128->pcch_information_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v860ext_ies_mode_specific_info_tdd128_hs_dsch_common_sys_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v860ext_IEs_modeSpecificInfo_tdd128_hs_dsch_CommonSysInfo to
 *      sysinfotype5_v860ext_ies_mode_specific_info_tdd128_hs_dsch_common_sys_info_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v860ext_ies_mode_specific_info_tdd128_hs_dsch_common_sys_info
(
 UMTS_SysInfoType5_v860ext_IEs_modeSpecificInfo_tdd128_hs_dsch_CommonSysInfo    *pvalue,
 sysinfotype5_v860ext_ies_mode_specific_info_tdd128_hs_dsch_common_sys_info_t   *p_info 
 )
{
    convert_hs_dsch_common_system_information_tdd128(
            &pvalue->hs_dsch_CommonSystemInformation,
            &p_info->hs_dsch_common_system_information);

    if (pvalue->m.hs_dsch_PagingSystemInformationPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V860EXT_IES_MODE_SPECIFIC_INFO_TDD128_HS_DSCH_COMMON_SYS_INFO_PAGING_SYSTEM_INFO_PRESENCE_FLAG;

        convert_hs_dsch_paging_system_information_tdd128(
                &pvalue->hs_dsch_PagingSystemInformation,
                &p_info->hs_dsch_paging_system_information); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_hs_dsch_drx_cell_fach_info_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_HS_DSCH_DrxCellfach_info_TDD128 to
 *      hs_dsch_drx_cell_fach_info_tdd128_t
 *
 *******************************************************************************/
void convert_hs_dsch_drx_cell_fach_info_tdd128
(
 UMTS_HS_DSCH_DrxCellfach_info_TDD128   *pvalue,
 hs_dsch_drx_cell_fach_info_tdd128_t    *p_tdd128 
 )
{
    p_tdd128->t_321 = pvalue->t_321;
    p_tdd128->hs_dsch_drx_cycle_fach = pvalue->hs_dsch_DrxCycleFach;
    p_tdd128->hs_dsch_drx_burst_fach = pvalue->hs_dsch_DrxBurstFach;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v860ext_ies_mode_specific_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v860ext_IEs_modeSpecificInfo to
 *      sysinfotype5_v860ext_ies_mode_specific_info_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v860ext_ies_mode_specific_info
(
 UMTS_SysInfoType5_v860ext_IEs_modeSpecificInfo     *pvalue,
 sysinfotype5_v860ext_ies_mode_specific_info_t      *p_info
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_SysInfoType5_v860ext_IEs_modeSpecificInfo_fdd)
    {
        if (pvalue->u.fdd->m.hs_dsch_DrxCellfach_infoPresent)    
        {
            p_info->u.fdd.presence_bitmask |=
                UMTS_SIB_SYSINFOTYPE5_V860EXT_IES_MODE_SPECIFIC_INFO_FDD_HS_DSCH_DRX_CELL_FACH_INFO_PRESENCE_FLAG;

            convert_hs_dsch_drx_cell_fach_info(
                    &pvalue->u.fdd->hs_dsch_DrxCellfach_info,
                    &p_info->u.fdd.hs_dsch_drx_cell_fach_info);
        }
    }
    else if (pvalue->t == T_UMTS_SysInfoType5_v860ext_IEs_modeSpecificInfo_tdd128)
    {
        if (pvalue->u.tdd128->m.hs_dsch_CommonSysInfoPresent)
        {
            p_info->u.tdd128.presence_bitmask |=
                UMTS_SIB_SYSINFOTYPE5_V860EXT_IES_MODE_SPECIFIC_INFO_TDD128_HS_DSCH_COMMON_SYS_INFO_PRESENCE_FLAG;

            convert_sysinfotype5_v860ext_ies_mode_specific_info_tdd128_hs_dsch_common_sys_info(
                    &pvalue->u.tdd128->hs_dsch_CommonSysInfo,
                    &p_info->u.tdd128.hs_dsch_common_sys_info); 
        }

        if (pvalue->u.tdd128->m.hs_dsch_DrxCellfach_infoPresent)
        {
            p_info->u.tdd128.presence_bitmask |=
                UMTS_SIB_SYSINFOTYPE5_V860EXT_IES_MODE_SPECIFIC_INFO_TDD128_HS_DSCH_DRX_CELL_FACH_INFO_PRESENCE_FLAG;

            convert_hs_dsch_drx_cell_fach_info_tdd128(
                    &pvalue->u.tdd128->hs_dsch_DrxCellfach_info,
                    &p_info->u.tdd128.hs_dsch_drx_cell_fach_info);
        }
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v860ext_ies
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v860ext_IEs to
 *      sysinfotype5_v860ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v860ext_ies
(
 UMTS_SysInfoType5_v860ext_IEs  *pvalue,
 sysinfotype5_v860ext_ies_t     *p_ies 
 )
{
    if (pvalue->m.dummyPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V860EXT_IES_DUMMY_PRESENCE_FLAG;

        convert_sysinfotype5_v860ext_ies_dummy(
                &pvalue->dummy,
                &p_ies->dummy);
    }

    convert_sysinfotype5_v860ext_ies_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_ies->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_e_dch_mac_d_flow_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_Common_E_DCH_MAC_d_FlowList to
 *      common_e_dch_mac_d_flow_list_t
 *
 *******************************************************************************/
void convert_common_e_dch_mac_d_flow_list
(
 UMTS_Common_E_DCH_MAC_d_FlowList   *pvalue,
 common_e_dch_mac_d_flow_list_t     *p_list 
 )
{
    UMTS_Common_E_DCH_MAC_d_Flow    *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_Common_E_DCH_MAC_d_Flow*)pnode->data;

        p_list->common_e_dch_mac_d_flow[index].mac_d_flow_identity =
            pdata->mac_d_FlowIdentity;

        p_list->common_e_dch_mac_d_flow[index].mac_d_flow_power_offset =
            pdata->mac_d_FlowPowerOffset;

        p_list->common_e_dch_mac_d_flow[index].mac_d_flow_max_retrans = 
            pdata->mac_d_FlowMaxRetrans;

        if (pdata->m.mac_d_FlowMultiplexingListPresent)
        {
            p_list->common_e_dch_mac_d_flow[index].presence_bitmask |=
                UMTS_SIB_COMMON_E_DCH_MAC_D_FLOW_MAC_D_FLOW_MULTIPLEXING_LIST_PRESENCE_FLAG;

            convert_umts1_bit_str32(
                    &pdata->mac_d_FlowMultiplexingList,
                    &p_list->common_e_dch_mac_d_flow[index].mac_d_flow_multiplexing_list);
        }

        if (pdata->m.e_dch_mac_d_flow_retransmission_timerPresent)
        {
            p_list->common_e_dch_mac_d_flow[index].presence_bitmask |=
                UMTS_SIB_COMMON_E_DCH_MAC_D_FLOW_E_DCH_MAC_D_FLOW_RETRANSMISSION_TIMER_PRESENCE_FLAG;

            p_list->common_e_dch_mac_d_flow[index].e_dch_mac_d_flow_retransmission_timer =
                pdata->e_dch_mac_d_flow_retransmission_timer;
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_rucch_access_service_class
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_RUCCH_AccessServiceClass to
 *      e_rucch_access_service_class_t
 *
 *******************************************************************************/
void convert_e_rucch_access_service_class
(
 UMTS_E_RUCCH_AccessServiceClass    *pvalue,
 e_rucch_access_service_class_t     *p_class
 )
{
    UMTS_ASCSetting_TDD_LCR_r4  *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_class->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_ASCSetting_TDD_LCR_r4*)pnode->data;

        convert_asc_setting_tdd_lcr_r4(
                pdata,
                &p_class->ascsetting_tdd_lcr_r4[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_persistence_scaling_factor_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PersistenceScalingFactorList to
 *      persistence_scaling_factor_list_t
 *
 *******************************************************************************/
void convert_persistence_scaling_factor_list
(
 UMTS_PersistenceScalingFactorList  *pvalue,
 persistence_scaling_factor_list_t  *p_list 
 )
{
    p_list->n = pvalue->n;

    memcpy(&p_list->elem,
            &pvalue->elem, sizeof(U32)*p_list->n);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sync_ul_info_for_e_rucch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SYNC_UL_InfoForE_RUCCH to
 *      sync_ul_info_for_e_rucch_t
 *
 *******************************************************************************/
void convert_sync_ul_info_for_e_rucch
(
 UMTS_SYNC_UL_InfoForE_RUCCH    *pvalue,
 sync_ul_info_for_e_rucch_t     *p_info
 )
{
    if (pvalue->m.prxUpPCHdesPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_SYNC_UL_INFO_FOR_E_RUCCH_PRX_UP_PCH_DES_PRESENCE_FLAG;

        p_info->prx_up_pch_des = pvalue->prxUpPCHdes;
    }
    if (pvalue->m.powerRampStepPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_SYNC_UL_INFO_FOR_E_RUCCH_POWER_RAMP_STEP_PRESENCE_FLAG;

        p_info->power_ramp_step = pvalue->powerRampStep;
    }
    if (pvalue->m.max_SYNC_UL_TransmissionsPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_SYNC_UL_INFO_FOR_E_RUCCH_MAX_SYNC_UL_TRANSMISSIONS_PRESENCE_FLAG;

        p_info->max_sync_ul_transmissions = pvalue->max_SYNC_UL_Transmissions;
    }

    convert_sync_ul_codes_bitmap(
            &pvalue->e_RUCCH_Sync_UL_Codes_Bitmap,
            &p_info->sync_ul_codes_bitmap);

    p_info->mmax = pvalue->mmax;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_chan_codes_list_lcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_ChanCodes_List_LCR to
 *      prach_chan_codes_list_lcr_t
 *
 *******************************************************************************/
void convert_prach_chan_codes_list_lcr
(
 UMTS_PRACH_ChanCodes_List_LCR  *pvalue,
 prach_chan_codes_list_lcr_t    *p_lcr
 )
{
    p_lcr->n = pvalue->n;

    memcpy(&p_lcr->elem,
            &pvalue->elem,
            sizeof(U32)*p_lcr->n);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_information_lcr_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_Information_LCR_List to
 *      prach_information_lcr_list_t
 *
 *******************************************************************************/
void convert_prach_information_lcr_list
(
 UMTS_PRACH_Information_LCR_List    *pvalue,
 prach_information_lcr_list_t       *p_list
 )
{
    UMTS_PRACH_Information_LCR  *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PRACH_Information_LCR*)pnode->data;

        p_list->prach_information_lcr[index].timeslot =
            pdata->timeslot;

        convert_prach_chan_codes_list_lcr(
                &pdata->prach_ChanCodes_list_LCR,
                &p_list->prach_information_lcr[index].prach_chan_codes_list_lcr);

        convert_midamble_shift_and_burst_type_lcr_r4(
                &pdata->midambleShiftAndBurstType,
                &p_list->prach_information_lcr[index].midamble_shift_and_burst_type);

        if (pdata->m.fpach_InfoPresent)
        {
            p_list->prach_information_lcr[index].presence_bitmask |=
                UMTS_SIB_PRACH_INFORMATION_LCR_FPACH_INFO_PRESENCE_FLAG;

            convert_fpach_info_r4(
                    &pdata->fpach_Info,
                    &p_list->prach_information_lcr[index].fpach_info);
        }

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_rucch_info_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_RUCCH_Info_TDD128 to
 *      e_rucch_info_tdd128_t
 *
 *******************************************************************************/
void convert_e_rucch_info_tdd128
(
 UMTS_E_RUCCH_Info_TDD128   *pvalue,
 e_rucch_info_tdd128_t      *p_info 
 )
{
    if (pvalue->m.t_RUCCHPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_T_RUCCH_PRESENCE_FLAG;

        p_info->t_rucch = pvalue->t_RUCCH;
    }

    if (pvalue->m.n_RUCCHPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_N_RUCCH_PRESENCE_FLAG;

        p_info->n_rucch = pvalue->n_RUCCH;
    }

    if (pvalue->m.t_WAITPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_T_WAIT_PRESENCE_FLAG;

        p_info->t_wait = pvalue->t_WAIT;
    }

    if (pvalue->m.t_SIPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_T_SI_PRESENCE_FLAG;

        p_info->t_si = pvalue->t_SI;    
    }

    if (pvalue->m.extendedEstimationWindowPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_EXTENDED_ESTIMATION_WINDOW_PRESENCE_FLAG;

        p_info->extended_estimation_window = pvalue->extendedEstimationWindow;
    }

    if (pvalue->m.e_RUCCH_AccessServiceClassPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_E_RUCCH_ACCESS_SERVICE_CLASS_PRESENCE_FLAG;

        convert_e_rucch_access_service_class(
                &pvalue->e_RUCCH_AccessServiceClass,
                &p_info->e_rucch_access_service_class); 
    }

    if (pvalue->m.e_RUCCH_PersistenceScalingFactorPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_PERSISTENCE_SCALING_FACTOR_LIST_PRESENCE_FLAG;

        convert_persistence_scaling_factor_list(
                &pvalue->e_RUCCH_PersistenceScalingFactor,
                &p_info->persistence_scaling_factor_list); 
    }

    if (pvalue->m.sync_UL_InfoForE_RUCCHPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_SYNC_UL_INFO_FOR_E_RUCCH_PRESENCE_FLAG;

        convert_sync_ul_info_for_e_rucch(
                &pvalue->sync_UL_InfoForE_RUCCH,
                &p_info->sync_ul_info_for_e_rucch);
    }

    if (pvalue->m.prach_informationPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RUCCH_INFO_TDD128_PRACH_INFORMATION_LCR_LIST_PRESENCE_FLAG;

        convert_prach_information_lcr_list(
                &pvalue->prach_information,
                &p_info->prach_information_lcr_list);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_tfcs_info_reference_beta_qpsk_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_TFCS_Info_reference_Beta_QPSK_List to
 *      e_tfcs_info_reference_beta_qpsk_list_t
 *
 *******************************************************************************/
void convert_e_tfcs_info_reference_beta_qpsk_list
(
 UMTS_E_TFCS_Info_reference_Beta_QPSK_List  *pvalue,
 e_tfcs_info_reference_beta_qpsk_list_t     *p_list 
 )
{
    UMTS_Reference_Beta_QPSK    *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_Reference_Beta_QPSK*)pnode->data;

        p_list->reference_beta_qpsk[index].reference_code_rate =
            pdata->reference_Code_Rate;

        p_list->reference_beta_qpsk[index].reference_beta =
            pdata->reference_Beta;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_tfcs_info_reference_beta_16qam_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_TFCS_Info_reference_Beta_16QAM_List to
 *      e_tfcs_info_reference_beta_16qam_list_t
 *
 *******************************************************************************/
void convert_e_tfcs_info_reference_beta_16qam_list
(
 UMTS_E_TFCS_Info_reference_Beta_16QAM_List *pvalue,
 e_tfcs_info_reference_beta_16qam_list_t    *p_list 
 )
{
    UMTS_Reference_Beta_16QAM   *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_Reference_Beta_16QAM*)pnode->data;

        p_list->reference_beta_16qam[index].reference_code_rate =
            pdata->reference_Code_Rate;

        p_list->reference_beta_16qam[index].reference_beta =
            pdata->reference_Beta;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_tfcs_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_TFCS_Info to
 *      e_tfcs_info_t
 *
 *******************************************************************************/
void convert_e_tfcs_info
(
 UMTS_E_TFCS_Info   *pvalue,
 e_tfcs_info_t      *p_info 
 )
{
    convert_e_tfcs_info_reference_beta_qpsk_list(
            &pvalue->reference_Beta_QPSK_List,
            &p_info->info_reference_beta_qpsk_list);

    convert_e_tfcs_info_reference_beta_16qam_list(
            &pvalue->reference_Beta_16QAM_List,
            &p_info->info_reference_beta_16qam_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ul_synchronisation_parameters_r4
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UL_SynchronisationParameters_r4 to
 *      ul_synchronisation_parameters_r4_t
 *
 *******************************************************************************/
void convert_ul_synchronisation_parameters_r4
(
 UMTS_UL_SynchronisationParameters_r4   *pvalue,
 ul_synchronisation_parameters_r4_t     *p_r4 
 )
{
    p_r4->step_size = pvalue->stepSize;
    p_r4->frequency = pvalue->frequency;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_puch_ts_slots_lcr_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_PUCH_TS_Slots_LCR_midambleAllocationMode to
 *      e_puch_ts_slots_lcr_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_e_puch_ts_slots_lcr_midamble_allocation_mode
(
 UMTS_E_PUCH_TS_Slots_LCR_midambleAllocationMode    *pvalue,
 e_puch_ts_slots_lcr_midamble_allocation_mode_t     *p_mode
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_E_PUCH_TS_Slots_LCR_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_E_PUCH_TS_Slots_LCR_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble = pvalue->u.ueSpecificMidamble;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_puch_info_tdd128_e_puch_ts_configuration_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_PUCH_Info_TDD128_e_PUCH_TS_ConfigurationList to
 *      e_puch_info_tdd128_e_puch_ts_configuration_list_t
 *
 *******************************************************************************/
void convert_e_puch_info_tdd128_e_puch_ts_configuration_list
(
 UMTS_E_PUCH_Info_TDD128_e_PUCH_TS_ConfigurationList    *pvalue,
 e_puch_info_tdd128_e_puch_ts_configuration_list_t      *p_list 
 )
{
    UMTS_E_PUCH_TS_Slots_LCR    *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_E_PUCH_TS_Slots_LCR*)pnode->data;

        p_list->e_puch_ts_slots_lcr[index].timeslot_number =
            pdata->timeslotNumber;

        convert_e_puch_ts_slots_lcr_midamble_allocation_mode(
                &pdata->midambleAllocationMode,
                &p_list->e_puch_ts_slots_lcr[index].midamble_allocation_mode);

        p_list->e_puch_ts_slots_lcr[index].midamble_configuration =
            pdata->midambleConfiguration;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_puch_info_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_PUCH_Info_TDD128 to
 *      e_puch_info_tdd128_t
 *
 *******************************************************************************/
void convert_e_puch_info_tdd128
(
 UMTS_E_PUCH_Info_TDD128    *pvalue,
 e_puch_info_tdd128_t       *p_info
 )
{
    convert_e_tfcs_info(
            &pvalue->e_TFCS_Info,
            &p_info->e_tfcs_info);

    if (pvalue->m.snpl_ReportTypePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_PUCH_INFO_TDD128_SNPL_REPORT_TYPE_PRESENCE_FLAG;

        p_info->snpl_report_type =
            pvalue->snpl_ReportType;
    }

    p_info->prx_base_des = pvalue->prxBASEdes;

    if (pvalue->m.beaconPLEstPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_PUCH_INFO_TDD128_BEACON_PLE_ST_PRESENCE_FLAG;

        p_info->beacon_ple_st = pvalue->beaconPLEst;
    }

    p_info->tpc_stepsize = pvalue->tpc_StepSize;

    if (pvalue->m.pebase_PowerControlGAPPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_PUCH_INFO_TDD128_PEBASE_POWER_CONTROL_GAP_PRESENCE_FLAG;

        p_info->pebase_power_control_gap = pvalue->pebase_PowerControlGAP;
    }

    if (pvalue->m.ul_SynchronisationParametersPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_PUCH_INFO_TDD128_UL_SYNCHRONISATION_PARAMETERS_R4_PRESENCE_FLAG;

        convert_ul_synchronisation_parameters_r4(
                &pvalue->ul_SynchronisationParameters,
                &p_info->ul_synchronisation_parameters_r4);
    }

    convert_e_puch_info_tdd128_e_puch_ts_configuration_list(
            &pvalue->e_PUCH_TS_ConfigurationList,
            &p_info->e_puch_ts_configuration_list);

    p_info->minimum_allowed_code_rate = pvalue->minimum_Allowed_Code_Rate;
    p_info->maximum_allowed_code_rate = pvalue->maximum_Allowed_Code_Rate;
    p_info->maximum_num_of_retrans_sched_info = pvalue->maximumNumOfRetransSchedInfo;
    p_info->retrans_timer_for_sched_info = pvalue->retransTimerForSchedInfo;

    if (pvalue->m.dummyPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_PUCH_INFO_TDD128_DUMMY_PRESENCE_FLAG;

        p_info->dummy = pvalue->dummy;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_hich_information_lcr_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_HICH_Information_LCR_midambleAllocationMode to
 *      e_hich_information_lcr_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_e_hich_information_lcr_midamble_allocation_mode
(
 UMTS_E_HICH_Information_LCR_midambleAllocationMode *pvalue,
 e_hich_information_lcr_midamble_allocation_mode_t  *p_mode
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_E_HICH_Information_LCR_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_E_HICH_Information_LCR_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble = pvalue->u.ueSpecificMidamble;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_hich_information_lcr_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_HICH_Information_LCR_List to
 *      e_hich_information_lcr_list_t
 *
 *******************************************************************************/
void convert_e_hich_information_lcr_list
(
 UMTS_E_HICH_Information_LCR_List   *pvalue,
 e_hich_information_lcr_list_t      *p_list
 )
{
    UMTS_E_HICH_Information_LCR *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_E_HICH_Information_LCR*)pnode->data;

        p_list->e_hich_information_lcr[index].ei =
            pdata->ei;

        p_list->e_hich_information_lcr[index].timeslot_number =
            pdata->timeslotNumber;

        p_list->e_hich_information_lcr[index].channelisation_code =
            pdata->channelisation_Code;

        convert_e_hich_information_lcr_midamble_allocation_mode(
                &pdata->midambleAllocationMode,
                &p_list->e_hich_information_lcr[index].midamble_allocation_mode);

        p_list->e_hich_information_lcr[index].midamble_configuration =
            pdata->midambleConfiguration;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_hich_information_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_HICH_Information_TDD128 to
 *      e_hich_information_tdd128_t
 *
 *******************************************************************************/
void convert_e_hich_information_tdd128
(
 UMTS_E_HICH_Information_TDD128     *pvalue,
 e_hich_information_tdd128_t        *p_info 
 )
{
    p_info->n_e_hich = pvalue->n_E_HICH;

    convert_e_hich_information_lcr_list(
            &pvalue->e_HICH_InfoList,
            &p_info->e_hich_information_lcr_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_agch_individual_lcr_midamble_allocation_mode
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_AGCH_Individual_LCR_midambleAllocationMode to
 *      e_agch_individual_lcr_midamble_allocation_mode_t
 *
 *******************************************************************************/
void convert_e_agch_individual_lcr_midamble_allocation_mode
(
 UMTS_E_AGCH_Individual_LCR_midambleAllocationMode  *pvalue,
 e_agch_individual_lcr_midamble_allocation_mode_t   *p_mode 
 )
{
    p_mode->t = pvalue->t;

    if (pvalue->t == T_UMTS_E_AGCH_Individual_LCR_midambleAllocationMode_defaultMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_E_AGCH_Individual_LCR_midambleAllocationMode_commonMidamble)
    {
        /* for future use */
    }
    else if (pvalue->t == T_UMTS_E_AGCH_Individual_LCR_midambleAllocationMode_ueSpecificMidamble)
    {
        p_mode->u.ue_specific_midamble = pvalue->u.ueSpecificMidamble; 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_agch_set_config_lcr
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_AGCH_Set_Config_LCR to
 *      e_agch_set_config_lcr_t
 *
 *******************************************************************************/
void convert_e_agch_set_config_lcr
(
 UMTS_E_AGCH_Set_Config_LCR *pvalue,
 e_agch_set_config_lcr_t    *p_lcr
 )
{
    UMTS_E_AGCH_Individual_LCR  *pdata = NULL;
    OSRTDListNode               *pnode = NULL;
    U32                         index;

    pnode = pvalue->head;
    p_lcr->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_E_AGCH_Individual_LCR*)pnode->data;

        p_lcr->e_agch_individual_lcr[index].timeslot_number =
            pdata->timeslotNumber;

        p_lcr->e_agch_individual_lcr[index].first_channelisation_code =
            pdata->firstChannelisationCode;

        p_lcr->e_agch_individual_lcr[index].second_channelisation_code =
            pdata->secondChannelisationCode;

        convert_e_agch_individual_lcr_midamble_allocation_mode(
                &pdata->midambleAllocationMode,
                &p_lcr->e_agch_individual_lcr[index].midamble_allocation_mode);

        p_lcr->e_agch_individual_lcr[index].midamble_configuration =
            pdata->midambleConfiguration;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_agch_information_tdd128
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_AGCH_Information_TDD128 to
 *      e_agch_information_tdd128_t
 *
 *******************************************************************************/
void convert_e_agch_information_tdd128
(
 UMTS_E_AGCH_Information_TDD128 *pvalue,
 e_agch_information_tdd128_t    *p_tdd128 
 )
{
    p_tdd128->rdi_indicator = pvalue->rdi_Indicator;
    p_tdd128->tpc_step_size = pvalue->tpc_StepSize;

    convert_e_agch_set_config_lcr(
            &pvalue->e_AGCH_Set_Config,
            &p_tdd128->e_agch_set_config_lcr);

    memcpy(&p_tdd128->e_agch_bler_target,
            &pvalue->e_AGCH_BLER_Target,
            sizeof(S8));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_e_rnti_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_Common_E_RNTI_Info to
 *      common_e_rnti_info_t
 *
 *******************************************************************************/
void convert_common_e_rnti_info
(
 UMTS_Common_E_RNTI_Info    *pvalue,
 common_e_rnti_info_t       *p_info 
 )
{
    UMTS_Common_E_RNTI_Info_element *pdata = NULL;
    OSRTDListNode                   *pnode = NULL;
    U32                             index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_Common_E_RNTI_Info_element*)pnode->data;

        convert_umts1_bit_str32(
                &pdata->starting_E_RNTI,
                &p_info->common_e_rnti_info_element[index].starting_e_rnti);

        p_info->common_e_rnti_info_element[index].number_of_group =
            pdata->number_of_group;

        p_info->common_e_rnti_info_element[index].number_of_enrti_per_group =
            pdata->number_of_ENRTI_per_group;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_edch_system_info_mode_specific_info_tdd_tdd128_ccch_transmission_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonEDCHSystemInfo_modeSpecificInfo_tdd_tdd128_ccch_transmission_Info to
 *      common_edch_system_info_mode_specific_info_tdd_tdd128_ccch_transmission_info_t
 *
 *******************************************************************************/
void convert_common_edch_system_info_mode_specific_info_tdd_tdd128_ccch_transmission_info
(
 UMTS_CommonEDCHSystemInfo_modeSpecificInfo_tdd_tdd128_ccch_transmission_Info   *pvalue,
 common_edch_system_info_mode_specific_info_tdd_tdd128_ccch_transmission_info_t *p_info 
 )
{
    convert_common_e_rnti_info(
            &pvalue->common_e_rnti_Info,
            &p_info->common_e_rnti_info);

    p_info->harq_maximum_number_of_retransmissions =
        pvalue->harq_MaximumNumberOfRetransmissions;

    p_info->harq_retransmission_timer =
        pvalue->harq_retransmission_timer;

    p_info->harq_power_offset =
        pvalue->harq_power_offset;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_edch_system_info_mode_specific_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonEDCHSystemInfo_modeSpecificInfo to
 *      common_edch_system_info_mode_specific_info_t
 *
 *******************************************************************************/
void convert_common_edch_system_info_mode_specific_info
(
 UMTS_CommonEDCHSystemInfo_modeSpecificInfo     *pvalue,
 common_edch_system_info_mode_specific_info_t   *p_info 
 )
{
    p_info->t = pvalue->t;

    if (pvalue->t == T_UMTS_CommonEDCHSystemInfo_modeSpecificInfo_dummy)
    {
        p_info->u.dummy.__dummy__ =
            pvalue->u.dummy->__dummy__; 
    }
    else if (pvalue->t == T_UMTS_CommonEDCHSystemInfo_modeSpecificInfo_tdd)
    {
        p_info->u.tdd.t = pvalue->u.tdd->t;

        if (pvalue->u.tdd->t == T_UMTS_CommonEDCHSystemInfo_modeSpecificInfo_tdd_tdd768)
        {
            /* for future use */ 
        }
        else if (pvalue->u.tdd->t == T_UMTS_CommonEDCHSystemInfo_modeSpecificInfo_tdd_tdd384)
        {
            /* for future use */ 
        }
        else if (pvalue->u.tdd->t == T_UMTS_CommonEDCHSystemInfo_modeSpecificInfo_tdd_tdd128)
        {
            convert_e_rucch_info_tdd128(
                    &pvalue->u.tdd->u.tdd128->e_RUCCH_Info,
                    &p_info->u.tdd.u.tdd128.e_rucch_info);

            convert_e_puch_info_tdd128(
                    &pvalue->u.tdd->u.tdd128->e_PUCH_Info,
                    &p_info->u.tdd.u.tdd128.e_puch_info);

            convert_e_hich_information_tdd128(
                    &pvalue->u.tdd->u.tdd128->e_hich_Information,
                    &p_info->u.tdd.u.tdd128.e_hich_information);

            convert_e_agch_information_tdd128(
                    &pvalue->u.tdd->u.tdd128->e_agch_Information,
                    &p_info->u.tdd.u.tdd128.e_agch_information);

            p_info->u.tdd.u.tdd128.harq_info =
                pvalue->u.tdd->u.tdd128->harq_Info;

            convert_common_edch_system_info_mode_specific_info_tdd_tdd128_ccch_transmission_info(
                    &pvalue->u.tdd->u.tdd128->ccch_transmission_Info,
                    &p_info->u.tdd.u.tdd128.ccch_transmission_info);
        }
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_edch_system_info
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonEDCHSystemInfo to
 *      common_edch_system_info_t
 *
 *******************************************************************************/
void convert_common_edch_system_info
(
 UMTS_CommonEDCHSystemInfo  *pvalue,
 common_edch_system_info_t  *p_info 
 )
{
    if (pvalue->m.ul_InterferenceForCommonEDCHPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_COMMON_EDCH_SYSTEM_INFO_UL_INTERFERENCE_FOR_COMMON_EDCH_PRESENCE_FLAG;

        memcpy(&p_info->ul_interference_for_common_edch,
                &pvalue->ul_InterferenceForCommonEDCH,
                sizeof(S8));
    }

    convert_common_e_dch_mac_d_flow_list(
            &pvalue->common_E_DCH_MAC_d_FlowList,
            &p_info->common_e_dch_mac_d_flow_list);

    convert_common_edch_system_info_mode_specific_info(
            &pvalue->modeSpecificInfo,
            &p_info->mode_specific_info);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v890ext_ies
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v890ext_IEs to
 *      sysinfotype5_v890ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v890ext_ies
(
 UMTS_SysInfoType5_v890ext_IEs  *pvalue,
 sysinfotype5_v890ext_ies_t     *p_ies 
 )
{
    if (pvalue->m.secondFrequencyInfoPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V890EXT_IES_SECOND_FREQUENCY_INFO_PRESENCE_FLAG;

        convert_frequency_info_tdd(
                &pvalue->secondFrequencyInfo,
                &p_ies->second_frequency_info);
    }

    if (pvalue->m.commonEDCHSystemInfoPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V890EXT_IES_COMMON_EDCH_SYSTEM_INFO_PRESENCE_FLAG;

        convert_common_edch_system_info(
                &pvalue->commonEDCHSystemInfo,
                &p_ies->common_edch_system_info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v8b0ext_ies
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v8b0ext_IEs to
 *      sysinfotype5_v8b0ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v8b0ext_ies
(
 UMTS_SysInfoType5_v8b0ext_IEs  *pvalue,
 sysinfotype5_v8b0ext_ies_t     *p_ies 
 )
{
    if (pvalue->m.tresetUsageIndicatorPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V8B0EXT_IES_TRESET_USAGE_INDICATOR_PRESENCE_FLAG; 

        p_ies->treset_usage_indicator = pvalue->tresetUsageIndicator;
    }

    if (pvalue->m.upPCHpositionInfoPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V8B0EXT_IES_UP_PCH_POSITION_INFO_PRESENCE_FLAG;

        p_ies->up_pch_position_info = pvalue->upPCHpositionInfo;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_available_sub_channel_numbers
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_AvailableSubChannelNumbers to
 *      available_sub_channel_numbers_t
 *
 *******************************************************************************/
void convert_available_sub_channel_numbers
(
 UMTS_AvailableSubChannelNumbers    *pvalue,
 available_sub_channel_numbers_t    *p_numbers 
 )
{
    p_numbers->numbits = pvalue->numbits;

    memcpy(&p_numbers->data,
            pvalue->data,
            sizeof(U8)*p_numbers->numbits);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_power_offset
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_PowerOffset to
 *      prach_power_offset_t
 *
 *******************************************************************************/
void convert_prach_power_offset
(
 UMTS_PRACH_PowerOffset *pvalue,
 prach_power_offset_t   *p_offset 
 )
{
    p_offset->power_ramp_step = pvalue->powerRampStep;
    p_offset->preamble_retrans_max = pvalue->preambleRetransMax;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_prach_preamble_for_enhanced_uplink
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PRACH_PreambleForEnhancedUplink to
 *      prach_preamble_for_enhanced_uplink_t
 *
 *******************************************************************************/
void convert_prach_preamble_for_enhanced_uplink
(
 UMTS_PRACH_PreambleForEnhancedUplink   *pvalue,
 prach_preamble_for_enhanced_uplink_t   *p_info
 )
{
    if (pvalue->m.availableSignaturesPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_AVAILABLE_SIGNATURES_PRESENCE_FLAG;

        convert_available_signatures(
                &pvalue->availableSignatures,
                &p_info->available_signatures);
    }

    p_info->e_ai_indication = pvalue->e_ai_Indication;

    if (pvalue->m.preambleScramblingCodeWordNumberPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_PREAMBLE_SCRAMBLING_CODE_WORD_NUMBER_PRESENCE_FLAG;

        p_info->preamble_scrambling_code_word_number =
            pvalue->preambleScramblingCodeWordNumber;
    }

    if (pvalue->m.availableSubChannelNumbersPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_AVAILABLE_SUB_CHANNEL_NUMBERS_PRESENCE_FLAG;

        convert_available_sub_channel_numbers(
                &pvalue->availableSubChannelNumbers,
                &p_info->available_sub_channel_numbers);
    }

    if (pvalue->m.prach_PartitioningPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_PRACH_PARTITIONING_R7_PRESENCE_FLAG;

        convert_prach_partitioning_r7(
                &pvalue->prach_Partitioning,
                &p_info->prach_partitioning_r7);
    }

    if (pvalue->m.persistenceScalingFactorListPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_PERSISTENCE_SCALING_FACTOR_LIST_PRESENCE_FLAG;

        convert_persistence_scaling_factor_list(
                &pvalue->persistenceScalingFactorList,
                &p_info->persistence_scaling_factor_list);
    }

    if (pvalue->m.ac_To_ASC_MappingTablePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_AC_TO_ASC_MAPPING_TABLE_PRESENCE_FLAG;

        convert_ac_to_asc_mapping_table(
                &pvalue->ac_To_ASC_MappingTable,
                &p_info->ac_to_asc_mapping_table);
    }

    if (pvalue->m.primaryCPICH_TX_PowerPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_PRIMARY_CPICH_TX_POWER_PRESENCE_FLAG;

        memcpy(&p_info->primary_cpich_tx_power,
                &pvalue->primaryCPICH_TX_Power,
                sizeof(S8));
    }

    if (pvalue->m.constantValuePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_CONSTANT_VALUE_PRESENCE_FLAG;

        memcpy(&p_info->constant_value,
                &pvalue->constantValue,
                sizeof(S8));
    }

    if (pvalue->m.prach_PowerOffsetPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_PRACH_POWER_OFFSET_PRESENCE_FLAG;

        convert_prach_power_offset(
                &pvalue->prach_PowerOffset,
                &p_info->prach_power_offset);
    }

    if (pvalue->m.rach_TransmissionParametersPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_RACH_TRANSMISSION_PARAMETERS_PRESENCE_FLAG;

        convert_rach_transmission_parameters(
                &pvalue->rach_TransmissionParameters,
                &p_info->rach_transmission_parameters);
    }

    if (pvalue->m.aich_InfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PRACH_PREAMBLE_FOR_ENHANCED_UPLINK_AICH_INFO_PRESENCE_FLAG;

        convert_aich_info(
                &pvalue->aich_Info,
                &p_info->aich_info);
    }

    memcpy(&p_info->power_offset_pp_e,
            &pvalue->powerOffsetPp_e,
            sizeof(S8));

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_agch_information
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_AGCH_Information to
 *      e_agch_information_t
 *
 *******************************************************************************/
void convert_e_agch_information
(
 UMTS_E_AGCH_Information    *pvalue,
 e_agch_information_t       *p_info 
 )
{
    p_info->e_agch_channelisation_code =
        pvalue->e_AGCH_ChannelisationCode;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_power_control_algorithm
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PowerControlAlgorithm to
 *      power_control_algorithm_t
 *
 *******************************************************************************/
void convert_power_control_algorithm
(
 UMTS_PowerControlAlgorithm *pvalue,
 power_control_algorithm_t  *p_algorithm 
 )
{
    p_algorithm->t = pvalue->t;

    if (pvalue->t == T_UMTS_PowerControlAlgorithm_algorithm1)
    {
        p_algorithm->u.algorithm1 = pvalue->u.algorithm1;
    }
    else if (pvalue->t == T_UMTS_PowerControlAlgorithm_algorithm2)
    {
        /* for future use */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ul_dpch_power_control_info_for_common_edch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UL_DPCHpowerControlInfoForCommonEDCH to
 *      ul_dpch_power_control_info_for_common_edch_t
 *
 *******************************************************************************/
void convert_ul_dpch_power_control_info_for_common_edch
(
 UMTS_UL_DPCHpowerControlInfoForCommonEDCH      *pvalue,
 ul_dpch_power_control_info_for_common_edch_t   *p_info 
 )
{
    convert_power_control_algorithm(
            &pvalue->powerControlAlgorithm,
            &p_info->power_control_algorithm);

    if (pvalue->m.deltaACKPresent)
    {
        p_info->presence_bitmask |=
            UL_DPCH_POWER_CONTROL_INFO_FOR_COMMON_EDCH_DELTA_ACK_PRESENCE_FLAG;

        p_info->delta_ack = pvalue->deltaACK;    
    }

    if (pvalue->m.deltaNACKPresent)
    {
        p_info->presence_bitmask |=
            UL_DPCH_POWER_CONTROL_INFO_FOR_COMMON_EDCH_DELTA_NACK_PRESENCE_FLAG;

        p_info->delta_nack = pvalue->deltaNACK; 
    }

    if (pvalue->m.ack_NACK_repetition_factorPresent)
    {
        p_info->presence_bitmask |=
            UL_DPCH_POWER_CONTROL_INFO_FOR_COMMON_EDCH_ACK_NACK_REPETITION_FACTOR_PRESENCE_FLAG;

        p_info->ack_nack_repetition_factor = pvalue->ack_NACK_repetition_factor;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_tfc_boost_info_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_TFC_Boost_Info_r7 to
 *      e_tfc_boost_info_r7_t
 *
 *******************************************************************************/
void convert_e_tfc_boost_info_r7
(
 UMTS_E_TFC_Boost_Info_r7   *pvalue,
 e_tfc_boost_info_r7_t      *p_info
 )
{
    p_info->e_tfci_boost = pvalue->e_TFCI_Boost;

    if (pvalue->m.delta_T2TPPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_TFC_BOOST_INFO_R7_DELTA_T2TP_PRESENCE_FLAG;

        p_info->delta_t2tp = pvalue->delta_T2TP;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_dpcch_info_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_DPCCH_Info_r7 to
 *      e_dpcch_info_r7_t
 *
 *******************************************************************************/
void convert_e_dpcch_info_r7
(
 UMTS_E_DPCCH_Info_r7   *pvalue,
 e_dpcch_info_r7_t      *p_info
 )
{
    p_info->e_dpcch_dpcch_power_offset = 
        pvalue->e_DPCCH_DPCCH_PowerOffset;

    p_info->happy_bit_delay_condition =
        pvalue->happyBit_DelayCondition;

    if (pvalue->m.e_TFC_Boost_InfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_DPCCH_INFO_R7_E_TFC_BOOST_INFO_PRESENCE_FLAG;

        convert_e_tfc_boost_info_r7(
                &pvalue->e_TFC_Boost_Info,
                &p_info->e_tfc_boost_info);
    }

    if (pvalue->m.e_DPDCH_PowerInterpolationPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_DPCCH_INFO_R7_E_DPDCH_POWER_INTERPOLATION_PRESENCE_FLAG;

        p_info->e_dpdch_power_interpolation =
            pvalue->e_DPDCH_PowerInterpolation;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_dpdch_reference_e_tfci_list_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_DPDCH_Reference_E_TFCIList_r7 to
 *      e_dpdch_reference_e_tfci_list_r7_t
 *
 *******************************************************************************/
void convert_e_dpdch_reference_e_tfci_list_r7
(
 UMTS_E_DPDCH_Reference_E_TFCIList_r7   *pvalue,
 e_dpdch_reference_e_tfci_list_r7_t     *p_r7 
 )
{
    UMTS_E_DPDCH_Reference_E_TFCI_r7    *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_r7->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_E_DPDCH_Reference_E_TFCI_r7*)pnode->data;

        p_r7->e_dpdch_reference_e_tfci_r7[index].reference_e_tfci =
            pdata->reference_E_TFCI;

        p_r7->e_dpdch_reference_e_tfci_r7[index].reference_e_tfci_po_r7 =
            pdata->reference_E_TFCI_PO_r7;

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_dpdch_scheduling_info_configuration
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_DPDCH_SchedulingInfoConfiguration to
 *      e_dpdch_scheduling_info_configuration_t
 *
 *******************************************************************************/
void convert_e_dpdch_scheduling_info_configuration
(
 UMTS_E_DPDCH_SchedulingInfoConfiguration   *pvalue,
 e_dpdch_scheduling_info_configuration_t    *p_conf
 )
{
    if (pvalue->m.periodicityOfSchedInfo_NoGrantPresent)
    {
        p_conf->presence_bitmask |=
            UMTS_SIB_E_DPDCH_SCHEDULING_INFO_CONFIGURATION_PERIODICITY_OF_SCHED_INFO_NO_GRANT_PRESENCE_FLAG;

        p_conf->periodicity_of_sched_info_no_grant = pvalue->periodicityOfSchedInfo_NoGrant;
    }

    if (pvalue->m.periodicityOfSchedInfo_GrantPresent)
    {
        p_conf->presence_bitmask |=
            UMTS_SIB_E_DPDCH_SCHEDULING_INFO_CONFIGURATION_PERIODICITY_OF_SCHED_INFO_GRANT_PRESENCE_FLAG;

        p_conf->periodicity_of_sched_info_grant = pvalue->periodicityOfSchedInfo_Grant;
    }

    p_conf->power_offset_for_sched_info = pvalue->powerOffsetForSchedInfo;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_dpdch_info_r8
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_DPDCH_Info_r8 to
 *      e_dpdch_info_r8_t
 *
 *******************************************************************************/
void convert_e_dpdch_info_r8
(
 UMTS_E_DPDCH_Info_r8   *pvalue,
 e_dpdch_info_r8_t      *p_info 
 )
{
    p_info->e_tfci_table_index = pvalue->e_TFCI_TableIndex;

    if (pvalue->m.e_DCH_MinimumSet_E_TFCIPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_DPDCH_INFO_R8_E_DCH_MINIMUM_SET_E_TFCI_PRESENCE_FLAG;

        p_info->e_dch_minimum_set_e_tfci = pvalue->e_DCH_MinimumSet_E_TFCI;
    }

    convert_e_dpdch_reference_e_tfci_list_r7(
            &pvalue->reference_E_TFCIs,
            &p_info->e_dpdch_reference_e_tfci_list);

    if (pvalue->m.minReduced_E_DPDCH_GainFactorPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_DPDCH_INFO_R8_MIN_REDUCED_E_DPDCH_GAIN_FACTOR_PRESENCE_FLAG;

        p_info->min_reduced_e_dpdch_gain_factor =
            pvalue->minReduced_E_DPDCH_GainFactor;
    }

    p_info->max_channelisation_codes =
        pvalue->maxChannelisationCodes;

    p_info->pl_non_max = pvalue->pl_NonMax;

    convert_e_dpdch_scheduling_info_configuration(
            &pvalue->schedulingInfoConfiguration,
            &p_info->e_dpdch_scheduling_info_configuration);

    if (pvalue->m.threeIndexStepThresholdPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_DPDCH_INFO_R8_THREE_INDEX_STEP_THRESHOLD_PRESENCE_FLAG;

        p_info->three_index_step_threshold = pvalue->threeIndexStepThreshold;
    }

    if (pvalue->m.twoIndexStepThresholdPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_DPDCH_INFO_R8_TWO_INDEX_STEP_THRESHOLD_PRESENCE_FLAG;

        p_info->two_index_step_threshold = pvalue->twoIndexStepThreshold;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_measurement_feedback_info_r7
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_Measurement_Feedback_Info_r7 to
 *      measurement_feedback_info_r7_t
 *
 *******************************************************************************/
void convert_measurement_feedback_info_r7
(
 UMTS_Measurement_Feedback_Info_r7  *pvalue,
 measurement_feedback_info_r7_t     *p_r7 
 )
{
    p_r7->mode_specific_info.t = pvalue->modeSpecificInfo.t;

    if (pvalue->modeSpecificInfo.t == T_UMTS_Measurement_Feedback_Info_r7_modeSpecificInfo_fdd)
    {
        memcpy(&p_r7->mode_specific_info.u.fdd.measurement_power_offset,
                &pvalue->modeSpecificInfo.u.fdd->measurementPowerOffset,
                sizeof(S8));

        p_r7->mode_specific_info.u.fdd.feedback_cycle =
            pvalue->modeSpecificInfo.u.fdd->feedback_cycle;

        p_r7->mode_specific_info.u.fdd.cqi_repetition_factor =
            pvalue->modeSpecificInfo.u.fdd->cqi_RepetitionFactor;

        p_r7->mode_specific_info.u.fdd.delta_cqi =
            pvalue->modeSpecificInfo.u.fdd->deltaCQI;
    }
    else if (pvalue->modeSpecificInfo.t == T_UMTS_Measurement_Feedback_Info_r7_modeSpecificInfo_tdd)
    {
        /* for future use */
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_hich_information_common_edch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_HICH_Information_CommonEdch to
 *      e_hich_information_common_edch_t
 *
 *******************************************************************************/
void convert_e_hich_information_common_edch
(
 UMTS_E_HICH_Information_CommonEdch *pvalue,
 e_hich_information_common_edch_t   *p_info 
 )
{
    if (pvalue->m.channelisationCodePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_HICH_INFORMATION_COMMON_EDCH_CHANNELISATION_CODE_PRESENCE_FLAG;

        p_info->channelisation_code =
            pvalue->channelisationCode;
    }

    if (pvalue->m.signatureSequencePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_HICH_INFORMATION_COMMON_EDCH_SIGNATURE_SEQUENCE_PRESENCE_FLAG;

        p_info->signature_sequence = pvalue->signatureSequence;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_e_rgch_information_common_edch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_E_RGCH_Information_CommonEdch to
 *      e_rgch_information_common_edch_t
 *
 *******************************************************************************/
void convert_e_rgch_information_common_edch
(
 UMTS_E_RGCH_Information_CommonEdch *pvalue,
 e_rgch_information_common_edch_t   *p_info 
 )
{
    if (pvalue->m.signatureSequencePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_E_RGCH_INFORMATION_COMMON_EDCH_PRESENCE_FLAG;

        p_info->signature_sequence = pvalue->signatureSequence;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_ul_dpch_code_info_for_common_edch
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_UL_DPCH_CodeInfoForCommonEDCH to
 *      ul_dpch_code_info_for_common_edch_t
 *
 *******************************************************************************/
void convert_ul_dpch_code_info_for_common_edch
(
 UMTS_UL_DPCH_CodeInfoForCommonEDCH     *pvalue,
 ul_dpch_code_info_for_common_edch_t    *p_info
 )
{
    p_info->ul_dpcch_scrambling_code_type =
        pvalue->ul_DPCCHscramblingCodeType;

    if (pvalue->m.ul_DPCCHscramblingCodePresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_UL_DPCH_CODE_INFO_FOR_COMMON_EDCH_UL_DPCCH_SCRAMBLING_CODE_PRESENCE_FLAG;

        p_info->ul_dpcch_scrambling_code = pvalue->ul_DPCCHscramblingCode;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_edch_system_info_fdd_common_e_dch_resource_info_list
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonEDCHSystemInfoFDD_common_E_DCH_ResourceInfoList to
 *      common_edch_system_info_fdd_common_e_dch_resource_info_list_t
 *
 *******************************************************************************/
void convert_common_edch_system_info_fdd_common_e_dch_resource_info_list
(
 UMTS_CommonEDCHSystemInfoFDD_common_E_DCH_ResourceInfoList     *pvalue,
 common_edch_system_info_fdd_common_e_dch_resource_info_list_t  *p_list
 )
{
    UMTS_Common_E_DCH_ResourceInfoList  *pdata = NULL;
    OSRTDListNode                       *pnode = NULL;
    U32                                 index;

    pnode = pvalue->head;
    p_list->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_Common_E_DCH_ResourceInfoList*)pnode->data;

        if (pdata->m.s_offsetPresent)
        {
            p_list->common_e_dch_resource_info_list[index].presence_bitmask |=
                UMTS_SIB_COMMON_E_DCH_RESOURCE_INFO_LIST_S_OFFSET_PRESENCE_FLAG;

            p_list->common_e_dch_resource_info_list[index].s_offset =
                pdata->s_offset;
        }

        if (pdata->m.f_dpch_ChannelisationCodeNumberPresent)
        {
            p_list->common_e_dch_resource_info_list[index].presence_bitmask |=
                UMTS_SIB_COMMON_E_DCH_RESOURCE_INFO_LIST_F_DPCH_CHANNELISATION_CODE_NUMBER_PRESENCE_FLAG;

            p_list->common_e_dch_resource_info_list[index].f_dpch_channelisation_code_number =
                pdata->f_dpch_ChannelisationCodeNumber;
        }

        if (pdata->m.e_RGCH_InformationPresent)
        {
            p_list->common_e_dch_resource_info_list[index].presence_bitmask |=
                UMTS_SIB_COMMON_E_DCH_RESOURCE_INFO_LIST_E_RGCH_INFORMATION_COMMON_EDCH_PRESENCE_FLAG;

            convert_e_rgch_information_common_edch(
                    &pdata->e_RGCH_Information,
                    &p_list->common_e_dch_resource_info_list[index].e_rgch_information_common_edch); 
        }

        convert_e_hich_information_common_edch(
                &pdata->e_hich_Info,
                &p_list->common_e_dch_resource_info_list[index].e_hich_information_common_edch);

        convert_ul_dpch_code_info_for_common_edch(
                &pdata->ul_DPCH_CodeInfoForCommonEDCH,
                &p_list->common_e_dch_resource_info_list[index].ul_dpch_code_info_for_common_edch);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_common_edch_system_info_fdd
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_CommonEDCHSystemInfoFDD to
 *      common_edch_system_info_fdd_t
 *
 *******************************************************************************/
void convert_common_edch_system_info_fdd
(
 UMTS_CommonEDCHSystemInfoFDD   *pvalue,
 common_edch_system_info_fdd_t  *p_fdd
 )
{
    if (pvalue->m.ul_InterferenceForCommonEDCHPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_COMMON_EDCH_SYSTEM_INFO_FDD_UL_INTERFERENCE_FOR_COMMON_EDCH_PRESENCE_FLAG;

        p_fdd->ul_interference_for_common_edch =
            pvalue->ul_InterferenceForCommonEDCH;
    }

    convert_common_e_dch_mac_d_flow_list(
            &pvalue->common_E_DCH_MAC_d_FlowList,
            &p_fdd->common_e_dch_mac_d_flow_list);

    convert_prach_preamble_for_enhanced_uplink(
            &pvalue->prach_PreambleForEnhancedUplink,
            &p_fdd->prach_preamble_for_enhanced_uplink);

    p_fdd->initial_serving_grant_value = pvalue->initialServingGrantValue;
    p_fdd->e_dch_tti = pvalue->e_dch_TTI;

    convert_e_agch_information(
            &pvalue->e_agch_Information,
            &p_fdd->e_agch_information);

    p_fdd->harq_info = pvalue->harq_Info;

    convert_ul_dpch_power_control_info_for_common_edch(
            &pvalue->ul_DPCHpowerControlInfoForCommonEDCH,
            &p_fdd->ul_dpch_power_control_info_for_common_edch);

    convert_e_dpcch_info_r7(
            &pvalue->e_dpcch_Info,
            &p_fdd->e_dpcch_info);

    convert_e_dpdch_info_r8(
            &pvalue->e_dpdch_Info,
            &p_fdd->e_dpdch_info);

    p_fdd->dl_fdpch_tpc_command_error_rate =
        pvalue->dl_FDPCH_TPCcommandErrorRate;

    p_fdd->additional_e_dch_transmit_backoff =
        pvalue->additional_E_DCH_TransmitBackoff;

    p_fdd->max_ccch_resource_allocation =
        pvalue->max_CCCH_ResourceAllocation;

    p_fdd->max_period_for_collision_resolution =
        pvalue->max_PeriodForCollisionResolution;

    p_fdd->e_dch_transmit_continuation_offset =
        pvalue->e_dch_TransmitContinuationOffset;

    p_fdd->ack_nack_support_on_hs_dpcch =
        pvalue->ack_nack_support_on_HS_DPCCH;

    if (pvalue->m.measurement_Feedback_InfoPresent)
    {
        p_fdd->presence_bitmask |=
            UMTS_SIB_COMMON_EDCH_SYSTEM_INFO_FDD_MEASUREMENT_FEEDBACK_INFO_PRESENCE_FLAG;

        convert_measurement_feedback_info_r7(
                &pvalue->measurement_Feedback_Info,
                &p_fdd->measurement_feedback_info);
    }

    convert_common_edch_system_info_fdd_common_e_dch_resource_info_list(
            &pvalue->common_E_DCH_ResourceInfoList,
            &p_fdd->common_e_dch_resource_info_list);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v8d0ext_ies
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v8d0ext_IEs to
 *      sysinfotype5_v8d0ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v8d0ext_ies
(
 UMTS_SysInfoType5_v8d0ext_IEs  *pvalue,
 sysinfotype5_v8d0ext_ies_t     *p_ies 
 )
{
    if (pvalue->m.commonEDCHSystemInfoFDDPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V8D0EXT_IES_COMMON_EDCH_SYSTEM_INFO_FDD_PRESENCE_FLAG;

        convert_common_edch_system_info_fdd(
                &pvalue->commonEDCHSystemInfoFDD,
                &p_ies->common_edch_system_info_fdd);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces_nces
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions_v890NonCriticalExtensions_v8b0NonCriticalExtensions_v8d0NonCriticalExtensions_nonCriticalExtensions to
 *      sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces_nces_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces_nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions_v890NonCriticalExtensions_v8b0NonCriticalExtensions_v8d0NonCriticalExtensions_nonCriticalExtensions    *pvalue,
 sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces_nces_t  *p_nce 
 )
{
    p_nce->__dummy__ = pvalue->__dummy__;

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions_v890NonCriticalExtensions_v8b0NonCriticalExtensions_v8d0NonCriticalExtensions to
 *      sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions_v890NonCriticalExtensions_v8b0NonCriticalExtensions_v8d0NonCriticalExtensions  *pvalue,
 sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces_t   *p_nces 
 )
{
    convert_sysinfotype5_v8d0ext_ies(
            &pvalue->sysInfoType5_v8d0ext,
            &p_nces->sysinfotype5_v8d0ext_ies);

    if (pvalue->m.nonCriticalExtensionsPresent)
    {
        p_nces->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V4B0NCES_V590NCES_V650NCES_V680NCES_V690NCES_V770NCES_V860NCES_V890NCES_V8B0NCES_V8D0NCES_NCES_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces_nces(
                &pvalue->nonCriticalExtensions,
                &p_nces->v8d0nces_nces);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions_v890NonCriticalExtensions_v8b0NonCriticalExtensions to
 *      sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions_v890NonCriticalExtensions_v8b0NonCriticalExtensions    *pvalue,
 sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_t    *p_nce 
 )
{
    convert_sysinfotype5_v8b0ext_ies(
            &pvalue->sysInfoType5_v8b0ext,
            &p_nce->sysinfotype5_v8b0ext_ies);

    if (pvalue->m.v8d0NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V4B0NCES_V590NCES_V650NCES_V680NCES_V690NCES_V770NCES_V860NCES_V890NCES_V8B0NCES_V8D0NCES_NCES_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces_v8d0nces(
                &pvalue->v8d0NonCriticalExtensions,
                &p_nce->v8d0nces);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions_v890NonCriticalExtensions to
 *      sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions_v890NonCriticalExtensions  *pvalue,
 sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_t *p_nce
 )
{
    convert_sysinfotype5_v890ext_ies(
            &pvalue->sysInfoType5_v890ext,
            &p_nce->sysinfotype5_v890ext);

    if (pvalue->m.v8b0NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_SYSINFOTYPE5_V4B0NCES_V590NCES_V650NCES_V680NCES_V690NCES_V770NCES_V860NCES_V890NCES_V8B0NONCRITICALEXTENSIONS_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces_v8b0nces(
                &pvalue->v8b0NonCriticalExtensions,
                &p_nce->v8b0NonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions to
 *      sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions_v860NonCriticalExtensions    *pvalue,
 sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_t  *p_nce 
 )
{
    convert_sysinfotype5_v860ext_ies(
            &pvalue->sysInfoType5_v860ext,
            &p_nce->sysInfoType5_v860ext);

    if (pvalue->m.v890NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0NCESS_V590NCES_V650NCES_V680NCES_V690NCES_V770NCES_V860NCES_890NCES_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces_v890nces(
                &pvalue->v890NonCriticalExtensions,
                &p_nce->v890nces);    
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0ncess_v590nces_v650nces_v680nces_v690nces_v770nces
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions to
 *      sysinfotype5_v4b0ncess_v590nces_v650nces_v680nces_v690nces_v770nces_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0ncess_v590nces_v650nces_v680nces_v690nces_v770nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions_v770NonCriticalExtensions       *pvalue,
 sysinfotype5_v4b0ncess_v590nces_v650nces_v680nces_v690nces_v770nces_t       *p_v770NonCriticalExtensions
 )
{
    convert_sysinfotype5_v770ext_ies(
            &pvalue->sysInfoType5_v770ext,
            &p_v770NonCriticalExtensions->sysInfoType5_v770ext);

    if(pvalue->m.v860NonCriticalExtensionsPresent)
    {
        p_v770NonCriticalExtensions->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0NCESS_V590NCES_V650NCES_V680NCES_V690NCES_V770NCES_V860NONCRITICALEXTENSIONS_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_v770nces_v860nces(
                &pvalue->v860NonCriticalExtensions,
                &p_v770NonCriticalExtensions->v860NonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions
 *      to sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_t 
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions_v690NonCriticalExtensions    *pvalue,
 sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces_t            *p_v690NonCriticalExtensions
 )
{
    convert_sysinfotype5_v690ext_ies(
            &pvalue->sysInfoType5_v690ext,
            &p_v690NonCriticalExtensions->sysInfoType5_v690ext);

    if(pvalue->m.v770NonCriticalExtensionsPresent)
    {
        p_v690NonCriticalExtensions->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0NCES_V590NCES_V650NCES_V680NCES_V690NCES_V770NCES_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0ncess_v590nces_v650nces_v680nces_v690nces_v770nces(
                &pvalue->v770NonCriticalExtensions,
                &p_v690NonCriticalExtensions->v770NonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions to
 *      sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions_v680NonCriticalExtensions  *pvalue,
 sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_t                                                                         *p_v680NonCriticalExtensions
 )
{
    if(pvalue->m.sysInfoType5_v680extPresent)
    {
        p_v680NonCriticalExtensions->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0NCES_V590NCES_V650NCES_V680NCES_V680EXT_PRESENCE_FLAG;

        convert_sysinfotype5_v680ext_ies(
                &pvalue->sysInfoType5_v680ext,
                &p_v680NonCriticalExtensions->sysinfotype5_v680ext);
    }

    if(pvalue->m.v690NonCriticalExtensionsPresent)
    {
        p_v680NonCriticalExtensions->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0NCES_V590NCES_V650NCES_V680NCES_V690NCES_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces_v690nces(
                &pvalue->v690NonCriticalExtensions,
                &p_v680NonCriticalExtensions->v690NonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_usch_transport_channels_info_element 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_USCH_TransportChannelsInfo_element to
 *      usch_transport_channels_info_element_t
 *
 *******************************************************************************/
void convert_usch_transport_channels_info_element
(
 UMTS_USCH_TransportChannelsInfo_element    *pvalue,
 usch_transport_channels_info_element_t     *p_element
 )
{
    p_element->usch_transport_channel_identity =
        pvalue->usch_TransportChannelIdentity;

    convert_transport_format_set(
            &pvalue->usch_TFS,
            &p_element->usch_tfs);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_usch_transport_channels_info 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_USCH_TransportChannelsInfo to
 *      usch_transport_channels_info_t
 *
 *******************************************************************************/
void convert_usch_transport_channels_info
(
 UMTS_USCH_TransportChannelsInfo    *pvalue,
 usch_transport_channels_info_t     *p_info 
 )
{
    UMTS_USCH_TransportChannelsInfo_element *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_USCH_TransportChannelsInfo_element*)pnode->data;

        convert_usch_transport_channels_info_element(
                pdata,
                &p_info->usch_transport_channels_info_element[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_hcr_r5 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfo_HCR_r5 to
 *      pusch_sys_info_hcr_r5_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_hcr_r5
(
 UMTS_PUSCH_SysInfo_HCR_r5      *pvalue,
 pusch_sys_info_hcr_r5_t        *p_r5 
 )
{
    p_r5->pusch_identity = pvalue->pusch_Identity;

    convert_pusch_info(
            &pvalue->pusch_Info,
            &p_r5->pusch_info);

    if (pvalue->m.usch_TransportChannelsInfoPresent)
    {
        p_r5->presence_bitmask |=
            UMTS_SIB_PUSCH_SYS_INFO_HCR_R5_USCH_TRANSPORT_CHANNELS_INFO_PRESENCE_FLAG;

        convert_usch_transport_channels_info(
                &pvalue->usch_TransportChannelsInfo,
                &p_r5->usch_transport_channels_info); 
    }

    if (pvalue->m.usch_TFCSPresent)
    {
        p_r5->presence_bitmask |=
            UMTS_SIB_PUSCH_SYS_INFO_HCR_R5_USCH_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->usch_TFCS,
                &p_r5->usch_tfcs);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_list_sfn_hcr_r5_element 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfoList_SFN_HCR_r5_element to
 *      pusch_sys_info_list_sfn_hcr_r5_element_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_list_sfn_hcr_r5_element
(
 UMTS_PUSCH_SysInfoList_SFN_HCR_r5_element  *pvalue,
 pusch_sys_info_list_sfn_hcr_r5_element_t   *p_element 
 )
{
    convert_pusch_sys_info_hcr_r5(
            &pvalue->pusch_SysInfo,
            &p_element->pusch_sysinfo);

    if (pvalue->m.sfn_TimeInfoPresent)
    {
        p_element->presence_bitmask |=
            UMTS_SIB_PUSCH_SYS_INFO_LIST_SFN_HCR_R5_ELEMENT_SFN_TIMEINFO_PRESENCE_FLAG;

        convert_sfn_time_info(
                &pvalue->sfn_TimeInfo,
                &p_element->sfn_timeinfo);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pusch_sys_info_list_sfn_hcr_r5 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PUSCH_SysInfoList_SFN_HCR_r5 to
 *      pusch_sys_info_list_sfn_hcr_r5_t
 *
 *******************************************************************************/
void convert_pusch_sys_info_list_sfn_hcr_r5
(
 UMTS_PUSCH_SysInfoList_SFN_HCR_r5  *pvalue,
 pusch_sys_info_list_sfn_hcr_r5_t   *p_r5 
 )
{
    UMTS_PUSCH_SysInfoList_SFN_HCR_r5_element   *pdata = NULL;
    OSRTDListNode                               *pnode = NULL;
    U32                                         index;

    pnode = pvalue->head;
    p_r5->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PUSCH_SysInfoList_SFN_HCR_r5_element*)pnode->data;

        convert_pusch_sys_info_list_sfn_hcr_r5_element(
                pdata,
                &p_r5->pusch_sys_info_list_sfn_hcr_r5_element[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dsch_transport_channels_info_element 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DSCH_TransportChannelsInfo_element to
 *      dsch_transport_channels_info_element_t
 *
 *******************************************************************************/
void convert_dsch_transport_channels_info_element
(
 UMTS_DSCH_TransportChannelsInfo_element    *pvalue,
 dsch_transport_channels_info_element_t     *p_element 
 )
{
    p_element->dsch_transport_channel_identity =
        pvalue->dsch_transport_channel_identity;

    convert_transport_format_set(
            &pvalue->dsch_TFS,
            &p_element->dsch_tfs);

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_dsch_transport_channels_info 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_DSCH_TransportChannelsInfo to
 *      dsch_transport_channels_info_t
 *
 *******************************************************************************/
void convert_dsch_transport_channels_info
(
 UMTS_DSCH_TransportChannelsInfo    *pvalue,
 dsch_transport_channels_info_t     *p_info 
 )
{
    UMTS_DSCH_TransportChannelsInfo_element *pdata = NULL;
    OSRTDListNode                           *pnode = NULL;
    U32                                     index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_DSCH_TransportChannelsInfo_element*)pnode->data;

        convert_dsch_transport_channels_info_element(
                pdata,
                &p_info->dsch_transport_channels_info_element[index]); 

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sys_info_hcr_r5 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_SysInfo_HCR_r5 to
 *      pdsch_sys_info_hcr_r5_t
 *
 *******************************************************************************/
void convert_pdsch_sys_info_hcr_r5
(
 UMTS_PDSCH_SysInfo_HCR_r5  *pvalue,
 pdsch_sys_info_hcr_r5_t    *p_info 
 )
{
    p_info->pdsch_identity = pvalue->pdsch_Identity;

    convert_pdsch_info(
            &pvalue->pdsch_Info,
            &p_info->pdsch_info);

    if (pvalue->m.dsch_TransportChannelsInfoPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PDSCH_SYS_INFO_HCR_R5_DSCH_TRANSPORTCHANNELSINFO_PRESENCE_FLAG;

        convert_dsch_transport_channels_info(
                &pvalue->dsch_TransportChannelsInfo,
                &p_info->dsch_transport_channels_info); 
    }

    if (pvalue->m.dsch_TFCSPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_PDSCH_SYS_INFO_HCR_R5_DSCH_TFCS_PRESENCE_FLAG;

        convert_tfcs(
                &pvalue->dsch_TFCS,
                &p_info->dsch_tfcs);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sys_info_list_sfn_hcr_r5_element 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_SysInfoList_SFN_HCR_r5_element to
 *      pdsch_sys_info_list_sfn_hcr_r5_element_t
 *
 *******************************************************************************/
void convert_pdsch_sys_info_list_sfn_hcr_r5_element
(
 UMTS_PDSCH_SysInfoList_SFN_HCR_r5_element  *pvalue,
 pdsch_sys_info_list_sfn_hcr_r5_element_t   *p_element 
 )
{
    convert_pdsch_sys_info_hcr_r5(
            &pvalue->pdsch_SysInfo,
            &p_element->pdsch_sys_info);

    if (pvalue->m.sfn_TimeInfoPresent)
    {
        p_element->presence_bitmask |=
            UMTS_SIB_PDSCH_SYS_INFO_LIST_SFN_HCR_R5_ELEMENT_SFN_TIMEINFO_PRESENCE_FLAG;

        convert_sfn_time_info(
                &pvalue->sfn_TimeInfo,
                &p_element->sfn_timeinfo);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_pdsch_sys_info_list_sfn_hcr_r5 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_PDSCH_SysInfoList_SFN_HCR_r5 to
 *      pdsch_sys_info_list_sfn_hcr_r5_t
 *
 *******************************************************************************/
void convert_pdsch_sys_info_list_sfn_hcr_r5
(
 UMTS_PDSCH_SysInfoList_SFN_HCR_r5  *pvalue,
 pdsch_sys_info_list_sfn_hcr_r5_t   *p_info 
 )
{
    UMTS_PDSCH_SysInfoList_SFN_HCR_r5_element   *pdata = NULL;
    OSRTDListNode                               *pnode = NULL;
    U32                                         index;

    pnode = pvalue->head;
    p_info->count = pvalue->count;

    for ( index = 0; index < pvalue->count; index++ )
    {
        pdata = (UMTS_PDSCH_SysInfoList_SFN_HCR_r5_element*)pnode->data;

        convert_pdsch_sys_info_list_sfn_hcr_r5_element(
                pdata,
                &p_info->pdsch_sys_info_list_sfn_hcr_r5_element[index]);

        pnode = pnode->next;
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v590ext_ies_hcr_r5_specific_info 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v590ext_IEs_hcr_r5_SpecificInfo to
 *      sysinfotype5_v590ext_ies_hcr_r5_specific_info_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v590ext_ies_hcr_r5_specific_info
(
 UMTS_SysInfoType5_v590ext_IEs_hcr_r5_SpecificInfo  *pvalue,
 sysinfotype5_v590ext_ies_hcr_r5_specific_info_t    *p_info 
 )
{
    if (pvalue->m.pusch_SysInfoList_SFNPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_V590EXT_IES_HCR_R5_PUSCH_SYS_INFO_LIST_SFN_PRESENCE_FLAG;

        convert_pusch_sys_info_list_sfn_hcr_r5(
                &pvalue->pusch_SysInfoList_SFN,
                &p_info->pusch_sys_info_list_sfn);
    }

    if (pvalue->m.pdsch_SysInfoList_SFNPresent)
    {
        p_info->presence_bitmask |=
            UMTS_SIB_TYPE_5_V590EXT_IES_HCR_R5_PDSCH_SYS_INFO_LIST_SFN_PRESENCE_FLAG;

        convert_pdsch_sys_info_list_sfn_hcr_r5(
                &pvalue->pdsch_SysInfoList_SFN,
                &p_info->pdsch_sys_info_list_sfn); 
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v590ext_ies 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v590ext_IEs to
 *      sysinfotype5_v590ext_ies_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v590ext_ies
(
 UMTS_SysInfoType5_v590ext_IEs  *pvalue,
 sysinfotype5_v590ext_ies_t     *p_ies
 )
{
    if (pvalue->m.hcr_r5_SpecificInfoPresent)
    {
        p_ies->presence_bitmask |=
            UMTS_SIB_TYPE_5_V590EXT_IES_HCR_R5_SPECIFICINFO_PRESENCE_FLAG;

        convert_sysinfotype5_v590ext_ies_hcr_r5_specific_info(
                &pvalue->hcr_r5_SpecificInfo,
                &p_ies->hcr_r5_specific_info);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME:sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions
 *
 *   DESCRIPTION:
 *      This function converts UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions to
 *      sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions_t and checks whether input
 *      data are valid.
 *
 *******************************************************************************/
void sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions 
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions   *pvalue,
 sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions_t      *p_v590NonCriticalExtensions
 )
{
    if(pvalue->m.sysInfoType5_v590extPresent)
    {
        p_v590NonCriticalExtensions->presence_bitmask |=
            UMTS_SIB_TYPE_5_V590EXT_PRESENCE_FLAG;

        convert_sysinfotype5_v590ext_ies(
                &pvalue->sysInfoType5_v590ext,
                &p_v590NonCriticalExtensions->sysInfoType5_v590ext);

    }

    if(pvalue->m.v650NonCriticalExtensionsPresent)
    {
        p_v590NonCriticalExtensions->presence_bitmask |=
            UMTS_SIB_TYPE_5_V650NONCRITICALEXTENSION_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces(
                &pvalue->v650NonCriticalExtensions,
                &p_v590NonCriticalExtensions->v650NonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0nces_v590nces_v650nces 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions to
 *      sysinfotype5_v4b0nces_v590nces_v650nces_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0nces_v590nces_v650nces
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions_v650NonCriticalExtensions    *pvalue,
 sysinfotype5_v4b0nces_v590nces_v650nces_t      *p_nce 
 )
{
    if(pvalue->m.sysInfoType5_v650extPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_5V4B0NCES_V590NCES_V650NCES_V650EXT_PRESENCE_FLAG;

        convert_sysinfotype5_v650ext_ies(
                &pvalue->sysInfoType5_v650ext,
                &p_nce->sysInfoType5_v650ext);
    }

    if(pvalue->m.v680NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_5V4B0NCES_V590NCES_V680NONCRITICALEXTENSIONS_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces_v680nces(
                &pvalue->v680NonCriticalExtensions,
                &p_nce->v680NonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions 
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions to
 *      sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions_v590NonCriticalExtensions      *pvalue,
 sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions_t         *p_nce
 )
{
    if(pvalue->m.sysInfoType5_v590extPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_5_V590EXT_PRESENCE_FLAG;

        convert_sysinfotype5_v590ext_ies(
                &pvalue->sysInfoType5_v590ext,
                &p_nce->sysInfoType5_v590ext);
    }

    if(pvalue->m.v650NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_5_V650NONCRITICALEXTENSION_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0nces_v590nces_v650nces(
                &pvalue->v650NonCriticalExtensions,
                &p_nce->v650NonCriticalExtensions);
    }

    return;
}

/******************************************************************************
 *   FUNCTION NAME: convert_sysinfotype5_v4b0_non_critical_extensions
 *
 *   DESCRIPTION:
 *      This function converts 
 *      UMTS_SysInfoType5_v4b0NonCriticalExtensions to
 *      sysinfotype5_v4b0_non_critical_extensions_t
 *
 *******************************************************************************/
void convert_sysinfotype5_v4b0_non_critical_extensions
(
 UMTS_SysInfoType5_v4b0NonCriticalExtensions    *pvalue,
 sysinfotype5_v4b0_non_critical_extensions_t    *p_nce 
 )
{
    if(pvalue->m.sysInfoType5_v4b0extPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_5_V4B0EXT_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0ext_ies(
                &pvalue->sysInfoType5_v4b0ext,
                &p_nce->sysInfoType5_v4b0ext);
    }

    if (pvalue->m.v590NonCriticalExtensionsPresent)
    {
        p_nce->presence_bitmask |=
            UMTS_SIB_TYPE_5_V590NCE_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0noncriticalextensions_v590noncriticalextensions(
                &pvalue->v590NonCriticalExtensions,
                &p_nce->v590NonCriticalExtensions);
    }

    return;
}


/******************************************************************************
 *   FUNCTION NAME: umts_convert_sib5
 *
 *   DESCRIPTION:
 *       This function converts UMTS_SysInfoType5 to
 *       umts_sib_type_5_info_t and checks if input data are valid.
 *
 *   INPUT:
 *       umts_sib_type_5_info   - Pointer to decoded SIB5
 *
 *   RETURNS:
 *       SUCCESS - if all data are valid
 *       FAILURE - if data are invalid or if there are not enough memory
 *
 *******************************************************************************/
return_code umts_convert_sib5
(
 umts_sib_type_5_info_t  *umts_sib_type_5_info
 )
{
    UMTS_SysInfoType5   sys_info_type_5;
    OSCTXT  ctxt;

    memset(&ctxt,0x00, sizeof(OSCTXT));

    if (rtInitContext (&ctxt) != 0)
    {
        printf("ASN context initialisation failed \n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }

    pu_setBuffer (&ctxt, g_umts_ctxt.bch_info[UMTS_SIB_TYPE_5_INFO].p_start_bch_data, 
            MAX_ASN_ENCODED_MSG_SIZE, FALSE);

    memset(&sys_info_type_5, 0, sizeof(UMTS_SysInfoType5));

    if (0 != (asn1PD_UMTS_SysInfoType5(&ctxt, &sys_info_type_5)))
    {
        printf("umts_convert_sib5:asn decoding failed\n");
        rtFreeContext(&ctxt);
        return FAILURE;
    }
    asn1Print_UMTS_SysInfoType5("Decoded SysInfoType5\n", &sys_info_type_5);
    memset(umts_sib_type_5_info, 0, sizeof(umts_sib_type_5_info_t));

    umts_sib_type_5_info->sib_6_indicator = sys_info_type_5.sib6indicator;
    umts_sib_type_5_info->pich_poweroffset = sys_info_type_5.pich_PowerOffset;

    /* SysInfoType5_modeSpecificInfo */
    convert_sib_type_5_mode_specific_info(
            &sys_info_type_5.modeSpecificInfo,
            &umts_sib_type_5_info->modespecific_info);

    /* PrimaryCCPCH_Info */
    if (sys_info_type_5.m.primaryCCPCH_InfoPresent)
    {
        umts_sib_type_5_info->presence_bitmask |= UMTS_SIB_TYPE_5_INFO_PRIMARY_CCPCH_INFO_PRESENCE_FLAG;

        convert_primary_ccpch_info(
                &sys_info_type_5.primaryCCPCH_Info,
                &umts_sib_type_5_info->primary_ccpch_info);
    }

    /* PRACH_SystemInformationList */
    convert_prach_system_information_list(
            &sys_info_type_5.prach_SystemInformationList, 
            &umts_sib_type_5_info->prach_systemInformation_list);

    /* UMTS_SCCPCH_SystemInformationList */
    convert_sccpch_system_information_list(
            &sys_info_type_5.sCCPCH_SystemInformationList, 
            &umts_sib_type_5_info->sccpch_systemInformation_list);

    /* CBS_DRX_Level1Information */
    if (sys_info_type_5.m.cbs_DRX_Level1InformationPresent)
    {
        umts_sib_type_5_info->presence_bitmask |= UMTS_SIB_TYPE_5_INFO_CBS_DRX_LEVEL1_INFO_PRESENCE_FLAG;

        convert_cbs_drx_level1_information(
                &sys_info_type_5.cbs_DRX_Level1Information,
                &umts_sib_type_5_info->cbs_DRX_level1_information); 
    }

    /* V4B0_NON_CRITICAL_EXTENSIONS */
    if (sys_info_type_5.m.v4b0NonCriticalExtensionsPresent)
    {
        umts_sib_type_5_info->presence_bitmask |= 
            UMTS_SIB_TYPE_5_INFO_V4B0_NON_CRITICAL_EXTNS_PRESENCE_FLAG;

        convert_sysinfotype5_v4b0_non_critical_extensions(
                &sys_info_type_5.v4b0NonCriticalExtensions,
                &umts_sib_type_5_info->v4b0_Non_Critical_Extensions);
    }

    rtFreeContext(&ctxt);
    return SUCCESS;
}
